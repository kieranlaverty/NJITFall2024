{"docstore/metadata": {"82e8e78e-1466-4020-b2d4-4d7a0239afd5": {"doc_hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b"}, "50c1b7ec-25fb-470b-a31c-4b05756df829": {"doc_hash": "0a121b811bd97a6e844d7fbfd02be54a64e65ef5d87c6f5543700f1f6ead8d3e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "4ed79338-a2a3-4f67-bc96-7e2155338c75": {"doc_hash": "6a87cb0834af522e52abd9af40472900be6e4872d8a341aa05cd5132908744a1", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c5882dac-ebd5-4da5-957f-7649a9446182": {"doc_hash": "66480094b0d52c0ee14dcde94f41b8d399550989ed0a73644fa5f0df69fcd744", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "6412964f-4a1b-42ff-995a-cdd78f115370": {"doc_hash": "106197fc66fcc86c0f9e918165fe1ecf2819cad5ff89db9a2c2b4ffa590069aa", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "6475d4dc-319f-4399-8bd3-ca51d9b603c9": {"doc_hash": "e28d97ab4207de47b689cf741f1731b429e5c46035aabda6b5adb827245fdd69", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b9597f06-568e-42d1-aa55-7b2bc77ea3ba": {"doc_hash": "4fb662c9b1292c95a7309c3400901c9865c96388341b8497653ff6a710a36e5e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "28d5e5ca-c507-4ef1-86d4-19b8b648404b": {"doc_hash": "48e8201a01ba47dbbf4649ed8865e9d300dbb9e21befd22023cc65ce134edac7", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "aa00d208-7795-4c59-9460-061cd07cfa76": {"doc_hash": "9b3784a67f30b6147ae80e7c8025f436280be0e5b92c645bc9fdf63ee052482c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "46c78bf2-500c-429f-9bd0-ed4ceb894a89": {"doc_hash": "235da3bacedc54432a8c208afd8ad493bc9dfa9656a50123655dbea277b12514", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "aa39f7c1-f5da-4dae-8033-1a5f49e94b47": {"doc_hash": "999380b4b243b5c0e4c9820fe7c14100bf04d7766b3e9ae8124848aa22dfbd03", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e53e8d83-27b4-458e-b6d4-7fe075f7aff8": {"doc_hash": "7520f530c00c6987c594a23e0619f98222811ae7d3545a766e7f5af34d8963ea", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "5df950dc-1329-403a-b7f7-13e1e8880ee4": {"doc_hash": "5ef8625cb504e07f38b70049d18ecb7e09027c782b843d392b67cabaa13ba7d8", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ff4ffe15-fb0f-44fb-a002-54a16e1a5b1f": {"doc_hash": "e1ec660aebdc2d7f4ec3ed274555e53111e4eee49448066eba6f1c305ed4e9c3", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0b338cb1-20e5-433b-a0da-58f00e3fb91c": {"doc_hash": "c2affa291b61e970779a3c1137e01b84f474525499a56cec91cf16eab696c3d0", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fd54ecda-fa15-4467-b87f-8cafe7ea8434": {"doc_hash": "cb17104eec8844b925d8460b2aa2ea15bac0b50d8ad687f96d62992df6d51129", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "257d7b50-3303-4dcd-8b76-5c502bf9664f": {"doc_hash": "0cd7e861ee423d4fb35418796a6d664504a62d25244d8caf9d7c412681b9a0a0", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d5b9712c-1dc8-401a-85fa-e65b88f9b380": {"doc_hash": "c61db6f21f7ad1c40f83fef64fb726b80193931b6d1fe4afb83e13f0bc3d239f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "00fb73c4-71ce-4a64-af5d-a8c10f6f2241": {"doc_hash": "bbb90fad6b9f1bbc21080da0e86e0a8a5ec468057b0870c126fe67a0c85195e5", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a4d7efef-f070-43d5-ad09-30fdefef852e": {"doc_hash": "edaecb3dbc44db6f24f28150b98273dd9d8c1d70fe8288e4fa787965640aa730", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "373a6d13-c0eb-423b-b059-336b73998d0f": {"doc_hash": "1c1748cd440808ff51f8e1b7f9e2664f65345ab07aacfe4ba1658923ac5b1455", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "5f934c3b-5adf-4c34-bde5-8ceedee0b6e1": {"doc_hash": "e06df89410cb6754713e166e778eac8ed6545a5a4506752ad785af57560a5596", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "f9ed79d9-1e81-4faa-bb89-5d75c5994da8": {"doc_hash": "bf860a5f5479527dff84696752d1e1f0a63807de4fbe5d644dd37a1685325ee4", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fc246ea3-adfa-4cd0-87b9-ab0de35a9473": {"doc_hash": "562dabd2e726ab25a8e21362969c441f1257c8565e65b5f53e53d6269205c232", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "041f8e3f-4237-43e5-8c1f-24e63629d5ff": {"doc_hash": "1793c32cdcfabe8dddbe5de723203a08d0ad3f1046510fd90d694b647df61ff9", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "dd131950-5133-48b8-88c1-c7ce3f4ce169": {"doc_hash": "c873005fedd29789486a0910956c2d0e7679505193482c38a63d104e6c7ddc36", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3a8acb83-750b-4acb-ad79-7aaf220d0c05": {"doc_hash": "6ac6bbf9e7895c69bab187451dfba0967cfa15f094a14d004772ae52b0ba6476", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "253f1368-47e0-49e0-a656-9956fc8afd02": {"doc_hash": "e26cd69ca34442385a8efc423ff5861f4892c389542c63984f0d7765a52f95a4", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "da1cd37e-4718-44a8-ae01-7a57c62705f7": {"doc_hash": "fd61bab7e12ba1a2e101e1f446d3f823f3c19d570ccb01e7569bbfc673b0cf97", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "8eb7fe94-1be2-4977-be3e-df3298bf41c6": {"doc_hash": "2bac018de88f402f28062aa312a0c494b96ea71684888443aef64daa553e69b0", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "f83842ef-d454-437b-afaf-2696b2f55951": {"doc_hash": "8cd1fb952a30317bdd5ff3c4b6ef39fc9f2147a52c3ff7db87e3251cea8eba1b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "5650e9e1-956f-42d4-a3d9-1095b397ac43": {"doc_hash": "4e0ea0d5ac6fd0bcb2c40a7a93d7d6c9045d583a1ba65580b923ee122062ad04", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "99e849d5-d340-4d42-b89f-5f84376e0d7c": {"doc_hash": "0b62450cd4ca717f3f0fc8bcbe43a8ea24487a9206437109c8a120bb2feaf6a8", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7c2c4e2a-f042-493c-91fc-d0efbdf97db3": {"doc_hash": "96a3a08ae95c3044ba9e9de0da6dcc9d45d6d575c340f162c0ad88d911b1eb5b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "71710e7d-9be5-4554-9e47-5236c50c1ef5": {"doc_hash": "2b203b57da249d1646867cba7d95f87fb38ea32cba437a57b0d31a917605a173", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ace4dc8e-23a8-427d-8a5d-706f0740563f": {"doc_hash": "3c61c071a40819d124e285a84a04102c5716bc3c73883733da65a3a1b5f7592b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "45832d34-5ac9-49ed-892b-112e826b24c8": {"doc_hash": "c15a934b41b289dfad01800b976ee582603c3f9bb3a9e2377da24aab871bfe4c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "58881db4-4581-42dc-98d8-e64fdbb22d9d": {"doc_hash": "4e4ebdf7f9c2fcb35f6dbad151421441bed09484655aacdb6aa9d41fc4c7ba8a", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b170fe60-9304-4479-8103-ae20816a6412": {"doc_hash": "fb1ff10b3c703b6abfea6831872aa9b7ebb1a06344a56074703b94db13e69935", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "724185fd-5d85-4139-8e1f-c15d8b64ab7f": {"doc_hash": "44c78458908822247d6ca618f97c54e9b646fe819ccc11eed272bf64ef4918a9", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "36708a62-8036-4f63-830e-bfddbc8fff5f": {"doc_hash": "bce3df175f4d7834ac6c06e63d1a367fbf08dc132c495af5ee1a99b04de808d2", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "48ab4063-7c85-420e-88ae-44771decc928": {"doc_hash": "f078457b86aea1acdf3e93545a3467aa845a34bbaee88fb9e970dda9c20d9a35", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "938a69f6-cbc8-43ab-96da-9caccd7c8b67": {"doc_hash": "25d59c5ca0b9f70be4104a3323f5f8b510059fee335133c4c0ce8332cfe5aa78", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "cebcef18-11ab-475f-b374-f0ee85ba83e2": {"doc_hash": "1f77b58aadfcfd683d664ee2be707dfe04861bb31632939ccb42c808a1eb444d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "94a2897e-06c3-4be4-a13a-b2a8b234fd9e": {"doc_hash": "afa49af4ae49d81f6bb1898e5012e95981b3938a5d7cbb89dd5a0d1e2df5ce44", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "dc43f26d-c5dc-48c4-b73b-776e0c110b8d": {"doc_hash": "5721032b452ddc43b093afd03cae99bc1779ef2e2c114667547fec94602f9e65", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "35066ca7-4c6f-41f4-bb48-e280725af122": {"doc_hash": "626c63ee410fa97282091dfff0d3d83d9b147f20639a73c2817aac64c341acfd", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ec4fefb6-1e2b-4cf0-8874-1fee3189dceb": {"doc_hash": "adff759b790dc762b2f8fa8242fbd13ae911bb29f54d362063d42e399a1ba348", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "f4debcd1-bd94-4084-b443-ded515ce04f3": {"doc_hash": "8170c90d8fb52945df35df42828d65f2553191acc9eac0dca2ee84c14127c4be", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7fa36e60-dbdd-4379-b971-a0fded704532": {"doc_hash": "1e9ec069d049495ee3ab8ab9898c20a367c8b198909e21424cb1a47cc65c4a04", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3bb0d24c-efcf-470c-adf0-1e6ce405700e": {"doc_hash": "3999a47eba0cad5fc60f851e3aa46d937a2f678391bc57274554a58777d9a676", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9f2e6dee-6479-415e-aa75-334f636a70be": {"doc_hash": "a7cdc5cbcbdf250276d705e30d8c9451cf31a41c3a1cbe11025f0a99b6ffc44f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3827d73a-050e-48c8-8d6d-769c4eb3d3e2": {"doc_hash": "14ed7c299676f20339e4ebf1b0042b7e8e4ba13b4ca2177c6212da80b5c0c2c9", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3bc53aec-8718-4602-8867-c0da06fa9983": {"doc_hash": "f114762da2f7fc59d9df03640da8cd0f08b8cd918bb6fb5150537f165a370530", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3a4de07a-ccaa-45f7-aa03-418c440a33db": {"doc_hash": "11b2fe939760b1aae78d1c83d134d44fe934a170d6b8ec87cdf4ad0a2657c119", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "f2988966-9c4c-4f36-9432-b96b682fe6f8": {"doc_hash": "b45ed1ba793d65fb487083d675fde12f34ed18cfbe465829256398f4c70c14bb", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ae7b1e93-c6fb-43f4-b3ba-a6c49b57a605": {"doc_hash": "5d8abe219a6cc5e2653dc0bf952f39f6464d94438d8a39db00518483fa56ccab", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "124b1e89-33e5-4d81-95d0-0513f3d50fbb": {"doc_hash": "53b572cee9d57841c5ea697eba185089881b1209eecb9ced6ffc681d2319f8e0", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "4eeaaa35-36cc-4ec0-ac2a-03018d6d7bc3": {"doc_hash": "0606cb13819ce21195d7ab71baffb38396718113a57af6196c4b62fdeebff16e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d74c16b8-15fc-4581-8c33-2934279a3a25": {"doc_hash": "8d6e51d3819c1352b0c6d23a4801ac95d23267351e472fdc0fa583d305af47de", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "55fbb0ce-02a9-4ce1-89c2-48471a993397": {"doc_hash": "9395a1c84e5a15999cc063886f790747b7f913c5ad3c23a06235399946955d22", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fc7a684b-0813-46f7-be9f-79faba003a3b": {"doc_hash": "5bb9a257476997e938f7d033934cf283f5c7573a7b5aa9a063540dec8d52936f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e961a397-16d3-4818-8b98-1ce8a69b568d": {"doc_hash": "d364e2b85868ef9e4a258f7e3a69ce815154a2b3d4d18146eeefd81a4634784d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "306550e1-7ddf-4a29-975f-3484eef50f6a": {"doc_hash": "47ecd901957b6561925879b63b6add361fd774acae0b38cdd99d5204857f3cc5", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "316721c3-b326-431b-a332-9d1da418ee75": {"doc_hash": "28ed963698f4c5e99ac649c2094683d859f800565d7ed39aee39b4cfc77750e2", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "cde99be9-3e82-46ec-9f6a-0a27bc6811af": {"doc_hash": "2426f94cbaf81b6747c20bc02b950038a2ab1c53a142121437d414a508f86999", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1b0698fe-d177-4e69-be70-ed13b8bfe470": {"doc_hash": "6e5d9cd55f83237b620d7295b1267a661a11dcae6ac730ec98650880a6561e80", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fa9879be-6fb3-4228-a95f-ad6b089adc3d": {"doc_hash": "1778bd02d0bcf0a7cb47a4cb6649b6e0b9d7860688b3d0734f288bd4b9b5e89e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7b8794e7-ecc4-4647-b9f1-c3fa2b813a45": {"doc_hash": "47b9c0adb269e9d086c719a1893601c4036a792c40714ec227d61ec1729bbbea", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "6922a4f6-c044-428f-9dd1-585ecabf18fd": {"doc_hash": "b71dc41a3c876e35de39e4d93de7e2c4f152611f50041455bb587b592c73d338", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e79670ed-9b31-4781-b8eb-f151aa3b5930": {"doc_hash": "b286aef6543137bf1db979d4c9a660145ee2007391e6b71e21b0e7c0c24262b0", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "f46655c2-ca05-46e2-ad04-1ab74fde8d60": {"doc_hash": "0ab27203901daee8c56c3636cba481436eb9648485e8d1a5c6c0a146c1de9cd4", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1c190347-aaeb-48ad-99c3-a88551674f17": {"doc_hash": "79d2d27e650d5efe1a0d45776dee355b548f12fc176258ef24119d88d958eb3c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e501b0d0-616c-48d3-87f6-fe53165a682c": {"doc_hash": "f935c4770aad57955f4777f51a3b87c8bcc8f04f7823d211a63f5b18295f2dbe", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c26cff40-8464-4055-b45f-9244e5378bb2": {"doc_hash": "2d1b3fa4e7bc0820507d198ee5f8da9f4dc3032a95bd7bdec40fa6fa5d844b64", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "08a42b27-547d-43fe-9b39-3d5c810c3fa2": {"doc_hash": "9c4160fef1983eb4fd432815eb6abbf775e2a22d49f40ccb0d193b77c2c2defe", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "23da883a-4603-46ce-b19d-cc43b4a02543": {"doc_hash": "9aae21802aaec26153f78de350205ee1a08f642939a5b3831c4517dcd593f6be", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "4dfa06ed-5258-4af2-9845-6f8d123589fe": {"doc_hash": "989941d7fa2bd1e12af92f1cca6607ec132c2c390b1fb007413b65d485e7af69", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "6eb8cf36-f29a-42ad-abb9-0c3b5cda754e": {"doc_hash": "4afe30098e1e1e5337829322aad566e15a79d445d6bed1f836c8743341680739", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d4ebb515-bfd4-4f08-94a5-82f44de014e6": {"doc_hash": "4edce542555cce1908b8c862fa35f3781358feb4a3975708b8e1602c20033850", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d2e153a2-c8e3-441b-93f7-bfc9e13c8709": {"doc_hash": "e50a99b0478fbee0b980b137c0e2452bbcf63e4eba00d6aa421d7e083290b374", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "13a78da8-74de-487a-9504-38a9711b41e0": {"doc_hash": "1e8f674c226257b71b6d860d8f304c081889e879b80b99499bb0a96e0b03b1e1", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "924a08d5-8997-47c3-906c-754af4429b33": {"doc_hash": "5ef5f874b1070688a0efdbc16cc14e280253de2d3548b6bf4764a54740357d34", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3c09aac6-94c6-4437-ad0b-de84ce020bc3": {"doc_hash": "52119cc83628d279623e0aa98263f41ebd59b0cc635e7f729883cda7cca2f888", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "68c1efb8-1656-4606-887a-d6c7379334f6": {"doc_hash": "5975596644d4fa23c9cd29b7fbfd44439b34d59f67c0a3bfd09177b1fecfff77", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "f31c5c66-bb37-40b3-81b0-9843fa657cb7": {"doc_hash": "df6d2e5d03e34c69292e25903cef7a2916aca593a5880640d0a880a136245fb0", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "61147081-a760-4e59-918d-5c4e1c1b9cc0": {"doc_hash": "add69deb9abee7b6a6d57b2c3f298b80e237e0f6f6be590405d13d143f514c97", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "41ad2588-e366-4c0c-ba1f-0461e147a213": {"doc_hash": "b2f177fa015213f3504ecb120e065d38ea528ccdee2b2d9161eeff2512334d02", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a13f254e-a1c0-40b3-9b27-f5f6148ea669": {"doc_hash": "8e9df907fd2214e4beddc5af7ac6e70d0ea686bb46655f860c5d8af169300bd3", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "63d7b5e1-45ec-47be-aa2c-371e4271c32c": {"doc_hash": "30f3dfa3c4922ddcaf5586d175259be816fc60a923836b482df4a6d1d5b3d5f2", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "12d94253-e077-472b-b9c3-37aa97cf3a38": {"doc_hash": "e1c35be37b9e48c83d740dbc7656bdb5ee8dbde3e9781305778f5d2400dfdf38", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3f42be62-1814-4568-a4bc-864cd9b2dddf": {"doc_hash": "026e5e8574144f21f0896c8f7e4b7609262d264f4f32b6e5c519fe328704b658", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "4b93aa5b-0b03-4055-ab37-196da4583e07": {"doc_hash": "c9d6c1ff9c97a3050413d01ab81b34f1a115e52d1dce9d10a290595ea653206a", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "62d58b0d-3c60-484d-a53a-793f9088281f": {"doc_hash": "e8068031a766ef0bc48a05d47fbc6cbcba928d21a9ba1473b86410dd192ff8bb", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "abdcc70f-33c9-427c-8f4d-9421055320a8": {"doc_hash": "cd875a763504ed9c839cadbf9c0c6c51d682670eef4f43f01f92f8f7d856b376", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "133a8355-0e86-440b-a84a-31ce094f22c1": {"doc_hash": "71cd2eaa2548b501285c401445a0e9db1468ff911c401edb34e46ccc0c7aa0fc", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "be94ea1d-dbd3-40b0-8921-9dbadb91824b": {"doc_hash": "16b8246519d0b4f159d9e11ecb87a49a04556763e39d0db5856c3a498fbd4011", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c4bfdcca-0b4a-4865-8c87-fba0e37fb362": {"doc_hash": "e5d50f553a3249e127a42f0a431a1c0ad056559c1fbead67d0434932b4c81ada", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "968c65ba-7cd0-453e-875f-cafea63b76dc": {"doc_hash": "ee58087a57e7e31aa4752a2e408ca7adef2ed15591e7d5fb858207f8ea756fe1", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "127f89c2-677e-486c-9518-de26b67e2fb9": {"doc_hash": "7fa850f6eda41c3401b27bd7759e07a102fb2fbf4bdd4783c1e16021dde11a28", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2feeafb8-ad81-40a1-87ea-1e24efd44817": {"doc_hash": "0745b9c52263d2f154153a50c125b6acaa39191f1e64575af0730030dbe72d91", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0b1e5549-963d-40bb-9d44-fdcf58581701": {"doc_hash": "41029ac0d7b68353feee8cf246abf8ef9ff51d09c6e20a0e8bed6a8eb30831bd", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0c85c528-bb94-4028-b1cd-16fcf24cb567": {"doc_hash": "d17b35735d543011957704ea6cf3575237de3f787d65a71ee0ea66066e7d21b4", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "196e93bf-5a6c-49cd-8ac5-397df9f380c2": {"doc_hash": "5250a8c81fbad558ceffbd2f0c01dece2f602e70894faef445480060b57fc6d5", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "cec537db-a0d2-428d-a719-531d5e784101": {"doc_hash": "773893593acccd4af056a6f41f1f0375afb69051fe81558549c3cbdbec19d4cb", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "62803096-4e40-4a71-b06a-a0477fe04661": {"doc_hash": "2306aea7edcd9f6e5b585ded59b4104aafb3c214e56f7e9fac87c222679db88b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "811d4bc4-e353-42ee-b491-f04f65640a46": {"doc_hash": "c54c2eed02ee8af5084b161fbd8fc341cb8454b2cd8303a05281f572bcbddb43", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "28742bc0-8105-4e78-a6b2-1c6d6d5e5e8f": {"doc_hash": "39149c2b49a81ee591969b0ab56f2a379633b35ab50066547b2045a98da57628", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a4651b7e-529a-4afa-ad0e-919646a806d7": {"doc_hash": "e170a058826884675177f8781e8985b3882a34c37999c9c8269c3910246af5c2", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a02493ac-e77c-4847-95ce-13836be165e7": {"doc_hash": "f1042b0240b3af1dab788e32acb5f573a45a9e1c455c45b994dedf9536f124e2", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "190f683a-e61c-4d61-a127-1057b8d5f9ab": {"doc_hash": "390401396e344d2039d92e288e96e0fca140f19c3ea57879244f473c4f130c01", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3b0e344d-e122-4fc3-9c59-a92fd47539c9": {"doc_hash": "78f45731cf73acafba322f212f63f1a57b60a0cc1ffd7cdffc954d1172c51d46", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7c22e814-135e-47d3-9f88-74f42f2f2c47": {"doc_hash": "dccff960361a512e34105c549bd7048bce09dc4523f3e59e9dd5980f57ea8cb7", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "06bf9afa-d5f5-43e3-b4fa-b2caec574e43": {"doc_hash": "0c45821d59fb68def9abeee00dcb34a2c23836464b6d6c4186a0ca9b2e87378e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "521ae863-11c5-414e-83ea-61acb4de6393": {"doc_hash": "4d04d9601ae5ad4884804fe7bea95d99f79f43e24009a255379324a945cbac54", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b21228bc-4516-406a-a004-ecbc82b1dd31": {"doc_hash": "d411c0a7b1404dc0614abef862492f609bcc46d67876dd0b5ac1e5847bc92ad2", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2e61a564-ff85-4386-86a0-5c5f76482752": {"doc_hash": "26d26365daac065693451b26bfbe03b96dcaba3ed9f0fea09503032d28547c9b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7850297b-a989-4039-a16e-2225725936e6": {"doc_hash": "52e1cc9bb32f4a78e0a637207cb8b1fbcf7b5bd30039240607eda6013b4633a5", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9603abc4-b73c-47f7-97ab-ea8e6fe06ce2": {"doc_hash": "728d6c1ee8612e1be58945a2131991bfd256749e11535266782d1461620ea344", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "f9bbc849-6673-4f2a-877d-64eb24231f9c": {"doc_hash": "b4d420ce1b0770237c3724dbd6c9c2e7d718bd043aab34dbe17489422209fb03", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0a750766-c41a-482f-bf7f-7c0474edae91": {"doc_hash": "dd4a9186a5b3f3e873053dc6877ded926511f702aeebf6464a327c3329bbf593", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "652d991d-170b-4da8-a6c9-8038457422e8": {"doc_hash": "8df4e42ead4862000a595ae282fd306d2e2fdad8d666a99ce0dc1c291e7327db", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "10254a26-55c2-499f-a709-ec450303e992": {"doc_hash": "46a5fdbfb3d0092080ef167e428e33364c644b00f0fb8906a0e1638647512386", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "6d7dfe58-0728-43ba-a282-ed63a7e36735": {"doc_hash": "78f30334644b4c7a7ce18e8c5a3bd8fdef7ac9345da0fb7c2db64ac365d2725c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "030d18ef-2e41-4113-abf5-5e4a1f3eb6ea": {"doc_hash": "44923356bc7d396d343bc836641c2bd603379aca6a1388ebb09ee17a229958cd", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d3742376-9ef0-43c6-8fa8-126333c1d06a": {"doc_hash": "37f9a89c46baad80bcd6597696c25cb1c4a559fcd4e205c36745319a635871f0", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "83738921-b5f1-4c2b-8bcc-9a8562e31053": {"doc_hash": "27877725af25791be4757636de3cd0dce6f18cf23ec94158a004d9f1e01c476b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d85e9b53-ca93-4db8-9c45-37496b153e50": {"doc_hash": "4e4de1a451f45510feb7dba29db6d8a445d02e17a11d6086cc3945763f7cd3a4", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fe108d59-2465-4bea-a890-61b6ff6585b8": {"doc_hash": "8af7724357677147cc8941e1cdf8a4f2f6bf2f26d52f83e29bae9f9994cee0d3", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7d6fbfb3-3d5b-4b06-a506-fff0aed113e7": {"doc_hash": "78e8700e729678aff49aea0b02d87f819765422367968299907c7a728313f834", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "bc7569da-4df3-4295-8e16-c6936efa5ed8": {"doc_hash": "95bcdcbfd3005fbb83355f6a73126d1769330d546106e6db6ea076b3af1deb8b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "73bf6874-0f20-4875-accd-a3ff3ff54539": {"doc_hash": "56c87096ca8d0d8b52bab9e1f1751af5df94b6b2b5964f0824a3439e2b0bf9a0", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "bc78bc95-5add-48f9-ada8-d124be5d884f": {"doc_hash": "5ce8f4ae5e04aa5845b92c5fcfaf4ae096df65fb0366407613e207566ce62dff", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1c7c6c78-732b-44ed-b5e0-006632d5c729": {"doc_hash": "5d49a230a2992224c7a0b410896ede40075db70b12196c5906a8db1e0a56091b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1d8f84d6-6553-40f1-9a71-5a321f0f4eab": {"doc_hash": "deac98032a1720af88dfb3eaa73e1e5c5ab7f4aff9ddfba98bcdf492a2eede79", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2ca2f478-f27b-409f-a44e-c2c7e6bde926": {"doc_hash": "347b757b13e60edb9bee8cb4e4a9fc162e50cd00f32c9d93dee1f1049ca330c0", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "dd1469cf-8d89-4c10-b5ac-fff709b77fa1": {"doc_hash": "d4fa128fae1c13dc6dde91ed2121193e3d8796ace5ad92f0fde32158bc4af9cd", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d4cc47cb-217c-4d71-ae5e-42f74e1fe281": {"doc_hash": "1d0c629420cc491a7054b9b280d14770dbf174efd012d34854dd7837ac603669", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7d9a124d-5c1e-48c7-8698-5f2ddc4386a8": {"doc_hash": "da9e923afd42a2e6c37ca4b6de8072a69b8e119885a972873560533f650e7d0d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "5b36484a-ac86-4c34-8ee1-792a3e784c5c": {"doc_hash": "c892888855e4b4c7aba07a815ac0e483b480c34d12c8968072ba34d71e7721c2", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "91e1ea5b-a0ea-49bc-b9e7-5ff96fe451a4": {"doc_hash": "d24b9426c3667c7ef8915fa19a540e886bde28fdf68a7fafda3f026c82b8d4f7", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "65d007b3-7b80-4d05-9983-e4ed6e9431dd": {"doc_hash": "62c6e8e832b3c5025cd3a86ed5011cb4911d939374c3a4c4af9e594a4da2072d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a557c721-a73a-40a0-9599-4e5ae44f26f9": {"doc_hash": "bfa83bc6a69c886932989a6f4b6d94907865e633226d7b400cae55fe5036f8c5", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "47eb288e-8199-4459-b13e-07115c044be8": {"doc_hash": "314d89929de012bd0519962964f32c44f2ee029ba9e3efd8b78b34ca45ccf018", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9603a88f-476c-4920-81d6-3a884142cd88": {"doc_hash": "63cc6e77a1a753240e2165599f0014ee73b49598264d09e5302a8815f0929c26", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c01c977f-bd47-4ca6-a32a-f3eb3b608a7d": {"doc_hash": "04cf76486f651ac4b96e88a804ed32c46eeae18b8bfcf447cba0752d8edd453d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e76e09cd-e8e0-404a-b37b-3af88b692632": {"doc_hash": "dfe1a20fb2d132fc7c1b51d30fcc2e9a992e3a0a672ed1ed69207486e9cae13c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9cb8a305-a433-47c5-b154-30bf23c973c0": {"doc_hash": "972bfd1b22e77822f1228d5bd54239253152342371b7b95421e3177cff67631c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1a5c4e0f-33ae-41a1-8356-d09cf4d65000": {"doc_hash": "39797076f98cb12beee9c8416ddaec49d4d243b47bf74c7c05ba71791c22303e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d4473a1d-7cd1-4c8d-b261-cd482db417fa": {"doc_hash": "21cb816fa6763a09bf117b9eb09834223aa7ae523789b4137c063a06a84dd413", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "46041e36-7a56-47d3-ab2c-abbbf8494045": {"doc_hash": "4a35b441347d063e15f81377affa983e7e1cac99259df9c04c21a942c0646e3b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "533b1447-356b-48a6-9e37-97f14a4d57ce": {"doc_hash": "66e7d1813f13745104bdd57e1aece5d01c2a2eb8d691f1cc3840b3aba7b16e3c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0f9f8736-85cd-43c5-8c06-04754b3973e3": {"doc_hash": "24350aba1ebb1f58293ae81bee26e627f89066ef0dd3908cf2d35b3d5ac6c409", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2ed174eb-26fb-4e1d-a551-23eb0479a4b7": {"doc_hash": "a98fb549b4dd9e33abff1d668db9301771e969f4767608f3ae081ca99e48b7f6", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e52f0545-4c18-4c46-aac1-03b7a67a2325": {"doc_hash": "cabbcfad5a5f30204eb49781acef4b3dbb134e00b3146249e3563b345b51b484", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "f2093f11-86bb-4398-a654-bebe23434c35": {"doc_hash": "6c5a612d74feb94574d173472fa1f1ea47d901c5274d1fec481ec81529c68ca1", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3ab35daa-7256-412f-8002-02e9b91c77d8": {"doc_hash": "9f84361667124332d307d0b9386f74b2ad49329df3d77e80fa934fad7d302573", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d6691739-074e-48f3-9292-85590786444e": {"doc_hash": "b25a3cdcf20c893a4c6f9b3c869625c66801a0ca9354d2119689475d5cca5f31", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2e72b2fb-798d-4849-9166-c72eca0958aa": {"doc_hash": "716f01897b38b3bd0f39c1c27c8a34b23bd2cff3db5fe3b15f5ad8ef1defe5f8", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "34d82bf9-550f-4600-b65f-91b0e3c2f36a": {"doc_hash": "27fa44f948eed926aa0e41730fce13ad43235877bc2849349a62d436f48e92d9", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "bf905f9e-d201-4976-9232-93deab333e01": {"doc_hash": "e0d6deac08c0bb31f4f628e8f2dcac22e93d61dcd63f741d577b96ad93c7a074", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a57bbc41-33ce-4b4f-8054-4e67b9c22e1b": {"doc_hash": "4826c3bc1e8d4a81342015c835300a4101d81a6ae67532c165afff837381964b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "216bc339-c5f9-4b5d-b18b-6fb154833903": {"doc_hash": "d6a4ecc8767b7a350bd03515a795688c10544eedf070c14742ec7b45688cfaf2", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c9b34d9f-6621-4f1d-a83c-d2b41d78b178": {"doc_hash": "ffe4cd8df7d7ea2fc4c2c66fbce34ba0e600b06ac1a932a417f22d5f54576718", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2d51534e-9765-4938-be84-43bd55158e08": {"doc_hash": "d1f00baeae1e4d414cfade1953711199173a29148b3c2207fd66c2afba0b761d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "569c9fb6-0bed-49ad-a6bc-f656dc91324d": {"doc_hash": "ba02e9a9130af07c0d2195c9ebd85e88ed9eef64bf1dfcf6b55e835c9603034b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "04a44e49-a82d-43f5-bcec-484fd8b2dd9b": {"doc_hash": "1df28a4ccd79e1a356200c240a310c321304c3427a26b743a0eed55289f3b280", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "f958c009-805c-42d2-addb-becbda52d561": {"doc_hash": "b6efed729f13fac837cfc9acdf40714a33524a322b16611d664d799444699b1f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fc10d8df-97bd-4f0e-98d8-417aa7304325": {"doc_hash": "717ba89e615b663de286977efc0ccc8a06cdce2017d00ab0437fe3a11739e1ef", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "91ac4010-9545-4d67-ab47-6d48fe5b0da0": {"doc_hash": "4137c0dee9cb58b7c76b30567bf3a76c7c83f8270dbef10fc5973a632f8166ed", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e7af3b22-90e0-4e78-b84e-115132b95cdf": {"doc_hash": "7bd4dd4d89680ef968686d3812882dbdebb162755f998a812670a13e72021ce6", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7730bfa3-9986-46fa-a1dd-befa1def170e": {"doc_hash": "06f927594d3966eb98bf79ab692791201340ab2dd28572618812ec47e47bb3d9", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b8ed9649-0992-4a76-bca5-2ccfaa454ea7": {"doc_hash": "290752932fdc7063c435ec7c9bc4ff8770f98558d465f1b9b4efe19b2aece296", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fa841011-abcf-4258-a6a0-90f3c89e2132": {"doc_hash": "0f8386e42e8ebc3a51c8e47fb0af719de617ec67310bfc4e4d0ca9c9f4068f26", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1cc979c3-3c13-42e9-b015-8d38be4c5c59": {"doc_hash": "845326605fbdac6a9f44aff54921bfad38d488f17076b2cba0e83bc501b6a378", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "f4d39709-e689-4591-968f-5e9429df58fa": {"doc_hash": "5cc28546553f7d2753ec5842b3a54eec333066466f704d2b4b3edf053d4a5e2f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "12137bef-3990-46e8-b25f-5a7f26ab2187": {"doc_hash": "f889eb912f80b3ab376b15996a6ca1f6a575f65aef380ce6159beeeeb8c2e89a", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "51a8835b-34e3-4736-afb3-79865b481727": {"doc_hash": "f2058806e14261e4efd8504d9ce6b185a2c92860a2082f10d639dcdc81c4ac1a", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3c200dda-f51a-4e20-9fdf-20a7cdfc5a91": {"doc_hash": "304f77ade5810a56b58b794e08f1f72e2b6c52bb522a30d9a1625b82f78b90d6", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "4286f418-ca59-4f91-879b-ddc181bf4748": {"doc_hash": "a66e5bc59b444b678473a3cfc6b0c61618fc26991c2fecaaa2cdbb5d8fc3ce10", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "cc220c01-464e-484b-bffe-85f301700500": {"doc_hash": "bb0d134e917fb19be12732b50cde1b1923ed2de1a28a74aa92ed2b2605d3aa91", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "14bb583a-fd06-45c0-86ea-863a9e175427": {"doc_hash": "41723816da94ddbbd0d3368e659b52247805ed3125ce666ea8321fa3ab065a73", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "90bded7c-0a2e-48b5-b6d6-075dadb2e012": {"doc_hash": "d6bde4b775ff5f866bf78e5f24db1b506d5dc954be24f245b1d78bac24ca4853", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7aa8b595-d077-4205-8a57-fb408a906c94": {"doc_hash": "36a003fc052b894757f146589484337616a2e554076795fcd63d265547a9e897", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1ecb85cf-23fb-4794-8b19-b0090b1fd607": {"doc_hash": "5c8c695f1dd9e67344685ec8477cb8231de58f300cbe5d72dbf171107e0c9f53", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "382ef4a6-f79f-435d-ae5a-c80858947111": {"doc_hash": "24a3b78de680252131732cffbfdb1692272dc97806493f2c645af8ab4fda426d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "44ac21c8-1e03-4669-bdf7-816b0b3393cf": {"doc_hash": "3078bf73fe126c81ac8e22b37b6203a0a7be2f39052341475b62117e40a74956", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d96ce7ce-d17d-4866-bcf8-431b7b6a6cc1": {"doc_hash": "a3912bf72a500c6634cb5b3cc90000b8e23e22389df00f8ae08b5b7da3cb38df", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b4f1a3e9-3c70-42af-b6a3-088863b927d1": {"doc_hash": "ed873ad1fe95ccf64be4e6f199cb2e3a130971d4112a32a3765d4ee9da700be9", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d4ad6ff8-e157-430a-b5fe-41ab311c782c": {"doc_hash": "4551c9ad2ca27adec7781ad33a331d2243432f4f61731a74c3bd4212eba9ca7e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "6647ce3b-1e0d-4fbb-ad02-ff9d14ea1e11": {"doc_hash": "a6755888c88a847c2edfaf99e3415c3d0a79981b4443893efea7ce191d9ff8da", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b9a48fc4-e5aa-4a64-a594-c14003264340": {"doc_hash": "86357e7bc09c3eaf4b9e4fd3233914bd3692f1594db1d7d12d49fa5c96744a1c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "04d7a591-36bb-4f6d-b509-044ce1cdc3d2": {"doc_hash": "3ff30c3d1659fc2aff5ead6dac67c741023194ec3530bab0da0121b8e25b7b89", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fc776d3e-ecea-4d0c-a3d3-a96ee8dd6a19": {"doc_hash": "09436890d3a443b2f8baeef1fce0d56228a3660e81b4fd264374d60177a04eaa", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0b7c6787-0bc0-429d-b3cf-ccda2220549d": {"doc_hash": "73212779a8f9b82ee5deea05eee6119f4eb639ed8c8347b2abb4fdf826a00058", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b55b4cc7-426f-498a-a206-8b60cd584741": {"doc_hash": "3a7374d944ae3ab167a84ae808fe31f7ef6b7a901bcf737b95982da2e04090ba", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7522c200-552d-4278-bc4e-4c6f2a57cd1d": {"doc_hash": "86ead281a72320229b306b479e13ad7ceb1894bf49c68a7c1eaad368ad6c88e0", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2d291ee0-29a1-4d16-a769-8a750eab2eca": {"doc_hash": "193665734460e58963fc5bfc8933956301af650df072b53317243f9abb0a1268", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "45f09d6a-a8c1-4e17-85f3-6c4b1a6c1eac": {"doc_hash": "95a52e8b816320ce83e41a2ccc76731c39e2af86a0c0e2e7fec202cc4f70852c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7aee0d06-2203-47da-afba-028df6d37ce2": {"doc_hash": "7a49da4dd8fc8426e36a62e2ba96453c84e0bc5ad7631db1fe76868b3e20400c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "87f81415-a5ea-4cf7-bae7-24ca4c4f5dcb": {"doc_hash": "5f306725746fa50ccc744a2a13f51ea87308437380a0c09a309b1cf24d050e78", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b4c6f59b-a442-40b5-ac2c-d43005a6d1b5": {"doc_hash": "8bdbf23603f453ab498118204503107fe159d65c3ccb0c0354a56c85088e8979", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "36ac5c8c-8e14-4cae-bf86-710a0218d847": {"doc_hash": "571b638ee3ed3dd9525722624762b7708cb7ea8807852c3f5e556666c3c43854", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "298adf03-6580-46c5-b487-d672be177bb5": {"doc_hash": "a2e388b74e1c019e44955947135aaf95384de142fbd82647ba6c841a3af30d9e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9ce42bbf-0e9b-4e4c-a33a-fd041051140c": {"doc_hash": "406befe55788e30ded0df94dc48e3d9672a8684a58610d400917e59320648909", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "24f0f93c-6afd-4467-ae71-e58cae9526f2": {"doc_hash": "3e5fdfce02df5d125e984ff6722eefd09def783bb8ac91959453c83239b7f8f4", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7dbd256a-c916-4366-8227-abb1b7f2da4d": {"doc_hash": "ec4c1b1df59d17c8e630ea361bc5b760872f4a1d069b6709e3cf3b8c316bd987", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d426c44b-034c-4d79-9af0-23847b9b11bd": {"doc_hash": "11f47b336644f81d70f05f5aaca318558794bac5a6109de5cafcb8ba9f331413", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3cf444a2-9039-4b72-86ec-ed55fa6f1676": {"doc_hash": "ef059c2f449b71606e842e48b9d268274d4d1f1fef0dd3446b91281a40c98931", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fd714e9f-2a9d-475f-b06a-005be7fcb008": {"doc_hash": "92766ff857df48928faa8c2638702cd3ad5a3f851e3ad653b8cbbaed0abab034", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "4a82dddf-fb11-4bd6-b022-781d59ab7ef7": {"doc_hash": "5407c2edd467d8cea2c7bd718417f49a3b92057d8ebbc35caf1bfe985acb0f53", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "182ef506-6e97-4f72-8044-68eb2b2e2f7c": {"doc_hash": "f66f5c73139eef1a12ada1aa1965a123bda10c56987d497490e7202a546c4856", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b5aa3cc3-a817-4330-b6ce-2d3e8cdca1e2": {"doc_hash": "8aae878a3524ead8fe0cb4d26810567821bae0a9d7a7c6f808606002a5fa59d2", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a070f35b-5bcb-40f1-80d3-01dc3819e51a": {"doc_hash": "3d5dedc21035640ead91620a044c5f58de3c0280c746cd308f00f91624aa6275", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d6d7be01-150c-455d-b559-f2568193ae2e": {"doc_hash": "01fdd3483568444421775469a19945bdcf55a7c50e055de15084bb3ab7c28777", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "cceff5f6-4491-4d94-a19c-32f160f07ba6": {"doc_hash": "6a96e970c252b0790bf782971b4d553775fb69ece92550d6004cb04a8065553e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1c074884-7cbc-4cbc-ba86-41a59e0b6b0b": {"doc_hash": "44002f6740cd3749e33408de916894a85a45049105442cb6a8e39fdb5576d04f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0d26815e-76c0-4860-8864-1c296ba46899": {"doc_hash": "4d10e1c0dfc7c1f26ca88219492e5e093fcc0630fd251e8f64b8173123e29f18", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3a033a10-4c0b-44f9-b798-fd96c01070f2": {"doc_hash": "76fffd6ddf0dc641c9cf8a46270b55643832cad00a3bbe585a951da70466eca1", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "12b81399-52e7-4549-8a65-92a2fc91d9a8": {"doc_hash": "d3e208bd51873b8c99381104768b61040ed84a23d380be6f10c84091fe4d0ad0", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "5a9eef3e-586f-4353-a345-9c02dc25dbf9": {"doc_hash": "ecb96783de3f0474e4f08a63aaad6b4acf922d5cd028fc826c8e2b76decd33b3", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "4b6e6cd7-a76e-4ca6-8d14-f08a68501b91": {"doc_hash": "f00d27a4edabe88206cd09119df622b25107c125220a3332d9c5711f30cd5dfc", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b3d4a14b-7cb4-4b47-96df-be0f4d0d5cd6": {"doc_hash": "5734935572227d13eff3cb2827672f6627060ff54c010cce7100d9cde5b99990", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fed390c8-3e08-4d00-88c1-15b05dbb52a9": {"doc_hash": "4628eeab8e4528a32a5a20529ffbcfaeee6d992a833afeaade3a65970ac45b4b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "45897cfe-f088-425e-b3ed-d4763fd766ed": {"doc_hash": "0620f8c778829b3025e2156a814351896ddf143c261630c5824e901268987d71", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "5e2f4c66-8ac8-4a1d-96e2-07185610c734": {"doc_hash": "26c225150baf99081e477f870b14f01f97c768b65e1a28272efaa76c3381cc26", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "09900028-e59a-4225-9d3e-636b0028bb0d": {"doc_hash": "c7010f76ea10723b7c29302085c150dc770a034a386bc65701f7d5b726c8d0dc", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "01356ff9-3de9-4b85-a286-ea2d0cff02dc": {"doc_hash": "c1ec60e9d83750cba1e048d4299fc4d3ff05e731df6b92693b7c25b1d5597d06", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "944d2286-9133-41f9-9b88-0d2922b66104": {"doc_hash": "deafe76d0b536041e29931409c831e508c164d2f9fc7e4b41a3c214e389f31ed", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "64f8e839-7502-4a3d-b88d-d2aaea3e8513": {"doc_hash": "6d4e20b9376352be4a20fbf52a0b6adefe6d91be06c0b41e946829ee84bec093", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "78b814a9-6089-45aa-abdc-b6e1787db1b7": {"doc_hash": "25b6b3154b0d712216b23fe1177c983eb704c56bd9e23ce6ae4c2ce570c3bcd8", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "12c17f23-ca2a-4b5d-a896-8bfcef37b213": {"doc_hash": "b3360aeafe2ad36f6dd4ff9b970dae1078433d9e12a9bddf1d4b9cbf4bfff69e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a2303d8e-5a77-4073-9fc4-08424723d347": {"doc_hash": "29a2998570e0106de59bf4a7ab0523fb643d339fe9deafef891e2fa2e6dce992", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7ae2bcb6-feed-484d-a118-812617939f33": {"doc_hash": "0b5c9a7d96d4d4b3d92dee6209342b9f90ad4464564f7d5cebbbdd234d297302", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "daefad5b-2b0b-45b0-b15e-ee3eb591a175": {"doc_hash": "c761b3e349d08f132d3c95616c5a4ce55e4a83bec1cb08201d65d3ef9057be6b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "8f818552-857e-45b5-8b95-39bf6167d197": {"doc_hash": "88412691840314907b6f1809e8890b4a7ef9990f6b5aeab8921bfc94452f8e79", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c4ea145d-ddf2-44a8-b129-bcf29ba6e028": {"doc_hash": "a6fe6b2ab4e17ea3fd4cd916bf0aac9775f2131d5d54394a2ddb233de5e99a9f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ce668fd0-8521-4d37-a084-5dc2aebc58ae": {"doc_hash": "a6b8e93e425ed887eddb43d9e0f7503016a22690f55f21bf998cf0a33fb2c12e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "42ed2599-f8c2-4949-8b6e-faad0d133eed": {"doc_hash": "58daa6eacb0569fb6fc95dc51b7ed09ee0f5b95cb73af2181a407138106bbf2e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "f85b1783-0912-432c-8656-fd774eda57de": {"doc_hash": "3c62bcf147a33c59b45916e140bfaaa4041da5b9d46405167a2648cc4c70cad1", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b6c68a12-fc00-4985-ad3a-10d0077a5981": {"doc_hash": "0cc5824cbf89a886da26ea471e83c4e85553020635a524c23183752620a2e17d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d830fd03-a3f0-4228-a89b-5cba2c25fc4f": {"doc_hash": "ab22d00159d397626bc94c00cc5c9039350ebbb9fb05bcda6a37f07ccde76952", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7fb35b1c-69b8-4300-b8fb-e118c65cfbfc": {"doc_hash": "e8353e9e416f1c3c6da21b6341beb2d4574f6ec4f58b5af868e51dc808482856", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "37fa0b59-53d7-4741-8c21-e2b8daaac836": {"doc_hash": "d433f94646937d3c66fa58986be8e390401fb0ce87399dd730e9b1d61e6f7b73", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2c3e176c-92cf-41a7-b046-c0112f546fcb": {"doc_hash": "854f52f292d2367664f87fcf8a90c3c5b65b4283b6d35b1187fb1eaef834f6ab", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7937e5a7-db35-4dc5-ad90-6b8a729aa4b0": {"doc_hash": "0a480f012e95577aab76d0a84d15e375c747e59d27333109e0e1f9075d0e7916", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "65ec2c99-5c01-4c5f-b6fa-096d2f356a14": {"doc_hash": "f07815050a19ade9181d85c62f61030f145fd8c973b057d139bf01a564c69242", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0771d6b2-a553-471e-a058-0f9ad4e469b1": {"doc_hash": "9f23e0e95ed9f2c6ff4220757c179405aefeb57921cc2edf25a512690fda76d4", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ce89d424-a04b-4f9b-b9aa-4276768e844b": {"doc_hash": "eca67b20cbaccdbb87bad62f85acc9709ae4d143735e15752e7eb43d0bf78b9d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0c069235-9fae-4900-bdef-87327737ab9e": {"doc_hash": "6d0c3c4c06561d5cc259ce7a9f26ac478cbff7b08826ff99febc4923c67fa5a8", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a21095e3-c318-46b5-8081-2cec8514ebcc": {"doc_hash": "5ee2f81c1c865de9a3f0637a4715483cce05db885b2dc8fd19989900b15133e2", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b3defebc-c3f9-49a0-9978-7566398756b9": {"doc_hash": "ba565d1ed7687ebaa90be53feb036644d283c2c132dd8d2bc9c424f3c5caeab1", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ede0064d-4a3a-4281-b41e-a7632ba5f776": {"doc_hash": "22710dd4611603029c1609f645e85dbbf1c0cad3331178fd851886273e32f253", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ed0cfaef-602b-43f1-8596-3f03d96edd4f": {"doc_hash": "7eaab1817c741b34f41b174c6d4ee0743a74722d34a19611358545fd56788d61", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "5d741aad-6968-4ba2-8105-8f15ccdf5529": {"doc_hash": "b1f3b9ab5120d811e90ed25ac94b0c912983cfa53e7b02ec7b3d8a69d37609f2", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "067a7c2d-52a2-49d2-80a3-9f3b081a64b6": {"doc_hash": "bab1a42ce4a7555a4ab0cfdddc14a9f4a7db240ae4f265b5b9b3f5a217c79337", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "dda8ba92-a80d-41b8-b3d7-adbf79c3fd5c": {"doc_hash": "4d671c61e97d056479087b4381a8bf7f2beae78296d8b22cc6ef67966bfc84e9", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d6a201b0-d2f1-4e35-aa3d-c78a9d683b49": {"doc_hash": "1fab1148476d6c8325167b110dcd9ad8dcff704fac0d7ba991944fa89e078339", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "f4e32fb4-2876-4510-8630-08136a9554c1": {"doc_hash": "09ccee323210d03915d0e893108c5007c57b66aae59203f78a79004cd06177b3", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9cd6319e-f239-4045-8650-2ffb30c28565": {"doc_hash": "4cd606f380fe515d14846b089df1c0eca983dc06f2ffb39d6a3998d89a26ba6b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ae457299-c48f-4275-a94f-79b808571acb": {"doc_hash": "8f4974672fc8205e071dd636c87e1bc0307ee23e8b83304b5aecaf67cb7f8fc5", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "df9e68bd-2ecf-49a5-81db-e6c7260409c2": {"doc_hash": "b23fada5f33e5acc9eb91b5f2e4cc7c14583722ed662dc2039d7a475e1dca9f1", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b3c0c935-51bf-46d3-9c70-fae814ab7935": {"doc_hash": "f989df0b83db938208e99972d3be25db8900356bd2fd9412608a3bfbce054a43", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "8a1180e1-2815-4bb4-bea9-7ddfe04ca59a": {"doc_hash": "c221889823a63384c597bedabe82598a3f3b7e4883e04c05c1a4f5036afcfdef", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fad39a75-456c-43f7-853f-40c8e02e00e1": {"doc_hash": "aada3dec8b49d8f530bdc6fb4d6a317685dc90e6e56d1aa632bf17be1af008e5", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "92d388c1-f890-4a92-b556-a1e32286b117": {"doc_hash": "e3a1a65c16a3fe29349867cca7340bf7fade5d080ccd1f147780b3520dffa4b0", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ce4398f7-c886-4b34-8e57-5905f99a7ea7": {"doc_hash": "a744e2f87fc501122dc0f8c21f6a947c799a567fc4ca2d93566c99984b0143a3", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "cf754a1e-5838-470a-a19c-2c106150bb63": {"doc_hash": "b86d0237dfd758eeae76a7a671c67cd263b67db3ffb17c50812d402bfcb192a7", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0cb2f343-92c1-47c4-89ce-c3fc954a3d28": {"doc_hash": "50288321eb03d865c2ebbb822a4b7db1ce934b9bf14ab821874e34ea8cd7155d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fe4d0878-a2b9-4704-9fcb-ac7c0be822f3": {"doc_hash": "b261333985c04bc4d8a49433986d1be225cf6783b066bb0f7579194efa635b54", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "f1bf788f-6dd6-4694-b0bb-76bd0e083baa": {"doc_hash": "56ba094ae5a8056f99a42ca5229d849612656546ac386a05ec12f681fa1cca1e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d4dd3629-17d8-4979-b27a-2b785e9d9e00": {"doc_hash": "958f7b558fe7a0807f28125d80dcbf6c6e1c14c9a49d880416724136c6b46bf7", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0306ffb8-89c6-4daf-b391-ef44c918266a": {"doc_hash": "792554ea1b825854772f89653ea24bfed19c2e3303c827656f10b12ddea610eb", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "60dd11e1-4437-485a-a5f2-edce7893ad77": {"doc_hash": "1a0e701d0f5358effb9c113c95fb8ca117e13b4bc00bc80127eda640a0aa3483", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "735a507b-9a5a-4b49-80fa-083c601d9138": {"doc_hash": "19fc0ef7153c3d84813689334b45063473c687e332fb2c589c028b34c593c475", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7a118f90-381c-46c5-8091-7726c0a36476": {"doc_hash": "2b6aa256224474ca42b79b8cb446a931d0f763506121847231366e3dfddae550", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9bbce4d6-9059-4ac1-a38f-f256bb7688f7": {"doc_hash": "0a9236a1b0cd46cf9347666316f07f12bc8fcbffaf4daf2b050017c1fc1cdf58", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "5c600742-599f-4c38-ae5d-4d8e35e7172b": {"doc_hash": "7549b700e006d08859440f619a0de898b0c128d2efc8467e2b299b9391cb593a", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "cc2c15db-3c3f-48a3-acda-58f8a61f09b3": {"doc_hash": "aa359c60180e5be363d5574edacc4403265e170da021244e0e4cb6267c6f4501", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "10e50c27-ec8f-4f96-a235-873d5dc6890e": {"doc_hash": "6f9b2220f7df9421b7ade95cc67a59f17a9dbe5a86c81a79310f7b6f9e90a1e7", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "6b54c715-51ff-4f60-baa0-c5499d80e177": {"doc_hash": "1cb72403bee5dc7c676a37b56ae599b086e7c6243773b59c164056a8305a544e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "5dbccf7b-5ce5-4308-ad0f-bf57b02f8664": {"doc_hash": "6445f9fb1492cca2df61dadbf719976309f0ed99acd6121376b34dbded2106fa", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "60d8a5ea-871d-425c-ba22-8f6335886d9d": {"doc_hash": "20b23ab4f15172ad4f777c0be1a1af55a7a47c217419e119b898c3700d7fb8f8", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "13f2ba21-ea4d-4828-9b4c-8c21829ac607": {"doc_hash": "07e67de7d7178717a90a7ddad8ff4f6083ee442da224a8dc133c8ebc512d7e5a", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "55a581d2-aa2e-4879-82ef-31a2734ef44b": {"doc_hash": "1fbf705e68c6b3bed3c694d6cb338ac40b1c3030cc89e541320982200d335ca7", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "da26f561-4f90-438d-889f-18e100ce7cdc": {"doc_hash": "03061eb5c738053c1c228cc8aa336273057bfed0c5c078b7d192a8b273aeae64", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "946da3ae-095a-4376-aa05-d80f5eeab86a": {"doc_hash": "2e86cd36171f9802c38d92905dff17a5e63ad117955ea1e1354563f474b763cc", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e46db9a1-daf2-427b-84e3-4e700078319f": {"doc_hash": "4feb093ec47fbeeb702aa8384dfeaab777c3bbb2798f440370f541eedc4029ba", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "571ac82d-4426-4296-905f-a07eb3ed9d62": {"doc_hash": "64784ff27e961518244eb2f426a3a77e1659121001f138dd3eb1d2826ee368b4", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "311a4f84-216d-410f-90ba-5b70baeb799e": {"doc_hash": "4e7f82454c640cb0de88843b7dcf5bf0ab27c718aa35b0e2d39de48b66d38ee8", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b80d32b0-f760-439b-a708-4a8cbd492117": {"doc_hash": "bcf74eff78bf0928f87c6d56454b7bd91b5f2f5c1bb5cfc94dcdd3d9db4c0279", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "97e535ca-abe4-45ee-8c50-37537064d747": {"doc_hash": "ff6bc2fcd0d04830b040f4372d3783bd03d8d54bcf7b1ea30c24fa9d1f4cc19b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7c23e5b6-6f9d-4e53-a34e-845dfefa4ebf": {"doc_hash": "063c34dd51f672cb3d6f8a36390ca0a36a2858f11f1fbcea7edfbc6a87466bf2", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "55b3bece-979b-473a-bb1c-8e98d34e75d1": {"doc_hash": "bc402af6d35ca26110ea636d54f4c9d1c0afc3b3f276e9cb33d7018d8d9495a8", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b7545fc3-3e76-48f1-84b3-64aa28f53585": {"doc_hash": "09f69980d34f7c2b7385c912bcdbc344027a92982193049a06483910850d2aa6", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "128677bd-f083-4b1f-b67f-8ccd7cb6b47f": {"doc_hash": "a359d2db6b85da93889aff5b5c955a7d67d25942afb00f9f1905f502d50a0450", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d0c39b82-8fc8-4067-96bd-c346e07c792d": {"doc_hash": "be1318f073953b6e019196dfff1aa43c397d9fd0496608ceebdac4fb73a6c4a6", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e680a6ac-ac0c-4d92-8183-62fd3ebb181a": {"doc_hash": "3c2ca6385c1c77901702988280060e52978cdcc1781318d756160291510cb73e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e4628853-0607-4cc2-a7b6-d8d06d02edcb": {"doc_hash": "634e0356b13dd0af8406fdf35dc60850feaea4909516ab88a9e344eaee53e669", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "97a4a886-b503-4105-9bde-4b58459e7f3c": {"doc_hash": "0e4aefc79b1fc1280d0bd8fec3cae377185497c018daad4c17129b57fd45b1b2", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "018d7dec-ee8f-41ab-8daf-bf002e87ff10": {"doc_hash": "2df7e78a41eb6aff8618d611c268bce2f3e856365c27a8a2f499a44ce39ff530", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9448b4c0-7343-4771-b7e4-22c02c6f0782": {"doc_hash": "34313f126f077fef8a66940cd1c2e0797c177fbd80079e84b7456b17cf4eaada", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e446ffeb-8f34-4495-8c3d-5c79f5d764aa": {"doc_hash": "2a22cd08e11e19879169106a3896b25ac2eceac78fbac3f233c02d1ea5abd0ee", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ae06a1bc-738c-4ffa-998c-dd8b71e85f96": {"doc_hash": "568dee9760ff96b1d51fba39d71d328b0bf1ba9fdafbcc974ac8a2aa21a77e26", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3e1dd7e7-6f88-4aa5-8cc8-8d25543ff446": {"doc_hash": "d4d419fb5774d2776a3e6ec816726367f6a91d430cf2581b0b71bd347c27c364", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1dd3ecb4-96a5-428f-8ae9-30a3b56acadc": {"doc_hash": "732973bb8df868027fb186645bdab3f9431ba3a2211592048141bfefbcdca492", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "24fe6c16-fac4-47ba-8236-4ff611ae0481": {"doc_hash": "63a2c5ff0a2e923a59c882720342831258fc015a98147cfe61b0fa2f33063080", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7a81335a-d499-4696-a820-7044d8daadc1": {"doc_hash": "2a7dfbf20438a32d7ca23b342e7c37869475141321f4a6ba3c1196427c9ba224", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "8fa5f463-3d75-4b45-999a-fc7c91a750ca": {"doc_hash": "ec64e1982ef18190cc76aff5e3ae3cb394bedc1b3999def717f6276d20327fff", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "522bacc8-4e94-4665-9b88-5e902bc8bc16": {"doc_hash": "6f8325f6adb169c576341ea04894dac70256a763d1e5a7daac75d9f20cb5b5a4", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3110c164-5f55-4d67-9508-e1c9a984a3f7": {"doc_hash": "59f494e05b4fe2497c8805f1f0630e8f915228f65550986d26d166017b38dbe2", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d8209767-669f-4131-9d83-bfc337549707": {"doc_hash": "52a267f0e9bc58b4dbe7b1bb6241acb6c9a3b86070d036c5f6c1306b7a1df16d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e403de8b-cc6c-4e47-a438-30328ae64779": {"doc_hash": "fdc7eb9f1a34c67028a3b79942ada3a648eb65bbf092a60435c8e443744e0f0c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "6444dcea-c708-4530-9d2d-232fcbc50633": {"doc_hash": "828a22b74c4e8ed0389a04fe6c3841f95708b8e8d0aa12556355c25f72aa40eb", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "6f950f92-47ff-4ddb-930e-21dc669b5a03": {"doc_hash": "229f910d108fbdf67a416114ee864b9379f444d4c2c46b5229e74bd8ffcec018", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c2ce7c52-7cf7-4119-8f64-032187212523": {"doc_hash": "c730967efa644419bcdea5fa5bdf423b4d65134d04a207cb193b36cd9ef5341d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "88de74a9-caa7-41a6-acb9-b0f14e0ed7d7": {"doc_hash": "68f4e711bd103ed413724aa51b6a4faf53a0b2e790e3a61f983a68e096846184", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "bf0ec803-bff8-4fdd-a4ca-3538cafc356f": {"doc_hash": "35883b9ed1a42f1e57086fec46f94c47b7c00f9d0059c968d55c968d33ef066a", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "686b03ab-70bb-429b-8d44-d424fefb7c67": {"doc_hash": "f2d7e8a340dd4e583185160149e5ea1c138130915eddd2015a730321ecb00f2a", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "22496963-c3cb-4862-9f0b-1fe966848a5d": {"doc_hash": "cc1faa7fcb5390089a4b610048daf37ab22e0d1eafb1d6384cf936d2c775ba0d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "cb51740e-e8a1-4c57-a871-aee89c774c85": {"doc_hash": "f033417e92d469666b7c84ac57375e10f86bf54e73dca8963a57a9788c339e3d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "aca14484-b9db-427d-ba59-9993f6cce0f3": {"doc_hash": "54cd53783c3589549ed64768cd704de6e05a5f0630c644b00269091d360cf7bd", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2a3fb042-e61e-4cfb-b057-88c550d50988": {"doc_hash": "3917f6fb819b937d6b76672db3c815b96c3eb5ae36f72ed29c11811bb05f4752", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "da56cccc-2bea-4768-8250-b36246416785": {"doc_hash": "1920519ae843209f4e9268546db59dbdc7eb80a8c2d72ac90768ba875c3dd051", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e280d9a0-0a5a-41c6-a5ca-eb2e8972f2db": {"doc_hash": "69e4dc35e052d1d85f2059253fba19ff204e30c7063cecdb50e18d5950cc2cb7", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "01c47f2a-a1f1-4616-83c6-ec0fb4db2179": {"doc_hash": "471a6f9c8897b141e935844f71ec36626384b0fec2e65f0294d60b349b2c17c0", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9c36a244-cc03-41e5-8673-1b2ba7311e92": {"doc_hash": "b43bddc730aeb136e35ca6c4e629c77d5797081ce1e9f8bb6cce12c0858e1111", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "35105674-9e76-4f82-833f-80ecdddd75f7": {"doc_hash": "dfd0e601a3b29736761fbd0d338273182b878c74f61de03c87a38ee8be30ca82", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "67c5803b-8cba-421c-8449-d0838698e7ae": {"doc_hash": "eb8b993d229fc2ee116c67fa70bdbb2101b14bee83c10ee15c57cbf46cc7a709", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "cd79b74d-d00f-4c27-b11a-7b3847109b4a": {"doc_hash": "1ac5969c925d2e86e0eb6e8476ed78602c415bb8ed729ede565885316dabc28d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "dcb5fb76-14d0-476b-97c5-d4708a8dad4a": {"doc_hash": "a2c4106480870912bcc03575238f982325bf47d15ab1d674d0ac6d27cebe6e1f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ed1c198a-a7ca-43e0-862c-a4c7e752fa89": {"doc_hash": "3765fcf4312aae1b22ee48f8a9e4fb5ba2aa25d09b42c6dccf8c715d1bb61e58", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "59eb2e06-f1e1-4ac3-b80f-cf52bceda9a6": {"doc_hash": "43407a45384fa26ce3adbb78e7510ab9dc1fd289dca8384a7cec7954af0fcefc", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2cb340ec-7a0a-489c-8839-ac278053d120": {"doc_hash": "a43aa29bb40110736bf6aaf60f484ea3afad192b92248e5df44d885be3d3ee81", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a5a81eca-ac97-458c-b358-d783f1c3312d": {"doc_hash": "48bec7a938bfecfb3d9771518eb82daf9ee0ff842b95df2c4e45954c3cb868be", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "19ca01b1-6f58-4728-87b5-6943dfa7c727": {"doc_hash": "d799827ef6d5c4be74995fbef2157cc9d0f36a963475a4f460a630c0f08cfd8b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c701bc5b-185c-4ba3-9888-fd83cc4ba487": {"doc_hash": "b8541c823437564673f049892f6bc3f5ddf3105bdc2f9898cc96f0c4610fd654", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "130c92ef-e69f-4377-b704-424018681566": {"doc_hash": "2a80c6b4b623c09f98881fbe88849d1883462a93007def307e06a47e9c99bcd5", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "4e2cecbd-0358-46d8-8b2f-bf9219036913": {"doc_hash": "4e7c7920642a3d16ca30dd9ae23006e1ba46b29dc7db5ed8e51fbe0594402ecf", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "82af1557-e069-49ae-bb1c-39435e9f00d5": {"doc_hash": "93686b4488e638b909ce4f5f1ee73de54fa7e677867ac801026d4c276bdbc693", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2fa30afc-b0e1-4854-8dfd-77d05249d86f": {"doc_hash": "6d44740ac7ae6707a5a58a07755f1274eb3a3aab4e21555468e856fd0134016a", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a30de74e-e646-4077-bf63-53cb6290d3d5": {"doc_hash": "998343da3ff876dc4dfdd8aea4f5da5d0e6cf42f384a02381907abb33615fbdb", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "55083392-a9aa-4796-a0a8-1891632c1ed9": {"doc_hash": "354821a817886fb33f125a74cd0695ff190a123e48b13a22b4935eb093b5377c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "eaaf5dc4-4dd6-4777-b169-68bff69bf2d1": {"doc_hash": "a4d096bfcb65f98bc1487f2b662a9b0a4806bf4c3c4269df7c75196518e74374", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "338753a6-aa61-4edd-84ef-a88828170e6e": {"doc_hash": "92cd5a1d7da6e58ec869a352bf0986fe1cd642b33ce40025d5ccefa25051faef", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "f7a824d0-2277-4083-b89e-795153a4c489": {"doc_hash": "a91595c1bdf29a1174662386812d7a88102f2330bf5305c59ac5717c4b92b379", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "360d7fc7-f58d-4cb8-874d-e87e393dea73": {"doc_hash": "a4b5655930bac830838f0150dcb25d2328d76f0aeb8f924c090f8d5954200f72", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "90f09988-290a-473d-a99b-1037d2b67520": {"doc_hash": "3bb91b5728e8d5e8a645208da59ada21b09b026b9124cddd90dab9fdb15246e4", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "22714739-1ef0-4798-810e-82f79b3feca7": {"doc_hash": "853b8b834fe1cf93a3385b36862488569169febfabaddbc1dcf0d5732de5672a", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1ddc0ff5-2186-4b87-88a0-52849aa73e92": {"doc_hash": "c216b6d3c3e87a162fdee7d9b054214d4bf8df370c6b07bb2518e203acb1c6d7", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7ade0e6f-0c37-4145-85b1-0789a13f21f7": {"doc_hash": "8fefb7a3979d0383c609782da03e1367d2ea7d99b5667395be2835e2869fd709", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "4a410f7e-fd45-47e7-a87b-5fc9bff48df6": {"doc_hash": "76b2938c019f22b1537d2aa04b032f47cb75ee4be9949eec18e9bd27222cb0c2", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c63a68a3-d998-4ee7-af61-6bcb5e53ab74": {"doc_hash": "e4a3757f802f5a3cfeb60b298c4e125e36195eb5a78525c265d1313037a0ca0b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "4f5f404e-c195-478d-95eb-07d3e13673e1": {"doc_hash": "51baa176e3977b377cf8e99f95110964a8f5ca8e79be86e61a27427182076572", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "95d231b3-b165-48d9-b311-4e17bbff18e5": {"doc_hash": "f8c2934f03c3a4d884c4ab5ef376eb127397da0d2bc33f2876d91ca7608d3691", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "4fcb5bd0-6daa-4a71-8845-4b4fea16070c": {"doc_hash": "78586efba8a79ed0e245ddbd75afcde024a2413a9a25fa9369f4725d3a532d24", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1df95d59-b2ee-4a6b-9444-44c468f6b198": {"doc_hash": "c975aad82525761b1be0211ca14c721f98a661143fee57193bb80babd985e6b6", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7d6393e3-faa8-40de-8bce-bd7fb99a8342": {"doc_hash": "cc0bd30090204fccbb40f9415ba46c27b3a75b41eb14dc3506de3426a8836653", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7d14db31-94bb-4152-bdb3-616e816587fa": {"doc_hash": "d6eec0f2b374851ba8dae432324c410e311c51880806259f6ec4fd6c3b392b15", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "11accb39-cd89-4687-8fb4-ea5bb91de766": {"doc_hash": "61ceeafa4b3917fe495e2599016f503fbecaa9037bc6bb555e6b2e11332340c3", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "905b7137-aaa7-4c69-8f04-376caa0ba25f": {"doc_hash": "ce0463d796a61ad02eda4428d659320d34f18871026d428ed3db942e7199e4d1", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "096fba12-75c4-4820-ad30-f526f27a4b9b": {"doc_hash": "a55716595595a0798f6183ad13893bfe1979e26afe6d8bf5eb549884e598a70d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "75461e90-a1fe-4582-ae21-55b040fb884c": {"doc_hash": "894109ca6adf45342ecee5db998c97f96fc9b2f06b85b3800dbb4d33e965a86f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "46ef9c6c-7aa1-43cc-a57b-1da066a2d134": {"doc_hash": "813af3e0f1395a90d95f6b658517cdc97f58652648a6ba359079b9209b24eb04", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9dda4634-0594-4a53-8b39-a78fcb827ffc": {"doc_hash": "d33fb71ff1a86782b92e1a4c34115aaa5f17219de4d8a6dfc711e1840e039b57", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c5fbe5b1-d5da-4769-850b-3babab7c10db": {"doc_hash": "dea71ae9bf6cbbc164dea8d265495be58193bf8e8738b15cc1d44d8351868b3b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2fc3bf49-5958-44aa-99f8-8acd981c2ac4": {"doc_hash": "a5dd83d7aa2b7d8e8c23271683a4c05c66ab7de7bcbfdfa29ab41f4aef1f3b87", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "8942b9bc-724f-49b0-8138-13d142f3feb8": {"doc_hash": "aba4c83f628eb7dd2be9189199b67882a57322334400787fba05929d3994b21b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "08de803a-98e6-4b38-9022-07c1dbd118aa": {"doc_hash": "86149722e4febd883ac12df6fe52fb0bdb74c7be7244c0abadb42f18f1c4916a", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "585a4373-4cc9-41e3-8d33-9641cecf44f8": {"doc_hash": "d2607c75fbb4349202509cb88ed5d3dc9841307b00618230c56fe6d7dbaaa77b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e1e3c140-a670-4810-b39f-6dd236233009": {"doc_hash": "53c2c450869c639030fcfb7f12978f39ce8547f04005a3a9f7c4f35b592d786c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7ad45b4c-3408-4485-9150-a7a7d1b185ee": {"doc_hash": "fada5b0e23e7c544f8eef150efb8e5b0ecdb6a1f27124fab4a1145b2ef7dc29a", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e33dd020-53f9-41b0-be9d-ab6b01dcc728": {"doc_hash": "10947093352a8ccaebe051466c1790bd1ba68b9bdfb4988b6a07136d3b02190a", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "470e2ce7-18db-42e0-a851-42971fc120a6": {"doc_hash": "d08a4a972d69eff7f3d5ee1b034b96040e1a483fa16cc9a94f25a7b46b71f80d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a8205fb5-3aec-4806-a0bd-e73ae8068fe0": {"doc_hash": "dd4be2ec33aad1bd7096d72d319c65fffd8d6e19fdda21e8fec138051534602c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "98ccc000-2938-4df0-a1a1-5f494889d456": {"doc_hash": "4b741dc26c313d630c93892d393aab0ace2f19edfb8f3b85034e41f78817964c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "34765d87-3450-479c-85a2-b889b6002968": {"doc_hash": "4c42b3f7417e84c96e8201c40a0b39bfade99805907ec20d3989fc8d57cebe78", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2bbb3ca2-5d94-4a20-9322-96f471a966cf": {"doc_hash": "dcc13aa6d84f54eda28549ae68101be59e2cb2b5553cff20beef89aab64590c2", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "acf05399-5715-46b2-91f2-8a73866e10ef": {"doc_hash": "4e896818a2e9f4fe9c0e4aa9c1881b45efda070ca8b81d9952330ade7e70b88a", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9e60ac1e-2bd1-4861-9bde-7b805dd113eb": {"doc_hash": "fa5a808d2b184c54e28bc2b533f83fe64a02c0316d312b1584159d5372530ef4", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2c374338-aff8-4340-9989-461cd3772603": {"doc_hash": "bfdb3a7c0f18f32ae8cf4f83d78f25c4bd4b2321eca703b693df2c168fb170a2", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "afd7222d-103e-4394-b970-a3c18b4a5605": {"doc_hash": "dc1c0f5172d8176ea142b542013d693e509f117c932b54b9e624cbd921bd9836", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1a055c74-cb31-4a2a-be35-478b80bc440a": {"doc_hash": "2956c98d41bdb519c5258206b124e3ef5567b46f8bd0697a52de5643a3f833db", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "db66b242-0707-40a3-9ab8-20fb3b7a0503": {"doc_hash": "d81519791ab30968150c8569d0e8e643f9a2a9a17d4cdbf0a8f74b6718d20744", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "5cc01fda-462a-4658-ab49-f0730ad71f27": {"doc_hash": "27a0f1a1a066b4234effe448a3239203ebbc5c20d783eb25e4b2ed10185e0bb7", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3b4a8070-947a-435b-9ead-04d4dd6aab58": {"doc_hash": "b1b85f925ac389a236032935a358f9a5f93ee93419dca1bdf413133a72182b61", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "21b7a125-5e6b-4d45-ae1f-2cd19d09209a": {"doc_hash": "5485561aa3a42195cbaf64b8cdcc76d98ad5163d77a583e376ff363075b4eaa8", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "27a407f7-fb20-417e-8c24-85060c31d721": {"doc_hash": "88c22dba1d70c97c976685e24b454e3348b22619583463f3425c3427971cbe6f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "238f6e68-b9ae-4bd3-8c78-85b3949f9122": {"doc_hash": "841def7d43a29cce0f7aafe491559eb2e31957dd136dbf114707cf51a4641a95", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "749a0e77-ade1-443e-b149-fe68ec0b68d7": {"doc_hash": "aa3c27ce7466f8ade857e97cf0d7e389ef36ecf0d435e62c91b90292bb98e469", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "cb254eb2-33eb-4522-8532-554e38dd156c": {"doc_hash": "e8ee639a5e4a485ca1b802690840190eff1b05026930309ecb5a562ace8ed543", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "192ff4e3-6ece-4cb3-a6d7-ce2f40203bfb": {"doc_hash": "25896bc1193a690fa10090b6483992215eded9188aae5e860a4f7d5327adec79", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "53153f7c-e5ae-4e9a-98dc-471e679933e4": {"doc_hash": "90632e82e5356663762fc419e5cec6790dd772b6abfac35804644c62008efecf", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a8108559-f5f7-4b72-8cca-9ee4607b6b5a": {"doc_hash": "41fb61e336e8f8dc3f6bea63a4b7d2579c4840715a29b93231e15956e787ebf2", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9abd33f9-e15a-40b1-88d6-11bae333f56a": {"doc_hash": "f5b8f4757501cb47cf7a74b82250a4cb06447bfaa38b9516ca990dd62ddc4a18", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e533d7a1-eac8-4b65-a0a5-a6c8fe76fc53": {"doc_hash": "f5ecfac5f610c19350aefd02af5668ac97afece4295040040c9f5618825424f3", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "96664a2f-c869-47ec-8c84-1bd6863f7f1d": {"doc_hash": "3c84e7a8ddc0dc75a4460e366b0e70d7f55768518fb5ccb18d41df04793a1133", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "5fb631e2-974e-4e8a-b028-db46062cda98": {"doc_hash": "f9a2d641af648c05e7262911e84213adb972c30bb3fedb7f42721ec8fd6641e5", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "04102463-f094-42ee-afb1-96d4d77f8e27": {"doc_hash": "10423a28597f47a4b804535ddb746de89e86a5aabddc1bd3484077d8426b8578", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9b27d44a-be18-44da-a473-6088b9d5de91": {"doc_hash": "4dc8da64917e7ce67f1a4fb3c676421b406c543aaf4173ad48ba19794d9df640", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "5e50fe11-6130-43e7-8024-d917ecfcf59f": {"doc_hash": "0c09706e7e90054edcc2feafd5705f0b9fc563004ecf4c9b4952402a3f0203d9", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c768ba46-27d0-4b6a-8e27-9cdd8abb1e60": {"doc_hash": "712c055a0fa816c11c7864056b3d85c3ca32336d6215fd44b4c564f3106e8860", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "df34c738-7989-48e0-a326-a69724d76c85": {"doc_hash": "613c98b454a327209f78856f25879d9d6f5a8c3f5dbee36e66b597d2ede1b55e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c8f15898-4e03-4ef7-9153-4eca7d45994b": {"doc_hash": "3e61d4de0c340804c5d5841c82a83be294d36747ce97857ef9a7a968b33ef318", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ed18ea18-8c89-4647-9698-2bbacf3b418e": {"doc_hash": "79a7c69062205d37293aaafbaa99b8d2d6d58c70368dfb648e7349cacdf6eee7", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9b10b181-e696-478f-bba8-65e1512d9e2d": {"doc_hash": "d9d79a74bdbbc31d3e616fbaed4366ca9c916ca3af7d861a3f1efb5296950a59", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "96eb6e4e-7e41-4bd8-a54d-64978ab74e6b": {"doc_hash": "8cb86592ad3e37033aea2b984e911014819c30fa8e944250ee30f54df3df7baf", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e4e204ba-f69c-431b-9b17-8e21afe443cb": {"doc_hash": "d8d18031da8a48221447e820ccf7b7e3e3cd09bfdee9a23ee67c3e026fe39319", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "999c0f05-0c2b-4984-9124-7dbfda9b86f6": {"doc_hash": "7a93b59d91eb0c7d3275b131d4aa29fcb27b070c4470ff69efc9965acef67636", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "168b9c05-e7de-4a5a-b3f2-aed96acb1998": {"doc_hash": "4a4383cb5c81bedac14317264607f9a4306702266cc90a1693bf4e32a5554e5c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ad0811b8-4c65-4397-b1c5-1d7f2ba8be04": {"doc_hash": "f69196a6a0da95eca6ff94a2604f59300d0068cac3e3cb31019f1c85d2cba7ca", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "6dcc486f-837f-4ee3-acb4-d2944d99d7cf": {"doc_hash": "84a3224f7cfff167cee3707297bdf3e96e3f8cdf89046f12616087beabd87e7f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "f3375fb2-130c-4acc-884b-b8450f77355a": {"doc_hash": "64fc0f5a6f6efb06dcbe1e36e479a1e65d1e269eaaeb39984c540e0bbda5dca6", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "96f32a2e-3ab9-42aa-889e-64099d03cea9": {"doc_hash": "6417054021be624113b54b5d9fe836f06b733bdc2567b9b1cecf4fdaf85d5a73", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7f706f29-d30f-41bb-9478-08833679dacd": {"doc_hash": "29a7d798007eac746a0355922f1ff9966261d4e0ec08441e3b2277f419f05920", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e4832e7c-8f15-4bc8-ae93-d33ff7d0cfc5": {"doc_hash": "ab3f5d225fad5b6a25318ab3f8476e6a92560f4ee6a73b5c6b5b51b2198f62f3", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e62583b0-f0d9-49b1-b704-bee5b88b2e91": {"doc_hash": "0ef7216c2b7fe953d51fefc3e050f5cdb8f2190e0e76408a7c1301b682acb759", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "4ef04176-c2a4-452b-962c-c378ef3bbbcb": {"doc_hash": "6ddb7b0b672c3da5eeed8d671278cdfc2504937be5734f5168540e9ace732ef8", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "acc3a559-70a7-4eed-9406-50d986e7e19a": {"doc_hash": "ed22ed4e7a816d041a11c5ee9148e53172595c333be6e2b84587e825eefc5977", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "87e75afc-8069-40f0-a37d-b9aac3f8c281": {"doc_hash": "00fe9aff2c383a974101392015521d52ae3ce75226b642b4e6895c82cd973674", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "11e32d85-68f1-41b2-9dec-8054d5146547": {"doc_hash": "34522b1fab90afe1233c3ea22d93116ef8f5ebd6bb2bec64b0411d9c667e491d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "17d75778-1247-4631-bd0f-319f0ee3f7c3": {"doc_hash": "56ee18b57b412513773ac00fb3235e321bd35e4af7ffc0c839d6f40a2949653b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0eea75ec-3e05-4f76-8dae-8664f16e6830": {"doc_hash": "7dea3d0b0298438eadf9369b365b18b0c9609881ca826aa441e2ff2e0cfdde51", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fc141463-fae4-476a-be7d-73f4dccf807b": {"doc_hash": "53bc65ccea7c355d4864196d26960f77b52fbb6af69aa271d1e7dc86dffb1ab0", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "64c117fe-f2ca-41d3-b8dd-52609c6c65e6": {"doc_hash": "b076b5c8641149bc5f21eacf89872f427209da68653f65901ff8f4c471414c6d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "281304a4-4ea0-438b-9955-15e6625d0f5c": {"doc_hash": "56953ad407286dd89fe7248a0f62f8bcb468770d45f1e186bc3fad026742a27c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "5bde89bf-7c70-4d25-afcd-527765ec4113": {"doc_hash": "6054fedcac49d16491d73cd273ded0b5667e591a0174164248587dfda12559b1", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9183f831-862b-4073-9074-62ed11c27564": {"doc_hash": "154aa5d6b40661f286f9b739d2b23d86277ceb37d8da3f52def693dd4a50417d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "83b2f2c4-4a02-4e15-934f-41c8d013c6af": {"doc_hash": "a4663c1b944f2c1097abd03d9cde0e8f83f3a88aa7f6a8b92ea0b15855bd8410", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7f2d0e50-7ccd-4e21-909a-46903e008260": {"doc_hash": "51c21730580d525e68b74fb583dff8c5dfe5d4b1b408471cd95c525df695fc7a", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "4d06838a-aa0a-457c-b19b-107cf8fa4841": {"doc_hash": "d119fb8f52e0c4a64a01e20de18526ea68b77c1bb0d38eec8b6cbe21442fea0f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "25c8c7a3-4c74-4f2f-9af9-3fdfe59cb492": {"doc_hash": "f88af33877d225649eba287f1fe29781585308f831eb775b833dfd85dd0ae534", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ae2b4d2e-77ee-4568-8d22-7bc4a42a98db": {"doc_hash": "22d5fd79ea2feab083d229c14a7a313108f476a61e2468b913696da8edf269df", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "8916a554-80a3-436e-8a5c-d43781b23a5b": {"doc_hash": "ddd79807c992d2b53c7099b1e8914f8f7e269125de3b75f15185b619c0b228c8", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "657a1771-105a-4996-bdc1-81314727d1df": {"doc_hash": "f2e77d1ba37723e121a5b5f69611ecd8d453f8d746a7f4d13e1f376eab99f0d7", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fd5f37ce-6dc8-46d9-aa2a-227b313b411d": {"doc_hash": "82721eacd39a7ffbe508516f62bb38762c514c03f723bd7e1ddeb12bc3d4535f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "56071c9c-7b12-4005-89a8-fede6b09e692": {"doc_hash": "e786632023321e19d5eabe2f40c9b1400ccc62c77e2988734d96982e083dce6c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fa3a8e1d-9c6e-4fbc-ae2f-e341a990579b": {"doc_hash": "52616e27c0005e3f371058ac288b1a80825b0b9a12a0949cdb25c8e1f7e62b2a", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "03ea9e79-eb86-4c7a-87db-ddd7d8a95b80": {"doc_hash": "e1f7f1f84ad66bd3545614542f9eccde84acc9f90a405e907d4ea6be02a2fe42", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2bc3cdef-0830-43a1-83db-8f548a4aaa81": {"doc_hash": "ae9ad3d675343b8a7b93b651c361d45adef832a8cc5c16223d20c3753db4c60c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "100bb1e2-1a6a-4712-bdfc-07694f518a1f": {"doc_hash": "abdd21bbfd9bc390a342485860a50856b9ff013ccb487fa1509ee7899033054d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2e244c12-8eff-4d05-b84d-7cfe7ffc3df8": {"doc_hash": "618d03efcbf96ed8e30243779e6fc9f3369e06d0131320ee7dfc1e795280e5c0", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "8b7e8d6f-28d6-4550-8817-61ba1977a7eb": {"doc_hash": "a82088aeb711385d0742073a3a46f8d39fa609f5ab43cad7bf20c767214bf43b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "6e9ef3fe-735a-48e0-92f9-e9e14ea81ab6": {"doc_hash": "4167267128d87c436cd2e07f679c2170f5a178fd3499f5551b259218f0046025", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "65c24837-ffd9-4243-af83-1eeb87f7e04b": {"doc_hash": "c362bf064549cfaab69bd939e37dd801605c0b8ba3ecb8fb49ffb3b380e719f6", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c84adff4-0f77-45c2-9f07-1c799e1b91c6": {"doc_hash": "f0be3d8d1a574e672c6c0c45cf58220e46cf8f5c62bb90b3efd8ea635e88b30c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2115b772-8509-4d77-8f9d-9282082ac41f": {"doc_hash": "c7fd8f14e9f48f9b2b1bc957d559465be2f3e61dcdcc13654f328c824f094e20", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7c5ab1e9-f70a-472b-af4f-c3ce8399578e": {"doc_hash": "85cfd7922e233e4876089ce7be9c1d474e08c62fc6362bd89d081ec517b77237", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ff15a545-95a9-491e-8fbe-1c0f1435a9e5": {"doc_hash": "309747bcaaf20aae4a32abf99b7d3eaed6bbb537a90171c4d23a3b740af62f6f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9495b846-9914-4797-8427-651d38d839f4": {"doc_hash": "90b81395292c92376aa159d7fcb5df97bb5e952253e437c5030c5ded27f235d4", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9d1cf90b-dfaa-421d-8087-62572f888b26": {"doc_hash": "fd029c07c0d31c140e8dcca2cea8de1b9dd12b7d26903318d0795c8c5b41a130", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "71e2e835-a40d-4238-bdd5-3825f506e252": {"doc_hash": "4a20a41a213bcf599f551ef23f629e74d65a3585e271bc9dacb6f8bf620360e7", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "57cf0d00-5651-4a1a-833e-77281d3f812f": {"doc_hash": "8d5416927aac2b984cecb0cf2287559a84efd35b7ad5757ac6a9ba3f21e8f10f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d4169122-5b86-4624-8283-0e7a93f50124": {"doc_hash": "1400e96bfe39306f224ac821f4768cd41900396139ac594ab5587a8444edeec9", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ddeb8977-929d-491a-93b4-eb9dc1001373": {"doc_hash": "8e6e51eeb2d05083a7b749191657627ace825ef4c769176d77e84bf693ed667d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ba498d18-3a2f-4d6a-9e14-2c1ad7ebb655": {"doc_hash": "17cf08175f5d28a9e94d5b2489003d10f73b3ed6458fc30269c1d68b1e8b5625", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b35277f4-aafb-4163-b251-f09441c86327": {"doc_hash": "d9a60c76fe7864c3a4b9f4811bb1343fdbc43b7c80545a6777238a72bbe3f76b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "81663b14-04a6-46e5-9c43-4d479f62bf91": {"doc_hash": "7ead802befdcaf5bf6f2e7dffbfa176c4acaa10476db84cd7b8c9a490bc550a8", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "bea6263b-747d-4a7b-8e69-f9fe68c53e9f": {"doc_hash": "06e12d20055368725b22d9c1513af30b305ae05ede8f07c2163ad4ef545ac36e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "546e0c0e-6877-4a50-a9e0-577e6af9fe13": {"doc_hash": "c96ff92bd985f59009b9383ede3bed686e6f75b2bf49d11aa1cc2ca21c2c6afd", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a13cecf5-a466-4976-a0c7-bb95b78f9a56": {"doc_hash": "cb9be2e0581bafb7ad05dbadbe112c179dc66d9212103001fdd01693413f79fa", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3fa962bb-5545-4c5e-b344-89d929ce07e4": {"doc_hash": "81b20af001fc1e8bf13feb9969299d73d34c532079f5882a6a9248811a7abcf0", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3757b948-93a9-4fd0-b2c3-676754f23664": {"doc_hash": "c4809ccaed546479d150d3253252755c3df09f5bc2317a569ccaff1e48b5c585", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c7bb4ec6-4f38-4ac2-8a6c-b3d742e0ff75": {"doc_hash": "b3c2baf8b10b68dd3ec579c54403b851f29b1336318186b0f96210e39047787a", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9ffb9523-808d-45b5-be30-0fcd56148e7b": {"doc_hash": "d336072bf4da397531151d7a85cc1654ea6bdf2ba27b957fb1ffac80c91566f8", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "683129e2-08b9-4b10-84ba-2eb021a15378": {"doc_hash": "3425b963312c23dd0ce0b95d37e184e39e68e7732aad01af04927daf5fcad9bc", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "210b47bc-7094-4519-a2f7-6278801c87c0": {"doc_hash": "adbfe749ccc907199e75f65c91304c336e272b966ddd695c9e0b4a2075c81adb", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "40017e6a-f269-45d2-80ca-66a430022027": {"doc_hash": "dfa863c7eb60aa3a1a3e9007f816a90ca3fca70940dbca0ca130c88bd90e3372", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "33c66e75-86b4-4636-97ba-3268898e44d9": {"doc_hash": "6c455f2102c2f5d9b41e41caf62b0b433de181d3e4326762a88338e1278b8670", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "8ca962dc-dedd-4e3f-a8c0-c8d389e84298": {"doc_hash": "8cb776e571e4e6fdab2cb8c46a30b7a840069e0e3315fff540ac0a6eb8896a2d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a1d0213e-d38f-4b4a-aea1-9aa41277b3c1": {"doc_hash": "590632c2d06cc3c6e095a06000be88dd685a7f97e3ca8d45618368c5c5e8b285", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9dc4dd20-e23a-49f8-b57b-97c4a8ff19cb": {"doc_hash": "0959e3290a19336f524866eb546dec82b1863819bc03a80e2f5e6ac53d5bf98c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "643dbdfd-6cfe-4ed0-a892-780a3b985eb7": {"doc_hash": "55b8701856c5afbcd1fb54db267d7c053ae417953a110392c662ac08cff3d3d2", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3cd98c10-1fd6-46eb-a3e1-72d52c1814f3": {"doc_hash": "9671ce6258aca68c0cb9c13bc4dcbbf7d91e86e163aacd5716377600a051eace", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e904659e-e60c-4692-a9ae-9d4e71b927a1": {"doc_hash": "ac6d8516768bd738206f39f78d5d380bd432d34948bf3f0ba1aad96806f00236", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1a808038-9f0c-4b12-9c72-12393769d7be": {"doc_hash": "4652f330332d17fae750a84b412665a8d992bfbd3c26cd083b2d97d5c6fd9359", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a136d892-c327-4dec-90db-51241861a6f3": {"doc_hash": "70a458cd9e90eee79faac4935665be94dcd30ac4323cd38c973a3048d53dde51", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "4849393f-ea79-483e-9afc-f52509a9a5b6": {"doc_hash": "0d7aacaba2aff4f24c6fd632dac87394f12120da19520c154bda6708bca4cf38", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1832f8df-fcd5-4133-a245-f54f51a3e6f0": {"doc_hash": "272fe834103038f919e20c918384c25e95eb9484b1385c24c135df2281161ca4", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9b40513b-344e-41f3-a282-0d8fb50f2d98": {"doc_hash": "b4436c720ef0614fbc93d323252c9c6589345c5665d8a82923a592d50e1c1c99", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "8527d035-deba-4ca2-b6e4-799dc328ff13": {"doc_hash": "386d7efd14f4157fa429709225fbad6efec53ef5b4dbd4ceb28a3faa6783f23d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "27673371-4df1-4858-beba-f8f3f275d7d1": {"doc_hash": "163db9b5b216d6ed0635e629adbb1451717872ab97291bc38dac8e7f022f99dc", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "5e195af6-959f-48bf-9c02-0ea2f0d2ec7a": {"doc_hash": "b6e76dc62e287c90bd42bc0dc92d8270c9fec16828fe5759cbc3496b85c5ceb2", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0024d872-b833-4e4f-affd-91246c7c4def": {"doc_hash": "8e2d67810a4e026d120fad6ab2a03b5d1aab74f64e654afc6fa47ba37729e1bd", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "38b1bb0e-3206-4cee-9253-9de30a59a97c": {"doc_hash": "50e79e2078b27248adebde97e7356bfba1048f8d680fb8a9a75e614e2baa1893", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "8167dce3-dbed-4fd3-92cc-d7c82873d052": {"doc_hash": "9adf740860d87bbdf4004c2e53244c93cef67ecc9f75d36101891c24c38af39c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d85ff2c0-b1df-4576-bbc7-2d0c571149e9": {"doc_hash": "4e67166070733f578e33dd85b2702d6a927223342e7fd5d4bd5021b169aad72c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d87bea31-b41f-47b2-a169-57a99ae23454": {"doc_hash": "74b15c4544f0ba9c731f05e6ba8d3d3301aacf9cbeb3acd8be56a27e3b94ab69", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fdf686f2-910a-4d24-b978-7dbecb560c30": {"doc_hash": "688d0815e23af9444a26392d0bc164a94aaf631c124f3e440b3fc49ec71c0bce", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7da223b6-cb70-4999-aef0-59f2825b1ff3": {"doc_hash": "ef3e57fb3f286d3ef1d7ff1109275016121436e815329107604989e97d020374", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d8915676-45ef-408c-8bec-f06b0ce7ab95": {"doc_hash": "77fe023604a0958a551bd82c1eaed3fd075d9be7e0b9688aa318b96614812849", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1b293cae-24eb-4a25-a5f4-15f93546f2b7": {"doc_hash": "ab11455510a784b6dd41b2ae7e39bc0c4b9a7e50167b95282491552af73ab0bf", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b275dc52-6c6a-44c9-9c56-1dafb2bd36ee": {"doc_hash": "d20de2a48e003fb9a304c85072e9f1393970954a278e32b02c2f58da77ab467a", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "731e143c-8837-4cef-85ec-9b5cbec72510": {"doc_hash": "d0b85a60ac562400b69b41a57656e69edfd587fd26376441f8212d4e626bfe26", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "404162c3-2736-4fe6-b571-41b7751a7fff": {"doc_hash": "78940fd9f223f39767f0ad533f0325617119c11e0549246edf32464917217d85", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "eb48d6dd-d417-496d-8f2c-2a44c91bb67e": {"doc_hash": "1092fae78ff24f9c7d9726b13c5a6a23fbb1d34cfa1b7a52408104685d29d81d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "dcb7d909-bab1-461b-aff3-488736260ea2": {"doc_hash": "56ae7bdbedc0e9c8afef3581d0b4739f49d851bad24a8d5c88d521324fb78eff", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "8391ed98-00ee-451e-9a03-b801190d5456": {"doc_hash": "235cb6e6b3c4dacf0345967242558f764cf977f75d5861a0d325e31c3db2aa53", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "61ffb61d-ad1b-42d9-be24-10c966579ce2": {"doc_hash": "c64af7481ddf6e01ad5f4e7ac59c7905840bf9577baa3a6cfd909cb2d8b66558", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "29516556-776c-4ce8-82fa-7cba9f49be79": {"doc_hash": "5cb3762514e37d46ebb16c74df917b400cf99101eae2409904bdb7c04d80e418", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "4c2a4489-d811-4b67-a762-865abadd57f9": {"doc_hash": "a4c0e7c18ba73208f81bf4a84ec080ca7cefa68036265dbee53d38f03283e0cd", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0e095c44-0846-43f0-8856-1eca7aacb70b": {"doc_hash": "7deaa958bda7105b4a23b9e0260e9d19768eeaedcc4908f29299bed1e7f0600d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d761b3af-3655-48d5-87c0-779853445479": {"doc_hash": "160db5f4df7293bea2b0f3991abb01480b98f042ec656370146741421c2f289f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ffc66e9d-80e1-4b4f-adb3-6c7a0c57d752": {"doc_hash": "cfe40af21d96560cf405869c2656a52f4e125402e666f410dfb9f2d0a5748499", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d3ebdc93-a33e-4c04-886b-52c491e5f78f": {"doc_hash": "f41eb8c80e18bcb3b96a4d218212840c0315ce339e28587d21ba763951eba448", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "6f23de83-87cf-4dd2-a932-ace03c8c56d9": {"doc_hash": "f50e0cf2ddd34f2b13a2e35b9604717c1fdbf1ed0f77c6e5223e6129c178eb42", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a1f5496c-c780-4073-b394-ace49f9964ef": {"doc_hash": "2259afa671db1a99a7874c44e54004ef1d8c7785d0e3da2e1b1e8deec2b96125", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "10211d91-9ae7-404c-946e-cf40ea3aef94": {"doc_hash": "c5546917d44e539417fea880fa0dcf505745375444821f78883a592dd3786695", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "18a08a9b-7b9f-4b09-ac5c-af5fa10ff3cf": {"doc_hash": "d913a33870aeaea8a8a68869a5c2359295f4e8dcf1fddf5f18bdf3a5d7137b12", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fd13fe4b-ecd3-4a3a-9590-5036fd87c338": {"doc_hash": "07eebde8571c1fbc79d627ff6f8dae771e67a7f8cfac507da429c06b291a96cd", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "f137b538-04d9-4b12-a449-9fa9d9a1193e": {"doc_hash": "1823c55b6eb64b3a02c28a2bd5945eed8064cc038e83c8414a8fdad6273c6355", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "758e590b-5a22-47d9-94c5-0738db8f6d43": {"doc_hash": "4abaf70b3a0b0fb01cb53260ef0b3d079af0b5f50ab9342856b10bbd07adc9bf", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "71a7ba79-fafd-4a22-9eee-b6f0135aef1c": {"doc_hash": "d11ff43d0aa3d5f961c424256dbf34c55820ff161f91b6754d24e9471168fb43", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ec50e8ee-346b-4904-817e-cce8a8829bf9": {"doc_hash": "8ab4430d8c2c68f17e56e53c1a9b4795e297da3620567821c8c207521b150986", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "57961b04-9358-4554-ae3f-3a8dea55ec6c": {"doc_hash": "737a1edbb00cad37f475f801ece10fef291a3bcacc669c498883a103b0484b45", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "50eb6a2b-3299-475d-a63d-2273ddf245b2": {"doc_hash": "78f5be8342d31a54a0c41a192ccd1463f5c36bfbcd4d852e58ff75a50a2404bc", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "29107840-2bf5-43c6-b33d-17a520f61d7a": {"doc_hash": "a0b94c0722119d903388adb3ea667a6d21a6cb54e28602975b7485df7a85eb6d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ed4a7b55-44a6-4d88-b9ee-e278d300be71": {"doc_hash": "a04b781da4a15c9074fc03923ced66da59a12a6c8f9d8f41f59a7e86832904ba", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0e0a4085-51c9-47bd-b355-1ec9d825c61a": {"doc_hash": "a6919b59a61abdae0f4bc9bd1d832304613305dc8f22ee5dbf5ba3c1fba656dc", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "dd481b27-c04c-491e-a3a6-28665f177ee5": {"doc_hash": "da8903c78843e9ef861789ed2ea84c92fdd30df179b8246fd54e5d995ad01f89", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "28fb0d26-ed06-4898-a099-44b4f9af5054": {"doc_hash": "09f19e0a4d387fd6c691628eafe56d38639febb2c38bae4876dea958fe77fdf4", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "6af41214-d677-42ad-9247-e888244059cb": {"doc_hash": "070e30d93b3de7aa3f7860aaf23d15c65467e0d035f859d8f1a5e0c630a8fe2e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "24029408-8ced-4525-a4ad-b40c9aad9fd0": {"doc_hash": "72489a91152562d24ad9d1039599201eb7cf071e03369007b61b0b1ee0e31fa4", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fcb0185f-dbf8-40ba-924b-8fae181b073c": {"doc_hash": "f793a2e84c263330c4180915254053255df6d24f3fa749c0aa3cde67e3147768", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "5e4149ba-612a-4888-8e4f-e9aca4be2611": {"doc_hash": "62fc713a0cfbc8dabc49f844202a875a1c64d618cb5a67d97e93c94092feaa58", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "08eb9bca-53e5-4359-baf9-7ad3e9d8e3f9": {"doc_hash": "4ccb0c0fed5ae6a2adb85b74dc8a91bffc8fd55d2b5812b4827faa3f3b441e5a", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "aab111d3-5a77-454b-bde9-9126ccfb096c": {"doc_hash": "716d9ea19f1f0d7a411edc7fa1c1680f55b46e885daa6c02b1e95b72700a59ad", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "717f6a15-fd93-4b21-9a10-f3da311ccf80": {"doc_hash": "5f80e252502b2d90d6e46fc560a0cae131b9f465a7d52f07a3f5b5f5380efd66", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d87f29a6-ddb6-4a34-ab86-2fe9a317e63b": {"doc_hash": "342d67ce9d48e928a3b1bc773aafeaf910638fccb1313aab0f58125bf3ce1a81", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d5696b51-3619-4906-bc37-9abd85ea5a53": {"doc_hash": "63a1b530d5a5fa9a585b6a382d03ae0702007dad2109c3dc3ba2bb161d86f18b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ba664613-e34d-4d2f-8d7d-219b4dde655b": {"doc_hash": "88f3a7c6c1e46a38479112702c4f28039843cea6ce5099ca2a3a8a4e4fa6d356", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "362b25b1-ae2a-42ba-bf01-b0d30f39b0b3": {"doc_hash": "c841b5789953bbc6caa99267f8c453246c86b1e7461ff7162e90ae7f2cc97fb8", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ddfc4157-b6ba-4b22-88a4-369b0145eea9": {"doc_hash": "83b40f04fcb22da2ca4071507e113b8b3d134566dfc9863ce6693f5620dc2f21", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "31dafcb9-20a3-46f5-b892-4741dcdf3ddf": {"doc_hash": "0ba26301d1886bdcdde9b292fc800b500d75b2e736913b4068e63bb20f097689", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "cf73f85d-e095-4d93-8ac1-15a099abce90": {"doc_hash": "5ce496da13acd48b68e454064a690457dd0207e836a07a3f11b10fb1e30a94d9", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "5cb38e66-60a6-46c9-ad6d-f68a7327f624": {"doc_hash": "14559389c06dd823547baa3b0d060cbb778e00eab37ad4769ae1dbb5c43b6f71", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "436560a5-e974-4910-9c44-d0a2d5034950": {"doc_hash": "72fc485c907796da7fdfd48c4600e031149f47a84b14d22f390a65fa6ea0f7af", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b20d81a9-d671-4b73-a2a8-26c234f21e1f": {"doc_hash": "8e2febec3c49ad91dc1b434f033fe7211678b2e679a35e14e018315ce040b88d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b610ebb2-8deb-49db-977f-535a81c03e5e": {"doc_hash": "75c33c13b82688fd85ea979abbe2f773167945cb08135459bbeb7f6e50062348", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "85d3c9dc-5542-40d2-af57-996131303f4c": {"doc_hash": "e59b1fb03a8a608d8262b7f8fe510158e2bc1f37228263970ae0581f4d12ea81", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7e89e79f-4550-4a1c-bd33-f56d6a21777a": {"doc_hash": "cceb8d160ce08778675775d553cd914983a7a724b4142af87a94bf96de4657b7", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "91b4f30c-c6ae-44e1-9fd5-bbe750f6a465": {"doc_hash": "9b4b47346e2d40db0397f3906a2f95d171545b2b6d723c25d4a525e461177ad8", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "5ccfaa56-c362-4bf0-acae-05bdc9761d1e": {"doc_hash": "ea868c630bfdc67986a168472b41fe9d98f3fb9be455bdcdbc6c581969521c34", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7bcdaf01-e30a-45ea-a9e5-b82d9558bf04": {"doc_hash": "99fd419f40bef2d17eab86c583d0726e2923d6acf0c0fdefa9daf013410dd9e3", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "5c2ae046-771d-412c-bda0-3393a696a5c6": {"doc_hash": "6782541800d8fc1221bddfa6348504df6872ecbd57faa5d28c189454eb611501", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a94527e4-4014-4265-9f2d-c50204060837": {"doc_hash": "ef07605a125ed2630d2c917a243e059e1e1a838b35c73b06a5090625cbae0c37", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9a8ef49c-f904-4312-976d-e2b295402e11": {"doc_hash": "7771a14a21a2f883b54cc13a81464c9feaeaf5ae4d47e338ff62dbe1b8378c48", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2f7d3508-4e64-4f90-88ba-a547657a7fb3": {"doc_hash": "b984b5dd35025216f179c1f227d8e7d94c659d724919db2c34d9ed0afd24e0c1", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9aea6539-0d3c-474f-89ca-f26119fdefae": {"doc_hash": "d4e19c6542905958b14afa3de031f5fad48c5f152d1763e2c3181ba44aa7c3dd", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e96294ca-271a-4eb2-b996-1033f856b4af": {"doc_hash": "3bc9c54572ad3b1263b67a39c40444830e6f063d4cec22717b5482c99db98f35", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "aff623f3-f1f2-4b01-b89e-b0252c199668": {"doc_hash": "74e4419a3f2e02a78b011210ca78a9df9767ac24e809d90310fa4d220e520431", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d95a7860-9d26-4dc2-a297-cf7368e8d370": {"doc_hash": "e791ffb08bab5f4b493d23bcd55ff9e8fd09b9d6bdd4fb8eb3fd8e4984cf0cdc", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9b20ef12-ea90-4f6d-898f-f090f2d683ec": {"doc_hash": "067af8ef76d00ba4cef19467f4164855e26f2cad75994b9dd38b846793bd5d28", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d6e2a5f2-13e6-4a45-a193-9680a8b3f024": {"doc_hash": "c5d74bbca97ea58a4d550aa854420ce5113621231563943b1f571b5a2c1f6a7e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2cfa4121-8687-4330-ae60-7acd5c90c175": {"doc_hash": "3df2d6532acf0c30a2e0fa7a7933939deda82a93fc959f9cb6085496225f1325", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c3470aa7-69fc-4ca9-a6b5-69d9015cbabf": {"doc_hash": "ccff685ecc79c6e82bcd877043027eb04efbc334d38a11d73ec0aa6cd06948db", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "6c826fd3-fe51-4d34-9d6e-d3be471307f1": {"doc_hash": "672d0f18f6b2412e36fae1b0341b8bd42108d08327de201f74797af1dec34b26", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a1579f83-abc5-4e54-ae01-4f2b4e50bff2": {"doc_hash": "49d2f4041bc696520362eb5b671a40eaa84b5e237a0943da748636551aa6890e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "85011d4b-a961-44a2-9bc6-c16b28b4fa74": {"doc_hash": "ffb727f8442b2f66757e73b5e4ac58f5f6d6f1fc83f729da96fac947b8fa876a", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0742ec95-a573-461b-aaec-d8cc5a6cfa82": {"doc_hash": "0c50a142aaec2179c423c805fc74c1c3524b90d4c70b21b2f22514f7288b0494", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "5d8e209c-8ad4-41cd-b7fd-5c06aac5ee81": {"doc_hash": "69e02139e8ec291ec76a051a99b9d9e9a6e18d83c46650fc0b89fdf843553506", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b42f59fd-091c-4579-9792-51645c108dd7": {"doc_hash": "4bdc0dad69eddf7a7f3c0ac24be9ac69ab5f8f0bb1e575934125a8f9cf42f324", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9e5d968f-e9bb-4018-84b7-5cc22b9acf9d": {"doc_hash": "d296f0c2828b33ac18b3e820058ee47753488d0e925a7a9af13e2bd128799209", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1068d22a-9227-4c98-b10a-60b728b278c4": {"doc_hash": "8421c9991763a329c856004f230b750f912a12655f75e1d25ff455493f85d923", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a456d989-0671-4f8b-b2e0-f59f3dbfda16": {"doc_hash": "591e524c8ed2e897194e534c15b0ab2938ba0a628e34d46e0c831a5735d8cb85", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3025ae38-324e-4b42-8ac6-cbbd067deb63": {"doc_hash": "67b19c0c012b5db0f1ddb6d0259787e9d02aac44f5e52236ceaef033cd31b9a0", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "42461474-7491-4d56-9021-ccd0ebb6d537": {"doc_hash": "ad1da94c23c3d5980a8f24e251bd8a7d5652d11ad9bfdf49642153a8fd437c83", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "03a96b86-71c1-439a-b005-0fabbb0c29bb": {"doc_hash": "1c8223a96883aeb838df8482fd21aa05618545cbdf14470fd26c481f5222287a", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b87de440-03fc-439a-b84e-86aea492da7b": {"doc_hash": "9b0e3efa8b0e0b23f41ab563767440ff37e796d9d8e42c40edc4b08063c3f5a7", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3feced31-14f1-4a7a-b2d5-36c9ad3a36db": {"doc_hash": "11be3bb31e0a2dc0398c76f6a4121c668f193e403e785f04d6461fe65fcc17d3", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "be4607c6-9c12-4dad-b226-ec6a1ff03a17": {"doc_hash": "e7e276e6844a144d4a81d624665e55eb92622ee3e420e4f8a7c762764cb5e6ce", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "13a6febd-9565-42bf-bcbc-9fb6623c8637": {"doc_hash": "5aa911572b57ab0c423024a417d83f913051ce5c635f329236bc3e4cc3372ce8", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "71765722-539b-42f2-8781-889529263c05": {"doc_hash": "f7b711da14702fef597bc3a40c6e6e86b74acb15ba97b069ec857170cf000316", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3f0eaee1-af63-4bb1-8f56-7c949fc4286c": {"doc_hash": "f33a47486dda8119e992f46f7faa38d936f280d92ba2cb901c0bfc9ce3287135", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e7f97ad7-75c0-493f-9152-2122c7224606": {"doc_hash": "311a0ba35471318ea6328b702f755c4330b18394050ae0ca09cf75cba8233837", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9a792f79-dbaf-4fcb-925a-26a7bc0f88ce": {"doc_hash": "b7221dc9b3b72d6a3b326795c861745e5da1310be0d8fbd365ee48f0b68bc804", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d292bce9-817f-4945-ab26-222dd5544c0a": {"doc_hash": "03fb25704ee439b9efdde60ae9f284d927ff72e9b47d3b84e64cdb335c9d5564", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b62a9260-a482-44a9-9c36-96ae2fb536cd": {"doc_hash": "4740e1bb52cb62259e307a7c0047256d08d520ca7a31a55d0bb8c45c461a9307", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "40c285f1-c60f-4ae5-93ff-5a1c3eaa38e0": {"doc_hash": "c862060fc28065de50f6b7488c6882b926ba13da8e1052ffd7c9b1dd96a86ddf", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0d69bb94-5121-4932-a3f3-4835db45f0f3": {"doc_hash": "204d72cff2ed8fbef8454142baffffbca18877251f97c9bfc93b2b00b2cc130b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e7b06f7a-090d-493f-b4ee-b5e1ae15f3c0": {"doc_hash": "bf6695aeefddf1d661942570af7eac4094c90e744e197b2a8491c93c4f69caf2", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ad7cad6b-46db-4336-a5d0-cf4bca1889ca": {"doc_hash": "feb587251acbb23a161f7cb285cfe58c73e0eba902051cb15ea4aad5326c6d40", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b75352c8-a8bb-484d-81af-d1b615d9e5d4": {"doc_hash": "bf4328490c0b852f3ea4baa5d4cd799ea09ef9ad8c0028543ffc80b13ee83828", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2a0b1413-c297-4845-8f50-887220c6f48e": {"doc_hash": "ac1da532d86ea98c25438059690a7a331618f40c8e3124358660771764bacdc9", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1854b75e-1faf-4491-95b4-6cc73bf2dfd4": {"doc_hash": "c97e80473a71e97a52517dc0029b1c8d2a1c3fc05fc41ce31567bff235a44f5e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "278211b7-2d8c-41c8-bf27-316ca001f527": {"doc_hash": "a4fe80bb8cf32181bd2da036d3d6a4280d6538d56351b86f32eaf3a3ca2d6b43", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "78234772-c54f-414e-a047-40a991152d53": {"doc_hash": "244e195a8cda0d2ff46533388122451ebf2a34e358ba7b82072fe72721381362", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c001f618-7031-4d55-a2e7-bf9ce23f658c": {"doc_hash": "4c7df1dc123aed17b52f453d5fa45bc6c1f9d8e373502608f5b5f266a5417191", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fa4f03f8-a7af-43e8-91c4-b4e0c879a814": {"doc_hash": "9bdcac51a09be941d8292a7a3376905f58a0254f7674a40036da7bfaf9985a5c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "25ddc4eb-6ecd-4ad4-9378-44b79b47661f": {"doc_hash": "48b65c36c91d96cd16c4a0315120fa2652d128007de8581fd8579307d188af91", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "4cf04562-8f51-4a87-9a36-5ace5410436b": {"doc_hash": "384a31b34ee63b51a3d08209098a18aab358ba4a2130919ada0010e356f6d5d0", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "8609a38c-b9b3-483a-b596-d0c11beb5551": {"doc_hash": "80b45c071b6e401a13b88d4c529a821d17fa26cd7e93e3182c2d3df6430c066a", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0b422f79-ce42-4436-b3e0-0efbb204de9c": {"doc_hash": "b6bcd167fcb9403816859ffb78697092438aa55cae795a09acc264bc87fa9577", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "981098bb-eef9-4fbf-a02a-b45b14c6e7c6": {"doc_hash": "1a0ca8af08d7abf09c43e2880dd38c42214103ac507847576e58b1d0c58ede00", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9724efee-9716-4bc6-af76-98cda7acbeed": {"doc_hash": "36e5760e544dd1118c792579ed869c7e916d1d2996f8efd47f2f9127fdbdfc7b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "8d8a1f93-c17f-4b3b-9b54-9a020282838f": {"doc_hash": "46cc181b6adbb1ae60e092394971c087b1d8e757b5263f9ed4b70c0a0ede1387", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "bb850212-4186-4087-9aaf-7f2c79b9f1f3": {"doc_hash": "7e4d6b60b64e08c20e41599b83bc6d05ec8f15eb5d41dfde6f2451ab26b19e57", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a7c4082a-a126-44e6-bd05-abf0284e4f63": {"doc_hash": "46dd498632fe7eeeaa04e1dde98b6bc08a0330bba4450d8a78f41ebdc0a188f7", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0e2bee3e-830a-4f39-a9c9-0e43a3ea562e": {"doc_hash": "e70dc6e9a78b6b9ce81a3116dbeba320a203d57d93f662063a3b84daff23f7ca", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c503baab-8e2d-433b-980c-37079534d9fe": {"doc_hash": "69225d1c9ac11aab44ff66bf6ee7bb9d8b4c5495e5b1d05f332f60375c0a0c62", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2944fa4d-855d-4953-9eef-5c38053be67e": {"doc_hash": "2568b2ad88f077d6930351112ecf16d61626b313ff86c0ca8b02860f246c3c29", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0d801766-8ee2-4561-ba6a-241ece43bc84": {"doc_hash": "77334db99b161d8b5ac4a1d3fe77e2f146b386531bc932d41fe0690146096159", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e11ba821-b3bf-4744-a088-c7a79d6032e2": {"doc_hash": "966d433a53ff5bcad03057b925d6bd77931bc5ec4763e1ce1420e9a83b42743e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "aa904af0-41f2-4d28-9e10-1a0a286a90e5": {"doc_hash": "ff3746354ee44684e7da909935c72a472b90b73f52d7b152225ff42c6cbdc725", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c88d4d0b-79cd-4c30-a93e-d74aec5d7810": {"doc_hash": "218092d25d27d7bf819d39563f87da21d47ef326ef674d6f98693357b18f99b8", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "05af1732-21c9-4b11-810f-17f8b32c4509": {"doc_hash": "603fafa7631dac18e1b4dec5f6eeabb89e8097bc7bfc428d5a386003463bf7ce", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a4129773-b553-450a-b270-48acb3e0e609": {"doc_hash": "206546f9b560fbfbc1b437c30b93a2e8502a490032efb0798c73c25b7a2f224c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ef08a95c-ec0c-4f73-88d5-243a16ceb8bc": {"doc_hash": "5a8f226163d67056005cb2d23f8d8f1251bfe5a329986ee2804b9ada692fa229", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d7b73331-45b9-42f0-b0cb-99336330ea1d": {"doc_hash": "1ca5f85bb3b7d342b5489434c2e4206ee73062c4da43baf10851ff612067f596", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2cdab69f-f41b-4253-b20e-3befb4a6bda7": {"doc_hash": "6185db19e3799dc7a604c1ca1df699c02cef028da2b075a77a87971542b600e9", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7908bb46-3f91-4f90-a6e7-49a2221d2055": {"doc_hash": "578f9ab12e08d050ccb3d7ba03c8be7e40c51969233ae8f38d145a6620146d68", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "363fcfb7-4786-4de2-b2ab-89a98620a6b2": {"doc_hash": "5b207660ff14d588452105b96d6e074747b823ee63473c98cd81501bfb8157c6", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "f57a25b1-d70a-4107-ba24-a04b31ed45f7": {"doc_hash": "dc7656f32eb34af820113e0ddcb21350f4d4247e495fadb96b06f5933fb08dc0", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "826e1233-b776-4ded-87fd-851c0552ab1d": {"doc_hash": "1ddda2b505baac2a1b13f354e7cd543a0668b77d3a2aa62124929e1b9439b9d1", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "418f078d-d7f6-461c-9b9a-f67cf581cebe": {"doc_hash": "8554299dffca76586878517e8a8d1395bcbfcdfc9a6d8c675df8153940d71611", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "8a70e728-d913-4271-867a-3ba32ba5f3bd": {"doc_hash": "78b68caca20e7b8353529510bc1d504e32a45df5ff1e42726aa1043a98218fcc", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0a3378e0-8042-4a79-8c32-9fcd4a609d7f": {"doc_hash": "5d533423a3313dd587a0d7358805c070cb0b4a106cb48c0e142eb76e0d54818f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0585fee7-2d2c-4630-a9ae-be6659344b91": {"doc_hash": "bc6007c5c62e320c7a3164d415c03a777c54ea5652976e789d394ee483af7e02", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b8674ab9-13b1-4abe-b2a8-c99fe6f4ea73": {"doc_hash": "4396c64a9035194e1a9c6c25835d0f127eacf86eb0ff7286672e9da25fe3a6de", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "87279993-ca14-4b2b-8e7a-a013724a1b94": {"doc_hash": "8b5acbcdb62201a21dc17ee4e5ec78b794cc1bd6e7e81be00f449d316f904175", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d1441a6e-252b-4a41-b843-50e0f3bd062f": {"doc_hash": "e544b97b420a23f27ab9d0d932d89ed7323c5525599746914e3dfa51422eaedc", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "052affed-9bad-4a95-9d16-e0320f67c43d": {"doc_hash": "1cd22cb53d0a7602e3b5eb28e05b7a6c7d462444e6ea56df0bd97a049da59686", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "814d44f0-c7d7-46de-8c0d-0cc3f3d7cc3e": {"doc_hash": "87fe78d0817c9d206ab3bb7e7a0228d0376b9f3e6b20529c04f25277f60b578b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "edde0b2f-02da-4b61-b3a1-d348823cf101": {"doc_hash": "e8043a58a1fef0dd733488403a3fb2365bbb4efbb31ed46ac2d881b58d0baa46", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "179d8a33-a284-4718-be66-78d7af07c644": {"doc_hash": "40f423fb9ec596440b57fcbcdf37d4d97b528189c6cbc711998254f00bcf10bf", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "bbebbddc-2ed2-45d0-99a7-0640874e85a2": {"doc_hash": "8b82e5b7e8b2cd0d2e059a32d8e3fb47f273d191a793d82acae26cfa7cc4cf52", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ac2bffca-da33-49d4-91b7-92596e979138": {"doc_hash": "5d661fadcb3cbe316625d6b128699dde3be0e4c3ab393f86260cb10213dd4d38", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "55754304-bcbe-4e76-9cf2-940fcd16f611": {"doc_hash": "5c8f5b13de04ad0592b616655c32c2b465d1fc43fdd9470c90204d1d31b60579", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "116d199e-4d69-4bb0-a0e1-e638c84e0e16": {"doc_hash": "5b75fad08f0e3600c4fe0f7066036be3206eff540e5e7db71f5ed910ef3c319e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "5e3d7301-bc24-414b-a172-8bb1c98ba632": {"doc_hash": "117d9f0e6206ac0da05617eba6350b82ff58e199b5f638b7c35707aff65e76b7", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ea06dfe6-3024-47a9-b42c-5ffa407255c6": {"doc_hash": "a1d02a37b6939fc11746fddfb2097018952a8a5c2b9eb2c8f4962691e315f61d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1e06d94e-ea09-4ae9-ba40-4d8dabe22721": {"doc_hash": "47d787f01c1e3f6183aa21c8337ab8689800c0b5c289bcbf7a8ef74a50a8401a", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a4634d29-0704-4b39-b474-82c80c9f1869": {"doc_hash": "dfd0319f5286dedf404abf42f929f373cf0efbc1e07d07a3043a1d739df8c390", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "19a53f73-b11e-46ea-9841-6045e4686021": {"doc_hash": "ea777518a99dc9d75d5d026bbe604a0387e103ca6e105ac7e7090eaf7f62d2d7", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3ee8d4fd-0d8d-4d18-b0dc-5c7bc9409e39": {"doc_hash": "ce173d622d93e2636e57e1f9b63e3dfd4515c6a3e6a3b6e9be5acab980837b56", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0031de93-b481-40f7-b3b9-7ab1d6b9b19d": {"doc_hash": "4801141dde0a7cf2486740cf3ebeb639f6cccdaafb6566a951baecb7dece4d6f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1f9cdd27-0a10-4503-bc43-02dd47723cad": {"doc_hash": "88427ecb527eeeffbb312c8edac64bb052610ecc414d3d735ca08a65971b3446", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "738c3606-b3fd-41d1-b6b2-22bd25b1dcc4": {"doc_hash": "7c9fa0d29e569913b5fe6b146e443b00b5125b4f9fe0288ee94f7ce4058b5e6e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "31cd402e-372b-489e-80aa-160a07fc3d1a": {"doc_hash": "f8b258542d3965b4ef7a4483f182f09ff0702900e2509fe57a01028f14c28ef8", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2f918556-7c48-438d-b25e-ab9fc4ccd98e": {"doc_hash": "5a9455a9289d375d94c047a5148ef28c6b74b6ba13847d75f94ba2e6ac0cada0", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a7b99c9c-8ebd-43e1-877a-df3dd25fd951": {"doc_hash": "a498041f8db40faf6f6f8ddd47fb2af28446fa3122c94d9d815327010b6f3fa9", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "cfe051f1-a6a6-45b6-93f0-3d19bd8bf0f7": {"doc_hash": "38e67cc4789bc75c2935dd4978de9c3b4d65ca3ba8a3f948951d6061e8ab860e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "8f4933db-2e33-4ec0-bafd-6f16126e2e66": {"doc_hash": "56e6d4afee3353f38b49cdc8097a1b80e0962bd6ad23b04f3730e56937a737ec", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "29155992-b3da-4b80-9b9b-ce9b61a402e7": {"doc_hash": "dda07aedc052a3a7d0e9a5893ef891a03215135e61169f59035d66061aa01efe", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a57ef517-064e-4ce7-aeb6-0c8b2a5e0239": {"doc_hash": "e19fa9005f0d427198dc8697735f100a320c58f192e06e3a55368972cb9ae5bd", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "4a357617-06d5-4c3c-83df-ee4980264dc1": {"doc_hash": "2eda3bdaf40d18a225d501c88676a5168211b4e2b5a7014e2e15e385fe634fe7", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "cb2e7194-1a33-4487-9872-5da78a79d5d1": {"doc_hash": "72724c3fedb94b598439b951ac7675f21e0e9a8ae8ee3760f92f1e063e1999f5", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2184b767-f43e-47f1-a833-febe4e6bf134": {"doc_hash": "958102fae5df58c408917d74c4eb5ab415e0b164693640b839440fd0421ac74d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "8332ea64-2f88-481d-b28c-bb63331070c1": {"doc_hash": "693e0f01eb870b8aca47a7f3e4e4ebded814f04ab7d3adfcdda4d9624862e29b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b6441abf-d574-4d5e-9c3a-adc3042d5e65": {"doc_hash": "3726486133fae6db6179c8cf3f7fc2a775c1f3d7724cd8a627bb64858838a52c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "dfb4e10a-4700-4940-ba7c-ba2be17b0770": {"doc_hash": "194ea0783f77b29462d7620febc2a92d8e2967cf1e8318aa8913afcf2c332e16", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ff30c03e-8e04-4adb-b67a-152e29242a6c": {"doc_hash": "ff612911efea21c2c54fd51c45229ab0245185602e114d3292228b226ccbbe02", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "6fd9564b-551c-4d8f-952c-d1d4fd208214": {"doc_hash": "2c6fc41186e74f0195f2bc6178a710c37e617430b8c52024a068de3b80b2121d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "06bcccdc-bb7d-4f35-ad87-e46d77d8eba0": {"doc_hash": "6191da0b6ab0dcaeb27ff476a3c333bf6ca55a302b64d2c3ce62e341f46282a3", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "eb31aadb-e3da-4c00-8eb3-fa3591317426": {"doc_hash": "96bf390896002d7186927c9333e0db47085a23d75c6878864aea6f3b1426cf3d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "582f2e27-ae44-45a7-8546-e2a0a15d5d8b": {"doc_hash": "4ec43a10a373212ac345fef72cb2de93d35c483429b40a1195da6aea5925f4f6", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3f2dde09-9003-4df4-aee2-156d94662d33": {"doc_hash": "24fa0856fc8849e0afa6caa19867f28382051530493ffa756d1af6ae1177422d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "42f2cd88-9c2c-4f03-aac4-547373275ce9": {"doc_hash": "613e6ac28753121c4170c2467808ca7db9b52078fa482541ba794d07a9f26708", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "8aa42ac4-0f80-4350-a0f0-2258a3de4a7f": {"doc_hash": "87b9603f3096c4877a7d878c7aa380ba948f9b2750a0ecb1886b024e27afc36f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2c40f651-abe8-415e-84a2-33daf2d4143c": {"doc_hash": "abf420fc9fc565f2eeb3191c09fd1b845ef27b2d30c6f802d64458c1f7b4a4d4", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "80d30081-2dcc-4dfd-8e12-4adb36a7c2b1": {"doc_hash": "bbd54eeae10482f698c1f703c0b869ce64f11d59eb32c92e6608903e769d8328", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c95c8429-7190-480a-96cc-5b2ef8a196c0": {"doc_hash": "05d5d64d0d88ef4dd962a8885ea2e180204410837a1990e908f318fce53ac4be", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "be90c87c-7f20-424e-90fc-376920aeb72c": {"doc_hash": "8822a83534b551ba17d1f2ad4265ba481900d349b58ff702118bb9f39439658c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "00a98829-b011-4567-8ce2-ad6343d89dbf": {"doc_hash": "b679fe8e9025096d57c9cce6712306bac7f89b3f032218cb2f3498da5ec12b22", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fe5c83f0-d7ae-46c0-8331-c20472872894": {"doc_hash": "8199043aeb7a26ee7e7043f646596b5e0aee20a8a564f12ac6ec66b6734d4e36", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "96b22698-fad4-44ac-857b-96b268f674b5": {"doc_hash": "2cda572fad13623f2ad1fa0b98b28978e60dfdba32c79bee6b82c9d72439a047", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "409ac874-db56-4595-8e2b-3b30bd458cda": {"doc_hash": "1171eb0b2a782fae7fb82a97fffc466885fbc287809688387500dd7fc86af036", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "6e0c28b6-a032-4435-b6f1-a6bd8d31aa58": {"doc_hash": "cf88a8581d5eb394fe4c80f6b995318a76cf55e361f83fc4059c5b6f3041d67d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c4245eef-9049-4d32-8165-c2b9470186b4": {"doc_hash": "04dd1ffde3bf68ad7b4c144450f69f88ca7413d609f3e6f499744a9d58656898", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9d0f09ce-7f75-4b77-8bba-45919deb553b": {"doc_hash": "70fc432b69d715cf741530c20df9b72800b23d7ded3bdb2dcdd7ef6f7c6f6f0e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "6a66994f-4d49-405c-a29c-a9d5f871913c": {"doc_hash": "91c231a3bac343794249bdeefc8547f3a51ebc574e3440e03cb863b4d87722e5", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "38624caa-3343-41bb-9b59-1701438b4e39": {"doc_hash": "c10291031fae8931b08407452f9ec80e763022fd8870c97c143c34f315b2350e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e5c01dda-7094-44b3-9da5-abe2ec0aa7f2": {"doc_hash": "4fad0c0a0b2cf5366977a4e1d7a86913ee9be4dead26f74ea3ac1acb40682dce", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e15971d5-d03f-44cf-9bb7-77e06e78fd61": {"doc_hash": "04db4bc61878b6758c587e96ff7b07894f097711f3c085e734b8df16d757be57", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "301868e2-73d9-4ebd-95d2-ab13bd73be75": {"doc_hash": "ba4c70ff137592b2fdec9f7e8ed5918f29ecc9a7dedb268c8f0b8b27ab1c3aba", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ea876c21-1193-4daf-b17c-d5ec43f481ae": {"doc_hash": "10e3e0382370723aeff195e1c8380d657863c8e4c3443c1f75ecbe40051ff397", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "87adc65f-05b4-4387-83df-33ad9c68108e": {"doc_hash": "2cef81e8bf8961f599b9ef9bb0215f2cf7c1bb14350466006a39ca3b888c378e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c8a4ae60-4e1c-474f-b2d9-dfdce19e50c7": {"doc_hash": "d4a2f3173a5d4cac7d83180f42e2b8a1fc68272e200a23a9fc09d248329ac56b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "6c2e8c1a-3510-416a-aa59-abfd57c1fc9f": {"doc_hash": "fe510788435b10011adba4a6f85a4485d00b3ac5b6e2e1e141c0b22f9c6ceebf", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e58ea5b0-30f0-4ae6-863f-d7b0c9bfc306": {"doc_hash": "ba2ce99a367b62fd6e0f176654335c5f5912296206eb2cc8998b245f38c66a1e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "30b46570-c0ab-48cd-a15b-8f18a3023c6e": {"doc_hash": "9007c0caf82917893a176d01e9a68c3e52ec38dc3c3133bef0b9b59cf9c9b61c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0c6c2b56-2b1b-4023-a2e2-4e60bc1ead9e": {"doc_hash": "df365f754194691938861b7238675f38a5f5b2d89b54923becb35964a819c757", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "6161a539-ad9c-4ee2-8740-d6602bb43990": {"doc_hash": "4e9fa352099e463fd6692f346d006a9c46d34a65b555ab4dc7bb249c44a39555", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e31e278c-d1d2-4198-97fe-74ddc7835c9d": {"doc_hash": "9b4e9c57f9770f13ff0f330b83697af7391dd4e58727b085fa0c18dcdf87e503", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b666e30d-dbf0-46aa-bdd8-26d5defda016": {"doc_hash": "f17b7aee7092a1338c256d98950a96c695a1acaa3ef4e2fa76f02410ced10682", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "de91eca8-1f38-4e8e-8123-00f4dffb6e6b": {"doc_hash": "bce268023ba4b4ae0be4d8d7456bb45657718004776d8b8133f0921b06108a53", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "716d466a-d6d8-4d2d-abb5-ed754f4de062": {"doc_hash": "4a89cb66970fa87fc2c73bd15aa9ac11f69b7e1e142c9814852efb13ba30e67b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e0fe5a01-0595-4b25-bcf6-8fd87515d906": {"doc_hash": "d61e1f0f5be0d8a310d137bf4966293646d376db5f192ca5b9c08cf4e3b73bb9", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "610baafe-749c-4f5b-a6aa-66a8ca91c7d9": {"doc_hash": "c5c0309416ad439bcd9c2d996fc29cff2a199a86de465ef6eb1a73847c80f9a8", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0e6a003c-c742-4e00-a6be-c4801b3bdcc5": {"doc_hash": "5f23cf2d1f8363cdb41510c8afa694303ccb425a4053d8bd76cece5e2f980462", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "bda6cfaf-92ba-44cd-9f23-88e29eeda142": {"doc_hash": "598ff6e889fac0d136790bd40b81e91390afe24f0e2a9ac8ce1053a256ac14e7", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "6602c357-9540-41f8-9795-01c5ca99552d": {"doc_hash": "e6c8bc7307237a26d40118df611094db27f02f90b6c53936dbdf961406bbeb86", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "92498833-a69e-4641-a86b-ab83b59056b6": {"doc_hash": "1cb03402f4c26685aab84f7df62dbb9621a2c2764b023be8b4c257c3975ee056", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "699dd142-9901-4c19-bd5b-b35aac5e1531": {"doc_hash": "d848bbe458b71b24f4636e9e942cb5807ed55641179c8285ff849dcf1b05e136", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "4ce97d59-9318-4c6d-aef8-5f84a22fb1a4": {"doc_hash": "4b33117926e9ce030d46b5e171721a9e1c65d1d5c093c6f1bd42dd6ada2e82f2", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c4272f47-f0cc-48fa-b821-a7dfc044a0a9": {"doc_hash": "40e1db2b6c7242e87329ef111ad199d795e81aa381076f934b6c6c509a21b6ce", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "99f4b3e1-a4f4-4143-bad9-d1d808fa7175": {"doc_hash": "13962a32247f225899a45cf3ddac7678de5e5a230bbfd48399662fd2abb49be8", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "4f32ca98-23a4-4377-8530-b48a9339975b": {"doc_hash": "30f9a91b73f402f7d7d88c5c33ad0a757c49118f91e165749463f21e5e102997", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "704c5ee7-4817-491e-ac00-1af9edb0e4aa": {"doc_hash": "362e3459b84b6fa688f65f3ed3fbc536c2a9f1a1573d5c1939031767c17393ad", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fb215f6d-b4b7-47c6-80f7-fa7606a75733": {"doc_hash": "d45eed5d41907fb7e91cc5e2d6853dbe2d746c5a15fbd3d363875894008c3439", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9eeba003-de7d-4c29-b4f2-25528ad56275": {"doc_hash": "a15d525bdbde8fb7616dfec13b46ddfb9f56fd6a73bf7c7e67314ea9138ee83f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "23a834ad-1264-4b70-a59a-6eb9fd92b097": {"doc_hash": "26574a72cfa043058db4c9076b3460a9cab64fa7c8c74e0378f79d430677f5e4", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "39935019-4023-4996-8ba6-1c8a8deec6d3": {"doc_hash": "82a3266d34e7826000b691196c627fce5134c4ca8408fa55eb8bc3f89c5522a8", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "33254742-f72c-4234-81e2-91cc47b223d7": {"doc_hash": "0f2532be4a722d7828961f1024cee68a63e2016d4e7bf87a84f597ed349fab3e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d57f150c-2208-4866-ae1b-14305e248f65": {"doc_hash": "1cf3aeabefae9410bea90b94d898cd572ac8eb761790b85fa36a6d0f2ab1efdf", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e8241460-99c3-47e9-9f64-59c4cdd5832e": {"doc_hash": "371f5b3baf2a561b635f3db64eba248d3a89a0fa7a12242812da05bf68a10fdb", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "318c3cde-77a5-46b3-bedd-faa580a33da4": {"doc_hash": "d0508f279e2f5e50e14d61cf1b85d23ddb75f12e0be81622b3e98bb56ca109b1", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b5bd7d32-8f7f-4f09-8b49-fceebd38c860": {"doc_hash": "8e5c0430e96a1968ef9296c4c5d0c0212a877acd948e3d8f5cd0e271be2d8d4d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1b1a3d3d-5c52-40ae-a4f9-b489a54ddf4e": {"doc_hash": "a588fac9839609008c8ebc1c8ca25a5d09dd8aa0c2e76af0a2372a24a3673e63", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "18ebeeb0-c2c1-4f2e-84ef-8e0b4304213e": {"doc_hash": "13738c61a832236ce94c4eb4b10a4f58abc4598f6c2123c4040b5e8ddc5b0a28", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "62461ea1-aa58-4ead-bf7e-38c3a99fbb97": {"doc_hash": "c2794ee7b4e3867565fcee147ab94d96a4c4d655e59b0fadf8f62a72547fd6bd", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2c0f4fc8-10f1-4944-800b-dc624cef2c9f": {"doc_hash": "ab008555775274c66c898f553696bbe8aa8929c1954ab663668ce389e9b430e3", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c09c3d44-1be5-484c-9259-896c3446fdc6": {"doc_hash": "d074c83790d5ede76e9dff60137cd8b933e61c2837aba2240117bc62621b3e78", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "301fd21b-2537-4c8c-bacd-8ffbac02c176": {"doc_hash": "0973d0f83f213b2990c664df1afe34fe79aac7235f714381fe7185cf5ca105df", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3b94e476-ea17-4c7d-b7be-3cf188c9f020": {"doc_hash": "e7c5c2258dc279fd6213a9544908ea682dd7709bdabbeee49922718659804386", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "db6a2667-cd4b-4de2-9c73-f827241a1433": {"doc_hash": "0260c8146dc1ef7f22ec2513aed104f9917896ca8a5625bb49b12ed269c6b70e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7b6f05a9-b267-4aef-915f-e4e46339863a": {"doc_hash": "791e58f13942fd565e18a85f67ff660aa8f03c0aa7e1291c41b1259de5777ff1", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ecd926ac-f872-41fa-943e-baf9d6ffa683": {"doc_hash": "6af605a162bfa0c8e891eb932d3c03481452078a1d05f8093038117d89bcc00f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "343413bd-0f8e-402c-83c4-c7a61d6f5022": {"doc_hash": "6611eeb5f647c16a5efb5cd0479ed864e9991926d48043d5ef714d62bc351078", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e662e19a-b809-472e-83d9-fadf8eb23e22": {"doc_hash": "be75027361442447762adc4425c67f530025d9bf8696e12e529e602516c95c97", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ddd0533f-4d6f-4b40-8c8e-06aad0b26729": {"doc_hash": "8da3b67f645b81398897fea688fc9d889674db674c7366e0de3f6787b8cd663e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9da7d8dd-a5c2-41e7-91fd-c45ff98c7b56": {"doc_hash": "f52370c201085d0d25436082e32c38aff1eef63e122cae74a3d5a58b142d7f22", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "bb37f5af-3a6a-49fe-8ba2-c2cb54a9b40d": {"doc_hash": "1bfa1f27a7c247497a7d3ad262f8ead507b90164e1bf8559ac42d4f0d1ae6c16", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ec7edc44-8306-437c-9761-22cb6d782ced": {"doc_hash": "22bc0e13c972e463c571a0d573168fc89198f860626c8c072b731a4c29c0b6b0", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "69d531e3-c4bd-47e5-a5e4-45ce031b5a52": {"doc_hash": "397887058030b1a33035bad93cb75b15b941e5bea13fea575471f3cb62511f3b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b491f6ec-c51c-48dd-bf90-c4285ad5bb24": {"doc_hash": "a5308da9a0e7104c6a52050b049f261107d5226cc03018461dd6c6c892d425f5", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "8c830307-442a-4d3f-8518-19e377dcaabf": {"doc_hash": "6b2d451393f047dc316e611e3d59551e2fa388f86ad9c68105fed99cb8839877", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "03c5ef62-ab3c-4f85-b9bf-0c7215985ac1": {"doc_hash": "48bd25e71d49374a4b5c624327aa1008281bd647975260eddda3f4d3d890dc50", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7c5184c0-325c-4446-9858-838d5a636993": {"doc_hash": "ec942bd68dcd4dc89e8cea69fb6ed9dac938dc4eed2a3e071548893613b3d430", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "945fa7e9-37ce-49d2-b044-2ec172bdbc64": {"doc_hash": "1d1b934870c4482a951f009987a53afd1354ad14c1ba87bc0417287cf11f4c35", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ce85fb12-c6a2-495d-bdc7-90438d4e86ec": {"doc_hash": "bf9deec0d5ae9c9df1b79ff2a7af83be3fde77b8f09e751fc9e44ceb49e379ce", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ad360a28-2882-41e6-b363-7c06d8bc0e9a": {"doc_hash": "78ab5f4ebb13c1945a4763d84ea784f66a46f2cee65d4b4b1c352c3a130fd407", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c6a5dd39-9381-4829-857f-05a6ce2eff2c": {"doc_hash": "990b5c316d5a14233e3376acebd2cfe373e18e6cb298a5fe16a1476c09ddfd1d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "f4cb8c68-0c5e-45d7-b933-3a96b08c4f29": {"doc_hash": "06f5d09d41e2780b63dc440b9218f74b03378a5438311e95fe7f6690bd347b13", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "dbccd467-cb3e-45fb-b8a1-62ccf849d933": {"doc_hash": "fbdbc6ed77ec9588b485f9dba7ca18ab681cf7db044fbe0a039a5ce5e3e5697f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "dd4c30fd-bab0-471d-b0b3-04b8ca553aa4": {"doc_hash": "2d9d0ca8b712d951732c79b48c3b3429408d3678efb0abec3bdf3f047a9cbb45", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "89bb0b3f-288d-4843-890a-e3e65abaccd5": {"doc_hash": "cdf74c377751d7355dd448f39497cb6c44cf6d79478dd27418cdda2778930cbf", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "39ccdc42-9477-44a4-b4b8-d9cede84314d": {"doc_hash": "d0522ce2036e1f18647ba1ca527f8b8ccb3966c6bc38bd8d9a34eaefc5ee73b7", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "cd5e87ef-855d-4dd2-baaf-f466a5c8f6ec": {"doc_hash": "f8d8456bb09e017eeddfee90ed2861c1746ebb08f2cf3b3bea27d7b3bba88572", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "22eaea98-2ef8-4385-b893-7ffa4582c19d": {"doc_hash": "41a320acc13f652e7cb511410d6ce455aaf563bd211b7727526d9c3d37a121c9", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "18b040d1-02d1-4581-a0b9-91d390c92109": {"doc_hash": "bc4828582f574d049ee15b92dc228193bd53363025842a6938bdef70ff3fe570", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7b6d014d-c532-4647-9350-96def4925efe": {"doc_hash": "f98d0cfb8047682d237dc37c2a10a516552fafed5026f27ca806695431fefa0b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e873e8c9-399d-4443-b06f-f882a35f7d1c": {"doc_hash": "58ff78eb09d7cca8b0e88547e3016790467f42c80e35a99d1ed765da61658e82", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e9ff621c-e2eb-49dc-9dc2-2a277fbade30": {"doc_hash": "c6b1ee82eaad661e5b9a88de0b35f3fdb442a646ab2d54e7858ca5cec83c311c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "156d97e3-ce98-419c-8505-975d5e2bd61a": {"doc_hash": "ee6b59d4faf5c8aedf48c916e0ae14e501b6a2db6c0e88865ed321eae993a634", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "584584aa-5565-408f-a4d5-c55faea49732": {"doc_hash": "390291d7ca721d04fefaef4865b3cf7600c7d9321760e044b1c0e4fa5bfcbe44", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3f4d0360-f30c-4fb8-842f-be8d521262e2": {"doc_hash": "049d35c886f574e31ed61fa6fe9d03bb8b3b7c448b8b2f09f803662de7d8bcf7", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0764d31f-4fe2-4a66-bfe5-ff3aa150d2b8": {"doc_hash": "67ceed14b6a222315838a2d75c18dbe80715296da7ff8ad905dae76c49462461", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d7068396-4c09-4337-8426-002717e9737a": {"doc_hash": "ae59feb999b31e603e8b4ea19ed35803eec2c5313bc20aa81db4e9fc9165fda3", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c6885a3e-29ff-486f-b06e-9139dce5c533": {"doc_hash": "aae009a36749e87125faebcd4a915ced1eb5d8919cfc041d2cfd0f9526286cc4", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "13883e49-d4bf-4844-9ac2-3ada0487ca28": {"doc_hash": "3fd0dd35b9c10608fadbc7d45ff218f3accd9b574ccc3e3a1c1bbdc61aa8fe06", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "60f1423f-82db-4c2f-b9f3-02e4cdf08c1d": {"doc_hash": "29c5e5bad6fb65c0ed17981b395103b3eb887310c2fda7ec44853b30a1dc9d9d", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b7d42f41-0545-4504-9ac8-bb50b3841d24": {"doc_hash": "8d2ce161a82078e7b7119c2d33a7688b9a881707fc7a264133b9fdba363ef6a0", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "93f5d1aa-f126-4880-93e1-c70729984fe9": {"doc_hash": "f73ed9088a18ed22074e1f3ba28f295527043f3cf2e411ecc27b37479978a473", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9b99c536-8bf3-4bb1-bb08-81dd7f81a440": {"doc_hash": "f0c0944fe4753f22e6196985f15c11a59db5a2dfa70a12249d797a02ac16218b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1895c57d-0027-43af-be92-7f4bbdffd460": {"doc_hash": "ef559ef3508ba298274eef7b6ed5fb9334191f51501070af7288a339c27bcc81", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "04b622a7-073a-434b-bbd5-ab949915012b": {"doc_hash": "5aa30f61540929e8a066c1541792ac684c8bc0a60538efb54e5fc444c08d9c6a", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1994563d-ae5a-4047-a525-17510f4de97f": {"doc_hash": "723037b696c54a47edcc2cf43c9a41bb75a45c79a9fdc5ef89d4c00f55e1ace0", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fc7b26da-4ef0-444b-97cb-2e4e013a816c": {"doc_hash": "f56a15fbf238f88276d32cf2bfae41e6f93d8610853b8f73caa79cf047d245ec", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a00f05f9-355c-4121-8dab-bbdff524518e": {"doc_hash": "af2f10ad40e1089fc527001db0f79cd40671d8d92355acfcc87863d3b993d629", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "f33304f6-01f8-4750-b78f-e65583b17438": {"doc_hash": "c0d2c3cac251b9ee45491509d6633c41e330c71799fea9d2e2db2d7443b1aa2f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "16e958e9-6e74-4331-9986-c5a59d0b612c": {"doc_hash": "614a381b047620d5ca3ce8e1c235a65b5c3643739756c826527021df8f25e22e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "144aea52-dccf-4950-ad77-b28949db4b03": {"doc_hash": "319e5adb8f7e44544333b5d595c7569d195e8e8a49c8376b9c76ef7c92e44106", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "96101319-5f76-4052-b361-d2966fb7fe0e": {"doc_hash": "75e35fc480172344cdd8c36370e733d0edeb91d8d79eefdf37bd411ecf874917", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "131a694b-f269-449e-9d51-dc3e68c32971": {"doc_hash": "c17a93a3d02fe6070c263ccb4d67e1b9edf02c75906182d2b51dd46f3d17b16e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "114e7916-a391-46cf-9f33-ca3e9f21c476": {"doc_hash": "dfb1fb3f1a6e394d128464931fb204275e4f318f0462d1828b1a377e4da5e06f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "2aa194c7-cbf9-4543-b32a-0465e69af259": {"doc_hash": "795b96f7dc850c568216c1239a691f629a0d1252d306b5c93dcfa307445608b3", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "06a9375e-686d-4938-936b-01084edc7b88": {"doc_hash": "cd5fd612a8b35e64d8cc3546e6b8594b49d75591588edffba71f7ba9d8740faf", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3d7b892f-11b9-4ba4-b71f-980ca9b7c99a": {"doc_hash": "ca8e3408d805473badc9ac96b5763beaa2bcd57b7a946f2d1cd844482f3994cd", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "778b46dc-7e6a-4fdc-897d-085e54fc2cef": {"doc_hash": "17213c9d706333d924a03480415f888a7535fa6bf22f8ae6269821e32b8aef3b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0bc868de-49dc-44bb-bc86-95e6e03ce24c": {"doc_hash": "6581c3b2d5dd0f707e04bd85bf756362d5979075543d9579f5472e577560acd5", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "83cac814-a32f-4ef9-93f9-514c40403b2f": {"doc_hash": "39a2d2409f211767012685113afc89da78ceb299a64068343681bf2edaa2b6ab", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "76e44ce9-23db-4a3c-bd4f-1783aee6042f": {"doc_hash": "2e45813bdf58e6b602a836c6f0268b23fdce66d1d387db02c61c36c8502c71d2", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "7a590fa2-8cc0-4b6a-b932-0cb1da7dc52d": {"doc_hash": "324b8afad7bd4f5f24ba83ee1fdfa0306937648350f8ef173c42956df670fb02", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "603b65f3-ad11-4cc5-a42e-6a65a7759c8a": {"doc_hash": "3cca60bbefbbd7220eb56c0269694c5210832a70a2f063843332018cbbbc6f1f", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "a82f46f7-2b71-4e3f-8953-9723bad9ee3a": {"doc_hash": "ba9be3beaa80c9443ef692fe298709ea6b2f78541eb835c2dfd65aab4e6119bf", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fc5ddfb1-a8f2-4e1a-8283-8625bb07902e": {"doc_hash": "0188a11be4aff3f46bb78b132ee693035df341d22d63aba93ae82c8075c71ca5", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1c7eab56-3747-4b7c-8f15-6dd3ef965227": {"doc_hash": "b584536c494dcbe1108563aa8dffa9759efc09c5d520679787522f072e3c611b", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "50cf6ca3-55ba-48dd-a89b-5a39d8aed9a5": {"doc_hash": "bc9899088eeb76e486a6a2cec572855b90374aa6ea9913f21edb5e572a978784", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "10f632a9-6683-4d18-8140-1b2a2babcd19": {"doc_hash": "6a84a85706c39c1eb288b69971353f035755fd450ef561ae349e3982519f6e44", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "cf3e27ab-78d7-400e-b5bb-3b76538f9737": {"doc_hash": "997b170335774b9c3ff03fa8e86534c6abc431f06314c85a9d3d6138a3b4aa5e", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "5d01bac4-ab37-4172-9a26-7a88ab926f75": {"doc_hash": "d81d6f51eb86a3de78eda5e9c1bea6de4b8d777fb1b1d798488e464f8edb8a91", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "6c21240c-9f22-43ba-8351-cdc428bb9db7": {"doc_hash": "f75383ba5cd49416a9e5a96456776920c91d15fe651c738251147607f49614cc", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d57482fa-4867-4e8b-a887-89a1144858c6": {"doc_hash": "d09bb68cc3a307e1e19431e1450d14038c2444453dce4ae790b78edd434b5c89", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "20c30fd8-6a76-4886-a4de-de97a4a9d90d": {"doc_hash": "f4f10fa656c4898da76e38237ca829809efb673110cdb5c137b6c5f2acc82615", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "39ddf429-be05-47f6-9254-e5031f5ddfa0": {"doc_hash": "b54d4a02ba25dd98b187efc8fba61bed5f318415d87606a93047a2d687e4ed35", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "cab96ccd-ceda-4937-8f92-5763b4c8a5c7": {"doc_hash": "2640785ec42086e52bad18d99a630f3a1c3dd769e16c6ebb6e78230f5fa2a4d2", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1c2fe0a5-2ec1-42d8-9bb6-13a948a79538": {"doc_hash": "0b2249d93898dc86fccf44d61280c6531da8067e281b7be33f5369fe38e08d15", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d9718bb3-6a49-46c3-aaec-5d6b64cf486f": {"doc_hash": "141c2bae13a1edb35d284cd07a9afcdb41749764fb3deb550f531f287a678779", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1e14e335-28ec-4e8a-81c1-f81065d39227": {"doc_hash": "50e8b227b85603b0f0423f4dd919cb3436f8f66f12660367035ab2dca55aedd3", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "0fce7818-36d8-4641-af69-611bea3ea1b4": {"doc_hash": "c1e75d11674d445f31ea8022c64e184225b888a8f0b89e6b7e8fbf45aae68bd7", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "f365573c-743a-4d61-9265-7e6ddbfb8afd": {"doc_hash": "13ce0281fe414e962377bc0f668e60ba454b3e9c0dd6e4a3900ddc81aba86c84", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1af23bc0-73ce-4020-b761-8237e84d9ef4": {"doc_hash": "b91da0d979be15ffbb7bf6025b32a8fac47cb7be2b897fdb0fbaafb8810fd278", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1fe53da9-3851-4498-a058-8efa68bfb688": {"doc_hash": "f1a7826e14750b9c2a9df7859c5ebb3f8cbda50b7d45b2dda8ed8034cf2aa9ae", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b5b7955c-d9fa-492f-b223-22f4515bf5dd": {"doc_hash": "c88d004afdf5cdff08c52596981f4af33c235e4d2cac1c345ba3546e23f09a32", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "b5428440-e491-47f6-83f3-bf28e9393d09": {"doc_hash": "494284139e4267c78470a0e9788672b2b3a323f4788d57dc19841eebdc0a3122", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "91f789f1-52cf-4b7b-8813-1bb32e2aade3": {"doc_hash": "3ea8de013e73bb183d54cca88e7dabdf5d71b1d844f3539444223557adde0399", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "3680adf0-3107-4e4d-92f3-cb6e1974e150": {"doc_hash": "62e49839bb01d98ea05e8ecbe34c29bc6bee1a628325ace483c90ed97561f7a8", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "d464eeae-ed59-4cf3-bb39-412f2207a2e0": {"doc_hash": "1bfac8e2af4eed6923e46b966e375ddb9949f278407bae67b1713f1c890a9f62", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fcb58d6e-76a7-4339-a4f3-fbb4bda5f953": {"doc_hash": "7c618e15044a2debe7de4d2e92c2899288d9ffcc1507d9365ddb0251e102cc41", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "c47830cf-5f41-44a8-96de-3225f00bc345": {"doc_hash": "4242f30b131550ddc924879308476f3845754b39b4cc82017f96ac3cde09a788", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "06193a1d-e19f-4d7d-8549-e730b78e28be": {"doc_hash": "872924232a14fa378b59392682a806f8718cd990de2443f3e20a9cfea77691c4", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "e5355f4d-cfa9-4eb9-abd5-6a24fd55aa98": {"doc_hash": "9d9b9fd051e4ae96c6947229094d44b0e743c5ba7513f89b6b59ec24cef6faf4", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ca9acbb1-5468-406e-8a33-7319dde01d6b": {"doc_hash": "f0a1886f90f9b81dde8e545b4856e2c15861c6aadd4e21aab8111f617b778d93", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "de24e18f-e50b-4bb2-a9d8-20657317d580": {"doc_hash": "0de94cbe8e63fd983a6b0cdf846e9e40acc35a316040f33f6272b50cd4b3b173", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "1449fa66-f198-4207-8d0e-6bd32c08bffb": {"doc_hash": "ac62f6f0f46d7fc3e20fc3d347012d94b2c92dce754edfc8bdde55d122e6fa66", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "fad80e03-96f6-44e9-9ec4-77f3f51e5ada": {"doc_hash": "6e0e697f64c572af4e9bcacd9845effa86e5d24a50ff436bff8d841e3c66cb2c", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "9831867d-c656-42dc-b517-c50d84486ea8": {"doc_hash": "4c7551a9f5a9b00dbbfcd4e7b7bbb9eec4e63ed2cef02bd1607b9246b1e03853", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "95859364-c274-46e4-a404-23805cab18e3": {"doc_hash": "d5e43a8a8b6caafbdb57cd571dbe15669cdbc718b1539f1b91f2f3b74a867789", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "98c6ff7e-a235-431a-92c5-1b0b1b6c5c15": {"doc_hash": "f4b72f6e555da60086cc7ef791b973778a1f6c2579d884280d8e6e2f64a33bb6", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ec1d6025-4278-4b50-968c-4845047e89ef": {"doc_hash": "06baf68175f2b106a46c3f010b4c560ac09112167e12d5e01678e379adc8d2ff", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}, "ec66e3e9-cc89-4462-b020-bbda40bda188": {"doc_hash": "c7d100823e1d34216b73b4674099bcddee4364804704145fe16da92e69614e84", "ref_doc_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5"}}, "docstore/data": {"50c1b7ec-25fb-470b-a31c-4b05756df829": {"__data__": {"id_": "50c1b7ec-25fb-470b-a31c-4b05756df829", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4ed79338-a2a3-4f67-bc96-7e2155338c75", "node_type": "1", "metadata": {}, "hash": "6a87cb0834af522e52abd9af40472900be6e4872d8a341aa05cd5132908744a1", "class_name": "RelatedNodeInfo"}}, "text": "Dive into Deep Learning\nASTON ZHANG, ZACHARY C. LIPTON, MU LI, AND ALEXANDER J.\nSMOLA\n\nContents\nPreface pagexxv\nInstallation xxxiv\nNotation xxxvii\n1 Introduction 1\n1.1 A Motivating Example 2\n1.2 Key Components 4\n1.3 Kinds of Machine Learning Problems 7\n1.4 Roots 20\n1.5 The Road to Deep Learning 22\n1.6 Success Stories 25\n1.7 The Essence of Deep Learning 27\n1.8 Summary 29\n1.9 Exercises 29\n2 Preliminaries 30\n2.1 Data Manipulation 30\n2.1.1 Getting Started 30\n2.1.2 Indexing and Slicing 33\n2.1.3 Operations 34\n2.1.4 Broadcasting 35\n2.1.5 Saving Memory 36\n2.1.6 Conversion to Other Python Objects 37\n2.1.7 Summary 37\n2.1.8 Exercises 38\n2.2 Data Preprocessing 38\n2.2.1 Reading the Dataset 38\n2.2.2 Data Preparation 39\n2.2.3 Conversion to the Tensor Format 40\n2.2.4 Discussion 40\n2.2.5 Exercises 40\n2.3 Linear Algebra 41\n2.3.1 Scalars 41\niii\n2.3.2 Vectors 42\n2.3.3 Matrices 43\n2.3.4 Tensors 44\n2.3.5 Basic Properties of Tensor Arithmetic 45\n2.3.6 Reduction 46\n2.3.7 Non-Reduction Sum 47\n2.3.8 Dot Products 48\n2.3.9 Matrix\u2013Vector Products 48\n2.3.10 Matrix\u2013Matrix Multiplication 49\n2.3.11 Norms 50\n2.3.12 Discussion 52\n2.3.13 Exercises 53\n2.4 Calculus 54\n2.4.1 Derivatives and Differentiation 54\n2.4.2 Visualization Utilities 56\n2.4.3 Partial Derivatives and Gradients 58\n2.4.4 Chain Rule 58\n2.4.5 Discussion 59\n2.4.6 Exercises 59\n2.5 Automatic Differentiation 60\n2.5.1 A Simple Function 60\n2.5.2 Backward for Non-Scalar Variables 61\n2.5.3 Detaching Computation 62\n2.5.4 Gradients and Python Control Flow 63\n2.5.5 Discussion 64\n2.5.6 Exercises 64\n2.6 Probability and Statistics 65\n2.6.1 A Simple Example: Tossing Coins 66\n2.6.2 A More Formal Treatment 68\n2.6.3 Random Variables 69\n2.6.4 Multiple Random Variables 70\n2.6.5 An Example 73\n2.6.6 Expectations 74\n2.6.7 Discussion 76\n2.6.8 Exercises 77\n2.7 Documentation 78\n2.7.1 Functions and Classes in a Module 78\n2.7.2 Specific Functions and Classes 79\n3 Linear Neural Networks for Regression 82\n3.1 Linear Regression 82\n3.1.1 Basics 83\n3.1.2 Vectorization for Speed 88\n3.1.3 The Normal Distribution and Squared Loss 88\n3.1.4 Linear Regression as a Neural Network 90\niv\n3.1.5 Summary 91\n3.1.6 Exercises 92\n3.2 Object-Oriented Design for Implementation 93\n3.2.1 Utilities 94\n3.2.2 Models 96\n3.2.3 Data 97\n3.2.4 Training 97\n3.2.5 Summary 98\n3.2.6 Exercises 98\n3.3 Synthetic Regression Data 99\n3.3.1 Generating the Dataset 99\n3.3.2 Reading the Dataset 100\n3.3.3 Concise Implementation of the Data Loader 101\n3.3.4 Summary 102\n3.3.5 Exercises 102\n3.4 Linear Regression Implementation from Scratch 103\n3.4.1 Defining the Model 103\n3.4.2 Defining the Loss Function 104\n3.4.3 Defining the Optimization Algorithm 104\n3.4.4 Training 105\n3.4.5 Summary 107\n3.4.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2692, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4ed79338-a2a3-4f67-bc96-7e2155338c75": {"__data__": {"id_": "4ed79338-a2a3-4f67-bc96-7e2155338c75", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "50c1b7ec-25fb-470b-a31c-4b05756df829", "node_type": "1", "metadata": {}, "hash": "0a121b811bd97a6e844d7fbfd02be54a64e65ef5d87c6f5543700f1f6ead8d3e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c5882dac-ebd5-4da5-957f-7649a9446182", "node_type": "1", "metadata": {}, "hash": "66480094b0d52c0ee14dcde94f41b8d399550989ed0a73644fa5f0df69fcd744", "class_name": "RelatedNodeInfo"}}, "text": "2 Object-Oriented Design for Implementation 93\n3.2.1 Utilities 94\n3.2.2 Models 96\n3.2.3 Data 97\n3.2.4 Training 97\n3.2.5 Summary 98\n3.2.6 Exercises 98\n3.3 Synthetic Regression Data 99\n3.3.1 Generating the Dataset 99\n3.3.2 Reading the Dataset 100\n3.3.3 Concise Implementation of the Data Loader 101\n3.3.4 Summary 102\n3.3.5 Exercises 102\n3.4 Linear Regression Implementation from Scratch 103\n3.4.1 Defining the Model 103\n3.4.2 Defining the Loss Function 104\n3.4.3 Defining the Optimization Algorithm 104\n3.4.4 Training 105\n3.4.5 Summary 107\n3.4.6 Exercises 107\n3.5 Concise Implementation of Linear Regression 108\n3.5.1 Defining the Model 109\n3.5.2 Defining the Loss Function 109\n3.5.3 Defining the Optimization Algorithm 110\n3.5.4 Training 110\n3.5.5 Summary 111\n3.5.6 Exercises 111\n3.6 Generalization 112\n3.6.1 Training Error and Generalization Error 113\n3.6.2 Underfitting or Overfitting? 115\n3.6.3 Model Selection 116\n3.6.4 Summary 117\n3.6.5 Exercises 117\n3.7 Weight Decay 118\n3.7.1 Norms and Weight Decay 119\n3.7.2 High-Dimensional Linear Regression 120\n3.7.3 Implementation from Scratch 121\n3.7.4 Concise Implementation 122\n3.7.5 Summary 124\n3.7.6 Exercises 124\n4 Linear Neural Networks for Classi\ufb01cation 125\n4.1 Softmax Regression 125\nv\n4.1.1 Classification 126\n4.1.2 Loss Function 129\n4.1.3 Information Theory Basics 130\n4.1.4 Summary and Discussion 131\n4.1.5 Exercises 132\n4.2 The Image Classification Dataset 134\n4.2.1 Loading the Dataset 134\n4.2.2 Reading a Minibatch 135\n4.2.3 Visualization 136\n4.2.4 Summary 137\n4.2.5 Exercises 137\n4.3 The Base Classification Model 138\n4.3.1 TheClassifier Class 138\n4.3.2 Accuracy 138\n4.3.3 Summary 139\n4.3.4 Exercises 139\n4.4 Softmax Regression Implementation from Scratch 140\n4.4.1 The Softmax 140\n4.4.2 The Model 141\n4.4.3 The Cross-Entropy Loss 141\n4.4.4 Training 142\n4.4.5 Prediction 143\n4.4.6 Summary 143\n4.4.7 Exercises 144\n4.5 Concise Implementation of Softmax Regression 144\n4.5.1 Defining the Model 145\n4.5.2 Softmax Revisited 145\n4.5.3 Training 146\n4.5.4 Summary 146\n4.5.5 Exercises 147\n4.6 Generalization in Classification 147\n4.6.1 The Test Set 148\n4.6.2 Test Set Reuse 150\n4.6.3 Statistical Learning Theory 151\n4.6.4 Summary 153\n4.6.5 Exercises 154\n4.7 Environment and Distribution Shift 154\n4.7.1 Types of Distribution Shift 155\n4.7.2 Examples of Distribution Shift 157\n4.7.3 Correction of Distribution Shift 159\n4.7.4 A Taxonomy of Learning Problems 163\n4.7.5 Fairness, Accountability, and Transparency in Machine\nLearning 164\n4.7.6 Summary 165\n4.7.7 Exercises 166\nvi\n5 Multilayer Perceptrons 167\n5.1 Multilayer Perceptrons 167\n5.1.1 Hidden Layers 167\n5.1.2 Activation Functions 171\n5.1.3 Summary and Discussion 174\n5.1.4 Exercises 175\n5.2 Implementation of Multilayer Perceptrons 176\n5.2.1 Implementation from Scratch 176\n5.2.2 Concise Implementation 177\n5.2.3 Summary 178\n5.", "mimetype": "text/plain", "start_char_idx": 2150, "end_char_idx": 4984, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c5882dac-ebd5-4da5-957f-7649a9446182": {"__data__": {"id_": "c5882dac-ebd5-4da5-957f-7649a9446182", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4ed79338-a2a3-4f67-bc96-7e2155338c75", "node_type": "1", "metadata": {}, "hash": "6a87cb0834af522e52abd9af40472900be6e4872d8a341aa05cd5132908744a1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6412964f-4a1b-42ff-995a-cdd78f115370", "node_type": "1", "metadata": {}, "hash": "106197fc66fcc86c0f9e918165fe1ecf2819cad5ff89db9a2c2b4ffa590069aa", "class_name": "RelatedNodeInfo"}}, "text": "7.1 Types of Distribution Shift 155\n4.7.2 Examples of Distribution Shift 157\n4.7.3 Correction of Distribution Shift 159\n4.7.4 A Taxonomy of Learning Problems 163\n4.7.5 Fairness, Accountability, and Transparency in Machine\nLearning 164\n4.7.6 Summary 165\n4.7.7 Exercises 166\nvi\n5 Multilayer Perceptrons 167\n5.1 Multilayer Perceptrons 167\n5.1.1 Hidden Layers 167\n5.1.2 Activation Functions 171\n5.1.3 Summary and Discussion 174\n5.1.4 Exercises 175\n5.2 Implementation of Multilayer Perceptrons 176\n5.2.1 Implementation from Scratch 176\n5.2.2 Concise Implementation 177\n5.2.3 Summary 178\n5.2.4 Exercises 179\n5.3 Forward Propagation, Backward Propagation, and Computational Graphs 180\n5.3.1 Forward Propagation 180\n5.3.2 Computational Graph of Forward Propagation 181\n5.3.3 Backpropagation 181\n5.3.4 Training Neural Networks 183\n5.3.5 Summary 183\n5.3.6 Exercises 183\n5.4 Numerical Stability and Initialization 184\n5.4.1 Vanishing and Exploding Gradients 184\n5.4.2 Parameter Initialization 187\n5.4.3 Summary 188\n5.4.4 Exercises 189\n5.5 Generalization in Deep Learning 189\n5.5.1 Revisiting Overfitting and Regularization 190\n5.5.2 Inspiration from Nonparametrics 191\n5.5.3 Early Stopping 192\n5.5.4 Classical Regularization Methods for Deep Networks 193\n5.5.5 Summary 193\n5.5.6 Exercises 194\n5.6 Dropout 194\n5.6.1 Dropout in Practice 195\n5.6.2 Implementation from Scratch 196\n5.6.3 Concise Implementation 197\n5.6.4 Summary 198\n5.6.5 Exercises 198\n5.7 Predicting House Prices on Kaggle 199\n5.7.1 Downloading Data 199\n5.7.2 Kaggle 200\n5.7.3 Accessing and Reading the Dataset 201\n5.7.4 Data Preprocessing 201\n5.7.5 Error Measure 203\n5.7.6 \ud835\udc3e-Fold Cross-Validation 204\n5.7.7 Model Selection 204\n5.7.8 Submitting Predictions on Kaggle 205\nvii\n5.7.9 Summary and Discussion 206\n5.7.10 Exercises 206\n6 Builders\u2019 Guide 207\n6.1 Layers and Modules 207\n6.1.1 A Custom Module 209\n6.1.2 The Sequential Module 211\n6.1.3 Executing Code in the Forward Propagation Method 211\n6.1.4 Summary 213\n6.1.5 Exercises 213\n6.2 Parameter Management 213\n6.2.1 Parameter Access 214\n6.2.2 Tied Parameters 215\n6.2.3 Summary 216\n6.2.4 Exercises 216\n6.3 Parameter Initialization 216\n6.3.1 Built-in Initialization 217\n6.3.2 Summary 219\n6.3.3 Exercises 219\n6.4 Lazy Initialization 219\n6.4.1 Summary 220\n6.4.2 Exercises 221\n6.5 Custom Layers 221\n6.5.1 Layers without Parameters 221\n6.5.2 Layers with Parameters 222\n6.5.3 Summary 223\n6.5.4 Exercises 223\n6.6 File I/O 223\n6.6.1 Loading and Saving Tensors 224\n6.6.2 Loading and Saving Model Parameters 225\n6.6.3 Summary 226\n6.6.4 Exercises 226\n6.7 GPUs 226\n6.7.1 Computing Devices 227\n6.7.2 Tensors and GPUs 228\n6.7.3 Neural Networks and GPUs 230\n6.7.4 Summary 231\n6.7.5 Exercises 231\n7 Convolutional Neural Networks 233\n7.1 From Fully Connected Layers to Convolutions 234\n7.1.1 Invariance 234\n7.1.2 Constraining the MLP 235\n7.1.3 Convolutions 237\n7.1.", "mimetype": "text/plain", "start_char_idx": 4400, "end_char_idx": 7251, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6412964f-4a1b-42ff-995a-cdd78f115370": {"__data__": {"id_": "6412964f-4a1b-42ff-995a-cdd78f115370", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c5882dac-ebd5-4da5-957f-7649a9446182", "node_type": "1", "metadata": {}, "hash": "66480094b0d52c0ee14dcde94f41b8d399550989ed0a73644fa5f0df69fcd744", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6475d4dc-319f-4399-8bd3-ca51d9b603c9", "node_type": "1", "metadata": {}, "hash": "e28d97ab4207de47b689cf741f1731b429e5c46035aabda6b5adb827245fdd69", "class_name": "RelatedNodeInfo"}}, "text": "5.2 Layers with Parameters 222\n6.5.3 Summary 223\n6.5.4 Exercises 223\n6.6 File I/O 223\n6.6.1 Loading and Saving Tensors 224\n6.6.2 Loading and Saving Model Parameters 225\n6.6.3 Summary 226\n6.6.4 Exercises 226\n6.7 GPUs 226\n6.7.1 Computing Devices 227\n6.7.2 Tensors and GPUs 228\n6.7.3 Neural Networks and GPUs 230\n6.7.4 Summary 231\n6.7.5 Exercises 231\n7 Convolutional Neural Networks 233\n7.1 From Fully Connected Layers to Convolutions 234\n7.1.1 Invariance 234\n7.1.2 Constraining the MLP 235\n7.1.3 Convolutions 237\n7.1.4 Channels 238\nviii\n7.1.5 Summary and Discussion 239\n7.1.6 Exercises 239\n7.2 Convolutions for Images 240\n7.2.1 The Cross-Correlation Operation 240\n7.2.2 Convolutional Layers 242\n7.2.3 Object Edge Detection in Images 242\n7.2.4 Learning a Kernel 244\n7.2.5 Cross-Correlation and Convolution 245\n7.2.6 Feature Map and Receptive Field 245\n7.2.7 Summary 246\n7.2.8 Exercises 247\n7.3 Padding and Stride 247\n7.3.1 Padding 248\n7.3.2 Stride 250\n7.3.3 Summary and Discussion 251\n7.3.4 Exercises 251\n7.4 Multiple Input and Multiple Output Channels 252\n7.4.1 Multiple Input Channels 252\n7.4.2 Multiple Output Channels 253\n7.4.3 1\u00021Convolutional Layer 255\n7.4.4 Discussion 256\n7.4.5 Exercises 256\n7.5 Pooling 257\n7.5.1 Maximum Pooling and Average Pooling 258\n7.5.2 Padding and Stride 260\n7.5.3 Multiple Channels 261\n7.5.4 Summary 261\n7.5.5 Exercises 262\n7.6 Convolutional Neural Networks (LeNet) 262\n7.6.1 LeNet 263\n7.6.2 Training 265\n7.6.3 Summary 266\n7.6.4 Exercises 266\n8 Modern Convolutional Neural Networks 268\n8.1 Deep Convolutional Neural Networks (AlexNet) 269\n8.1.1 Representation Learning 270\n8.1.2 AlexNet 273\n8.1.3 Training 276\n8.1.4 Discussion 276\n8.1.5 Exercises 277\n8.2 Networks Using Blocks (VGG) 278\n8.2.1 VGG Blocks 279\n8.2.2 VGG Network 279\n8.2.3 Training 281\nix\n8.2.4 Summary 282\n8.2.5 Exercises 282\n8.3 Network in Network (NiN) 283\n8.3.1 NiN Blocks 283\n8.3.2 NiN Model 284\n8.3.3 Training 285\n8.3.4 Summary 286\n8.3.5 Exercises 286\n8.4 Multi-Branch Networks (GoogLeNet) 287\n8.4.1 Inception Blocks 287\n8.4.2 GoogLeNet Model 288\n8.4.3 Training 291\n8.4.4 Discussion 291\n8.4.5 Exercises 292\n8.5 Batch Normalization 292\n8.5.1 Training Deep Networks 293\n8.5.2 Batch Normalization Layers 295\n8.5.3 Implementation from Scratch 297\n8.5.4 LeNet with Batch Normalization 298\n8.5.5 Concise Implementation 299\n8.5.6 Discussion 300\n8.5.7 Exercises 301\n8.6 Residual Networks (ResNet) and ResNeXt 302\n8.6.1 Function Classes 302\n8.6.2 Residual Blocks 304\n8.6.3 ResNet Model 306\n8.6.4 Training 308\n8.6.5 ResNeXt 308\n8.6.6 Summary and Discussion 310\n8.6.7 Exercises 311\n8.", "mimetype": "text/plain", "start_char_idx": 6736, "end_char_idx": 9308, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6475d4dc-319f-4399-8bd3-ca51d9b603c9": {"__data__": {"id_": "6475d4dc-319f-4399-8bd3-ca51d9b603c9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6412964f-4a1b-42ff-995a-cdd78f115370", "node_type": "1", "metadata": {}, "hash": "106197fc66fcc86c0f9e918165fe1ecf2819cad5ff89db9a2c2b4ffa590069aa", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b9597f06-568e-42d1-aa55-7b2bc77ea3ba", "node_type": "1", "metadata": {}, "hash": "4fb662c9b1292c95a7309c3400901c9865c96388341b8497653ff6a710a36e5e", "class_name": "RelatedNodeInfo"}}, "text": "4.4 Discussion 291\n8.4.5 Exercises 292\n8.5 Batch Normalization 292\n8.5.1 Training Deep Networks 293\n8.5.2 Batch Normalization Layers 295\n8.5.3 Implementation from Scratch 297\n8.5.4 LeNet with Batch Normalization 298\n8.5.5 Concise Implementation 299\n8.5.6 Discussion 300\n8.5.7 Exercises 301\n8.6 Residual Networks (ResNet) and ResNeXt 302\n8.6.1 Function Classes 302\n8.6.2 Residual Blocks 304\n8.6.3 ResNet Model 306\n8.6.4 Training 308\n8.6.5 ResNeXt 308\n8.6.6 Summary and Discussion 310\n8.6.7 Exercises 311\n8.7 Densely Connected Networks (DenseNet) 312\n8.7.1 From ResNet to DenseNet 312\n8.7.2 Dense Blocks 313\n8.7.3 Transition Layers 314\n8.7.4 DenseNet Model 315\n8.7.5 Training 315\n8.7.6 Summary and Discussion 316\n8.7.7 Exercises 316\n8.8 Designing Convolution Network Architectures 317\n8.8.1 The AnyNet Design Space 318\n8.8.2 Distributions and Parameters of Design Spaces 320\n8.8.3 RegNet 322\n8.8.4 Training 323\n8.8.5 Discussion 323\n8.8.6 Exercises 324\nx\n9 Recurrent Neural Networks 325\n9.1 Working with Sequences 327\n9.1.1 Autoregressive Models 328\n9.1.2 Sequence Models 330\n9.1.3 Training 331\n9.1.4 Prediction 333\n9.1.5 Summary 335\n9.1.6 Exercises 335\n9.2 Converting Raw Text into Sequence Data 336\n9.2.1 Reading the Dataset 336\n9.2.2 Tokenization 337\n9.2.3 Vocabulary 337\n9.2.4 Putting It All Together 338\n9.2.5 Exploratory Language Statistics 339\n9.2.6 Summary 341\n9.2.7 Exercises 342\n9.3 Language Models 342\n9.3.1 Learning Language Models 343\n9.3.2 Perplexity 345\n9.3.3 Partitioning Sequences 346\n9.3.4 Summary and Discussion 347\n9.3.5 Exercises 348\n9.4 Recurrent Neural Networks 348\n9.4.1 Neural Networks without Hidden States 349\n9.4.2 Recurrent Neural Networks with Hidden States 349\n9.4.3 RNN-Based Character-Level Language Models 351\n9.4.4 Summary 352\n9.4.5 Exercises 352\n9.5 Recurrent Neural Network Implementation from Scratch 352\n9.5.1 RNN Model 353\n9.5.2 RNN-Based Language Model 354\n9.5.3 Gradient Clipping 356\n9.5.4 Training 357\n9.5.5 Decoding 358\n9.5.6 Summary 359\n9.5.7 Exercises 359\n9.6 Concise Implementation of Recurrent Neural Networks 360\n9.6.1 Defining the Model 360\n9.6.2 Training and Predicting 361\n9.6.3 Summary 362\n9.6.4 Exercises 362\n9.7 Backpropagation Through Time 362\n9.7.1 Analysis of Gradients in RNNs 362\n9.7.2 Backpropagation Through Time in Detail 365\n9.7.3 Summary 368\nxi\n9.7.4 Exercises 368\n10 Modern Recurrent Neural Networks 369\n10.1 Long Short-Term Memory (LSTM) 370\n10.1.1 Gated Memory Cell 370\n10.1.2 Implementation from Scratch 373\n10.1.3 Concise Implementation 375\n10.1.4 Summary 376\n10.1.5 Exercises 376\n10.2 Gated Recurrent Units (GRU) 376\n10.2.1 Reset Gate and Update Gate 377\n10.2.2 Candidate Hidden State 378\n10.2.3 Hidden State 378\n10.2.4 Implementation from Scratch 379\n10.2.5 Concise Implementation 380\n10.2.6 Summary 381\n10.2.", "mimetype": "text/plain", "start_char_idx": 8803, "end_char_idx": 11581, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b9597f06-568e-42d1-aa55-7b2bc77ea3ba": {"__data__": {"id_": "b9597f06-568e-42d1-aa55-7b2bc77ea3ba", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6475d4dc-319f-4399-8bd3-ca51d9b603c9", "node_type": "1", "metadata": {}, "hash": "e28d97ab4207de47b689cf741f1731b429e5c46035aabda6b5adb827245fdd69", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "28d5e5ca-c507-4ef1-86d4-19b8b648404b", "node_type": "1", "metadata": {}, "hash": "48e8201a01ba47dbbf4649ed8865e9d300dbb9e21befd22023cc65ce134edac7", "class_name": "RelatedNodeInfo"}}, "text": "7.2 Backpropagation Through Time in Detail 365\n9.7.3 Summary 368\nxi\n9.7.4 Exercises 368\n10 Modern Recurrent Neural Networks 369\n10.1 Long Short-Term Memory (LSTM) 370\n10.1.1 Gated Memory Cell 370\n10.1.2 Implementation from Scratch 373\n10.1.3 Concise Implementation 375\n10.1.4 Summary 376\n10.1.5 Exercises 376\n10.2 Gated Recurrent Units (GRU) 376\n10.2.1 Reset Gate and Update Gate 377\n10.2.2 Candidate Hidden State 378\n10.2.3 Hidden State 378\n10.2.4 Implementation from Scratch 379\n10.2.5 Concise Implementation 380\n10.2.6 Summary 381\n10.2.7 Exercises 381\n10.3 Deep Recurrent Neural Networks 382\n10.3.1 Implementation from Scratch 383\n10.3.2 Concise Implementation 384\n10.3.3 Summary 385\n10.3.4 Exercises 385\n10.4 Bidirectional Recurrent Neural Networks 385\n10.4.1 Implementation from Scratch 387\n10.4.2 Concise Implementation 387\n10.4.3 Summary 388\n10.4.4 Exercises 388\n10.5 Machine Translation and the Dataset 388\n10.5.1 Downloading and Preprocessing the Dataset 389\n10.5.2 Tokenization 390\n10.5.3 Loading Sequences of Fixed Length 391\n10.5.4 Reading the Dataset 392\n10.5.5 Summary 393\n10.5.6 Exercises 394\n10.6 The Encoder\u0000Decoder Architecture 394\n10.6.1 Encoder 394\n10.6.2 Decoder 395\n10.6.3 Putting the Encoder and Decoder Together 395\n10.6.4 Summary 396\n10.6.5 Exercises 396\n10.7 Sequence-to-Sequence Learning for Machine Translation 396\n10.7.1 Teacher Forcing 397\n10.7.2 Encoder 397\n10.7.3 Decoder 399\n10.7.4 Encoder\u2013Decoder for Sequence-to-Sequence Learning 400\nxii\n10.7.5 Loss Function with Masking 401\n10.7.6 Training 401\n10.7.7 Prediction 402\n10.7.8 Evaluation of Predicted Sequences 403\n10.7.9 Summary 404\n10.7.10 Exercises 404\n10.8 Beam Search 405\n10.8.1 Greedy Search 405\n10.8.2 Exhaustive Search 407\n10.8.3 Beam Search 407\n10.8.4 Summary 408\n10.8.5 Exercises 408\n11 Attention Mechanisms and Transformers 409\n11.1 Queries, Keys, and Values 411\n11.1.1 Visualization 413\n11.1.2 Summary 414\n11.1.3 Exercises 414\n11.2 Attention Pooling by Similarity 415\n11.2.1 Kernels and Data 415\n11.2.2 Attention Pooling via Nadaraya\u2013Watson Regression 417\n11.2.3 Adapting Attention Pooling 418\n11.2.4 Summary 419\n11.2.5 Exercises 420\n11.3 Attention Scoring Functions 420\n11.3.1 Dot Product Attention 421\n11.3.2 Convenience Functions 421\n11.3.3 Scaled Dot Product Attention 423\n11.3.4 Additive Attention 424\n11.3.5 Summary 426\n11.3.6 Exercises 426\n11.4 The Bahdanau Attention Mechanism 427\n11.4.1 Model 428\n11.4.2 Defining the Decoder with Attention 428\n11.4.3 Training 430\n11.4.4 Summary 431\n11.4.5 Exercises 432\n11.5 Multi-Head Attention 432\n11.5.1 Model 433\n11.5.2 Implementation 433\n11.5.3 Summary 435\n11.5.4 Exercises 435\n11.6 Self-Attention and Positional Encoding 435\n11.6.1 Self-Attention 436\n11.6.2 Comparing CNNs, RNNs, and Self-Attention 436\nxiii\n11.6.3 Positional Encoding 437\n11.6.4 Summary 440\n11.6.5 Exercises 440\n11.7 The Transformer Architecture 440\n11.7.", "mimetype": "text/plain", "start_char_idx": 11042, "end_char_idx": 13908, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "28d5e5ca-c507-4ef1-86d4-19b8b648404b": {"__data__": {"id_": "28d5e5ca-c507-4ef1-86d4-19b8b648404b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b9597f06-568e-42d1-aa55-7b2bc77ea3ba", "node_type": "1", "metadata": {}, "hash": "4fb662c9b1292c95a7309c3400901c9865c96388341b8497653ff6a710a36e5e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "aa00d208-7795-4c59-9460-061cd07cfa76", "node_type": "1", "metadata": {}, "hash": "9b3784a67f30b6147ae80e7c8025f436280be0e5b92c645bc9fdf63ee052482c", "class_name": "RelatedNodeInfo"}}, "text": "4 The Bahdanau Attention Mechanism 427\n11.4.1 Model 428\n11.4.2 Defining the Decoder with Attention 428\n11.4.3 Training 430\n11.4.4 Summary 431\n11.4.5 Exercises 432\n11.5 Multi-Head Attention 432\n11.5.1 Model 433\n11.5.2 Implementation 433\n11.5.3 Summary 435\n11.5.4 Exercises 435\n11.6 Self-Attention and Positional Encoding 435\n11.6.1 Self-Attention 436\n11.6.2 Comparing CNNs, RNNs, and Self-Attention 436\nxiii\n11.6.3 Positional Encoding 437\n11.6.4 Summary 440\n11.6.5 Exercises 440\n11.7 The Transformer Architecture 440\n11.7.1 Model 441\n11.7.2 Positionwise Feed-Forward Networks 442\n11.7.3 Residual Connection and Layer Normalization 443\n11.7.4 Encoder 444\n11.7.5 Decoder 445\n11.7.6 Training 447\n11.7.7 Summary 451\n11.7.8 Exercises 451\n11.8 Transformers for Vision 451\n11.8.1 Model 452\n11.8.2 Patch Embedding 453\n11.8.3 Vision Transformer Encoder 453\n11.8.4 Putting It All Together 454\n11.8.5 Training 455\n11.8.6 Summary and Discussion 455\n11.8.7 Exercises 456\n11.9 Large-Scale Pretraining with Transformers 456\n11.9.1 Encoder-Only 457\n11.9.2 Encoder\u2013Decoder 459\n11.9.3 Decoder-Only 461\n11.9.4 Scalability 463\n11.9.5 Large Language Models 465\n11.9.6 Summary and Discussion 466\n11.9.7 Exercises 467\n12 Optimization Algorithms 468\n12.1 Optimization and Deep Learning 468\n12.1.1 Goal of Optimization 469\n12.1.2 Optimization Challenges in Deep Learning 469\n12.1.3 Summary 473\n12.1.4 Exercises 473\n12.2 Convexity 474\n12.2.1 Definitions 474\n12.2.2 Properties 476\n12.2.3 Constraints 479\n12.2.4 Summary 481\n12.2.5 Exercises 482\n12.3 Gradient Descent 482\n12.3.1 One-Dimensional Gradient Descent 482\n12.3.2 Multivariate Gradient Descent 486\n12.3.3 Adaptive Methods 488\nxiv\n12.3.4 Summary 492\n12.3.5 Exercises 492\n12.4 Stochastic Gradient Descent 493\n12.4.1 Stochastic Gradient Updates 493\n12.4.2 Dynamic Learning Rate 495\n12.4.3 Convergence Analysis for Convex Objectives 496\n12.4.4 Stochastic Gradients and Finite Samples 498\n12.4.5 Summary 499\n12.4.6 Exercises 499\n12.5 Minibatch Stochastic Gradient Descent 500\n12.5.1 Vectorization and Caches 500\n12.5.2 Minibatches 503\n12.5.3 Reading the Dataset 504\n12.5.4 Implementation from Scratch 504\n12.5.5 Concise Implementation 507\n12.5.6 Summary 509\n12.5.7 Exercises 509\n12.6 Momentum 510\n12.6.1 Basics 510\n12.6.2 Practical Experiments 514\n12.6.3 Theoretical Analysis 516\n12.6.4 Summary 518\n12.6.5 Exercises 519\n12.7 Adagrad 519\n12.7.1 Sparse Features and Learning Rates 519\n12.7.2 Preconditioning 520\n12.7.3 The Algorithm 521\n12.7.4 Implementation from Scratch 523\n12.7.5 Concise Implementation 524\n12.7.6 Summary 524\n12.7.7 Exercises 525\n12.8 RMSProp 525\n12.8.1 The Algorithm 526\n12.8.2 Implementation from Scratch 526\n12.8.3 Concise Implementation 528\n12.8.4 Summary 528\n12.8.5 Exercises 529\n12.9 Adadelta 529\n12.9.1 The Algorithm 529\n12.9.2 Implementation 530\n12.9.", "mimetype": "text/plain", "start_char_idx": 13387, "end_char_idx": 16188, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "aa00d208-7795-4c59-9460-061cd07cfa76": {"__data__": {"id_": "aa00d208-7795-4c59-9460-061cd07cfa76", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "28d5e5ca-c507-4ef1-86d4-19b8b648404b", "node_type": "1", "metadata": {}, "hash": "48e8201a01ba47dbbf4649ed8865e9d300dbb9e21befd22023cc65ce134edac7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "46c78bf2-500c-429f-9bd0-ed4ceb894a89", "node_type": "1", "metadata": {}, "hash": "235da3bacedc54432a8c208afd8ad493bc9dfa9656a50123655dbea277b12514", "class_name": "RelatedNodeInfo"}}, "text": "6.3 Theoretical Analysis 516\n12.6.4 Summary 518\n12.6.5 Exercises 519\n12.7 Adagrad 519\n12.7.1 Sparse Features and Learning Rates 519\n12.7.2 Preconditioning 520\n12.7.3 The Algorithm 521\n12.7.4 Implementation from Scratch 523\n12.7.5 Concise Implementation 524\n12.7.6 Summary 524\n12.7.7 Exercises 525\n12.8 RMSProp 525\n12.8.1 The Algorithm 526\n12.8.2 Implementation from Scratch 526\n12.8.3 Concise Implementation 528\n12.8.4 Summary 528\n12.8.5 Exercises 529\n12.9 Adadelta 529\n12.9.1 The Algorithm 529\n12.9.2 Implementation 530\n12.9.3 Summary 531\n12.9.4 Exercises 532\n12.10 Adam 532\n12.10.1 The Algorithm 532\n12.10.2 Implementation 533\nxv\n12.10.3 Yogi 534\n12.10.4 Summary 535\n12.10.5 Exercises 536\n12.11 Learning Rate Scheduling 536\n12.11.1 Toy Problem 537\n12.11.2 Schedulers 539\n12.11.3 Policies 540\n12.11.4 Summary 545\n12.11.5 Exercises 545\n13 Computational Performance 547\n13.1 Compilers and Interpreters 547\n13.1.1 Symbolic Programming 548\n13.1.2 Hybrid Programming 549\n13.1.3 Hybridizing the Sequential Class 550\n13.1.4 Summary 552\n13.1.5 Exercises 552\n13.2 Asynchronous Computation 552\n13.2.1 Asynchrony via Backend 553\n13.2.2 Barriers and Blockers 554\n13.2.3 Improving Computation 555\n13.2.4 Summary 555\n13.2.5 Exercises 555\n13.3 Automatic Parallelism 555\n13.3.1 Parallel Computation on GPUs 556\n13.3.2 Parallel Computation and Communication 557\n13.3.3 Summary 558\n13.3.4 Exercises 559\n13.4 Hardware 559\n13.4.1 Computers 560\n13.4.2 Memory 561\n13.4.3 Storage 562\n13.4.4 CPUs 563\n13.4.5 GPUs and other Accelerators 566\n13.4.6 Networks and Buses 569\n13.4.7 More Latency Numbers 570\n13.4.8 Summary 571\n13.4.9 Exercises 571\n13.5 Training on Multiple GPUs 572\n13.5.1 Splitting the Problem 573\n13.5.2 Data Parallelism 574\n13.5.3 A Toy Network 575\n13.5.4 Data Synchronization 576\n13.5.5 Distributing Data 577\n13.5.6 Training 578\nxvi\n13.5.7 Summary 580\n13.5.8 Exercises 580\n13.6 Concise Implementation for Multiple GPUs 581\n13.6.1 A Toy Network 581\n13.6.2 Network Initialization 582\n13.6.3 Training 582\n13.6.4 Summary 583\n13.6.5 Exercises 584\n13.7 Parameter Servers 584\n13.7.1 Data-Parallel Training 584\n13.7.2 Ring Synchronization 586\n13.7.3 Multi-Machine Training 588\n13.7.4 Key\u2013Value Stores 589\n13.7.5 Summary 591\n13.7.6 Exercises 591\n14 Computer Vision 592\n14.1 Image Augmentation 592\n14.1.1 Common Image Augmentation Methods 593\n14.1.2 Training with Image Augmentation 596\n14.1.3 Summary 599\n14.1.4 Exercises 599\n14.2 Fine-Tuning 600\n14.2.1 Steps 600\n14.2.2 Hot Dog Recognition 601\n14.2.3 Summary 605\n14.2.4 Exercises 606\n14.3 Object Detection and Bounding Boxes 606\n14.3.1 Bounding Boxes 607\n14.3.2 Summary 609\n14.3.3 Exercises 609\n14.4 Anchor Boxes 609\n14.4.1 Generating Multiple Anchor Boxes 610\n14.4.", "mimetype": "text/plain", "start_char_idx": 15662, "end_char_idx": 18362, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "46c78bf2-500c-429f-9bd0-ed4ceb894a89": {"__data__": {"id_": "46c78bf2-500c-429f-9bd0-ed4ceb894a89", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "aa00d208-7795-4c59-9460-061cd07cfa76", "node_type": "1", "metadata": {}, "hash": "9b3784a67f30b6147ae80e7c8025f436280be0e5b92c645bc9fdf63ee052482c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "aa39f7c1-f5da-4dae-8033-1a5f49e94b47", "node_type": "1", "metadata": {}, "hash": "999380b4b243b5c0e4c9820fe7c14100bf04d7766b3e9ae8124848aa22dfbd03", "class_name": "RelatedNodeInfo"}}, "text": "7.4 Key\u2013Value Stores 589\n13.7.5 Summary 591\n13.7.6 Exercises 591\n14 Computer Vision 592\n14.1 Image Augmentation 592\n14.1.1 Common Image Augmentation Methods 593\n14.1.2 Training with Image Augmentation 596\n14.1.3 Summary 599\n14.1.4 Exercises 599\n14.2 Fine-Tuning 600\n14.2.1 Steps 600\n14.2.2 Hot Dog Recognition 601\n14.2.3 Summary 605\n14.2.4 Exercises 606\n14.3 Object Detection and Bounding Boxes 606\n14.3.1 Bounding Boxes 607\n14.3.2 Summary 609\n14.3.3 Exercises 609\n14.4 Anchor Boxes 609\n14.4.1 Generating Multiple Anchor Boxes 610\n14.4.2 Intersection over Union (IoU) 612\n14.4.3 Labeling Anchor Boxes in Training Data 613\n14.4.4 PredictingBoundingBoxeswithNon-MaximumSuppression 619\n14.4.5 Summary 622\n14.4.6 Exercises 623\n14.5 Multiscale Object Detection 623\n14.5.1 Multiscale Anchor Boxes 623\n14.5.2 Multiscale Detection 625\n14.5.3 Summary 626\n14.5.4 Exercises 626\n14.6 The Object Detection Dataset 627\n14.6.1 Downloading the Dataset 627\nxvii\n14.6.2 Reading the Dataset 627\n14.6.3 Demonstration 629\n14.6.4 Summary 629\n14.6.5 Exercises 630\n14.7 Single Shot Multibox Detection 630\n14.7.1 Model 630\n14.7.2 Training 636\n14.7.3 Prediction 638\n14.7.4 Summary 639\n14.7.5 Exercises 640\n14.8 Region-based CNNs (R-CNNs) 642\n14.8.1 R-CNNs 642\n14.8.2 Fast R-CNN 643\n14.8.3 Faster R-CNN 645\n14.8.4 Mask R-CNN 646\n14.8.5 Summary 647\n14.8.6 Exercises 647\n14.9 Semantic Segmentation and the Dataset 648\n14.9.1 Image Segmentation and Instance Segmentation 648\n14.9.2 The Pascal VOC2012 Semantic Segmentation Dataset 648\n14.9.3 Summary 654\n14.9.4 Exercises 654\n14.10 Transposed Convolution 654\n14.10.1 Basic Operation 654\n14.10.2 Padding, Strides, and Multiple Channels 656\n14.10.3 Connection to Matrix Transposition 657\n14.10.4 Summary 659\n14.10.5 Exercises 659\n14.11 Fully Convolutional Networks 659\n14.11.1 The Model 660\n14.11.2 Initializing Transposed Convolutional Layers 662\n14.11.3 Reading the Dataset 663\n14.11.4 Training 664\n14.11.5 Prediction 664\n14.11.6 Summary 666\n14.11.7 Exercises 666\n14.12 Neural Style Transfer 666\n14.12.1 Method 666\n14.12.2 Reading the Content and Style Images 668\n14.12.3 Preprocessing and Postprocessing 668\n14.12.4 Extracting Features 669\n14.12.5 Defining the Loss Function 670\n14.12.6 Initializing the Synthesized Image 672\n14.12.7 Training 673\n14.12.8 Summary 674\nxviii\n14.12.9 Exercises 674\n14.13 Image Classification (CIFAR-10) on Kaggle 674\n14.13.1 Obtaining and Organizing the Dataset 675\n14.13.2 Image Augmentation 678\n14.13.3 Reading the Dataset 678\n14.13.4 Defining the Model 679\n14.13.5 Defining the Training Function 679\n14.13.6 Training and Validating the Model 680\n14.13.7 Classifying the Testing Set and Submitting Results on Kaggle 680\n14.13.8 Summary 681\n14.13.9 Exercises 682\n14.14 Dog Breed Identification (ImageNet Dogs) on Kaggle 682\n14.14.1 Obtaining and Organizing the Dataset 682\n14.14.2 Image Augmentation 684\n14.14.", "mimetype": "text/plain", "start_char_idx": 17826, "end_char_idx": 20687, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "aa39f7c1-f5da-4dae-8033-1a5f49e94b47": {"__data__": {"id_": "aa39f7c1-f5da-4dae-8033-1a5f49e94b47", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "46c78bf2-500c-429f-9bd0-ed4ceb894a89", "node_type": "1", "metadata": {}, "hash": "235da3bacedc54432a8c208afd8ad493bc9dfa9656a50123655dbea277b12514", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e53e8d83-27b4-458e-b6d4-7fe075f7aff8", "node_type": "1", "metadata": {}, "hash": "7520f530c00c6987c594a23e0619f98222811ae7d3545a766e7f5af34d8963ea", "class_name": "RelatedNodeInfo"}}, "text": "12.8 Summary 674\nxviii\n14.12.9 Exercises 674\n14.13 Image Classification (CIFAR-10) on Kaggle 674\n14.13.1 Obtaining and Organizing the Dataset 675\n14.13.2 Image Augmentation 678\n14.13.3 Reading the Dataset 678\n14.13.4 Defining the Model 679\n14.13.5 Defining the Training Function 679\n14.13.6 Training and Validating the Model 680\n14.13.7 Classifying the Testing Set and Submitting Results on Kaggle 680\n14.13.8 Summary 681\n14.13.9 Exercises 682\n14.14 Dog Breed Identification (ImageNet Dogs) on Kaggle 682\n14.14.1 Obtaining and Organizing the Dataset 682\n14.14.2 Image Augmentation 684\n14.14.3 Reading the Dataset 685\n14.14.4 Fine-Tuning a Pretrained Model 685\n14.14.5 Defining the Training Function 686\n14.14.6 Training and Validating the Model 687\n14.14.7 Classifying the Testing Set and Submitting Results on Kaggle 688\n14.14.8 Summary 688\n14.14.9 Exercises 689\n15 Natural Language Processing: Pretraining 690\n15.1 Word Embedding (word2vec) 691\n15.1.1 One-Hot Vectors Are a Bad Choice 691\n15.1.2 Self-Supervised word2vec 691\n15.1.3 The Skip-Gram Model 692\n15.1.4 The Continuous Bag of Words (CBOW) Model 694\n15.1.5 Summary 695\n15.1.6 Exercises 695\n15.2 Approximate Training 696\n15.2.1 Negative Sampling 696\n15.2.2 Hierarchical Softmax 698\n15.2.3 Summary 699\n15.2.4 Exercises 699\n15.3 The Dataset for Pretraining Word Embeddings 699\n15.3.1 Reading the Dataset 699\n15.3.2 Subsampling 700\n15.3.3 Extracting Center Words and Context Words 702\n15.3.4 Negative Sampling 703\n15.3.5 Loading Training Examples in Minibatches 704\n15.3.6 Putting It All Together 705\n15.3.7 Summary 706\n15.3.8 Exercises 706\n15.4 Pretraining word2vec 707\nxix\n15.4.1 The Skip-Gram Model 707\n15.4.2 Training 708\n15.4.3 Applying Word Embeddings 711\n15.4.4 Summary 711\n15.4.5 Exercises 711\n15.5 Word Embedding with Global Vectors (GloVe) 711\n15.5.1 Skip-Gram with Global Corpus Statistics 712\n15.5.2 The GloVe Model 713\n15.5.3 Interpreting GloVe from the Ratio of Co-occurrence\nProbabilities 713\n15.5.4 Summary 715\n15.5.5 Exercises 715\n15.6 Subword Embedding 715\n15.6.1 The fastText Model 715\n15.6.2 Byte Pair Encoding 716\n15.6.3 Summary 719\n15.6.4 Exercises 719\n15.7 Word Similarity and Analogy 720\n15.7.1 Loading Pretrained Word Vectors 720\n15.7.2 Applying Pretrained Word Vectors 722\n15.7.3 Summary 724\n15.7.4 Exercises 724\n15.8 Bidirectional Encoder Representations from Transformers (BERT) 724\n15.8.1 From Context-Independent to Context-Sensitive 724\n15.8.2 From Task-Specific to Task-Agnostic 725\n15.8.3 BERT: Combining the Best of Both Worlds 725\n15.8.4 Input Representation 726\n15.8.5 Pretraining Tasks 728\n15.8.6 Putting It All Together 731\n15.8.7 Summary 732\n15.8.8 Exercises 733\n15.9 The Dataset for Pretraining BERT 733\n15.9.1 Defining Helper Functions for Pretraining Tasks 734\n15.9.2 Transforming Text into the Pretraining Dataset 736\n15.9.3 Summary 738\n15.9.4 Exercises 739\n15.10 Pretraining BERT 739\n15.10.1 Pretraining BERT 739\n15.10.", "mimetype": "text/plain", "start_char_idx": 20096, "end_char_idx": 23015, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e53e8d83-27b4-458e-b6d4-7fe075f7aff8": {"__data__": {"id_": "e53e8d83-27b4-458e-b6d4-7fe075f7aff8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "aa39f7c1-f5da-4dae-8033-1a5f49e94b47", "node_type": "1", "metadata": {}, "hash": "999380b4b243b5c0e4c9820fe7c14100bf04d7766b3e9ae8124848aa22dfbd03", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5df950dc-1329-403a-b7f7-13e1e8880ee4", "node_type": "1", "metadata": {}, "hash": "5ef8625cb504e07f38b70049d18ecb7e09027c782b843d392b67cabaa13ba7d8", "class_name": "RelatedNodeInfo"}}, "text": "8.1 From Context-Independent to Context-Sensitive 724\n15.8.2 From Task-Specific to Task-Agnostic 725\n15.8.3 BERT: Combining the Best of Both Worlds 725\n15.8.4 Input Representation 726\n15.8.5 Pretraining Tasks 728\n15.8.6 Putting It All Together 731\n15.8.7 Summary 732\n15.8.8 Exercises 733\n15.9 The Dataset for Pretraining BERT 733\n15.9.1 Defining Helper Functions for Pretraining Tasks 734\n15.9.2 Transforming Text into the Pretraining Dataset 736\n15.9.3 Summary 738\n15.9.4 Exercises 739\n15.10 Pretraining BERT 739\n15.10.1 Pretraining BERT 739\n15.10.2 Representing Text with BERT 741\n15.10.3 Summary 742\n15.10.4 Exercises 743\n16 Natural Language Processing: Applications 744\n16.1 Sentiment Analysis and the Dataset 745\n16.1.1 Reading the Dataset 745\nxx\n16.1.2 Preprocessing the Dataset 746\n16.1.3 Creating Data Iterators 747\n16.1.4 Putting It All Together 747\n16.1.5 Summary 748\n16.1.6 Exercises 748\n16.2 Sentiment Analysis: Using Recurrent Neural Networks 748\n16.2.1 Representing Single Text with RNNs 749\n16.2.2 Loading Pretrained Word Vectors 750\n16.2.3 Training and Evaluating the Model 751\n16.2.4 Summary 751\n16.2.5 Exercises 752\n16.3 Sentiment Analysis: Using Convolutional Neural Networks 752\n16.3.1 One-Dimensional Convolutions 753\n16.3.2 Max-Over-Time Pooling 754\n16.3.3 The textCNN Model 755\n16.3.4 Summary 758\n16.3.5 Exercises 758\n16.4 Natural Language Inference and the Dataset 759\n16.4.1 Natural Language Inference 759\n16.4.2 The Stanford Natural Language Inference (SNLI) Dataset 760\n16.4.3 Summary 763\n16.4.4 Exercises 763\n16.5 Natural Language Inference: Using Attention 763\n16.5.1 The Model 764\n16.5.2 Training and Evaluating the Model 768\n16.5.3 Summary 770\n16.5.4 Exercises 770\n16.6 Fine-Tuning BERT for Sequence-Level and Token-Level Applications 771\n16.6.1 Single Text Classification 771\n16.6.2 Text Pair Classification or Regression 772\n16.6.3 Text Tagging 773\n16.6.4 Question Answering 773\n16.6.5 Summary 774\n16.6.6 Exercises 774\n16.7 Natural Language Inference: Fine-Tuning BERT 775\n16.7.1 Loading Pretrained BERT 775\n16.7.2 The Dataset for Fine-Tuning BERT 776\n16.7.3 Fine-Tuning BERT 778\n16.7.4 Summary 779\n16.7.5 Exercises 779\n17 Reinforcement Learning 781\n17.1 Markov Decision Process (MDP) 782\n17.1.1 Definition of an MDP 782\n17.1.2 Return and Discount Factor 783\nxxi\n17.1.3 Discussion of the Markov Assumption 784\n17.1.4 Summary 785\n17.1.5 Exercises 785\n17.2 Value Iteration 785\n17.2.1 Stochastic Policy 785\n17.2.2 Value Function 786\n17.2.3 Action-Value Function 786\n17.2.4 Optimal Stochastic Policy 787\n17.2.5 Principle of Dynamic Programming 787\n17.2.6 Value Iteration 788\n17.2.7 Policy Evaluation 788\n17.2.8 Implementation of Value Iteration 789\n17.2.9 Summary 790\n17.2.10 Exercises 791\n17.3 Q-Learning 791\n17.3.1 The Q-Learning Algorithm 791\n17.3.2 An Optimization Problem Underlying Q-Learning 791\n17.3.3 Exploration in Q-Learning 793\n17.3.4 The \u201cSelf-correcting\u201d Property of Q-Learning 793\n17.3.5 Implementation of Q-Learning 794\n17.3.", "mimetype": "text/plain", "start_char_idx": 22466, "end_char_idx": 25436, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5df950dc-1329-403a-b7f7-13e1e8880ee4": {"__data__": {"id_": "5df950dc-1329-403a-b7f7-13e1e8880ee4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e53e8d83-27b4-458e-b6d4-7fe075f7aff8", "node_type": "1", "metadata": {}, "hash": "7520f530c00c6987c594a23e0619f98222811ae7d3545a766e7f5af34d8963ea", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ff4ffe15-fb0f-44fb-a002-54a16e1a5b1f", "node_type": "1", "metadata": {}, "hash": "e1ec660aebdc2d7f4ec3ed274555e53111e4eee49448066eba6f1c305ed4e9c3", "class_name": "RelatedNodeInfo"}}, "text": "2.1 Stochastic Policy 785\n17.2.2 Value Function 786\n17.2.3 Action-Value Function 786\n17.2.4 Optimal Stochastic Policy 787\n17.2.5 Principle of Dynamic Programming 787\n17.2.6 Value Iteration 788\n17.2.7 Policy Evaluation 788\n17.2.8 Implementation of Value Iteration 789\n17.2.9 Summary 790\n17.2.10 Exercises 791\n17.3 Q-Learning 791\n17.3.1 The Q-Learning Algorithm 791\n17.3.2 An Optimization Problem Underlying Q-Learning 791\n17.3.3 Exploration in Q-Learning 793\n17.3.4 The \u201cSelf-correcting\u201d Property of Q-Learning 793\n17.3.5 Implementation of Q-Learning 794\n17.3.6 Summary 795\n17.3.7 Exercises 796\n18 Gaussian Processes 797\n18.1 Introduction to Gaussian Processes 798\n18.1.1 Summary 807\n18.1.2 Exercises 808\n18.2 Gaussian Process Priors 809\n18.2.1 Definition 809\n18.2.2 A Simple Gaussian Process 810\n18.2.3 From Weight Space to Function Space 811\n18.2.4 The Radial Basis Function (RBF) Kernel 811\n18.2.5 The Neural Network Kernel 813\n18.2.6 Summary 814\n18.2.7 Exercises 814\n18.3 Gaussian Process Inference 815\n18.3.1 Posterior Inference for Regression 815\n18.3.2 Equations for Making Predictions and Learning Kernel\nHyperparameters in GP Regression 817\n18.3.3 Interpreting Equations for Learning and Predictions 817\n18.3.4 Worked Example from Scratch 818\n18.3.5 Making Life Easy with GPyTorch 822\n18.3.6 Summary 825\n18.3.7 Exercises 826\nxxii\n19 Hyperparameter Optimization 828\n19.1 What Is Hyperparameter Optimization?", "mimetype": "text/plain", "start_char_idx": 24877, "end_char_idx": 26291, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ff4ffe15-fb0f-44fb-a002-54a16e1a5b1f": {"__data__": {"id_": "ff4ffe15-fb0f-44fb-a002-54a16e1a5b1f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5df950dc-1329-403a-b7f7-13e1e8880ee4", "node_type": "1", "metadata": {}, "hash": "5ef8625cb504e07f38b70049d18ecb7e09027c782b843d392b67cabaa13ba7d8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0b338cb1-20e5-433b-a0da-58f00e3fb91c", "node_type": "1", "metadata": {}, "hash": "c2affa291b61e970779a3c1137e01b84f474525499a56cec91cf16eab696c3d0", "class_name": "RelatedNodeInfo"}}, "text": "2.3 From Weight Space to Function Space 811\n18.2.4 The Radial Basis Function (RBF) Kernel 811\n18.2.5 The Neural Network Kernel 813\n18.2.6 Summary 814\n18.2.7 Exercises 814\n18.3 Gaussian Process Inference 815\n18.3.1 Posterior Inference for Regression 815\n18.3.2 Equations for Making Predictions and Learning Kernel\nHyperparameters in GP Regression 817\n18.3.3 Interpreting Equations for Learning and Predictions 817\n18.3.4 Worked Example from Scratch 818\n18.3.5 Making Life Easy with GPyTorch 822\n18.3.6 Summary 825\n18.3.7 Exercises 826\nxxii\n19 Hyperparameter Optimization 828\n19.1 What Is Hyperparameter Optimization? 828\n19.1.1 The Optimization Problem 829\n19.1.2 Random Search 832\n19.1.3 Summary 834\n19.1.4 Exercises 835\n19.2 Hyperparameter Optimization API 836\n19.2.1 Searcher 836\n19.2.2 Scheduler 837\n19.2.3 Tuner 837\n19.2.4 Bookkeeping the Performance of HPO Algorithms 838\n19.2.5 Example: Optimizing the Hyperparameters of a Convolu-\ntional Neural Network 839\n19.2.6 Comparing HPO Algorithms 841\n19.2.7 Summary 842\n19.2.8 Exercises 842\n19.3 Asynchronous Random Search 843\n19.3.1 Objective Function 844\n19.3.2 Asynchronous Scheduler 845\n19.3.3 Visualize the Asynchronous Optimization Process 851\n19.3.4 Summary 852\n19.3.5 Exercises 853\n19.4 Multi-Fidelity Hyperparameter Optimization 853\n19.4.1 Successive Halving 855\n19.4.2 Summary 866\n19.5 Asynchronous Successive Halving 867\n19.5.1 Objective Function 869\n19.5.2 Asynchronous Scheduler 870\n19.5.3 Visualize the Optimization Process 879\n19.5.4 Summary 879\n20 Generative Adversarial Networks 880\n20.1 Generative Adversarial Networks 880\n20.1.1 Generate Some \u201cReal\u201d Data 882\n20.1.2 Generator 883\n20.1.3 Discriminator 883\n20.1.4 Training 883\n20.1.5 Summary 885\n20.1.6 Exercises 885\n20.2 Deep Convolutional Generative Adversarial Networks 886\n20.2.1 The Pokemon Dataset 886\n20.2.2 The Generator 887\n20.2.3 Discriminator 889\n20.2.4 Training 891\n20.2.5 Summary 892\nxxiii\nxxiv Contents\n20.2.6 Exercises 892\n21 Recommender Systems 893\n21.1 Overview of Recommender Systems 893\n21.1.1 Collaborative Filtering 894\n21.1.2 Explicit Feedback and Implicit Feedback 895\n21.1.3 Recommendation Tasks 895\n21.1.4 Summary 895\n21.1.5 Exercises 895\nAppendix A Mathematics for Deep Learning 897\nAppendix B Tools for Deep Learning 1035\nReferences 1089\nPreface\nJust a few years ago, there were no legions of deep learning scientists developing intelli-\ngent products and services at major companies and startups. When we entered the field,\nmachinelearningdidnotcommandheadlinesindailynewspapers. Ourparentshadnoidea\nwhatmachinelearningwas, letalonewhywemightpreferittoacareerinmedicineorlaw.\nMachine learning was a blue skies academic discipline whose industrial significance was\nlimited to a narrow set of real-world applications, including speech recognition and com-\nputer vision. Moreover, many of these applications required so much domain knowledge\nthat they were often regarded as entirely separate areas for which machine learning was\none small component. At that time, neural networks\u2014the predecessors of the deep learn-\ning methods that we focus on in this book\u2014were generally regarded as outmoded.\nYet in just few years, deep learning has taken the world by surprise, driving rapid progress\nin such diverse fields as computer vision, natural language processing, automatic speech\nrecognition, reinforcement learning, and biomedical informatics. Moreover, the success\nof deep learning in so many tasks of practical interest has even catalyzed developments in\ntheoreticalmachinelearningandstatistics.", "mimetype": "text/plain", "start_char_idx": 25676, "end_char_idx": 29213, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0b338cb1-20e5-433b-a0da-58f00e3fb91c": {"__data__": {"id_": "0b338cb1-20e5-433b-a0da-58f00e3fb91c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ff4ffe15-fb0f-44fb-a002-54a16e1a5b1f", "node_type": "1", "metadata": {}, "hash": "e1ec660aebdc2d7f4ec3ed274555e53111e4eee49448066eba6f1c305ed4e9c3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fd54ecda-fa15-4467-b87f-8cafe7ea8434", "node_type": "1", "metadata": {}, "hash": "cb17104eec8844b925d8460b2aa2ea15bac0b50d8ad687f96d62992df6d51129", "class_name": "RelatedNodeInfo"}}, "text": "Machine learning was a blue skies academic discipline whose industrial significance was\nlimited to a narrow set of real-world applications, including speech recognition and com-\nputer vision. Moreover, many of these applications required so much domain knowledge\nthat they were often regarded as entirely separate areas for which machine learning was\none small component. At that time, neural networks\u2014the predecessors of the deep learn-\ning methods that we focus on in this book\u2014were generally regarded as outmoded.\nYet in just few years, deep learning has taken the world by surprise, driving rapid progress\nin such diverse fields as computer vision, natural language processing, automatic speech\nrecognition, reinforcement learning, and biomedical informatics. Moreover, the success\nof deep learning in so many tasks of practical interest has even catalyzed developments in\ntheoreticalmachinelearningandstatistics. Withtheseadvancesinhand, wecannowbuild\ncars that drive themselves with more autonomy than ever before (though less autonomy\nthansomecompaniesmighthaveyoubelieve),dialoguesystemsthatdebugcodebyasking\nclarifying questions, and software agents beating the best human players in the world at\nboardgamessuchas Go, a featonce thought tobe decades away. Already, thesetools exert\never-wider influence on industry and society, changing the way movies are made, diseases\nare diagnosed, and playing a growing role in basic sciences\u2014from astrophysics, to climate\nmodeling, to weather prediction, to biomedicine.\nAboutThis Book\nThis book represents our attempt to make deep learning approachable, teaching you the\nconcepts , thecontext, and thecode.\nOne Medium Combining Code, Math, and HTML\nFor any computing technology to reach its full impact, it must be well understood, well\ndocumented, and supported by mature, well-maintained tools. The key ideas should be\nclearly distilled, minimizing the onboarding time needed to bring new practitioners up to\nxxv\nxxvi Preface\n1\n2date. Mature libraries should automate common tasks, and exemplar code should make\nit easy for practitioners to modify, apply, and extend common applications to suit their\nneeds.\nAs an example, take dynamic web applications. Despite a large number of companies,\nsuch as Amazon, developing successful database-driven web applications in the 1990s, the\npotentialofthistechnologytoaidcreativeentrepreneurswasrealizedtoafargreaterdegree\nonly in the past ten years, owing in part to the development of powerful, well-documented\nframeworks.\nTesting the potential of deep learning presents unique challenges because any single appli-\ncationbringstogethervariousdisciplines. Applyingdeeplearningrequiressimultaneously\nunderstanding (i) the motivations for casting a problem in a particular way; (ii) the math-\nematical form of a given model; (iii) the optimization algorithms for fitting the models to\ndata;(iv)thestatisticalprinciplesthattelluswhenweshouldexpectourmodelstogeneral-\nize to unseen data and practical methods for certifying that they have, in fact, generalized;\nand (v) the engineering techniques required to train models efficiently, navigating the pit-\nfalls of numerical computing and getting the most out of available hardware. Teaching the\ncritical thinking skills required to formulate problems, the mathematics to solve them, and\nthe software tools to implement those solutions all in one place presents formidable chal-\nlenges. Ourgoalinthisbookistopresentaunifiedresourcetobringwould-bepractitioners\nup to speed.\nWhenwestartedthisbookproject,therewerenoresourcesthatsimultaneously(i)remained\nup to date; (ii) covered the breadth of modern machine learning practices with sufficient\ntechnical depth; and (iii) interleaved exposition of the quality one expects of a textbook\nwith the clean runnable code that one expects of a hands-on tutorial. We found plenty of\ncode examples illustrating how to use a given deep learning framework (e.g., how to do\nbasic numerical computing with matrices in TensorFlow) or for implementing particular\ntechniques (e.g., code snippets for LeNet, AlexNet, ResNet, etc.) scattered across various\nblog posts and GitHub repositories. However, these examples typically focused on howto\nimplement a given approach, but left out the discussion of whycertain algorithmic deci-\nsionsaremade. Whilesomeinteractiveresourceshavepoppedupsporadicallytoaddressa\nparticulartopic,e.g.,theengagingblogpostspublishedonthewebsite Distill1,orpersonal\nblogs,theyonlycoveredselectedtopicsindeeplearning, andoftenlackedassociatedcode.", "mimetype": "text/plain", "start_char_idx": 28296, "end_char_idx": 32834, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fd54ecda-fa15-4467-b87f-8cafe7ea8434": {"__data__": {"id_": "fd54ecda-fa15-4467-b87f-8cafe7ea8434", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0b338cb1-20e5-433b-a0da-58f00e3fb91c", "node_type": "1", "metadata": {}, "hash": "c2affa291b61e970779a3c1137e01b84f474525499a56cec91cf16eab696c3d0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "257d7b50-3303-4dcd-8b76-5c502bf9664f", "node_type": "1", "metadata": {}, "hash": "0cd7e861ee423d4fb35418796a6d664504a62d25244d8caf9d7c412681b9a0a0", "class_name": "RelatedNodeInfo"}}, "text": "We found plenty of\ncode examples illustrating how to use a given deep learning framework (e.g., how to do\nbasic numerical computing with matrices in TensorFlow) or for implementing particular\ntechniques (e.g., code snippets for LeNet, AlexNet, ResNet, etc.) scattered across various\nblog posts and GitHub repositories. However, these examples typically focused on howto\nimplement a given approach, but left out the discussion of whycertain algorithmic deci-\nsionsaremade. Whilesomeinteractiveresourceshavepoppedupsporadicallytoaddressa\nparticulartopic,e.g.,theengagingblogpostspublishedonthewebsite Distill1,orpersonal\nblogs,theyonlycoveredselectedtopicsindeeplearning, andoftenlackedassociatedcode.\nOn the other hand, while several deep learning textbooks have emerged\u2014e.g., Goodfellow\net al.(2016), which offers a comprehensive survey on the basics of deep learning\u2014these\nresources do not marry the descriptions to realizations of the concepts in code, sometimes\nleaving readers clueless as to how to implement them. Moreover, too many resources are\nhidden behind the paywalls of commercial course providers.\nWesetouttocreatearesourcethatcould(i)befreelyavailableforeveryone; (ii)offersuffi-\ncienttechnicaldepthtoprovideastartingpointonthepathtoactuallybecominganapplied\nmachine learning scientist; (iii) include runnable code, showing readers howto solve prob-\nlemsinpractice;(iv)allowforrapidupdates,bothbyusandalsobythecommunityatlarge;\nand (v) be complemented by a forum2for interactive discussion of technical details and to\nanswer questions.\nxxvii Preface\nThesegoalswereofteninconflict. Equations,theorems,andcitationsarebestmanagedand\nlaid out in LaTeX. Code is best described in Python. And webpages are native in HTML\nandJavaScript. Furthermore,wewantthecontenttobeaccessiblebothasexecutablecode,\nasaphysicalbook,asadownloadablePDF,andontheInternetasawebsite. Noworkflows\nseemed suited to these demands, so we decided to assemble our own ( Section B.6 ). We\nsettled on GitHub to share the source and to facilitate community contributions; Jupyter\nnotebooksformixingcode,equationsandtext;Sphinxasarenderingengine;andDiscourse\nasadiscussionplatform. Whileoursystemisnotperfect,thesechoicesstrikeacompromise\namongthecompetingconcerns. Webelievethat DiveintoDeepLearning mightbethefirst\nbook published using such an integrated workflow.\nLearningbyDoing\nMany textbooks present concepts in succession, covering each in exhaustive detail. For\nexample, the excellent textbook of Bishop ( 2006), teaches each topic so thoroughly that\ngetting to the chapter on linear regression requires a nontrivial amount of work. While\nexpertslovethisbookpreciselyforitsthoroughness,fortruebeginners,thispropertylimits\nits usefulness as an introductory text.\nIn this book, we teach most concepts just in time . In other words, you will learn concepts\nat the very moment that they are needed to accomplish some practical end. While we\ntake some time at the outset to teach fundamental preliminaries, like linear algebra and\nprobability,wewantyoutotastethesatisfactionoftrainingyourfirstmodelbeforeworrying\nabout more esoteric concepts.\nAside from a few preliminary notebooks that provide a crash course in the basic mathe-\nmatical background, each subsequent chapter both introduces a reasonable number of new\nconcepts and provides several self-contained working examples, using real datasets. This\npresented an organizational challenge. Some models might logically be grouped together\nin a single notebook. And some ideas might be best taught by executing several models\nin succession. By contrast, there is a big advantage to adhering to a policy of one working\nexample,onenotebook : Thismakesitaseasyaspossibleforyoutostartyourownresearch\nprojects by leveraging our code. Just copy a notebook and start modifying it.\nThroughout, we interleave the runnable code with background material as needed. In gen-\neral, we err on the side of making tools available before explaining them fully (often filling\nin the background later). For instance, we might use stochastic gradient descent before\nexplaining why it is useful or offering some intuition for why it works. This helps to give\npractitionersthenecessaryammunitiontosolveproblemsquickly, attheexpenseofrequir-\ning the reader to trust us with some curatorial decisions.\nThis book teaches deep learning concepts from scratch.", "mimetype": "text/plain", "start_char_idx": 32135, "end_char_idx": 36499, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "257d7b50-3303-4dcd-8b76-5c502bf9664f": {"__data__": {"id_": "257d7b50-3303-4dcd-8b76-5c502bf9664f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fd54ecda-fa15-4467-b87f-8cafe7ea8434", "node_type": "1", "metadata": {}, "hash": "cb17104eec8844b925d8460b2aa2ea15bac0b50d8ad687f96d62992df6d51129", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d5b9712c-1dc8-401a-85fa-e65b88f9b380", "node_type": "1", "metadata": {}, "hash": "c61db6f21f7ad1c40f83fef64fb726b80193931b6d1fe4afb83e13f0bc3d239f", "class_name": "RelatedNodeInfo"}}, "text": "And some ideas might be best taught by executing several models\nin succession. By contrast, there is a big advantage to adhering to a policy of one working\nexample,onenotebook : Thismakesitaseasyaspossibleforyoutostartyourownresearch\nprojects by leveraging our code. Just copy a notebook and start modifying it.\nThroughout, we interleave the runnable code with background material as needed. In gen-\neral, we err on the side of making tools available before explaining them fully (often filling\nin the background later). For instance, we might use stochastic gradient descent before\nexplaining why it is useful or offering some intuition for why it works. This helps to give\npractitionersthenecessaryammunitiontosolveproblemsquickly, attheexpenseofrequir-\ning the reader to trust us with some curatorial decisions.\nThis book teaches deep learning concepts from scratch. Sometimes, we delve into fine\ndetails about models that would typically be hidden from users by modern deep learning\nframeworks. This comes up especially in the basic tutorials, where we want you to un-\nderstand everything that happens in a given layer or optimizer. In these cases, we often\npresent two versions of the example: one where we implement everything from scratch,\nrelying only on NumPy-like functionality and automatic differentiation, and a more prac-\nxxviii Preface\ntical example, where we write succinct code using the high-level APIs of deep learning\nframeworks. After explaining how some component works, we rely on the high-level API\nin subsequent tutorials.\nContent and Structure\nThebookcanbedividedintoroughlythreeparts,dealingwithpreliminaries,deeplearning\ntechniques, and advanced topics focused on real systems and applications ( Fig. 1).\ntFig. 1 Book structure.\n\u000fPart1: BasicsandPreliminaries .Chapter 1 is an introduction to deep learning. Then,\ninChapter2 ,wequicklybringyouuptospeedontheprerequisitesrequiredforhands-\non deep learning, such as how to store and manipulate data, and how to apply vari-\nousnumericaloperationsbasedonelementaryconceptsfromlinearalgebra, calculus,\nand probability. Chapter 3 andChapter 5 cover the most fundamental concepts and\ntechniques in deep learning, including regression and classification; linear models;\nmultilayer perceptrons; and overfitting and regularization.\n\u000fPart 2: Modern Deep Learning Techniques .Chapter 6 describes the key computa-\ntional components of deep learning systems and lays the groundwork for our sub-\nsequent implementations of more complex models. Next, Chapter 7 andChapter 8\npresent convolutional neural networks (CNNs), powerful tools that form the back-\nbone of most modern computer vision systems. Similarly, Chapter 9 andChapter 10\nintroducerecurrentneuralnetworks(RNNs),modelsthatexploitsequential(e.g.,tem-\nporal) structure in data and are commonly used for natural language processing and\ntime series prediction. In Chapter 11 , we describe a relatively new class of models,\nbased on so-called attention mechanisms , that has displaced RNNs as the dominant\narchitecture for most natural language processing tasks. These sections will bring\nyou up to speed on the most powerful and general tools that are widely used by deep\nlearning practitioners.\nxxix Preface\n3\u000fPart3: Scalability,E\ufb00iciency,andApplications (available online3). InChapter12,we\ndiscuss several common optimization algorithms used to train deep learning models.\nNext, in Chapter 13, we examine several key factors that influence the computational\nperformance of deep learning code. Then, in Chapter 14, we illustrate major applica-\ntions of deep learning in computer vision. Finally, in Chapter 15 and Chapter 16, we\ndemonstratehowtopretrainlanguagerepresentationmodelsandapplythemtonatural\nlanguage processing tasks.\nCode\nMostsectionsofthisbookfeatureexecutablecode. Webelievethatsomeintuitionsarebest\ndeveloped via trial and error, tweaking the code in small ways and observing the results.\nIdeally, an elegant mathematical theory might tell us precisely how to tweak our code to\nachieveadesiredresult. However,deeplearningpractitionerstodaymustoftentreadwhere\nno solid theory provides guidance. Despite our best attempts, formal explanations for the\nefficacy of various techniques are still lacking, for a variety of reasons: the mathematics to\ncharacterize these models can be so difficult; the explanation likely depends on properties\nof the data that currently lack clear definitions; and serious inquiry on these topics has\nonly recently kicked into high gear.", "mimetype": "text/plain", "start_char_idx": 35630, "end_char_idx": 40130, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d5b9712c-1dc8-401a-85fa-e65b88f9b380": {"__data__": {"id_": "d5b9712c-1dc8-401a-85fa-e65b88f9b380", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "257d7b50-3303-4dcd-8b76-5c502bf9664f", "node_type": "1", "metadata": {}, "hash": "0cd7e861ee423d4fb35418796a6d664504a62d25244d8caf9d7c412681b9a0a0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "00fb73c4-71ce-4a64-af5d-a8c10f6f2241", "node_type": "1", "metadata": {}, "hash": "bbb90fad6b9f1bbc21080da0e86e0a8a5ec468057b0870c126fe67a0c85195e5", "class_name": "RelatedNodeInfo"}}, "text": "Finally, in Chapter 15 and Chapter 16, we\ndemonstratehowtopretrainlanguagerepresentationmodelsandapplythemtonatural\nlanguage processing tasks.\nCode\nMostsectionsofthisbookfeatureexecutablecode. Webelievethatsomeintuitionsarebest\ndeveloped via trial and error, tweaking the code in small ways and observing the results.\nIdeally, an elegant mathematical theory might tell us precisely how to tweak our code to\nachieveadesiredresult. However,deeplearningpractitionerstodaymustoftentreadwhere\nno solid theory provides guidance. Despite our best attempts, formal explanations for the\nefficacy of various techniques are still lacking, for a variety of reasons: the mathematics to\ncharacterize these models can be so difficult; the explanation likely depends on properties\nof the data that currently lack clear definitions; and serious inquiry on these topics has\nonly recently kicked into high gear. We are hopeful that as the theory of deep learning\nprogresses,eachfutureeditionofthisbookwillprovideinsightsthateclipsethosepresently\navailable.\nToavoidunnecessaryrepetition,wecapturesomeofourmostfrequentlyimportedandused\nfunctions and classes in the d2lpackage. Throughout, we mark blocks of code (such as\nfunctions,classes,orcollectionofimportstatements)with #@savetoindicatethattheywill\nbe accessed later via the d2lpackage. We offer a detailed overview of these classes and\nfunctions in Section B.8 . The d2lpackage is lightweight and only requires the following\ndependencies:\n#@save\nimport collections\nimport hashlib\nimport inspect\nimport math\nimport os\nimport random\nimport re\nimport shutil\nimport sys\nimport tarfile\nimport time\nimport zipfile\nfrom collections import defaultdict\nimport pandas aspd\nimport requests\nfrom IPython import display\nfrom matplotlib import pyplot asplt\nfrom matplotlib_inline import backend_inline\nd2l =sys.modules[ __name__ ]\nxxx Preface\n4\n5\n6\n7\n8\n9\n10Most of the code in this book is based on PyTorch, a popular open-source framework that\nhas been enthusiastically embraced by the deep learning research community. All of the\ncode in this book has passed tests under the latest stable version of PyTorch. However, due\nto the rapid development of deep learning, some code in the print edition may not work\nproperly in future versions of PyTorch. We plan to keep the online version up to date.\nIn case you encounter any problems, please consult Installation (page xxxiv) to update\nyour code and runtime environment. Below lists dependencies in our PyTorch implemen-\ntation.\n#@save\nimport numpy asnp\nimport torch\nimport torchvision\nfrom PIL import Image\nfrom scipy .spatial import distance_matrix\nfrom torch import nn\nfrom torch .nnimport functional asF\nfrom torchvision import transforms\nTargetAudience\nThisbookisforstudents(undergraduateorgraduate),engineers,andresearchers,whoseek\na solid grasp of the practical techniques of deep learning. Because we explain every con-\nceptfromscratch,nopreviousbackgroundindeeplearningormachinelearningisrequired.\nFully explaining the methods of deep learning requires some mathematics and program-\nming, but we will only assume that you enter with some basics, including modest amounts\nof linear algebra, calculus, probability, and Python programming. Just in case you have\nforgotten anything, the online Appendix4provides a refresher on most of the mathematics\nyouwillfindinthisbook. Usually, wewillprioritizeintuitionandideasovermathematical\nrigor. If you would like to extend these foundations beyond the prerequisites to understand\nour book, we happily recommend some other terrific resources: Linear Analysis by Bol-\nlob\u00e1s (1999) covers linear algebra and functional analysis in great depth. All of Statistics\n(Wasserman, 2013 ) provides a marvelous introduction to statistics. Joe Blitzstein\u2019s books5\nandcourses6on probability and inference are pedagogical gems. And if you have not used\nPython before, you may want to peruse this Python tutorial7.\nNotebooks,Website,GitHub, and Forum\nAll of our notebooks are available for download on the D2L.ai website8and onGitHub9.\nAssociated with this book, we have launched a discussion forum, located at discuss.d2l.ai\n10. Whenever you have questions on any section of the book, you can find a link to the\nassociated discussion page at the end of each notebook.\nxxxi Preface\nAcknowledgments\nWeareindebtedtothehundredsofcontributorsforboththeEnglishandtheChinesedrafts.\nThey helped improve the content and offered valuable feedback.", "mimetype": "text/plain", "start_char_idx": 39238, "end_char_idx": 43680, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "00fb73c4-71ce-4a64-af5d-a8c10f6f2241": {"__data__": {"id_": "00fb73c4-71ce-4a64-af5d-a8c10f6f2241", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d5b9712c-1dc8-401a-85fa-e65b88f9b380", "node_type": "1", "metadata": {}, "hash": "c61db6f21f7ad1c40f83fef64fb726b80193931b6d1fe4afb83e13f0bc3d239f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a4d7efef-f070-43d5-ad09-30fdefef852e", "node_type": "1", "metadata": {}, "hash": "edaecb3dbc44db6f24f28150b98273dd9d8c1d70fe8288e4fa787965640aa730", "class_name": "RelatedNodeInfo"}}, "text": "All of Statistics\n(Wasserman, 2013 ) provides a marvelous introduction to statistics. Joe Blitzstein\u2019s books5\nandcourses6on probability and inference are pedagogical gems. And if you have not used\nPython before, you may want to peruse this Python tutorial7.\nNotebooks,Website,GitHub, and Forum\nAll of our notebooks are available for download on the D2L.ai website8and onGitHub9.\nAssociated with this book, we have launched a discussion forum, located at discuss.d2l.ai\n10. Whenever you have questions on any section of the book, you can find a link to the\nassociated discussion page at the end of each notebook.\nxxxi Preface\nAcknowledgments\nWeareindebtedtothehundredsofcontributorsforboththeEnglishandtheChinesedrafts.\nThey helped improve the content and offered valuable feedback. This book was originally\nimplemented with MXNet as the primary framework. We thank Anirudh Dagar and Yuan\nTang for adapting a majority part of earlier MXNet code into PyTorch and TensorFlow im-\nplementations, respectively. Since July 2021, we have redesigned and reimplemented this\nbook in PyTorch, MXNet, and TensorFlow, choosing PyTorch as the primary framework.\nWe thank Anirudh Dagar for adapting a majority part of more recent PyTorch code into\nJAX implementations. We thank Gaosheng Wu, Liujun Hu, Ge Zhang, and Jiehang Xie\nfrom Baidu for adapting a majority part of more recent PyTorch code into PaddlePaddle\nimplementations in the Chinese draft. We thank Shuai Zhang for integrating the LaTeX\nstyle from the press into the PDF building.\nOn GitHub, we thank every contributor of this English draft for making it better for ev-\neryone. Their GitHub IDs or names are (in no particular order): alxnorden, avinashingit,\nbowen0701, brettkoonce, Chaitanya Prakash Bapat, cryptonaut, Davide Fiocco, edgarro-\nman, gkutiel, JohnMitro, LiangPu, RahulAgarwal, MohamedAliJamaoui, Michael(Stu)\nStewart, Mike M\u00fcller, NRauschmayr, Prakhar Srivastav, sad-, sfermigier, Sheng Zha, sun-\ndeepteki, topecongiro, tpdi, vermicelli, Vishaal Kapoor, Vishwesh Ravi Shrimali, YaYaB,\nYuhong Chen, Evgeniy Smirnov, lgov, Simon Corston-Oliver, Igor Dzreyev, Ha Nguyen,\npmuens, Andrei Lukovenko, senorcinco, vfdev-5, dsweet, Mohammad Mahdi Rahimi, Ab-\nhishek Gupta, uwsd, DomKM, Lisa Oakley, Bowen Li, Aarush Ahuja, Prasanth Bud-\ndareddygari, brianhendee, mani2106, mtn, lkevinzc, caojilin, Lakshya, Fiete L\u00fcer, Surbhi\nVijayvargeeya, Muhyun Kim, dennismalmgren, adursun, Anirudh Dagar, liqingnz, Pe-\ndro Larroy, lgov, ati-ozgur, Jun Wu, Matthias Blume, Lin Yuan, geogunow, Josh Gard-\nner, Maximilian B\u00f6ther, Rakib Islam, Leonard Lausen, Abhinav Upadhyay, rongruosong,\nSteve Sedlmeyer, Ruslan Baratov, Rafael Schlatter, liusy182, Giannis Pappas, ati-ozgur,\nqbaza, dchoi77, Adam Gerson, Phuc Le, Mark Atwood, christabella, vn09, Haibin Lin,\njjangga0214, RichyChen, noelo, hansent, Giel Dops, dvincent1337, WhiteD3vil, Peter\nKulits, codypenta, joseppinilla, ahmaurya, karolszk, heytitle, Peter Goetz, rigtorp, Tiep\nVu,sfilip,mlxd,Kale-abTessera,SanjarAdilov,MatteoFerrara,hsneto,KatarzynaBiesial-\nska, Gregory Bruss, Duy\u2013Thanh Doan, paulaurel, graytowne, Duc Pham, sl7423, Jaedong\nHwang, Yida Wang, cys4, clhm, Jean Kaddour, austinmw,", "mimetype": "text/plain", "start_char_idx": 42899, "end_char_idx": 46089, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a4d7efef-f070-43d5-ad09-30fdefef852e": {"__data__": {"id_": "a4d7efef-f070-43d5-ad09-30fdefef852e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "00fb73c4-71ce-4a64-af5d-a8c10f6f2241", "node_type": "1", "metadata": {}, "hash": "bbb90fad6b9f1bbc21080da0e86e0a8a5ec468057b0870c126fe67a0c85195e5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "373a6d13-c0eb-423b-b059-336b73998d0f", "node_type": "1", "metadata": {}, "hash": "1c1748cd440808ff51f8e1b7f9e2664f65345ab07aacfe4ba1658923ac5b1455", "class_name": "RelatedNodeInfo"}}, "text": "Adam Gerson, Phuc Le, Mark Atwood, christabella, vn09, Haibin Lin,\njjangga0214, RichyChen, noelo, hansent, Giel Dops, dvincent1337, WhiteD3vil, Peter\nKulits, codypenta, joseppinilla, ahmaurya, karolszk, heytitle, Peter Goetz, rigtorp, Tiep\nVu,sfilip,mlxd,Kale-abTessera,SanjarAdilov,MatteoFerrara,hsneto,KatarzynaBiesial-\nska, Gregory Bruss, Duy\u2013Thanh Doan, paulaurel, graytowne, Duc Pham, sl7423, Jaedong\nHwang, Yida Wang, cys4, clhm, Jean Kaddour, austinmw, trebeljahr, tbaums, Cuong V.\nNguyen, pavelkomarov, vzlamal, NotAnotherSystem, J-Arun-Mani, jancio, eldarkurtic,\nthe-great-shazbot, doctorcolossus, gducharme, cclauss, Daniel-Mietchen, hoonose, bia-\ngiom, abhinavsp0730, jonathanhrandall, ysraell, Nodar Okroshiashvili, UgurKap, Jiyang\nKang, StevenJokes, Tomer Kaftan, liweiwp, netyster, ypandya, NishantTharani, heiligerl,\nSportsTHU,HoaNguyen,manuel-arno-korfmann-webentwicklung,aterzis-personal,nxby,\nXiaoting He, Josiah Yoder, mathresearch, mzz2017, jroberayalas, iluu, ghejc, BSharmi,\nvkramdev,simonwardjones,LakshKD,TalNeoran,djliden,Nikhil95,OrenBarkan,guoweis,\nhaozhu233, pratikhack, YueYing, tayfununal, steinsag, charleybeller, AndrewLumsdaine,\nJiekui Zhang, Deepak Pathak, Florian Donhauser, Tim Gates, Adriaan Tijsseling, Ron\nxxxii Preface\n11Medina, Gaurav Saha, Murat Semerci, Lei Mao, Levi McClenny, Joshua Broyde, jake221,\njonbally, zyhazwraith, Brian Pulfer, Nick Tomasino, Lefan Zhang, Hongshen Yang, Vin-\nney Cavallo, yuntai, Yuanxiang Zhu, amarazov, pasricha, Ben Greenawald, Shivam Upad-\nhyay, Quanshangze Du, Biswajit Sahoo, Parthe Pandit, Ishan Kumar, HomunculusK, Lane\nSchwartz,varadgunjal,JasonWiener,ArminGholampoor,Shreshtha13,eigen-arnav,Hyeong-\ngyu Kim, EmilyOng, B\u00e1lint Mucs\u00e1nyi, Chase DuBois, Juntian Tao, Wenxiang Xu, Lifu\nHuang, filevich, quake2005, nils-werner, Yiming Li, Marsel Khisamutdinov, Francesco\n\u201cFuma\u201dFumagalli,PeilinSun,VincentGurgul,qingfengtommy,JanmeyShukla,MoShan,\nKaanSancak,regob,AlexSauer,GopalakrishnaRamachandra,TobiasUelwer,ChaoWang,\nTianCao,NicolasCorthorn,akash5474,kxxt,zxydi1992,JacobBritton,ShuangchiHe,zh-\nmou, krahets, Jie-Han Chen, Atishay Garg, Marcel Flygare, adtygan, Nik Vaessen, bolded,\nLouisSchlessinger,BalajiVaratharajan,atgctg,KaixinLi,VictorBarbaros,RiccardoMusto,\nElizabeth Ho, azimjonn, Guilherme Miotto, Alessandro Finamore, Joji Joseph, Anthony\nBiel,ZemingZhao,shjustinbaek,gab-chen,nantekoto,YutaroNishiyama,OrenAmsalem,\nTian-MaoMao, Amin Allahyar, Gijs van Tulder, Mikhail Berkov,", "mimetype": "text/plain", "start_char_idx": 45630, "end_char_idx": 48095, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "373a6d13-c0eb-423b-b059-336b73998d0f": {"__data__": {"id_": "373a6d13-c0eb-423b-b059-336b73998d0f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a4d7efef-f070-43d5-ad09-30fdefef852e", "node_type": "1", "metadata": {}, "hash": "edaecb3dbc44db6f24f28150b98273dd9d8c1d70fe8288e4fa787965640aa730", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5f934c3b-5adf-4c34-bde5-8ceedee0b6e1", "node_type": "1", "metadata": {}, "hash": "e06df89410cb6754713e166e778eac8ed6545a5a4506752ad785af57560a5596", "class_name": "RelatedNodeInfo"}}, "text": "ChaoWang,\nTianCao,NicolasCorthorn,akash5474,kxxt,zxydi1992,JacobBritton,ShuangchiHe,zh-\nmou, krahets, Jie-Han Chen, Atishay Garg, Marcel Flygare, adtygan, Nik Vaessen, bolded,\nLouisSchlessinger,BalajiVaratharajan,atgctg,KaixinLi,VictorBarbaros,RiccardoMusto,\nElizabeth Ho, azimjonn, Guilherme Miotto, Alessandro Finamore, Joji Joseph, Anthony\nBiel,ZemingZhao,shjustinbaek,gab-chen,nantekoto,YutaroNishiyama,OrenAmsalem,\nTian-MaoMao, Amin Allahyar, Gijs van Tulder, Mikhail Berkov, iamorphen, Matthew\nCaseres, Andrew Walsh, pggPL, RohanKarthikeyan, Ryan Choi, and Likun Lei.\nWe thank Amazon Web Services, especially Wen-Ming Ye, George Karypis, Swami Siva-\nsubramanian,PeterDeSantis,AdamSelipsky,andAndrewJassyfortheirgeneroussupport\nin writing this book. Without the available time, resources, discussions with colleagues,\nand continuous encouragement, this book would not have happened. During the prepara-\ntion of the book for publication, Cambridge University Press has offered excellent support.\nWethankourcommissioningeditorDavidTranahforhishelpandprofessionalism.\nSummary\nDeep learning has revolutionized pattern recognition, introducing technology that now\npowers a wide range of technologies, in such diverse fields as computer vision, natural\nlanguage processing, and automatic speech recognition. To successfully apply deep learn-\ning, you must understand how to cast a problem, the basic mathematics of modeling, the\nalgorithms for fitting your models to data, and the engineering techniques to implement it\nall. This book presents a comprehensive resource, including prose, figures, mathematics,\nand code, all in one place.\nExercises\n1.Register an account on the discussion forum of this book discuss.d2l.ai11.\n2.Install Python on your computer.\nxxxiii Preface\n123.Follow the links at the bottom of the section to the forum, where you will be able to\nseek out help and discuss the book and find answers to your questions by engaging the\nauthors and broader community.\nDiscussions12.\n13\n14\nInstallation\nInordertogetupandrunning,wewillneedanenvironmentforrunningPython,theJupyter\nNotebook, the relevant libraries, and the code needed to run the book itself.\nInstalling Miniconda\nYoursimplestoptionistoinstall Miniconda13. NotethatthePython3.xversionisrequired.\nYou can skip the following steps if your machine already has conda installed.\nVisit the Miniconda website and determine the appropriate version for your system based\non your Python 3.x version and machine architecture. Suppose that your Python version is\n3.9(ourtestedversion). IfyouareusingmacOS,youwoulddownloadthebashscriptwhose\nname contains the strings \u201cMacOSX\u201d, navigate to the download location, and execute the\ninstallation as follows (taking Intel Macs as an example):\n# The file name is subject to changes\nshMiniconda3-py39_4.12.0-MacOSX-x86_64.sh -b\nALinuxuserwoulddownloadthefilewhosenamecontainsthestrings\u201cLinux\u201dandexecute\nthe following at the download location:\n# The file name is subject to changes\nshMiniconda3-py39_4.12.0-Linux-x86_64.sh -b\nAWindowsuserwoulddownloadandinstallMinicondabyfollowingits onlineinstructions\n14. On Windows, you may search for cmdto open the Command Prompt (command-line\ninterpreter) for running commands.\nNext, initialize the shell so we can run condadirectly.\n~/miniconda3/bin/conda init\nThen close and reopen your current shell. You should be able to create a new environment\nas follows:\nxxxiv\nxxxv Installation\n15\n16conda create --name d2l python =3.9-y\nNow we can activate the d2lenvironment:\nconda activate d2l\nInstalling the Deep Learning Frameworkand the\nd2lPackage\nBefore installing any deep learning framework, please first check whether or not you have\nproper GPUs on your machine (the GPUs that power the display on a standard laptop are\nnot relevant for our purposes). For example, if your computer has NVIDIA GPUs and has\ninstalled CUDA15, then you are all set.", "mimetype": "text/plain", "start_char_idx": 47615, "end_char_idx": 51505, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5f934c3b-5adf-4c34-bde5-8ceedee0b6e1": {"__data__": {"id_": "5f934c3b-5adf-4c34-bde5-8ceedee0b6e1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "373a6d13-c0eb-423b-b059-336b73998d0f", "node_type": "1", "metadata": {}, "hash": "1c1748cd440808ff51f8e1b7f9e2664f65345ab07aacfe4ba1658923ac5b1455", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f9ed79d9-1e81-4faa-bb89-5d75c5994da8", "node_type": "1", "metadata": {}, "hash": "bf860a5f5479527dff84696752d1e1f0a63807de4fbe5d644dd37a1685325ee4", "class_name": "RelatedNodeInfo"}}, "text": "On Windows, you may search for cmdto open the Command Prompt (command-line\ninterpreter) for running commands.\nNext, initialize the shell so we can run condadirectly.\n~/miniconda3/bin/conda init\nThen close and reopen your current shell. You should be able to create a new environment\nas follows:\nxxxiv\nxxxv Installation\n15\n16conda create --name d2l python =3.9-y\nNow we can activate the d2lenvironment:\nconda activate d2l\nInstalling the Deep Learning Frameworkand the\nd2lPackage\nBefore installing any deep learning framework, please first check whether or not you have\nproper GPUs on your machine (the GPUs that power the display on a standard laptop are\nnot relevant for our purposes). For example, if your computer has NVIDIA GPUs and has\ninstalled CUDA15, then you are all set. If your machine does not house any GPU, there\nis no need to worry just yet. Your CPU provides more than enough horsepower to get you\nthrough the first few chapters. Just remember that you will want to access GPUs before\nrunning larger models.\nYoucan installPyTorch(the specified versionsare testedat the time ofwriting) with either\nCPU or GPU support as follows:\npip install torch ==2.0.0 torchvision ==0.15.1\nOur next step is to install the d2lpackage that we developed in order to encapsulate fre-\nquently used functions and classes found throughout this book:\npip install d2l==1.0.3\nDownloadingand Runningthe Code\nNext, you will want to download the notebooks so that you can run each of the book\u2019s\ncode blocks. Simply click on the \u201cNotebooks\u201d tab at the top of any HTML page on the\nD2L.ai website16to download the code and then unzip it. Alternatively, you can fetch the\nnotebooks from the command line as follows:\nmkdir d2l-en &&cdd2l-en\ncurl https://d2l.ai/d2l-en-1.0.3.zip -od2l-en.zip\nunzip d2l-en.zip &&rmd2l-en.zip\ncdpytorch\nxxxvi Installation\n17If you do not already have unzipinstalled, first run sudo apt-get install unzip . Now\nwe can start the Jupyter Notebook server by running:\njupyter notebook\nAtthispoint,youcanopen http://localhost:8888 (itmayhavealreadyopenedautomatically)\nin your web browser. Then we can run the code for each section of the book. Whenever\nyou open a new command line window, you will need to execute conda activate d2l\nto activate the runtime environment before running the D2L notebooks, or updating your\npackages(eitherthedeeplearningframeworkorthe d2lpackage). Toexittheenvironment,\nrunconda deactivate .\nDiscussions17.\nNotation\nThroughout this book, we adhere to the following notational conventions. Note that some\nof these symbols are placeholders, while others refer to specific objects. As a general rule\nof thumb, the indefinite article \u201ca\u201d often indicates that the symbol is a placeholder and that\nsimilarly formatted symbols can denote other objects of the same type. For example, \u201c \ud835\udc65: a\nscalar\u201d means that lowercased letters generally represent scalar values, but \u201c Z: the set of\nintegers\u201d refers specifically to the symbol Z.\nNumericalObjects\n\u000f\ud835\udc65: a scalar\n\u000fx: a vector\n\u000fX: a matrix\n\u000fX: a general tensor\n\u000fI: the identity matrix (of some given dimension), i.e. a square matrix with 1on all\ndiagonal entries and 0on all off-diagonals\n\u000f\ud835\udc65\ud835\udc56,\u00bbx\u00bc\ud835\udc56: the\ud835\udc56thelement of vector x\n\u000f\ud835\udc65\ud835\udc56\ud835\udc57,\ud835\udc65\ud835\udc56,\ud835\udc57,\u00bbX\u00bc\ud835\udc56\ud835\udc57,\u00bbX\u00bc\ud835\udc56,\ud835\udc57: the element of matrix Xat row\ud835\udc56and column \ud835\udc57.", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f9ed79d9-1e81-4faa-bb89-5d75c5994da8": {"__data__": {"id_": "f9ed79d9-1e81-4faa-bb89-5d75c5994da8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5f934c3b-5adf-4c34-bde5-8ceedee0b6e1", "node_type": "1", "metadata": {}, "hash": "e06df89410cb6754713e166e778eac8ed6545a5a4506752ad785af57560a5596", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fc246ea3-adfa-4cd0-87b9-ab0de35a9473", "node_type": "1", "metadata": {}, "hash": "562dabd2e726ab25a8e21362969c441f1257c8565e65b5f53e53d6269205c232", "class_name": "RelatedNodeInfo"}}, "text": "For example, \u201c \ud835\udc65: a\nscalar\u201d means that lowercased letters generally represent scalar values, but \u201c Z: the set of\nintegers\u201d refers specifically to the symbol Z.\nNumericalObjects\n\u000f\ud835\udc65: a scalar\n\u000fx: a vector\n\u000fX: a matrix\n\u000fX: a general tensor\n\u000fI: the identity matrix (of some given dimension), i.e. a square matrix with 1on all\ndiagonal entries and 0on all off-diagonals\n\u000f\ud835\udc65\ud835\udc56,\u00bbx\u00bc\ud835\udc56: the\ud835\udc56thelement of vector x\n\u000f\ud835\udc65\ud835\udc56\ud835\udc57,\ud835\udc65\ud835\udc56,\ud835\udc57,\u00bbX\u00bc\ud835\udc56\ud835\udc57,\u00bbX\u00bc\ud835\udc56,\ud835\udc57: the element of matrix Xat row\ud835\udc56and column \ud835\udc57.\nSetTheory\n\u000fX: a set\n\u000fZ: the set of integers\n\u000fZ\u00b8: the set of positive integers\n\u000fR: the set of real numbers\n\u000fR\ud835\udc5b: the set of\ud835\udc5b-dimensional vectors of real numbers\nxxxvii\nxxxviii Notation\n\u000fR\ud835\udc4e\u0002\ud835\udc4f: The set of matrices of real numbers with \ud835\udc4erows and\ud835\udc4fcolumns\n\u000fjXj: cardinality (number of elements) of set X\n\u000fA[B: union of setsAandB\n\u000fA\\B: intersection of sets AandB\n\u000fAnB: set subtraction of BfromA(contains only those elements of Athat do not\nbelong toB)\nFunctions and Operators\n\u000f\ud835\udc53\u00b9\u0001\u00ba: a function\n\u000flog\u00b9\u0001\u00ba: the natural logarithm (base \ud835\udc52)\n\u000flog2\u00b9\u0001\u00ba: logarithm to base 2\n\u000fexp\u00b9\u0001\u00ba: the exponential function\n\u000f1\u00b9\u0001\u00ba: the indicator function; evaluates to 1if the boolean argument is true, and 0other-\nwise\n\u000f1X\u00b9\ud835\udc67\u00ba: the set-membership indicator function; evaluates to 1if the element \ud835\udc67belongs to\nthe setXand0otherwise\n\u000f\u00b9\u0001\u00ba>: transpose of a vector or a matrix\n\u000fX\u00001: inverse of matrix X\n\u000f\f: Hadamard (elementwise) product\n\u000f\u00bb\u0001,\u0001\u00bc: concatenation\n\u000fk\u0001k\ud835\udc5d:\u2113\ud835\udc5dnorm\n\u000fk\u0001k:\u21132norm\n\u000fhx,yi: inner (dot) product of vectors xandy\n\u000f\u00cd: summation over a collection of elements\n\u000f\u00ce: product over a collection of elements\n\u000fdef=: an equality asserted as a definition of the symbol on the left-hand side\nxxxix Notation\n18Calculus\n\u000f\ud835\udc51\ud835\udc66\n\ud835\udc51\ud835\udc65: derivative of \ud835\udc66with respect to \ud835\udc65\n\u000f\ud835\udf15\ud835\udc66\n\ud835\udf15\ud835\udc65: partial derivative of \ud835\udc66with respect to \ud835\udc65\n\u000frx\ud835\udc66: gradient of \ud835\udc66with respect to x\n\u000f\u00af\ud835\udc4f\n\ud835\udc4e\ud835\udc53\u00b9\ud835\udc65\u00ba\ud835\udc51\ud835\udc65: definite integral of \ud835\udc53from\ud835\udc4eto\ud835\udc4fwith respect to \ud835\udc65\n\u000f\u00af\n\ud835\udc53\u00b9\ud835\udc65\u00ba\ud835\udc51\ud835\udc65: indefinite integral of \ud835\udc53with respect to \ud835\udc65\nProbabilityand InformationTheory\n\u000f\ud835\udc4b: a random variable\n\u000f\ud835\udc43: a probability distribution\n\u000f\ud835\udc4b\u0018\ud835\udc43: the random variable \ud835\udc4bfollows distribution \ud835\udc43\n\u000f\ud835\udc43\u00b9\ud835\udc4b=\ud835\udc65\u00ba: the probability assigned to the event where random variable \ud835\udc4btakes value\ud835\udc65\n\u000f\ud835\udc43\u00b9\ud835\udc4bj\ud835\udc4c\u00ba: the conditional probability distribution of \ud835\udc4bgiven\ud835\udc4c\n\u000f\ud835\udc5d\u00b9\u0001\u00ba: a probability density function (PDF) associated with distribution \ud835\udc43\n\u000f\ud835\udc38\u00bb\ud835\udc4b\u00bc: expectation of a random variable \ud835\udc4b\n\u000f\ud835\udc4b?\ud835\udc4c: random variables \ud835\udc4band\ud835\udc4care independent\n\u000f\ud835\udc4b?\ud835\udc4cj\ud835\udc4d: random variables \ud835\udc4band\ud835\udc4care conditionally independent given \ud835\udc4d\n\u000f\ud835\udf0e\ud835\udc4b: standard deviation of random variable \ud835\udc4b\n\u000fVar\u00b9\ud835\udc4b\u00ba: variance of random variable \ud835\udc4b, equal to\ud835\udf0e2\n\ud835\udc4b\n\u000fCov\u00b9\ud835\udc4b,", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fc246ea3-adfa-4cd0-87b9-ab0de35a9473": {"__data__": {"id_": "fc246ea3-adfa-4cd0-87b9-ab0de35a9473", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f9ed79d9-1e81-4faa-bb89-5d75c5994da8", "node_type": "1", "metadata": {}, "hash": "bf860a5f5479527dff84696752d1e1f0a63807de4fbe5d644dd37a1685325ee4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "041f8e3f-4237-43e5-8c1f-24e63629d5ff", "node_type": "1", "metadata": {}, "hash": "1793c32cdcfabe8dddbe5de723203a08d0ad3f1046510fd90d694b647df61ff9", "class_name": "RelatedNodeInfo"}}, "text": "equal to\ud835\udf0e2\n\ud835\udc4b\n\u000fCov\u00b9\ud835\udc4b,\ud835\udc4c\u00ba: covariance of random variables \ud835\udc4band\ud835\udc4c\n\u000f\ud835\udf0c\u00b9\ud835\udc4b,\ud835\udc4c\u00ba: the Pearson correlation coefficient between \ud835\udc4band\ud835\udc4c, equalsCov\u00b9\ud835\udc4b,\ud835\udc4c\u00ba\n\ud835\udf0e\ud835\udc4b\ud835\udf0e\ud835\udc4c\n\u000f\ud835\udc3b\u00b9\ud835\udc4b\u00ba: entropy of random variable \ud835\udc4b\n\u000f\ud835\udc37KL\u00b9\ud835\udc43k\ud835\udc44\u00ba: the KL-divergence (or relative entropy) from distribution \ud835\udc44to distribution\n\ud835\udc43\nDiscussions18.\n\n1 Introduction\nUntilrecently,nearlyeverycomputerprogramthatyoumighthaveinteractedwithduringan\nordinarydaywascodedupasarigidsetofrulesspecifyingpreciselyhowitshouldbehave.\nSay that we wanted to write an application to manage an e-commerce platform. After\nhuddling around a whiteboard for a few hours to ponder the problem, we might settle on\nthe broad strokes of a working solution, for example: (i) users interact with the application\nthrough an interface running in a web browser or mobile application; (ii) our application\ninteracts with a commercial-grade database engine to keep track of each user\u2019s state and\nmaintain records of historical transactions; and (iii) at the heart of our application, the\nbusiness logic (you might say, the brains) of our application spells out a set of rules that\nmap every conceivable circumstance to the corresponding action that our program should\ntake.\nTo build the brains of our application, we might enumerate all the common events that our\nprogram should handle. For example, whenever a customer clicks to add an item to their\nshoppingcart,ourprogramshouldaddanentrytotheshoppingcartdatabasetable,associ-\nating that user\u2019s ID with the requested product\u2019s ID. We might then attempt to step through\nevery possible corner case, testing the appropriateness of our rules and making any neces-\nsary modifications. What happens if a user initiates a purchase with an empty cart? While\nfew developers ever get it completely right the first time (it might take some test runs to\nwork out the kinks), for the most part we can write such programs and confidently launch\nthembeforeever seeing a real customer. Our ability to manually design automated sys-\ntems that drive functioning products and systems, often in novel situations, is a remarkable\ncognitive feat. And when you are able to devise solutions that work 100%of the time, you\ntypically should not be worrying about machine learning.\nFortunately for the growing community of machine learning scientists, many tasks that we\nwouldliketoautomatedonotbendsoeasilytohumaningenuity. Imaginehuddlingaround\nthe whiteboard with the smartest minds you know, but this time you are tackling one of the\nfollowing problems:\n\u000fWriteaprogramthatpredictstomorrow\u2019sweathergivengeographicinformation,satellite\nimages, and a trailing window of past weather.\n\u000fWriteaprogramthattakesinafactoidquestion,expressedinfree-formtext,andanswers\nit correctly.\n\u000fWrite a program that, given an image, identifies every person depicted in it and draws\noutlines around each.\n1\n2 Introduction\n\u000fWrite a program that presents users with products that they are likely to enjoy but un-\nlikely, in the natural course of browsing, to encounter.\nFor these problems, even elite programmers would struggle to code up solutions from\nscratch. The reasons can vary. Sometimes the program that we are looking for follows\na pattern that changes over time, so there is no fixed right answer! In such cases, any\nsuccessful solution must adapt gracefully to a changing world. At other times, the rela-\ntionship (say between pixels, and abstract categories) may be too complicated, requiring\nthousands or millions of computations and following unknown principles. In the case of\nimage recognition, the precise steps required to perform the task lie beyond our conscious\nunderstanding, even though our subconscious cognitive processes execute the task effort-\nlessly.\nMachinelearning is the study of algorithms that can learn from experience. As a machine\nlearning algorithm accumulates more experience, typically in the form of observational\ndata or interactions with an environment, its performance improves. Contrast this with\nour deterministic e-commerce platform, which follows the same business logic, no matter\nhow much experience accrues, until the developers themselves learn and decide that it is\ntime to update the software.", "mimetype": "text/plain", "start_char_idx": 56012, "end_char_idx": 60163, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "041f8e3f-4237-43e5-8c1f-24e63629d5ff": {"__data__": {"id_": "041f8e3f-4237-43e5-8c1f-24e63629d5ff", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fc246ea3-adfa-4cd0-87b9-ab0de35a9473", "node_type": "1", "metadata": {}, "hash": "562dabd2e726ab25a8e21362969c441f1257c8565e65b5f53e53d6269205c232", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "dd131950-5133-48b8-88c1-c7ce3f4ce169", "node_type": "1", "metadata": {}, "hash": "c873005fedd29789486a0910956c2d0e7679505193482c38a63d104e6c7ddc36", "class_name": "RelatedNodeInfo"}}, "text": "In such cases, any\nsuccessful solution must adapt gracefully to a changing world. At other times, the rela-\ntionship (say between pixels, and abstract categories) may be too complicated, requiring\nthousands or millions of computations and following unknown principles. In the case of\nimage recognition, the precise steps required to perform the task lie beyond our conscious\nunderstanding, even though our subconscious cognitive processes execute the task effort-\nlessly.\nMachinelearning is the study of algorithms that can learn from experience. As a machine\nlearning algorithm accumulates more experience, typically in the form of observational\ndata or interactions with an environment, its performance improves. Contrast this with\nour deterministic e-commerce platform, which follows the same business logic, no matter\nhow much experience accrues, until the developers themselves learn and decide that it is\ntime to update the software. In this book, we will teach you the fundamentals of machine\nlearning, focusing in particular on deep learning , a powerful set of techniques driving in-\nnovations in areas as diverse as computer vision, natural language processing, healthcare,\nand genomics.\n1.1AMotivatingExample\nBefore beginning writing, the authors of this book, like much of the work force, had to\nbecomecaffeinated. Wehoppedinthecarandstarteddriving. UsinganiPhone,Alexcalled\nout \u201cHey Siri\u201d, awakening the phone\u2019s voice recognition system. Then Mu commanded\n\u201cdirections to Blue Bottle coffee shop\u201d. The phone quickly displayed the transcription of\nhis command. It also recognized that we wereasking for directions and launched the Maps\napplication (app) to fulfill our request. Once launched, the Maps app identified a number\nof routes. Next to each route, the phone displayed a predicted transit time. While this story\nwas fabricated for pedagogical convenience, it demonstrates that in the span of just a few\nseconds,oureverydayinteractionswithasmartphonecanengageseveralmachinelearning\nmodels.\nImagine just writing a program to respond to a wakeword such as \u201cAlexa\u201d, \u201cOK Google\u201d,\nand \u201cHey Siri\u201d. Try coding it up in a room by yourself with nothing but a computer and\na code editor, as illustrated in Fig. 1.1.1 . How would you write such a program from first\nprinciples? Think about it\u2026 the problem is hard. Every second, the microphone will col-\nlect roughly 44,000 samples. Each sample is a measurement of the amplitude of the sound\nwave. What rule could map reliably from a snippet of raw audio to confident predictions\nfyes,nogaboutwhetherthesnippetcontainsthewakeword? Ifyouarestuck,donotworry.\n3 A Motivating Example\nWe do not know how to write such a program from scratch either. That is why we use ma-\nchine learning.\ntFig. 1.1.1 Identify a wake word.\nHere is the trick. Often, even when we do not know how to tell a computer explicitly how\nto map from inputs to outputs, we are nonetheless capable of performing the cognitive feat\nourselves. In other words, even if you do not know how to program a computer to rec-\nognize the word \u201cAlexa\u201d, you yourself are able to recognize it. Armed with this ability,\nwe can collect a huge datasetcontaining examples of audio snippets and associated labels,\nindicating which snippets contain the wake word. In the currently dominant approach to\nmachinelearning,wedonotattempttodesignasystem explicitly torecognizewakewords.\nInstead, we define a flexible program whose behavior is determined by a number of pa-\nrameters . Then we use the dataset to determine the best possible parameter values, i.e.,\nthose that improve the performance of our program with respect to a chosen performance\nmeasure.\nYou can think of the parameters as knobs that we can turn, manipulating the behavior of\nthe program. Once the parameters are fixed, we call the program a model. The set of all\ndistinct programs (input\u2013output mappings) that we can produce just by manipulating the\nparameters is called a familyof models. And the \u201cmeta-program\u201d that uses our dataset to\nchoose the parameters is called a learning algorithm .\nBefore we can go ahead and engage the learning algorithm, we have to define the problem\nprecisely, pinning down the exact nature of the inputs and outputs, and choosing an ap-\npropriate model family. In this case, our model receives a snippet of audio as input, and\nthe model generates a selection among fyes,nogasoutput. If all goes according to plan\nthe model\u2019s guesses will typically be correct as to whether the snippet contains the wake\nword.", "mimetype": "text/plain", "start_char_idx": 59224, "end_char_idx": 63733, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dd131950-5133-48b8-88c1-c7ce3f4ce169": {"__data__": {"id_": "dd131950-5133-48b8-88c1-c7ce3f4ce169", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "041f8e3f-4237-43e5-8c1f-24e63629d5ff", "node_type": "1", "metadata": {}, "hash": "1793c32cdcfabe8dddbe5de723203a08d0ad3f1046510fd90d694b647df61ff9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3a8acb83-750b-4acb-ad79-7aaf220d0c05", "node_type": "1", "metadata": {}, "hash": "6ac6bbf9e7895c69bab187451dfba0967cfa15f094a14d004772ae52b0ba6476", "class_name": "RelatedNodeInfo"}}, "text": "You can think of the parameters as knobs that we can turn, manipulating the behavior of\nthe program. Once the parameters are fixed, we call the program a model. The set of all\ndistinct programs (input\u2013output mappings) that we can produce just by manipulating the\nparameters is called a familyof models. And the \u201cmeta-program\u201d that uses our dataset to\nchoose the parameters is called a learning algorithm .\nBefore we can go ahead and engage the learning algorithm, we have to define the problem\nprecisely, pinning down the exact nature of the inputs and outputs, and choosing an ap-\npropriate model family. In this case, our model receives a snippet of audio as input, and\nthe model generates a selection among fyes,nogasoutput. If all goes according to plan\nthe model\u2019s guesses will typically be correct as to whether the snippet contains the wake\nword.\nIf we choose the right family of models, there should exist one setting of the knobs such\nthatthemodelfires\u201cyes\u201deverytimeithearstheword\u201cAlexa\u201d. Becausetheexactchoiceof\nthe wake word is arbitrary, we will probably need a model family sufficiently rich that, via\nanother setting of the knobs, it could fire \u201cyes\u201d only upon hearing the word \u201cApricot\u201d. We\nexpectthatthesamemodelfamilyshouldbesuitablefor\u201cAlexa\u201drecognitionand\u201cApricot\u201d\nrecognition because they seem, intuitively, to be similar tasks. However, we might need a\ndifferent family of models entirely if we want to deal with fundamentally different inputs\nor outputs, say if we wanted to map from images to captions, or from English sentences to\nChinese sentences.\nAs you might guess, if we just set all of the knobs randomly, it is unlikely that our model\nwill recognize \u201cAlexa\u201d, \u201cApricot\u201d, or any other English word. In machine learning, the\nlearning is the process by which we discover the right setting of the knobs for coercing the\n4 Introduction\ndesired behavior from our model. In other words, we trainour model with data. As shown\ninFig. 1.1.2 , the training process usually looks like the following:\n1.Start off with a randomly initialized model that cannot do anything useful.\n2.Grab some of your data (e.g., audio snippets and corresponding fyes,noglabels).\n3.Tweak the knobs to make the model perform better as assessed on those examples.\n4.Repeat Steps 2 and 3 until the model is awesome.\ntFig. 1.1.2 A typical training process.\nTo summarize, rather than code up a wakeword recognizer, wecode up a program that can\nlearnto recognize wake words, if presented with a large labeled dataset. You can think of\nthisactofdeterminingaprogram\u2019sbehaviorbypresentingitwithadatasetas programming\nwithdata . Thatistosay,wecan\u201cprogram\u201dacatdetectorbyprovidingourmachinelearning\nsystem with many examples of cats and dogs. This way the detector will eventually learn\nto emit a very large positive number if it is a cat, a very large negative number if it is a\ndog, andsomethingclosertozeroifitisnotsure. Thisbarelyscratchesthesurfaceofwhat\nmachine learning can do. Deep learning, which we will explain in greater detail later, is\njust one among many popular methods for solving machine learning problems.\n1.2KeyComponents\nIn our wake word example, we described a dataset consisting of audio snippets and binary\nlabels, and we gave a hand-wavy sense of how we might train a model to approximate a\nmapping from snippets to classifications. This sort of problem, where we try to predict a\ndesignated unknown label based on known inputs given a dataset consisting of examples\nforwhichthelabelsareknown, iscalled supervisedlearning . Thisisjustoneamongmany\nkinds of machine learning problems. Before we explore other varieties, we would like to\nshed more light on some core components that will follow us around, no matter what kind\nof machine learning problem we tackle:\n1.Thedatathat we can learn from.\n2.Amodelof how to transform the data.\n3.Anobjectivefunction that quantifies how well (or badly) the model is doing.\n4.Analgorithm to adjust the model\u2019s parameters to optimize the objective function.\n5 Key Components\n1.2.1Data\nIt might go without saying that you cannot do data science without data. We could lose\nhundreds of pages pondering what precisely data is, but for now, we will focus on the key\npropertiesofthedatasetsthatwewillbeconcernedwith. Generally,weareconcernedwith\na collection of examples.", "mimetype": "text/plain", "start_char_idx": 62880, "end_char_idx": 67193, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3a8acb83-750b-4acb-ad79-7aaf220d0c05": {"__data__": {"id_": "3a8acb83-750b-4acb-ad79-7aaf220d0c05", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "dd131950-5133-48b8-88c1-c7ce3f4ce169", "node_type": "1", "metadata": {}, "hash": "c873005fedd29789486a0910956c2d0e7679505193482c38a63d104e6c7ddc36", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "253f1368-47e0-49e0-a656-9956fc8afd02", "node_type": "1", "metadata": {}, "hash": "e26cd69ca34442385a8efc423ff5861f4892c389542c63984f0d7765a52f95a4", "class_name": "RelatedNodeInfo"}}, "text": "Thisisjustoneamongmany\nkinds of machine learning problems. Before we explore other varieties, we would like to\nshed more light on some core components that will follow us around, no matter what kind\nof machine learning problem we tackle:\n1.Thedatathat we can learn from.\n2.Amodelof how to transform the data.\n3.Anobjectivefunction that quantifies how well (or badly) the model is doing.\n4.Analgorithm to adjust the model\u2019s parameters to optimize the objective function.\n5 Key Components\n1.2.1Data\nIt might go without saying that you cannot do data science without data. We could lose\nhundreds of pages pondering what precisely data is, but for now, we will focus on the key\npropertiesofthedatasetsthatwewillbeconcernedwith. Generally,weareconcernedwith\na collection of examples. In order to work with data usefully, we typically need to come\nup with a suitable numerical representation. Each example (ordata point ,data instance ,\nsample)typicallyconsistsofasetofattributescalled features (sometimescalled covariates\norinputs), based on which the model must make its predictions. In supervised learning\nproblems, our goal is to predict the value of a special attribute, called the label(ortarget),\nthat is not part of the model\u2019s input.\nIf we were working with image data, each example might consist of an individual photo-\ngraph(thefeatures)andanumberindicatingthecategorytowhichthephotographbelongs\n(the label). The photograph would be represented numerically as three grids of numerical\nvalues representing the brightness of red, green, and blue light at each pixel location. For\nexample, a 200\u0002200pixel color photograph would consist of 200\u0002200\u00023=120000\nnumerical values.\nAlternatively, we might work with electronic health record data and tackle the task of pre-\ndicting the likelihood that a given patient will survive the next 30 days. Here, our features\nmight consist of a collection of readily available attributes and frequently recorded mea-\nsurements, including age, vital signs, comorbidities, current medications, and recent pro-\ncedures. The label available for training would be a binary value indicating whether each\npatient in the historical data survived within the 30-day window.\nIn such cases, when every example is characterized by the same number of numerical fea-\ntures, we say that the inputs are fixed-length vectors and we call the (constant) length of\nthe vectors the dimensionality of the data. As you might imagine, fixed-length inputs can\nbe convenient, giving us one less complication to worry about. However, not all data can\neasilyberepresentedas fixed-length vectors. Whilewemightexpectmicroscopeimagesto\ncomefromstandardequipment,wecannotexpectimagesminedfromtheInternetalltohave\nthe same resolution or shape. For images, we might consider cropping them to a standard\nsize, but that strategy only gets us so far. We risk losing information in the cropped-out\nportions. Moreover, text data resists fixed-length representations even more stubbornly.\nConsider the customer reviews left on e-commerce sites such as Amazon, IMDb, and Tri-\npAdvisor. Some are short: \u201cit stinks!\u201d. Others ramble for pages. One major advantage of\ndeeplearningovertraditionalmethodsisthecomparativegracewithwhichmodernmodels\ncan handle varying-length data.\nGenerally,themoredatawehave,theeasierourjobbecomes. Whenwehavemoredata,we\ncan train more powerful models and rely less heavily on preconceived assumptions. The\nregime change from (comparatively) small to big data is a major contributor to the success\nof modern deep learning. To drive the point home, many of the most exciting models in\ndeep learning do not work without large datasets. Some others might work in the small\ndata regime, but are no better than traditional approaches.\nFinally, it is not enough to have lots of data and to process it cleverly. We need the right\n6 Introduction\ndata. If the data is full of mistakes, or if the chosen features are not predictive of the target\nquantity of interest, learning is going to fail. The situation is captured well by the clich\u00e9:\ngarbage in, garbage out . Moreover, poor predictive performance is not the only poten-\ntial consequence. In sensitive applications of machine learning, like predictive policing,\nresumescreening, andriskmodelsusedforlending, wemustbeespeciallyalerttothecon-\nsequencesofgarbagedata. Onecommonlyoccurringfailuremodeconcernsdatasetswhere\nsomegroupsofpeopleareunrepresentedinthetrainingdata.", "mimetype": "text/plain", "start_char_idx": 66415, "end_char_idx": 70852, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "253f1368-47e0-49e0-a656-9956fc8afd02": {"__data__": {"id_": "253f1368-47e0-49e0-a656-9956fc8afd02", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3a8acb83-750b-4acb-ad79-7aaf220d0c05", "node_type": "1", "metadata": {}, "hash": "6ac6bbf9e7895c69bab187451dfba0967cfa15f094a14d004772ae52b0ba6476", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "da1cd37e-4718-44a8-ae01-7a57c62705f7", "node_type": "1", "metadata": {}, "hash": "fd61bab7e12ba1a2e101e1f446d3f823f3c19d570ccb01e7569bbfc673b0cf97", "class_name": "RelatedNodeInfo"}}, "text": "Some others might work in the small\ndata regime, but are no better than traditional approaches.\nFinally, it is not enough to have lots of data and to process it cleverly. We need the right\n6 Introduction\ndata. If the data is full of mistakes, or if the chosen features are not predictive of the target\nquantity of interest, learning is going to fail. The situation is captured well by the clich\u00e9:\ngarbage in, garbage out . Moreover, poor predictive performance is not the only poten-\ntial consequence. In sensitive applications of machine learning, like predictive policing,\nresumescreening, andriskmodelsusedforlending, wemustbeespeciallyalerttothecon-\nsequencesofgarbagedata. Onecommonlyoccurringfailuremodeconcernsdatasetswhere\nsomegroupsofpeopleareunrepresentedinthetrainingdata. Imagineapplyingaskincan-\ncer recognition system that had never seen black skin before. Failure can also occur when\nthedatadoesnotonlyunder-representsomegroupsbutreflectssocietalprejudices. Forex-\nample,ifpasthiringdecisionsareusedtotrainapredictivemodelthatwillbeusedtoscreen\nresumesthenmachinelearningmodelscouldinadvertentlycaptureandautomatehistorical\ninjustices. Note that this can all happen without the data scientist actively conspiring, or\neven being aware.\n1.2.2Models\nMost machine learning involves transforming the data in some sense. We might want to\nbuildasystemthatingestsphotosandpredictssmiley-ness. Alternatively,wemightwantto\ningest a set of sensor readings and predict how normal vs. anomalous the readings are. By\nmodel, we denote the computational machinery for ingesting data of one type, and spitting\nout predictions of a possibly different type. In particular, we are interested in statistical\nmodelsthat can be estimated from data. While simple models are perfectly capable of ad-\ndressing appropriately simple problems, the problems that we focus on in this book stretch\nthe limits of classical methods. Deep learning is differentiated from classical approaches\nprincipally by the set of powerful models that it focuses on. These models consist of many\nsuccessive transformations of the data that are chained together top to bottom, thus the\nnamedeep learning . On our way to discussing deep models, we will also discuss some\nmore traditional methods.\n1.2.3ObjectiveFunctions\nEarlier,weintroducedmachinelearningaslearningfromexperience. By learning here,we\nmeanimprovingatsometaskovertime. Butwhoistosaywhatconstitutesanimprovement?\nYou might imagine that we could propose updating our model, and some people might\ndisagree on whether our proposal constituted an improvement or not.\nIn order to develop a formal mathematical system of learning machines, we need to have\nformal measures of how good (or bad) our models are. In machine learning, and optimiza-\ntion more generally, we call these objective functions . By convention, we usually define\nobjective functions so that lower is better. This is merely a convention. You can take any\nfunctionforwhichhigheris better, and turn itinto a newfunction that is qualitativelyiden-\ntical but for which lower is better by flipping the sign. Because we choose lower to be\nbetter, these functions are sometimes called loss functions .\nWhen trying to predict numerical values, the most common loss function is squarederror ,\ni.e., the square of the difference between the prediction and the ground truth target. For\nclassification, the most common objective is to minimize error rate, i.e., the fraction of\n7 Kinds of Machine Learning Problems\nexamples on which our predictions disagree with the ground truth. Some objectives (e.g.,\nsquared error) are easy to optimize, while others (e.g., error rate) are difficult to optimize\ndirectly,owingtonon-differentiabilityorothercomplications. Inthesecases,itiscommon\ninstead to optimize a surrogateobjective .\nDuringoptimization, wethinkofthelossasafunctionofthemodel\u2019sparameters, andtreat\nthe training dataset as a constant. We learn the best values of our model\u2019s parameters by\nminimizing the loss incurred on a set consisting of some number of examples collected for\ntraining. However, doing well on the training data does not guarantee that we will do well\non unseen data. So we will typically want to split the available data into two partitions:\nthetraining dataset (ortraining set ), for learning model parameters; and the test dataset\n(ortest set), which is held out for evaluation. At the end of the day, we typically report\nhow our models perform on both partitions.", "mimetype": "text/plain", "start_char_idx": 70069, "end_char_idx": 74542, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "da1cd37e-4718-44a8-ae01-7a57c62705f7": {"__data__": {"id_": "da1cd37e-4718-44a8-ae01-7a57c62705f7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "253f1368-47e0-49e0-a656-9956fc8afd02", "node_type": "1", "metadata": {}, "hash": "e26cd69ca34442385a8efc423ff5861f4892c389542c63984f0d7765a52f95a4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8eb7fe94-1be2-4977-be3e-df3298bf41c6", "node_type": "1", "metadata": {}, "hash": "2bac018de88f402f28062aa312a0c494b96ea71684888443aef64daa553e69b0", "class_name": "RelatedNodeInfo"}}, "text": "Inthesecases,itiscommon\ninstead to optimize a surrogateobjective .\nDuringoptimization, wethinkofthelossasafunctionofthemodel\u2019sparameters, andtreat\nthe training dataset as a constant. We learn the best values of our model\u2019s parameters by\nminimizing the loss incurred on a set consisting of some number of examples collected for\ntraining. However, doing well on the training data does not guarantee that we will do well\non unseen data. So we will typically want to split the available data into two partitions:\nthetraining dataset (ortraining set ), for learning model parameters; and the test dataset\n(ortest set), which is held out for evaluation. At the end of the day, we typically report\nhow our models perform on both partitions. You could think of training performance as\nanalogous to the scores that a student achieves on the practice exams used to prepare for\nsome real final exam. Even if the results are encouraging, that does not guarantee success\non the final exam. Over the course of studying, the student might begin to memorize the\npractice questions, appearing to master the topic but faltering when faced with previously\nunseen questions on the actual final exam. When a model performs well on the training set\nbutfailstogeneralizetounseendata,wesaythatitis overfitting tothetrainingdata.\n1.2.4OptimizationAlgorithms\nOnce we have got some data source and representation, a model, and a well-defined objec-\ntive function, we need an algorithm capable of searching for the best possible parameters\nfor minimizing the loss function. Popular optimization algorithms for deep learning are\nbased on an approach called gradient descent . In brief, at each step, this method checks\nto see, for each parameter, how that training set loss would change if you perturbed that\nparameter by just a small amount. It would then update the parameter in the direction that\nlowers the loss.\n1.3Kinds of MachineLearning Problems\nThe wake word problem in our motivating example is just one among many that machine\nlearning can tackle. To motivate the reader further and provide us with some common\nlanguage that will follow us throughout the book, we now provide a broad overview of the\nlandscape of machine learning problems.\n1.3.1SupervisedLearning\nSupervised learning describes tasks where we are given a dataset containing both features\nand labels and asked to produce a model that predicts the labels when given input features.\nEach feature\u2013label pair is called an example. Sometimes, when the context is clear, we\nmay use the term examples to refer to a collection of inputs, even when the corresponding\n8 Introduction\nlabels are unknown. The supervision comes into play because, for choosing the parame-\nters, we (the supervisors) provide the model with a dataset consisting of labeled examples.\nIn probabilistic terms, we typically are interested in estimating the conditional probability\nof a label given input features. While it is just one among several paradigms, supervised\nlearning accounts for the majority of successful applications of machine learning in indus-\ntry. Partly that is because many important tasks can be described crisply as estimating the\nprobability of something unknown given a particular set of available data:\n\u000fPredict cancer vs. not cancer, given a computer tomography image.\n\u000fPredict the correct translation in French, given a sentence in English.\n\u000fPredict the price of a stock next month based on this month\u2019s financial reporting data.\nWhile all supervised learning problems are captured by the simple description \u201cpredicting\nthelabelsgiveninputfeatures\u201d,supervisedlearningitselfcantakediverseformsandrequire\ntons of modeling decisions, depending on (among other considerations) the type, size, and\nquantity of the inputs and outputs. For example, we use different models for processing\nsequences of arbitrary lengths and fixed-length vector representations. We will visit many\nof these problems in depth throughout this book.\nInformally, the learning process looks something like the following. First, grab a big col-\nlectionofexamplesforwhichthefeaturesareknownandselectfromthemarandomsubset,\nacquiring the ground truth labels for each. Sometimes these labels might be available data\nthat have already been collected (e.g., did a patient die within the following year?) and\nother times we might need to employ human annotators to label the data, (e.g., assigning\nimages to categories). Together, these inputs and corresponding labels comprise the train-\ning set. We feed the training dataset into a supervised learning algorithm, a function that\ntakes as input a dataset and outputs another function: the learned model. Finally, we can\nfeed previously unseen inputs to the learned model, using its outputs as predictions of the\ncorresponding label. The full process is drawn in Fig.", "mimetype": "text/plain", "start_char_idx": 73809, "end_char_idx": 78627, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8eb7fe94-1be2-4977-be3e-df3298bf41c6": {"__data__": {"id_": "8eb7fe94-1be2-4977-be3e-df3298bf41c6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "da1cd37e-4718-44a8-ae01-7a57c62705f7", "node_type": "1", "metadata": {}, "hash": "fd61bab7e12ba1a2e101e1f446d3f823f3c19d570ccb01e7569bbfc673b0cf97", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f83842ef-d454-437b-afaf-2696b2f55951", "node_type": "1", "metadata": {}, "hash": "8cd1fb952a30317bdd5ff3c4b6ef39fc9f2147a52c3ff7db87e3251cea8eba1b", "class_name": "RelatedNodeInfo"}}, "text": "We will visit many\nof these problems in depth throughout this book.\nInformally, the learning process looks something like the following. First, grab a big col-\nlectionofexamplesforwhichthefeaturesareknownandselectfromthemarandomsubset,\nacquiring the ground truth labels for each. Sometimes these labels might be available data\nthat have already been collected (e.g., did a patient die within the following year?) and\nother times we might need to employ human annotators to label the data, (e.g., assigning\nimages to categories). Together, these inputs and corresponding labels comprise the train-\ning set. We feed the training dataset into a supervised learning algorithm, a function that\ntakes as input a dataset and outputs another function: the learned model. Finally, we can\nfeed previously unseen inputs to the learned model, using its outputs as predictions of the\ncorresponding label. The full process is drawn in Fig. 1.3.1 .\ntFig. 1.3.1 Supervised learning.\nRegression\nPerhapsthesimplestsupervisedlearningtasktowrapyourheadaroundis regression . Con-\nsider, for example, a set of data harvested from a database of home sales. We might con-\nstruct a table, in which each row corresponds to a different house, and each column cor-\nresponds to some relevant attribute, such as the square footage of a house, the number of\nbedrooms, the number of bathrooms, and the number of minutes (walking) to the center\nof town. In this dataset, each example would be a specific house, and the corresponding\n9 Kinds of Machine Learning Problems\n19featurevectorwouldbeonerowinthetable. IfyouliveinNewYorkorSanFrancisco, and\nyou are not the CEO of Amazon, Google, Microsoft, or Facebook, the (sq. footage, no. of\nbedrooms, no. of bathrooms, walking distance) feature vector for your home might look\nsomething like:\u00bb600,1,1,60\u00bc. However, if you live in Pittsburgh, it might look more like\n\u00bb3000,4,3,10\u00bc. Fixed-lengthfeaturevectorslikethisareessentialformostclassicmachine\nlearning algorithms.\nWhatmakesaproblemaregressionisactuallytheformofthetarget. Saythatyouareinthe\nmarket for a new home. You might want to estimate the fair market value of a house, given\nsomefeaturessuchasabove. Thedataheremightconsistofhistoricalhomelistingsandthe\nlabels might be the observed sales prices. When labels take on arbitrary numerical values\n(even within some interval), we call this a regression problem. The goal is to produce a\nmodel whose predictions closely approximate the actual label values.\nLotsofpracticalproblemsareeasilydescribedasregressionproblems. Predictingtherating\nthat a user will assign to a movie can be thought of as a regression problem and if you\ndesigned a great algorithm to accomplish this feat in 2009, you might have won the 1-\nmillion-dollar Netflix prize19. Predicting the length of stay for patients in the hospital is\nalso a regression problem. A good rule of thumb is that any how much? orhow many?\nproblem is likely to be regression. For example:\n\u000fHow many hours will this surgery take?\n\u000fHow much rainfall will this town have in the next six hours?\nEven if you have never worked with machine learning before, you have probably worked\nthrougharegressionprobleminformally. Imagine,forexample,thatyouhadyourdrainsre-\npairedandthatyourcontractorspent3hoursremovinggunkfromyoursewagepipes. Then\nthey sent you a bill of 350 dollars. Now imagine that your friend hired the same contractor\nfor 2 hours and received a bill of 250 dollars. If someone then asked you how much to\nexpect on their upcoming gunk-removal invoice you might make some reasonable assump-\ntions, such as more hours worked costs more dollars. You might also assume that there is\nsome base charge and that the contractor then charges per hour. If these assumptions held\ntrue,thengiventhesetwodataexamples,youcouldalreadyidentifythecontractor\u2019spricing\nstructure: 100 dollars per hour plus 50 dollars to show up at your house. If you followed\nthatmuch,thenyoualreadyunderstandthehigh-levelideabehind linearregression.\nIn this case, we could produce the parameters that exactly matched the contractor\u2019s prices.\nSometimes this is not possible, e.g., if some of the variation arises from factors beyond\nyour two features.", "mimetype": "text/plain", "start_char_idx": 77702, "end_char_idx": 81891, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f83842ef-d454-437b-afaf-2696b2f55951": {"__data__": {"id_": "f83842ef-d454-437b-afaf-2696b2f55951", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8eb7fe94-1be2-4977-be3e-df3298bf41c6", "node_type": "1", "metadata": {}, "hash": "2bac018de88f402f28062aa312a0c494b96ea71684888443aef64daa553e69b0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5650e9e1-956f-42d4-a3d9-1095b397ac43", "node_type": "1", "metadata": {}, "hash": "4e0ea0d5ac6fd0bcb2c40a7a93d7d6c9045d583a1ba65580b923ee122062ad04", "class_name": "RelatedNodeInfo"}}, "text": "Now imagine that your friend hired the same contractor\nfor 2 hours and received a bill of 250 dollars. If someone then asked you how much to\nexpect on their upcoming gunk-removal invoice you might make some reasonable assump-\ntions, such as more hours worked costs more dollars. You might also assume that there is\nsome base charge and that the contractor then charges per hour. If these assumptions held\ntrue,thengiventhesetwodataexamples,youcouldalreadyidentifythecontractor\u2019spricing\nstructure: 100 dollars per hour plus 50 dollars to show up at your house. If you followed\nthatmuch,thenyoualreadyunderstandthehigh-levelideabehind linearregression.\nIn this case, we could produce the parameters that exactly matched the contractor\u2019s prices.\nSometimes this is not possible, e.g., if some of the variation arises from factors beyond\nyour two features. In these cases, we will try to learn models that minimize the distance\nbetween our predictions and the observed values. In most of our chapters, we will focus on\nminimizing the squared error loss function. As we will see later, this loss corresponds to\nthe assumption that our data were corrupted by Gaussian noise.\nClassification\nWhileregressionmodelsaregreatforaddressing howmany? questions,lotsofproblemsdo\nnot fit comfortably in this template. Consider, for example, a bank that wants to develop a\n10 Introduction\ncheck scanning feature for its mobile app. Ideally, the customer would simply snap a photo\nof a check and the app would automatically recognize the text from the image. Assuming\nthat we had some ability to segment out image patches corresponding to each handwritten\ncharacter, then the primary remaining task would be to determine which character among\nsome known set is depicted in each image patch. These kinds of which one? problems\nare called classification and require a different set of tools from those used for regression,\nalthough many techniques will carry over.\nInclassification , we want our model to look at features, e.g., the pixel values in an image,\nand then predict to which category (sometimes called a class) among some discrete set\nof options, an example belongs. For handwritten digits, we might have ten classes, corre-\nsponding to the digits 0 through 9. The simplest form of classification is when there are\nonly two classes, a problem which we call binary classification . For example, our dataset\ncouldconsistofimagesofanimalsandourlabelsmightbetheclasses{cat, dog}. Whereas\nin regression we sought a regressor to output a numerical value, in classification we seek a\nclassifier, whose output is the predicted class assignment.\nFor reasons that we will get into as the book gets more technical, it can be difficult to opti-\nmizeamodelthatcanonlyoutputa firmcategoricalassignment,e.g.,either\u201ccat\u201dor\u201cdog\u201d.\nIn these cases, it is usually much easier to express our model in the language of probabili-\nties. Given features of an example, our model assigns a probability to each possible class.\nReturning to our animal classification example where the classes are {cat, dog}, a classi-\nfier might see an image and output the probability that the image is a cat as 0.9. We can\ninterpret this number by saying that the classifier is 90% sure that the image depicts a cat.\nThe magnitude of the probability for the predicted class conveys a notion of uncertainty.\nIt is not the only one available and we will discuss others in chapters dealing with more\nadvanced topics.\nWhenwehavemorethantwopossibleclasses,wecalltheproblem multiclassclassification .\nCommonexamplesincludehandwrittencharacterrecognition{0, 1, 2, ... 9, a, b, c, ...}. While\nwe attacked regression problems by trying to minimize the squared error loss function, the\ncommonlossfunctionforclassificationproblemsiscalled cross-entropy , whosenamewill\nbe demystified when we introduce information theory in later chapters.\nNote that the most likely class is not necessarily the one that you are going to use for your\ndecision. Assume that you find a beautiful mushroom in your backyard as shown in Fig.\n1.3.2.\nNow, assumethatyoubuiltaclassifierandtrainedittopredictwhetheramushroomispoi-\nsonous based on a photograph. Say our poison-detection classifier outputs that the proba-\nbility that Fig. 1.3.2 shows a death cap is 0.2. In other words, the classifier is 80% sure that\nourmushroomisnotadeathcap. Still,youwouldhavetobeafooltoeatit.", "mimetype": "text/plain", "start_char_idx": 81040, "end_char_idx": 85427, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5650e9e1-956f-42d4-a3d9-1095b397ac43": {"__data__": {"id_": "5650e9e1-956f-42d4-a3d9-1095b397ac43", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f83842ef-d454-437b-afaf-2696b2f55951", "node_type": "1", "metadata": {}, "hash": "8cd1fb952a30317bdd5ff3c4b6ef39fc9f2147a52c3ff7db87e3251cea8eba1b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "99e849d5-d340-4d42-b89f-5f84376e0d7c", "node_type": "1", "metadata": {}, "hash": "0b62450cd4ca717f3f0fc8bcbe43a8ea24487a9206437109c8a120bb2feaf6a8", "class_name": "RelatedNodeInfo"}}, "text": "While\nwe attacked regression problems by trying to minimize the squared error loss function, the\ncommonlossfunctionforclassificationproblemsiscalled cross-entropy , whosenamewill\nbe demystified when we introduce information theory in later chapters.\nNote that the most likely class is not necessarily the one that you are going to use for your\ndecision. Assume that you find a beautiful mushroom in your backyard as shown in Fig.\n1.3.2.\nNow, assumethatyoubuiltaclassifierandtrainedittopredictwhetheramushroomispoi-\nsonous based on a photograph. Say our poison-detection classifier outputs that the proba-\nbility that Fig. 1.3.2 shows a death cap is 0.2. In other words, the classifier is 80% sure that\nourmushroomisnotadeathcap. Still,youwouldhavetobeafooltoeatit. Thatisbecause\nthe certain benefit of a delicious dinner is not worth a 20% risk of dying from it. In other\nwords, the effect of the uncertain risk outweighs the benefit by far. Thus, in order to make\na decision about whether to eat the mushroom, we need to compute the expected detriment\nassociated with each action which depends both on the likely outcomes and the benefits or\nharms associated with each. In this case, the detriment incurred by eating the mushroom\n11 Kinds of Machine Learning Problems\ntFig. 1.3.2 Death cap - do not eat!\n20might be 0.2\u00021\u00b8 0.8\u00020=1, whereas the loss of discarding it is 0.2\u00020\u00b80.8\u00021=0.8.\nOur caution was justified: as any mycologist would tell us, the mushroom in Fig. 1.3.2 is\nactually a death cap.\nClassification can get much more complicated than just binary or multiclass classification.\nFor instance, there are some variants of classification addressing hierarchically structured\nclasses. Insuchcasesnotallerrorsareequal\u2014ifwemusterr,wemightprefertomisclassify\nto a related class rather than a distant class. Usually, this is referred to as hierarchical\nclassification . For inspiration, you might think of Linnaeus20, who organized fauna in a\nhierarchy.\nInthecaseofanimalclassification,itmightnotbesobadtomistakeapoodleforaschnauzer,\nbut our model would pay a huge penalty if it confused a poodle with a dinosaur. Which\nhierarchy is relevant might depend on how you plan to use the model. For example, rat-\ntlesnakes and garter snakes might be close on the phylogenetic tree, but mistaking a rattler\nfor a garter could have fatal consequences.\nTagging\nSome classification problems fit neatly into the binary or multiclass classification setups.\nForexample,wecouldtrainanormalbinaryclassifiertodistinguishcatsfromdogs. Given\nthecurrentstateofcomputervision,wecandothiseasily,withoff-the-shelftools. Nonethe-\nless, no matter how accurate our model gets, we might find ourselves in trouble when the\nclassifier encounters an image of the Town Musicians of Bremen , a popular German fairy\ntale featuring four animals ( Fig. 1.3.3 ).\nAs you can see, the photo features a cat, a rooster, a dog, and a donkey, with some trees in\nthebackground. Ifweanticipateencounteringsuchimages, multiclassclassificationmight\nnot be the right problem formulation. Instead, we might want to give the model the option\nof saying the image depicts a cat, a dog, a donkey, anda rooster.\n12 Introduction\ntFig. 1.3.3 A donkey, a dog, a cat, and a rooster.\n21The problem of learning to predict classes that are not mutually exclusive is called multi-\nlabel classification . Auto-tagging problems are typically best described in terms of multi-\nlabel classification. Think of the tags people might apply to posts on a technical blog, e.g.,\n\u201cmachine learning\u201d, \u201ctechnology\u201d, \u201cgadgets\u201d, \u201cprogramming languages\u201d, \u201cLinux\u201d, \u201ccloud\ncomputing\u201d, \u201cAWS\u201d. A typical article might have 5\u201310 tags applied. Typically, tags will\nexhibit some correlation structure. Posts about \u201ccloud computing\u201d are likely to mention\n\u201cAWS\u201d and posts about \u201cmachine learning\u201d are likely to mention \u201cGPUs\u201d.\nSometimes such tagging problems draw on enormous label sets.", "mimetype": "text/plain", "start_char_idx": 84663, "end_char_idx": 88568, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "99e849d5-d340-4d42-b89f-5f84376e0d7c": {"__data__": {"id_": "99e849d5-d340-4d42-b89f-5f84376e0d7c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5650e9e1-956f-42d4-a3d9-1095b397ac43", "node_type": "1", "metadata": {}, "hash": "4e0ea0d5ac6fd0bcb2c40a7a93d7d6c9045d583a1ba65580b923ee122062ad04", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7c2c4e2a-f042-493c-91fc-d0efbdf97db3", "node_type": "1", "metadata": {}, "hash": "96a3a08ae95c3044ba9e9de0da6dcc9d45d6d575c340f162c0ad88d911b1eb5b", "class_name": "RelatedNodeInfo"}}, "text": "12 Introduction\ntFig. 1.3.3 A donkey, a dog, a cat, and a rooster.\n21The problem of learning to predict classes that are not mutually exclusive is called multi-\nlabel classification . Auto-tagging problems are typically best described in terms of multi-\nlabel classification. Think of the tags people might apply to posts on a technical blog, e.g.,\n\u201cmachine learning\u201d, \u201ctechnology\u201d, \u201cgadgets\u201d, \u201cprogramming languages\u201d, \u201cLinux\u201d, \u201ccloud\ncomputing\u201d, \u201cAWS\u201d. A typical article might have 5\u201310 tags applied. Typically, tags will\nexhibit some correlation structure. Posts about \u201ccloud computing\u201d are likely to mention\n\u201cAWS\u201d and posts about \u201cmachine learning\u201d are likely to mention \u201cGPUs\u201d.\nSometimes such tagging problems draw on enormous label sets. The National Library of\nMedicineemploysmanyprofessionalannotatorswhoassociateeacharticletobeindexedin\nPubMed with a set of tags drawn from the Medical Subject Headings (MeSH) ontology, a\ncollection of roughly 28,000 tags. Correctly tagging articles is important because it allows\nresearchers to conduct exhaustive reviews of the literature. This is a time-consuming pro-\ncessand typicallythere isa one-yearlagbetweenarchivingand tagging. Machinelearning\ncan provide provisional tags until each article has a proper manual review. Indeed, for\nseveral years, the BioASQ organization has hosted competitions21for this task.\n13 Kinds of Machine Learning Problems\n22Search\nIn the field of information retrieval, we often impose ranks on sets of items. Take web\nsearchforexample. Thegoalislesstodetermine whether aparticularpageisrelevantfora\nquery,butratherwhich,amongasetofrelevantresults,shouldbeshownmostprominently\nto a particular user. One way of doing this might be to first assign a score to every element\nin the set and then to retrieve the top-rated elements. PageRank22, the original secret\nsauce behind the Google search engine, was an early example of such a scoring system.\nWeirdly, the scoring provided by PageRank did not depend on the actual query. Instead,\nthey relied on a simple relevance filter to identify the set of relevant candidates and then\nused PageRank to prioritize the more authoritative pages. Nowadays, search engines use\nmachinelearningandbehavioralmodelstoobtainquery-dependentrelevancescores. There\nare entire academic conferences devoted to this subject.\nRecommender Systems\nRecommender systems are another problem setting that is related to search and ranking.\nThe problems are similar insofar as the goal is to display a set of items relevant to the user.\nThe main difference is the emphasis on personalization to specific users in the context of\nrecommender systems. For instance, for movie recommendations, the results page for a\nscience fiction fan and the results page for a connoisseur of Peter Sellers comedies might\ndiffer significantly. Similar problems pop up in other recommendation settings, e.g., for\nretail products, music, and news recommendation.\nInsomecases,customersprovideexplicitfeedback,communicatinghowmuchtheylikeda\nparticularproduct(e.g.,theproductratingsandreviewsonAmazon,IMDb,orGoodreads).\nIn other cases, they provide implicit feedback, e.g., by skipping titles on a playlist, which\nmight indicate dissatisfaction or maybe just indicate that the song was inappropriate in\ncontext. In the simplest formulations, these systems are trained to estimate some score,\nsuchasanexpectedstarratingortheprobabilitythatagivenuserwillpurchaseaparticular\nitem.\nGiven such a model, for any given user, we could retrieve the set of objects with the largest\nscores, which could then be recommended to the user. Production systems are consider-\nably more advanced and take detailed user activity and item characteristics into account\nwhencomputingsuchscores. Fig.1.3.4 displaysthedeeplearningbooksrecommendedby\nAmazon based on personalization algorithms tuned to capture Aston\u2019s preferences.\nDespite their tremendous economic value, recommender systems naively built on top of\npredictivemodelssuffersomeseriousconceptualflaws. Tostart,weonlyobserve censored\nfeedback : users preferentially rate movies that they feel strongly about. For example, on\na five-point scale, you might notice that items receive many one- and five-star ratings but\nthat there are conspicuously few three-star ratings. Moreover, current purchase habits are\noften a result of the recommendation algorithm currently in place, but learning algorithms\ndo not always take this detail into account.", "mimetype": "text/plain", "start_char_idx": 87826, "end_char_idx": 92278, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7c2c4e2a-f042-493c-91fc-d0efbdf97db3": {"__data__": {"id_": "7c2c4e2a-f042-493c-91fc-d0efbdf97db3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "99e849d5-d340-4d42-b89f-5f84376e0d7c", "node_type": "1", "metadata": {}, "hash": "0b62450cd4ca717f3f0fc8bcbe43a8ea24487a9206437109c8a120bb2feaf6a8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "71710e7d-9be5-4554-9e47-5236c50c1ef5", "node_type": "1", "metadata": {}, "hash": "2b203b57da249d1646867cba7d95f87fb38ea32cba437a57b0d31a917605a173", "class_name": "RelatedNodeInfo"}}, "text": "Production systems are consider-\nably more advanced and take detailed user activity and item characteristics into account\nwhencomputingsuchscores. Fig.1.3.4 displaysthedeeplearningbooksrecommendedby\nAmazon based on personalization algorithms tuned to capture Aston\u2019s preferences.\nDespite their tremendous economic value, recommender systems naively built on top of\npredictivemodelssuffersomeseriousconceptualflaws. Tostart,weonlyobserve censored\nfeedback : users preferentially rate movies that they feel strongly about. For example, on\na five-point scale, you might notice that items receive many one- and five-star ratings but\nthat there are conspicuously few three-star ratings. Moreover, current purchase habits are\noften a result of the recommendation algorithm currently in place, but learning algorithms\ndo not always take this detail into account. Thus it is possible for feedback loops to form\nwhere a recommender system preferentially pushes an item that is then taken to be better\n(due to greater purchases) and in turn is recommended even more frequently. Many of\n14 Introduction\ntFig. 1.3.4 Deep learning books recommended by Amazon.\nthese problems\u2014about how to deal with censoring, incentives, and feedback loops\u2014are\nimportant open research questions.\nSequenceLearning\nSofar,wehavelookedatproblemswherewehavesomefixednumberofinputsandproduce\na fixed number of outputs. For example, we considered predicting house prices given a\nfixed set of features: square footage, number of bedrooms, number of bathrooms, and the\ntransit time to downtown. We also discussed mapping from an image (of fixed dimension)\nto the predicted probabilities that it belongs to each among a fixed number of classes and\npredictingstarratingsassociatedwithpurchasesbasedontheuserIDandproductIDalone.\nIn these cases, once our model is trained, after each test example is fed into our model, it\nis immediately forgotten. We assumed that successive observations were independent and\nthus there was no need to hold on to this context.\nBut how should we deal with video snippets? In this case, each snippet might consist of\na different number of frames. And our guess of what is going on in each frame might be\nmuchstrongerifwetakeintoaccountthepreviousorsucceedingframes. Thesamegoesfor\nlanguage. Forexample,onepopulardeeplearningproblemismachinetranslation: thetask\nof ingesting sentences in some source language and predicting their translations in another\nlanguage.\nSuch problems also occur in medicine. We might want a model to monitor patients in the\nintensive care unit and to fire off alerts whenever their risk of dying in the next 24 hours\nexceeds some threshold. Here, we would not throw away everything that we know about\n15 Kinds of Machine Learning Problems\nthe patient history every hour, because we might not want to make predictions based only\non the most recent measurements.\nQuestions like these are among the most exciting applications of machine learning and\nthey are instances of sequence learning . They require a model either to ingest sequences\nof inputs or to emit sequences of outputs (or both). Specifically, sequence-to-sequence\nlearning considers problems where both inputs and outputs consist of variable-length se-\nquences. Examples include machine translation and speech-to-text transcription. While it\nis impossible to consider all types of sequence transformations, the following special cases\nare worth mentioning.\nTagging and Parsing . This involves annotating a text sequence with attributes. Here,\nthe inputs and outputs are aligned, i.e., they are of the same number and occur in a corre-\nsponding order. For instance, in part-of-speech (PoS) tagging , we annotate every word in\na sentence with the corresponding part of speech, i.e., \u201cnoun\u201d or \u201cdirect object\u201d. Alterna-\ntively, we might want to know which groups of contiguous words refer to named entities,\nlikepeople,places, ororganizations . In the cartoonishly simple example below, we might\njust want to indicate whether or not any word in the sentence is part of a named entity\n(tagged as \u201cEnt\u201d).\nTom has dinner in Washington with Sally\nEnt - - - Ent - Ent\nAutomatic Speech Recognition . With speech recognition, the input sequence is an audio\nrecording of a speaker ( Fig. 1.3.5 ), and the output is a transcript of what the speaker said.\nThe challenge is that there are many more audio frames (sound is typically sampled at\n8kHz or 16kHz) than text, i.e., there is no 1:1 correspondence between audio and text,\nsince thousands of samples may correspond to a single spoken word. These are sequence-\nto-sequence learning problems, where the output is much shorter than the input.", "mimetype": "text/plain", "start_char_idx": 91423, "end_char_idx": 96081, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "71710e7d-9be5-4554-9e47-5236c50c1ef5": {"__data__": {"id_": "71710e7d-9be5-4554-9e47-5236c50c1ef5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7c2c4e2a-f042-493c-91fc-d0efbdf97db3", "node_type": "1", "metadata": {}, "hash": "96a3a08ae95c3044ba9e9de0da6dcc9d45d6d575c340f162c0ad88d911b1eb5b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ace4dc8e-23a8-427d-8a5d-706f0740563f", "node_type": "1", "metadata": {}, "hash": "3c61c071a40819d124e285a84a04102c5716bc3c73883733da65a3a1b5f7592b", "class_name": "RelatedNodeInfo"}}, "text": "In the cartoonishly simple example below, we might\njust want to indicate whether or not any word in the sentence is part of a named entity\n(tagged as \u201cEnt\u201d).\nTom has dinner in Washington with Sally\nEnt - - - Ent - Ent\nAutomatic Speech Recognition . With speech recognition, the input sequence is an audio\nrecording of a speaker ( Fig. 1.3.5 ), and the output is a transcript of what the speaker said.\nThe challenge is that there are many more audio frames (sound is typically sampled at\n8kHz or 16kHz) than text, i.e., there is no 1:1 correspondence between audio and text,\nsince thousands of samples may correspond to a single spoken word. These are sequence-\nto-sequence learning problems, where the output is much shorter than the input. While\nhumans are remarkably good at recognizing speech, even from low-quality audio, getting\ncomputers to perform the same feat is a formidable challenge.\ntFig. 1.3.5 -D-e-e-p- L-ea-r-ni-ng- in an audio recording.\nTexttoSpeech . This is the inverse of automatic speech recognition. Here, the input is text\nandtheoutputisanaudiofile. Inthiscase,theoutputismuchlongerthantheinput.\nMachineTranslation . Unlike the case of speech recognition, where corresponding inputs\nand outputs occur in the same order, in machine translation, unaligned data poses a new\nchallenge. Here the input and output sequences can have different lengths, and the corre-\n16 Introduction\nsponding regions of the respective sequences may appear in a different order. Consider the\nfollowingillustrativeexampleofthepeculiartendencyofGermanstoplacetheverbsatthe\nend of sentences:\nGerman: Haben Sie sich schon dieses grossartige Lehrwerk angeschaut?\nEnglish: Have you already looked at this excellent textbook?\nWrong alignment: Have you yourself already this excellent textbook looked at?\nMany related problems pop up in other learning tasks. For instance, determining the order\nin which a user reads a webpage is a two-dimensional layout analysis problem. Dialogue\nproblemsexhibitallkindsofadditionalcomplications,wheredeterminingwhattosaynext\nrequires taking into account real-world knowledge and the prior state of the conversation\nacross long temporal distances. Such topics are active areas of research.\n1.3.2Unsupervisedand Self-Supervised Learning\nThe previous examples focused on supervised learning, where we feed the model a giant\ndataset containing both the features and corresponding label values. You could think of\nthe supervised learner as having an extremely specialized job and an extremely dictatorial\nboss. Thebossstandsoverthelearner\u2019sshoulderandtellsthemexactlywhattodoinevery\nsituationuntiltheylearntomapfromsituationstoactions. Workingforsuchabosssounds\npretty lame. On the other hand, pleasing such a boss is pretty easy. You just recognize the\npattern as quickly as possible and imitate the boss\u2019s actions.\nConsidering the opposite situation, it could be frustrating to work for a boss who has no\nidea what they want you to do. However, if you plan to be a data scientist, you had better\nget used to it. The boss might just hand you a giant dump of data and tell you to do some\ndatasciencewithit! This sounds vague because it is vague. We call this class of problems\nunsupervisedlearning , and the type and number of questions we can ask is limited only by\nourcreativity. Wewilladdressunsupervisedlearningtechniquesinlaterchapters. Towhet\nyour appetite for now, we describe a few of the following questions you might ask.\n\u000fCan we find a small number of prototypes that accurately summarize the data? Given a\nsetofphotos,canwegroupthemintolandscapephotos,picturesofdogs,babies,cats,\nand mountain peaks? Likewise, given a collection of users\u2019 browsing activities, can\nwe group them into users with similar behavior? This problem is typically known as\nclustering .\n\u000fCanwefindasmallnumberofparametersthataccuratelycapturetherelevantproperties\nof the data? The trajectories of a ball are well described by velocity, diameter, and\nmass of the ball. Tailors have developed a small number of parameters that describe\nhuman body shape fairlyaccuratelyforthe purpose of fitting clothes. These problems\narereferredtoas subspaceestimation . Ifthedependenceislinear,itiscalled principal\ncomponentanalysis .\n\u000fIs there a representation of (arbitrarily structured) objects in Euclidean space such that\nsymbolic properties can be well matched?", "mimetype": "text/plain", "start_char_idx": 95341, "end_char_idx": 99700, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ace4dc8e-23a8-427d-8a5d-706f0740563f": {"__data__": {"id_": "ace4dc8e-23a8-427d-8a5d-706f0740563f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "71710e7d-9be5-4554-9e47-5236c50c1ef5", "node_type": "1", "metadata": {}, "hash": "2b203b57da249d1646867cba7d95f87fb38ea32cba437a57b0d31a917605a173", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "45832d34-5ac9-49ed-892b-112e826b24c8", "node_type": "1", "metadata": {}, "hash": "c15a934b41b289dfad01800b976ee582603c3f9bb3a9e2377da24aab871bfe4c", "class_name": "RelatedNodeInfo"}}, "text": "Given a\nsetofphotos,canwegroupthemintolandscapephotos,picturesofdogs,babies,cats,\nand mountain peaks? Likewise, given a collection of users\u2019 browsing activities, can\nwe group them into users with similar behavior? This problem is typically known as\nclustering .\n\u000fCanwefindasmallnumberofparametersthataccuratelycapturetherelevantproperties\nof the data? The trajectories of a ball are well described by velocity, diameter, and\nmass of the ball. Tailors have developed a small number of parameters that describe\nhuman body shape fairlyaccuratelyforthe purpose of fitting clothes. These problems\narereferredtoas subspaceestimation . Ifthedependenceislinear,itiscalled principal\ncomponentanalysis .\n\u000fIs there a representation of (arbitrarily structured) objects in Euclidean space such that\nsymbolic properties can be well matched? This can be used to describe entities and\ntheir relations, such as \u201cRome\u201d \u0000\u201cItaly\u201d\u00b8\u201cFrance\u201d =\u201cParis\u201d.\n17 Kinds of Machine Learning Problems\n\u000fIsthereadescriptionoftherootcausesofmuchofthedatathatweobserve? Forinstance,\nifwehavedemographicdataabouthouseprices,pollution,crime,location,education,\nand salaries, can we discover how they are related simply based on empirical data?\nThe fields concerned with causality andprobabilistic graphical models tackle such\nquestions.\n\u000fAnother important and exciting recent development in unsupervised learning is the ad-\nvent ofdeep generativemodels . These models estimate the density of the data, either\nexplicitly or implicitly . Once trained, we can use a generative model either to score\nexamples according to how likely they are, or to sample synthetic examples from the\nlearned distribution. Early deep learning breakthroughs in generative modeling came\nwith the invention of variational autoencoders (Kingma and Welling, 2014 ,Rezende\net al., 2014) and continued with the development of generative adversarial networks\n(Goodfellow et al., 2014). More recent advances include normalizing flows ( Dinhet\nal., 2014,Dinhet al., 2017) and diffusion models ( Hoet al., 2020,Sohl-Dickstein et\nal., 2015,Song and Ermon, 2019 ,Songetal., 2021).\nA further development in unsupervised learning has been the rise of self-supervisedlearn-\ning, techniques that leverage some aspect of the unlabeled data to provide supervision. For\ntext, we can train models to \u201cfill in the blanks\u201d by predicting randomly masked words us-\ning their surrounding words (contexts) in big corpora without any labeling effort ( Devlin\net al., 2018)! For images, we may train models to tell the relative position between two\ncroppedregionsofthesameimage( Doerschetal., 2015), topredictanoccludedpartofan\nimage based on the remaining portions of the image, or to predict whether two examples\nare perturbed versions of the same underlying image. Self-supervised models often learn\nrepresentationsthataresubsequentlyleveragedbyfine-tuningtheresultingmodelsonsome\ndownstream task of interest.\n1.3.3Interactingwith an Environment\nSo far, we have not discussed where data actually comes from, or what actually happens\nwhen a machine learning model generates an output. That is because supervised learning\nand unsupervised learning do not address these issues in a very sophisticated way. In each\ncase,wegrababigpileofdataupfront,thensetourpatternrecognitionmachinesinmotion\nwithout ever interacting with the environment again. Because all the learning takes place\nafter the algorithm is disconnected from the environment, this is sometimes called offline\nlearning . Forexample,supervisedlearningassumesthesimpleinteractionpatterndepicted\ninFig. 1.3.6 .\nThis simplicity of offline learning has its charms. The upside is that we can worry about\npattern recognition in isolation, with no concern about complications arising from interac-\ntions with a dynamic environment. But this problem formulation is limiting. If you grew\nup reading Asimov\u2019s Robot novels, then you probably picture artificially intelligent agents\ncapable not only of making predictions, but also of taking actions in the world. We want\nto think about intelligent agents, not just predictive models. This means that we need to\nthink about choosing actions, not just making predictions. In contrast to mere predictions,\nactions actually impact the environment. If we want to train an intelligent agent, we must\n18 Introduction\ntFig.", "mimetype": "text/plain", "start_char_idx": 98874, "end_char_idx": 103200, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "45832d34-5ac9-49ed-892b-112e826b24c8": {"__data__": {"id_": "45832d34-5ac9-49ed-892b-112e826b24c8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ace4dc8e-23a8-427d-8a5d-706f0740563f", "node_type": "1", "metadata": {}, "hash": "3c61c071a40819d124e285a84a04102c5716bc3c73883733da65a3a1b5f7592b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "58881db4-4581-42dc-98d8-e64fdbb22d9d", "node_type": "1", "metadata": {}, "hash": "4e4ebdf7f9c2fcb35f6dbad151421441bed09484655aacdb6aa9d41fc4c7ba8a", "class_name": "RelatedNodeInfo"}}, "text": "Forexample,supervisedlearningassumesthesimpleinteractionpatterndepicted\ninFig. 1.3.6 .\nThis simplicity of offline learning has its charms. The upside is that we can worry about\npattern recognition in isolation, with no concern about complications arising from interac-\ntions with a dynamic environment. But this problem formulation is limiting. If you grew\nup reading Asimov\u2019s Robot novels, then you probably picture artificially intelligent agents\ncapable not only of making predictions, but also of taking actions in the world. We want\nto think about intelligent agents, not just predictive models. This means that we need to\nthink about choosing actions, not just making predictions. In contrast to mere predictions,\nactions actually impact the environment. If we want to train an intelligent agent, we must\n18 Introduction\ntFig. 1.3.6 Collecting data for supervised learning from an environment.\naccount for the way its actions might impact the future observations of the agent, and so\noffline learning is inappropriate.\nConsidering the interaction with an environment opens a whole set of new modeling ques-\ntions. The following are just a few examples.\n\u000fDoes the environment remember what we did previously?\n\u000fDoes the environment want to help us, e.g., a user reading text into a speech recognizer?\n\u000fDoes the environment want to beat us, e.g., spammers adapting their emails to evade\nspam filters?\n\u000fDoes the environment have shifting dynamics? For example, would future data always\nresemble the past or would the patterns change over time, either naturally or in re-\nsponse to our automated tools?\nThese questions raise the problem of distribution shift , where training and test data are\ndifferent. An example of this, that many of us may have met, is when taking exams written\nby a lecturer, while the homework was composed by their teaching assistants. Next, we\nbriefly describe reinforcement learning, a rich framework for posing learning problems in\nwhich an agent interacts with an environment.\n1.3.4ReinforcementLearning\nIf you are interested in using machine learning to develop an agent that interacts with an\nenvironment and takes actions, then you are probably going to wind up focusing on re-\ninforcement learning . This might include applications to robotics, to dialogue systems,\nand even to developing artificial intelligence (AI) for video games. Deep reinforcement\nlearning , which applies deep learning to reinforcement learning problems, has surged in\npopularity. The breakthroughdeepQ-network, thatbeathumans atAtari gamesusingonly\nthe visual input ( Mnihetal., 2015), and the AlphaGo program, which dethroned the world\nchampion at the board game Go ( Silveretal., 2016), are two prominent examples.\nReinforcementlearninggivesaverygeneralstatementofaprobleminwhichanagentinter-\nacts with an environment over a series of time steps. At each time step, the agent receives\nsomeobservation from the environment and must choose an actionthat is subsequently\ntransmitted back to the environment via some mechanism (sometimes called an actuator ),\nwhen, after each loop, the agent receives a reward from the environment. This process is\n19 Kinds of Machine Learning Problems\nillustrated in Fig. 1.3.7 . The agent then receives a subsequent observation, and chooses a\nsubsequent action, and so on. The behavior of a reinforcement learning agent is governed\nby apolicy. In brief, a policyis just a function that maps from observations of the environ-\nment to actions. The goal of reinforcement learning is to produce good policies.\ntFig. 1.3.7 The interaction between reinforcement learning and an environment.\nItishardtooverstatethegeneralityofthereinforcementlearningframework. Forexample,\nsupervised learning can be recast as reinforcement learning. Say we had a classification\nproblem. We could create a reinforcement learning agent with one action corresponding\nto each class. We could then create an environment which gave a reward that was exactly\nequal to the loss function from the original supervised learning problem.\nFurther, reinforcement learning can also address many problems that supervised learning\ncannot. Forexample,insupervisedlearning,wealwaysexpectthatthetraininginputcomes\nassociated with the correct label. But in reinforcement learning, we do not assume that,\nfor each observation the environment tells us the optimal action. In general, we just get\nsome reward. Moreover, the environment may not even tell us which actions led to the\nreward.\nConsiderthegameofchess. Theonlyrealrewardsignalcomesattheendofthegamewhen\nwe either win, earning a reward of, say, 1, or when we lose, receiving a reward of, say,\n\u00001.", "mimetype": "text/plain", "start_char_idx": 102368, "end_char_idx": 107020, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "58881db4-4581-42dc-98d8-e64fdbb22d9d": {"__data__": {"id_": "58881db4-4581-42dc-98d8-e64fdbb22d9d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "45832d34-5ac9-49ed-892b-112e826b24c8", "node_type": "1", "metadata": {}, "hash": "c15a934b41b289dfad01800b976ee582603c3f9bb3a9e2377da24aab871bfe4c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b170fe60-9304-4479-8103-ae20816a6412", "node_type": "1", "metadata": {}, "hash": "fb1ff10b3c703b6abfea6831872aa9b7ebb1a06344a56074703b94db13e69935", "class_name": "RelatedNodeInfo"}}, "text": "We could create a reinforcement learning agent with one action corresponding\nto each class. We could then create an environment which gave a reward that was exactly\nequal to the loss function from the original supervised learning problem.\nFurther, reinforcement learning can also address many problems that supervised learning\ncannot. Forexample,insupervisedlearning,wealwaysexpectthatthetraininginputcomes\nassociated with the correct label. But in reinforcement learning, we do not assume that,\nfor each observation the environment tells us the optimal action. In general, we just get\nsome reward. Moreover, the environment may not even tell us which actions led to the\nreward.\nConsiderthegameofchess. Theonlyrealrewardsignalcomesattheendofthegamewhen\nwe either win, earning a reward of, say, 1, or when we lose, receiving a reward of, say,\n\u00001. So reinforcement learners must deal with the creditassignment problem: determining\nwhich actions to credit or blame for an outcome. The same goes for an employee who gets\napromotiononOctober11. Thatpromotionlikelyreflectsanumberofwell-chosenactions\nover the previous year. Getting promoted in the future requires figuring out which actions\nalong the way led to the earlier promotions.\nReinforcement learners may also have to deal with the problem of partial observability.\nThat is, the current observation might not tell you everything about your current state. Say\nyour cleaning robot found itself trapped in one of many identical closets in your house.\nRescuing the robot involves inferring its precise location which might require considering\nearlier observations prior to it entering the closet.\nFinally, at any given point, reinforcement learners might know of one good policy, but\nthere might be many other better policies that the agent has never tried. The reinforcement\nlearner must constantly choose whether to exploitthe best (currently) known strategy as a\npolicy, or to explorethe space of strategies, potentially giving up some short-term reward\nin exchange for knowledge.\nThe general reinforcement learning problem has a very general setting. Actions affect sub-\n20 Introduction\n23\n24\n25\n26sequent observations. Rewards are only observed when they correspond to the chosen ac-\ntions. The environment may be either fully or partially observed. Accounting for all this\ncomplexity at once may be asking too much. Moreover, not every practical problem ex-\nhibits all this complexity. As a result, researchers have studied a number of special cases\nof reinforcement learning problems.\nWhen the environment is fully observed, we call the reinforcement learning problem a\nMarkovdecisionprocess . When the state does not depend on the previous actions, we call\nit acontextual bandit problem . When there is no state, just a set of available actions with\ninitially unknown rewards, we have the classic multi-armed bandit problem .\n1.4Roots\nWe have just reviewed a small subset of problems that machine learning can address. For\na diverse set of machine learning problems, deep learning provides powerful tools for their\nsolution. Although many deep learning methods are recent inventions, the core ideas be-\nhind learning from data have been studied for centuries. In fact, humans have held the\ndesire to analyze data and to predict future outcomes for ages, and it is this desire that is\nat the root of much of natural science and mathematics. Two examples are the Bernoulli\ndistribution, named after Jacob Bernoulli (1655\u20131705)23, and the Gaussian distribution\ndiscovered by Carl Friedrich Gauss (1777\u20131855)24. Gauss invented, for instance, the least\nmean squares algorithm, which is still used today for a multitude of problems from insur-\nance calculations to medical diagnostics. Such tools enhanced the experimental approach\nin the natural sciences\u2014for instance, Ohm\u2019s law relating current and voltage in a resistor\nis perfectly described by a linear model.\nEven in the middle ages, mathematicians had a keen intuition of estimates. For instance,\nthe geometry book of Jacob K\u00f6bel (1460\u20131533)25illustrates averaging the length of 16\nadult men\u2019s feet to estimate the typical foot length in the population ( Fig. 1.4.1 ).\nAs a group of individuals exited a church, 16 adult men were asked to line up in a row\nand have their feet measured. The sum of these measurements was then divided by 16 to\nobtain an estimate for what now is called one foot. This \u201calgorithm\u201d was later improved to\ndeal with misshapen feet; The two men with the shortest and longest feet were sent away,\naveraging only over the remainder. This is among the earliest examples of a trimmed mean\nestimate.\nStatistics really took off with the availability and collection of data.", "mimetype": "text/plain", "start_char_idx": 106175, "end_char_idx": 110876, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b170fe60-9304-4479-8103-ae20816a6412": {"__data__": {"id_": "b170fe60-9304-4479-8103-ae20816a6412", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "58881db4-4581-42dc-98d8-e64fdbb22d9d", "node_type": "1", "metadata": {}, "hash": "4e4ebdf7f9c2fcb35f6dbad151421441bed09484655aacdb6aa9d41fc4c7ba8a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "724185fd-5d85-4139-8e1f-c15d8b64ab7f", "node_type": "1", "metadata": {}, "hash": "44c78458908822247d6ca618f97c54e9b646fe819ccc11eed272bf64ef4918a9", "class_name": "RelatedNodeInfo"}}, "text": "Even in the middle ages, mathematicians had a keen intuition of estimates. For instance,\nthe geometry book of Jacob K\u00f6bel (1460\u20131533)25illustrates averaging the length of 16\nadult men\u2019s feet to estimate the typical foot length in the population ( Fig. 1.4.1 ).\nAs a group of individuals exited a church, 16 adult men were asked to line up in a row\nand have their feet measured. The sum of these measurements was then divided by 16 to\nobtain an estimate for what now is called one foot. This \u201calgorithm\u201d was later improved to\ndeal with misshapen feet; The two men with the shortest and longest feet were sent away,\naveraging only over the remainder. This is among the earliest examples of a trimmed mean\nestimate.\nStatistics really took off with the availability and collection of data. One of its pioneers,\nRonald Fisher (1890\u20131962)26, contributed significantly to its theory and also its applica-\ntions in genetics. Many of his algorithms (such as linear discriminant analysis) and con-\ncepts (such as the Fisher information matrix) still hold a prominent place in the founda-\ntions of modern statistics. Even his data resources had a lasting impact. The Iris dataset\nthat Fisher released in 1936 is still sometimes used to demonstrate machine learning algo-\nrithms. Fisher was also a proponent of eugenics, which should remind us that the morally\n21 Roots\ntFig. 1.4.1 Estimating the length of a foot.\n27\n28\n29dubious use of data science has as long and enduring a history as its productive use in\nindustry and the natural sciences.\nOther influences for machine learning came from the information theory of Claude Shan-\nnon (1916\u20132001)27and the theory of computation proposed by Alan Turing (1912\u20131954)\n28. Turing posed the question \u201ccan machines think?\u201d in his famous paper Computing Ma-\nchineryandIntelligence (Turing, 1950 ). Describing what is now known as the Turing test,\nhe proposed that a machine can be considered intelligent if it is difficult for a human evalu-\nator to distinguish between the replies from a machine and those of a human, based purely\non textual interactions.\nFurther influences came from neuroscience and psychology. After all, humans clearly ex-\nhibit intelligent behavior. Many scholars have asked whether one could explain and pos-\nsibly reverse engineer this capacity. One of the first biologically inspired algorithms was\nformulated by Donald Hebb (1904\u20131985)29. In his groundbreaking book The Organiza-\ntion of Behavior (Hebb, 1949 ), he posited that neurons learn by positive reinforcement.\nThis became known as the Hebbian learning rule. These ideas inspired later work, such\nas Rosenblatt\u2019s perceptron learning algorithm, and laid the foundations of many stochastic\ngradient descent algorithms that underpin deep learning today: reinforce desirable behav-\nior and diminish undesirable behavior to obtain good settings of the parameters in a neural\nnetwork.\n22 Introduction\nBiological inspiration is what gave neuralnetworks their name. For over a century (dating\nback to the models of Alexander Bain, 1873, and James Sherrington, 1890), researchers\nhavetriedtoassemblecomputationalcircuitsthatresemblenetworksofinteractingneurons.\nOver time, the interpretation of biology has become less literal, but the name stuck. At its\nheart lie a few key principles that can be found in most networks today:\n\u000fThe alternation of linear and nonlinear processing units, often referred to as layers.\n\u000fThe use of the chain rule (also known as backpropagation ) for adjusting parameters in\nthe entire network at once.\nAfterinitialrapidprogress, researchinneuralnetworkslanguishedfromaround1995until\n2005. This was mainly due to two reasons. First, training a network is computationally\nvery expensive. While random-access memory was plentiful at the end of the past century,\ncomputational power was scarce. Second, datasets were relatively small. In fact, Fisher\u2019s\nIris dataset from 1936 was still a popular tool for testing the efficacy of algorithms. The\nMNIST dataset with its 60,000 handwritten digits was considered huge.\nGiven the scarcity of data and computation, strong statistical tools such as kernel methods,\ndecision trees, and graphical models proved empirically superior in many applications.\nMoreover, unlike neural networks, they did not require weeks to train and provided pre-\ndictable results with strong theoretical guarantees.", "mimetype": "text/plain", "start_char_idx": 110091, "end_char_idx": 114460, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "724185fd-5d85-4139-8e1f-c15d8b64ab7f": {"__data__": {"id_": "724185fd-5d85-4139-8e1f-c15d8b64ab7f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b170fe60-9304-4479-8103-ae20816a6412", "node_type": "1", "metadata": {}, "hash": "fb1ff10b3c703b6abfea6831872aa9b7ebb1a06344a56074703b94db13e69935", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "36708a62-8036-4f63-830e-bfddbc8fff5f", "node_type": "1", "metadata": {}, "hash": "bce3df175f4d7834ac6c06e63d1a367fbf08dc132c495af5ee1a99b04de808d2", "class_name": "RelatedNodeInfo"}}, "text": "\u000fThe use of the chain rule (also known as backpropagation ) for adjusting parameters in\nthe entire network at once.\nAfterinitialrapidprogress, researchinneuralnetworkslanguishedfromaround1995until\n2005. This was mainly due to two reasons. First, training a network is computationally\nvery expensive. While random-access memory was plentiful at the end of the past century,\ncomputational power was scarce. Second, datasets were relatively small. In fact, Fisher\u2019s\nIris dataset from 1936 was still a popular tool for testing the efficacy of algorithms. The\nMNIST dataset with its 60,000 handwritten digits was considered huge.\nGiven the scarcity of data and computation, strong statistical tools such as kernel methods,\ndecision trees, and graphical models proved empirically superior in many applications.\nMoreover, unlike neural networks, they did not require weeks to train and provided pre-\ndictable results with strong theoretical guarantees.\n1.5The Roadto Deep Learning\nMuch of this changed with the availabilityof massiveamounts of data, thanks to the World\nWide Web, the advent of companies serving hundreds of millions of users online, a dis-\nsemination of low-cost, high-quality sensors, inexpensive data storage (Kryder\u2019s law), and\ncheap computation (Moore\u2019s law). In particular, the landscape of computation in deep\nlearning was revolutionized by advances in GPUs that were originally engineered for com-\nputer gaming. Suddenly algorithms and models that seemed computationally infeasible\nwere within reach. This is best illustrated in tab_intro_decade .\n:Dataset vs. computer memory and computational power\nTable 1.5.1: label: tab_intro_decade\n23 The Road to Deep Learning\nDecade Dataset Mem-\noryFloating point calculations per\nsecond\n1970 100 (Iris) 1 KB 100 KF (Intel 8080)\n1980 1 K (house prices in Boston) 100\nKB1 MF (Intel 80186)\n1990 10 K (optical character recog-\nnition)10 MB 10 MF (Intel 80486)\n2000 10 M (web pages) 100\nMB1 GF (Intel Core)\n2010 10 G (advertising) 1 GB 1 TF (NVIDIA C2050)\n2020 1 T (social network) 100\nGB1 PF (NVIDIA DGX-2)\nNote that random-access memory has not kept pace with the growth in data. At the same\ntime, increases in computational power have outpaced the growth in datasets. This means\nthatstatisticalmodelsneedtobecomemorememoryefficient,andsotheyarefreetospend\nmore computer cycles optimizing parameters, thanks to the increased compute budget.\nConsequently, the sweet spot in machine learning and statistics moved from (generalized)\nlinear models and kernel methods to deep neural networks. This is also one of the rea-\nsons why many of the mainstays of deep learning, such as multilayer perceptrons ( McCul-\nloch and Pitts, 1943 ), convolutional neural networks ( LeCunetal., 1998), long short-term\nmemory( HochreiterandSchmidhuber,1997 ),andQ-Learning( WatkinsandDayan,1992 ),\nwere essentially \u201crediscovered\u201d in the past decade, after lying comparatively dormant for\nconsiderable time.\nThe recent progress in statistical models, applications, and algorithms has sometimes been\nlikenedtotheCambrianexplosion: amomentofrapidprogressintheevolutionofspecies.\nIndeed, the state of the art is not just a mere consequence of available resources applied\nto decades-old algorithms. Note that the list of ideas below barely scratches the surface of\nwhat has helped researchers achieve tremendous progress over the past decade.\n\u000fNovelmethodsforcapacitycontrol,suchas dropout (Srivastava etal.,2014),havehelped\nto mitigate overfitting. Here, noise is injected ( Bishop, 1995 ) throughout the neural\nnetwork during training.\n\u000fAttention mechanisms solved a second problem that had plagued statistics for over a\ncentury: how to increase the memory and complexity of a system without increasing\nthe number of learnable parameters. Researchers found an elegant solution by using\nwhat can only be viewed as a learnable pointer structure (Bahdanau et al., 2014).\nRather than having to remember an entire text sequence, e.g., for machine translation\nin a fixed-dimensional representation, all that needed to be stored was a pointer to the\nintermediate state of the translation process. This allowed for significantly increased\naccuracyforlongsequences,sincethemodelnolongerneededtoremembertheentire\nsequence before commencing the generation of a new one.", "mimetype": "text/plain", "start_char_idx": 113515, "end_char_idx": 117804, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "36708a62-8036-4f63-830e-bfddbc8fff5f": {"__data__": {"id_": "36708a62-8036-4f63-830e-bfddbc8fff5f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "724185fd-5d85-4139-8e1f-c15d8b64ab7f", "node_type": "1", "metadata": {}, "hash": "44c78458908822247d6ca618f97c54e9b646fe819ccc11eed272bf64ef4918a9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "48ab4063-7c85-420e-88ae-44771decc928", "node_type": "1", "metadata": {}, "hash": "f078457b86aea1acdf3e93545a3467aa845a34bbaee88fb9e970dda9c20d9a35", "class_name": "RelatedNodeInfo"}}, "text": "Here, noise is injected ( Bishop, 1995 ) throughout the neural\nnetwork during training.\n\u000fAttention mechanisms solved a second problem that had plagued statistics for over a\ncentury: how to increase the memory and complexity of a system without increasing\nthe number of learnable parameters. Researchers found an elegant solution by using\nwhat can only be viewed as a learnable pointer structure (Bahdanau et al., 2014).\nRather than having to remember an entire text sequence, e.g., for machine translation\nin a fixed-dimensional representation, all that needed to be stored was a pointer to the\nintermediate state of the translation process. This allowed for significantly increased\naccuracyforlongsequences,sincethemodelnolongerneededtoremembertheentire\nsequence before commencing the generation of a new one.\n\u000fBuiltsolelyonattentionmechanisms,the Transformer architecture( Vaswanietal.,2017)\n24 Introduction\n30has demonstrated superior scalingbehavior: it performs better with an increase in\ndataset size, model size, and amount of training compute ( Kaplanet al., 2020). This\narchitecture has demonstrated compelling success in a wide range of areas, such as\nnaturallanguageprocessing( Brownetal.,2020,Devlinetal.,2018),computervision\n(Dosovitskiy et al., 2021,Liuet al., 2021), speech recognition ( Gulatiet al., 2020),\nreinforcement learning ( Chenet al., 2021), and graph neural networks ( Dwivedi and\nBresson,2020 ). Forexample,asingleTransformerpretrainedonmodalitiesasdiverse\nas text, images, joint torques, and button presses can play Atari, caption images, chat,\nand control a robot ( Reedetal., 2022).\n\u000fModeling probabilities of text sequences, language models can predict text given other\ntext. Scaling up the data, model, and compute has unlocked a growing number of\ncapabilities of language models to perform desired tasks via human-like text genera-\ntionbasedoninputtext( Aniletal.,2023,Brownetal.,2020,Chowdhery etal.,2022,\nHoffmann etal.,2022,OpenAI,2023 ,Raeetal.,2021,Touvronetal.,2023a,Touvron\net al., 2023b). For instance, aligning language models with human intent ( Ouyanget\nal., 2022), OpenAI\u2019s ChatGPT30allows users to interact with it in a conversational\nway to solve problems, such as code debugging and creative writing.\n\u000fMulti-stagedesigns,e.g.,viathememorynetworks( Sukhbaatar etal.,2015)andtheneu-\nralprogrammer-interpreter( ReedandDeFreitas,2015 )permittedstatisticalmodelers\ntodescribeiterativeapproachestoreasoning. Thesetoolsallowforaninternalstateof\nthe deep neural network to be modified repeatedly, thus carrying out subsequent steps\nin a chain of reasoning, just as a processor can modify memory for a computation.\n\u000fA key development in deep generative modeling was the invention of generative adver-\nsarialnetworks (Goodfellow etal.,2014). Traditionally,statisticalmethodsfordensity\nestimation and generative models focused on finding proper probability distributions\nand (often approximate) algorithms for sampling from them. As a result, these algo-\nrithms were largely limited by the lack of flexibility inherent in the statistical models.\nThe crucial innovation in generative adversarial networks was to replace the sampler\nby an arbitrary algorithm with differentiable parameters. These are then adjusted in\nsuch a way that the discriminator (effectively a two-sample test) cannot distinguish\nfake from real data. Through the ability to use arbitrary algorithms to generate data,\ndensity estimation was opened up to a wide variety of techniques. Examples of gal-\nloping zebras ( Zhuet al., 2017) and of fake celebrity faces ( Karraset al., 2017) are\neach testimony to this progress. Even amateur doodlers can produce photorealistic\nimages just based on sketches describing the layout of a scene ( Parketal., 2019).\n\u000fFurthermore, while the diffusion process gradually adds random noise to data samples,\ndiffusionmodels (Hoetal.,2020,Sohl-Dickstein etal.,2015)learnthedenoisingpro-\ncess to gradually construct data samples from random noise, reversing the diffusion\nprocess.", "mimetype": "text/plain", "start_char_idx": 116994, "end_char_idx": 121012, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "48ab4063-7c85-420e-88ae-44771decc928": {"__data__": {"id_": "48ab4063-7c85-420e-88ae-44771decc928", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "36708a62-8036-4f63-830e-bfddbc8fff5f", "node_type": "1", "metadata": {}, "hash": "bce3df175f4d7834ac6c06e63d1a367fbf08dc132c495af5ee1a99b04de808d2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "938a69f6-cbc8-43ab-96da-9caccd7c8b67", "node_type": "1", "metadata": {}, "hash": "25d59c5ca0b9f70be4104a3323f5f8b510059fee335133c4c0ce8332cfe5aa78", "class_name": "RelatedNodeInfo"}}, "text": "These are then adjusted in\nsuch a way that the discriminator (effectively a two-sample test) cannot distinguish\nfake from real data. Through the ability to use arbitrary algorithms to generate data,\ndensity estimation was opened up to a wide variety of techniques. Examples of gal-\nloping zebras ( Zhuet al., 2017) and of fake celebrity faces ( Karraset al., 2017) are\neach testimony to this progress. Even amateur doodlers can produce photorealistic\nimages just based on sketches describing the layout of a scene ( Parketal., 2019).\n\u000fFurthermore, while the diffusion process gradually adds random noise to data samples,\ndiffusionmodels (Hoetal.,2020,Sohl-Dickstein etal.,2015)learnthedenoisingpro-\ncess to gradually construct data samples from random noise, reversing the diffusion\nprocess. They have started to replace generative adversarial networks in more recent\ndeep generative models, such as in DALL-E 2 ( Rameshetal., 2022) and Imagen ( Sa-\nhariaetal., 2022) for creative art and image generation based on text descriptions.\n\u000fIn many cases, a single GPU is insufficient for processing the large amounts of data\n25 Success Stories\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42availablefortraining. Overthepastdecadetheabilitytobuildparallelanddistributed\ntrainingalgorithmshasimprovedsignificantly. Oneofthekeychallengesindesigning\nscalable algorithms is that the workhorse of deep learning optimization, stochastic\ngradient descent, relies on relatively small minibatches of data to be processed. At\nthe same time, small batches limit the efficiency of GPUs. Hence, training on 1,024\nGPUs with a minibatch size of, say, 32 images per batch amounts to an aggregate\nminibatch of about 32,000 images. Work, first by Li ( 2017) and subsequently by You\netal.(2017) and Jiaetal.(2018) pushed the size up to 64,000 observations, reducing\ntraining time forthe ResNet-50model on the ImageNetdataset to less than 7 minutes.\nBy comparison, training times were initially of the order of days.\n\u000fThe ability to parallelize computation has also contributed to progress in reinforcement\nlearning . This has led to significant progress in computers achieving superhuman\nperformanceontaskslikeGo,Atarigames,Starcraft,andinphysicssimulations(e.g.,\nusing MuJoCo) where environment simulators are available. See, e.g., Silver et al.\n(2016)foradescriptionofsuchachievementsinAlphaGo. Inanutshell,reinforcement\nlearningworksbestifplentyof(state,action, reward)tuplesareavailable. Simulation\nprovides such an avenue.\n\u000fDeep learning frameworks have played a crucial role in disseminating ideas. The first\ngenerationofopen-sourceframeworksforneuralnetworkmodelingconsistedof Caffe\n31,Torch32, andTheano33. Many seminal papers were written using these tools.\nThese have now been superseded by TensorFlow34(often used via its high-level API\nKeras35),CNTK36,Caffe 237, andApache MXNet38. The third generation of\nframeworks consists of so-called imperative tools for deep learning, a trend that was\narguably ignited by Chainer39, which used a syntax similar to Python NumPy to\ndescribe models. This idea was adopted by both PyTorch40, theGluon API41of\nMXNet, and JAX42.\nThe division of labor between system researchers building better tools and statistical mod-\nelers building better neural networks has greatly simplified things. For instance, training a\nlinear logistic regression model used to be a nontrivial homework problem, worthy to give\nto new machine learning Ph.D. students at Carnegie Mellon University in 2014. By now,\nthistaskcanbeaccomplishedwithunder10linesofcode,puttingitfirmlywithinthereach\nof any programmer.\n1.6Success Stories\nArtificial intelligence has a long history of delivering results that would be difficult to ac-\ncomplish otherwise. For instance, mail sorting systems using optical character recognition\nhave been deployed since the 1990s. This is, after all, the source of the famous MNIST\ndataset of handwritten digits. The same applies to reading checks for bank deposits and\nscoring creditworthiness of applicants. Financial transactions are checked for fraud auto-\n26 Introduction\nmatically.", "mimetype": "text/plain", "start_char_idx": 120221, "end_char_idx": 124317, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "938a69f6-cbc8-43ab-96da-9caccd7c8b67": {"__data__": {"id_": "938a69f6-cbc8-43ab-96da-9caccd7c8b67", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "48ab4063-7c85-420e-88ae-44771decc928", "node_type": "1", "metadata": {}, "hash": "f078457b86aea1acdf3e93545a3467aa845a34bbaee88fb9e970dda9c20d9a35", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cebcef18-11ab-475f-b374-f0ee85ba83e2", "node_type": "1", "metadata": {}, "hash": "1f77b58aadfcfd683d664ee2be707dfe04861bb31632939ccb42c808a1eb444d", "class_name": "RelatedNodeInfo"}}, "text": "For instance, training a\nlinear logistic regression model used to be a nontrivial homework problem, worthy to give\nto new machine learning Ph.D. students at Carnegie Mellon University in 2014. By now,\nthistaskcanbeaccomplishedwithunder10linesofcode,puttingitfirmlywithinthereach\nof any programmer.\n1.6Success Stories\nArtificial intelligence has a long history of delivering results that would be difficult to ac-\ncomplish otherwise. For instance, mail sorting systems using optical character recognition\nhave been deployed since the 1990s. This is, after all, the source of the famous MNIST\ndataset of handwritten digits. The same applies to reading checks for bank deposits and\nscoring creditworthiness of applicants. Financial transactions are checked for fraud auto-\n26 Introduction\nmatically. Thisformsthebackboneofmanye-commercepaymentsystems,suchasPayPal,\nStripe, AliPay, WeChat, Apple, Visa, and MasterCard. Computer programs for chess have\nbeen competitive for decades. Machine learning feeds search, recommendation, personal-\nization, and ranking on the Internet. In other words, machine learning is pervasive, albeit\noften hidden from sight.\nItisonlyrecentlythatAIhasbeeninthelimelight,mostlyduetosolutionstoproblemsthat\nwere considered intractable previously and that are directly related to consumers. Many of\nsuch advances are attributed to deep learning.\n\u000fIntelligent assistants, such as Apple\u2019s Siri, Amazon\u2019s Alexa, and Google\u2019s assistant, are\nable to respond to spoken requests with a reasonable degree of accuracy. This in-\ncludes menial jobs, like turning on light switches, and more complex tasks, such as\narranging barber\u2019s appointments and offering phone support dialog. This is likely the\nmost noticeable sign that AI is affecting our lives.\n\u000fA key ingredient in digital assistants is their ability to recognize speech accurately. The\naccuracyofsuchsystemshasgraduallyincreasedtothepointofachievingparitywith\nhumans for certain applications ( Xiongetal., 2018).\n\u000fObject recognition has likewise come a long way. Identifying the object in a picture was\na fairly challenging task in 2010. On the ImageNet benchmark researchers from NEC\nLabs and University of Illinois at Urbana-Champaign achieved a top-five error rate\nof 28% ( Linet al., 2010). By 2017, this error rate was reduced to 2.25% ( Huet al.,\n2018). Similarly, stunning results have been achieved for identifying birdsong and for\ndiagnosing skin cancer.\n\u000fProwess in games used to provide a measuring stick for human ability. Starting from\nTD-Gammon, a program for playing backgammon using temporal difference rein-\nforcement learning, algorithmic and computational progress has led to algorithms for\na wide range of applications. Compared with backgammon, chess has a much more\ncomplex state space and set of actions. DeepBlue beat Garry Kasparov using mas-\nsive parallelism, special-purpose hardware and efficient search through the game tree\n(Campbell etal.,2002). Goismoredifficultstill,duetoitshugestatespace. AlphaGo\nreached human parity in 2015, using deep learning combined with Monte Carlo tree\nsampling ( Silveretal., 2016). The challenge in Poker was that the state space is large\nandonlypartiallyobserved(wedonotknowtheopponents\u2019cards). Libratusexceeded\nhuman performance in Poker using efficiently structured strategies ( Brown and Sand-\nholm, 2017 ).\n\u000fAnother indication of progress in AI is the advent of self-driving vehicles. While full\nautonomy is not yet within reach, excellent progress has been made in this direction,\nwith companies such as Tesla, NVIDIA, and Waymo shipping products that enable\npartial autonomy. What makes full autonomy so challenging is that proper driving\nrequires the ability to perceive, to reason and to incorporate rules into a system. At\npresent, deep learning is used primarily in the visual aspect of these problems. The\nrest is heavily tuned by engineers.\n27 The Essence of Deep Learning\nThis barely scratches the surface of significant applications of machine learning. For in-\nstance, robotics, logistics, computational biology, particle physics, and astronomy owe\nsome of their most impressive recent advances at least in parts to machine learning, which\nis thus becoming a ubiquitous tool for engineers and scientists.\nFrequently, questions about a coming AI apocalypse and the plausibility of a singularity\nhave been raised in non-technical articles. The fear is that somehow machine learning\nsystems will become sentient and make decisions, independently of their programmers,\nthat directly impact the lives of humans.", "mimetype": "text/plain", "start_char_idx": 123521, "end_char_idx": 128077, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cebcef18-11ab-475f-b374-f0ee85ba83e2": {"__data__": {"id_": "cebcef18-11ab-475f-b374-f0ee85ba83e2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "938a69f6-cbc8-43ab-96da-9caccd7c8b67", "node_type": "1", "metadata": {}, "hash": "25d59c5ca0b9f70be4104a3323f5f8b510059fee335133c4c0ce8332cfe5aa78", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "94a2897e-06c3-4be4-a13a-b2a8b234fd9e", "node_type": "1", "metadata": {}, "hash": "afa49af4ae49d81f6bb1898e5012e95981b3938a5d7cbb89dd5a0d1e2df5ce44", "class_name": "RelatedNodeInfo"}}, "text": "What makes full autonomy so challenging is that proper driving\nrequires the ability to perceive, to reason and to incorporate rules into a system. At\npresent, deep learning is used primarily in the visual aspect of these problems. The\nrest is heavily tuned by engineers.\n27 The Essence of Deep Learning\nThis barely scratches the surface of significant applications of machine learning. For in-\nstance, robotics, logistics, computational biology, particle physics, and astronomy owe\nsome of their most impressive recent advances at least in parts to machine learning, which\nis thus becoming a ubiquitous tool for engineers and scientists.\nFrequently, questions about a coming AI apocalypse and the plausibility of a singularity\nhave been raised in non-technical articles. The fear is that somehow machine learning\nsystems will become sentient and make decisions, independently of their programmers,\nthat directly impact the lives of humans. To some extent, AI already affects the livelihood\nof humans in direct ways: creditworthiness is assessed automatically, autopilots mostly\nnavigate vehicles, decisions about whether to grant bail use statistical data as input. More\nfrivolously, we can ask Alexa to switch on the coffee machine.\nFortunately, we are far from a sentient AI system that could deliberately manipulate its\nhuman creators. First, AI systems are engineered, trained, and deployed in a specific, goal-\norientedmanner. Whiletheirbehaviormightgivetheillusionofgeneralintelligence,itisa\ncombination of rules, heuristics and statistical models that underlie the design. Second, at\npresent, there are simply no tools for artificialgeneralintelligence that are able to improve\nthemselves,reasonaboutthemselves,andthatareabletomodify,extend,andimprovetheir\nown architecture while trying to solve general tasks.\nA much more pressing concern is how AI is being used in our daily lives. It is likely that\nmany routine tasks, currently fulfilled by humans, can and will be automated. Farm robots\nwill likely reduce the costs for organic farmers but they will also automate harvesting op-\nerations. This phase of the industrial revolution may have profound consequences for large\nswaths of society, since menial jobs provide much employment in many countries. Fur-\nthermore, statistical models, when applied without care, can lead to racial, gender, or age\nbias and raise reasonable concerns about procedural fairness if automated to drive conse-\nquential decisions. It is important to ensure that these algorithms are used with care. With\nwhat we know today, this strikes us as a much more pressing concern than the potential of\nmalevolent superintelligence for destroying humanity.\n1.7The Essence of Deep Learning\nThusfar,wehavetalkedinbroadtermsaboutmachinelearning. Deeplearningisthesubset\nof machine learning concerned with models based on many-layered neural networks. It is\ndeepinpreciselythesensethatitsmodelslearnmany layersoftransformations. Whilethis\nmightsoundnarrow,deeplearninghasgivenrisetoadizzyingarrayofmodels,techniques,\nproblem formulations, and applications. Many intuitions have been developed to explain\nthe benefits of depth. Arguably, all machine learning has many layers of computation, the\nfirst consisting of feature processing steps. What differentiates deep learning is that the\noperations learned at each of the many layers of representations are learned jointly from\ndata.\n28 Introduction\nTheproblemsthatwehavediscussedsofar, suchaslearningfromtherawaudiosignal, the\nraw pixel values of images, or mapping between sentences of arbitrary lengths and their\ncounterparts in foreign languages, are those where deep learning excels and traditional\nmethods falter. It turns out that these many-layered models are capable of addressing low-\nlevel perceptual data in a way that previous tools could not. Arguably the most significant\ncommonality in deep learning methods is end-to-end training . That is, rather than assem-\nbling a system based on components that are individually tuned, one builds the system and\nthen tunes their performance jointly. For instance, in computer vision scientists used to\nseparate the process of feature engineering from the process of building machine learn-\ning models. The Canny edge detector ( Canny, 1987 ) and Lowe\u2019s SIFT feature extractor\n(Lowe, 2004 ) reigned supreme for over a decade as algorithms for mapping images into\nfeature vectors. In bygone days, the crucial part of applying machine learning to these\nproblems consisted of coming up with manually-engineered ways of transforming the data\ninto some form amenable to shallow models. Unfortunately, there is only so much that\nhumans can accomplish by ingenuity in comparison with a consistent evaluation over mil-\nlions of choices carried out automatically by an algorithm.", "mimetype": "text/plain", "start_char_idx": 127138, "end_char_idx": 131935, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "94a2897e-06c3-4be4-a13a-b2a8b234fd9e": {"__data__": {"id_": "94a2897e-06c3-4be4-a13a-b2a8b234fd9e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cebcef18-11ab-475f-b374-f0ee85ba83e2", "node_type": "1", "metadata": {}, "hash": "1f77b58aadfcfd683d664ee2be707dfe04861bb31632939ccb42c808a1eb444d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "dc43f26d-c5dc-48c4-b73b-776e0c110b8d", "node_type": "1", "metadata": {}, "hash": "5721032b452ddc43b093afd03cae99bc1779ef2e2c114667547fec94602f9e65", "class_name": "RelatedNodeInfo"}}, "text": "That is, rather than assem-\nbling a system based on components that are individually tuned, one builds the system and\nthen tunes their performance jointly. For instance, in computer vision scientists used to\nseparate the process of feature engineering from the process of building machine learn-\ning models. The Canny edge detector ( Canny, 1987 ) and Lowe\u2019s SIFT feature extractor\n(Lowe, 2004 ) reigned supreme for over a decade as algorithms for mapping images into\nfeature vectors. In bygone days, the crucial part of applying machine learning to these\nproblems consisted of coming up with manually-engineered ways of transforming the data\ninto some form amenable to shallow models. Unfortunately, there is only so much that\nhumans can accomplish by ingenuity in comparison with a consistent evaluation over mil-\nlions of choices carried out automatically by an algorithm. When deep learning took over,\nthese feature extractors were replaced by automatically tuned filters that yielded superior\naccuracy.\nThus, one key advantage of deep learning is that it replaces not only the shallow models at\ntheendoftraditionallearningpipelines,butalsothelabor-intensiveprocessoffeatureengi-\nneering. Moreover,byreplacingmuchofthedomain-specificpreprocessing,deeplearning\nhas eliminated many of the boundaries that previously separated computer vision, speech\nrecognition, naturallanguageprocessing, medicalinformatics, andother applicationareas,\nthereby offering a unified set of tools for tackling diverse problems.\nBeyond end-to-end training, we are experiencing a transition from parametric statistical\ndescriptions to fullynonparametric models. When datais scarce, one needsto relyonsim-\nplifyingassumptionsaboutrealityinordertoobtainusefulmodels. Whendataisabundant,\nthese can be replaced by nonparametric models that better fit the data. To some extent, this\nmirrors the progress that physics experienced in the middle of the previous century with\nthe availability of computers. Rather than solving by hand parametric approximations of\nhow electrons behave, one can now resort to numerical simulations of the associated par-\ntial differential equations. This has led to much more accurate models, albeit often at the\nexpense of interpretation.\nAnother difference from previous work is the acceptance of suboptimal solutions, dealing\nwith nonconvex nonlinear optimization problems, and the willingness to try things before\nproving them. This new-found empiricism in dealing with statistical problems, combined\nwith a rapid influx of talent has led to rapid progress in the development of practical algo-\nrithms, albeit in many cases at the expense of modifying and re-inventing tools that existed\nfor decades.\nIntheend, thedeeplearningcommunitypridesitselfonsharingtoolsacrossacademicand\ncorporate boundaries, releasing many excellent libraries, statistical models, and trained\nnetworks as open source. It is in this spirit that the notebooks forming this book are freely\navailable for distribution and use. We have worked hard to lower the barriers of access for\n29 Summary\n43anyonewishingtolearnaboutdeeplearningandwehopethatourreaderswillbenefitfrom\nthis.\n1.8Summary\nMachine learning studies how computer systems can leverage experience (often data) to\nimprove performance at specific tasks. It combines ideas from statistics, data mining, and\noptimization. Often, it is used as a means of implementing AI solutions. As a class of\nmachine learning, representational learning focuses on how to automatically find the ap-\npropriate way to represent data. Considered as multi-level representation learning through\nlearning many layers of transformations, deep learning replaces not only the shallow mod-\nels at the end of traditional machinelearning pipelines, but also the labor-intensiveprocess\nof feature engineering. Much of the recent progress in deep learning has been triggered\nby an abundance of data arising from cheap sensors and Internet-scale applications, and\nby significant progress in computation, mostly through GPUs. Furthermore, the availabil-\nity of efficient deep learning frameworks has made design and implementation of whole\nsystem optimization significantly easier, and this is a key component in obtaining high\nperformance.\n1.9Exercises\n1.Which parts of code that you are currently writing could be \u201clearned\u201d, i.e., improved\nby learning and automatically determining design choices that are made in your code?\nDoes your code include heuristic design choices? What data might you need to learn\nthe desired behavior?\n2.Which problems that you encounter have many examples for their solution, yet no spe-\ncificwayforautomatingthem? Thesemaybeprimecandidatesforusingdeeplearning.\n3.Describe the relationships between algorithms, data, and computation. How do char-\nacteristics of the data and the current available computational resources influence the\nappropriateness of various algorithms?", "mimetype": "text/plain", "start_char_idx": 131060, "end_char_idx": 135970, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dc43f26d-c5dc-48c4-b73b-776e0c110b8d": {"__data__": {"id_": "dc43f26d-c5dc-48c4-b73b-776e0c110b8d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "94a2897e-06c3-4be4-a13a-b2a8b234fd9e", "node_type": "1", "metadata": {}, "hash": "afa49af4ae49d81f6bb1898e5012e95981b3938a5d7cbb89dd5a0d1e2df5ce44", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "35066ca7-4c6f-41f4-bb48-e280725af122", "node_type": "1", "metadata": {}, "hash": "626c63ee410fa97282091dfff0d3d83d9b147f20639a73c2817aac64c341acfd", "class_name": "RelatedNodeInfo"}}, "text": "Furthermore, the availabil-\nity of efficient deep learning frameworks has made design and implementation of whole\nsystem optimization significantly easier, and this is a key component in obtaining high\nperformance.\n1.9Exercises\n1.Which parts of code that you are currently writing could be \u201clearned\u201d, i.e., improved\nby learning and automatically determining design choices that are made in your code?\nDoes your code include heuristic design choices? What data might you need to learn\nthe desired behavior?\n2.Which problems that you encounter have many examples for their solution, yet no spe-\ncificwayforautomatingthem? Thesemaybeprimecandidatesforusingdeeplearning.\n3.Describe the relationships between algorithms, data, and computation. How do char-\nacteristics of the data and the current available computational resources influence the\nappropriateness of various algorithms?\n4.Name some settings where end-to-end training is not currently the default approach but\nwhere it might be useful.\nDiscussions43.\n2 Preliminaries\nTo prepare for your dive into deep learning, you will need a few survival skills: (i) tech-\nniques for storing and manipulating data; (ii) libraries for ingesting and preprocessing data\nfrom a variety of sources; (iii) knowledge of the basic linear algebraic operations that we\napply to high-dimensional data elements; (iv) just enough calculus to determine which di-\nrection to adjust each parameter in order to decrease the loss function; (v) the ability to\nautomatically compute derivatives so that you can forget much of the calculus you just\nlearned; (vi) some basic fluency in probability, our primary language for reasoning under\nuncertainty; and(vii)someaptitudeforfindinganswersintheofficialdocumentationwhen\nyou get stuck.\nInshort, thischapterprovidesarapidintroductiontothebasicsthatyouwillneedtofollow\nmostof the technical content in this book.\n2.1Data Manipulation\nIn order to get anything done, we need some way to store and manipulate data. Generally,\nthere are two important things we need to do with data: (i) acquire them; and (ii) process\nthem once they are inside the computer. There is no point in acquiring data without some\nway to store it, so to start, let\u2019s get our hands dirty with \ud835\udc5b-dimensional arrays, which we\nalsocalltensors. IfyoualreadyknowtheNumPyscientificcomputingpackage,thiswillbe\na breeze. For all modern deep learning frameworks, the tensor class (ndarray in MXNet,\nTensorin PyTorch and TensorFlow) resembles NumPy\u2019s ndarray , with a few killer fea-\ntures added. First, the tensor class supports automatic differentiation. Second, it leverages\nGPUs to accelerate numerical computation, whereas NumPy only runs on CPUs. These\nproperties make neural networks both easy to code and fast to run.\n2.1.1GettingStarted\nTo start, we import the PyTorch library. Note that the package name is torch.\nimport torch\nA tensor represents a (possibly multidimensional) array of numerical values. In the one-\ndimensionalcase, i.e., whenonlyoneaxisisneededforthedata, atensoriscalleda vector.\n30\n31 Data Manipulation\nWith two axes, a tensor is called a matrix. With\ud835\udc58 > 2axes, we drop the specialized names\nand just refer to the object as a \ud835\udc58th-ordertensor .\nPyTorch provides a variety of functions for creating new tensors prepopulated with values.\nForexample,byinvoking arange(n) ,wecancreateavectorofevenlyspacedvalues,start-\ning at 0 (included) and ending at n(not included). By default, the interval size is 1. Unless\notherwisespecified,newtensorsarestoredinmainmemoryanddesignatedforCPU-based\ncomputation.\nx=torch .arange( 12, dtype =torch .float32)\nx\ntensor([ 0.,1.,2.,3.,4.,5.,6.,7.,8.,9.,10.,11.])\nEach of these values is called an element of the tensor. The tensor xcontains 12 elements.\nWe can inspect the total number of elements in a tensor via its numelmethod.\nx.numel()\n12\nWecanaccessatensor\u2019s shape(thelengthalongeachaxis)byinspectingits shapeattribute.\nBecause we are dealing with a vector here, the shapecontains just a single element and is\nidentical to the size.\nx.shape\ntorch .Size([ 12])\nWecanchangetheshapeofatensorwithoutalteringitssizeorvalues,byinvoking reshape .", "mimetype": "text/plain", "start_char_idx": 135092, "end_char_idx": 139226, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "35066ca7-4c6f-41f4-bb48-e280725af122": {"__data__": {"id_": "35066ca7-4c6f-41f4-bb48-e280725af122", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "dc43f26d-c5dc-48c4-b73b-776e0c110b8d", "node_type": "1", "metadata": {}, "hash": "5721032b452ddc43b093afd03cae99bc1779ef2e2c114667547fec94602f9e65", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ec4fefb6-1e2b-4cf0-8874-1fee3189dceb", "node_type": "1", "metadata": {}, "hash": "adff759b790dc762b2f8fa8242fbd13ae911bb29f54d362063d42e399a1ba348", "class_name": "RelatedNodeInfo"}}, "text": "Unless\notherwisespecified,newtensorsarestoredinmainmemoryanddesignatedforCPU-based\ncomputation.\nx=torch .arange( 12, dtype =torch .float32)\nx\ntensor([ 0.,1.,2.,3.,4.,5.,6.,7.,8.,9.,10.,11.])\nEach of these values is called an element of the tensor. The tensor xcontains 12 elements.\nWe can inspect the total number of elements in a tensor via its numelmethod.\nx.numel()\n12\nWecanaccessatensor\u2019s shape(thelengthalongeachaxis)byinspectingits shapeattribute.\nBecause we are dealing with a vector here, the shapecontains just a single element and is\nidentical to the size.\nx.shape\ntorch .Size([ 12])\nWecanchangetheshapeofatensorwithoutalteringitssizeorvalues,byinvoking reshape .\nFor example, we can transform our vector xwhose shape is (12,) to a matrix Xwith shape\n(3,4). Thisnewtensorretainsallelementsbutreconfiguresthemintoamatrix. Noticethat\ntheelementsofourvectorarelaidoutonerowatatimeandthus x[3] == X[0, 3] .\nX=x.reshape( 3,4)\nX\ntensor([[ 0.,1.,2.,3.],\n[4.,5.,6.,7.],\n[8.,9.,10.,11.]])\nNote that specifying every shape component to reshape is redundant. Because we already\nknow our tensor\u2019s size, we can work out one component of the shape given the rest. For\nexample, given a tensor of size \ud835\udc5band target shape ( \u210e,\ud835\udc64), we know that \ud835\udc64=\ud835\udc5b\u009d\u210e. To\n32 Preliminaries\nautomaticallyinferonecomponentoftheshape,wecanplacea -1fortheshapecomponent\nthatshouldbeinferredautomatically. Inourcase, insteadofcalling x.reshape(3, 4) , we\ncould have equivalently called x.reshape(-1, 4) orx.reshape(3, -1) .\nPractitioners often need to work with tensors initialized to contain all 0s or 1s. We can\nconstruct a tensor with all elements set to 0 and a shape of (2, 3, 4) via the zerosfunc-\ntion.\ntorch .zeros(( 2,3,4))\ntensor([[[ 0.,0.,0.,0.],\n[0.,0.,0.,0.],\n[0.,0.,0.,0.]],\n[[0.,0.,0.,0.],\n[0.,0.,0.,0.],\n[0.,0.,0.,0.]]])\nSimilarly, we can create a tensor with all 1s by invoking ones.\ntorch .ones(( 2,3,4))\ntensor([[[ 1.,1.,1.,1.],\n[1.,1.,1.,1.],\n[1.,1.,1.,1.]],\n[[1.,1.,1.,1.],\n[1.,1.,1.,1.],\n[1.,1.,1.,1.]]])\nWe often wish to sample each element randomly (and independently) from a given prob-\nability distribution. For example, the parameters of neural networks are often initialized\nrandomly. The following snippet creates a tensor with elements drawn from a standard\nGaussian (normal) distribution with mean 0 and standard deviation 1.\ntorch .randn( 3,4)\ntensor([[ 0.1351 ,-0.9099 ,-0.2028 ,2.1937 ],\n[-0.3200 ,-0.7545 ,0.8086 ,-1.8730 ],\n[0.3929 ,0.4931 ,0.9114 ,-0.7072 ]])\nFinally, we can construct tensors by supplying the exact values for each element by sup-\nplying (possibly nested) Python list(s) containing numerical literals. Here, we construct a\nmatrix with a list of lists, where the outermost list corresponds to axis 0, and the inner list\ncorresponds to axis 1.\n33 Data Manipulation\ntorch .tensor([[ 2,1,4,3], [ 1,2,3,4], [ 4,3,2,1]])\ntensor([[ 2,1,4,3],\n[1,2,3,4],\n[4,3,2,1]])\n2.1.2Indexingand Slicing\nAswithPythonlists,wecanaccesstensorelementsbyindexing(startingwith0).", "mimetype": "text/plain", "start_char_idx": 138553, "end_char_idx": 141527, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ec4fefb6-1e2b-4cf0-8874-1fee3189dceb": {"__data__": {"id_": "ec4fefb6-1e2b-4cf0-8874-1fee3189dceb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "35066ca7-4c6f-41f4-bb48-e280725af122", "node_type": "1", "metadata": {}, "hash": "626c63ee410fa97282091dfff0d3d83d9b147f20639a73c2817aac64c341acfd", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f4debcd1-bd94-4084-b443-ded515ce04f3", "node_type": "1", "metadata": {}, "hash": "8170c90d8fb52945df35df42828d65f2553191acc9eac0dca2ee84c14127c4be", "class_name": "RelatedNodeInfo"}}, "text": "Here, we construct a\nmatrix with a list of lists, where the outermost list corresponds to axis 0, and the inner list\ncorresponds to axis 1.\n33 Data Manipulation\ntorch .tensor([[ 2,1,4,3], [ 1,2,3,4], [ 4,3,2,1]])\ntensor([[ 2,1,4,3],\n[1,2,3,4],\n[4,3,2,1]])\n2.1.2Indexingand Slicing\nAswithPythonlists,wecanaccesstensorelementsbyindexing(startingwith0). Toaccess\nanelementbasedonitspositionrelativetotheendofthelist,wecanusenegativeindexing.\nFinally, we can access whole ranges of indices via slicing (e.g., X[start:stop] ), where\nthe returned value includes the first index ( start)but not the last (stop). Finally, when\nonly one index (or slice) is specified for a \ud835\udc58th-order tensor, it is applied along axis 0. Thus,\nin the following code, [-1]selects the last row and [1:3]selects the second and third\nrows.\nX[-1], X[ 1:3]\n(tensor([ 8.,9.,10.,11.]),\ntensor([[ 4.,5.,6.,7.],\n[8.,9.,10.,11.]]))\nBeyondreadingthem,wecanalso writeelementsofamatrixbyspecifyingindices.\nX[1,2]=17\nX\ntensor([[ 0.,1.,2.,3.],\n[4.,5.,17.,7.],\n[8.,9.,10.,11.]])\nIf we want to assign multiple elements the same value, we apply the indexing on the left-\nhandsideoftheassignmentoperation. Forinstance, [:2, :] accessesthefirstandsecond\nrows, where :takes all the elements along axis 1 (column). While we discussed indexing\nformatrices,thisalsoworksforvectorsandfortensorsofmorethantwodimensions.\nX[:2, :] =12\nX\ntensor([[ 12.,12.,12.,12.],\n[12.,12.,12.,12.],\n[8.,9.,10.,11.]])\n34 Preliminaries\n2.1.3Operations\nNow that we know how to construct tensors and how to read from and write to their ele-\nments,wecanbegintomanipulatethemwithvariousmathematicaloperations. Amongthe\nmost useful of these are the elementwise operations. These apply a standard scalar opera-\ntion to each element of a tensor. For functions that take two tensors as inputs, elementwise\noperations apply some standard binary operator on each pair of corresponding elements.\nWe can create an elementwise function from any function that maps from a scalar to a\nscalar.\nIn mathematical notation, we denote such unaryscalar operators (taking one input) by the\nsignature\ud835\udc53:R!R. This just means that the function maps from any real number onto\nsome other real number. Most standard operators, including unary ones like \ud835\udc52\ud835\udc65, can be\napplied elementwise.\ntorch .exp(x)\ntensor([ 162754.7969 ,162754.7969 ,162754.7969 ,162754.7969 ,162754.7969 ,\n162754.7969 ,162754.7969 ,162754.7969 , 2980.9580 , 8103.0840 ,\n22026.4648 ,59874.1406 ])\nLikewise, we denote binaryscalar operators, which map pairs of real numbers to a (single)\nreal number via the signature \ud835\udc53:R,R!R. Given any two vectors uandvof the\nsame shape , and a binary operator \ud835\udc53, we can produce a vector c=\ud835\udc39\u00b9u,v\u00baby setting\n\ud835\udc50\ud835\udc56 \ud835\udc53\u00b9\ud835\udc62\ud835\udc56,\ud835\udc63\ud835\udc56\u00bafor all\ud835\udc56, where\ud835\udc50\ud835\udc56,\ud835\udc62\ud835\udc56, and\ud835\udc63\ud835\udc56are the\ud835\udc56thelements of vectors c,u, andv.\nHere, we produced the vector-valued \ud835\udc39:R\ud835\udc51,R\ud835\udc51!R\ud835\udc51byliftingthe scalar function to an\nelementwise vector operation. The common standard arithmetic operators for addition ( +),\nsubtraction( -),multiplication( *),division( /),andexponentiation( **)haveallbeen lifted\nto elementwise operations for identically-shaped tensors of arbitrary shape.", "mimetype": "text/plain", "start_char_idx": 141177, "end_char_idx": 144296, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f4debcd1-bd94-4084-b443-ded515ce04f3": {"__data__": {"id_": "f4debcd1-bd94-4084-b443-ded515ce04f3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ec4fefb6-1e2b-4cf0-8874-1fee3189dceb", "node_type": "1", "metadata": {}, "hash": "adff759b790dc762b2f8fa8242fbd13ae911bb29f54d362063d42e399a1ba348", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7fa36e60-dbdd-4379-b971-a0fded704532", "node_type": "1", "metadata": {}, "hash": "1e9ec069d049495ee3ab8ab9898c20a367c8b198909e21424cb1a47cc65c4a04", "class_name": "RelatedNodeInfo"}}, "text": "Given any two vectors uandvof the\nsame shape , and a binary operator \ud835\udc53, we can produce a vector c=\ud835\udc39\u00b9u,v\u00baby setting\n\ud835\udc50\ud835\udc56 \ud835\udc53\u00b9\ud835\udc62\ud835\udc56,\ud835\udc63\ud835\udc56\u00bafor all\ud835\udc56, where\ud835\udc50\ud835\udc56,\ud835\udc62\ud835\udc56, and\ud835\udc63\ud835\udc56are the\ud835\udc56thelements of vectors c,u, andv.\nHere, we produced the vector-valued \ud835\udc39:R\ud835\udc51,R\ud835\udc51!R\ud835\udc51byliftingthe scalar function to an\nelementwise vector operation. The common standard arithmetic operators for addition ( +),\nsubtraction( -),multiplication( *),division( /),andexponentiation( **)haveallbeen lifted\nto elementwise operations for identically-shaped tensors of arbitrary shape.\nx=torch .tensor([ 1.0,2,4,8])\ny=torch .tensor([ 2,2,2,2])\nx+y, x -y, x *y, x /y, x **y\n(tensor([ 3.,4.,6.,10.]),\ntensor([ -1.,0.,2.,6.]),\ntensor([ 2.,4.,8.,16.]),\ntensor([ 0.5000 ,1.0000 ,2.0000 ,4.0000 ]),\ntensor([ 1.,4.,16.,64.]))\nIn addition to elementwise computations, we can also perform linear algebraic operations,\nsuch as dot products and matrix multiplications. We will elaborate on these in Section\n2.3.\nWe can also concatenate multiple tensors, stacking them end-to-end to form a larger one.\nWejustneedtoprovidealistoftensorsandtellthesystemalongwhichaxistoconcatenate.\nThe example below shows what happens when we concatenate two matrices along rows\n35 Data Manipulation\n(axis 0) instead of columns (axis 1). We can see that the first output\u2019s axis-0 length ( 6) is\nthe sum of the two input tensors\u2019 axis-0 lengths ( 3\u00b83); while the second output\u2019s axis-1\nlength ( 8) is the sum of the two input tensors\u2019 axis-1 lengths ( 4\u00b84).\nX=torch .arange( 12, dtype =torch .float32) .reshape(( 3,4))\nY=torch .tensor([[ 2.0,1,4,3], [ 1,2,3,4], [ 4,3,2,1]])\ntorch .cat((X, Y), dim =0), torch .cat((X, Y), dim =1)\n(tensor([[ 0.,1.,2.,3.],\n[4.,5.,6.,7.],\n[8.,9.,10.,11.],\n[2.,1.,4.,3.],\n[1.,2.,3.,4.],\n[4.,3.,2.,1.]]),\ntensor([[ 0.,1.,2.,3.,2.,1.,4.,3.],\n[4.,5.,6.,7.,1.,2.,3.,4.],\n[8.,9.,10.,11.,4.,3.,2.,1.]]))\nSometimes, we wantto construct a binary tensor via logicalstatements . Take X == Yas an\nexample. Foreachposition i, j,ifX[i, j] andY[i, j] areequal,thenthecorresponding\nentry in the result takes value 1, otherwise it takes value 0.\nX==Y\ntensor([[ False ,True ,False ,True ],\n[False ,False ,False ,False ],\n[False ,False ,False ,False ]])\nSumming all the elements in the tensor yields a tensor with only one element.\nX.sum()\ntensor( 66.)\n2.1.4Broadcasting\nBy now, you know how to perform elementwise binary operations on two tensors of the\nsame shape. Under certain conditions, even when shapes differ, we can still perform ele-\nmentwisebinaryoperationsbyinvokingthe broadcastingmechanism . Broadcastingworks\naccording to the following two-step procedure: (i) expand one or both arrays by copying\nelementsalongaxeswithlength1sothatafterthistransformation, thetwotensorshavethe\nsame shape; (ii) perform an elementwise operation on the resulting arrays.\na=torch .arange( 3).reshape(( 3,1))\nb=torch .arange( 2).reshape(( 1,2))\na, b\n36 Preliminaries\n(tensor([[ 0],\n[1],\n[2]]),\ntensor([[ 0,1]]))\nSince aandbare3\u00021and 1\u00022matrices, respectively, their shapes do not match up.", "mimetype": "text/plain", "start_char_idx": 143766, "end_char_idx": 146775, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7fa36e60-dbdd-4379-b971-a0fded704532": {"__data__": {"id_": "7fa36e60-dbdd-4379-b971-a0fded704532", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f4debcd1-bd94-4084-b443-ded515ce04f3", "node_type": "1", "metadata": {}, "hash": "8170c90d8fb52945df35df42828d65f2553191acc9eac0dca2ee84c14127c4be", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3bb0d24c-efcf-470c-adf0-1e6ce405700e", "node_type": "1", "metadata": {}, "hash": "3999a47eba0cad5fc60f851e3aa46d937a2f678391bc57274554a58777d9a676", "class_name": "RelatedNodeInfo"}}, "text": "Under certain conditions, even when shapes differ, we can still perform ele-\nmentwisebinaryoperationsbyinvokingthe broadcastingmechanism . Broadcastingworks\naccording to the following two-step procedure: (i) expand one or both arrays by copying\nelementsalongaxeswithlength1sothatafterthistransformation, thetwotensorshavethe\nsame shape; (ii) perform an elementwise operation on the resulting arrays.\na=torch .arange( 3).reshape(( 3,1))\nb=torch .arange( 2).reshape(( 1,2))\na, b\n36 Preliminaries\n(tensor([[ 0],\n[1],\n[2]]),\ntensor([[ 0,1]]))\nSince aandbare3\u00021and 1\u00022matrices, respectively, their shapes do not match up.\nBroadcasting produces a larger 3\u00022matrix by replicating matrix aalong the columns and\nmatrix balong the rows before adding them elementwise.\na+b\ntensor([[ 0,1],\n[1,2],\n[2,3]])\n2.1.5SavingMemory\nRunning operations can cause new memory to be allocated to host results. For example, if\nwewrite Y = X + Y ,wedereferencethetensorthat Yusedtopointtoandinsteadpoint Yat\nthe newly allocated memory. We can demonstrate this issue with Python\u2019s id()function,\nwhich gives us the exact address of the referenced object in memory. Note that after we\nrunY = Y + X ,id(Y)points to a different location. That is because Python first evaluates\nY + X, allocating new memory for the result and then points Yto this new location in\nmemory.\nbefore =id(Y)\nY=Y+X\nid(Y) ==before\nFalse\nThis might be undesirable for two reasons. First, we do not want to run around allocat-\ning memory unnecessarily all the time. In machine learning, we often have hundreds of\nmegabytes of parameters and update all of them multiple times per second. Whenever\npossible, we want to perform these updates in place. Second, we might point at the same\nparameters from multiple variables. If we do not update in place, we must be careful to\nupdate all of these references, lest we spring a memory leak or inadvertently refer to stale\nparameters.\nFortunately, performing in-place operations is easy. We can assign the result of an oper-\nation to a previously allocated array Yby using slice notation: Y[:] = <expression> .\nTo illustrate this concept, we overwrite the values of tensor Z, after initializing it, using\nzeros_like , to have the same shape as Y.\n37 Data Manipulation\nZ=torch .zeros_like(Y)\nprint ('id(Z): ',id(Z))\nZ[:] =X+Y\nprint ('id(Z): ',id(Z))\nid(Z): 140381179266448\nid(Z): 140381179266448\nIf the value of Xis not reused in subsequent computations, we can also use X[:] = X + Y\norX += Yto reduce the memory overhead of the operation.\nbefore =id(X)\nX+=Y\nid(X) ==before\nTrue\n2.1.6Conversionto Other Python Objects\nConverting to a NumPy tensor ( ndarray ), or vice versa, is easy. The torch tensor and\nNumPy array will share their underlying memory, and changing one through an in-place\noperation will also change the other.\nA=X.numpy()\nB=torch .from_numpy(A)\ntype (A), type (B)\n(numpy .ndarray, torch .Tensor)\nTo convert a size-1 tensor to a Python scalar, we can invoke the itemfunction or Python\u2019s\nbuilt-in functions.\na=torch .tensor([ 3.5])\na, a .item(), float (a), int(a)\n(tensor([ 3.5000 ]), 3.5,3.5,3)\n2.1.7Summary\nThe tensor class is the main interface for storing and manipulating data in deep learning li-\nbraries. Tensorsprovideavarietyoffunctionalitiesincludingconstructionroutines; index-\ningandslicing;basicmathematicsoperations;broadcasting;memory-efficientassignment;\nand conversion to and from other Python objects.\n38 Preliminaries\n44\n45\n462.1.8Exercises\n1.Run the code in this section. Change the conditional statement X == YtoX < YorX >\nY, and then see what kind of tensor you can get.\n2.Replace the two tensors that operate by element in the broadcasting mechanism with\nother shapes, e.g., 3-dimensional tensors. Is the result the same as expected?\nDiscussions44.\n2.2Data Preprocessing\nSo far, we have been working with synthetic data that arrived in ready-made tensors.", "mimetype": "text/plain", "start_char_idx": 146159, "end_char_idx": 150033, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3bb0d24c-efcf-470c-adf0-1e6ce405700e": {"__data__": {"id_": "3bb0d24c-efcf-470c-adf0-1e6ce405700e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7fa36e60-dbdd-4379-b971-a0fded704532", "node_type": "1", "metadata": {}, "hash": "1e9ec069d049495ee3ab8ab9898c20a367c8b198909e21424cb1a47cc65c4a04", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9f2e6dee-6479-415e-aa75-334f636a70be", "node_type": "1", "metadata": {}, "hash": "a7cdc5cbcbdf250276d705e30d8c9451cf31a41c3a1cbe11025f0a99b6ffc44f", "class_name": "RelatedNodeInfo"}}, "text": "Tensorsprovideavarietyoffunctionalitiesincludingconstructionroutines; index-\ningandslicing;basicmathematicsoperations;broadcasting;memory-efficientassignment;\nand conversion to and from other Python objects.\n38 Preliminaries\n44\n45\n462.1.8Exercises\n1.Run the code in this section. Change the conditional statement X == YtoX < YorX >\nY, and then see what kind of tensor you can get.\n2.Replace the two tensors that operate by element in the broadcasting mechanism with\nother shapes, e.g., 3-dimensional tensors. Is the result the same as expected?\nDiscussions44.\n2.2Data Preprocessing\nSo far, we have been working with synthetic data that arrived in ready-made tensors. How-\never, to apply deep learning in the wild we must extract messy data stored in arbitrary\nformats, andpreprocessittosuitourneeds. Fortunately,the pandaslibrary45candomuch\nof the heavy lifting. This section, while no substitute for a proper pandastutorial46, will\ngive you a crash course on some of the most common routines.\n2.2.1Readingthe Dataset\nComma-separatedvalues(CSV)filesareubiquitousforthestoringoftabular(spreadsheet-\nlike) data. In them, each line corresponds to one record and consists of several (comma-\nseparated)fields,e.g.,\u201cAlbertEinstein,March141879,Ulm,Federalpolytechnicschool,field\nof gravitational physics\u201d. To demonstrate how to load CSV files with pandas, we create a\nCSV file below ../data/house_tiny.csv . This file represents a dataset of homes, where\neach row corresponds to a distinct home and the columns correspond to the number of\nrooms ( NumRooms ), the roof type ( RoofType ), and the price ( Price).\nimport os\nos.makedirs(os .path .join( '..','data '), exist_ok =True )\ndata_file =os.path .join( '..','data ','house_tiny.csv ')\nwith open (data_file, 'w')asf:\nf.write( '''NumRooms,RoofType,Price\nNA,NA,127500\n2,NA,106000\n4,Slate,178100\nNA,NA,140000 ''')\nNow let\u2019s import pandasand load the dataset with read_csv .\nimport pandas aspd\ndata =pd.read_csv(data_file)\nprint (data)\n39 Data Preprocessing\nNumRooms RoofType Price\n0 NaN NaN 127500\n1 2.0 NaN 106000\n2 4.0 Slate 178100\n3 NaN NaN 140000\n2.2.2Data Preparation\nIn supervised learning, we train models to predict a designated targetvalue, given some\nset ofinputvalues. Our first step in processing the dataset is to separate out columns cor-\nresponding to input versus target values. We can select columns either by name or via\ninteger-location based indexing ( iloc).\nYou might have noticed that pandasreplaced all CSV entries with value NAwith a spe-\ncialNaN(not a number ) value. This can also happen whenever an entry is empty, e.g.,\n\u201c3\u201e,270000\u201d. These are called missingvalues and they are the \u201cbed bugs\u201d of data science,\na persistent menace that you will confront throughout your career. Depending upon the\ncontext, missing values might be handled either via imputation ordeletion. Imputation re-\nplaces missing values with estimates of their values while deletion simply discards either\nthose rows or those columns that contain missing values.\nHerearesomecommonimputationheuristics. Forcategoricalinputfields,wecantreat NaN\nasacategory. Sincethe RoofType columntakesvalues SlateandNaN,pandascanconvert\nthiscolumnintotwocolumns RoofType_Slate andRoofType_nan . Arowwhoserooftype\nisSlatewill set values of RoofType_Slate andRoofType_nan to 1 and 0, respectively.\nThe converse holds for a row with a missing RoofType value.\ninputs, targets =data .iloc[:, 0:2], data .iloc[:, 2]\ninputs =pd.get_dummies(inputs, dummy_na =True )\nprint (inputs)\nNumRooms RoofType_Slate RoofType_nan\n0 NaN False True\n1 2.0 False True\n2 4.0 True False\n3 NaN False True\nFor missing numerical values, one common heuristic is to replace the NaNentries with the\nmean value of the corresponding column.", "mimetype": "text/plain", "start_char_idx": 149367, "end_char_idx": 153099, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9f2e6dee-6479-415e-aa75-334f636a70be": {"__data__": {"id_": "9f2e6dee-6479-415e-aa75-334f636a70be", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3bb0d24c-efcf-470c-adf0-1e6ce405700e", "node_type": "1", "metadata": {}, "hash": "3999a47eba0cad5fc60f851e3aa46d937a2f678391bc57274554a58777d9a676", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3827d73a-050e-48c8-8d6d-769c4eb3d3e2", "node_type": "1", "metadata": {}, "hash": "14ed7c299676f20339e4ebf1b0042b7e8e4ba13b4ca2177c6212da80b5c0c2c9", "class_name": "RelatedNodeInfo"}}, "text": "Forcategoricalinputfields,wecantreat NaN\nasacategory. Sincethe RoofType columntakesvalues SlateandNaN,pandascanconvert\nthiscolumnintotwocolumns RoofType_Slate andRoofType_nan . Arowwhoserooftype\nisSlatewill set values of RoofType_Slate andRoofType_nan to 1 and 0, respectively.\nThe converse holds for a row with a missing RoofType value.\ninputs, targets =data .iloc[:, 0:2], data .iloc[:, 2]\ninputs =pd.get_dummies(inputs, dummy_na =True )\nprint (inputs)\nNumRooms RoofType_Slate RoofType_nan\n0 NaN False True\n1 2.0 False True\n2 4.0 True False\n3 NaN False True\nFor missing numerical values, one common heuristic is to replace the NaNentries with the\nmean value of the corresponding column.\ninputs =inputs .fillna(inputs .mean())\nprint (inputs)\nNumRooms RoofType_Slate RoofType_nan\n0 3.0 False True\n1 2.0 False True\n(continues on next page)\n40 Preliminaries\n47\n48\n49\n50\n51(continued from previous page)\n2 4.0 True False\n3 3.0 False True\n2.2.3Conversionto the TensorFormat\nNow that all the entries in inputsandtargets are numerical, we can load them into a\ntensor (recall Section 2.1 ).\nimport torch\nX=torch .tensor(inputs .to_numpy(dtype =float ))\ny=torch .tensor(targets .to_numpy(dtype =float ))\nX, y\n(tensor([[ 3.,0.,1.],\n[2.,0.,1.],\n[4.,1.,0.],\n[3.,0.,1.]], dtype =torch .float64),\ntensor([ 127500. ,106000. ,178100. ,140000. ], dtype =torch .float64))\n2.2.4Discussion\nYou now know how to partition data columns, impute missing variables, and load pan-\ndasdata into tensors. In Section 5.7 , you will pick up some more data processing skills.\nWhile this crash course kept things simple, data processing can get hairy. For example,\nrather than arriving in a single CSV file, our dataset might be spread across multiple files\nextractedfromarelationaldatabase. Forinstance, inane-commerceapplication, customer\naddressesmightliveinonetableandpurchasedatainanother. Moreover,practitionersface\nmyriaddatatypesbeyondcategoricalandnumeric, forexample, textstrings, images, audio\ndata, and point clouds. Oftentimes, advanced tools and efficient algorithms are required\nin order to prevent data processing from becoming the biggest bottleneck in the machine\nlearning pipeline. These problems will arise when we get to computer vision and natural\nlanguageprocessing. Finally,wemustpayattentiontodataquality. Real-worlddatasetsare\noften plagued by outliers, faulty measurements from sensors, and recording errors, which\nmust be addressed before feeding the data into any model. Data visualization tools such as\nseaborn47,Bokeh48,ormatplotlib49canhelpyoutomanuallyinspectthedataanddevelop\nintuitions about the type of problems you may need to address.\n2.2.5Exercises\n1.Try loading datasets, e.g., Abalone from the UCI Machine Learning Repository50and\ninspect their properties. What fraction of them has missing values? What fraction of\nthe variables is numerical, categorical, or text?\n2.Try indexing and selecting data columns by name rather than by column number. The\npandas documentation on indexing51has further details on how to do this.\n41 Linear Algebra\n52\n53\n543.How large a dataset do you think you could load this way? What might be the limita-\ntions? Hint: consider the time to read the data, representation, processing, and memory\nfootprint. Try this out on your laptop. What happens if you try it out on a server?\n4.How would you deal with data that has a very large number of categories? What if the\ncategory labels are all unique? Should you include the latter?\n5.What alternatives to pandas can you think of? How about loading NumPy tensors from\na file52? Check out Pillow53, the Python Imaging Library.\nDiscussions54.\n2.3LinearAlgebra\nBy now, we can load datasets into tensors and manipulate these tensors with basic math-\nematical operations. To start building sophisticated models, we will also need a few tools\nfromlinearalgebra. Thissectionoffersagentleintroductiontothemostessentialconcepts,\nstarting from scalar arithmetic and ramping up to matrix multiplication.", "mimetype": "text/plain", "start_char_idx": 152411, "end_char_idx": 156386, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3827d73a-050e-48c8-8d6d-769c4eb3d3e2": {"__data__": {"id_": "3827d73a-050e-48c8-8d6d-769c4eb3d3e2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9f2e6dee-6479-415e-aa75-334f636a70be", "node_type": "1", "metadata": {}, "hash": "a7cdc5cbcbdf250276d705e30d8c9451cf31a41c3a1cbe11025f0a99b6ffc44f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3bc53aec-8718-4602-8867-c0da06fa9983", "node_type": "1", "metadata": {}, "hash": "f114762da2f7fc59d9df03640da8cd0f08b8cd918bb6fb5150537f165a370530", "class_name": "RelatedNodeInfo"}}, "text": "What might be the limita-\ntions? Hint: consider the time to read the data, representation, processing, and memory\nfootprint. Try this out on your laptop. What happens if you try it out on a server?\n4.How would you deal with data that has a very large number of categories? What if the\ncategory labels are all unique? Should you include the latter?\n5.What alternatives to pandas can you think of? How about loading NumPy tensors from\na file52? Check out Pillow53, the Python Imaging Library.\nDiscussions54.\n2.3LinearAlgebra\nBy now, we can load datasets into tensors and manipulate these tensors with basic math-\nematical operations. To start building sophisticated models, we will also need a few tools\nfromlinearalgebra. Thissectionoffersagentleintroductiontothemostessentialconcepts,\nstarting from scalar arithmetic and ramping up to matrix multiplication.\nimport torch\n2.3.1Scalars\nMost everyday mathematics consists of manipulating numbers one at a time. Formally, we\ncall these values scalars. For example, the temperature in Palo Alto is a balmy 72degrees\nFahrenheit. If you wanted to convert the temperature to Celsius you would evaluate the\nexpression\ud835\udc50=5\n9\u00b9\ud835\udc53\u000032\u00ba, setting\ud835\udc53to72. In this equation, the values 5,9, and 32are\nconstant scalars. The variables \ud835\udc50and\ud835\udc53in general represent unknown scalars.\nWe denote scalars by ordinary lower-cased letters (e.g., \ud835\udc65,\ud835\udc66, and\ud835\udc67) and the space of all\n(continuous) real-valued scalars by R. For expedience, we will skip past rigorous defini-\ntions ofspaces: just remember that the expression \ud835\udc652Ris a formal way to say that \ud835\udc65is\na real-valued scalar. The symbol 2(pronounced \u201cin\u201d) denotes membership in a set. For\nexample,\ud835\udc65,\ud835\udc662f0,1gindicates that \ud835\udc65and\ud835\udc66are variables that can only take values 0or\n1.\nScalars are implemented as tensors that contain only one element. Below, we assign two\nscalars and perform the familiar addition, multiplication, division, and exponentiation op-\nerations.\nx=torch .tensor( 3.0)\ny=torch .tensor( 2.0)\nx+y, x *y, x /y, x **y\n42 Preliminaries\n(tensor( 5.), tensor( 6.), tensor( 1.5000 ), tensor( 9.))\n2.3.2Vectors\nFor current purposes, you can think of a vector as a fixed-length array of scalars. As with\ntheir code counterparts, we call these scalars the elements of the vector (synonyms include\nentriesandcomponents ). When vectors represent examples from real-world datasets, their\nvalues hold some real-world significance. For example, if we were training a model to\npredicttheriskofaloandefaulting, wemightassociateeachapplicantwithavectorwhose\ncomponentscorrespondtoquantitiesliketheirincome,lengthofemployment,ornumberof\nprevious defaults. If we were studying the risk of heart attack, each vector might represent\na patient and its components might correspond to their most recent vital signs, cholesterol\nlevels, minutes of exercise per day, etc. We denote vectors by bold lowercase letters, (e.g.,\nx,y, andz).\nVectors are implemented as 1st-order tensors. In general, such tensors can have arbitrary\nlengths, subject to memory limitations. Caution: in Python, as in most programming lan-\nguages, vector indices start at 0, also known as zero-based indexing , whereas in linear\nalgebra subscripts begin at 1(one-based indexing).\nx=torch .arange( 3)\nx\ntensor([ 0,1,2])\nWe can refer to an element of a vector by using a subscript. For example, \ud835\udc652denotes the\nsecondelementof x. Since\ud835\udc652isascalar,wedonotboldit. Bydefault,wevisualizevectors\nby stacking their elements vertically.\nx=2666664\ud835\udc651\n...\n\ud835\udc65\ud835\udc5b3777775, (2.3.1)\nHere\ud835\udc651,...,\ud835\udc65\ud835\udc5bare elements of the vector. Later on, we will distinguish between such\ncolumn vectors androw vectors whose elements are stacked horizontally. Recall that we\naccess a tensor\u2019s elements via indexing.", "mimetype": "text/plain", "start_char_idx": 155529, "end_char_idx": 159225, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3bc53aec-8718-4602-8867-c0da06fa9983": {"__data__": {"id_": "3bc53aec-8718-4602-8867-c0da06fa9983", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3827d73a-050e-48c8-8d6d-769c4eb3d3e2", "node_type": "1", "metadata": {}, "hash": "14ed7c299676f20339e4ebf1b0042b7e8e4ba13b4ca2177c6212da80b5c0c2c9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3a4de07a-ccaa-45f7-aa03-418c440a33db", "node_type": "1", "metadata": {}, "hash": "11b2fe939760b1aae78d1c83d134d44fe934a170d6b8ec87cdf4ad0a2657c119", "class_name": "RelatedNodeInfo"}}, "text": "x=torch .arange( 3)\nx\ntensor([ 0,1,2])\nWe can refer to an element of a vector by using a subscript. For example, \ud835\udc652denotes the\nsecondelementof x. Since\ud835\udc652isascalar,wedonotboldit. Bydefault,wevisualizevectors\nby stacking their elements vertically.\nx=2666664\ud835\udc651\n...\n\ud835\udc65\ud835\udc5b3777775, (2.3.1)\nHere\ud835\udc651,...,\ud835\udc65\ud835\udc5bare elements of the vector. Later on, we will distinguish between such\ncolumn vectors androw vectors whose elements are stacked horizontally. Recall that we\naccess a tensor\u2019s elements via indexing.\nx[2]\ntensor( 2)\nTo indicate that a vector contains \ud835\udc5belements, we write x2R\ud835\udc5b. Formally, we call \ud835\udc5bthe\ndimensionality ofthevector. Incode,thiscorrespondstothetensor\u2019slength,accessiblevia\nPython\u2019s built-in lenfunction.\n43 Linear Algebra\nlen(x)\n3\nWe can also access the length via the shapeattribute. The shape is a tuple that indicates\na tensor\u2019s length along each axis. Tensors with just one axis have shapes with just one\nelement.\nx.shape\ntorch .Size([ 3])\nOftentimes,theword\u201cdimension\u201dgetsoverloadedtomeanboththenumberofaxesandthe\nlength along a particular axis. To avoid this confusion, we use orderto refer to the number\nof axes and dimensionality exclusively to refer to the number of components.\n2.3.3Matrices\nJustasscalarsare 0th-ordertensorsandvectorsare 1st-ordertensors,matricesare 2nd-order\ntensors. Wedenotematricesbyboldcapitalletters(e.g., X,Y, andZ), andrepresentthem\nin code by tensors with two axes. The expression A2R\ud835\udc5a\u0002\ud835\udc5bindicates that a matrix A\ncontains\ud835\udc5a\u0002\ud835\udc5breal-valued scalars, arranged as \ud835\udc5arows and\ud835\udc5bcolumns. When \ud835\udc5a=\ud835\udc5b, we\nsay that a matrix is square. Visually, we can illustrate any matrix as a table. To refer to an\nindividualelement,wesubscriptboththerowandcolumnindices,e.g., \ud835\udc4e\ud835\udc56\ud835\udc57isthevaluethat\nbelongs to A\u2019s\ud835\udc56throw and\ud835\udc57thcolumn:\nA=266666664\ud835\udc4e11\ud835\udc4e12\u0001\u0001\u0001\ud835\udc4e1\ud835\udc5b\n\ud835\udc4e21\ud835\udc4e22\u0001\u0001\u0001\ud835\udc4e2\ud835\udc5b\n............\n\ud835\udc4e\ud835\udc5a1\ud835\udc4e\ud835\udc5a2\u0001\u0001\u0001\ud835\udc4e\ud835\udc5a\ud835\udc5b377777775. (2.3.2)\nIn code, we represent a matrix A2R\ud835\udc5a\u0002\ud835\udc5bby a 2nd-order tensor with shape ( \ud835\udc5a,\ud835\udc5b). We can\nconvert any appropriately sized \ud835\udc5a\u0002\ud835\udc5btensor into an \ud835\udc5a\u0002\ud835\udc5bmatrix by passing the desired\nshape to reshape :\nA=torch .arange( 6).reshape( 3,2)\nA\ntensor([[ 0,1],\n[2,3],\n[4,5]])\nSometimes we want to flip the axes. When we exchange a matrix\u2019s rows and columns, the\nresult is called its transpose . Formally, we signify a matrix A\u2019s transpose by A>and if\n44 Preliminaries\nB=A>, then\ud835\udc4f\ud835\udc56\ud835\udc57=\ud835\udc4e\ud835\udc57\ud835\udc56for all\ud835\udc56and\ud835\udc57. Thus, the transpose of an \ud835\udc5a\u0002\ud835\udc5bmatrix is an\ud835\udc5b\u0002\ud835\udc5a\nmatrix:\nA>=266666664\ud835\udc4e11\ud835\udc4e21... \ud835\udc4e\ud835\udc5a1\n\ud835\udc4e12\ud835\udc4e22... \ud835\udc4e\ud835\udc5a2\n............\n\ud835\udc4e1\ud835\udc5b\ud835\udc4e2\ud835\udc5b... \ud835\udc4e\ud835\udc5a\ud835\udc5b377777775. (2.3.3)\nIn code, we can access any matrix\u2019s transpose as follows:\nA.T\ntensor([[ 0,2,4],\n[1,3,5]])\nSymmetricmatricesarethesubsetofsquarematricesthatareequaltotheirowntransposes:\nA=A>.", "mimetype": "text/plain", "start_char_idx": 158734, "end_char_idx": 161343, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3a4de07a-ccaa-45f7-aa03-418c440a33db": {"__data__": {"id_": "3a4de07a-ccaa-45f7-aa03-418c440a33db", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3bc53aec-8718-4602-8867-c0da06fa9983", "node_type": "1", "metadata": {}, "hash": "f114762da2f7fc59d9df03640da8cd0f08b8cd918bb6fb5150537f165a370530", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f2988966-9c4c-4f36-9432-b96b682fe6f8", "node_type": "1", "metadata": {}, "hash": "b45ed1ba793d65fb487083d675fde12f34ed18cfbe465829256398f4c70c14bb", "class_name": "RelatedNodeInfo"}}, "text": "Thus, the transpose of an \ud835\udc5a\u0002\ud835\udc5bmatrix is an\ud835\udc5b\u0002\ud835\udc5a\nmatrix:\nA>=266666664\ud835\udc4e11\ud835\udc4e21... \ud835\udc4e\ud835\udc5a1\n\ud835\udc4e12\ud835\udc4e22... \ud835\udc4e\ud835\udc5a2\n............\n\ud835\udc4e1\ud835\udc5b\ud835\udc4e2\ud835\udc5b... \ud835\udc4e\ud835\udc5a\ud835\udc5b377777775. (2.3.3)\nIn code, we can access any matrix\u2019s transpose as follows:\nA.T\ntensor([[ 0,2,4],\n[1,3,5]])\nSymmetricmatricesarethesubsetofsquarematricesthatareequaltotheirowntransposes:\nA=A>. The following matrix is symmetric:\nA=torch .tensor([[ 1,2,3], [ 2,0,4], [ 3,4,5]])\nA==A.T\ntensor([[ True ,True ,True ],\n[True ,True ,True ],\n[True ,True ,True ]])\nMatrices are useful for representing datasets. Typically, rows correspond to individual\nrecords and columns correspond to distinct attributes.\n2.3.4Tensors\nWhile you can go far in your machine learning journey with only scalars, vectors, and\nmatrices, eventually you may need to work with higher-order tensors. Tensors give us\na generic way of describing extensions to \ud835\udc5bth-order arrays. We call software objects of\nthetensor class \u201ctensors\u201d precisely because they too can have arbitrary numbers of axes.\nWhile it may be confusing to use the word tensorfor both the mathematical object and its\nrealization in code, our meaning should usually be clear from context. We denote general\ntensors by capital letters with a special font face (e.g., X,Y, andZ) and their indexing\nmechanism (e.g., \ud835\udc65\ud835\udc56\ud835\udc57\ud835\udc58and\u00bbX\u00bc1,2\ud835\udc56\u00001,3) follows naturally from that of matrices.\nTensors will become more important when we start working with images. Each image\narrives as a 3rd-order tensor with axes corresponding to the height, width, and channel. At\neachspatiallocation,theintensitiesofeachcolor(red,green,andblue)arestackedalongthe\nchannel. Furthermore, a collection of images is represented in code by a 4th-order tensor,\nwheredistinctimagesareindexedalongthefirstaxis. Higher-ordertensorsareconstructed,\nas were vectors and matrices, by growing the number of shape components.\n45 Linear Algebra\ntorch .arange( 24).reshape( 2,3,4)\ntensor([[[ 0,1,2,3],\n[4,5,6,7],\n[8,9,10,11]],\n[[12,13,14,15],\n[16,17,18,19],\n[20,21,22,23]]])\n2.3.5BasicPropertiesof Tensor Arithmetic\nScalars,vectors,matrices,andhigher-ordertensorsallhavesomehandyproperties. Forex-\nample,elementwiseoperationsproduceoutputsthathavethesameshapeastheiroperands.\nA=torch .arange( 6, dtype =torch .float32) .reshape( 2,3)\nB=A.clone() # Assign a copy of A to B by allocating new memory\nA, A +B\n(tensor([[ 0.,1.,2.],\n[3.,4.,5.]]),\ntensor([[ 0.,2.,4.],\n[6.,8.,10.]]))\nThe elementwise product of two matrices is called their Hadamard product (denoted\f).\nWecanspellouttheentriesoftheHadamardproductoftwomatrices A,B2R\ud835\udc5a\u0002\ud835\udc5b:\nA\fB=266666664\ud835\udc4e11\ud835\udc4f11\ud835\udc4e12\ud835\udc4f12... \ud835\udc4e 1\ud835\udc5b\ud835\udc4f1\ud835\udc5b\n\ud835\udc4e21\ud835\udc4f21\ud835\udc4e22\ud835\udc4f22... \ud835\udc4e 2\ud835\udc5b\ud835\udc4f2\ud835\udc5b\n............\n\ud835\udc4e\ud835\udc5a1\ud835\udc4f\ud835\udc5a1\ud835\udc4e\ud835\udc5a2\ud835\udc4f\ud835\udc5a2... \ud835\udc4e\ud835\udc5a\ud835\udc5b\ud835\udc4f\ud835\udc5a\ud835\udc5b377777775. (2.3.4)\nA*B\ntensor([[ 0.,1.,4.],\n[9.,16.,25.]])\nAdding or multiplying a scalar and a tensor produces a result with the same shape as\nthe original tensor. Here, each element of the tensor is added to (or multiplied by) the\nscalar.", "mimetype": "text/plain", "start_char_idx": 161031, "end_char_idx": 163896, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f2988966-9c4c-4f36-9432-b96b682fe6f8": {"__data__": {"id_": "f2988966-9c4c-4f36-9432-b96b682fe6f8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3a4de07a-ccaa-45f7-aa03-418c440a33db", "node_type": "1", "metadata": {}, "hash": "11b2fe939760b1aae78d1c83d134d44fe934a170d6b8ec87cdf4ad0a2657c119", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ae7b1e93-c6fb-43f4-b3ba-a6c49b57a605", "node_type": "1", "metadata": {}, "hash": "5d8abe219a6cc5e2653dc0bf952f39f6464d94438d8a39db00518483fa56ccab", "class_name": "RelatedNodeInfo"}}, "text": "(2.3.4)\nA*B\ntensor([[ 0.,1.,4.],\n[9.,16.,25.]])\nAdding or multiplying a scalar and a tensor produces a result with the same shape as\nthe original tensor. Here, each element of the tensor is added to (or multiplied by) the\nscalar.\na=2\nX=torch .arange( 24).reshape( 2,3,4)\na+X, (a *X).shape\n46 Preliminaries\n(tensor([[[ 2,3,4,5],\n[6,7,8,9],\n[10,11,12,13]],\n[[14,15,16,17],\n[18,19,20,21],\n[22,23,24,25]]]),\ntorch .Size([ 2,3,4]))\n2.3.6Reduction\nOften, we wish to calculate the sum of a tensor\u2019s elements. To express the sum of the\nelementsinavector xoflength\ud835\udc5b,wewrite\u00cd\ud835\udc5b\n\ud835\udc56=1\ud835\udc65\ud835\udc56. Thereisasimplefunctionforit:\nx=torch .arange( 3, dtype =torch .float32)\nx, x .sum()\n(tensor([ 0.,1.,2.]), tensor( 3.))\nTo express sums over the elements of tensors of arbitrary shape, we simply sum over all\nits axes. For example, the sum of the elements of an \ud835\udc5a\u0002\ud835\udc5bmatrix Acould be written\u00cd\ud835\udc5a\n\ud835\udc56=1\u00cd\ud835\udc5b\n\ud835\udc57=1\ud835\udc4e\ud835\udc56\ud835\udc57.\nA.shape, A .sum()\n(torch .Size([ 2,3]), tensor( 15.))\nBy default, invoking the sum function reduces a tensor along all of its axes, eventually\nproducing a scalar. Our libraries also allow us to specify the axes along which the tensor\nshould be reduced. To sum over all elements along the rows (axis 0), we specify axis=0in\nsum. Since the input matrix reduces along axis 0 to generate the output vector, this axis is\nmissing from the shape of the output.\nA.shape, A .sum(axis =0).shape\n(torch .Size([ 2,3]), torch .Size([ 3]))\nSpecifying axis=1will reduce the column dimension (axis 1) by summing up elements of\nall the columns.\nA.shape, A .sum(axis =1).shape\n(torch .Size([ 2,3]), torch .Size([ 2]))\n47 Linear Algebra\nReducing a matrix along both rows and columns via summation is equivalent to summing\nup all the elements of the matrix.\nA.sum(axis =[0,1])==A.sum() # Same as A.sum()\ntensor( True )\nA related quantity is the mean, also called the average. We calculate the mean by dividing\nthe sum by the total number of elements. Because computing the mean is so common, it\ngets a dedicated library function that works analogously to sum.\nA.mean(), A .sum() /A.numel()\n(tensor( 2.5000 ), tensor( 2.5000 ))\nLikewise, the function for calculating the mean can also reduce a tensor along specific\naxes.\nA.mean(axis =0), A .sum(axis =0)/A.shape[ 0]\n(tensor([ 1.5000 ,2.5000 ,3.5000 ]), tensor([ 1.5000 ,2.5000 ,3.5000 ]))\n2.3.7Non-ReductionSum\nSometimes it can be useful to keep the number of axesunchanged when invoking the func-\ntion for calculating the sum or mean. This matters when we want to use the broadcast\nmechanism.\nsum_A =A.sum(axis =1, keepdims =True )\nsum_A, sum_A .shape\n(tensor([[ 3.],\n[12.]]),\ntorch .Size([ 2,1]))\nFor instance, since sum_Akeeps its two axes after summing each row, we can divide Aby\nsum_Awith broadcasting to create a matrix where each row sums up to 1.\nA/sum_A\ntensor([[ 0.0000 ,0.3333 ,0.6667 ],\n[0.2500 ,0.3333 ,0.4167 ]])\n48 Preliminaries\nIf we want to calculate the cumulative sum of elements of Aalong some axis, say axis=0\n(row by row), we can call the cumsumfunction. By design, this function does not reduce\nthe input tensor along any axis.\nA.cumsum(axis =0)\ntensor([[ 0.,1.,2.],\n[3.,5.,7.]])", "mimetype": "text/plain", "start_char_idx": 163667, "end_char_idx": 166778, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ae7b1e93-c6fb-43f4-b3ba-a6c49b57a605": {"__data__": {"id_": "ae7b1e93-c6fb-43f4-b3ba-a6c49b57a605", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f2988966-9c4c-4f36-9432-b96b682fe6f8", "node_type": "1", "metadata": {}, "hash": "b45ed1ba793d65fb487083d675fde12f34ed18cfbe465829256398f4c70c14bb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "124b1e89-33e5-4d81-95d0-0513f3d50fbb", "node_type": "1", "metadata": {}, "hash": "53b572cee9d57841c5ea697eba185089881b1209eecb9ced6ffc681d2319f8e0", "class_name": "RelatedNodeInfo"}}, "text": "],\n[12.]]),\ntorch .Size([ 2,1]))\nFor instance, since sum_Akeeps its two axes after summing each row, we can divide Aby\nsum_Awith broadcasting to create a matrix where each row sums up to 1.\nA/sum_A\ntensor([[ 0.0000 ,0.3333 ,0.6667 ],\n[0.2500 ,0.3333 ,0.4167 ]])\n48 Preliminaries\nIf we want to calculate the cumulative sum of elements of Aalong some axis, say axis=0\n(row by row), we can call the cumsumfunction. By design, this function does not reduce\nthe input tensor along any axis.\nA.cumsum(axis =0)\ntensor([[ 0.,1.,2.],\n[3.,5.,7.]])\n2.3.8DotProducts\nSofar,wehaveonlyperformedelementwiseoperations,sums,andaverages. Andifthiswas\nallwecoulddo,linearalgebrawouldnotdeserveitsownsection. Fortunately,thisiswhere\nthings get more interesting. One of the most fundamental operations is the dot product.\nGiven two vectors x,y2R\ud835\udc51, theirdotproduct x>y(also known as innerproduct ,hx,yi)\nis a sum over the products of the elements at the same position: x>y=\u00cd\ud835\udc51\n\ud835\udc56=1\ud835\udc65\ud835\udc56\ud835\udc66\ud835\udc56.\ny=torch .ones( 3, dtype =torch .float32)\nx, y, torch .dot(x, y)\n(tensor([ 0.,1.,2.]), tensor([ 1.,1.,1.]), tensor( 3.))\nEquivalently,wecancalculatethedotproductoftwovectorsbyperforminganelementwise\nmultiplication followed by a sum:\ntorch .sum(x *y)\ntensor( 3.)\nDot products are useful in a wide range of contexts. For example, given some set of val-\nues, denoted by a vector x2R\ud835\udc5b, and a set of weights, denoted by w2R\ud835\udc5b, the weighted\nsum of the values in xaccording to the weights wcould be expressed as the dot product\nx>w. When the weights are nonnegative and sum to 1, i.e.,\u0000\u00cd\ud835\udc5b\n\ud835\udc56=1\ud835\udc64\ud835\udc56=1\u0001, the dot prod-\nuct expresses a weighted average . After normalizing two vectors to have unit length, the\ndot products express the cosine of the angle between them. Later in this section, we will\nformally introduce this notion of length.\n2.3.9Matrix\u2013VectorProducts\nNow that we know how to calculate dot products, we can begin to understand the product\nbetween an\ud835\udc5a\u0002\ud835\udc5bmatrix Aand an\ud835\udc5b-dimensional vector x. To start off, we visualize our\n49 Linear Algebra\nmatrix in terms of its row vectors\nA=266666664a>\n1\na>\n2...\na>\n\ud835\udc5a377777775, (2.3.5)\nwhere each a>\n\ud835\udc562R\ud835\udc5bis a row vector representing the \ud835\udc56throw of the matrix A.\nThe matrix\u2013vector product Axis simply a column vector of length \ud835\udc5a, whose\ud835\udc56thelement\nis the dot product a>\n\ud835\udc56x:\nAx=266666664a>\n1\na>\n2...\na>\n\ud835\udc5a377777775x=266666664a>\n1x\na>\n2x\n...\na>\n\ud835\udc5ax377777775. (2.3.6)\nWe can think of multiplication with a matrix A2R\ud835\udc5a\u0002\ud835\udc5bas a transformation that projects\nvectorsfrom R\ud835\udc5btoR\ud835\udc5a. Thesetransformationsareremarkablyuseful. Forexample,wecan\nrepresent rotations as multiplications by certain square matrices. Matrix\u2013vector products\nalsodescribethekeycalculationinvolvedincomputingtheoutputsofeachlayerinaneural\nnetwork given the outputs from the previous layer.\nTo express a matrix\u2013vector product in code, we use the mvfunction. Note that the column\ndimensionof A(itslengthalongaxis1)mustbethesameasthedimensionof x(itslength).\nPythonhasaconvenienceoperator @thatcanexecutebothmatrix\u2013vectorandmatrix\u2013matrix\nproducts (depending on its arguments). Thus we can write A@x.\nA.shape, x .shape, torch .mv(A, x), A @x\n(torch .Size([ 2,3]), torch .Size([ 3]), tensor([ 5.,14.]), tensor([ 5.,14.]))", "mimetype": "text/plain", "start_char_idx": 166241, "end_char_idx": 169408, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "124b1e89-33e5-4d81-95d0-0513f3d50fbb": {"__data__": {"id_": "124b1e89-33e5-4d81-95d0-0513f3d50fbb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ae7b1e93-c6fb-43f4-b3ba-a6c49b57a605", "node_type": "1", "metadata": {}, "hash": "5d8abe219a6cc5e2653dc0bf952f39f6464d94438d8a39db00518483fa56ccab", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4eeaaa35-36cc-4ec0-ac2a-03018d6d7bc3", "node_type": "1", "metadata": {}, "hash": "0606cb13819ce21195d7ab71baffb38396718113a57af6196c4b62fdeebff16e", "class_name": "RelatedNodeInfo"}}, "text": "Thesetransformationsareremarkablyuseful. Forexample,wecan\nrepresent rotations as multiplications by certain square matrices. Matrix\u2013vector products\nalsodescribethekeycalculationinvolvedincomputingtheoutputsofeachlayerinaneural\nnetwork given the outputs from the previous layer.\nTo express a matrix\u2013vector product in code, we use the mvfunction. Note that the column\ndimensionof A(itslengthalongaxis1)mustbethesameasthedimensionof x(itslength).\nPythonhasaconvenienceoperator @thatcanexecutebothmatrix\u2013vectorandmatrix\u2013matrix\nproducts (depending on its arguments). Thus we can write A@x.\nA.shape, x .shape, torch .mv(A, x), A @x\n(torch .Size([ 2,3]), torch .Size([ 3]), tensor([ 5.,14.]), tensor([ 5.,14.]))\n2.3.10Matrix\u2013MatrixMultiplication\nOnce you have gotten the hang of dot products and matrix\u2013vector products, then matrix\u2013\nmatrixmultiplication should be straightforward.\nSay that we have two matrices A2R\ud835\udc5b\u0002\ud835\udc58andB2R\ud835\udc58\u0002\ud835\udc5a:\nA=266666664\ud835\udc4e11\ud835\udc4e12\u0001\u0001\u0001\ud835\udc4e1\ud835\udc58\n\ud835\udc4e21\ud835\udc4e22\u0001\u0001\u0001\ud835\udc4e2\ud835\udc58\n............\n\ud835\udc4e\ud835\udc5b1\ud835\udc4e\ud835\udc5b2\u0001\u0001\u0001\ud835\udc4e\ud835\udc5b\ud835\udc58377777775,B=266666664\ud835\udc4f11\ud835\udc4f12\u0001\u0001\u0001\ud835\udc4f1\ud835\udc5a\n\ud835\udc4f21\ud835\udc4f22\u0001\u0001\u0001\ud835\udc4f2\ud835\udc5a\n............\n\ud835\udc4f\ud835\udc581\ud835\udc4f\ud835\udc582\u0001\u0001\u0001\ud835\udc4f\ud835\udc58\ud835\udc5a377777775. (2.3.7)\nLeta>\n\ud835\udc562R\ud835\udc58denotetherowvectorrepresentingthe \ud835\udc56throwofthematrix Aandlet b\ud835\udc572R\ud835\udc58\n50 Preliminaries\ndenote the column vector from the \ud835\udc57thcolumn of the matrix B:\nA=266666664a>\n1\na>\n2...\na>\n\ud835\udc5b377777775,B=\u0002\nb1b2\u0001\u0001\u0001b\ud835\udc5a\u0003\n. (2.3.8)\nTo form the matrix product C2R\ud835\udc5b\u0002\ud835\udc5a, we simply compute each element \ud835\udc50\ud835\udc56\ud835\udc57as the dot\nproduct between the \ud835\udc56throw of Aand the\ud835\udc57thcolumn of B, i.e.,a>\n\ud835\udc56b\ud835\udc57:\nC=AB=266666664a>\n1\na>\n2...\na>\n\ud835\udc5b377777775\u0002\nb1b2\u0001\u0001\u0001b\ud835\udc5a\u0003\n=266666664a>\n1b1a>\n1b2\u0001\u0001\u0001a>\n1b\ud835\udc5a\na>\n2b1a>\n2b2\u0001\u0001\u0001a>\n2b\ud835\udc5a\n............\na>\n\ud835\udc5bb1a>\n\ud835\udc5bb2\u0001\u0001\u0001a>\n\ud835\udc5bb\ud835\udc5a377777775. (2.3.9)\nWecanthinkofthematrix\u2013matrixmultiplication ABasperforming \ud835\udc5amatrix\u2013vectorprod-\nucts or\ud835\udc5a\u0002\ud835\udc5bdot products and stitching the results together to form an \ud835\udc5b\u0002\ud835\udc5amatrix. In the\nfollowing snippet, we perform matrix multiplication on AandB. Here, Ais a matrix with\ntwo rows and three columns, and Bis a matrix with three rows and four columns. After\nmultiplication, we obtain a matrix with two rows and four columns.\nB=torch .ones( 3,4)\ntorch .mm(A, B), A @B\n(tensor([[ 3.,3.,3.,3.],\n[12.,12.,12.,12.]]),\ntensor([[ 3.,3.,3.,3.],\n[12.,12.,12.,12.]]))\nThe term matrix\u2013matrix multiplication is often simplified to matrix multiplication , and\nshould not be confused with the Hadamard product.\n2.3.11Norms\nSome of the most useful operators in linear algebra are norms. Informally, the norm of a\nvector tells us how bigit is. For instance, the \u21132norm measures the (Euclidean) length of a\nvector. Here, we are employing a notion of sizethat concerns the magnitude of a vector\u2019s\ncomponents (not its dimensionality).", "mimetype": "text/plain", "start_char_idx": 168704, "end_char_idx": 171295, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4eeaaa35-36cc-4ec0-ac2a-03018d6d7bc3": {"__data__": {"id_": "4eeaaa35-36cc-4ec0-ac2a-03018d6d7bc3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "124b1e89-33e5-4d81-95d0-0513f3d50fbb", "node_type": "1", "metadata": {}, "hash": "53b572cee9d57841c5ea697eba185089881b1209eecb9ced6ffc681d2319f8e0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d74c16b8-15fc-4581-8c33-2934279a3a25", "node_type": "1", "metadata": {}, "hash": "8d6e51d3819c1352b0c6d23a4801ac95d23267351e472fdc0fa583d305af47de", "class_name": "RelatedNodeInfo"}}, "text": "After\nmultiplication, we obtain a matrix with two rows and four columns.\nB=torch .ones( 3,4)\ntorch .mm(A, B), A @B\n(tensor([[ 3.,3.,3.,3.],\n[12.,12.,12.,12.]]),\ntensor([[ 3.,3.,3.,3.],\n[12.,12.,12.,12.]]))\nThe term matrix\u2013matrix multiplication is often simplified to matrix multiplication , and\nshould not be confused with the Hadamard product.\n2.3.11Norms\nSome of the most useful operators in linear algebra are norms. Informally, the norm of a\nvector tells us how bigit is. For instance, the \u21132norm measures the (Euclidean) length of a\nvector. Here, we are employing a notion of sizethat concerns the magnitude of a vector\u2019s\ncomponents (not its dimensionality).\nA norm is a function k\u0001kthat maps a vector to a scalar and satisfies the following three\nproperties:\n1.Given any vector x, if we scale (all elements of) the vector by a scalar \ud835\udefc2R, its norm\nscales accordingly:\nk\ud835\udefcxk=j\ud835\udefcjkxk. (2.3.10)\n51 Linear Algebra\n2.For any vectors xandy: norms satisfy the triangle inequality:\nkx\u00b8yk\u0014kxk\u00b8kyk. (2.3.11)\n3.The norm of a vector is nonnegative and it only vanishes if the vector is zero:\nkxk>0for allx\u22600. (2.3.12)\nMany functions are valid norms and different norms encode different notions of size. The\nEuclidean norm that we all learned in elementary school geometry when calculating the\nhypotenuseofarighttriangleisthesquarerootofthesumofsquaresofavector\u2019selements.\nFormally, this is called the \u21132normand expressed as\nkxk2=vt\ud835\udc5b\u00d5\n\ud835\udc56=1\ud835\udc652\n\ud835\udc56. (2.3.13)\nThe method normcalculates the \u21132norm.\nu=torch .tensor([ 3.0,-4.0])\ntorch .norm(u)\ntensor( 5.)\nThe\u21131norm is also common and the associated measure is called the Manhattan distance.\nBy definition, the \u21131norm sums the absolute values of a vector\u2019s elements:\nkxk1=\ud835\udc5b\u00d5\n\ud835\udc56=1j\ud835\udc65\ud835\udc56j. (2.3.14)\nCompared to the \u21132norm, it is less sensitive to outliers. To compute the \u21131norm, we\ncompose the absolute value with the sum operation.\ntorch .abs(u) .sum()\ntensor( 7.)\nBoth the\u21132and\u21131norms are special cases of the more general \u2113\ud835\udc5dnorms:\nkxk\ud835\udc5d= \ud835\udc5b\u00d5\n\ud835\udc56=1j\ud835\udc65\ud835\udc56j\ud835\udc5d!1\u009d\ud835\udc5d\n. (2.3.15)\nIn the case of matrices, matters are more complicated. After all, matrices can be viewed\nbothascollectionsofindividualentries andasobjectsthatoperateonvectorsandtransform\nthem into other vectors. For instance, we can ask by how much longer the matrix\u2013vector\nproduct Xvcould be relative to v. This line of thought leads to what is called the spectral\n52 Preliminaries\nnorm. For now, we introduce the Frobenius norm , which is much easier to compute and\ndefined as the square root of the sum of the squares of a matrix\u2019s elements:\nkXkF=vut\ud835\udc5a\u00d5\n\ud835\udc56=1\ud835\udc5b\u00d5\n\ud835\udc57=1\ud835\udc652\n\ud835\udc56\ud835\udc57. (2.3.16)\nThe Frobenius norm behaves as if it were an \u21132norm of a matrix-shaped vector. Invoking\nthe following function will calculate the Frobenius norm of a matrix.\ntorch .norm(torch .ones(( 4,9)))\ntensor( 6.)\nWhile we do not want to get too far ahead of ourselves, we already can plant some intu-\nition about why these concepts are useful. In deep learning, we are often trying to solve\noptimization problems: maximize the probability assigned to observed data; maximize the\nrevenue associated with a recommender model; minimize the distance between predictions\nandthegroundtruthobservations; minimize thedistancebetweenrepresentationsofphotos\nofthesamepersonwhile maximizing thedistancebetweenrepresentationsofphotosofdif-\nferentpeople.", "mimetype": "text/plain", "start_char_idx": 170632, "end_char_idx": 173921, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d74c16b8-15fc-4581-8c33-2934279a3a25": {"__data__": {"id_": "d74c16b8-15fc-4581-8c33-2934279a3a25", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4eeaaa35-36cc-4ec0-ac2a-03018d6d7bc3", "node_type": "1", "metadata": {}, "hash": "0606cb13819ce21195d7ab71baffb38396718113a57af6196c4b62fdeebff16e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "55fbb0ce-02a9-4ce1-89c2-48471a993397", "node_type": "1", "metadata": {}, "hash": "9395a1c84e5a15999cc063886f790747b7f913c5ad3c23a06235399946955d22", "class_name": "RelatedNodeInfo"}}, "text": "(2.3.16)\nThe Frobenius norm behaves as if it were an \u21132norm of a matrix-shaped vector. Invoking\nthe following function will calculate the Frobenius norm of a matrix.\ntorch .norm(torch .ones(( 4,9)))\ntensor( 6.)\nWhile we do not want to get too far ahead of ourselves, we already can plant some intu-\nition about why these concepts are useful. In deep learning, we are often trying to solve\noptimization problems: maximize the probability assigned to observed data; maximize the\nrevenue associated with a recommender model; minimize the distance between predictions\nandthegroundtruthobservations; minimize thedistancebetweenrepresentationsofphotos\nofthesamepersonwhile maximizing thedistancebetweenrepresentationsofphotosofdif-\nferentpeople. Thesedistances,whichconstitutetheobjectivesofdeeplearningalgorithms,\nare often expressed as norms.\n2.3.12Discussion\nIn this section, we have reviewed all the linear algebra that you will need to understand a\nsignificant chunk of modern deep learning. There is a lot more to linear algebra, though,\nand much of it is useful for machine learning. For example, matrices can be decomposed\ninto factors, and these decompositions can reveal low-dimensional structure in real-world\ndatasets. There are entire subfields of machine learning that focus on using matrix decom-\npositions and their generalizations to high-order tensors to discover structure in datasets\nand solve prediction problems. But this book focuses on deep learning. And we believe\nyouwillbemoreinclinedtolearnmoremathematicsonceyouhavegottenyourhandsdirty\napplyingmachinelearningtorealdatasets. Sowhilewereservetherighttointroducemore\nmathematics later on, we wrap up this section here.\nIf you are eager to learn more linear algebra, there are many excellent books and online\nresources. For a more advanced crash course, consider checking out Strang ( 1993), Kolter\n(2008), and Petersen and Pedersen ( 2008).\nTo recap:\n\u000fScalars, vectors, matrices, and tensors are the basic mathematical objects used in linear\nalgebra and have zero, one, two, and an arbitrary number of axes, respectively.\n\u000fTensors can be sliced or reduced along specified axes via indexing, or operations such\nassumandmean, respectively.\n53 Linear Algebra\n\u000fElementwiseproductsarecalledHadamardproducts. Bycontrast,dotproducts,matrix\u2013\nvector products, and matrix\u2013matrix products are not elementwise operations and in\ngeneral return objects having shapes that are different from the the operands.\n\u000fCompared to Hadamard products, matrix\u2013matrix products take considerably longer to\ncompute (cubic rather than quadratic time).\n\u000fNorms capture various notions of the magnitude of a vector (or matrix), and are com-\nmonly applied to the difference of two vectors to measure their distance apart.\n\u000fCommon vector norms include the \u21131and\u21132norms, and common matrix norms include\nthespectral andFrobenius norms.\n2.3.13Exercises\n1.Prove that the transpose of the transpose of a matrix is the matrix itself: \u00b9A>\u00ba>=A.\n2.Given two matrices AandB, show that sum and transposition commute: A>\u00b8B>=\n\u00b9A\u00b8B\u00ba>.\n3.Given any square matrix A, isA\u00b8A>always symmetric? Can you prove the result by\nusing only the results of the previous two exercises?\n4.We defined the tensor Xof shape (2, 3, 4) in this section. What is the output of len(X)?\nWrite your answer without implementing any code, then check your answer using code.\n5.For a tensor Xof arbitrary shape, does len(X) always correspond to the length of a\ncertain axis of X? What is that axis?\n6.Run A / A.sum(axis=1) and see what happens. Can you analyze the results?\n7.When traveling between two points in downtown Manhattan, what is the distance that\nyou need to cover in terms of the coordinates, i.e., in terms of avenues and streets? Can\nyou travel diagonally?\n8.Consider a tensor of shape (2, 3, 4). What are the shapes of the summation outputs\nalong axes 0, 1, and 2?\n9.Feed a tensor with three or more axes to the linalg.norm function and observe its\noutput. What does this function compute for tensors of arbitrary shape?\n10.Consider three large matrices, say A2R210\u0002216,B2R216\u000225andC2R25\u0002214, ini-\ntialized with Gaussian random variables. You want to compute the product ABC.", "mimetype": "text/plain", "start_char_idx": 173182, "end_char_idx": 177364, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "55fbb0ce-02a9-4ce1-89c2-48471a993397": {"__data__": {"id_": "55fbb0ce-02a9-4ce1-89c2-48471a993397", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d74c16b8-15fc-4581-8c33-2934279a3a25", "node_type": "1", "metadata": {}, "hash": "8d6e51d3819c1352b0c6d23a4801ac95d23267351e472fdc0fa583d305af47de", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fc7a684b-0813-46f7-be9f-79faba003a3b", "node_type": "1", "metadata": {}, "hash": "5bb9a257476997e938f7d033934cf283f5c7573a7b5aa9a063540dec8d52936f", "class_name": "RelatedNodeInfo"}}, "text": "What is that axis?\n6.Run A / A.sum(axis=1) and see what happens. Can you analyze the results?\n7.When traveling between two points in downtown Manhattan, what is the distance that\nyou need to cover in terms of the coordinates, i.e., in terms of avenues and streets? Can\nyou travel diagonally?\n8.Consider a tensor of shape (2, 3, 4). What are the shapes of the summation outputs\nalong axes 0, 1, and 2?\n9.Feed a tensor with three or more axes to the linalg.norm function and observe its\noutput. What does this function compute for tensors of arbitrary shape?\n10.Consider three large matrices, say A2R210\u0002216,B2R216\u000225andC2R25\u0002214, ini-\ntialized with Gaussian random variables. You want to compute the product ABC. Is\nthereanydifferenceinmemoryfootprintandspeed,dependingonwhetheryoucompute\n\u00b9AB\u00baCorA\u00b9BC\u00ba. Why?\n11.Consider three large matrices, say A2R210\u0002216,B2R216\u000225andC2R25\u0002216. Is there\nany difference in speed depending on whether you compute ABorAC>? Why? What\nchanges if you initialize C=B>without cloning memory? Why?\n12.Consider three matrices, say A,B,C2R100\u0002200. Construct a tensor with three axes by\n54 Preliminaries\n55stacking\u00bbA,B,C\u00bc. What is the dimensionality? Slice out the second coordinate of the\nthird axis to recover B. Check that your answer is correct.\nDiscussions55.\n2.4Calculus\nFor a long time, how to calculate the area of a circle remained a mystery. Then, in Ancient\nGreece, the mathematician Archimedes came up with the clever idea to inscribe a series of\npolygons with increasing numbers of vertices on the inside of a circle ( Fig. 2.4.1 ). For a\npolygon with \ud835\udc5bvertices, we obtain \ud835\udc5btriangles. The height of each triangle approaches the\nradius\ud835\udc5faswepartitionthecirclemorefinely. Atthesametime,itsbaseapproaches 2\ud835\udf0b\ud835\udc5f\u009d\ud835\udc5b,\nsince the ratio between arc and secant approaches 1 for a large number of vertices. Thus,\nthe area of the polygon approaches \ud835\udc5b\u0001\ud835\udc5f\u00011\n2\u00b92\ud835\udf0b\ud835\udc5f\u009d\ud835\udc5b\u00ba=\ud835\udf0b\ud835\udc5f2.\ntFig. 2.4.1 Finding the area of a circle as a limit procedure.\nThislimitingprocedureisattherootofboth differentialcalculus andintegralcalculus . The\nformer can tell us how to increase or decrease a function\u2019s value by manipulating its argu-\nments. This comes in handy for the optimization problems that we face in deep learning,\nwhere we repeatedly update our parameters in order to decrease the loss function. Opti-\nmizationaddresseshowtofitourmodelstotrainingdata,andcalculusisitskeyprerequisite.\nHowever, do not forget that our ultimate goal is to perform well on previouslyunseen data.\nThat problem is called generalization and will be a key focus of other chapters.\n%matplotlib inline\nimport numpy asnp\nfrom matplotlib_inline import backend_inline\nfrom d2l import torch asd2l\n2.4.1Derivativesand Differentiation\nPut simply, a derivative is the rate of change in a function with respect to changes in its\narguments. Derivatives can tell us how rapidly a loss function would increase or decrease\nwere we to increase ordecrease each parameter by an infinitesimally small amount. For-\nmally, for functions \ud835\udc53:R!R, that map from scalars to scalars, the derivative of\ud835\udc53at a\npoint\ud835\udc65is defined as\n\ud835\udc530\u00b9\ud835\udc65\u00ba=lim\n\u210e!0\ud835\udc53\u00b9\ud835\udc65\u00b8\u210e\u00ba\u0000\ud835\udc53\u00b9\ud835\udc65\u00ba\n\u210e. (2.4.1)\n55 Calculus\nThis term on the right hand side is called a limitand it tells us what happens to the value of\nan expression as a specified variable approaches a particular value. This limit tells us what\nthe ratio between a perturbation \u210eand the change in the function value \ud835\udc53\u00b9\ud835\udc65\u00b8\u210e\u00ba\u0000\ud835\udc53\u00b9\ud835\udc65\u00ba\nconverges to as we shrink its size to zero.", "mimetype": "text/plain", "start_char_idx": 176653, "end_char_idx": 180095, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fc7a684b-0813-46f7-be9f-79faba003a3b": {"__data__": {"id_": "fc7a684b-0813-46f7-be9f-79faba003a3b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "55fbb0ce-02a9-4ce1-89c2-48471a993397", "node_type": "1", "metadata": {}, "hash": "9395a1c84e5a15999cc063886f790747b7f913c5ad3c23a06235399946955d22", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e961a397-16d3-4818-8b98-1ce8a69b568d", "node_type": "1", "metadata": {}, "hash": "d364e2b85868ef9e4a258f7e3a69ce815154a2b3d4d18146eeefd81a4634784d", "class_name": "RelatedNodeInfo"}}, "text": "For-\nmally, for functions \ud835\udc53:R!R, that map from scalars to scalars, the derivative of\ud835\udc53at a\npoint\ud835\udc65is defined as\n\ud835\udc530\u00b9\ud835\udc65\u00ba=lim\n\u210e!0\ud835\udc53\u00b9\ud835\udc65\u00b8\u210e\u00ba\u0000\ud835\udc53\u00b9\ud835\udc65\u00ba\n\u210e. (2.4.1)\n55 Calculus\nThis term on the right hand side is called a limitand it tells us what happens to the value of\nan expression as a specified variable approaches a particular value. This limit tells us what\nthe ratio between a perturbation \u210eand the change in the function value \ud835\udc53\u00b9\ud835\udc65\u00b8\u210e\u00ba\u0000\ud835\udc53\u00b9\ud835\udc65\u00ba\nconverges to as we shrink its size to zero.\nWhen\ud835\udc530\u00b9\ud835\udc65\u00baexists,\ud835\udc53is said to be differentiable at\ud835\udc65; and when\ud835\udc530\u00b9\ud835\udc65\u00baexists for all \ud835\udc65on a\nset, e.g., the interval \u00bb\ud835\udc4e,\ud835\udc4f\u00bc, we say that \ud835\udc53is differentiable on this set. Not all functions are\ndifferentiable,includingmanythatwewishtooptimize,suchasaccuracyandtheareaunder\nthe receiving operating characteristic (AUC). However, because computing the derivative\nof the loss is a crucial step in nearly all algorithms for training deep neural networks, we\noften optimize a differentiable surrogate instead.\nWe can interpret the derivative \ud835\udc530\u00b9\ud835\udc65\u00baas theinstantaneous rate of change of \ud835\udc53\u00b9\ud835\udc65\u00bawith\nrespect to\ud835\udc65. Let\u2019s develop some intuition with an example. Define \ud835\udc62=\ud835\udc53\u00b9\ud835\udc65\u00ba=3\ud835\udc652\u0000\n4\ud835\udc65.\ndef f(x):\nreturn 3*x**2-4*x\nSetting\ud835\udc65=1, we see that\ud835\udc53\u00b9\ud835\udc65\u00b8\u210e\u00ba\u0000\ud835\udc53\u00b9\ud835\udc65\u00ba\n\u210eapproaches 2as\u210eapproaches 0. While this ex-\nperiment lacks the rigor of a mathematical proof, we can quickly see that indeed \ud835\udc530\u00b91\u00ba=\n2.\nfor hin10.0 **np.arange( -1,-6,-1):\nprint (f'h={h:.5f}, numerical limit= {(f(1+h)-f(1))/h:.5f}')\nh=0.10000 , numerical limit =2.30000\nh=0.01000 , numerical limit =2.03000\nh=0.00100 , numerical limit =2.00300\nh=0.00010 , numerical limit =2.00030\nh=0.00001 , numerical limit =2.00003\nThere are several equivalent notational conventions for derivatives. Given \ud835\udc66=\ud835\udc53\u00b9\ud835\udc65\u00ba, the\nfollowing expressions are equivalent:\n\ud835\udc530\u00b9\ud835\udc65\u00ba=\ud835\udc660=\ud835\udc51\ud835\udc66\n\ud835\udc51\ud835\udc65=\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65=\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc37\ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc37\ud835\udc65\ud835\udc53\u00b9\ud835\udc65\u00ba, (2.4.2)\nwhere the symbols\ud835\udc51\n\ud835\udc51\ud835\udc65and\ud835\udc37aredifferentiation operators . Below, we present the deriva-\ntives of some common functions:\n\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc36=0 for any constant \ud835\udc36\n\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc65\ud835\udc5b=\ud835\udc5b\ud835\udc65\ud835\udc5b\u00001for\ud835\udc5b\u22600\n\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc52\ud835\udc65=\ud835\udc52\ud835\udc65\n\ud835\udc51\n\ud835\udc51\ud835\udc65ln\ud835\udc65=\ud835\udc65\u00001.(2.4.3)\n56 Preliminaries\nFunctions composed from differentiable functions are often themselves differentiable.", "mimetype": "text/plain", "start_char_idx": 179622, "end_char_idx": 181709, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e961a397-16d3-4818-8b98-1ce8a69b568d": {"__data__": {"id_": "e961a397-16d3-4818-8b98-1ce8a69b568d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fc7a684b-0813-46f7-be9f-79faba003a3b", "node_type": "1", "metadata": {}, "hash": "5bb9a257476997e938f7d033934cf283f5c7573a7b5aa9a063540dec8d52936f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "306550e1-7ddf-4a29-975f-3484eef50f6a", "node_type": "1", "metadata": {}, "hash": "47ecd901957b6561925879b63b6add361fd774acae0b38cdd99d5204857f3cc5", "class_name": "RelatedNodeInfo"}}, "text": "Below, we present the deriva-\ntives of some common functions:\n\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc36=0 for any constant \ud835\udc36\n\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc65\ud835\udc5b=\ud835\udc5b\ud835\udc65\ud835\udc5b\u00001for\ud835\udc5b\u22600\n\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc52\ud835\udc65=\ud835\udc52\ud835\udc65\n\ud835\udc51\n\ud835\udc51\ud835\udc65ln\ud835\udc65=\ud835\udc65\u00001.(2.4.3)\n56 Preliminaries\nFunctions composed from differentiable functions are often themselves differentiable. The\nfollowing rules come in handy for working with compositions of any differentiable func-\ntions\ud835\udc53and\ud835\udc54, and constant \ud835\udc36.\n\ud835\udc51\n\ud835\udc51\ud835\udc65\u00bb\ud835\udc36\ud835\udc53\u00b9\ud835\udc65\u00ba\u00bc=\ud835\udc36\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc53\u00b9\ud835\udc65\u00ba Constant multiple rule\n\ud835\udc51\n\ud835\udc51\ud835\udc65\u00bb\ud835\udc53\u00b9\ud835\udc65\u00ba\u00b8\ud835\udc54\u00b9\ud835\udc65\u00ba\u00bc=\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc53\u00b9\ud835\udc65\u00ba\u00b8\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc54\u00b9\ud835\udc65\u00ba Sum rule\n\ud835\udc51\n\ud835\udc51\ud835\udc65\u00bb\ud835\udc53\u00b9\ud835\udc65\u00ba\ud835\udc54\u00b9\ud835\udc65\u00ba\u00bc=\ud835\udc53\u00b9\ud835\udc65\u00ba\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc54\u00b9\ud835\udc65\u00ba\u00b8\ud835\udc54\u00b9\ud835\udc65\u00ba\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc53\u00b9\ud835\udc65\u00baProduct rule\n\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc53\u00b9\ud835\udc65\u00ba\n\ud835\udc54\u00b9\ud835\udc65\u00ba=\ud835\udc54\u00b9\ud835\udc65\u00ba\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc53\u00b9\ud835\udc65\u00ba\u0000\ud835\udc53\u00b9\ud835\udc65\u00ba\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc54\u00b9\ud835\udc65\u00ba\n\ud835\udc542\u00b9\ud835\udc65\u00baQuotient rule(2.4.4)\nUsing this, we can apply the rules to find the derivative of 3\ud835\udc652\u00004\ud835\udc65via\n\ud835\udc51\n\ud835\udc51\ud835\udc65\u00bb3\ud835\udc652\u00004\ud835\udc65\u00bc=3\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc652\u00004\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc65=6\ud835\udc65\u00004. (2.4.5)\nPlugging in \ud835\udc65=1shows that, indeed, the derivative equals 2at this location. Note that\nderivatives tell us the slopeof a function at a particular location.\n2.4.2VisualizationUtilities\nWe can visualize the slopes of functions using the matplotlib library. We need to de-\nfine a few functions. As its name indicates, use_svg_display tells matplotlib to output\ngraphicsinSVGformatforcrisperimages. Thecomment #@saveisaspecialmodifierthat\nallows us to save any function, class, or other code block to the d2lpackage so that we can\ninvoke it later without repeating the code, e.g., via d2l.use_svg_display() .\ndef use_svg_display (): #@save\n\"\"\"Use the svg format to display a plot in Jupyter.\"\"\"\nbackend_inline .set_matplotlib_formats( 'svg')\nConveniently, we can set figure sizes with set_figsize . Since the import statement from\nmatplotlib import pyplot as plt was marked via #@savein the d2lpackage, we can\ncalld2l.plt .\ndef set_figsize (figsize =(3.5,2.5)): #@save\n\"\"\"Set the figure size for matplotlib.\"\"\"\nuse_svg_display()\nd2l.plt.rcParams[ 'figure.figsize ']=figsize\nThe set_axes function can associate axes with properties, including labels, ranges, and\nscales.\n#@save\ndef set_axes (axes, xlabel, ylabel, xlim, ylim, xscale, yscale, legend):\n\"\"\"Set the axes for matplotlib.\"\"\"\naxes .set_xlabel(xlabel), axes .set_ylabel(ylabel)\n(continues on next page)\n57 Calculus\n(continued from previous page)\naxes .set_xscale(xscale), axes .set_yscale(yscale)\naxes .set_xlim(xlim), axes .set_ylim(ylim)\niflegend:\naxes .legend(legend)\naxes .grid()\nWiththesethreefunctions,wecandefinea plotfunctiontooverlaymultiplecurves. Much\nof the code here is just ensuring that the sizes and shapes of inputs match.", "mimetype": "text/plain", "start_char_idx": 181469, "end_char_idx": 183842, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "306550e1-7ddf-4a29-975f-3484eef50f6a": {"__data__": {"id_": "306550e1-7ddf-4a29-975f-3484eef50f6a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e961a397-16d3-4818-8b98-1ce8a69b568d", "node_type": "1", "metadata": {}, "hash": "d364e2b85868ef9e4a258f7e3a69ce815154a2b3d4d18146eeefd81a4634784d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "316721c3-b326-431b-a332-9d1da418ee75", "node_type": "1", "metadata": {}, "hash": "28ed963698f4c5e99ac649c2094683d859f800565d7ed39aee39b4cfc77750e2", "class_name": "RelatedNodeInfo"}}, "text": "use_svg_display()\nd2l.plt.rcParams[ 'figure.figsize ']=figsize\nThe set_axes function can associate axes with properties, including labels, ranges, and\nscales.\n#@save\ndef set_axes (axes, xlabel, ylabel, xlim, ylim, xscale, yscale, legend):\n\"\"\"Set the axes for matplotlib.\"\"\"\naxes .set_xlabel(xlabel), axes .set_ylabel(ylabel)\n(continues on next page)\n57 Calculus\n(continued from previous page)\naxes .set_xscale(xscale), axes .set_yscale(yscale)\naxes .set_xlim(xlim), axes .set_ylim(ylim)\niflegend:\naxes .legend(legend)\naxes .grid()\nWiththesethreefunctions,wecandefinea plotfunctiontooverlaymultiplecurves. Much\nof the code here is just ensuring that the sizes and shapes of inputs match.\n#@save\ndef plot (X, Y =None , xlabel =None , ylabel =None , legend =[], xlim =None ,\nylim =None , xscale ='linear ', yscale ='linear ',\nfmts =('-','m--','g-.','r:'), figsize =(3.5,2.5), axes =None ):\n\"\"\"Plot data points.\"\"\"\ndef has_one_axis (X): # True if X (tensor or list) has 1 axis\nreturn (hasattr (X, \"ndim \")and X.ndim ==1orisinstance (X, list )\nand not hasattr (X[0],\"__len__ \"))\nifhas_one_axis(X): X =[X]\nifYisNone :\nX, Y =[[]] *len(X), X\nelif has_one_axis(Y):\nY=[Y]\niflen(X) !=len(Y):\nX=X*len(Y)\nset_figsize(figsize)\nifaxes isNone :\naxes =d2l.plt.gca()\naxes .cla()\nfor x, y, fmt inzip(X, Y, fmts):\naxes .plot(x,y,fmt) iflen(x) else axes .plot(y,fmt)\nset_axes(axes, xlabel, ylabel, xlim, ylim, xscale, yscale, legend)\nNow we can plot the function \ud835\udc62=\ud835\udc53\u00b9\ud835\udc65\u00baand its tangent line \ud835\udc66=2\ud835\udc65\u00003at\ud835\udc65=1, where the\ncoefficient 2is the slope of the tangent line.\nx=np.arange( 0,3,0.1)\nplot(x, [f(x), 2*x-3],'x','f(x) ', legend =['f(x) ','Tangent line (x=1) '])\n\n58 Preliminaries\n2.4.3PartialDerivativesand Gradients\nThus far, we have been differentiating functions of just one variable. In deep learning, we\nalso need to work with functions of manyvariables. We briefly introduce notions of the\nderivative that apply to such multivariate functions.\nLet\ud835\udc66=\ud835\udc53\u00b9\ud835\udc651,\ud835\udc652,...,\ud835\udc65\ud835\udc5b\u00babe a function with \ud835\udc5bvariables. The partial derivative of\ud835\udc66with\nrespect to its \ud835\udc56thparameter\ud835\udc65\ud835\udc56is\n\ud835\udf15\ud835\udc66\n\ud835\udf15\ud835\udc65\ud835\udc56=lim\n\u210e!0\ud835\udc53\u00b9\ud835\udc651,...,\ud835\udc65\ud835\udc56\u00001,\ud835\udc65\ud835\udc56\u00b8\u210e,\ud835\udc65\ud835\udc56\u00b81,...,\ud835\udc65\ud835\udc5b\u00ba\u0000\ud835\udc53\u00b9\ud835\udc651,...,\ud835\udc65\ud835\udc56,...,\ud835\udc65\ud835\udc5b\u00ba\n\u210e. (2.4.6)\nTocalculate\ud835\udf15\ud835\udc66\n\ud835\udf15\ud835\udc65\ud835\udc56,wecantreat \ud835\udc651,...,\ud835\udc65\ud835\udc56\u00001,\ud835\udc65\ud835\udc56\u00b81,...,\ud835\udc65\ud835\udc5basconstantsandcalculatethederiva-\ntive of\ud835\udc66with respect to \ud835\udc65\ud835\udc56. The following notational conventions for partial derivatives are\nall common and all mean the same thing:\n\ud835\udf15\ud835\udc66\n\ud835\udf15\ud835\udc65\ud835\udc56=\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc65\ud835\udc56=\ud835\udf15\ud835\udc65\ud835\udc56\ud835\udc53=\ud835\udf15\ud835\udc56\ud835\udc53=\ud835\udc53\ud835\udc65\ud835\udc56=\ud835\udc53\ud835\udc56=\ud835\udc37\ud835\udc56\ud835\udc53=\ud835\udc37\ud835\udc65\ud835\udc56\ud835\udc53. (2.4.7)\nWe can concatenate partial derivatives of a multivariate function with respect to all its\nvariables to obtain a vector that is called the gradient of the function.", "mimetype": "text/plain", "start_char_idx": 183156, "end_char_idx": 185702, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "316721c3-b326-431b-a332-9d1da418ee75": {"__data__": {"id_": "316721c3-b326-431b-a332-9d1da418ee75", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "306550e1-7ddf-4a29-975f-3484eef50f6a", "node_type": "1", "metadata": {}, "hash": "47ecd901957b6561925879b63b6add361fd774acae0b38cdd99d5204857f3cc5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cde99be9-3e82-46ec-9f6a-0a27bc6811af", "node_type": "1", "metadata": {}, "hash": "2426f94cbaf81b6747c20bc02b950038a2ab1c53a142121437d414a508f86999", "class_name": "RelatedNodeInfo"}}, "text": "The following notational conventions for partial derivatives are\nall common and all mean the same thing:\n\ud835\udf15\ud835\udc66\n\ud835\udf15\ud835\udc65\ud835\udc56=\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc65\ud835\udc56=\ud835\udf15\ud835\udc65\ud835\udc56\ud835\udc53=\ud835\udf15\ud835\udc56\ud835\udc53=\ud835\udc53\ud835\udc65\ud835\udc56=\ud835\udc53\ud835\udc56=\ud835\udc37\ud835\udc56\ud835\udc53=\ud835\udc37\ud835\udc65\ud835\udc56\ud835\udc53. (2.4.7)\nWe can concatenate partial derivatives of a multivariate function with respect to all its\nvariables to obtain a vector that is called the gradient of the function. Suppose that the\ninput of function \ud835\udc53:R\ud835\udc5b!Ris an\ud835\udc5b-dimensional vector x=\u00bb\ud835\udc651,\ud835\udc652,...,\ud835\udc65\ud835\udc5b\u00bc>and the\noutput is a scalar. The gradient of the function \ud835\udc53with respect to xis a vector of \ud835\udc5bpartial\nderivatives:\nrx\ud835\udc53\u00b9x\u00ba=\u0002\n\ud835\udf15\ud835\udc651\ud835\udc53\u00b9x\u00ba,\ud835\udf15\ud835\udc652\ud835\udc53\u00b9x\u00ba,...\ud835\udf15\ud835\udc65\ud835\udc5b\ud835\udc53\u00b9x\u00ba\u0003>. (2.4.8)\nWhen there is no ambiguity, rx\ud835\udc53\u00b9x\u00bais typically replaced by r\ud835\udc53\u00b9x\u00ba. The following rules\ncome in handy for differentiating multivariate functions:\n\u000fFor all A2R\ud835\udc5a\u0002\ud835\udc5bwe haverxAx=A>andrxx>A=A.\n\u000fFor square matrices A2R\ud835\udc5b\u0002\ud835\udc5bwe have thatrxx>Ax=\u00b9A\u00b8A>\u00baxand in particular\nrxkxk2=rxx>x=2x.\nSimilarly, for any matrix X, we haverXkXk2\nF=2X.\n2.4.4Chain Rule\nIn deep learning, the gradients of concern are often difficult to calculate because we are\nworkingwithdeeplynestedfunctions(offunctions(offunctions\u2026)). Fortunately,the chain\nruletakescareofthis. Returningtofunctionsofasinglevariable,supposethat \ud835\udc66=\ud835\udc53\u00b9\ud835\udc54\u00b9\ud835\udc65\u00ba\u00ba\nand that the underlying functions \ud835\udc66=\ud835\udc53\u00b9\ud835\udc62\u00baand\ud835\udc62=\ud835\udc54\u00b9\ud835\udc65\u00baare both differentiable. The chain\nrule states that\n\ud835\udc51\ud835\udc66\n\ud835\udc51\ud835\udc65=\ud835\udc51\ud835\udc66\n\ud835\udc51\ud835\udc62\ud835\udc51\ud835\udc62\n\ud835\udc51\ud835\udc65. (2.4.9)\nTurningbacktomultivariatefunctions,supposethat \ud835\udc66=\ud835\udc53\u00b9u\u00bahasvariables \ud835\udc621,\ud835\udc622,...,\ud835\udc62\ud835\udc5a,\nwhere each\ud835\udc62\ud835\udc56=\ud835\udc54\ud835\udc56\u00b9x\u00bahas variables \ud835\udc651,\ud835\udc652,...,\ud835\udc65\ud835\udc5b, i.e.,u=\ud835\udc54\u00b9x\u00ba. Then the chain rule\nstates that\n\ud835\udf15\ud835\udc66\n\ud835\udf15\ud835\udc65\ud835\udc56=\ud835\udf15\ud835\udc66\n\ud835\udf15\ud835\udc621\ud835\udf15\ud835\udc621\n\ud835\udf15\ud835\udc65\ud835\udc56\u00b8\ud835\udf15\ud835\udc66\n\ud835\udf15\ud835\udc622\ud835\udf15\ud835\udc622\n\ud835\udf15\ud835\udc65\ud835\udc56\u00b8...\u00b8\ud835\udf15\ud835\udc66\n\ud835\udf15\ud835\udc62\ud835\udc5a\ud835\udf15\ud835\udc62\ud835\udc5a\n\ud835\udf15\ud835\udc65\ud835\udc56and sorx\ud835\udc66=Aru\ud835\udc66, (2.4.10)\n59 Calculus\n56whereA2R\ud835\udc5b\u0002\ud835\udc5ais amatrixthat contains the derivative of vector uwith respect to vector\nx. Thus, evaluating the gradient requires computing a vector\u2013matrix product. This is one\nof the key reasons why linear algebra is such an integral building block in building deep\nlearning systems.\n2.4.5Discussion\nWhilewehavejustscratchedthesurfaceofadeeptopic,anumberofconceptsalreadycome\nintofocus: first, thecompositionrulesfordifferentiationcanbeappliedroutinely, enabling\nus to compute gradients automatically . This task requires no creativity and thus we can\nfocus our cognitive powers elsewhere. Second, computing the derivatives of vector-valued\nfunctions requires us to multiply matrices as we trace the dependency graph of variables\nfrom output to input.", "mimetype": "text/plain", "start_char_idx": 185386, "end_char_idx": 187676, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cde99be9-3e82-46ec-9f6a-0a27bc6811af": {"__data__": {"id_": "cde99be9-3e82-46ec-9f6a-0a27bc6811af", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "316721c3-b326-431b-a332-9d1da418ee75", "node_type": "1", "metadata": {}, "hash": "28ed963698f4c5e99ac649c2094683d859f800565d7ed39aee39b4cfc77750e2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1b0698fe-d177-4e69-be70-ed13b8bfe470", "node_type": "1", "metadata": {}, "hash": "6e5d9cd55f83237b620d7295b1267a661a11dcae6ac730ec98650880a6561e80", "class_name": "RelatedNodeInfo"}}, "text": "This is one\nof the key reasons why linear algebra is such an integral building block in building deep\nlearning systems.\n2.4.5Discussion\nWhilewehavejustscratchedthesurfaceofadeeptopic,anumberofconceptsalreadycome\nintofocus: first, thecompositionrulesfordifferentiationcanbeappliedroutinely, enabling\nus to compute gradients automatically . This task requires no creativity and thus we can\nfocus our cognitive powers elsewhere. Second, computing the derivatives of vector-valued\nfunctions requires us to multiply matrices as we trace the dependency graph of variables\nfrom output to input. In particular, this graph is traversed in a forward direction when\nwe evaluate a function and in a backwards direction when we compute gradients. Later\nchapters will formally introduce backpropagation, a computational procedure for applying\nthe chain rule.\nFrom the viewpoint of optimization, gradients allow us to determine how to move the pa-\nrametersofamodelinordertolowertheloss, andeachstepoftheoptimizationalgorithms\nused throughout this book will require calculating the gradient.\n2.4.6Exercises\n1.Sofarwetooktherulesforderivativesforgranted. Usingthedefinitionandlimitsprove\nthe properties for (i) \ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc50, (ii)\ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc65\ud835\udc5b, (iii)\ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc52\ud835\udc65and (iv)\ud835\udc53\u00b9\ud835\udc65\u00ba=log\ud835\udc65.\n2.In the same vein, prove the product, sum, and quotient rule from first principles.\n3.Prove that the constant multiple rule follows as a special case of the product rule.\n4.Calculate the derivative of \ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc65\ud835\udc65.\n5.What does it mean that \ud835\udc530\u00b9\ud835\udc65\u00ba=0for some\ud835\udc65? Give an example of a function \ud835\udc53and a\nlocation\ud835\udc65for which this might hold.\n6.Plot the function \ud835\udc66=\ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc653\u00001\n\ud835\udc65and plot its tangent line at \ud835\udc65=1.\n7.Find the gradient of the function \ud835\udc53\u00b9x\u00ba=3\ud835\udc652\n1\u00b85\ud835\udc52\ud835\udc652.\n8.What is the gradient of the function \ud835\udc53\u00b9x\u00ba=kxk2? What happens for x=0?\n9.Can you write out the chain rule for the case where \ud835\udc62=\ud835\udc53\u00b9\ud835\udc65,\ud835\udc66,\ud835\udc67\u00baand\ud835\udc65=\ud835\udc65\u00b9\ud835\udc4e,\ud835\udc4f\u00ba,\n\ud835\udc66=\ud835\udc66\u00b9\ud835\udc4e,\ud835\udc4f\u00ba, and\ud835\udc67=\ud835\udc67\u00b9\ud835\udc4e,\ud835\udc4f\u00ba?\n10.Given a function \ud835\udc53\u00b9\ud835\udc65\u00bathat is invertible, compute the derivative of its inverse \ud835\udc53\u00001\u00b9\ud835\udc65\u00ba.\nHere we have that \ud835\udc53\u00001\u00b9\ud835\udc53\u00b9\ud835\udc65\u00ba\u00ba=\ud835\udc65and conversely \ud835\udc53\u00b9\ud835\udc53\u00001\u00b9\ud835\udc66\u00ba\u00ba=\ud835\udc66. Hint: use these\nproperties in your derivation.\nDiscussions56.\n60 Preliminaries\n2.5AutomaticDifferentiation\nRecallfrom Section2.4 thatcalculatingderivativesisthecrucialstepinalltheoptimization\nalgorithms that we will use to train deep networks. While the calculations are straightfor-\nward,workingthemoutbyhandcanbetediousanderror-prone,andtheseissuesonlygrow\nas our models become more complex.\nFortunately all modern deep learning frameworks take this work off our plates by offering\nautomatic differentiation (often shortened to autograd ). As we pass data through each\nsuccessivefunction,theframeworkbuildsa computationalgraph thattrackshoweachvalue\ndepends on others. To calculate derivatives, automatic differentiation works backwards\nthrough this graph applying the chain rule. The computational algorithm for applying the\nchain rule in this fashion is called backpropagation .\nWhile autograd libraries have become a hot concern over the past decade, they have a\nlong history. In fact the earliest references to autograd date back over half of a century\n(Wengert, 1964 ). The core ideas behind modern backpropagation date to a PhD thesis\nfrom 1980 ( Speelpenning, 1980 ) and were further developed in the late 1980s ( Griewank,\n1989). While backpropagation has become the default method for computing gradients,\nit is not the only option.", "mimetype": "text/plain", "start_char_idx": 187089, "end_char_idx": 190444, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1b0698fe-d177-4e69-be70-ed13b8bfe470": {"__data__": {"id_": "1b0698fe-d177-4e69-be70-ed13b8bfe470", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cde99be9-3e82-46ec-9f6a-0a27bc6811af", "node_type": "1", "metadata": {}, "hash": "2426f94cbaf81b6747c20bc02b950038a2ab1c53a142121437d414a508f86999", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fa9879be-6fb3-4228-a95f-ad6b089adc3d", "node_type": "1", "metadata": {}, "hash": "1778bd02d0bcf0a7cb47a4cb6649b6e0b9d7860688b3d0734f288bd4b9b5e89e", "class_name": "RelatedNodeInfo"}}, "text": "As we pass data through each\nsuccessivefunction,theframeworkbuildsa computationalgraph thattrackshoweachvalue\ndepends on others. To calculate derivatives, automatic differentiation works backwards\nthrough this graph applying the chain rule. The computational algorithm for applying the\nchain rule in this fashion is called backpropagation .\nWhile autograd libraries have become a hot concern over the past decade, they have a\nlong history. In fact the earliest references to autograd date back over half of a century\n(Wengert, 1964 ). The core ideas behind modern backpropagation date to a PhD thesis\nfrom 1980 ( Speelpenning, 1980 ) and were further developed in the late 1980s ( Griewank,\n1989). While backpropagation has become the default method for computing gradients,\nit is not the only option. For instance, the Julia programming language employs forward\npropagation ( Revelsetal., 2016). Before exploring methods, let\u2019s first master the autograd\npackage.\nimport torch\n2.5.1ASimpleFunction\nLet\u2019s assume that we are interested in differentiating the function \ud835\udc66=2x>xwith respect to\nthe column vector x. To start, we assign xan initial value.\nx=torch .arange( 4.0)\nx\ntensor([ 0.,1.,2.,3.])\nBefore we calculate the gradient of \ud835\udc66with respect to x, we need a place to store it. In\ngeneral, we avoid allocating new memory every time we take a derivative because deep\nlearning requires successively computing derivatives with respect to the same parameters\na great many times, and we might risk running out of memory. Note that the gradient of\na scalar-valued function with respect to a vector xis vector-valued with the same shape as\nx.\n61 Automatic Differentiation\n# Can also create x = torch.arange(4.0, requires_grad=True)\nx.requires_grad_( True )\nx.grad # The gradient is None by default\nWe now calculate our function of xand assign the result to y.\ny=2*torch .dot(x, x)\ny\ntensor( 28., grad_fn =<MulBackward0 >)\nWe can now take the gradient of ywith respect to xby calling its backward method. Next,\nwe can access the gradient via x\u2019sgradattribute.\ny.backward()\nx.grad\ntensor([ 0.,4.,8.,12.])\nWe already know that the gradient of the function \ud835\udc66=2x>xwith respect to xshould be\n4x. Wecannowverify thattheautomaticgradientcomputationandtheexpectedresultare\nidentical.\nx.grad ==4*x\ntensor([ True ,True ,True ,True ])\nNow let\u2019s calculate another function of xand take its gradient. Note that PyTorch does not\nautomatically reset the gradient buffer when we record a new gradient. Instead, the new\ngradient is added to the already-stored gradient. This behavior comes in handy when we\nwant to optimize the sum of multiple objective functions. To reset the gradient buffer, we\ncan call x.grad.zero_() as follows:\nx.grad .zero_() # Reset the gradient\ny=x.sum()\ny.backward()\nx.grad\ntensor([ 1.,1.,1.,1.])\n2.5.2BackwardforNon-ScalarVariables\nWhen yis a vector, the most natural representation of the derivative of ywith respect\nto a vector xis a matrix called the Jacobian that contains the partial derivatives of each\n62 Preliminaries\n57component of ywith respect to each component of x. Likewise, for higher-order yandx,\nthe result of differentiation could be an even higher-order tensor.\nWhile Jacobians do show up in some advanced machine learning techniques, more com-\nmonly we want to sum up the gradients of each component of ywith respect to the full\nvector x, yielding a vector of the same shape as x. For example, we often have a vector\nrepresenting the value of our loss function calculated separately for each example among a\nbatchof training examples. Here, we just want to sum up the gradients computed individ-\nually for each example.\nBecause deep learning frameworks vary in how they interpret gradients of non-scalar ten-\nsors, PyTorch takes some steps to avoid confusion. Invoking backward on a non-scalar\nelicits an error unless we tell PyTorch how to reduce the object to a scalar. More formally,\nwe need to provide some vector vsuch that backward will compute v>\ud835\udf15xyrather than\n\ud835\udf15xy. This next part may be confusing, but for reasons that will become clear later, this\nargument (representing v) is named gradient .", "mimetype": "text/plain", "start_char_idx": 189643, "end_char_idx": 193770, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fa9879be-6fb3-4228-a95f-ad6b089adc3d": {"__data__": {"id_": "fa9879be-6fb3-4228-a95f-ad6b089adc3d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1b0698fe-d177-4e69-be70-ed13b8bfe470", "node_type": "1", "metadata": {}, "hash": "6e5d9cd55f83237b620d7295b1267a661a11dcae6ac730ec98650880a6561e80", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7b8794e7-ecc4-4647-b9f1-c3fa2b813a45", "node_type": "1", "metadata": {}, "hash": "47b9c0adb269e9d086c719a1893601c4036a792c40714ec227d61ec1729bbbea", "class_name": "RelatedNodeInfo"}}, "text": "Here, we just want to sum up the gradients computed individ-\nually for each example.\nBecause deep learning frameworks vary in how they interpret gradients of non-scalar ten-\nsors, PyTorch takes some steps to avoid confusion. Invoking backward on a non-scalar\nelicits an error unless we tell PyTorch how to reduce the object to a scalar. More formally,\nwe need to provide some vector vsuch that backward will compute v>\ud835\udf15xyrather than\n\ud835\udf15xy. This next part may be confusing, but for reasons that will become clear later, this\nargument (representing v) is named gradient . For a more detailed description, see Yang\nZhang\u2019s Medium post57.\nx.grad .zero_()\ny=x*x\ny.backward(gradient =torch .ones( len(y))) # Faster: y.sum().backward()\nx.grad\ntensor([ 0.,2.,4.,6.])\n2.5.3DetachingComputation\nSometimes, we wish to move some calculations outside of the recorded computational\ngraph. For example, say that we use the input to create some auxiliary intermediate terms\nfor which we do not want to compute a gradient. In this case, we need to detachthe re-\nspective computational graph from the final result. The following toy example makes this\nclearer: suppose we have z = x * y andy = x * x but we want to focus on the direct\ninfluence of xonzrather than the influence conveyed via y. In this case, we can create a\nnew variable uthat takes the same value as ybut whose provenance (how it was created)\nhasbeenwipedout. Thus uhasnoancestorsinthegraphandgradientsdonotflowthrough\nutox. For example, taking the gradient of z = x * u will yield the result u, (not 3 * x\n* xas you might have expected since z = x * x * x ).\nx.grad .zero_()\ny=x*x\nu=y.detach()\nz=u*x\nz.sum() .backward()\nx.grad ==u\n63 Automatic Differentiation\ntensor([ True ,True ,True ,True ])\nNotethatwhilethisproceduredetaches y\u2019sancestorsfromthegraphleadingto z, thecom-\nputational graph leading to ypersists and thus we can calculate the gradient of ywith\nrespect to x.\nx.grad .zero_()\ny.sum() .backward()\nx.grad ==2*x\ntensor([ True ,True ,True ,True ])\n2.5.4Gradientsand Python ControlFlow\nSo far we reviewed cases where the path from input to output was well defined via a func-\ntion such as z = x * x * x . Programming offers us a lot more freedom in how we\ncompute results. For instance, we can make them depend on auxiliary variables or condi-\ntion choices on intermediate results. One benefit of using automatic differentiation is that\neven if building the computational graph of a function required passing through a maze\nof Python control flow (e.g., conditionals, loops, and arbitrary function calls), we can still\ncalculate the gradient of the resulting variable. To illustrate this, consider the following\ncode snippet where the number of iterations of the whileloop and the evaluation of the if\nstatement both depend on the value of the input a.\ndef f(a):\nb=a*2\nwhile b.norm() <1000 :\nb=b*2\nifb.sum() >0:\nc=b\nelse :\nc=100 *b\nreturn c\nBelow, we call this function, passing in a random value, as input. Since the input is a\nrandom variable, we do not know what form the computational graph will take. However,\nwhenever we execute f(a)on a specific input, we realize a specific computational graph\nand can subsequently run backward .\na=torch .randn(size =(), requires_grad =True )\nd=f(a)\nd.backward()\nEven though our function fis, for demonstration purposes, a bit contrived, its dependence\non the input is quite simple: it is a linearfunction of awith piecewise defined scale. As\n64 Preliminaries\nsuch, f(a) / a is a vector of constant entries and, moreover, f(a) / a needs to match the\ngradient of f(a)with respect to a.\na.grad ==d/a\ntensor( True )\nDynamic control flow is very common in deep learning. For instance, when processing\ntext, the computational graph depends on the length of the input. In these cases, automatic\ndifferentiation becomes vital for statistical modeling since it is impossible to compute the\ngradienta priori.\n2.5.5Discussion\nYou have now gotten a taste of the power of automatic differentiation.", "mimetype": "text/plain", "start_char_idx": 193203, "end_char_idx": 197189, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7b8794e7-ecc4-4647-b9f1-c3fa2b813a45": {"__data__": {"id_": "7b8794e7-ecc4-4647-b9f1-c3fa2b813a45", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fa9879be-6fb3-4228-a95f-ad6b089adc3d", "node_type": "1", "metadata": {}, "hash": "1778bd02d0bcf0a7cb47a4cb6649b6e0b9d7860688b3d0734f288bd4b9b5e89e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6922a4f6-c044-428f-9dd1-585ecabf18fd", "node_type": "1", "metadata": {}, "hash": "b71dc41a3c876e35de39e4d93de7e2c4f152611f50041455bb587b592c73d338", "class_name": "RelatedNodeInfo"}}, "text": "a=torch .randn(size =(), requires_grad =True )\nd=f(a)\nd.backward()\nEven though our function fis, for demonstration purposes, a bit contrived, its dependence\non the input is quite simple: it is a linearfunction of awith piecewise defined scale. As\n64 Preliminaries\nsuch, f(a) / a is a vector of constant entries and, moreover, f(a) / a needs to match the\ngradient of f(a)with respect to a.\na.grad ==d/a\ntensor( True )\nDynamic control flow is very common in deep learning. For instance, when processing\ntext, the computational graph depends on the length of the input. In these cases, automatic\ndifferentiation becomes vital for statistical modeling since it is impossible to compute the\ngradienta priori.\n2.5.5Discussion\nYou have now gotten a taste of the power of automatic differentiation. The development of\nlibraries for calculating derivatives both automatically and efficiently has been a massive\nproductivity booster for deep learning practitioners, liberating them so they can focus on\nless menial. Moreover, autograd lets us design massive models for which pen and paper\ngradient computations would be prohibitively time consuming. Interestingly, while we use\nautograd to optimize models (in a statistical sense) the optimization of autograd libraries\nthemselves(inacomputationalsense)isarichsubjectofvitalinteresttoframeworkdesign-\ners. Here, tools from compilers and graph manipulation are leveraged to compute results\nin the most expedient and memory-efficient manner.\nFor now, try to remember these basics: (i) attach gradients to those variables with respect\nto which we desire derivatives; (ii) record the computation of the target value; (iii) execute\nthe backpropagation function; and (iv) access the resulting gradient.\n2.5.6Exercises\n1.Whyisthesecondderivativemuchmoreexpensivetocomputethanthefirstderivative?\n2.After running the function for backpropagation, immediately run it again and see what\nhappens. Investigate.\n3.In the control flow example where we calculate the derivative of dwith respect to a,\nwhat would happen if we changed the variable ato a random vector or a matrix? At\nthis point, the result of the calculation f(a)is no longer a scalar. What happens to the\nresult? How do we analyze this?\n4.Let\ud835\udc53\u00b9\ud835\udc65\u00ba=sin\u00b9\ud835\udc65\u00ba. Plot the graph of \ud835\udc53and of its derivative \ud835\udc530. Do not exploit the fact\nthat\ud835\udc530\u00b9\ud835\udc65\u00ba=cos\u00b9\ud835\udc65\u00babut rather use automatic differentiation to get the result.\n5.Let\ud835\udc53\u00b9\ud835\udc65\u00ba=\u00b9\u00b9log\ud835\udc652\u00ba\u0001sin\ud835\udc65\u00ba\u00b8\ud835\udc65\u00001. Write out a dependency graph tracing results from\n\ud835\udc65to\ud835\udc53\u00b9\ud835\udc65\u00ba.\n6.Usethechainruletocomputethederivative\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65oftheaforementionedfunction,placing\neach term on the dependency graph that you constructed previously.\n65 Probability and Statistics\n587.Given the graph and the intermediate derivative results, you have a number of options\nwhen computing the gradient. Evaluate the result once starting from \ud835\udc65to\ud835\udc53and once\nfrom\ud835\udc53tracing back to \ud835\udc65. The path from \ud835\udc65to\ud835\udc53is commonly known as forward differ-\nentiation , whereas the path from \ud835\udc53to\ud835\udc65is known as backward differentiation.\n8.When might you want to use forward, and when backward, differentiation? Hint: con-\nsider the amount of intermediate data needed, the ability to parallelize steps, and the\nsize of matrices and vectors involved.\nDiscussions58.\n2.6Probabilityand Statistics\nOne way or another, machine learning is all about uncertainty. In supervised learning, we\nwanttopredictsomethingunknown(the target)givensomethingknown(the features). De-\npending on our objective, we might attempt to predict the most likely value of the target.\nOr we might predict the value with the smallest expected distance from the target. And\nsometimes we wish not only to predict a specific value but to quantifyouruncertainty . For\nexample, given some features describing a patient, we might want to know howlikely they\nare to suffer a heart attack in the next year. In unsupervised learning, we often care about\nuncertainty. To determine whether a set of measurements are anomalous, it helps to know\nhow likely one is to observe values in a population of interest.", "mimetype": "text/plain", "start_char_idx": 196399, "end_char_idx": 200409, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6922a4f6-c044-428f-9dd1-585ecabf18fd": {"__data__": {"id_": "6922a4f6-c044-428f-9dd1-585ecabf18fd", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7b8794e7-ecc4-4647-b9f1-c3fa2b813a45", "node_type": "1", "metadata": {}, "hash": "47b9c0adb269e9d086c719a1893601c4036a792c40714ec227d61ec1729bbbea", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e79670ed-9b31-4781-b8eb-f151aa3b5930", "node_type": "1", "metadata": {}, "hash": "b286aef6543137bf1db979d4c9a660145ee2007391e6b71e21b0e7c0c24262b0", "class_name": "RelatedNodeInfo"}}, "text": "Discussions58.\n2.6Probabilityand Statistics\nOne way or another, machine learning is all about uncertainty. In supervised learning, we\nwanttopredictsomethingunknown(the target)givensomethingknown(the features). De-\npending on our objective, we might attempt to predict the most likely value of the target.\nOr we might predict the value with the smallest expected distance from the target. And\nsometimes we wish not only to predict a specific value but to quantifyouruncertainty . For\nexample, given some features describing a patient, we might want to know howlikely they\nare to suffer a heart attack in the next year. In unsupervised learning, we often care about\nuncertainty. To determine whether a set of measurements are anomalous, it helps to know\nhow likely one is to observe values in a population of interest. Furthermore, in reinforce-\nment learning, we wish to develop agents that act intelligently in various environments.\nThis requires reasoning about how an environment might be expected to change and what\nrewards one might expect to encounter in response to each of the available actions.\nProbability is the mathematical field concerned with reasoning under uncertainty. Given a\nprobabilistic model of some process, we can reason about the likelihood of various events.\nTheuseofprobabilitiestodescribethefrequenciesofrepeatableevents(likecointosses)is\nfairlyuncontroversial. Infact, frequentist scholarsadheretoaninterpretationofprobability\nthat applies onlyto such repeatable events. By contrast Bayesian scholars use the language\nofprobabilitymorebroadlytoformalizereasoningunderuncertainty. Bayesianprobability\nis characterized by two unique features: (i) assigning degrees of belief to non-repeatable\nevents, e.g., what is the probability that a dam will collapse?; and (ii) subjectivity. While\nBayesianprobabilityprovidesunambiguousrulesforhowoneshouldupdatetheirbeliefsin\nlight of new evidence, it allows for different individuals to start off with different priorbe-\nliefs.Statistics helps us to reason backwards, starting off with collection and organization\nof data and backing out to what inferences we might draw about the process that generated\nthe data. Whenever we analyze a dataset, hunting for patterns that we hope might charac-\nterize a broader population, we are employing statistical thinking. Many courses, majors,\ntheses, careers, departments, companies, and institutions have been devoted to the study of\nprobabilityand statistics. While thissection onlyscratchesthe surface, wewill providethe\nfoundation that you need to begin building models.\n66 Preliminaries\n%matplotlib inline\nimport random\nimport torch\nfrom torch .distributions .multinomial import Multinomial\nfrom d2l import torch asd2l\n2.6.1A SimpleExample: TossingCoins\nImagine that we plan to toss a coin and want to quantify how likely we are to see heads\n(vs. tails). If the coin is fair, then both outcomes (heads and tails), are equally likely.\nMoreover if we plan to toss the coin \ud835\udc5btimes then the fraction of heads that we expectto\nsee should exactly match the expected fraction of tails. One intuitive way to see this is\nby symmetry: for every possible outcome with \ud835\udc5bhheads and\ud835\udc5bt=\u00b9\ud835\udc5b\u0000\ud835\udc5bh\u00batails, there is\nan equally likely outcome with \ud835\udc5btheads and\ud835\udc5bhtails. Note that this is only possible if on\naverage we expect to see 1\u009d2of tosses come up heads and 1\u009d2come up tails. Of course, if\nyou conduct this experiment many times with \ud835\udc5b=1000000 tosses each, you might never\nsee a trial where \ud835\udc5bh=\ud835\udc5btexactly.\nFormally, the quantity 1\u009d2is called a probability and here it captures the certainty with\nwhich any given toss will come up heads. Probabilities assign scores between 0and1to\noutcomes of interest, called events. Here the event of interest is heads and we denote the\ncorrespondingprobability \ud835\udc43\u00b9heads\u00ba. Aprobabilityof 1indicatesabsolutecertainty(imag-\nine a trick coin where both sides were heads) and a probability of 0indicates impossibility\n(e.g.,ifbothsidesweretails). Thefrequencies \ud835\udc5bh\u009d\ud835\udc5band\ud835\udc5bt\u009d\ud835\udc5barenotprobabilitiesbutrather\nstatistics . Probabilities are theoretical quantities that underly the data generating process.\nHere,theprobability 1\u009d2isapropertyofthecoinitself.", "mimetype": "text/plain", "start_char_idx": 199593, "end_char_idx": 203762, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e79670ed-9b31-4781-b8eb-f151aa3b5930": {"__data__": {"id_": "e79670ed-9b31-4781-b8eb-f151aa3b5930", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6922a4f6-c044-428f-9dd1-585ecabf18fd", "node_type": "1", "metadata": {}, "hash": "b71dc41a3c876e35de39e4d93de7e2c4f152611f50041455bb587b592c73d338", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f46655c2-ca05-46e2-ad04-1ab74fde8d60", "node_type": "1", "metadata": {}, "hash": "0ab27203901daee8c56c3636cba481436eb9648485e8d1a5c6c0a146c1de9cd4", "class_name": "RelatedNodeInfo"}}, "text": "Formally, the quantity 1\u009d2is called a probability and here it captures the certainty with\nwhich any given toss will come up heads. Probabilities assign scores between 0and1to\noutcomes of interest, called events. Here the event of interest is heads and we denote the\ncorrespondingprobability \ud835\udc43\u00b9heads\u00ba. Aprobabilityof 1indicatesabsolutecertainty(imag-\nine a trick coin where both sides were heads) and a probability of 0indicates impossibility\n(e.g.,ifbothsidesweretails). Thefrequencies \ud835\udc5bh\u009d\ud835\udc5band\ud835\udc5bt\u009d\ud835\udc5barenotprobabilitiesbutrather\nstatistics . Probabilities are theoretical quantities that underly the data generating process.\nHere,theprobability 1\u009d2isapropertyofthecoinitself. Bycontrast,statisticsare empirical\nquantities that are computed as functions of the observed data. Our interests in probabilis-\ntic and statistical quantities are inextricably intertwined. We often design special statistics\ncalledestimators that,givenadataset,produce estimates ofmodelparameterssuchasprob-\nabilities. Moreover, when those estimators satisfy a nice property called consistency , our\nestimates will converge to the corresponding probability. In turn, these inferred probabili-\ntiestellaboutthelikelystatisticalpropertiesofdatafromthesamepopulationthatwemight\nencounter in the future.\nSuppose that we stumbled upon a real coin for which we did not know the true \ud835\udc43\u00b9heads\u00ba.\nTo investigate this quantity with statistical methods, we need to (i) collect some data; and\n(ii) design an estimator. Data acquisition here is easy; we can toss the coin many times\nandrecordalltheoutcomes. Formally, drawingrealizationsfromsomeunderlyingrandom\nprocess is called sampling . As you might have guessed, one natural estimator is the ratio\nof the number of observed headsto the total number of tosses.\nNow, suppose that the coin was in fact fair, i.e., \ud835\udc43\u00b9heads\u00ba=0.5. To simulate tosses of a\nfair coin, we can invoke any random number generator. There are some easy ways to draw\nsamples of an event with probability 0.5. For example Python\u2019s random.random yields\nnumbers in the interval \u00bb0,1\u00bcwhere the probability of lying in any sub-interval \u00bb\ud835\udc4e,\ud835\udc4f\u00bc\u001a\n67 Probability and Statistics\n\u00bb0,1\u00bcis equal to\ud835\udc4f\u0000\ud835\udc4e. Thus we can get out 0and1with probability 0.5each by testing\nwhether the returned float number is greater than 0.5:\nnum_tosses =100\nheads =sum([random .random() >0.5 for _inrange (num_tosses)])\ntails =num_tosses -heads\nprint (\"heads, tails: \", [heads, tails])\nheads, tails: [ 44,56]\nMore generally, we can simulate multiple draws from any variable with a finite number\nof possible outcomes (like the toss of a coin or roll of a die) by calling the multinomial\nfunction, setting the first argument to the number of draws and the second as a list of prob-\nabilitiesassociatedwitheachofthepossibleoutcomes. Tosimulatetentossesofafaircoin,\nweassignprobabilityvector [0.5, 0.5] ,interpretingindex0asheadsandindex1astails.\nThe function returns a vector with length equal to the number of possible outcomes (here,\n2), where the first component tells us the number of occurrences of heads and the second\ncomponent tells us the number of occurrences of tails.\nfair_probs =torch .tensor([ 0.5,0.5])\nMultinomial( 100, fair_probs) .sample()\ntensor([ 50.,50.])\nEach time you run this sampling process, you will receive a new random value that may\ndiffer from the previous outcome. Dividing by the number of tosses gives us the frequency\nofeachoutcomeinourdata. Notethatthesefrequencies,justliketheprobabilitiesthatthey\nare intended to estimate, sum to 1.\nMultinomial( 100, fair_probs) .sample() /100\ntensor([ 0.4800 ,0.5200 ])\nHere, even though our simulated coin is fair (we ourselves set the probabilities [0.5, 0.\n5]), the counts of heads and tails may not be identical. That is because we only drew a\nrelatively small number of samples.", "mimetype": "text/plain", "start_char_idx": 203090, "end_char_idx": 206888, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f46655c2-ca05-46e2-ad04-1ab74fde8d60": {"__data__": {"id_": "f46655c2-ca05-46e2-ad04-1ab74fde8d60", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e79670ed-9b31-4781-b8eb-f151aa3b5930", "node_type": "1", "metadata": {}, "hash": "b286aef6543137bf1db979d4c9a660145ee2007391e6b71e21b0e7c0c24262b0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1c190347-aaeb-48ad-99c3-a88551674f17", "node_type": "1", "metadata": {}, "hash": "79d2d27e650d5efe1a0d45776dee355b548f12fc176258ef24119d88d958eb3c", "class_name": "RelatedNodeInfo"}}, "text": "fair_probs =torch .tensor([ 0.5,0.5])\nMultinomial( 100, fair_probs) .sample()\ntensor([ 50.,50.])\nEach time you run this sampling process, you will receive a new random value that may\ndiffer from the previous outcome. Dividing by the number of tosses gives us the frequency\nofeachoutcomeinourdata. Notethatthesefrequencies,justliketheprobabilitiesthatthey\nare intended to estimate, sum to 1.\nMultinomial( 100, fair_probs) .sample() /100\ntensor([ 0.4800 ,0.5200 ])\nHere, even though our simulated coin is fair (we ourselves set the probabilities [0.5, 0.\n5]), the counts of heads and tails may not be identical. That is because we only drew a\nrelatively small number of samples. If we did not implement the simulation ourselves, and\nonlysawtheoutcome,howwouldweknowifthecoinwereslightlyunfairorifthepossible\ndeviation from 1\u009d2was just an artifact of the small sample size? Let\u2019s see what happens\nwhen we simulate 10,000 tosses.\ncounts =Multinomial( 10000 , fair_probs) .sample()\ncounts /10000\n68 Preliminaries\ntensor([ 0.4966 ,0.5034 ])\nIn general, for averages of repeated events (like coin tosses), as the number of repetitions\ngrows, our estimates are guaranteed to converge to the true underlying probabilities. The\nmathematical formulation of this phenomenon is called the law of large numbers and the\ncentral limit theorem tells us that in many situations, as the sample size \ud835\udc5bgrows, these\nerrors should go down at a rate of \u00b91\u009dp\ud835\udc5b\u00ba. Let\u2019s get some more intuition by studying how\nour estimate evolves as we grow the number of tosses from 1 to 10,000.\ncounts =Multinomial( 1, fair_probs) .sample(( 10000 ,))\ncum_counts =counts .cumsum(dim =0)\nestimates =cum_counts /cum_counts .sum(dim =1, keepdims =True )\nestimates =estimates .numpy()\nd2l.set_figsize(( 4.5,3.5))\nd2l.plt.plot(estimates[:, 0], label =(\"P(coin=heads) \"))\nd2l.plt.plot(estimates[:, 1], label =(\"P(coin=tails) \"))\nd2l.plt.axhline(y =0.5, color ='black ', linestyle ='dashed ')\nd2l.plt.gca() .set_xlabel( 'Samples ')\nd2l.plt.gca() .set_ylabel( 'Estimated probability ')\nd2l.plt.legend();\nEach solid curve corresponds to one of the two values of the coin and gives our estimated\nprobability that the coin turns up that value after each group of experiments. The dashed\nblack line gives the true underlying probability. As we get more data by conducting more\nexperiments, the curves converge towards the true probability. You might already begin to\nsee the shape of some of the more advanced questions that preoccupy statisticians: How\nquickly does this convergence happen? If we had already tested many coins manufactured\nat the same plant, how might we incorporate this information?\n2.6.2A MoreFormalTreatment\nWe have already gotten pretty far: posing a probabilistic model, generating synthetic data,\nrunning a statistical estimator, empirically assessing convergence, and reporting error met-\n69 Probability and Statistics\nrics (checking the deviation). However, to go much further, we will need to be more pre-\ncise.\nWhen dealing with randomness, we denote the set of possible outcomes Sand call it the\nsample space oroutcome space . Here, each element is a distinct possible outcome . In\nthe case of rolling a single coin, S=fheads,tailsg. For a single die,S=f1,2,3,4,5,6g.\nWhenflippingtwocoins,possibleoutcomesare f\u00b9heads,heads\u00ba,\u00b9heads,tails\u00ba,\u00b9tails,heads\u00ba,\u00b9tails,tails\u00bag.\nEventsare subsets of the sample space. For instance, the event \u201cthe first coin toss comes\nup heads\u201d corresponds to the set f\u00b9heads,heads\u00ba,\u00b9heads,tails\u00bag. Whenever the outcome\n\ud835\udc67of a random experiment satisfies \ud835\udc672A, then eventAhas occurred. For a single roll\nof a die, we could define the events \u201cseeing a 5\u201d (A=f5g) and \u201cseeing an odd number\u201d\n(B=f1,3,5g).", "mimetype": "text/plain", "start_char_idx": 206212, "end_char_idx": 209910, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1c190347-aaeb-48ad-99c3-a88551674f17": {"__data__": {"id_": "1c190347-aaeb-48ad-99c3-a88551674f17", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f46655c2-ca05-46e2-ad04-1ab74fde8d60", "node_type": "1", "metadata": {}, "hash": "0ab27203901daee8c56c3636cba481436eb9648485e8d1a5c6c0a146c1de9cd4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e501b0d0-616c-48d3-87f6-fe53165a682c", "node_type": "1", "metadata": {}, "hash": "f935c4770aad57955f4777f51a3b87c8bcc8f04f7823d211a63f5b18295f2dbe", "class_name": "RelatedNodeInfo"}}, "text": "Here, each element is a distinct possible outcome . In\nthe case of rolling a single coin, S=fheads,tailsg. For a single die,S=f1,2,3,4,5,6g.\nWhenflippingtwocoins,possibleoutcomesare f\u00b9heads,heads\u00ba,\u00b9heads,tails\u00ba,\u00b9tails,heads\u00ba,\u00b9tails,tails\u00bag.\nEventsare subsets of the sample space. For instance, the event \u201cthe first coin toss comes\nup heads\u201d corresponds to the set f\u00b9heads,heads\u00ba,\u00b9heads,tails\u00bag. Whenever the outcome\n\ud835\udc67of a random experiment satisfies \ud835\udc672A, then eventAhas occurred. For a single roll\nof a die, we could define the events \u201cseeing a 5\u201d (A=f5g) and \u201cseeing an odd number\u201d\n(B=f1,3,5g). Inthiscase,ifthediecameup 5,wewouldsaythatboth AandBoccurred.\nOn the other hand, if \ud835\udc67=3, thenAdid not occur butBdid.\nAprobability function maps events onto real values \ud835\udc43:A\u0012S!\u00bb 0,1\u00bc. The probabil-\nity, denoted \ud835\udc43\u00b9A\u00ba, of an eventAin the given sample space S, has the following proper-\nties:\n\u000fThe probability of any event Ais a nonnegative real number, i.e., \ud835\udc43\u00b9A\u00ba\u0015 0;\n\u000fThe probability of the entire sample space is 1, i.e.,\ud835\udc43\u00b9S\u00ba=1;\n\u000fFor any countable sequence of events A1,A2,...that aremutuallyexclusive (i.e.,A\ud835\udc56\\\nA\ud835\udc57=;for all\ud835\udc56\u2260\ud835\udc57), the probability that any of them happens is equal to the sum of\ntheir individual probabilities, i.e., \ud835\udc43\u00b9\u00d01\n\ud835\udc56=1A\ud835\udc56\u00ba=\u00cd1\n\ud835\udc56=1\ud835\udc43\u00b9A\ud835\udc56\u00ba.\nThese axioms of probability theory, proposed by Kolmogorov ( 1933), can be applied to\nrapidly derive a number of important consequences. For instance, it follows immediately\nthattheprobabilityofanyevent AoritscomplementA0occurringis1(because A[A0=\nS). We can also prove that \ud835\udc43\u00b9;\u00ba=0because 1=\ud835\udc43\u00b9S[S0\u00ba=\ud835\udc43\u00b9S[;\u00ba =\ud835\udc43\u00b9S\u00ba\u00b8\ud835\udc43\u00b9;\u00ba=\n1\u00b8\ud835\udc43\u00b9;\u00ba. Consequently, the probability of any event Aandits complementA0occurring\nsimultaneouslyis \ud835\udc43\u00b9A\\A0\u00ba=0. Informally,thistellsusthatimpossibleeventshavezero\nprobability of occurring.\n2.6.3RandomVariables\nWhen we spoke about events like the roll of a die coming up odds or the first coin toss\ncoming up heads, we were invoking the idea of a random variable . Formally, random\nvariablesaremappingsfromanunderlyingsamplespacetoasetof(possiblymany)values.\nYoumightwonderhowarandomvariableisdifferentfromthesamplespace,sincebothare\ncollections of outcomes. Importantly, random variables can be much coarser than the raw\nsample space. We can define a binary random variable like \u201cgreater than 0.5\u201d even when\nthe underlying sample space is infinite, e.g., points on the line segment between 0and1.\nAdditionally, multiple random variables can share the same underlying sample space. For\nexample\u201cwhethermyhomealarmgoesoff\u201dand\u201cwhethermyhousewasburgled\u201dareboth\nbinaryrandomvariablesthatshareanunderlyingsamplespace. Consequently,knowingthe\nvalue taken by one random variable can tell us something about the likely value of another\n70 Preliminaries\nrandom variable. Knowing that the alarm went off, we might suspect that the house was\nlikely burgled.\nEvery value taken by a random variable corresponds to a subset of the underlying sample\nspace. Thus the occurrence where the random variable \ud835\udc4btakes value\ud835\udc63, denoted by \ud835\udc4b=\ud835\udc63,\nis aneventand\ud835\udc43\u00b9\ud835\udc4b=\ud835\udc63\u00badenotes its probability. Sometimes this notation can get clunky,\nand we can abuse notation when the context is clear. For example, we might use \ud835\udc43\u00b9\ud835\udc4b\u00bato\nrefer broadly to the distribution of\ud835\udc4b, i.e., the function that tells us the probability that \ud835\udc4b\ntakes any given value.", "mimetype": "text/plain", "start_char_idx": 209315, "end_char_idx": 212584, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e501b0d0-616c-48d3-87f6-fe53165a682c": {"__data__": {"id_": "e501b0d0-616c-48d3-87f6-fe53165a682c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1c190347-aaeb-48ad-99c3-a88551674f17", "node_type": "1", "metadata": {}, "hash": "79d2d27e650d5efe1a0d45776dee355b548f12fc176258ef24119d88d958eb3c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c26cff40-8464-4055-b45f-9244e5378bb2", "node_type": "1", "metadata": {}, "hash": "2d1b3fa4e7bc0820507d198ee5f8da9f4dc3032a95bd7bdec40fa6fa5d844b64", "class_name": "RelatedNodeInfo"}}, "text": "Consequently,knowingthe\nvalue taken by one random variable can tell us something about the likely value of another\n70 Preliminaries\nrandom variable. Knowing that the alarm went off, we might suspect that the house was\nlikely burgled.\nEvery value taken by a random variable corresponds to a subset of the underlying sample\nspace. Thus the occurrence where the random variable \ud835\udc4btakes value\ud835\udc63, denoted by \ud835\udc4b=\ud835\udc63,\nis aneventand\ud835\udc43\u00b9\ud835\udc4b=\ud835\udc63\u00badenotes its probability. Sometimes this notation can get clunky,\nand we can abuse notation when the context is clear. For example, we might use \ud835\udc43\u00b9\ud835\udc4b\u00bato\nrefer broadly to the distribution of\ud835\udc4b, i.e., the function that tells us the probability that \ud835\udc4b\ntakes any given value. Other times we write expressions like \ud835\udc43\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=\ud835\udc43\u00b9\ud835\udc4b\u00ba\ud835\udc43\u00b9\ud835\udc4c\u00ba, as a\nshorthand to express a statement that is true for all of the values that the random variables\n\ud835\udc4band\ud835\udc4ccan take, i.e., for all \ud835\udc56,\ud835\udc57it holds that \ud835\udc43\u00b9\ud835\udc4b=\ud835\udc56and\ud835\udc4c=\ud835\udc57\u00ba=\ud835\udc43\u00b9\ud835\udc4b=\ud835\udc56\u00ba\ud835\udc43\u00b9\ud835\udc4c=\ud835\udc57\u00ba.\nOthertimes, weabusenotationbywriting \ud835\udc43\u00b9\ud835\udc63\u00bawhentherandomvariableisclearfromthe\ncontext. Since an event in probability theory is a set of outcomes from the sample space,\nwecanspecifyarangeofvaluesforarandomvariabletotake. Forexample, \ud835\udc43\u00b91\u0014\ud835\udc4b\u00143\u00ba\ndenotes the probability of the event f1\u0014\ud835\udc4b\u00143g.\nNote that there is a subtle difference between discrete random variables, like flips of a coin\nor tosses of a die, and continuous ones, like the weight and the height of a person sampled\nat random from the population. In this case we seldom really care about someone\u2019s exact\nheight. Moreover, if we took precise enough measurements, we would find that no two\npeople on the planet have the exact same height. In fact, with fine enough measurements,\nyou would never have the same height when you wake up and when you go to sleep. There\nislittlepointinaskingabouttheexactprobabilitythatsomeoneis1.801392782910287192\nmeters tall. Instead, we typically care more about being able to say whether someone\u2019s\nheightfallsintoagiveninterval, saybetween1.79and1.81meters. Inthesecaseswework\nwithprobability densities . Theheightofexactly1.80metershasnoprobability,butnonzero\ndensity. Toworkouttheprobabilityassignedtoaninterval, wemusttakean integralofthe\ndensity over that interval.\n2.6.4MultipleRandom Variables\nYoumighthavenoticedthatwecouldnotevenmakeitthroughtheprevioussectionwithout\nmakingstatementsinvolvinginteractionsamongmultiplerandomvariables(recall \ud835\udc43\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=\n\ud835\udc43\u00b9\ud835\udc4b\u00ba\ud835\udc43\u00b9\ud835\udc4c\u00ba). Mostofmachinelearningisconcernedwithsuchrelationships. Here,thesam-\nple space would be the population of interest, say customers who transact with a business,\nphotographs on the Internet, or proteins known to biologists. Each random variable would\nrepresent the (unknown) value of a different attribute. Whenever we sample an individual\nfrom the population, we observe a realization of each of the random variables. Because\nthe values taken by random variables correspond to subsets of the sample space that could\nbe overlapping, partially overlapping, or entirely disjoint, knowing the value taken by one\nrandom variable can cause us to update our beliefs about which values of another random\nvariable are likely. If a patient walks into a hospital and we observe that they are having\ntrouble breathing and have lost their sense of smell, then we believe that they are more\nlikely to have COVID-19 than we might if they had no trouble breathing and a perfectly\nordinary sense of smell.\nWhen working with multiple random variables, we can construct events corresponding to\n71 Probability and Statistics\nevery combination of values that the variables can jointly take. The probability function\nthatassignsprobabilitiestoeachofthesecombinations(e.g.", "mimetype": "text/plain", "start_char_idx": 211891, "end_char_idx": 215515, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c26cff40-8464-4055-b45f-9244e5378bb2": {"__data__": {"id_": "c26cff40-8464-4055-b45f-9244e5378bb2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e501b0d0-616c-48d3-87f6-fe53165a682c", "node_type": "1", "metadata": {}, "hash": "f935c4770aad57955f4777f51a3b87c8bcc8f04f7823d211a63f5b18295f2dbe", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "08a42b27-547d-43fe-9b39-3d5c810c3fa2", "node_type": "1", "metadata": {}, "hash": "9c4160fef1983eb4fd432815eb6abbf775e2a22d49f40ccb0d193b77c2c2defe", "class_name": "RelatedNodeInfo"}}, "text": "Whenever we sample an individual\nfrom the population, we observe a realization of each of the random variables. Because\nthe values taken by random variables correspond to subsets of the sample space that could\nbe overlapping, partially overlapping, or entirely disjoint, knowing the value taken by one\nrandom variable can cause us to update our beliefs about which values of another random\nvariable are likely. If a patient walks into a hospital and we observe that they are having\ntrouble breathing and have lost their sense of smell, then we believe that they are more\nlikely to have COVID-19 than we might if they had no trouble breathing and a perfectly\nordinary sense of smell.\nWhen working with multiple random variables, we can construct events corresponding to\n71 Probability and Statistics\nevery combination of values that the variables can jointly take. The probability function\nthatassignsprobabilitiestoeachofthesecombinations(e.g. \ud835\udc34=\ud835\udc4eand\ud835\udc35=\ud835\udc4f)iscalledthe\njoint probability function and simply returns the probability assigned to the intersection\nof the corresponding subsets of the sample space. The joint probability assigned to the\nevent where random variables \ud835\udc34and\ud835\udc35take values\ud835\udc4eand\ud835\udc4f, respectively, is denoted \ud835\udc43\u00b9\ud835\udc34=\n\ud835\udc4e,\ud835\udc35=\ud835\udc4f\u00ba, where the comma indicates \u201cand\u201d. Note that for any values \ud835\udc4eand\ud835\udc4f, it follows\nthat\n\ud835\udc43\u00b9\ud835\udc34=\ud835\udc4e,\ud835\udc35=\ud835\udc4f\u00ba\u0014\ud835\udc43\u00b9\ud835\udc34=\ud835\udc4e\u00baand\ud835\udc43\u00b9\ud835\udc34=\ud835\udc4e,\ud835\udc35=\ud835\udc4f\u00ba\u0014\ud835\udc43\u00b9\ud835\udc35=\ud835\udc4f\u00ba, (2.6.1)\nsince for\ud835\udc34=\ud835\udc4eand\ud835\udc35=\ud835\udc4fto happen,\ud835\udc34=\ud835\udc4ehas to happen and\ud835\udc35=\ud835\udc4falso has to\nhappen. Interestingly,thejointprobabilitytellsusallthatwecanknowabouttheserandom\nvariables in a probabilistic sense, and can be used to derive many other useful quantities,\nincluding recovering the individual distributions \ud835\udc43\u00b9\ud835\udc34\u00baand\ud835\udc43\u00b9\ud835\udc35\u00ba. To recover \ud835\udc43\u00b9\ud835\udc34=\ud835\udc4e\u00ba\nwe simply sum up \ud835\udc43\u00b9\ud835\udc34=\ud835\udc4e,\ud835\udc35=\ud835\udc63\u00baover all values \ud835\udc63that the random variable \ud835\udc35can take:\n\ud835\udc43\u00b9\ud835\udc34=\ud835\udc4e\u00ba=\u00cd\n\ud835\udc63\ud835\udc43\u00b9\ud835\udc34=\ud835\udc4e,\ud835\udc35=\ud835\udc63\u00ba.\nThe ratio\ud835\udc43\u00b9\ud835\udc34=\ud835\udc4e,\ud835\udc35=\ud835\udc4f\u00ba\n\ud835\udc43\u00b9\ud835\udc34=\ud835\udc4e\u00ba\u00141turns out to be extremely important. It is called the conditional\nprobability , and is denoted via the \u201c j\u201d symbol:\n\ud835\udc43\u00b9\ud835\udc35=\ud835\udc4fj\ud835\udc34=\ud835\udc4e\u00ba=\ud835\udc43\u00b9\ud835\udc34=\ud835\udc4e,\ud835\udc35=\ud835\udc4f\u00ba\u009d\ud835\udc43\u00b9\ud835\udc34=\ud835\udc4e\u00ba. (2.6.2)\nIt tells us the new probability associated with the event \ud835\udc35=\ud835\udc4f, once we condition on the\nfact\ud835\udc34=\ud835\udc4etook place. We can think of this conditional probability as restricting attention\nonlytothesubsetofthesamplespaceassociatedwith \ud835\udc34=\ud835\udc4eandthenrenormalizingsothat\nall probabilities sum to 1. Conditional probabilities are in fact just ordinary probabilities\nand thus respect all of the axioms, as long as we condition all terms on the same event and\nthus restrict attention to the same sample space. For instance, for disjoint events BandB0,\nwe have that \ud835\udc43\u00b9B[B0j\ud835\udc34=\ud835\udc4e\u00ba=\ud835\udc43\u00b9Bj\ud835\udc34=\ud835\udc4e\u00ba\u00b8\ud835\udc43\u00b9B0j\ud835\udc34=\ud835\udc4e\u00ba.\nUsing the definition of conditional probabilities, we can derive the famous result called\nBayes\u2019 theorem . By construction, we have that \ud835\udc43\u00b9\ud835\udc34,\ud835\udc35\u00ba=\ud835\udc43\u00b9\ud835\udc35j\ud835\udc34\u00ba\ud835\udc43\u00b9\ud835\udc34\u00baand\ud835\udc43\u00b9\ud835\udc34,\ud835\udc35\u00ba=\n\ud835\udc43\u00b9\ud835\udc34j\ud835\udc35\u00ba\ud835\udc43\u00b9\ud835\udc35\u00ba.", "mimetype": "text/plain", "start_char_idx": 214572, "end_char_idx": 217288, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "08a42b27-547d-43fe-9b39-3d5c810c3fa2": {"__data__": {"id_": "08a42b27-547d-43fe-9b39-3d5c810c3fa2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c26cff40-8464-4055-b45f-9244e5378bb2", "node_type": "1", "metadata": {}, "hash": "2d1b3fa4e7bc0820507d198ee5f8da9f4dc3032a95bd7bdec40fa6fa5d844b64", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "23da883a-4603-46ce-b19d-cc43b4a02543", "node_type": "1", "metadata": {}, "hash": "9aae21802aaec26153f78de350205ee1a08f642939a5b3831c4517dcd593f6be", "class_name": "RelatedNodeInfo"}}, "text": "Conditional probabilities are in fact just ordinary probabilities\nand thus respect all of the axioms, as long as we condition all terms on the same event and\nthus restrict attention to the same sample space. For instance, for disjoint events BandB0,\nwe have that \ud835\udc43\u00b9B[B0j\ud835\udc34=\ud835\udc4e\u00ba=\ud835\udc43\u00b9Bj\ud835\udc34=\ud835\udc4e\u00ba\u00b8\ud835\udc43\u00b9B0j\ud835\udc34=\ud835\udc4e\u00ba.\nUsing the definition of conditional probabilities, we can derive the famous result called\nBayes\u2019 theorem . By construction, we have that \ud835\udc43\u00b9\ud835\udc34,\ud835\udc35\u00ba=\ud835\udc43\u00b9\ud835\udc35j\ud835\udc34\u00ba\ud835\udc43\u00b9\ud835\udc34\u00baand\ud835\udc43\u00b9\ud835\udc34,\ud835\udc35\u00ba=\n\ud835\udc43\u00b9\ud835\udc34j\ud835\udc35\u00ba\ud835\udc43\u00b9\ud835\udc35\u00ba. Combining both equations yields \ud835\udc43\u00b9\ud835\udc35j\ud835\udc34\u00ba\ud835\udc43\u00b9\ud835\udc34\u00ba=\ud835\udc43\u00b9\ud835\udc34j\ud835\udc35\u00ba\ud835\udc43\u00b9\ud835\udc35\u00baand\nhence\n\ud835\udc43\u00b9\ud835\udc34j\ud835\udc35\u00ba=\ud835\udc43\u00b9\ud835\udc35j\ud835\udc34\u00ba\ud835\udc43\u00b9\ud835\udc34\u00ba\n\ud835\udc43\u00b9\ud835\udc35\u00ba. (2.6.3)\nThis simple equation has profound implications because it allows us to reverse the order of\nconditioning. Ifweknowhowtoestimate \ud835\udc43\u00b9\ud835\udc35j\ud835\udc34\u00ba,\ud835\udc43\u00b9\ud835\udc34\u00ba,and\ud835\udc43\u00b9\ud835\udc35\u00ba,thenwecanestimate\n\ud835\udc43\u00b9\ud835\udc34j\ud835\udc35\u00ba. We often find it easier to estimate one term directly but not the other and Bayes\u2019\ntheoremcancometotherescuehere. Forinstance,ifweknowtheprevalenceofsymptoms\nfor a given disease, and the overall prevalences of the disease and symptoms, respectively,\nwe can determine how likely someone is to have the disease based on their symptoms. In\nsome cases we might not have direct access to \ud835\udc43\u00b9\ud835\udc35\u00ba, such as the prevalence of symptoms.\nIn this case a simplified version of Bayes\u2019 theorem comes in handy:\n\ud835\udc43\u00b9\ud835\udc34j\ud835\udc35\u00ba/\ud835\udc43\u00b9\ud835\udc35j\ud835\udc34\u00ba\ud835\udc43\u00b9\ud835\udc34\u00ba. (2.6.4)\n72 Preliminaries\nSince we know that \ud835\udc43\u00b9\ud835\udc34j\ud835\udc35\u00bamust be normalized to 1, i.e.,\u00cd\n\ud835\udc4e\ud835\udc43\u00b9\ud835\udc34=\ud835\udc4ej\ud835\udc35\u00ba=1, we can\nuse it to compute\n\ud835\udc43\u00b9\ud835\udc34j\ud835\udc35\u00ba=\ud835\udc43\u00b9\ud835\udc35j\ud835\udc34\u00ba\ud835\udc43\u00b9\ud835\udc34\u00ba\u00cd\n\ud835\udc4e\ud835\udc43\u00b9\ud835\udc35j\ud835\udc34=\ud835\udc4e\u00ba\ud835\udc43\u00b9\ud835\udc34=\ud835\udc4e\u00ba. (2.6.5)\nIn Bayesian statistics, we think of an observer as possessing some (subjective) prior be-\nliefs about the plausibility of the available hypotheses encoded in the prior\ud835\udc43\u00b9\ud835\udc3b\u00ba, and a\nlikelihood function that says how likely one is to observe any value of the collected evi-\ndence for each of the hypotheses in the class \ud835\udc43\u00b9\ud835\udc38j\ud835\udc3b\u00ba. Bayes\u2019 theorem is then interpreted\nas telling us how to update the initial prior\ud835\udc43\u00b9\ud835\udc3b\u00bain light of the available evidence \ud835\udc38to\nproduceposterior beliefs\ud835\udc43\u00b9\ud835\udc3bj\ud835\udc38\u00ba=\ud835\udc43\u00b9\ud835\udc38j\ud835\udc3b\u00ba\ud835\udc43\u00b9\ud835\udc3b\u00ba\n\ud835\udc43\u00b9\ud835\udc38\u00ba. Informally, this can be stated as \u201cpos-\nterior equals prior times likelihood, divided by the evidence\u201d. Now, because the evidence\n\ud835\udc43\u00b9\ud835\udc38\u00bais the same for all hypotheses, we can get away with simply normalizing over the\nhypotheses.\nNote that\u00cd\n\ud835\udc4e\ud835\udc43\u00b9\ud835\udc34=\ud835\udc4ej\ud835\udc35\u00ba=1also allows us to marginalize over random variables.\nThat is, we can drop variables from a joint distribution such as \ud835\udc43\u00b9\ud835\udc34,\ud835\udc35\u00ba.", "mimetype": "text/plain", "start_char_idx": 216817, "end_char_idx": 219103, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "23da883a-4603-46ce-b19d-cc43b4a02543": {"__data__": {"id_": "23da883a-4603-46ce-b19d-cc43b4a02543", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "08a42b27-547d-43fe-9b39-3d5c810c3fa2", "node_type": "1", "metadata": {}, "hash": "9c4160fef1983eb4fd432815eb6abbf775e2a22d49f40ccb0d193b77c2c2defe", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4dfa06ed-5258-4af2-9845-6f8d123589fe", "node_type": "1", "metadata": {}, "hash": "989941d7fa2bd1e12af92f1cca6607ec132c2c390b1fb007413b65d485e7af69", "class_name": "RelatedNodeInfo"}}, "text": "Informally, this can be stated as \u201cpos-\nterior equals prior times likelihood, divided by the evidence\u201d. Now, because the evidence\n\ud835\udc43\u00b9\ud835\udc38\u00bais the same for all hypotheses, we can get away with simply normalizing over the\nhypotheses.\nNote that\u00cd\n\ud835\udc4e\ud835\udc43\u00b9\ud835\udc34=\ud835\udc4ej\ud835\udc35\u00ba=1also allows us to marginalize over random variables.\nThat is, we can drop variables from a joint distribution such as \ud835\udc43\u00b9\ud835\udc34,\ud835\udc35\u00ba. After all, we have\nthat\n\u00d5\n\ud835\udc4e\ud835\udc43\u00b9\ud835\udc35j\ud835\udc34=\ud835\udc4e\u00ba\ud835\udc43\u00b9\ud835\udc34=\ud835\udc4e\u00ba=\u00d5\n\ud835\udc4e\ud835\udc43\u00b9\ud835\udc35,\ud835\udc34=\ud835\udc4e\u00ba=\ud835\udc43\u00b9\ud835\udc35\u00ba.(2.6.6)\nIndependenceisanotherfundamentallyimportantconceptthatformsthebackboneofmany\nimportant ideas in statistics. In short, two variables are independent if conditioning on the\nvalue of\ud835\udc34does not cause any change to the probability distribution associated with \ud835\udc35and\nvice versa. More formally, independence, denoted \ud835\udc34?\ud835\udc35, requires that \ud835\udc43\u00b9\ud835\udc34j\ud835\udc35\u00ba=\ud835\udc43\u00b9\ud835\udc34\u00ba\nand, consequently, that \ud835\udc43\u00b9\ud835\udc34,\ud835\udc35\u00ba=\ud835\udc43\u00b9\ud835\udc34j\ud835\udc35\u00ba\ud835\udc43\u00b9\ud835\udc35\u00ba=\ud835\udc43\u00b9\ud835\udc34\u00ba\ud835\udc43\u00b9\ud835\udc35\u00ba. Independence is often\nan appropriate assumption. For example, if the random variable \ud835\udc34represents the outcome\nfrom tossing one fair coin and the random variable \ud835\udc35represents the outcome from tossing\nanother, then knowing whether \ud835\udc34came up heads should not influence the probability of \ud835\udc35\ncoming up heads.\nIndependence is especially useful when it holds among the successive draws of our data\nfrom some underlying distribution (allowing us to make strong statistical conclusions) or\nwhenitholdsamongvariousvariablesinourdata,allowingustoworkwithsimplermodels\nthat encode this independence structure. On the other hand, estimating the dependencies\namongrandomvariablesisoftentheveryaimoflearning. Wecaretoestimatetheprobabil-\nity of disease given symptoms specifically because we believe that diseases and symptoms\narenotindependent.\nNote that because conditional probabilities are proper probabilities, the concepts of inde-\npendenceanddependencealsoapplytothem. Tworandomvariables \ud835\udc34and\ud835\udc35arecondition-\nally independent given a third variable \ud835\udc36if and only if \ud835\udc43\u00b9\ud835\udc34,\ud835\udc35j\ud835\udc36\u00ba=\ud835\udc43\u00b9\ud835\udc34j\ud835\udc36\u00ba\ud835\udc43\u00b9\ud835\udc35j\ud835\udc36\u00ba.\nInterestingly, two variables can be independent in general but become dependent when\nconditioning on a third. This often occurs when the two random variables \ud835\udc34and\ud835\udc35cor-\nrespond to causes of some third variable \ud835\udc36. For example, broken bones and lung cancer\nmight be independent in the general population but if we condition on being in the hospital\nthen we might find that broken bones are negatively correlated with lung cancer. That is\n73 Probability and Statistics\nbecause the broken bone explainsaway why some person is in the hospital and thus lowers\nthe probability that they are hospitalized because of having lung cancer.\nAndconversely,twodependentrandomvariablescanbecomeindependentuponcondition-\ning on a third. This often happens when two otherwise unrelated events have a common\ncause. Shoesizeandreadinglevelarehighlycorrelatedamongelementaryschoolstudents,\nbut this correlation disappears if we condition on age.\n2.6.5An Example\nLet\u2019s put our skills to the test. Assume that a doctor administers an HIV test to a patient.\nThis test is fairly accurate and fails only with 1% probability if the patient is healthy but\nreported as diseased, i.e., healthy patients test positive in 1% of cases. Moreover, it never\nfailstodetectHIVifthepatientactuallyhasit. Weuse \ud835\udc3712f0,1gtoindicatethediagnosis\n(0if negative and 1if positive) and \ud835\udc3b2f0,1gto denote the HIV status.", "mimetype": "text/plain", "start_char_idx": 218729, "end_char_idx": 222006, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4dfa06ed-5258-4af2-9845-6f8d123589fe": {"__data__": {"id_": "4dfa06ed-5258-4af2-9845-6f8d123589fe", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "23da883a-4603-46ce-b19d-cc43b4a02543", "node_type": "1", "metadata": {}, "hash": "9aae21802aaec26153f78de350205ee1a08f642939a5b3831c4517dcd593f6be", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6eb8cf36-f29a-42ad-abb9-0c3b5cda754e", "node_type": "1", "metadata": {}, "hash": "4afe30098e1e1e5337829322aad566e15a79d445d6bed1f836c8743341680739", "class_name": "RelatedNodeInfo"}}, "text": "This often happens when two otherwise unrelated events have a common\ncause. Shoesizeandreadinglevelarehighlycorrelatedamongelementaryschoolstudents,\nbut this correlation disappears if we condition on age.\n2.6.5An Example\nLet\u2019s put our skills to the test. Assume that a doctor administers an HIV test to a patient.\nThis test is fairly accurate and fails only with 1% probability if the patient is healthy but\nreported as diseased, i.e., healthy patients test positive in 1% of cases. Moreover, it never\nfailstodetectHIVifthepatientactuallyhasit. Weuse \ud835\udc3712f0,1gtoindicatethediagnosis\n(0if negative and 1if positive) and \ud835\udc3b2f0,1gto denote the HIV status.\nConditional probability \ud835\udc3b=1\ud835\udc3b=0\n\ud835\udc43\u00b9\ud835\udc371=1j\ud835\udc3b\u00ba 1 0.01\n\ud835\udc43\u00b9\ud835\udc371=0j\ud835\udc3b\u00ba 0 0.99\nNote that the column sums are all 1 (but the row sums do not), since they are conditional\nprobabilities. Let\u2019s compute the probability of the patient having HIV if the test comes\nback positive, i.e., \ud835\udc43\u00b9\ud835\udc3b=1j\ud835\udc371=1\u00ba. Intuitively this is going to depend on how common\nthe disease is, since it affects the number of false alarms. Assume that the population is\nfairly free of the disease, e.g., \ud835\udc43\u00b9\ud835\udc3b=1\u00ba=0.0015. To apply Bayes\u2019 theorem, we need to\napply marginalization to determine\n\ud835\udc43\u00b9\ud835\udc371=1\u00ba=\ud835\udc43\u00b9\ud835\udc371=1,\ud835\udc3b=0\u00ba\u00b8\ud835\udc43\u00b9\ud835\udc371=1,\ud835\udc3b=1\u00ba\n=\ud835\udc43\u00b9\ud835\udc371=1j\ud835\udc3b=0\u00ba\ud835\udc43\u00b9\ud835\udc3b=0\u00ba\u00b8\ud835\udc43\u00b9\ud835\udc371=1j\ud835\udc3b=1\u00ba\ud835\udc43\u00b9\ud835\udc3b=1\u00ba\n=0.011485.(2.6.7)\nThis leads us to\n\ud835\udc43\u00b9\ud835\udc3b=1j\ud835\udc371=1\u00ba=\ud835\udc43\u00b9\ud835\udc371=1j\ud835\udc3b=1\u00ba\ud835\udc43\u00b9\ud835\udc3b=1\u00ba\n\ud835\udc43\u00b9\ud835\udc371=1\u00ba=0.1306. (2.6.8)\nIn other words, there is only a 13.06% chance that the patient actually has HIV, despite the\ntestbeingprettyaccurate. Aswecansee,probabilitycanbecounterintuitive. Whatshoulda\npatientdouponreceivingsuchterrifyingnews? Likely,thepatientwouldaskthephysician\nto administer another test to get clarity. The second test has different characteristics and it\nis not as good as the first one.\nConditional probability \ud835\udc3b=1\ud835\udc3b=0\n\ud835\udc43\u00b9\ud835\udc372=1j\ud835\udc3b\u00ba 0.98 0.03\n\ud835\udc43\u00b9\ud835\udc372=0j\ud835\udc3b\u00ba 0.02 0.97\n74 Preliminaries\nUnfortunately, the second test comes back positive, too. Let\u2019s calculate the requisite prob-\nabilities to invoke Bayes\u2019 theorem by assuming conditional independence:\n\ud835\udc43\u00b9\ud835\udc371=1,\ud835\udc372=1j\ud835\udc3b=0\u00ba=\ud835\udc43\u00b9\ud835\udc371=1j\ud835\udc3b=0\u00ba\ud835\udc43\u00b9\ud835\udc372=1j\ud835\udc3b=0\u00ba=0.0003,\n\ud835\udc43\u00b9\ud835\udc371=1,\ud835\udc372=1j\ud835\udc3b=1\u00ba=\ud835\udc43\u00b9\ud835\udc371=1j\ud835\udc3b=1\u00ba\ud835\udc43\u00b9\ud835\udc372=1j\ud835\udc3b=1\u00ba= 0.98.", "mimetype": "text/plain", "start_char_idx": 221356, "end_char_idx": 223436, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6eb8cf36-f29a-42ad-abb9-0c3b5cda754e": {"__data__": {"id_": "6eb8cf36-f29a-42ad-abb9-0c3b5cda754e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4dfa06ed-5258-4af2-9845-6f8d123589fe", "node_type": "1", "metadata": {}, "hash": "989941d7fa2bd1e12af92f1cca6607ec132c2c390b1fb007413b65d485e7af69", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d4ebb515-bfd4-4f08-94a5-82f44de014e6", "node_type": "1", "metadata": {}, "hash": "4edce542555cce1908b8c862fa35f3781358feb4a3975708b8e1602c20033850", "class_name": "RelatedNodeInfo"}}, "text": "Let\u2019s calculate the requisite prob-\nabilities to invoke Bayes\u2019 theorem by assuming conditional independence:\n\ud835\udc43\u00b9\ud835\udc371=1,\ud835\udc372=1j\ud835\udc3b=0\u00ba=\ud835\udc43\u00b9\ud835\udc371=1j\ud835\udc3b=0\u00ba\ud835\udc43\u00b9\ud835\udc372=1j\ud835\udc3b=0\u00ba=0.0003,\n\ud835\udc43\u00b9\ud835\udc371=1,\ud835\udc372=1j\ud835\udc3b=1\u00ba=\ud835\udc43\u00b9\ud835\udc371=1j\ud835\udc3b=1\u00ba\ud835\udc43\u00b9\ud835\udc372=1j\ud835\udc3b=1\u00ba= 0.98.\n(2.6.9)\nNow we can apply marginalization to obtain the probability that both tests come back pos-\nitive:\n\ud835\udc43\u00b9\ud835\udc371=1,\ud835\udc372=1\u00ba\n=\ud835\udc43\u00b9\ud835\udc371=1,\ud835\udc372=1,\ud835\udc3b=0\u00ba\u00b8\ud835\udc43\u00b9\ud835\udc371=1,\ud835\udc372=1,\ud835\udc3b=1\u00ba\n=\ud835\udc43\u00b9\ud835\udc371=1,\ud835\udc372=1j\ud835\udc3b=0\u00ba\ud835\udc43\u00b9\ud835\udc3b=0\u00ba\u00b8\ud835\udc43\u00b9\ud835\udc371=1,\ud835\udc372=1j\ud835\udc3b=1\u00ba\ud835\udc43\u00b9\ud835\udc3b=1\u00ba\n=0.00176955.\n(2.6.10)\nFinally,theprobabilityofthepatienthavingHIVgiventhatbothtestsarepositiveis\n\ud835\udc43\u00b9\ud835\udc3b=1j\ud835\udc371=1,\ud835\udc372=1\u00ba=\ud835\udc43\u00b9\ud835\udc371=1,\ud835\udc372=1j\ud835\udc3b=1\u00ba\ud835\udc43\u00b9\ud835\udc3b=1\u00ba\n\ud835\udc43\u00b9\ud835\udc371=1,\ud835\udc372=1\u00ba=0.8307.(2.6.11)\nThat is, the second test allowed us to gain much higher confidence that not all is well. De-\nspite the second test being considerably less accurate than the first one, it still significantly\nimproved our estimate. The assumption of both tests being conditionally independent of\neach other was crucial for our ability to generate a more accurate estimate. Take the ex-\ntreme case where we run the same test twice. In this situation we would expect the same\noutcomebothtimes,hencenoadditionalinsightisgainedfromrunningthesametestagain.\nThe astute reader might have noticed that the diagnosis behaved like a classifier hiding in\nplain sight where our ability to decide whether a patient is healthy increases as we obtain\nmore features (test outcomes).\n2.6.6Expectations\nOften, making decisions requires not just looking at the probabilities assigned to individ-\nual events but composing them together into useful aggregates that can provide us with\nguidance. For example, when random variables take continuous scalar values, we often\ncare about knowing what value to expect on average . This quantity is formally called an\nexpectation . If we are making investments, the first quantity of interest might be the return\nwe can expect, averaging over all the possible outcomes (and weighting by the appropri-\nate probabilities). For instance, say that with 50% probability, an investment might fail\naltogether, with 40% probability it might provide a 2 \u0002return, and with 10% probability\nit might provide a 10 \u0002return 10\u0002. To calculate the expected return, we sum over all re-\nturns, multiplying each by the probability that they will occur. This yields the expectation\n0.5\u00010\u00b80.4\u00012\u00b80.1\u000110=1.8. Hence the expected return is 1.8 \u0002.\nIn general, the expectation (or average) of the random variable \ud835\udc4bis defined as\n\ud835\udc38\u00bb\ud835\udc4b\u00bc=\ud835\udc38\ud835\udc65\u0018\ud835\udc43\u00bb\ud835\udc65\u00bc=\u00d5\n\ud835\udc65\ud835\udc65\ud835\udc43\u00b9\ud835\udc4b=\ud835\udc65\u00ba.(2.6.12)\n75 Probability and Statistics\nLikewise, for densities we obtain \ud835\udc38\u00bb\ud835\udc4b\u00bc=\u00af\n\ud835\udc65 \ud835\udc51\ud835\udc5d\u00b9\ud835\udc65\u00ba.", "mimetype": "text/plain", "start_char_idx": 223233, "end_char_idx": 225717, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d4ebb515-bfd4-4f08-94a5-82f44de014e6": {"__data__": {"id_": "d4ebb515-bfd4-4f08-94a5-82f44de014e6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6eb8cf36-f29a-42ad-abb9-0c3b5cda754e", "node_type": "1", "metadata": {}, "hash": "4afe30098e1e1e5337829322aad566e15a79d445d6bed1f836c8743341680739", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d2e153a2-c8e3-441b-93f7-bfc9e13c8709", "node_type": "1", "metadata": {}, "hash": "e50a99b0478fbee0b980b137c0e2452bbcf63e4eba00d6aa421d7e083290b374", "class_name": "RelatedNodeInfo"}}, "text": "To calculate the expected return, we sum over all re-\nturns, multiplying each by the probability that they will occur. This yields the expectation\n0.5\u00010\u00b80.4\u00012\u00b80.1\u000110=1.8. Hence the expected return is 1.8 \u0002.\nIn general, the expectation (or average) of the random variable \ud835\udc4bis defined as\n\ud835\udc38\u00bb\ud835\udc4b\u00bc=\ud835\udc38\ud835\udc65\u0018\ud835\udc43\u00bb\ud835\udc65\u00bc=\u00d5\n\ud835\udc65\ud835\udc65\ud835\udc43\u00b9\ud835\udc4b=\ud835\udc65\u00ba.(2.6.12)\n75 Probability and Statistics\nLikewise, for densities we obtain \ud835\udc38\u00bb\ud835\udc4b\u00bc=\u00af\n\ud835\udc65 \ud835\udc51\ud835\udc5d\u00b9\ud835\udc65\u00ba. Sometimes we are interested in the\nexpected value of some function of \ud835\udc65. We can calculate these expectations as\n\ud835\udc38\ud835\udc65\u0018\ud835\udc43\u00bb\ud835\udc53\u00b9\ud835\udc65\u00ba\u00bc=\u00d5\n\ud835\udc65\ud835\udc53\u00b9\ud835\udc65\u00ba\ud835\udc43\u00b9\ud835\udc65\u00baand\ud835\udc38\ud835\udc65\u0018\ud835\udc43\u00bb\ud835\udc53\u00b9\ud835\udc65\u00ba\u00bc=\u00b9\n\ud835\udc53\u00b9\ud835\udc65\u00ba\ud835\udc5d\u00b9\ud835\udc65\u00ba\ud835\udc51\ud835\udc65 (2.6.13)\nfor discrete probabilities and densities, respectively. Returning to the investment exam-\nple from above, \ud835\udc53might be the utility(happiness) associated with the return. Behavior\neconomists have long noted that people associate greater disutility with losing money than\nthe utility gained from earning one dollar relative to their baseline. Moreover, the value\nof money tends to be sub-linear. Possessing 100k dollars versus zero dollars can make the\ndifferencebetweenpayingtherent, eatingwell, andenjoyingqualityhealthcareversussuf-\nfering through homelessness. On the other hand, the gains due to possessing 200k versus\n100k are less dramatic. Reasoning like this motivates the clich\u00e9 that \u201cthe utility of money\nis logarithmic\u201d.\nIftheutilityassociatedwithatotallosswere \u00001, andtheutilitiesassociatedwithreturnsof\n1,2, and 10were 1,2and4, respectively, then the expected happiness of investing would\nbe0.5\u0001\u00b9\u00001\u00ba\u00b80.4\u00012\u00b80.1\u00014=0.7(an expected loss of utility of 30%). If indeed this were\nyour utility function, you might be best off keeping the money in the bank.\nForfinancialdecisions,wemightalsowanttomeasurehow riskyaninvestmentis. Here,we\ncare not just about the expected value but how much the actual values tend to varyrelative\nto this value. Note that we cannot just take the expectation of the difference between the\nactual and expected values. This is because the expectation of a difference is the difference\nof the expectations, i.e., \ud835\udc38\u00bb\ud835\udc4b\u0000\ud835\udc38\u00bb\ud835\udc4b\u00bc\u00bc=\ud835\udc38\u00bb\ud835\udc4b\u00bc\u0000\ud835\udc38\u00bb\ud835\udc38\u00bb\ud835\udc4b\u00bc\u00bc=0. However, we can look at\nthe expectation of any non-negative function of this difference. The variance of a random\nvariable is calculated by looking at the expected value of the squared differences:\nVar\u00bb\ud835\udc4b\u00bc=\ud835\udc38\u0002\n\u00b9\ud835\udc4b\u0000\ud835\udc38\u00bb\ud835\udc4b\u00bc\u00ba2\u0003\n=\ud835\udc38\u00bb\ud835\udc4b2\u00bc\u0000\ud835\udc38\u00bb\ud835\udc4b\u00bc2. (2.6.14)\nHere the equality follows by expanding \u00b9\ud835\udc4b\u0000\ud835\udc38\u00bb\ud835\udc4b\u00bc\u00ba2=\ud835\udc4b2\u00002\ud835\udc4b\ud835\udc38\u00bb\ud835\udc4b\u00bc\u00b8\ud835\udc38\u00bb\ud835\udc4b\u00bc2and taking\nexpectationsforeachterm. Thesquarerootofthevarianceisanotherusefulquantitycalled\nthestandarddeviation . Whilethisandthevarianceconveythesameinformation(eithercan\nbecalculatedfromtheother),thestandarddeviationhasthenicepropertythatitisexpressed\nin the same units as the original quantity represented by the random variable.\nLastly, the variance of a function of a random variable is defined analogously as\nVar\ud835\udc65\u0018\ud835\udc43\u00bb\ud835\udc53\u00b9\ud835\udc65\u00ba\u00bc=\ud835\udc38\ud835\udc65\u0018\ud835\udc43\u00bb\ud835\udc532\u00b9\ud835\udc65\u00ba\u00bc\u0000\ud835\udc38\ud835\udc65\u0018\ud835\udc43\u00bb\ud835\udc53\u00b9\ud835\udc65\u00ba\u00bc2.", "mimetype": "text/plain", "start_char_idx": 225319, "end_char_idx": 228113, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d2e153a2-c8e3-441b-93f7-bfc9e13c8709": {"__data__": {"id_": "d2e153a2-c8e3-441b-93f7-bfc9e13c8709", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d4ebb515-bfd4-4f08-94a5-82f44de014e6", "node_type": "1", "metadata": {}, "hash": "4edce542555cce1908b8c862fa35f3781358feb4a3975708b8e1602c20033850", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "13a78da8-74de-487a-9504-38a9711b41e0", "node_type": "1", "metadata": {}, "hash": "1e8f674c226257b71b6d860d8f304c081889e879b80b99499bb0a96e0b03b1e1", "class_name": "RelatedNodeInfo"}}, "text": "Thesquarerootofthevarianceisanotherusefulquantitycalled\nthestandarddeviation . Whilethisandthevarianceconveythesameinformation(eithercan\nbecalculatedfromtheother),thestandarddeviationhasthenicepropertythatitisexpressed\nin the same units as the original quantity represented by the random variable.\nLastly, the variance of a function of a random variable is defined analogously as\nVar\ud835\udc65\u0018\ud835\udc43\u00bb\ud835\udc53\u00b9\ud835\udc65\u00ba\u00bc=\ud835\udc38\ud835\udc65\u0018\ud835\udc43\u00bb\ud835\udc532\u00b9\ud835\udc65\u00ba\u00bc\u0000\ud835\udc38\ud835\udc65\u0018\ud835\udc43\u00bb\ud835\udc53\u00b9\ud835\udc65\u00ba\u00bc2. (2.6.15)\nReturning to our investment example, we can now compute the variance of the investment.\nIt is given by 0.5\u00010\u00b80.4\u000122\u00b80.1\u0001102\u00001.82=8.36. For all intents and purposes this\nis a risky investment. Note that by mathematical convention mean and variance are often\nreferenced as \ud835\udf07and\ud835\udf0e2. This is particularly the case whenever we use it to parametrize a\nGaussian distribution.\nIn the same way as we introduced expectations and variance for scalarrandom variables,\nwe can do so for vector-valued ones. Expectations are easy, since we can apply them el-\nementwise. For instance, \ud835\udf41def=\ud835\udc38x\u0018\ud835\udc43\u00bbx\u00bchas coordinates \ud835\udf07\ud835\udc56=\ud835\udc38x\u0018\ud835\udc43\u00bb\ud835\udc65\ud835\udc56\u00bc.Covariances\n76 Preliminaries\n59are more complicated. We define them by taking expectations of the outer product of the\ndifference between random variables and their mean:\n\ud835\udebadef=Covx\u0018\ud835\udc43\u00bbx\u00bc=\ud835\udc38x\u0018\ud835\udc43\u0002\n\u00b9x\u0000\ud835\udf41\u00ba\u00b9x\u0000\ud835\udf41\u00ba>\u0003\n. (2.6.16)\nThis matrix \ud835\udebais referred to as the covariance matrix. An easy way to see its effect is to\nconsider some vector vof the same size as x. It follows that\nv>\ud835\udebav=\ud835\udc38x\u0018\ud835\udc43\u0002\nv>\u00b9x\u0000\ud835\udf41\u00ba\u00b9x\u0000\ud835\udf41\u00ba>v\u0003\n=Var\ud835\udc65\u0018\ud835\udc43\u00bbv>x\u00bc. (2.6.17)\nAs such, \ud835\udebaallows us to compute the variance for any linear function of xby a simple\nmatrix multiplication. The off-diagonal elements tell us how correlated the coordinates\nare: a value of 0 means no correlation, where a larger positive value means that they are\nmore strongly correlated.\n2.6.7Discussion\nIn machine learning, there are many things to be uncertain about! We can be uncertain\nabout the value of a label given an input. We can be uncertain about the estimated value of\na parameter. We can even be uncertain about whether data arriving at deployment is even\nfrom the same distribution as the training data.\nByaleatoric uncertainty , we mean uncertainty that is intrinsic to the problem, and due to\ngenuine randomness unaccounted for by the observed variables. By epistemicuncertainty ,\nwe mean uncertainty over a model\u2019s parameters, the sort of uncertainty that we can hope\nto reduce by collecting more data. We might have epistemic uncertainty concerning the\nprobability that a coin turns up heads, but even once we know this probability, we are left\nwith aleatoric uncertainty about the outcome of any future toss. No matter how long we\nwatch someone tossing a fair coin, we will never be more or less than 50% certain that\nthe next toss will come up heads. These terms come from mechanical modeling, (see e.g.,\nDer Kiureghian and Ditlevsen ( 2009) for a review on this aspect of uncertainty quantifica-\ntion59). It is worth noting, however, that these terms constitute a slight abuse of language.\nThe term epistemic refers to anything concerning knowledge and thus, in the philosophical\nsense, all uncertainty is epistemic.\nWesawthatsamplingdatafromsomeunknownprobabilitydistributioncanprovideuswith\ninformation that can be used to estimate the parameters of the data generating distribution.\nThat said, the rate at which this is possible can be quite slow. In our coin tossing example\n(and many others) we can do no better than to design estimators that converge at a rate of\n1\u009dp\ud835\udc5b, where\ud835\udc5bis the sample size (e.g., the number of tosses).", "mimetype": "text/plain", "start_char_idx": 227696, "end_char_idx": 231200, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "13a78da8-74de-487a-9504-38a9711b41e0": {"__data__": {"id_": "13a78da8-74de-487a-9504-38a9711b41e0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d2e153a2-c8e3-441b-93f7-bfc9e13c8709", "node_type": "1", "metadata": {}, "hash": "e50a99b0478fbee0b980b137c0e2452bbcf63e4eba00d6aa421d7e083290b374", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "924a08d5-8997-47c3-906c-754af4429b33", "node_type": "1", "metadata": {}, "hash": "5ef5f874b1070688a0efdbc16cc14e280253de2d3548b6bf4764a54740357d34", "class_name": "RelatedNodeInfo"}}, "text": "These terms come from mechanical modeling, (see e.g.,\nDer Kiureghian and Ditlevsen ( 2009) for a review on this aspect of uncertainty quantifica-\ntion59). It is worth noting, however, that these terms constitute a slight abuse of language.\nThe term epistemic refers to anything concerning knowledge and thus, in the philosophical\nsense, all uncertainty is epistemic.\nWesawthatsamplingdatafromsomeunknownprobabilitydistributioncanprovideuswith\ninformation that can be used to estimate the parameters of the data generating distribution.\nThat said, the rate at which this is possible can be quite slow. In our coin tossing example\n(and many others) we can do no better than to design estimators that converge at a rate of\n1\u009dp\ud835\udc5b, where\ud835\udc5bis the sample size (e.g., the number of tosses). This means that by going\nfrom10to1000observations(usuallyaveryachievabletask)weseeatenfoldreductionof\nuncertainty, whereas the next 1000 observations help comparatively little, offering only a\n1.41timesreduction. Thisisapersistentfeatureofmachinelearning: whilethereareoften\neasy gains, it takes a very large amount of data, and often with it an enormous amount of\ncomputation, to make further gains. For an empirical review of this fact for large scale\nlanguage models see Revels etal.(2016).\nWe also sharpened our language and tools for statistical modeling. In the process of that\n77 Probability and Statistics\n60\n61\n62we learned about conditional probabilities and about one of the most important equations\nin statistics\u2014Bayes\u2019 theorem. It is an effective tool for decoupling information conveyed\nby data through a likelihood term \ud835\udc43\u00b9\ud835\udc35j\ud835\udc34\u00bathat addresses how well observations \ud835\udc35match\na choice of parameters \ud835\udc34, and a prior probability \ud835\udc43\u00b9\ud835\udc34\u00bawhich governs how plausible a par-\nticular choice of \ud835\udc34was in the first place. In particular, we saw how this rule can be applied\nto assign probabilities to diagnoses, based on the efficacy of the test andthe prevalence of\nthe disease itself (i.e., our prior).\nLastly, we introduced a first set of nontrivial questions about the effect of a specific proba-\nbilitydistribution,namelyexpectationsandvariances. Whiletherearemanymorethanjust\nlinear and quadratic expectations for a probability distribution, these two already provide\na good deal of knowledge about the possible behavior of the distribution. For instance,\nChebyshev\u2019s inequality60states that\ud835\udc43\u00b9j\ud835\udc4b\u0000\ud835\udf07j\u0015\ud835\udc58\ud835\udf0e\u00ba\u0014 1\u009d\ud835\udc582, where\ud835\udf07is the expecta-\ntion,\ud835\udf0e2is the variance of the distribution, and \ud835\udc58 > 1is a confidence parameter of our\nchoosing. It tells us that draws from a distribution lie with at least 50% probability within\na\u00bb\u0000p\n2\ud835\udf0e,p\n2\ud835\udf0e\u00bcinterval centered on the expectation.\n2.6.8Exercises\n1.Giveanexamplewhereobservingmoredatacanreducetheamountofuncertaintyabout\nthe outcome to an arbitrarily low level.\n2.Giveanexamplewhereobservingmoredatawillonlyreducetheamountofuncertainty\nuptoapointandthennofurther. Explainwhythisisthecaseandwhereyouexpectthis\npoint to occur.\n3.We empirically demonstrated convergence to the mean for the toss of a coin. Calculate\nthevarianceoftheestimateoftheprobabilitythatweseeaheadafterdrawing \ud835\udc5bsamples.\n1.How does the variance scale with the number of observations?\n2.Use Chebyshev\u2019s inequality to bound the deviation from the expectation.\n3.How does it relate to the central limit theorem?\n4.Assume that we draw \ud835\udc5asamples\ud835\udc65\ud835\udc56from a probability distribution with zero mean and\nunit variance. Compute the averages \ud835\udc67\ud835\udc5adef=\ud835\udc5a\u00001\u00cd\ud835\udc5a\n\ud835\udc56=1\ud835\udc65\ud835\udc56. Can we apply Chebyshev\u2019s\ninequality for every \ud835\udc67\ud835\udc5aindependently? Why not?\n5.Given two events with probability \ud835\udc43\u00b9A\u00baand\ud835\udc43\u00b9B\u00ba, compute upper and lower bounds\non\ud835\udc43\u00b9A[B\u00ba and\ud835\udc43\u00b9A\\B\u00ba . Hint: graph the situation using a Venn diagram61.", "mimetype": "text/plain", "start_char_idx": 230420, "end_char_idx": 234070, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "924a08d5-8997-47c3-906c-754af4429b33": {"__data__": {"id_": "924a08d5-8997-47c3-906c-754af4429b33", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "13a78da8-74de-487a-9504-38a9711b41e0", "node_type": "1", "metadata": {}, "hash": "1e8f674c226257b71b6d860d8f304c081889e879b80b99499bb0a96e0b03b1e1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3c09aac6-94c6-4437-ad0b-de84ce020bc3", "node_type": "1", "metadata": {}, "hash": "52119cc83628d279623e0aa98263f41ebd59b0cc635e7f729883cda7cca2f888", "class_name": "RelatedNodeInfo"}}, "text": "1.How does the variance scale with the number of observations?\n2.Use Chebyshev\u2019s inequality to bound the deviation from the expectation.\n3.How does it relate to the central limit theorem?\n4.Assume that we draw \ud835\udc5asamples\ud835\udc65\ud835\udc56from a probability distribution with zero mean and\nunit variance. Compute the averages \ud835\udc67\ud835\udc5adef=\ud835\udc5a\u00001\u00cd\ud835\udc5a\n\ud835\udc56=1\ud835\udc65\ud835\udc56. Can we apply Chebyshev\u2019s\ninequality for every \ud835\udc67\ud835\udc5aindependently? Why not?\n5.Given two events with probability \ud835\udc43\u00b9A\u00baand\ud835\udc43\u00b9B\u00ba, compute upper and lower bounds\non\ud835\udc43\u00b9A[B\u00ba and\ud835\udc43\u00b9A\\B\u00ba . Hint: graph the situation using a Venn diagram61.\n6.Assumethatwehaveasequenceofrandomvariables,say \ud835\udc34,\ud835\udc35,and\ud835\udc36,where\ud835\udc35onlyde-\npendson\ud835\udc34,and\ud835\udc36onlydependson \ud835\udc35,canyousimplifythejointprobability \ud835\udc43\u00b9\ud835\udc34,\ud835\udc35,\ud835\udc36\u00ba?\nHint: this is a Markov chain62.\n7.InSection 2.6.5 , assume that the outcomes of the two tests are not independent. In\nparticular assume that either test on its own has a false positive rate of 10% and a false\nnegative rate of 1%. That is, assume that \ud835\udc43\u00b9\ud835\udc37=1j\ud835\udc3b=0\u00ba=0.1and that\ud835\udc43\u00b9\ud835\udc37=\n0j\ud835\udc3b=1\u00ba=0.01. Moreover, assume that for \ud835\udc3b=1(infected) the test outcomes are\n78 Preliminaries\n63\n64\n65\n66conditionally independent, i.e., that \ud835\udc43\u00b9\ud835\udc371,\ud835\udc372j\ud835\udc3b=1\u00ba=\ud835\udc43\u00b9\ud835\udc371j\ud835\udc3b=1\u00ba\ud835\udc43\u00b9\ud835\udc372j\ud835\udc3b=\n1\u00babut that for healthy patients the outcomes are coupled via \ud835\udc43\u00b9\ud835\udc371=\ud835\udc372=1j\ud835\udc3b=\n0\u00ba=0.02.\n1.Work out the joint probability table for \ud835\udc371and\ud835\udc372, given\ud835\udc3b=0based on the infor-\nmation you have so far.\n2.Derive the probability that the patient is diseased ( \ud835\udc3b=1) after one test returns\npositive. You can assume the same baseline probability \ud835\udc43\u00b9\ud835\udc3b=1\u00ba=0.0015as\nbefore.\n3.Derive the probability that the patient is diseased ( \ud835\udc3b=1) after both tests return\npositive.\n8.Assume that you are an asset manager for an investment bank and you have a choice of\nstocks\ud835\udc60\ud835\udc56toinvestin. Yourportfolioneedstoaddupto 1withweights \ud835\udefc\ud835\udc56foreachstock.\nThe stocks have an average return \ud835\udf41=\ud835\udc38s\u0018\ud835\udc43\u00bbs\u00bcand covariance \ud835\udeba=Covs\u0018\ud835\udc43\u00bbs\u00bc.\n1.Compute the expected return for a given portfolio \ud835\udf36.\n2.If you wanted to maximize the return of the portfolio, how should you choose your\ninvestment?\n3.Compute the variance of the portfolio.\n4.Formulateanoptimizationproblemofmaximizingthereturnwhilekeepingthevari-\nanceconstrainedtoanupperbound. ThisistheNobel-Prizewinning Markovitzport-\nfolio63(Mangram, 2013 ). Tosolveityouwillneedaquadraticprogrammingsolver,\nsomething way beyond the scope of this book.\nDiscussions64.\n2.7Documentation\nWhilewecannotpossiblyintroduceeverysinglePyTorchfunctionandclass(andtheinfor-\nmation might become outdated quickly), the API documentation65and additional tutorials\n66and examples provide such documentation. This section provides some guidance for\nhow to explore the PyTorch API.\nimport torch\n2.7.1Functionsand Classes in a Module\nTo know which functions and classes can be called in a module, we invoke the dirfunc-\ntion. For instance, we can query all properties in the module for generating random num-\nbers:\n79 Documentation\nprint (dir(torch .distributions))\n['AbsTransform ','AffineTransform ','Bernoulli ','Beta ','Binomial ',\n\u21a9!'CatTransform ','Categorical ','Cauchy ','Chi2 ','ComposeTransform ',\n\u21a9!'ContinuousBernoulli ','CorrCholeskyTransform ',\n\u21a9!", "mimetype": "text/plain", "start_char_idx": 233522, "end_char_idx": 236594, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3c09aac6-94c6-4437-ad0b-de84ce020bc3": {"__data__": {"id_": "3c09aac6-94c6-4437-ad0b-de84ce020bc3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "924a08d5-8997-47c3-906c-754af4429b33", "node_type": "1", "metadata": {}, "hash": "5ef5f874b1070688a0efdbc16cc14e280253de2d3548b6bf4764a54740357d34", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "68c1efb8-1656-4606-887a-d6c7379334f6", "node_type": "1", "metadata": {}, "hash": "5975596644d4fa23c9cd29b7fbfd44439b34d59f67c0a3bfd09177b1fecfff77", "class_name": "RelatedNodeInfo"}}, "text": "Discussions64.\n2.7Documentation\nWhilewecannotpossiblyintroduceeverysinglePyTorchfunctionandclass(andtheinfor-\nmation might become outdated quickly), the API documentation65and additional tutorials\n66and examples provide such documentation. This section provides some guidance for\nhow to explore the PyTorch API.\nimport torch\n2.7.1Functionsand Classes in a Module\nTo know which functions and classes can be called in a module, we invoke the dirfunc-\ntion. For instance, we can query all properties in the module for generating random num-\nbers:\n79 Documentation\nprint (dir(torch .distributions))\n['AbsTransform ','AffineTransform ','Bernoulli ','Beta ','Binomial ',\n\u21a9!'CatTransform ','Categorical ','Cauchy ','Chi2 ','ComposeTransform ',\n\u21a9!'ContinuousBernoulli ','CorrCholeskyTransform ',\n\u21a9!'CumulativeDistributionTransform ','Dirichlet ','Distribution ','ExpTransform\n\u21a9!','Exponential ','ExponentialFamily ','FisherSnedecor ','Gamma ','Geometric\n\u21a9!','Gumbel ','HalfCauchy ','HalfNormal ','Independent ','IndependentTransform\n\u21a9!','Kumaraswamy ','LKJCholesky ','Laplace ','LogNormal ','LogisticNormal ',\n\u21a9!'LowRankMultivariateNormal ','LowerCholeskyTransform ','MixtureSameFamily ',\n\u21a9!'Multinomial ','MultivariateNormal ','NegativeBinomial ','Normal ',\n\u21a9!'OneHotCategorical ','OneHotCategoricalStraightThrough ','Pareto ','Poisson ',\n\u21a9!'PositiveDefiniteTransform ','PowerTransform ','RelaxedBernoulli ',\n\u21a9!'RelaxedOneHotCategorical ','ReshapeTransform ','SigmoidTransform ',\n\u21a9!'SoftmaxTransform ','SoftplusTransform ','StackTransform ',\n\u21a9!'StickBreakingTransform ','StudentT ','TanhTransform ','Transform ',\n\u21a9!'TransformedDistribution ','Uniform ','VonMises ','Weibull ','Wishart ','__\n\u21a9!all__ ','__builtins__ ','__cached__ ','__doc__ ','__file__ ','__loader__ ','_\n\u21a9!_name__ ','__package__ ','__path__ ','__spec__ ','bernoulli ','beta ',\n\u21a9!'biject_to ','binomial ','categorical ','cauchy ','chi2 ','constraint_\n\u21a9!registry ','constraints ','continuous_bernoulli ','dirichlet ','distribution\n\u21a9!','exp_family ','exponential ','fishersnedecor ','gamma ','geometric ',\n\u21a9!'gumbel ','half_cauchy ','half_normal ','identity_transform ','independent ',\n\u21a9!'kl','kl_divergence ','kumaraswamy ','laplace ','lkj_cholesky ','log_normal\n\u21a9!','logistic_normal ','lowrank_multivariate_normal ','mixture_same_family ',\n\u21a9!'multinomial ','multivariate_normal ','negative_binomial ','normal ','one_\n\u21a9!hot_categorical ','pareto ','poisson ','register_kl ','relaxed_bernoulli ',\n\u21a9!'relaxed_categorical ','studentT ','transform_to ','transformed_distribution\n\u21a9!','transforms ','uniform ','utils ','von_mises ','weibull ','wishart ']\nGenerally, we can ignore functions that start and end with __(special objects in Python) or\nfunctionsthatstartwithasingle _(usuallyinternalfunctions). Basedontheremainingfunc-\ntionorattributenames,wemighthazardaguessthatthismoduleoffersvariousmethodsfor\ngenerating random numbers, including sampling from the uniform distribution ( uniform ),\nnormal distribution ( normal), and multinomial distribution ( multinomial ).\n2.7.2SpecificFunctions and Classes\nFor specific instructions on how to use a given function or class, we can invoke the help\nfunction. Asanexample,let\u2019sexploretheusageinstructionsfortensors\u2019 onesfunction.\nhelp(torch .ones)\nHelp on built-in function ones in module torch:\nones(...)\nones( *size, *, out=None, dtype=None, layout=torch.strided, device=None,\n\u21a9!requires_grad=False) -> Tensor\nReturns a tensor filled with the scalar value 1, with the shape defined\n80 Preliminaries\nby the variable argument size.\nArgs:\nsize (int...): a sequence of integers defining the shape of the \u2423\n\u21a9!output tensor.\nCan be a variable number of arguments or a collection like a \u2423\n\u21a9!list or tuple.\nKeyword arguments:\nout (Tensor, optional): the output tensor.\ndtype (torch.dtype, optional): the desired data type of returned \u2423\n\u21a9!tensor.\nDefault: if None, uses a global default (see torch.set_default_\n\u21a9!tensor_type()).", "mimetype": "text/plain", "start_char_idx": 235804, "end_char_idx": 239727, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "68c1efb8-1656-4606-887a-d6c7379334f6": {"__data__": {"id_": "68c1efb8-1656-4606-887a-d6c7379334f6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3c09aac6-94c6-4437-ad0b-de84ce020bc3", "node_type": "1", "metadata": {}, "hash": "52119cc83628d279623e0aa98263f41ebd59b0cc635e7f729883cda7cca2f888", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f31c5c66-bb37-40b3-81b0-9843fa657cb7", "node_type": "1", "metadata": {}, "hash": "df6d2e5d03e34c69292e25903cef7a2916aca593a5880640d0a880a136245fb0", "class_name": "RelatedNodeInfo"}}, "text": "Asanexample,let\u2019sexploretheusageinstructionsfortensors\u2019 onesfunction.\nhelp(torch .ones)\nHelp on built-in function ones in module torch:\nones(...)\nones( *size, *, out=None, dtype=None, layout=torch.strided, device=None,\n\u21a9!requires_grad=False) -> Tensor\nReturns a tensor filled with the scalar value 1, with the shape defined\n80 Preliminaries\nby the variable argument size.\nArgs:\nsize (int...): a sequence of integers defining the shape of the \u2423\n\u21a9!output tensor.\nCan be a variable number of arguments or a collection like a \u2423\n\u21a9!list or tuple.\nKeyword arguments:\nout (Tensor, optional): the output tensor.\ndtype (torch.dtype, optional): the desired data type of returned \u2423\n\u21a9!tensor.\nDefault: if None, uses a global default (see torch.set_default_\n\u21a9!tensor_type()).\nlayout (torch.layout, optional): the desired layout of returned \u2423\n\u21a9!Tensor.\nDefault: torch.strided.\ndevice (torch.device, optional): the desired device of returned \u2423\n\u21a9!tensor.\nDefault: if None, uses the current device for the default tensor \u2423\n\u21a9!type\n(see torch.set_default_tensor_type()). device will be the CPU\nfor CPU tensor types and the current CUDA device for CUDA tensor \u2423\n\u21a9!types.\nrequires_grad (bool, optional): If autograd should record operations \u2423\n\u21a9!on the\nreturned tensor. Default: False.\nExample::\n>>> torch.ones(2, 3)\ntensor([[ 1., 1., 1.],\n[ 1., 1., 1.]])\n>>> torch.ones(5)\ntensor([ 1., 1., 1., 1., 1.])\nFrom the documentation, we can see that the onesfunction creates a new tensor with the\nspecified shape and sets all the elements to the value of 1. Whenever possible, you should\nrun a quick test to confirm your interpretation:\ntorch .ones( 4)\ntensor([ 1.,1.,1.,1.])\n81 Documentation\n67In the Jupyter notebook, we can use ?to display the document in another window. For\nexample, list?will create content that is almost identical to help(list) , displaying it\nin a new browser window. In addition, if we use two question marks, such as list??, the\nPython code implementing the function will also be displayed.\nThe official documentation provides plenty of descriptions and examples that are beyond\nthis book. We emphasize important use cases that will get you started quickly with prac-\ntical problems, rather than completeness of coverage. We also encourage you to study the\nsource code of the libraries to see examples of high-quality implementations of production\ncode. By doing this you will become a better engineer in addition to becoming a better\nscientist.\nDiscussions67.\n3 Linear Neural Networks for Regression\nBefore we worry about making our neural networks deep, it will be helpful to implement\nsomeshallowones,forwhichtheinputsconnectdirectlytotheoutputs. Thiswillproveim-\nportant for a few reasons. First, rather than getting distracted by complicated architectures,\nwe can focus on the basics of neural network training, including parametrizing the output\nlayer, handling data, specifying a loss function, and training the model. Second, this class\nof shallow networks happens to comprise the set of linear models, which subsumes many\nclassical methods of statistical prediction, including linear and softmax regression. Un-\nderstanding these classical tools is pivotal because they are widely used in many contexts\nand we will often need to use them as baselines when justifying the use of fancier archi-\ntectures. This chapter will focus narrowly on linear regression and the next one will extend\nour modeling repertoire by developing linear neural networks for classification.\n3.1LinearRegression\nRegression problems pop up whenever we want to predict a numerical value. Common ex-\namples include predicting prices (of homes, stocks, etc.), predicting the length of stay (for\npatientsinthehospital),forecastingdemand(forretailsales),amongnumerousothers. Not\neverypredictionproblemisoneofclassicalregression. Lateron,wewillintroduceclassifi-\ncationproblems,wherethegoalistopredictmembershipamongasetofcategories.\nAs a running example, suppose that we wish to estimate the prices of houses (in dollars)\nbased on their area (in square feet) and age (in years). To develop a model for predicting\nhouse prices, we need to get our hands on data, including the sales price, area, and age for\neach home.", "mimetype": "text/plain", "start_char_idx": 238966, "end_char_idx": 243158, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f31c5c66-bb37-40b3-81b0-9843fa657cb7": {"__data__": {"id_": "f31c5c66-bb37-40b3-81b0-9843fa657cb7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "68c1efb8-1656-4606-887a-d6c7379334f6", "node_type": "1", "metadata": {}, "hash": "5975596644d4fa23c9cd29b7fbfd44439b34d59f67c0a3bfd09177b1fecfff77", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "61147081-a760-4e59-918d-5c4e1c1b9cc0", "node_type": "1", "metadata": {}, "hash": "add69deb9abee7b6a6d57b2c3f298b80e237e0f6f6be590405d13d143f514c97", "class_name": "RelatedNodeInfo"}}, "text": "3.1LinearRegression\nRegression problems pop up whenever we want to predict a numerical value. Common ex-\namples include predicting prices (of homes, stocks, etc.), predicting the length of stay (for\npatientsinthehospital),forecastingdemand(forretailsales),amongnumerousothers. Not\neverypredictionproblemisoneofclassicalregression. Lateron,wewillintroduceclassifi-\ncationproblems,wherethegoalistopredictmembershipamongasetofcategories.\nAs a running example, suppose that we wish to estimate the prices of houses (in dollars)\nbased on their area (in square feet) and age (in years). To develop a model for predicting\nhouse prices, we need to get our hands on data, including the sales price, area, and age for\neach home. In the terminology of machine learning, the dataset is called a trainingdataset\nortraining set , and each row (containing the data corresponding to one sale) is called an\nexample (ordata point ,instance,sample). The thing we are trying to predict (price) is\ncalled alabel(ortarget). The variables (age and area) upon which the predictions are\nbased are called features (orcovariates ).\n%matplotlib inline\nimport math\nimport time\nimport numpy asnp\n(continues on next page)\n82\n83 Linear Regression\n(continued from previous page)\nimport torch\nfrom d2l import torch asd2l\n3.1.1Basics\nLinearregression is both the simplest and most popular among the standard tools for tack-\nling regression problems. Dating back to the dawn of the 19th century ( Gauss, 1809 ,Leg-\nendre, 1805 ), linear regression flows from a few simple assumptions. First, we assume that\nthe relationship between features xand target\ud835\udc66is approximately linear, i.e., that the con-\nditional mean \ud835\udc38\u00bb\ud835\udc4cj\ud835\udc4b=x\u00bccan be expressed as a weighted sum of the features x. This\nsetup allows that the target value may still deviate from its expected value on account of\nobservationnoise. Next,wecanimposetheassumptionthatanysuchnoiseiswellbehaved,\nfollowing a Gaussian distribution. Typically, we will use \ud835\udc5bto denote the number of exam-\nples in our dataset. We use superscripts to enumerate samples and targets, and subscripts\nto index coordinates. More concretely, x\u00b9\ud835\udc56\u00badenotes the\ud835\udc56thsample and\ud835\udc65\u00b9\ud835\udc56\u00ba\n\ud835\udc57denotes its\ud835\udc57th\ncoordinate.\nModel\nAt the heart of every solution is a model that describes how features can be transformed\ninto an estimate of the target. The assumption of linearity means that the expected value of\nthe target(price) can be expressedas a weighted sum of the features(area and age):\nprice=\ud835\udc64area\u0001area\u00b8\ud835\udc64age\u0001age\u00b8\ud835\udc4f. (3.1.1)\nHere\ud835\udc64areaand\ud835\udc64ageare called weights, and\ud835\udc4fis called a bias(oroffsetorintercept ). The\nweights determine the influence of each feature on our prediction. The bias determines the\nvalue of the estimate when all features are zero. Even though we will never see any newly-\nbuilt homes with precisely zero area, we still need the bias because it allows us to express\nall linear functions of our features (rather than restricting us to lines that pass through the\norigin). Strictly speaking, (3.1.1 )is ana\ufb00ine transformation of input features, which is\ncharacterized by a linear transformation of features via a weighted sum, combined with a\ntranslation via the added bias. Given a dataset, our goal is to choose the weights wand\nthe bias\ud835\udc4fthat, on average, make our model\u2019s predictions fit the true prices observed in the\ndata as closely as possible.\nIn disciplines where it is common to focus on datasets with just a few features, explicitly\nexpressing models long-form, as in (3.1.1 ), is common. In machine learning, we usually\nwork with high-dimensional datasets, where it is more convenient to employ compact lin-\near algebra notation. When our inputs consist of \ud835\udc51features, we can assign each an index\n(between 1and\ud835\udc51) and express our prediction \u02c6\ud835\udc66(in general the \u201chat\u201d symbol denotes an\nestimate) as\n\u02c6\ud835\udc66=\ud835\udc641\ud835\udc651\u00b8\u0001\u0001\u0001\u00b8\ud835\udc64\ud835\udc51\ud835\udc65\ud835\udc51\u00b8\ud835\udc4f.", "mimetype": "text/plain", "start_char_idx": 242440, "end_char_idx": 246255, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "61147081-a760-4e59-918d-5c4e1c1b9cc0": {"__data__": {"id_": "61147081-a760-4e59-918d-5c4e1c1b9cc0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f31c5c66-bb37-40b3-81b0-9843fa657cb7", "node_type": "1", "metadata": {}, "hash": "df6d2e5d03e34c69292e25903cef7a2916aca593a5880640d0a880a136245fb0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "41ad2588-e366-4c0c-ba1f-0461e147a213", "node_type": "1", "metadata": {}, "hash": "b2f177fa015213f3504ecb120e065d38ea528ccdee2b2d9161eeff2512334d02", "class_name": "RelatedNodeInfo"}}, "text": "Given a dataset, our goal is to choose the weights wand\nthe bias\ud835\udc4fthat, on average, make our model\u2019s predictions fit the true prices observed in the\ndata as closely as possible.\nIn disciplines where it is common to focus on datasets with just a few features, explicitly\nexpressing models long-form, as in (3.1.1 ), is common. In machine learning, we usually\nwork with high-dimensional datasets, where it is more convenient to employ compact lin-\near algebra notation. When our inputs consist of \ud835\udc51features, we can assign each an index\n(between 1and\ud835\udc51) and express our prediction \u02c6\ud835\udc66(in general the \u201chat\u201d symbol denotes an\nestimate) as\n\u02c6\ud835\udc66=\ud835\udc641\ud835\udc651\u00b8\u0001\u0001\u0001\u00b8\ud835\udc64\ud835\udc51\ud835\udc65\ud835\udc51\u00b8\ud835\udc4f. (3.1.2)\n84 Linear Neural Networks for Regression\nCollecting all features into a vector x2R\ud835\udc51and all weights into a vector w2R\ud835\udc51, we can\nexpress our model compactly via the dot product between wandx:\n\u02c6\ud835\udc66=w>x\u00b8\ud835\udc4f. (3.1.3)\nIn(3.1.3 ), the vector xcorresponds to the features of a single example. We will often\nfind it convenient to refer to features of our entire dataset of \ud835\udc5bexamples via the design\nmatrix X2R\ud835\udc5b\u0002\ud835\udc51. Here, Xcontains one row for every example and one column for every\nfeature. For a collection of features X, the predictions \u02c6y2R\ud835\udc5bcan be expressed via the\nmatrix\u2013vector product:\n\u02c6y=Xw\u00b8\ud835\udc4f, (3.1.4)\nwhere broadcasting ( Section 2.1.4 ) is applied during the summation. Given features of a\ntraining dataset Xand corresponding (known) labels y, the goal of linear regression is to\nfindtheweightvector wandthebiasterm \ud835\udc4fsuchthat,givenfeaturesofanewdataexample\nsampled from the same distribution as X, the new example\u2019s label will (in expectation) be\npredicted with the smallest error.\nEven if we believe that the best model for predicting \ud835\udc66givenxis linear, we would not\nexpect to find a real-world dataset of \ud835\udc5bexamples where \ud835\udc66\u00b9\ud835\udc56\u00baexactly equals w>x\u00b9\ud835\udc56\u00ba\u00b8\ud835\udc4f\nfor all 1\u0014\ud835\udc56\u0014\ud835\udc5b. For example, whatever instruments we use to observe the features X\nand labels y, there might be a small amount of measurement error. Thus, even when we\nare confident that the underlying relationship is linear, we will incorporate a noise term to\naccount for such errors.\nBefore we can go about searching for the best parameters (ormodelparameters )wand\ud835\udc4f,\nwe will need two more things: (i) a measure of the quality of some given model; and (ii) a\nprocedure for updating the model to improve its quality.\nLoss Function\nNaturally, fitting our model to the data requires that we agree on some measure of fitness\n(or, equivalently, of unfitness ).Loss functions quantify the distance between the realand\npredicted valuesofthetarget. Thelosswillusuallybeanonnegativenumberwheresmaller\nvaluesarebetterandperfectpredictionsincuralossof0. Forregressionproblems,themost\ncommon loss function is the squared error. When our prediction for an example \ud835\udc56is\u02c6\ud835\udc66\u00b9\ud835\udc56\u00ba\nand the corresponding true label is \ud835\udc66\u00b9\ud835\udc56\u00ba, thesquarederror is given by:\n\ud835\udc59\u00b9\ud835\udc56\u00ba\u00b9w,\ud835\udc4f\u00ba=1\n2\u0010\n\u02c6\ud835\udc66\u00b9\ud835\udc56\u00ba\u0000\ud835\udc66\u00b9\ud835\udc56\u00ba\u00112\n. (3.1.5)\nThe constant1\n2makes no real difference but proves to be notationally convenient, since it\ncancels out when we take the derivative of the loss. Because the training dataset is given\nto us, and thus is out of our control, the empirical error is only a function of the model\nparameters. In Fig. 3.1.1 , we visualize the fit of a linear regression model in a problem\nwith one-dimensional inputs.", "mimetype": "text/plain", "start_char_idx": 245605, "end_char_idx": 248870, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "41ad2588-e366-4c0c-ba1f-0461e147a213": {"__data__": {"id_": "41ad2588-e366-4c0c-ba1f-0461e147a213", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "61147081-a760-4e59-918d-5c4e1c1b9cc0", "node_type": "1", "metadata": {}, "hash": "add69deb9abee7b6a6d57b2c3f298b80e237e0f6f6be590405d13d143f514c97", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a13f254e-a1c0-40b3-9b27-f5f6148ea669", "node_type": "1", "metadata": {}, "hash": "8e9df907fd2214e4beddc5af7ac6e70d0ea686bb46655f860c5d8af169300bd3", "class_name": "RelatedNodeInfo"}}, "text": "When our prediction for an example \ud835\udc56is\u02c6\ud835\udc66\u00b9\ud835\udc56\u00ba\nand the corresponding true label is \ud835\udc66\u00b9\ud835\udc56\u00ba, thesquarederror is given by:\n\ud835\udc59\u00b9\ud835\udc56\u00ba\u00b9w,\ud835\udc4f\u00ba=1\n2\u0010\n\u02c6\ud835\udc66\u00b9\ud835\udc56\u00ba\u0000\ud835\udc66\u00b9\ud835\udc56\u00ba\u00112\n. (3.1.5)\nThe constant1\n2makes no real difference but proves to be notationally convenient, since it\ncancels out when we take the derivative of the loss. Because the training dataset is given\nto us, and thus is out of our control, the empirical error is only a function of the model\nparameters. In Fig. 3.1.1 , we visualize the fit of a linear regression model in a problem\nwith one-dimensional inputs.\nNotethatlargedifferencesbetweenestimates \u02c6\ud835\udc66\u00b9\ud835\udc56\u00baandtargets\ud835\udc66\u00b9\ud835\udc56\u00baleadtoevenlargercontri-\nbutions to the loss, due to its quadratic form (this quadraticity can be a double-edge sword;\n85 Linear Regression\ntFig. 3.1.1 Fitting a linear regression model to one-dimensional data.\nwhile it encourages the model to avoid large errors it can also lead to excessive sensitivity\nto anomalous data). To measure the quality of a model on the entire dataset of \ud835\udc5bexamples,\nwe simply average (or equivalently, sum) the losses on the training set:\n\ud835\udc3f\u00b9w,\ud835\udc4f\u00ba=1\n\ud835\udc5b\ud835\udc5b\u00d5\n\ud835\udc56=1\ud835\udc59\u00b9\ud835\udc56\u00ba\u00b9w,\ud835\udc4f\u00ba=1\n\ud835\udc5b\ud835\udc5b\u00d5\n\ud835\udc56=11\n2\u0010\nw>x\u00b9\ud835\udc56\u00ba\u00b8\ud835\udc4f\u0000\ud835\udc66\u00b9\ud835\udc56\u00ba\u00112\n. (3.1.6)\nWhen training the model, we seek parameters ( w\u0003,\ud835\udc4f\u0003) that minimize the total loss across\nall training examples:\nw\u0003,\ud835\udc4f\u0003=argmin\nw,\ud835\udc4f\ud835\udc3f\u00b9w,\ud835\udc4f\u00ba.(3.1.7)\nAnalyticSolution\nUnlike most of the models that we will cover, linear regression presents us with a surpris-\ningly easy optimization problem. In particular, we can find the optimal parameters (as\nassessed on the training data) analytically by applying a simple formula as follows. First,\nwe can subsume the bias \ud835\udc4finto the parameter wby appending a column to the design ma-\ntrix consisting of all 1s. Then our prediction problem is to minimize ky\u0000Xwk2. As long\nas the design matrix Xhas full rank (no feature is linearly dependent on the others), then\nthere will be just one critical point on the loss surface and it corresponds to the minimum\nof the loss over the entire domain. Taking the derivative of the loss with respect to wand\nsetting it equal to zero yields:\n\ud835\udf15wky\u0000Xwk2=2X>\u00b9Xw\u0000y\u00ba=0and hence X>y=X>Xw. (3.1.8)\nSolving for wprovides us with the optimal solution for the optimization problem. Note\nthat this solution\nw\u0003=\u00b9X>X\u00ba\u00001X>y (3.1.9)\nwillonlybeuniquewhenthematrix X>Xisinvertible,i.e.,whenthecolumnsofthedesign\nmatrix are linearly independent ( Golub and Van Loan, 1996 ).\nWhile simple problems like linear regression may admit analytic solutions, you should\nnotgetusedtosuchgoodfortune. Althoughanalyticsolutionsallowfornicemathematical\nanalysis,therequirementofananalyticsolutionissorestrictivethatitwouldexcludealmost\nall exciting aspects of deep learning.\n86 Linear Neural Networks for Regression\nMinibatchStochasticGradient Descent\nFortunately, even in cases where we cannot solve the models analytically, we can still of-\nten train models effectively in practice. Moreover, for many tasks, those hard-to-optimize\nmodels turn out to be so much better that figuring out howto train them ends up being well\nworth the trouble.\nThe key technique for optimizing nearly every deep learning model, and which we will\ncall upon throughout this book, consists of iteratively reducing the error by updating the\nparameters in the direction that incrementally lowers the loss function. This algorithm is\ncalledgradientdescent .\nThe most naive application of gradient descent consists of taking the derivative of the loss\nfunction,whichisanaverageofthelossescomputedoneverysingleexampleinthedataset.", "mimetype": "text/plain", "start_char_idx": 248325, "end_char_idx": 251806, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a13f254e-a1c0-40b3-9b27-f5f6148ea669": {"__data__": {"id_": "a13f254e-a1c0-40b3-9b27-f5f6148ea669", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "41ad2588-e366-4c0c-ba1f-0461e147a213", "node_type": "1", "metadata": {}, "hash": "b2f177fa015213f3504ecb120e065d38ea528ccdee2b2d9161eeff2512334d02", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "63d7b5e1-45ec-47be-aa2c-371e4271c32c", "node_type": "1", "metadata": {}, "hash": "30f3dfa3c4922ddcaf5586d175259be816fc60a923836b482df4a6d1d5b3d5f2", "class_name": "RelatedNodeInfo"}}, "text": "86 Linear Neural Networks for Regression\nMinibatchStochasticGradient Descent\nFortunately, even in cases where we cannot solve the models analytically, we can still of-\nten train models effectively in practice. Moreover, for many tasks, those hard-to-optimize\nmodels turn out to be so much better that figuring out howto train them ends up being well\nworth the trouble.\nThe key technique for optimizing nearly every deep learning model, and which we will\ncall upon throughout this book, consists of iteratively reducing the error by updating the\nparameters in the direction that incrementally lowers the loss function. This algorithm is\ncalledgradientdescent .\nThe most naive application of gradient descent consists of taking the derivative of the loss\nfunction,whichisanaverageofthelossescomputedoneverysingleexampleinthedataset.\nIn practice, this can be extremely slow: we must pass over the entire dataset before making\na single update, even if the update steps might be very powerful ( Liu and Nocedal, 1989 ).\nEven worse, if there is a lot of redundancy in the training data, the benefit of a full update\nis limited.\nThe other extreme is to consider only a single example at a time and to take update steps\nbased on one observation at a time. The resulting algorithm, stochastic gradient descent\n(SGD) can be an effective strategy ( Bottou, 2010 ), even for large datasets. Unfortunately,\nSGD has drawbacks, both computational and statistical. One problem arises from the fact\nthatprocessorsarealotfastermultiplyingandaddingnumbersthantheyareatmovingdata\nfrom main memory to processor cache. It is up to an order of magnitude more efficient\nto perform a matrix\u2013vector multiplication than a corresponding number of vector\u2013vector\noperations. Thismeansthatitcantakealotlongertoprocessonesampleatatimecompared\nto a full batch. A second problem is that some of the layers, such as batch normalization\n(to be described in Section 8.5 ), only work well when we have access to more than one\nobservation at a time.\nThe solution to both problems is to pick an intermediate strategy: rather than taking a full\nbatchoronlyasinglesampleatatime,wetakea minibatch ofobservations( Lietal.,2014).\nThe specific choice of the size of the said minibatch depends on many factors, such as the\namount of memory, the number of accelerators, the choice of layers, and the total dataset\nsize. Despite all that, a number between 32 and 256, preferably a multiple of a large power\nof2, is a good start. This leads us to minibatchstochasticgradientdescent .\nInitsmostbasicform, ineachiteration \ud835\udc61, wefirstrandomlysampleaminibatch B\ud835\udc61consist-\ning of a fixed number jBjof training examples. We then compute the derivative (gradient)\noftheaveragelossontheminibatchwithrespecttothemodelparameters. Finally,wemul-\ntiply the gradient by a predetermined small positive value \ud835\udf02, called the learning rate , and\nsubtract the resulting term from the current parameter values. We can express the update\nas follows:\n\u00b9w,\ud835\udc4f\u00ba \u00b9w,\ud835\udc4f\u00ba\u0000\ud835\udf02\njBj\u00d5\n\ud835\udc562B\ud835\udc61\ud835\udf15\u00b9w,\ud835\udc4f\u00ba\ud835\udc59\u00b9\ud835\udc56\u00ba\u00b9w,\ud835\udc4f\u00ba.(3.1.10)\nIn summary, minibatch SGD proceeds as follows: (i) initialize the values of the model\n87 Linear Regression\nparameters, typically at random; (ii) iteratively sample random minibatches from the data,\nupdating the parameters in the direction of the negative gradient. For quadratic losses and\naffine transformations, this has a closed-form expansion:\nw w\u0000\ud835\udf02\njBj\u00d5\n\ud835\udc562B\ud835\udc61\ud835\udf15w\ud835\udc59\u00b9\ud835\udc56\u00ba\u00b9w,\ud835\udc4f\u00ba=w\u0000\ud835\udf02\njBj\u00d5\n\ud835\udc562B\ud835\udc61x\u00b9\ud835\udc56\u00ba\u0010\nw>x\u00b9\ud835\udc56\u00ba\u00b8\ud835\udc4f\u0000\ud835\udc66\u00b9\ud835\udc56\u00ba\u0011\n\ud835\udc4f \ud835\udc4f\u0000\ud835\udf02\njBj\u00d5\n\ud835\udc562B\ud835\udc61\ud835\udf15\ud835\udc4f\ud835\udc59\u00b9\ud835\udc56\u00ba\u00b9w,\ud835\udc4f\u00ba=\ud835\udc4f\u0000\ud835\udf02\njBj\u00d5\n\ud835\udc562B\ud835\udc61\u0010\nw>x\u00b9\ud835\udc56\u00ba\u00b8\ud835\udc4f\u0000\ud835\udc66\u00b9\ud835\udc56\u00ba\u0011\n.", "mimetype": "text/plain", "start_char_idx": 250976, "end_char_idx": 254468, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "63d7b5e1-45ec-47be-aa2c-371e4271c32c": {"__data__": {"id_": "63d7b5e1-45ec-47be-aa2c-371e4271c32c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a13f254e-a1c0-40b3-9b27-f5f6148ea669", "node_type": "1", "metadata": {}, "hash": "8e9df907fd2214e4beddc5af7ac6e70d0ea686bb46655f860c5d8af169300bd3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "12d94253-e077-472b-b9c3-37aa97cf3a38", "node_type": "1", "metadata": {}, "hash": "e1c35be37b9e48c83d740dbc7656bdb5ee8dbde3e9781305778f5d2400dfdf38", "class_name": "RelatedNodeInfo"}}, "text": "(3.1.11)\nSince we pick a minibatch Bwe need to normalize by its size jBj. Frequently minibatch\nsize and learning rate are user-defined. Such tunable parameters that are not updated in the\ntraining loop are called hyperparameters . They can be tuned automatically by a number\nof techniques, such as Bayesian optimization ( Frazier, 2018 ). In the end, the quality of the\nsolution is typically assessed on a separate validationdataset (orvalidationset ).\nAfter training for some predetermined number of iterations (or until some other stopping\ncriterionismet),werecordtheestimatedmodelparameters,denoted \u02c6w,\u02c6\ud835\udc4f. Notethatevenif\nourfunctionistrulylinearandnoiseless, theseparameterswillnotbetheexactminimizers\nof the loss, nor even deterministic. Although the algorithm converges slowly towards the\nminimizers it typically will not find them exactly in a finite number of steps. Moreover,\nthe minibatchesBused for updating the parameters are chosen at random. This breaks\ndeterminism.\nLinear regression happens to be a learning problem with a global minimum (whenever X\nis full rank, or equivalently, whenever X>Xis invertible). However, the loss surfaces for\ndeep networks contain many saddle points and minima. Fortunately, we typically do not\ncare about finding an exact set of parameters but merely any set of parameters that leads\nto accurate predictions (and thus low loss). In practice, deep learning practitioners seldom\nstruggle to find parameters that minimize the loss on training sets (Frankle and Carbin,\n2018,Izmailov et al., 2018). The more formidable task is to find parameters that lead\nto accurate predictions on previously unseen data, a challenge called generalization . We\nreturn to these topics throughout the book.\nPredictions\nGiven the model \u02c6w>x\u00b8\u02c6\ud835\udc4f, we can now make predictions for a new example, e.g., pre-\ndicting the sales price of a previously unseen house given its area \ud835\udc651and age\ud835\udc652. Deep\nlearningpractitionershavetakentocallingthepredictionphase inference butthisisabitof\na misnomer\u2014 inference refers broadly to any conclusion reached on the basis of evidence,\nincluding both the values of the parameters and the likely label for an unseen instance. If\nanything, in the statistics literature inference more often denotes parameter inference and\nthis overloading of terminology creates unnecessary confusion when deep learning prac-\ntitioners talk to statisticians. In the following we will stick to prediction whenever possi-\nble.\n3.1.2VectorizationforSpeed\n88 Linear Neural Networks for Regression\nWhentrainingourmodels, wetypicallywanttoprocesswholeminibatchesofexamplessi-\nmultaneously. Doingthisefficientlyrequiresthatwevectorizethecalculationsandleverage\nfast linear algebra libraries rather than writing costly for-loops in Python.\nToseewhythismatterssomuch,let\u2019sconsidertwomethodsforaddingvectors. Tostart,we\ninstantiate two 10,000-dimensional vectors containing all 1s. In the first method, we loop\nover the vectors with a Python for-loop. In the second, we rely on a single call to +.\nn=10000\na=torch .ones(n)\nb=torch .ones(n)\nNow we can benchmark the workloads. First, we add them, one coordinate at a time, using\na for-loop.\nc=torch .zeros(n)\nt=time .time()\nfor iinrange (n):\nc[i] =a[i] +b[i]\nf'{time .time() -t:.5f}sec'\n'0.17802 sec '\nAlternatively, we rely on the reloaded +operator to compute the elementwise sum.\nt=time .time()\nd=a+b\nf'{time .time() -t:.5f}sec'\n'0.00036 sec '\nThesecondmethodisdramaticallyfasterthanthefirst. Vectorizingcodeoftenyieldsorder-\nof-magnitude speedups. Moreover, we push more of the mathematics to the library so we\ndo not have to write as many calculations ourselves, reducing the potential for errors and\nincreasing portability of the code.\n3.1.3The NormalDistribution and SquaredLoss\nSofarwehavegivenafairlyfunctionalmotivationofthesquaredlossobjective: theoptimal\nparameters return the conditional expectation \ud835\udc38\u00bb\ud835\udc4cj\ud835\udc4b\u00bcwhenever the underlying pattern\nis truly linear, and the loss assigns large penalties for outliers.", "mimetype": "text/plain", "start_char_idx": 254468, "end_char_idx": 258457, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "12d94253-e077-472b-b9c3-37aa97cf3a38": {"__data__": {"id_": "12d94253-e077-472b-b9c3-37aa97cf3a38", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "63d7b5e1-45ec-47be-aa2c-371e4271c32c", "node_type": "1", "metadata": {}, "hash": "30f3dfa3c4922ddcaf5586d175259be816fc60a923836b482df4a6d1d5b3d5f2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3f42be62-1814-4568-a4bc-864cd9b2dddf", "node_type": "1", "metadata": {}, "hash": "026e5e8574144f21f0896c8f7e4b7609262d264f4f32b6e5c519fe328704b658", "class_name": "RelatedNodeInfo"}}, "text": "t=time .time()\nd=a+b\nf'{time .time() -t:.5f}sec'\n'0.00036 sec '\nThesecondmethodisdramaticallyfasterthanthefirst. Vectorizingcodeoftenyieldsorder-\nof-magnitude speedups. Moreover, we push more of the mathematics to the library so we\ndo not have to write as many calculations ourselves, reducing the potential for errors and\nincreasing portability of the code.\n3.1.3The NormalDistribution and SquaredLoss\nSofarwehavegivenafairlyfunctionalmotivationofthesquaredlossobjective: theoptimal\nparameters return the conditional expectation \ud835\udc38\u00bb\ud835\udc4cj\ud835\udc4b\u00bcwhenever the underlying pattern\nis truly linear, and the loss assigns large penalties for outliers. We can also provide a more\nformalmotivationforthesquaredlossobjectivebymakingprobabilisticassumptionsabout\nthe distribution of noise.\nLinear regression was invented at the turn of the 19th century. While it has long been\ndebated whether Gauss or Legendre first thought up the idea, it was Gauss who also dis-\ncovered the normal distribution (also called the Gaussian ). It turns out that the normal\n89 Linear Regression\ndistribution and linear regression with squared loss share a deeper connection than com-\nmon parentage.\nTobegin,recallthatanormaldistributionwithmean \ud835\udf07andvariance \ud835\udf0e2(standarddeviation\n\ud835\udf0e) is given as\n\ud835\udc5d\u00b9\ud835\udc65\u00ba=1p\n2\ud835\udf0b\ud835\udf0e2exp\u0012\n\u00001\n2\ud835\udf0e2\u00b9\ud835\udc65\u0000\ud835\udf07\u00ba2\u0013\n. (3.1.12)\nBelow we define a function to compute the normal distribution.\ndef normal (x, mu, sigma):\np=1/math .sqrt( 2*math .pi*sigma **2)\nreturn p*np.exp( -0.5 *(x-mu)**2/sigma **2)\nWe can now visualize the normal distributions.\n# Use NumPy again for visualization\nx=np.arange( -7,7,0.01 )\n# Mean and standard deviation pairs\nparams =[(0,1), ( 0,2), ( 3,1)]\nd2l.plot(x, [normal(x, mu, sigma) for mu, sigma inparams], xlabel ='x',\nylabel ='p(x) ', figsize =(4.5,2.5),\nlegend =[f'mean {mu}, std {sigma }'for mu, sigma inparams])\nNote that changing the mean corresponds to a shift along the \ud835\udc65-axis, and increasing the\nvariance spreads the distribution out, lowering its peak.\nOnewaytomotivatelinearregressionwithsquaredlossistoassumethatobservationsarise\nfromnoisymeasurements,wherethenoise \ud835\udf16followsthenormaldistribution N\u00b90,\ud835\udf0e2\u00ba:\n\ud835\udc66=w>x\u00b8\ud835\udc4f\u00b8\ud835\udf16where\ud835\udf16\u0018N\u00b9 0,\ud835\udf0e2\u00ba. (3.1.13)\nThus, we can now write out the likelihood of seeing a particular \ud835\udc66for a given xvia\n\ud835\udc43\u00b9\ud835\udc66jx\u00ba=1p\n2\ud835\udf0b\ud835\udf0e2exp\u0012\n\u00001\n2\ud835\udf0e2\u00b9\ud835\udc66\u0000w>x\u0000\ud835\udc4f\u00ba2\u0013\n. (3.1.14)\nAs such, the likelihood factorizes. According to the principle of maximum likelihood , the\n90 Linear Neural Networks for Regression\nbest values of parameters wand\ud835\udc4fare those that maximize the likelihood of the entire\ndataset:\n\ud835\udc43\u00b9yjX\u00ba=\ud835\udc5b\u00d6\n\ud835\udc56=1\ud835\udc5d\u00b9\ud835\udc66\u00b9\ud835\udc56\u00bajx\u00b9\ud835\udc56\u00ba\u00ba. (3.1.15)\nTheequalityfollowssinceallpairs \u00b9x\u00b9\ud835\udc56\u00ba,\ud835\udc66\u00b9\ud835\udc56\u00ba\u00baweredrawnindependentlyofeachother. Es-\ntimatorschosenaccordingtotheprincipleofmaximumlikelihoodarecalled maximumlike-\nlihood estimators . While, maximizing the product of many exponential functions, might\nlookdifficult,wecansimplifythingssignificantly,withoutchangingtheobjective,bymax-\nimizing the logarithm of the likelihood instead. For historical reasons, optimizations are\nmoreoftenexpressedasminimizationratherthanmaximization.", "mimetype": "text/plain", "start_char_idx": 257822, "end_char_idx": 260839, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3f42be62-1814-4568-a4bc-864cd9b2dddf": {"__data__": {"id_": "3f42be62-1814-4568-a4bc-864cd9b2dddf", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "12d94253-e077-472b-b9c3-37aa97cf3a38", "node_type": "1", "metadata": {}, "hash": "e1c35be37b9e48c83d740dbc7656bdb5ee8dbde3e9781305778f5d2400dfdf38", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4b93aa5b-0b03-4055-ab37-196da4583e07", "node_type": "1", "metadata": {}, "hash": "c9d6c1ff9c97a3050413d01ab81b34f1a115e52d1dce9d10a290595ea653206a", "class_name": "RelatedNodeInfo"}}, "text": "(3.1.15)\nTheequalityfollowssinceallpairs \u00b9x\u00b9\ud835\udc56\u00ba,\ud835\udc66\u00b9\ud835\udc56\u00ba\u00baweredrawnindependentlyofeachother. Es-\ntimatorschosenaccordingtotheprincipleofmaximumlikelihoodarecalled maximumlike-\nlihood estimators . While, maximizing the product of many exponential functions, might\nlookdifficult,wecansimplifythingssignificantly,withoutchangingtheobjective,bymax-\nimizing the logarithm of the likelihood instead. For historical reasons, optimizations are\nmoreoftenexpressedasminimizationratherthanmaximization. So,withoutchangingany-\nthing,wecan minimize thenegativelog-likelihood ,whichwecanexpressasfollows:\n\u0000log\ud835\udc43\u00b9yjX\u00ba=\ud835\udc5b\u00d5\n\ud835\udc56=11\n2log\u00b92\ud835\udf0b\ud835\udf0e2\u00ba\u00b81\n2\ud835\udf0e2\u0010\n\ud835\udc66\u00b9\ud835\udc56\u00ba\u0000w>x\u00b9\ud835\udc56\u00ba\u0000\ud835\udc4f\u00112\n. (3.1.16)\nIf we assume that \ud835\udf0eis fixed, we can ignore the first term, because it does not depend on w\nor\ud835\udc4f. The second term is identical to the squared error loss introduced earlier, except for\nthe multiplicative constant1\n\ud835\udf0e2. Fortunately, the solution does not depend on \ud835\udf0eeither. It\nfollows that minimizing the mean squared error is equivalent to the maximum likelihood\nestimation of a linear model under the assumption of additive Gaussian noise.\n3.1.4Linear Regressionas a NeuralNetwork\nWhile linear models are not sufficiently rich to express the many complicated networks\nthat we will introduce in this book, (artificial) neural networks are rich enough to subsume\nlinear models as networks in which every feature is represented by an input neuron, all of\nwhich are connected directly to the output.\nFig. 3.1.2 depicts linear regression as a neural network. The diagram highlights the con-\nnectivity pattern, such as how each input is connected to the output, but not the specific\nvalues taken by the weights or biases.\ntFig. 3.1.2 Linear regression is a single-layer neural network.\nTheinputsare \ud835\udc651,...,\ud835\udc65\ud835\udc51. Wereferto \ud835\udc51asthenumberofinputs orthefeaturedimensional-\nityin the input layer. The output of the network is \ud835\udc5c1. Because we are just trying to predict\nasinglenumericalvalue,wehaveonlyoneoutputneuron. Notethattheinputvaluesareall\ngiven. There is just a single computed neuron. In summary, we can think of linear regres-\nsion as a single-layer fully connected neural network. We will encounter networks with far\nmore layers in later chapters.\n91 Linear Regression\nBiology\nBecause linear regression predates computational neuroscience, it might seem anachro-\nnistic to describe linear regression in terms of neural networks. Nonetheless, they were a\nnatural place to start when the cyberneticists and neurophysiologists Warren McCulloch\nand Walter Pitts began to develop models of artificial neurons. Consider the cartoonish\npicture of a biological neuron in Fig. 3.1.3 , consisting of dendrites (input terminals), the\nnucleus(CPU),the axon(outputwire),andthe axonterminals (outputterminals),enabling\nconnections to other neurons via synapses .\nDendrite\nCell bodyNode of\nRanvierAxon T erminal\nSchwann cell\nMyelin sheathAxon\nNucleus\ntFig. 3.1.3 The real neuron (source: \u201cAnatomy and Physiology\u201d by the US National Cancer\nInstitute\u2019s Surveillance, Epidemiology and End Results (SEER) Program).\nInformation \ud835\udc65\ud835\udc56arriving from other neurons (or environmental sensors) is received in the\ndendrites. In particular, that information is weighted by synaptic weights \ud835\udc64\ud835\udc56, determining\nthe effect of the inputs, e.g., activation or inhibition via the product \ud835\udc65\ud835\udc56\ud835\udc64\ud835\udc56. The weighted\ninputs arriving from multiple sources are aggregated in the nucleus as a weighted sum \ud835\udc66=\u00cd\n\ud835\udc56\ud835\udc65\ud835\udc56\ud835\udc64\ud835\udc56\u00b8\ud835\udc4f, possibly subject to some nonlinear postprocessing via a function \ud835\udf0e\u00b9\ud835\udc66\u00ba. This\ninformation is then sent via the axon to the axon terminals, where it reaches its destination\n(e.g., an actuator such as a muscle) or it is fed into another neuron via its dendrites.", "mimetype": "text/plain", "start_char_idx": 260354, "end_char_idx": 264020, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4b93aa5b-0b03-4055-ab37-196da4583e07": {"__data__": {"id_": "4b93aa5b-0b03-4055-ab37-196da4583e07", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3f42be62-1814-4568-a4bc-864cd9b2dddf", "node_type": "1", "metadata": {}, "hash": "026e5e8574144f21f0896c8f7e4b7609262d264f4f32b6e5c519fe328704b658", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "62d58b0d-3c60-484d-a53a-793f9088281f", "node_type": "1", "metadata": {}, "hash": "e8068031a766ef0bc48a05d47fbc6cbcba928d21a9ba1473b86410dd192ff8bb", "class_name": "RelatedNodeInfo"}}, "text": "Information \ud835\udc65\ud835\udc56arriving from other neurons (or environmental sensors) is received in the\ndendrites. In particular, that information is weighted by synaptic weights \ud835\udc64\ud835\udc56, determining\nthe effect of the inputs, e.g., activation or inhibition via the product \ud835\udc65\ud835\udc56\ud835\udc64\ud835\udc56. The weighted\ninputs arriving from multiple sources are aggregated in the nucleus as a weighted sum \ud835\udc66=\u00cd\n\ud835\udc56\ud835\udc65\ud835\udc56\ud835\udc64\ud835\udc56\u00b8\ud835\udc4f, possibly subject to some nonlinear postprocessing via a function \ud835\udf0e\u00b9\ud835\udc66\u00ba. This\ninformation is then sent via the axon to the axon terminals, where it reaches its destination\n(e.g., an actuator such as a muscle) or it is fed into another neuron via its dendrites.\nCertainly, the high-level idea that many such units could be combined, provided they have\nthe correct connectivity and learning algorithm, to produce far more interesting and com-\nplex behavior than any one neuron alone could express arises from our study of real bi-\nological neural systems. At the same time, most research in deep learning today draws\ninspiration from a much wider source. We invoke Russell and Norvig ( 2016) who pointed\nout that although airplanes might have been inspired by birds, ornithology has not been\nthe primary driver of aeronautics innovation for some centuries. Likewise, inspiration in\ndeep learning these days comes in equal or greater measure from mathematics, linguistics,\npsychology, statistics, computer science, and many other fields.\n3.1.5Summary\nInthissection,weintroducedtraditionallinearregression,wheretheparametersofalinear\nfunction are chosen to minimize squared loss on the training set. We also motivated this\nchoice of objective both via some practical considerations and through an interpretation\nof linear regression as maximimum likelihood estimation under an assumption of linearity\nandGaussiannoise. Afterdiscussingbothcomputationalconsiderationsandconnectionsto\n92 Linear Neural Networks for Regression\nstatistics,weshowedhowsuchlinearmodelscouldbeexpressedassimpleneuralnetworks\nwhere the inputs are directly wired to the output(s). While we will soon move past linear\nmodels altogether, they are sufficient to introduce most of the components that all of our\nmodels require: parametric forms, differentiable objectives, optimization via minibatch\nstochastic gradient descent, and ultimately, evaluation on previously unseen data.\n3.1.6Exercises\n1.Assume that we have some data \ud835\udc651,...,\ud835\udc65\ud835\udc5b2R. Our goal is to find a constant \ud835\udc4fsuch\nthat\u00cd\n\ud835\udc56\u00b9\ud835\udc65\ud835\udc56\u0000\ud835\udc4f\u00ba2is minimized.\n1.Find an analytic solution for the optimal value of \ud835\udc4f.\n2.How does this problem and its solution relate to the normal distribution?\n3.Whatifwechangethelossfrom\u00cd\n\ud835\udc56\u00b9\ud835\udc65\ud835\udc56\u0000\ud835\udc4f\u00ba2to\u00cd\n\ud835\udc56j\ud835\udc65\ud835\udc56\u0000\ud835\udc4fj? Canyoufindtheoptimal\nsolution for\ud835\udc4f?\n2.Prove that the affine functions that can be expressed by x>w\u00b8\ud835\udc4fare equivalent to linear\nfunctions on\u00b9x,1\u00ba.\n3.Assume that you want to find quadratic functions of x, i.e.,\ud835\udc53\u00b9x\u00ba=\ud835\udc4f\u00b8\u00cd\n\ud835\udc56\ud835\udc64\ud835\udc56\ud835\udc65\ud835\udc56\u00b8\u00cd\n\ud835\udc57\u0014\ud835\udc56\ud835\udc64\ud835\udc56\ud835\udc57\ud835\udc65\ud835\udc56\ud835\udc65\ud835\udc57. How would you formulate this in a deep network?\n4.Recall that one of the conditions for the linear regression problem to be solvable was\nthat the design matrix X>Xhas full rank.\n1.What happens if this is not the case?\n2.How could you fix it? What happens if you add a small amount of coordinate-wise\nindependent Gaussian noise to all entries of X?\n3.What is the expected value of the design matrix X>Xin this case?\n4.What happens with stochastic gradient descent when X>Xdoes not have full rank?\n5.Assume that the noise model governing the additive noise \ud835\udf16is the exponential distribu-\ntion. That is, \ud835\udc5d\u00b9\ud835\udf16\u00ba=1\n2exp\u00b9\u0000j\ud835\udf16j\u00ba.\n1.Write out the negative log-likelihood of the data under the model \u0000log\ud835\udc43\u00b9yjX\u00ba.\n2.Can you find a closed form solution?\n3.Suggest a minibatch stochastic gradient descent algorithm to solve this problem.", "mimetype": "text/plain", "start_char_idx": 263392, "end_char_idx": 267070, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "62d58b0d-3c60-484d-a53a-793f9088281f": {"__data__": {"id_": "62d58b0d-3c60-484d-a53a-793f9088281f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4b93aa5b-0b03-4055-ab37-196da4583e07", "node_type": "1", "metadata": {}, "hash": "c9d6c1ff9c97a3050413d01ab81b34f1a115e52d1dce9d10a290595ea653206a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "abdcc70f-33c9-427c-8f4d-9421055320a8", "node_type": "1", "metadata": {}, "hash": "cd875a763504ed9c839cadbf9c0c6c51d682670eef4f43f01f92f8f7d856b376", "class_name": "RelatedNodeInfo"}}, "text": "4.Recall that one of the conditions for the linear regression problem to be solvable was\nthat the design matrix X>Xhas full rank.\n1.What happens if this is not the case?\n2.How could you fix it? What happens if you add a small amount of coordinate-wise\nindependent Gaussian noise to all entries of X?\n3.What is the expected value of the design matrix X>Xin this case?\n4.What happens with stochastic gradient descent when X>Xdoes not have full rank?\n5.Assume that the noise model governing the additive noise \ud835\udf16is the exponential distribu-\ntion. That is, \ud835\udc5d\u00b9\ud835\udf16\u00ba=1\n2exp\u00b9\u0000j\ud835\udf16j\u00ba.\n1.Write out the negative log-likelihood of the data under the model \u0000log\ud835\udc43\u00b9yjX\u00ba.\n2.Can you find a closed form solution?\n3.Suggest a minibatch stochastic gradient descent algorithm to solve this problem.\nWhat could possibly go wrong (hint: what happens near the stationary point as we\nkeep on updating the parameters)? Can you fix this?\n6.Assume that we want to design a neural network with two layers by composing two\nlinear layers. That is, the output of the first layer becomes the input of the second layer.\nWhy would such a naive composition not work?\n7.What happens if you want to use regression for realistic price estimation of houses or\nstock prices?\n93 Object-Oriented Design for Implementation\n68\n69\n701.Show that the additive Gaussian noise assumption is not appropriate. Hint: can we\nhave negative prices? What about fluctuations?\n2.Whywouldregressiontothelogarithmofthepricebemuchbetter,i.e., \ud835\udc66=logprice?\n3.Whatdoyouneedtoworryaboutwhendealingwithpennystock,i.e.,stockwithvery\nlow prices? Hint: can you trade at all possible prices? Why is this a bigger problem\nfor cheap stock? For more information review the celebrated Black\u2013Scholes model\nfor option pricing ( Black and Scholes, 1973 ).\n8.Suppose we want to use regression to estimate the number of apples sold in a grocery\nstore.\n1.What are the problems with a Gaussian additive noise model? Hint: you are selling\napples, not oil.\n2.ThePoisson distribution68captures distributions over counts. It is given by \ud835\udc5d\u00b9\ud835\udc58j\n\ud835\udf06\u00ba=\ud835\udf06\ud835\udc58\ud835\udc52\u0000\ud835\udf06\u009d\ud835\udc58!. Here\ud835\udf06is the rate function and \ud835\udc58is the number of events you see.\nProve that\ud835\udf06is the expected value of counts \ud835\udc58.\n3.Design a loss function associated with the Poisson distribution.\n4.Design a loss function for estimating log\ud835\udf06instead.\nDiscussions69.\n3.2Object-Oriented Design forImplementation\nIn our introduction to linear regression, we walked through various components including\nthe data, the model, the loss function, and the optimization algorithm. Indeed, linear re-\ngressionisoneofthesimplestmachinelearningmodels. Trainingit,however,usesmanyof\nthe same components that other models in this book require. Therefore, before diving into\nthe implementation details it is worth designing some of the APIs that we use throughout.\nTreating components in deep learning as objects, we can start by defining classes for these\nobjects and their interactions. This object-oriented design for implementation will greatly\nstreamline the presentation and you might even want to use it in your projects.\nInspired by open-source libraries such as PyTorch Lightning70, at a high level we wish\nto have three classes: (i) Modulecontains models, losses, and optimization methods; (ii)\nDataModule provides data loaders for training and validation; (iii) both classes are com-\nbined using the Trainer class, which allows us to train models on a variety of hardware\nplatforms. Most code in this book adapts ModuleandDataModule . We will touch upon\ntheTrainer class only when we discuss GPUs, CPUs, parallel training, and optimization\nalgorithms.\n94 Linear Neural Networks for Regression\nimport time\nimport numpy asnp\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n3.2.1Utilities\nWeneedafewutilitiestosimplifyobject-orientedprogramminginJupyternotebooks. One\nof the challenges is that class definitions tend to be fairly long blocks of code. Notebook\nreadability demands short code fragments, interspersed with explanations, a requirement\nincompatible with the style of programming common for Python libraries. The first utility\nfunctionallowsustoregisterfunctionsasmethodsinaclass aftertheclasshasbeencreated.", "mimetype": "text/plain", "start_char_idx": 266298, "end_char_idx": 270466, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "abdcc70f-33c9-427c-8f4d-9421055320a8": {"__data__": {"id_": "abdcc70f-33c9-427c-8f4d-9421055320a8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "62d58b0d-3c60-484d-a53a-793f9088281f", "node_type": "1", "metadata": {}, "hash": "e8068031a766ef0bc48a05d47fbc6cbcba928d21a9ba1473b86410dd192ff8bb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "133a8355-0e86-440b-a84a-31ce094f22c1", "node_type": "1", "metadata": {}, "hash": "71cd2eaa2548b501285c401445a0e9db1468ff911c401edb34e46ccc0c7aa0fc", "class_name": "RelatedNodeInfo"}}, "text": "Most code in this book adapts ModuleandDataModule . We will touch upon\ntheTrainer class only when we discuss GPUs, CPUs, parallel training, and optimization\nalgorithms.\n94 Linear Neural Networks for Regression\nimport time\nimport numpy asnp\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n3.2.1Utilities\nWeneedafewutilitiestosimplifyobject-orientedprogramminginJupyternotebooks. One\nof the challenges is that class definitions tend to be fairly long blocks of code. Notebook\nreadability demands short code fragments, interspersed with explanations, a requirement\nincompatible with the style of programming common for Python libraries. The first utility\nfunctionallowsustoregisterfunctionsasmethodsinaclass aftertheclasshasbeencreated.\nIn fact, we can do so evenafter we have created instances of the class! It allows us to split\nthe implementation of a class into multiple code blocks.\ndef add_to_class (Class): #@save\n\"\"\"Register functions as methods in created class.\"\"\"\ndef wrapper (obj):\nsetattr (Class, obj .__name__ , obj)\nreturn wrapper\nLet\u2019s have a quick look at how to use it. We plan to implement a class Awith a method do.\nInstead of having code for both Aanddoin the same code block, we can first declare the\nclass Aand create an instance a.\nclass A:\ndef __init__ (self ):\nself .b=1\na=A()\nNext we define the method doas we normally would, but not in class A\u2019s scope. Instead,\nwe decorate this method by add_to_class with class Aas its argument. In doing so, the\nmethod is able to access the member variables of Ajust as we would expect had it been\nincludedaspartof A\u2019sdefinition. Let\u2019sseewhathappenswhenweinvokeitfortheinstance\na.\n@add_to_class (A)\ndef do(self ):\nprint ('Class attribute \"b\"is',self .b)\na.do()\nClass attribute \"b\"is1\nThe second one is a utility class that saves all arguments in a class\u2019s __init__ method\n95 Object-Oriented Design for Implementation\n71as class attributes. This allows us to extend constructor call signatures implicitly without\nadditional code.\nclass HyperParameters :#@save\n\"\"\"The base class of hyperparameters.\"\"\"\ndef save_hyperparameters (self , ignore =[]):\nraise NotImplemented\nWe defer its implementation into Section B.7 . To use it, we define our class that inherits\nfrom HyperParameters andcalls save_hyperparameters inthe __init__ method.\n# Call the fully implemented HyperParameters class saved in d2l\nclass B(d2l .HyperParameters):\ndef __init__ (self , a, b, c):\nself .save_hyperparameters(ignore =['c'])\nprint ('self.a = ',self .a,'self.b = ',self .b)\nprint ('There is no self.c = ',not hasattr (self ,'c'))\nb=B(a=1, b=2, c=3)\nself .a=1self .b=2\nThere isnoself .c=True\nThe final utility allows us to plot experiment progress interactively while it is going on.\nIn deference to the much more powerful (and complex) TensorBoard71we name it Pro-\ngressBoard . The implementation is deferred to Section B.7 . For now, let\u2019s simply see it\nin action.\nThedrawmethod plots a point (x, y) in the figure, with labelspecified in the legend.\nThe optional every_n smooths the line by only showing 1\u009d\ud835\udc5bpoints in the figure. Their\nvalues are averaged from the \ud835\udc5bneighbor points in the original figure.\nclass ProgressBoard (d2l .HyperParameters): #@save\n\"\"\"The board that plots data points in animation.\"\"\"\ndef __init__ (self , xlabel =None , ylabel =None , xlim =None ,\nylim =None , xscale ='linear ', yscale ='linear ',\nls=['-','--','-.',':'], colors =['C0','C1','C2','C3'],\nfig=None , axes =None , figsize =(3.5,2.5), display =True ):\nself .save_hyperparameters()\ndef draw (self , x, y, label, every_n =1):\nraise NotImplemented\nInthefollowingexample,wedraw sinandcoswithadifferentsmoothness. Ifyourunthis\ncode block, you will see the lines grow in animation.", "mimetype": "text/plain", "start_char_idx": 269719, "end_char_idx": 273433, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "133a8355-0e86-440b-a84a-31ce094f22c1": {"__data__": {"id_": "133a8355-0e86-440b-a84a-31ce094f22c1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "abdcc70f-33c9-427c-8f4d-9421055320a8", "node_type": "1", "metadata": {}, "hash": "cd875a763504ed9c839cadbf9c0c6c51d682670eef4f43f01f92f8f7d856b376", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "be94ea1d-dbd3-40b0-8921-9dbadb91824b", "node_type": "1", "metadata": {}, "hash": "16b8246519d0b4f159d9e11ecb87a49a04556763e39d0db5856c3a498fbd4011", "class_name": "RelatedNodeInfo"}}, "text": "Their\nvalues are averaged from the \ud835\udc5bneighbor points in the original figure.\nclass ProgressBoard (d2l .HyperParameters): #@save\n\"\"\"The board that plots data points in animation.\"\"\"\ndef __init__ (self , xlabel =None , ylabel =None , xlim =None ,\nylim =None , xscale ='linear ', yscale ='linear ',\nls=['-','--','-.',':'], colors =['C0','C1','C2','C3'],\nfig=None , axes =None , figsize =(3.5,2.5), display =True ):\nself .save_hyperparameters()\ndef draw (self , x, y, label, every_n =1):\nraise NotImplemented\nInthefollowingexample,wedraw sinandcoswithadifferentsmoothness. Ifyourunthis\ncode block, you will see the lines grow in animation.\nboard =d2l.ProgressBoard( 'x')\nfor xinnp.arange( 0,10,0.1):\nboard .draw(x, np .sin(x), 'sin', every_n =2)\nboard .draw(x, np .cos(x), 'cos', every_n =10)\n96 Linear Neural Networks for Regression\n3.2.2Models\nThe Module class is the base class of all models we will implement. At the very least\nwe need three methods. The first, __init__ , stores the learnable parameters, the train-\ning_step methodacceptsadatabatchtoreturnthelossvalue,andfinally, configure_optimizers\nreturns the optimization method, or a list of them, that is used to update the learnable pa-\nrameters. Optionally we can define validation_step to report the evaluation measures.\nSometimes we put the code for computing the output into a separate forward method to\nmake it more reusable.\nclass Module (nn.Module, d2l .HyperParameters): #@save\n\"\"\"The base class of models.\"\"\"\ndef __init__ (self , plot_train_per_epoch =2, plot_valid_per_epoch =1):\nsuper ().__init__ ()\nself .save_hyperparameters()\nself .board =ProgressBoard()\ndef loss (self , y_hat, y):\nraise NotImplementedError\ndef forward (self , X):\nassert hasattr (self ,'net'),'Neural network is defined '\nreturn self .net(X)\ndef plot (self , key, value, train):\n\"\"\"Plot a point in animation.\"\"\"\nassert hasattr (self ,'trainer '),'Trainer is not inited '\nself .board .xlabel ='epoch '\niftrain:\nx=self .trainer .train_batch_idx /\\\nself .trainer .num_train_batches\nn=self .trainer .num_train_batches /\\\nself .plot_train_per_epoch\nelse :\nx=self .trainer .epoch +1\nn=self .trainer .num_val_batches /\\\nself .plot_valid_per_epoch\nself .board .draw(x, value .to(d2l .cpu()) .detach() .numpy(),\n('train_ 'iftrain else 'val_ ')+key,\nevery_n =int(n))\n(continues on next page)\n97 Object-Oriented Design for Implementation\n(continued from previous page)\ndef training_step (self , batch):\nl=self .loss( self (*batch[: -1]), batch[ -1])\nself .plot( 'loss ', l, train =True )\nreturn l\ndef validation_step (self , batch):\nl=self .loss( self (*batch[: -1]), batch[ -1])\nself .plot( 'loss ', l, train =False )\ndef configure_optimizers (self ):\nraise NotImplementedError\nYou may notice that Moduleis a subclass of nn.Module , the base class of neural networks\nin PyTorch. It provides convenient features for handling neural networks. For example, if\nwe define a forward method, such as forward(self, X) , then for an instance awe can\ninvoke this method by a(X). This works since it calls the forward method in the built-in\n__call__ method. You can find more details and examples about nn.Module inSection\n6.1.\n3.2.3Data\nTheDataModule class is the base class for data. Quite frequently the __init__ method is\nused to prepare the data. This includes downloading and preprocessing if needed. The\ntrain_dataloader returns the data loader for the training dataset. A data loader is a\n(Python) generator that yields a data batch each time it is used. This batch is then fed\ninto the training_step method of Module to compute the loss. There is an optional\nval_dataloader to return the validation dataset loader. It behaves in the same manner,\nexcept that it yields data batches for the validation_step method in Module.\nclass DataModule (d2l .HyperParameters): #@save\n\"\"\"The base class of data.\"\"\"", "mimetype": "text/plain", "start_char_idx": 272799, "end_char_idx": 276628, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "be94ea1d-dbd3-40b0-8921-9dbadb91824b": {"__data__": {"id_": "be94ea1d-dbd3-40b0-8921-9dbadb91824b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "133a8355-0e86-440b-a84a-31ce094f22c1", "node_type": "1", "metadata": {}, "hash": "71cd2eaa2548b501285c401445a0e9db1468ff911c401edb34e46ccc0c7aa0fc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c4bfdcca-0b4a-4865-8c87-fba0e37fb362", "node_type": "1", "metadata": {}, "hash": "e5d50f553a3249e127a42f0a431a1c0ad056559c1fbead67d0434932b4c81ada", "class_name": "RelatedNodeInfo"}}, "text": "This works since it calls the forward method in the built-in\n__call__ method. You can find more details and examples about nn.Module inSection\n6.1.\n3.2.3Data\nTheDataModule class is the base class for data. Quite frequently the __init__ method is\nused to prepare the data. This includes downloading and preprocessing if needed. The\ntrain_dataloader returns the data loader for the training dataset. A data loader is a\n(Python) generator that yields a data batch each time it is used. This batch is then fed\ninto the training_step method of Module to compute the loss. There is an optional\nval_dataloader to return the validation dataset loader. It behaves in the same manner,\nexcept that it yields data batches for the validation_step method in Module.\nclass DataModule (d2l .HyperParameters): #@save\n\"\"\"The base class of data.\"\"\"\ndef __init__ (self , root ='../data ', num_workers =4):\nself .save_hyperparameters()\ndef get_dataloader (self , train):\nraise NotImplementedError\ndef train_dataloader (self ):\nreturn self .get_dataloader(train =True )\ndef val_dataloader (self ):\nreturn self .get_dataloader(train =False )\n3.2.4Training\nTheTrainer class trains the learnable parameters in the Moduleclass with data specified\ninDataModule . The key method is fit, which accepts two arguments: model, an instance\nofModule, and data, an instance of DataModule . It then iterates over the entire dataset\n98 Linear Neural Networks for Regression\n72\n73max_epochs times to train the model. As before, we will defer the implementation of this\nmethod to later chapters.\nclass Trainer (d2l .HyperParameters): #@save\n\"\"\"The base class for training models with data.\"\"\"\ndef __init__ (self , max_epochs, num_gpus =0, gradient_clip_val =0):\nself .save_hyperparameters()\nassert num_gpus ==0,'No GPU support yet '\ndef prepare_data (self , data):\nself .train_dataloader =data .train_dataloader()\nself .val_dataloader =data .val_dataloader()\nself .num_train_batches =len(self .train_dataloader)\nself .num_val_batches =(len(self .val_dataloader)\nifself .val_dataloader isnot None else 0)\ndef prepare_model (self , model):\nmodel .trainer =self\nmodel .board .xlim =[0,self .max_epochs]\nself .model =model\ndef fit(self , model, data):\nself .prepare_data(data)\nself .prepare_model(model)\nself .optim =model .configure_optimizers()\nself .epoch =0\nself .train_batch_idx =0\nself .val_batch_idx =0\nfor self .epoch inrange (self .max_epochs):\nself .fit_epoch()\ndef fit_epoch (self ):\nraise NotImplementedError\n3.2.5Summary\nTo highlight the object-oriented design for our future deep learning implementation, the\nabove classes simply show how their objects store data and interact with each other. We\nwill keep enriching implementations of these classes, such as via @add_to_class , in the\nrest of the book. Moreover, these fully implemented classes are saved in the D2L library72\n, alightweighttoolkit that makes structured modeling for deep learning easy. In particular,\nit facilitates reusing many components between projects without changing much at all. For\ninstance, we can replace just the optimizer, just the model, just the dataset, etc.; this degree\nof modularity pays dividends throughout the book in terms of conciseness and simplicity\n(this is why we added it) and it can do the same for your own projects.\n3.2.6Exercises\n1.Locate full implementations of the above classes that are saved in the D2L library73\n. We strongly recommend that you look at the implementation in detail once you have\ngained some more familiarity with deep learning modeling.\n99 Synthetic Regression Data\n742.Removethe save_hyperparameters statementinthe Bclass. Canyoustillprint self.a\nandself.b? Optional: if you have dived into the full implementation of the HyperPa-\nrameters class, can you explain why?\nDiscussions74.\n3.3SyntheticRegressionData\nMachine learning is all about extracting information from data. So you might wonder,\nwhat could we possibly learn from synthetic data? While we might not care intrinsically\nabout the patterns that we ourselves baked into an artificial data generating model, such\ndatasets are nevertheless useful for didactic purposes, helping us to evaluate the properties\nof our learning algorithms and to confirm that our implementations work as expected.", "mimetype": "text/plain", "start_char_idx": 275799, "end_char_idx": 280045, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c4bfdcca-0b4a-4865-8c87-fba0e37fb362": {"__data__": {"id_": "c4bfdcca-0b4a-4865-8c87-fba0e37fb362", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "be94ea1d-dbd3-40b0-8921-9dbadb91824b", "node_type": "1", "metadata": {}, "hash": "16b8246519d0b4f159d9e11ecb87a49a04556763e39d0db5856c3a498fbd4011", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "968c65ba-7cd0-453e-875f-cafea63b76dc", "node_type": "1", "metadata": {}, "hash": "ee58087a57e7e31aa4752a2e408ca7adef2ed15591e7d5fb858207f8ea756fe1", "class_name": "RelatedNodeInfo"}}, "text": "We strongly recommend that you look at the implementation in detail once you have\ngained some more familiarity with deep learning modeling.\n99 Synthetic Regression Data\n742.Removethe save_hyperparameters statementinthe Bclass. Canyoustillprint self.a\nandself.b? Optional: if you have dived into the full implementation of the HyperPa-\nrameters class, can you explain why?\nDiscussions74.\n3.3SyntheticRegressionData\nMachine learning is all about extracting information from data. So you might wonder,\nwhat could we possibly learn from synthetic data? While we might not care intrinsically\nabout the patterns that we ourselves baked into an artificial data generating model, such\ndatasets are nevertheless useful for didactic purposes, helping us to evaluate the properties\nof our learning algorithms and to confirm that our implementations work as expected. For\nexample, if we create data for which the correct parameters are known a priori, then we\ncan check that our model can in fact recover them.\n%matplotlib inline\nimport random\nimport torch\nfrom d2l import torch asd2l\n3.3.1Generating the Dataset\nFor this example, we will work in low dimension for succinctness. The following code\nsnippet generates 1000 examples with 2-dimensional features drawn from a standard nor-\nmaldistribution. Theresultingdesignmatrix Xbelongsto R1000\u00022. Wegenerateeachlabel\nby applying a groundtruth linear function, corrupting them via additive noise \ud835\udf50, drawn in-\ndependently and identically for each example:\ny=Xw\u00b8\ud835\udc4f\u00b8\ud835\udf50. (3.3.1)\nFor convenience we assume that \ud835\udf50is drawn from a normal distribution with mean \ud835\udf07=0\nand standard deviation \ud835\udf0e=0.01. Note that for object-oriented design we add the code to\nthe__init__ methodofasubclassof d2l.DataModule (introducedin Section3.2.3 ). Itis\ngood practice to allow the setting of any additional hyperparameters. We accomplish this\nwith save_hyperparameters() . The batch_size will be determined later.\nclass SyntheticRegressionData (d2l .DataModule): #@save\n\"\"\"Synthetic data for linear regression.\"\"\"\ndef __init__ (self , w, b, noise =0.01 , num_train =1000 , num_val =1000 ,\nbatch_size =32):\nsuper ().__init__ ()\nself .save_hyperparameters()\nn=num_train +num_val\n(continues on next page)\n100 Linear Neural Networks for Regression\n(continued from previous page)\nself .X=torch .randn(n, len(w))\nnoise =torch .randn(n, 1)*noise\nself .y=torch .matmul( self .X, w .reshape(( -1,1))) +b+noise\nBelow, we set the true parameters to w=\u00bb2,\u00003.4\u00bc>and\ud835\udc4f=4.2. Later, we can check our\nestimated parameters against these groundtruth values.\ndata =SyntheticRegressionData(w =torch .tensor([ 2,-3.4]), b =4.2)\nEach row in features consists of a vector in R2and each row in labelsis a scalar. Let\u2019s\nhave a look at the first entry.\nprint ('features: ', data .X[0],'\\nlabel: ', data .y[0])\nfeatures: tensor([ 0.9026 ,1.0264 ])\nlabel: tensor([ 2.5148 ])\n3.3.2Readingthe Dataset\nTraining machine learning models often requires multiple passes over a dataset, grabbing\none minibatch of examples at a time. This data is then used to update the model. To\nillustrate how this works, we implement the get_dataloader method, registering it in\ntheSyntheticRegressionData class via add_to_class (introduced in Section 3.2.1 ). It\ntakesa batchsize, a matrix offeatures, anda vectorof labels, and generatesminibatchesof\nsizebatch_size . As such, each minibatch consists of a tuple of features and labels. Note\nthat we need to be mindful of whether we\u2019re in training or validation mode: in the former,\nwewillwanttoreadthedatainrandomorder,whereasforthelatter,beingabletoreaddata\nin a pre-defined order may be important for debugging purposes.", "mimetype": "text/plain", "start_char_idx": 279190, "end_char_idx": 282818, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "968c65ba-7cd0-453e-875f-cafea63b76dc": {"__data__": {"id_": "968c65ba-7cd0-453e-875f-cafea63b76dc", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c4bfdcca-0b4a-4865-8c87-fba0e37fb362", "node_type": "1", "metadata": {}, "hash": "e5d50f553a3249e127a42f0a431a1c0ad056559c1fbead67d0434932b4c81ada", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "127f89c2-677e-486c-9518-de26b67e2fb9", "node_type": "1", "metadata": {}, "hash": "7fa850f6eda41c3401b27bd7759e07a102fb2fbf4bdd4783c1e16021dde11a28", "class_name": "RelatedNodeInfo"}}, "text": "This data is then used to update the model. To\nillustrate how this works, we implement the get_dataloader method, registering it in\ntheSyntheticRegressionData class via add_to_class (introduced in Section 3.2.1 ). It\ntakesa batchsize, a matrix offeatures, anda vectorof labels, and generatesminibatchesof\nsizebatch_size . As such, each minibatch consists of a tuple of features and labels. Note\nthat we need to be mindful of whether we\u2019re in training or validation mode: in the former,\nwewillwanttoreadthedatainrandomorder,whereasforthelatter,beingabletoreaddata\nin a pre-defined order may be important for debugging purposes.\n@d2l .add_to_class(SyntheticRegressionData)\ndef get_dataloader (self , train):\niftrain:\nindices =list (range (0,self .num_train))\n# The examples are read in random order\nrandom .shuffle(indices)\nelse :\nindices =list (range (self .num_train, self .num_train +self .num_val))\nfor iinrange (0,len(indices), self .batch_size):\nbatch_indices =torch .tensor(indices[i: i +self .batch_size])\nyield self .X[batch_indices], self .y[batch_indices]\nTo build some intuition, let\u2019s inspect the first minibatch of data. Each minibatch of fea-\ntures provides us with both its size and the dimensionality of input features. Likewise, our\nminibatch of labels will have a matching shape given by batch_size .\n101 Synthetic Regression Data\nX, y =next (iter (data .train_dataloader()))\nprint ('X shape: ', X.shape, '\\ny shape: ', y.shape)\nX shape: torch .Size([ 32,2])\ny shape: torch .Size([ 32,1])\nWhile seemingly innocuous, the invocation of iter(data.train_dataloader()) illus-\ntrates the power of Python\u2019s object-oriented design. Note that we added a method to the\nSyntheticRegressionData classaftercreating the dataobject. Nonetheless, the object\nbenefits from the ex postfacto addition of functionality to the class.\nThroughout the iteration we obtain distinct minibatches until the entire dataset has been\nexhausted (try this). While the iteration implemented above is good for didactic purposes,\nit is inefficient in ways that might get us into trouble with real problems. For example, it\nrequires that we load all the data in memory and that we perform lots of random memory\naccess. The built-in iterators implemented in a deep learning framework are considerably\nmore efficient and they can deal with sources such as data stored in files, data received via\na stream, and data generated or processed on the fly. Next let\u2019s try to implement the same\nmethod using built-in iterators.\n3.3.3Concise Implementation of the Data Loader\nRather than writing our own iterator, we can call the existing API in a framework to load\ndata. As before, we need a dataset with features Xand labels y. Beyond that, we set\nbatch_size in the built-in data loader and let it take care of shuffling examples effi-\nciently.\n@d2l .add_to_class(d2l .DataModule) #@save\ndef get_tensorloader (self , tensors, train, indices =slice (0,None )):\ntensors =tuple (a[indices] for aintensors)\ndataset =torch .utils .data .TensorDataset( *tensors)\nreturn torch .utils .data .DataLoader(dataset, self .batch_size,\nshuffle =train)\n@d2l .add_to_class(SyntheticRegressionData) #@save\ndef get_dataloader (self , train):\ni=slice (0,self .num_train) iftrain else slice (self .num_train, None )\nreturn self .get_tensorloader(( self .X,self .y), train, i)\nThe new data loader behaves just like the previous one, except that it is more efficient and\nhas some added functionality.\nX, y =next (iter (data .train_dataloader()))\nprint ('X shape: ', X.shape, '\\ny shape: ', y.shape)\n102 Linear Neural Networks for Regression\n75\n76X shape: torch .Size([ 32,2])\ny shape: torch .Size([ 32,1])\nFor instance, the data loader provided by the framework API supports the built-in __len__\nmethod, so we can query its length, i.e., the number of batches.\nlen(data .train_dataloader())\n32\n3.3.4Summary\nData loaders are a convenient way of abstracting out the process of loading and manipu-\nlating data.", "mimetype": "text/plain", "start_char_idx": 282192, "end_char_idx": 286148, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "127f89c2-677e-486c-9518-de26b67e2fb9": {"__data__": {"id_": "127f89c2-677e-486c-9518-de26b67e2fb9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "968c65ba-7cd0-453e-875f-cafea63b76dc", "node_type": "1", "metadata": {}, "hash": "ee58087a57e7e31aa4752a2e408ca7adef2ed15591e7d5fb858207f8ea756fe1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2feeafb8-ad81-40a1-87ea-1e24efd44817", "node_type": "1", "metadata": {}, "hash": "0745b9c52263d2f154153a50c125b6acaa39191f1e64575af0730030dbe72d91", "class_name": "RelatedNodeInfo"}}, "text": "X, y =next (iter (data .train_dataloader()))\nprint ('X shape: ', X.shape, '\\ny shape: ', y.shape)\n102 Linear Neural Networks for Regression\n75\n76X shape: torch .Size([ 32,2])\ny shape: torch .Size([ 32,1])\nFor instance, the data loader provided by the framework API supports the built-in __len__\nmethod, so we can query its length, i.e., the number of batches.\nlen(data .train_dataloader())\n32\n3.3.4Summary\nData loaders are a convenient way of abstracting out the process of loading and manipu-\nlating data. This way the same machine learning algorithm is capable of processing many\ndifferenttypesandsourcesofdatawithouttheneedformodification. Oneofthenicethings\nabout data loaders is that they can be composed. For instance, we might be loading images\nand then have a postprocessing filter that crops them or modifies them in other ways. As\nsuch, data loaders can be used to describe an entire data processing pipeline.\nAs for the model itself, the two-dimensional linear model is about the simplest we might\nencounter. It lets us test out the accuracy of regression models without worrying about\nhaving insufficient amounts of data or an underdetermined system of equations. We will\nput this to good use in the next section.\n3.3.5Exercises\n1.What will happen if the number of examples cannot be divided by the batch size. How\nwould you change this behavior by specifying a different argument by using the frame-\nwork\u2019s API?\n2.Suppose that we want to generate a huge dataset, where both the size of the parameter\nvector wand the number of examples num_examples are large.\n1.What happens if we cannot hold all data in memory?\n2.Howwouldyoushufflethedataifitisheldondisk? Yourtaskistodesignan e\ufb00icient\nalgorithm that does not require too many random reads or writes. Hint: pseudoran-\ndom permutation generators75allow you to design a reshuffle without the need to\nstore the permutation table explicitly ( Naor and Reingold, 1999 ).\n3.Implement a data generator that produces new data on the fly, every time the iterator is\ncalled.\n4.How would you design a random data generator that generates thesame data each time\nit is called?\nDiscussions76.\n103 Linear Regression Implementation from Scratch\n3.4LinearRegressionImplementationfromScratch\nWearenowreadytoworkthroughafullyfunctioningimplementationoflinearregression.\nIn this section, we will implement the entire method from scratch, including (i) the model;\n(ii) the loss function; (iii) a minibatch stochastic gradient descent optimizer; and (iv) the\ntrainingfunctionthatstitchesallofthesepiecestogether. Finally, wewillrunoursynthetic\ndatageneratorfrom Section3.3 andapplyourmodelontheresultingdataset. Whilemodern\ndeep learning frameworks can automate nearly all of this work, implementing things from\nscratch is the only way to make sure that you really know what you are doing. Moreover,\nwhenitistimetocustomizemodels, definingourownlayersorlossfunctions, understand-\ning how things work under the hood will prove handy. In this section, we will rely only\non tensors and automatic differentiation. Later, we will introduce a more concise imple-\nmentation, taking advantage of the bells and whistles of deep learning frameworks while\nretaining the structure of what follows below.\n%matplotlib inline\nimport torch\nfrom d2l import torch asd2l\n3.4.1Definingthe Model\nBefore we can begin optimizing our model\u2019s parameters by minibatch SGD, we need to\nhave some parameters in the first place. In the following we initialize weights by drawing\nrandom numbers from a normal distribution with mean 0 and a standard deviation of 0.01.\nThe magic number 0.01 often works well in practice, but you can specify a different value\nthrough the argument sigma. Moreover we set the bias to 0. Note that for object-oriented\ndesign we add the code to the __init__ method of a subclass of d2l.Module (introduced\ninSection 3.2.2 ).\nclass LinearRegressionScratch (d2l .Module): #@save\n\"\"\"The linear regression model implemented from scratch.\"\"\"\ndef __init__ (self , num_inputs, lr, sigma =0.01 ):\nsuper ().__init__ ()\nself .save_hyperparameters()\nself .w=torch .normal( 0, sigma, (num_inputs, 1), requires_grad =True )\nself .b=torch .zeros( 1, requires_grad =True )\nNext we must define our model, relating its input and parameters to its output.", "mimetype": "text/plain", "start_char_idx": 285642, "end_char_idx": 289917, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2feeafb8-ad81-40a1-87ea-1e24efd44817": {"__data__": {"id_": "2feeafb8-ad81-40a1-87ea-1e24efd44817", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "127f89c2-677e-486c-9518-de26b67e2fb9", "node_type": "1", "metadata": {}, "hash": "7fa850f6eda41c3401b27bd7759e07a102fb2fbf4bdd4783c1e16021dde11a28", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0b1e5549-963d-40bb-9d44-fdcf58581701", "node_type": "1", "metadata": {}, "hash": "41029ac0d7b68353feee8cf246abf8ef9ff51d09c6e20a0e8bed6a8eb30831bd", "class_name": "RelatedNodeInfo"}}, "text": "The magic number 0.01 often works well in practice, but you can specify a different value\nthrough the argument sigma. Moreover we set the bias to 0. Note that for object-oriented\ndesign we add the code to the __init__ method of a subclass of d2l.Module (introduced\ninSection 3.2.2 ).\nclass LinearRegressionScratch (d2l .Module): #@save\n\"\"\"The linear regression model implemented from scratch.\"\"\"\ndef __init__ (self , num_inputs, lr, sigma =0.01 ):\nsuper ().__init__ ()\nself .save_hyperparameters()\nself .w=torch .normal( 0, sigma, (num_inputs, 1), requires_grad =True )\nself .b=torch .zeros( 1, requires_grad =True )\nNext we must define our model, relating its input and parameters to its output. Using the\nsame notation as (3.1.4 )for our linear model we simply take the matrix\u2013vector product of\nthe input features Xand the model weights w, and add the offset \ud835\udc4fto each example. The\nproduct Xwis a vector and \ud835\udc4fis a scalar. Because of the broadcasting mechanism (see\nSection2.1.4 ), whenweaddavectorandascalar, thescalarisaddedtoeachcomponentof\nthe vector. The resulting forward method is registered in the LinearRegressionScratch\nclass via add_to_class (introduced in Section 3.2.1 ).\n104 Linear Neural Networks for Regression\n@d2l .add_to_class(LinearRegressionScratch) #@save\ndef forward (self , X):\nreturn torch .matmul(X, self .w)+self .b\n3.4.2Defining the Loss Function\nSince updating our model requires taking the gradient of our loss function, we ought to\ndefine the loss function first. Here we use the squared loss function in (3.1.5 ). In the\nimplementation, we need to transform the true value yinto the predicted value\u2019s shape\ny_hat. Theresultreturnedbythefollowingmethodwillalsohavethesameshapeas y_hat.\nWe also return the averaged loss value among all examples in the minibatch.\n@d2l .add_to_class(LinearRegressionScratch) #@save\ndef loss (self , y_hat, y):\nl=(y_hat -y)**2/2\nreturn l.mean()\n3.4.3Definingthe OptimizationAlgorithm\nAs discussed in Section 3.1 , linear regression has a closed-form solution. However, our\ngoal here is to illustrate how to train more general neural networks, and that requires that\nwe teach you how to use minibatch SGD. Hence we will take this opportunity to introduce\nyour first working example of SGD. At each step, using a minibatch randomly drawn from\nour dataset, we estimate the gradient of the loss with respect to the parameters. Next, we\nupdate the parameters in the direction that may reduce the loss.\nThe following code applies the update, given a set of parameters, a learning rate lr. Since\nourlossiscomputedasanaverageovertheminibatch,wedonotneedtoadjustthelearning\nrate against the batch size. In later chapters we will investigate how learning rates should\nbe adjusted for very large minibatches as they arise in distributed large-scale learning. For\nnow, we can ignore this dependency.\nWedefineour SGDclass,asubclassof d2l.HyperParameters (introducedin Section3.2.1 ),\nto have a similar API as the built-in SGD optimizer. We update the parameters in the step\nmethod. The zero_grad method sets all gradients to 0, which must be run before a back-\npropagation step.\nclass SGD(d2l .HyperParameters): #@save\n\"\"\"Minibatch stochastic gradient descent.\"\"\"\ndef __init__ (self , params, lr):\nself .save_hyperparameters()\ndef step (self ):\nfor param inself .params:\nparam -=self .lr*param .grad\ndef zero_grad (self ):\n(continues on next page)\n105 Linear Regression Implementation from Scratch\n(continued from previous page)\nfor param inself .params:\nifparam .grad isnot None :\nparam .grad .zero_()\nWe next define the configure_optimizers method, which returns an instance of the SGD\nclass.\n@d2l .add_to_class(LinearRegressionScratch) #@save\ndef configure_optimizers (self ):\nreturn SGD([ self .w,self .b], self .lr)\n3.4.4Training\nNowthatwehaveallofthepartsinplace(parameters,lossfunction,model,andoptimizer),\nwe are ready to implement the main training loop.", "mimetype": "text/plain", "start_char_idx": 289221, "end_char_idx": 293132, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0b1e5549-963d-40bb-9d44-fdcf58581701": {"__data__": {"id_": "0b1e5549-963d-40bb-9d44-fdcf58581701", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2feeafb8-ad81-40a1-87ea-1e24efd44817", "node_type": "1", "metadata": {}, "hash": "0745b9c52263d2f154153a50c125b6acaa39191f1e64575af0730030dbe72d91", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0c85c528-bb94-4028-b1cd-16fcf24cb567", "node_type": "1", "metadata": {}, "hash": "d17b35735d543011957704ea6cf3575237de3f787d65a71ee0ea66066e7d21b4", "class_name": "RelatedNodeInfo"}}, "text": "def __init__ (self , params, lr):\nself .save_hyperparameters()\ndef step (self ):\nfor param inself .params:\nparam -=self .lr*param .grad\ndef zero_grad (self ):\n(continues on next page)\n105 Linear Regression Implementation from Scratch\n(continued from previous page)\nfor param inself .params:\nifparam .grad isnot None :\nparam .grad .zero_()\nWe next define the configure_optimizers method, which returns an instance of the SGD\nclass.\n@d2l .add_to_class(LinearRegressionScratch) #@save\ndef configure_optimizers (self ):\nreturn SGD([ self .w,self .b], self .lr)\n3.4.4Training\nNowthatwehaveallofthepartsinplace(parameters,lossfunction,model,andoptimizer),\nwe are ready to implement the main training loop. It is crucial that you understand this\ncodefullysinceyouwillemploysimilartrainingloopsforeveryotherdeeplearningmodel\ncovered in this book. In each epoch, we iterate through the entire training dataset, passing\nonce through every example (assuming that the number of examples is divisible by the\nbatch size). In each iteration , we grab a minibatch of training examples, and compute its\nloss through the model\u2019s training_step method. Then we compute the gradients with\nrespect to each parameter. Finally, we will call the optimization algorithm to update the\nmodel parameters. In summary, we will execute the following loop:\n\u000fInitialize parameters \u00b9w,\ud835\udc4f\u00ba\n\u000fRepeat until done\n\u2013Compute gradient g \ud835\udf15\u00b9w,\ud835\udc4f\u00ba1\njBj\u00cd\n\ud835\udc562B\ud835\udc59\u00b9x\u00b9\ud835\udc56\u00ba,\ud835\udc66\u00b9\ud835\udc56\u00ba,w,\ud835\udc4f\u00ba\n\u2013Update parameters \u00b9w,\ud835\udc4f\u00ba \u00b9w,\ud835\udc4f\u00ba\u0000\ud835\udf02g\nRecallthatthesyntheticregressiondatasetthatwegeneratedin Section3.3 doesnotprovide\na validation dataset. In most cases, however, we will want a validation dataset to measure\nour model quality. Here we pass the validation dataloader once in each epoch to mea-\nsure the model performance. Following our object-oriented design, the prepare_batch\nandfit_epoch methods are registered in the d2l.Trainer class (introduced in Section\n3.2.4).\n@d2l .add_to_class(d2l .Trainer) #@save\ndef prepare_batch (self , batch):\nreturn batch\n@d2l .add_to_class(d2l .Trainer) #@save\ndef fit_epoch (self ):\nself .model .train()\nfor batch inself .train_dataloader:\nloss =self .model .training_step( self .prepare_batch(batch))\n(continues on next page)\n106 Linear Neural Networks for Regression\n(continued from previous page)\nself .optim .zero_grad()\nwith torch .no_grad():\nloss .backward()\nifself .gradient_clip_val >0:# To be discussed later\nself .clip_gradients( self .gradient_clip_val, self .model)\nself .optim .step()\nself .train_batch_idx +=1\nifself .val_dataloader isNone :\nreturn\nself .model .eval()\nfor batch inself .val_dataloader:\nwith torch .no_grad():\nself .model .validation_step( self .prepare_batch(batch))\nself .val_batch_idx +=1\nWe are almost ready to train the model, but first we need some training data. Here we use\ntheSyntheticRegressionData class and pass in some ground truth parameters. Then\nwe train our model with the learning rate lr=0.03 and set max_epochs=3 . Note that in\ngeneral, both the number of epochs and the learning rate are hyperparameters. In general,\nsetting hyperparameters is tricky and we will usually want to use a three-way split, one\nset for training, a second for hyperparameter selection, and the third reserved for the final\nevaluation. We elide these details for now but will revise them later.\nmodel =LinearRegressionScratch( 2, lr =0.03 )\ndata =d2l.SyntheticRegressionData(w =torch .tensor([ 2,-3.4]), b =4.2)\ntrainer =d2l.Trainer(max_epochs =3)\ntrainer .fit(model, data)\nBecause we synthesized the dataset ourselves, we know precisely what the true parameters\nare. Thus, we can evaluate our success in training by comparing the true parameters with\nthose that we learned through our training loop. Indeed they turn out to be very close to\neach other.", "mimetype": "text/plain", "start_char_idx": 292433, "end_char_idx": 296174, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0c85c528-bb94-4028-b1cd-16fcf24cb567": {"__data__": {"id_": "0c85c528-bb94-4028-b1cd-16fcf24cb567", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0b1e5549-963d-40bb-9d44-fdcf58581701", "node_type": "1", "metadata": {}, "hash": "41029ac0d7b68353feee8cf246abf8ef9ff51d09c6e20a0e8bed6a8eb30831bd", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "196e93bf-5a6c-49cd-8ac5-397df9f380c2", "node_type": "1", "metadata": {}, "hash": "5250a8c81fbad558ceffbd2f0c01dece2f602e70894faef445480060b57fc6d5", "class_name": "RelatedNodeInfo"}}, "text": "Note that in\ngeneral, both the number of epochs and the learning rate are hyperparameters. In general,\nsetting hyperparameters is tricky and we will usually want to use a three-way split, one\nset for training, a second for hyperparameter selection, and the third reserved for the final\nevaluation. We elide these details for now but will revise them later.\nmodel =LinearRegressionScratch( 2, lr =0.03 )\ndata =d2l.SyntheticRegressionData(w =torch .tensor([ 2,-3.4]), b =4.2)\ntrainer =d2l.Trainer(max_epochs =3)\ntrainer .fit(model, data)\nBecause we synthesized the dataset ourselves, we know precisely what the true parameters\nare. Thus, we can evaluate our success in training by comparing the true parameters with\nthose that we learned through our training loop. Indeed they turn out to be very close to\neach other.\nwith torch .no_grad():\nprint (f'error in estimating w: {data .w-model .w.reshape(data .w.shape) }')\nprint (f'error in estimating b: {data .b-model .b}')\n107 Linear Regression Implementation from Scratch\n77\n78error inestimating w: tensor([ 0.1408 ,-0.1493 ])\nerror inestimating b: tensor([ 0.2130 ])\nWe should not take the ability to exactly recover the ground truth parameters for granted.\nIn general, for deep models unique solutions for the parameters do not exist, and even\nfor linear models, exactly recovering the parameters is only possible when no feature is\nlinearlydependentontheothers. However,inmachinelearning,weareoftenlessconcerned\nwith recovering true underlying parameters, but rather with parameters that lead to highly\naccurate prediction ( Vapnik, 1992 ). Fortunately, even on difficult optimization problems,\nstochastic gradient descent can often find remarkably good solutions, owing partly to the\nfact that, for deep networks, there exist many configurations of the parameters that lead to\nhighly accurate prediction.\n3.4.5Summary\nIn this section, we took a significant step towards designing deep learning systems by im-\nplementing a fully functional neural network model and training loop. In this process, we\nbuilt a data loader, a model, a loss function, an optimization procedure, and a visualization\nand monitoring tool. We did this by composing a Python object that contains all relevant\ncomponentsfortrainingamodel. Whilethisisnotyetaprofessional-gradeimplementation\nit is perfectly functional and code like this could already help you to solve small problems\nquickly. In the coming sections, we will see how to do this both more concisely (avoiding\nboilerplate code) and moree\ufb00iciently (using our GPUs to their full potential).\n3.4.6Exercises\n1.What would happen if we were to initialize the weights to zero. Would the algorithm\nstill work? What if we initialized the parameters with variance 1000rather than 0.01?\n2.Assume that you are Georg Simon Ohm77trying to come up with a model for resis-\ntancethatrelatesvoltageandcurrent. Canyouuseautomaticdifferentiationtolearnthe\nparameters of your model?\n3.Can you use Planck\u2019s Law78to determine the temperature of an object using spectral\nenergy density? For reference, the spectral density \ud835\udc35of radiation emanating from a\nblack body is \ud835\udc35\u00b9\ud835\udf06,\ud835\udc47\u00ba=2\u210e\ud835\udc502\n\ud835\udf065\u0001\u0010\nexp\u210e\ud835\udc50\n\ud835\udf06\ud835\udc58\ud835\udc47\u00001\u0011\u00001\n. Here\ud835\udf06is the wavelength, \ud835\udc47is the\ntemperature, \ud835\udc50is the speed of light, \u210eis Planck\u2019s constant, and \ud835\udc58is the Boltzmann\nconstant. You measure the energy for different wavelengths \ud835\udf06and you now need to fit\nthe spectral density curve to Planck\u2019s law.\n4.Whataretheproblemsyoumightencounterifyouwantedtocomputethesecondderiva-\ntives of the loss? How would you fix them?\n5.Why is the reshape method needed in the lossfunction?\n6.Experimentusingdifferentlearningratestofindouthowquicklythelossfunctionvalue\ndrops. Can you reduce the error by increasing the number of epochs of training?\n108 Linear Neural Networks for Regression\n797.Ifthenumberofexamplescannotbedividedbythebatchsize,whathappensto data_iter\nat the end of an epoch?\n8.Try implementing a different loss function, such as the absolute value loss (y_hat -\nd2l.reshape(y, y_hat.shape)).abs().sum() .", "mimetype": "text/plain", "start_char_idx": 295359, "end_char_idx": 299371, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "196e93bf-5a6c-49cd-8ac5-397df9f380c2": {"__data__": {"id_": "196e93bf-5a6c-49cd-8ac5-397df9f380c2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0c85c528-bb94-4028-b1cd-16fcf24cb567", "node_type": "1", "metadata": {}, "hash": "d17b35735d543011957704ea6cf3575237de3f787d65a71ee0ea66066e7d21b4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cec537db-a0d2-428d-a719-531d5e784101", "node_type": "1", "metadata": {}, "hash": "773893593acccd4af056a6f41f1f0375afb69051fe81558549c3cbdbec19d4cb", "class_name": "RelatedNodeInfo"}}, "text": "You measure the energy for different wavelengths \ud835\udf06and you now need to fit\nthe spectral density curve to Planck\u2019s law.\n4.Whataretheproblemsyoumightencounterifyouwantedtocomputethesecondderiva-\ntives of the loss? How would you fix them?\n5.Why is the reshape method needed in the lossfunction?\n6.Experimentusingdifferentlearningratestofindouthowquicklythelossfunctionvalue\ndrops. Can you reduce the error by increasing the number of epochs of training?\n108 Linear Neural Networks for Regression\n797.Ifthenumberofexamplescannotbedividedbythebatchsize,whathappensto data_iter\nat the end of an epoch?\n8.Try implementing a different loss function, such as the absolute value loss (y_hat -\nd2l.reshape(y, y_hat.shape)).abs().sum() .\n1.Check what happens for regular data.\n2.Check whether there is a difference in behavior if you actively perturb some entries,\nsuch as\ud835\udc665=10000, ofy.\n3.Can you think of a cheap solution for combining the best aspects of squared loss and\nabsolute value loss? Hint: how can you avoid really large gradient values?\n9.Why do we need to reshuffle the dataset? Can you design a case where a maliciously\nconstructed dataset would break the optimization algorithm otherwise?\nDiscussions79.\n3.5ConciseImplementation of Linear Regression\nDeep learning has witnessed a sort of Cambrian explosion over the past decade. The sheer\nnumber of techniques, applications and algorithms by far surpasses the progress of pre-\nvious decades. This is due to a fortuitous combination of multiple factors, one of which\nis the powerful free tools offered by a number of open-source deep learning frameworks.\nTheano ( Bergstraet al., 2010), DistBelief ( Deanet al., 2012), and Caffe ( Jiaet al., 2014)\narguably represent the first generation of such models that found widespread adoption.\nIn contrast to earlier (seminal) works like SN2 (Simulateur Neuristique) ( Bottou and Le\nCun, 1988 ), which provided a Lisp-like programming experience, modern frameworks of-\nfer automatic differentiation and the convenience of Python. These frameworks allow us\nto automate and modularize the repetitive work of implementing gradient-based learning\nalgorithms.\nInSection 3.4 , we relied only on (i) tensors for data storage and linear algebra; and (ii)\nautomatic differentiation for calculating gradients. In practice, because data iterators, loss\nfunctions, optimizers, and neural network layers are so common, modern libraries imple-\nment these components for us as well. In this section, we will show you how to implement\nthe linear regression model from Section 3.4 concisely by using high-level APIs of deep\nlearning frameworks.\nimport numpy asnp\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n109 Concise Implementation of Linear Regression\n3.5.1Definingthe Model\nWhenweimplementedlinearregressionfromscratchin Section3.4 , wedefinedourmodel\nparameters explicitly and coded up the calculations to produce output using basic linear\nalgebra operations. You shouldknow how to do this. But once your models get more\ncomplex, and once you have to do this nearly every day, you will be glad of the assistance.\nThe situation is similar to coding up your own blog from scratch. Doing it once or twice\nis rewarding and instructive, but you would be a lousy web developer if you spent a month\nreinventing the wheel.\nFor standard operations, we can use a framework\u2019s predefined layers, which allow us to\nfocus on the layersused to construct the model rather than worrying about their implemen-\ntation. Recall the architecture of a single-layer network as described in Fig. 3.1.2 . The\nlayer is called fully connected , since each of its inputs is connected to each of its outputs\nby means of a matrix\u2013vector multiplication.\nIn PyTorch, the fully connected layer is defined in LinearandLazyLinear classes (avail-\nable since version 1.8.0). The latter allows users to specify merelythe output dimension,\nwhile the former additionally asks for how many inputs go into this layer. Specifying input\nshapes is inconvenient and may require nontrivial calculations (such as in convolutional\nlayers). Thus, for simplicity, we will use such \u201clazy\u201d layers whenever we can.\nclass LinearRegression (d2l .Module): #@save\n\"\"\"The linear regression model implemented with high-level APIs.\"\"\"", "mimetype": "text/plain", "start_char_idx": 298647, "end_char_idx": 302917, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cec537db-a0d2-428d-a719-531d5e784101": {"__data__": {"id_": "cec537db-a0d2-428d-a719-531d5e784101", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "196e93bf-5a6c-49cd-8ac5-397df9f380c2", "node_type": "1", "metadata": {}, "hash": "5250a8c81fbad558ceffbd2f0c01dece2f602e70894faef445480060b57fc6d5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "62803096-4e40-4a71-b06a-a0477fe04661", "node_type": "1", "metadata": {}, "hash": "2306aea7edcd9f6e5b585ded59b4104aafb3c214e56f7e9fac87c222679db88b", "class_name": "RelatedNodeInfo"}}, "text": "Recall the architecture of a single-layer network as described in Fig. 3.1.2 . The\nlayer is called fully connected , since each of its inputs is connected to each of its outputs\nby means of a matrix\u2013vector multiplication.\nIn PyTorch, the fully connected layer is defined in LinearandLazyLinear classes (avail-\nable since version 1.8.0). The latter allows users to specify merelythe output dimension,\nwhile the former additionally asks for how many inputs go into this layer. Specifying input\nshapes is inconvenient and may require nontrivial calculations (such as in convolutional\nlayers). Thus, for simplicity, we will use such \u201clazy\u201d layers whenever we can.\nclass LinearRegression (d2l .Module): #@save\n\"\"\"The linear regression model implemented with high-level APIs.\"\"\"\ndef __init__ (self , lr):\nsuper ().__init__ ()\nself .save_hyperparameters()\nself .net =nn.LazyLinear( 1)\nself .net.weight .data .normal_( 0,0.01 )\nself .net.bias .data .fill_( 0)\nIn the forward method we just invoke the built-in __call__ method of the predefined\nlayers to compute the outputs.\n@d2l .add_to_class(LinearRegression) #@save\ndef forward (self , X):\nreturn self .net(X)\n3.5.2Defining the Loss Function\nTheMSELoss class computes the mean squared error (without the 1\u009d2factor in (3.1.5 )).\nBy default, MSELoss returns the average loss over examples. It is faster (and easier to use)\nthan implementing our own.\n@d2l .add_to_class(LinearRegression) #@save\ndef loss (self , y_hat, y):\nfn=nn.MSELoss()\nreturn fn(y_hat, y)\n110 Linear Neural Networks for Regression\n3.5.3Definingthe OptimizationAlgorithm\nMinibatch SGD is a standard tool for optimizing neural networks and thus PyTorch sup-\nports it alongside a number of variations on this algorithm in the optimmodule. When we\ninstantiate an SGDinstance, we specify the parameters to optimize over, obtainable from\nour model via self.parameters() , and the learning rate ( self.lr ) required by our opti-\nmization algorithm.\n@d2l .add_to_class(LinearRegression) #@save\ndef configure_optimizers (self ):\nreturn torch .optim .SGD( self .parameters(), self .lr)\n3.5.4Training\nYoumighthavenoticedthatexpressingourmodelthroughhigh-levelAPIsofadeeplearn-\ning framework requires fewer lines of code. We did not have to allocate parameters indi-\nvidually, define our loss function, or implement minibatch SGD. Once we start working\nwith much more complex models, the advantages of the high-level API will grow consid-\nerably.\nNow that we have all the basic pieces in place, the training loop itself is the same as the\none we implemented from scratch. So we just call the fitmethod (introduced in Section\n3.2.4),whichreliesontheimplementationofthe fit_epoch methodin Section3.4 ,totrain\nour model.\nmodel =LinearRegression(lr =0.03 )\ndata =d2l.SyntheticRegressionData(w =torch .tensor([ 2,-3.4]), b =4.2)\ntrainer =d2l.Trainer(max_epochs =3)\ntrainer .fit(model, data)\nBelow, we compare the model parameters learned by training on finite data and the actual\nparametersthatgeneratedourdataset. Toaccessparameters,weaccesstheweightsandbias\nof the layer that we need. As in our implementation from scratch, note that our estimated\nparameters are close to their true counterparts.", "mimetype": "text/plain", "start_char_idx": 302145, "end_char_idx": 305338, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "62803096-4e40-4a71-b06a-a0477fe04661": {"__data__": {"id_": "62803096-4e40-4a71-b06a-a0477fe04661", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cec537db-a0d2-428d-a719-531d5e784101", "node_type": "1", "metadata": {}, "hash": "773893593acccd4af056a6f41f1f0375afb69051fe81558549c3cbdbec19d4cb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "811d4bc4-e353-42ee-b491-f04f65640a46", "node_type": "1", "metadata": {}, "hash": "c54c2eed02ee8af5084b161fbd8fc341cb8454b2cd8303a05281f572bcbddb43", "class_name": "RelatedNodeInfo"}}, "text": "Now that we have all the basic pieces in place, the training loop itself is the same as the\none we implemented from scratch. So we just call the fitmethod (introduced in Section\n3.2.4),whichreliesontheimplementationofthe fit_epoch methodin Section3.4 ,totrain\nour model.\nmodel =LinearRegression(lr =0.03 )\ndata =d2l.SyntheticRegressionData(w =torch .tensor([ 2,-3.4]), b =4.2)\ntrainer =d2l.Trainer(max_epochs =3)\ntrainer .fit(model, data)\nBelow, we compare the model parameters learned by training on finite data and the actual\nparametersthatgeneratedourdataset. Toaccessparameters,weaccesstheweightsandbias\nof the layer that we need. As in our implementation from scratch, note that our estimated\nparameters are close to their true counterparts.\n@d2l .add_to_class(LinearRegression) #@save\n(continues on next page)\n111 Concise Implementation of Linear Regression\n(continued from previous page)\ndef get_w_b (self ):\nreturn (self .net.weight .data, self .net.bias .data)\nw, b =model .get_w_b()\nprint (f'error in estimating w: {data .w-w.reshape(data .w.shape) }')\nprint (f'error in estimating b: {data .b-b}')\nerror inestimating w: tensor([ 0.0094 ,-0.0030 ])\nerror inestimating b: tensor([ 0.0137 ])\n3.5.5Summary\nThis section contains the first implementation of a deep network (in this book) to tap into\nthe conveniences afforded by modern deep learning frameworks, such as MXNet ( Chen\net al., 2015), JAX ( Frostiget al., 2018), PyTorch ( Paszkeet al., 2019), and Tensorflow\n(Abadiet al., 2016). We used framework defaults for loading data, defining a layer, a loss\nfunction,anoptimizerandatrainingloop. Whenevertheframeworkprovidesallnecessary\nfeatures, it is generally a good idea to use them, since the library implementations of these\ncomponentstendtobeheavilyoptimizedforperformanceandproperlytestedforreliability.\nAt the same time, try not to forget that these modules canbe implemented directly. This is\nespeciallyimportantforaspiringresearcherswhowishtoliveontheleadingedgeofmodel\ndevelopment, where you will be inventing new components that cannot possibly exist in\nany current library.\nIn PyTorch, the datamodule provides tools for data processing, the nnmodule defines a\nlargenumberofneuralnetworklayersandcommonlossfunctions. Wecaninitializethepa-\nrametersbyreplacingtheirvalueswithmethodsendingwith _. Notethatweneedtospecify\nthe input dimensions of the network. While this is trivial for now, it can have significant\nknock-on effects when we want to design complex networks with many layers. Careful\nconsiderations of how to parametrize these networks is needed to allow portability.\n3.5.6Exercises\n1.How would you need to change the learning rate if you replace the aggregate loss over\nthe minibatch with an average over the loss on the minibatch?\n2.Review the framework documentation to see which loss functions are provided. In par-\nticular, replace the squared loss with Huber\u2019s robust loss function. That is, use the loss\nfunction\n\ud835\udc59\u00b9\ud835\udc66,\ud835\udc660\u00ba=(\nj\ud835\udc66\u0000\ud835\udc660j\u0000\ud835\udf0e\n2ifj\ud835\udc66\u0000\ud835\udc660j>\ud835\udf0e\n1\n2\ud835\udf0e\u00b9\ud835\udc66\u0000\ud835\udc660\u00ba2otherwise(3.5.1)\n3.How do you access the gradient of the weights of the model?\n112 Linear Neural Networks for Regression\n804.What is the effect on the solution if you change the learning rate and the number of\nepochs? Does it keep on improving?\n5.How does the solution change as you vary the amount of data generated?\n1.Plot the estimation error for \u02c6w\u0000wand \u02c6\ud835\udc4f\u0000\ud835\udc4fas a function of the amount of data.\nHint: increase the amount of data logarithmically rather than linearly, i.e., 5, 10, 20,\n50, \u2026, 10,000 rather than 1000, 2000, \u2026, 10,000.\n2.Why is the suggestion in the hint appropriate?\nDiscussions80.\n3.6Generalization\nConsider two college students diligently preparing for their final exam.", "mimetype": "text/plain", "start_char_idx": 304592, "end_char_idx": 308277, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "811d4bc4-e353-42ee-b491-f04f65640a46": {"__data__": {"id_": "811d4bc4-e353-42ee-b491-f04f65640a46", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "62803096-4e40-4a71-b06a-a0477fe04661", "node_type": "1", "metadata": {}, "hash": "2306aea7edcd9f6e5b585ded59b4104aafb3c214e56f7e9fac87c222679db88b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "28742bc0-8105-4e78-a6b2-1c6d6d5e5e8f", "node_type": "1", "metadata": {}, "hash": "39149c2b49a81ee591969b0ab56f2a379633b35ab50066547b2045a98da57628", "class_name": "RelatedNodeInfo"}}, "text": "112 Linear Neural Networks for Regression\n804.What is the effect on the solution if you change the learning rate and the number of\nepochs? Does it keep on improving?\n5.How does the solution change as you vary the amount of data generated?\n1.Plot the estimation error for \u02c6w\u0000wand \u02c6\ud835\udc4f\u0000\ud835\udc4fas a function of the amount of data.\nHint: increase the amount of data logarithmically rather than linearly, i.e., 5, 10, 20,\n50, \u2026, 10,000 rather than 1000, 2000, \u2026, 10,000.\n2.Why is the suggestion in the hint appropriate?\nDiscussions80.\n3.6Generalization\nConsider two college students diligently preparing for their final exam. Commonly, this\npreparation will consist of practicing and testing their abilities by taking exams adminis-\nteredinpreviousyears. Nonetheless,doingwellonpastexamsisnoguaranteethattheywill\nexcelwhenitmatters. Forinstance,imagineastudent,ExtraordinaryEllie,whoseprepara-\ntion consisted entirely of memorizing the answers to previous years\u2019 exam questions. Even\nifElliewereendowedwithanextraordinarymemory,andthuscouldperfectlyrecallthean-\nswer to any previouslyseen question, she might nevertheless freeze when faced with a new\n(previously unseen ) question. By comparison, imagine another student, Inductive Irene,\nwith comparably poor memorization skills, but a knack for picking up patterns. Note that\nif the exam truly consisted of recycled questions from a previous year, Ellie would handily\noutperform Irene. Even if Irene\u2019s inferred patterns yielded 90% accurate predictions, they\ncouldnevercompetewithEllie\u2019s100%recall. However,eveniftheexamconsistedentirely\nof fresh questions, Irene might maintain her 90% average.\nAsmachinelearningscientists,ourgoalistodiscover patterns. Buthowcanwebesurethat\nwehavetrulydiscovereda generalpatternandnotsimplymemorizedourdata? Mostofthe\ntime, our predictions are only useful if our model discovers such a pattern. We do not want\nto predict yesterday\u2019s stock prices, but tomorrow\u2019s. We do not need to recognize already\ndiagnoseddiseasesforpreviouslyseenpatients,butratherpreviouslyundiagnosedailments\nin previously unseen patients. This problem\u2014how to discover patterns that generalize \u2014is\nthe fundamental problem of machine learning, and arguably of all of statistics. We might\ncast this problem as just one slice of a far grander question that engulfs all of science:\nwhen are we ever justified in making the leap from particular observations to more general\nstatements?\nIn real life, we must fit our models using a finite collection of data. The typical scales\nof that data vary wildly across domains. For many important medical problems, we can\nonly access a few thousand data points. When studying rare diseases, we might be lucky to\naccesshundreds. Bycontrast,thelargestpublicdatasetsconsistingoflabeledphotographs,\ne.g., ImageNet( Dengetal., 2009), containmillionsofimages. Andsomeunlabeledimage\n113 Generalization\ncollections such as the Flickr YFC100M dataset can be even larger, containing over 100\nmillion images ( Thomeeet al., 2016). However, even at this extreme scale, the number of\navailable data points remains infinitesimally small compared to the space of all possible\nimages at a megapixel resolution. Whenever we work with finite samples, we must keep in\nmind the risk that we might fit our training data, only to discover that we failed to discover\na generalizable pattern.\nThe phenomenon of fitting closer to our training data than to the underlying distribution is\ncalledoverfitting , and techniques for combatting overfitting are often called regularization\nmethods. While it is no substitute for a proper introduction to statistical learning theory\n(see Boucheron etal.(2005), Vapnik ( 1998)), we will give you just enough intuition to get\ngoing. Wewillrevisitgeneralizationinmanychaptersthroughoutthebook,exploringboth\nwhat is known about the principles underlying generalization in various models, and also\nheuristictechniquesthathavebeenfound(empirically)toyieldimprovedgeneralizationon\ntasks of practical interest.\n3.6.1Training Errorand Generalization Error\nIn the standard supervised learning setting, we assume that the training data and the test\ndata are drawn independently fromidentical distributions. This is commonly called the\nIID assumption .", "mimetype": "text/plain", "start_char_idx": 307665, "end_char_idx": 311901, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "28742bc0-8105-4e78-a6b2-1c6d6d5e5e8f": {"__data__": {"id_": "28742bc0-8105-4e78-a6b2-1c6d6d5e5e8f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "811d4bc4-e353-42ee-b491-f04f65640a46", "node_type": "1", "metadata": {}, "hash": "c54c2eed02ee8af5084b161fbd8fc341cb8454b2cd8303a05281f572bcbddb43", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a4651b7e-529a-4afa-ad0e-919646a806d7", "node_type": "1", "metadata": {}, "hash": "e170a058826884675177f8781e8985b3882a34c37999c9c8269c3910246af5c2", "class_name": "RelatedNodeInfo"}}, "text": "The phenomenon of fitting closer to our training data than to the underlying distribution is\ncalledoverfitting , and techniques for combatting overfitting are often called regularization\nmethods. While it is no substitute for a proper introduction to statistical learning theory\n(see Boucheron etal.(2005), Vapnik ( 1998)), we will give you just enough intuition to get\ngoing. Wewillrevisitgeneralizationinmanychaptersthroughoutthebook,exploringboth\nwhat is known about the principles underlying generalization in various models, and also\nheuristictechniquesthathavebeenfound(empirically)toyieldimprovedgeneralizationon\ntasks of practical interest.\n3.6.1Training Errorand Generalization Error\nIn the standard supervised learning setting, we assume that the training data and the test\ndata are drawn independently fromidentical distributions. This is commonly called the\nIID assumption . While this assumption is strong, it is worth noting that, absent any such\nassumption, we would be dead in the water. Why should we believe that training data\nsampled from distribution \ud835\udc43\u00b9\ud835\udc4b,\ud835\udc4c\u00bashould tell us how to make predictions on test data\ngeneratedbya differentdistribution \ud835\udc44\u00b9\ud835\udc4b,\ud835\udc4c\u00ba? Makingsuchleapsturnsouttorequirestrong\nassumptions about how \ud835\udc43and\ud835\udc44are related. Later on we will discuss some assumptions\nthat allow for shifts in distribution but first we need to understand the IID case, where\n\ud835\udc43\u00b9\u0001\u00ba=\ud835\udc44\u00b9\u0001\u00ba.\nTobeginwith, weneedtodifferentiatebetweenthe trainingerror \ud835\udc45emp, whichisa statistic\ncalculated on the training dataset, and the generalization error \ud835\udc45, which is an expectation\ntaken with respect to the underlying distribution. You can think of the generalization error\nas what you would see if you applied your model to an infinite stream of additional data\nexamples drawn from the same underlying data distribution. Formally the training error is\nexpressed as a sum(with the same notation as Section 3.1 ):\n\ud835\udc45emp\u00bbX,y, \ud835\udc53\u00bc=1\n\ud835\udc5b\ud835\udc5b\u00d5\n\ud835\udc56=1\ud835\udc59\u00b9x\u00b9\ud835\udc56\u00ba,\ud835\udc66\u00b9\ud835\udc56\u00ba, \ud835\udc53\u00b9x\u00b9\ud835\udc56\u00ba\u00ba\u00ba, (3.6.1)\nwhile the generalization error is expressed as an integral:\n\ud835\udc45\u00bb\ud835\udc5d, \ud835\udc53\u00bc=\ud835\udc38\u00b9x,\ud835\udc66\u00ba\u0018\ud835\udc43\u00bb\ud835\udc59\u00b9x,\ud835\udc66, \ud835\udc53\u00b9x\u00ba\u00ba\u00bc=\u00b9 \u00b9\n\ud835\udc59\u00b9x,\ud835\udc66, \ud835\udc53\u00b9x\u00ba\u00ba\ud835\udc5d\u00b9x,\ud835\udc66\u00ba\ud835\udc51x\ud835\udc51\ud835\udc66. (3.6.2)\nProblematically, we can never calculate the generalization error \ud835\udc45exactly. Nobody ever\ntells us the precise form of the density function \ud835\udc5d\u00b9x,\ud835\udc66\u00ba. Moreover, we cannot sample\nan infinite stream of data points. Thus, in practice, we must estimate the generalization\nerror by applying our model to an independent test set constituted of a random selection\nof examples X0and labels y0that were withheld from our training set. This consists of\n114 Linear Neural Networks for Regression\napplying the same formula that was used for calculating the empirical training error but to\na test set X0,y0.\nCrucially,whenweevaluateourclassifieronthetestset,weareworkingwitha fixedclassi-\nfier(itdoesnotdependonthesampleofthetestset), andthusestimatingitserrorissimply\ntheproblemofmeanestimation. Howeverthesamecannotbesaidforthetrainingset. Note\nthat the model we wind up with depends explicitly on the selection of the training set and\nthus the training error will in general be a biased estimate of the true error on the underly-\ning population. The central question of generalization is then when should we expect our\ntraining error to be close to the population error (and thus the generalization error).\nModelComplexity\nIn classical theory, when we have simple models and abundant data, the training and gen-\neralization errors tend to be close. However, when we work with more complex models\nand/or fewer examples, we expect the training error to go down but the generalization gap\nto grow. This should not be surprising.", "mimetype": "text/plain", "start_char_idx": 311015, "end_char_idx": 314606, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a4651b7e-529a-4afa-ad0e-919646a806d7": {"__data__": {"id_": "a4651b7e-529a-4afa-ad0e-919646a806d7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "28742bc0-8105-4e78-a6b2-1c6d6d5e5e8f", "node_type": "1", "metadata": {}, "hash": "39149c2b49a81ee591969b0ab56f2a379633b35ab50066547b2045a98da57628", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a02493ac-e77c-4847-95ce-13836be165e7", "node_type": "1", "metadata": {}, "hash": "f1042b0240b3af1dab788e32acb5f573a45a9e1c455c45b994dedf9536f124e2", "class_name": "RelatedNodeInfo"}}, "text": "Howeverthesamecannotbesaidforthetrainingset. Note\nthat the model we wind up with depends explicitly on the selection of the training set and\nthus the training error will in general be a biased estimate of the true error on the underly-\ning population. The central question of generalization is then when should we expect our\ntraining error to be close to the population error (and thus the generalization error).\nModelComplexity\nIn classical theory, when we have simple models and abundant data, the training and gen-\neralization errors tend to be close. However, when we work with more complex models\nand/or fewer examples, we expect the training error to go down but the generalization gap\nto grow. This should not be surprising. Imagine a model class so expressive that for any\ndataset of\ud835\udc5bexamples, we can find a set of parameters that can perfectly fit arbitrary labels,\neven if randomly assigned. In this case, even if we fit our training data perfectly, how can\nwe conclude anything about the generalization error? For all we know, our generalization\nerror might be no better than random guessing.\nIn general, absent any restriction on our model class, we cannot conclude, based on fitting\nthe training data alone, that our model has discovered any generalizable pattern ( Vapniket\nal., 1994). On the other hand, if our model class was not capable of fitting arbitrary labels,\nthen it must have discovered a pattern. Learning-theoretic ideas about model complexity\nderived some inspiration from the ideas of Karl Popper, an influential philosopher of sci-\nence, who formalized the criterion of falsifiability. According to Popper, a theory that can\nexplainanyandallobservationsisnotascientifictheoryatall! Afterall,whathasittoldus\nabouttheworldifithasnotruledoutanypossibility? Inshort,whatwewantisahypothesis\nthatcould not explain any observations we might conceivably make and yet nevertheless\nhappens to be compatible with those observations that we in factmake.\nNow what precisely constitutes an appropriate notion of model complexity is a complex\nmatter. Often, models with more parameters are able to fit a greater number of arbitrarily\nassignedlabels. However,thisisnotnecessarilytrue. Forinstance,kernelmethodsoperate\nin spaces with infinite numbers of parameters, yet their complexity is controlled by other\nmeans (Sch\u00f6lkopf and Smola, 2002 ). One notion of complexity that often proves useful\nis the range of values that the parameters can take. Here, a model whose parameters are\npermitted to take arbitrary values would be more complex. We will revisit this idea in the\nnextsection,whenweintroduce weightdecay ,yourfirstpracticalregularizationtechnique.\nNotably,itcanbedifficulttocomparecomplexityamongmembersofsubstantiallydifferent\nmodel classes (say, decision trees vs. neural networks).\nAt this point, we must stress another important point that we will revisit when introducing\ndeep neural networks. When a model is capable of fitting arbitrary labels, low training\nerror does not necessarily imply low generalization error. However,itdoesnotnecessarily\n115 Generalization\nimplyhighgeneralizationerroreither! All we can say with confidence is that low training\nerror alone is not enough to certify low generalization error. Deep neural networks turn\nout to be just such models: while they generalize well in practice, they are too powerful\nto allow us to conclude much on the basis of training error alone. In these cases we must\nrely more heavily on our holdout data to certify generalization after the fact. Error on the\nholdout data, i.e., validation set, is called the validationerror .\n3.6.2Underfittingor Overfitting?\nWhen we compare the training and validation errors, we want to be mindful of two com-\nmonsituations. First,wewanttowatchoutforcaseswhenourtrainingerrorandvalidation\nerror are both substantial but there is a little gap between them. If the model is unable to\nreduce the training error, that could mean that our model is too simple (i.e., insufficiently\nexpressive) to capture the pattern that we are trying to model. Moreover, since the gener-\nalization gap (\ud835\udc45emp\u0000\ud835\udc45) between our training and generalization errors is small, we have\nreason to believe that we could get away with a more complex model. This phenomenon is\nknown as underfitting .\nOn the other hand, as we discussed above, we want to watch out for the cases when our\ntraining error is significantly lower than our validation error, indicating severe overfitting .\nNote that overfitting is not always a bad thing.", "mimetype": "text/plain", "start_char_idx": 313875, "end_char_idx": 318395, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a02493ac-e77c-4847-95ce-13836be165e7": {"__data__": {"id_": "a02493ac-e77c-4847-95ce-13836be165e7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a4651b7e-529a-4afa-ad0e-919646a806d7", "node_type": "1", "metadata": {}, "hash": "e170a058826884675177f8781e8985b3882a34c37999c9c8269c3910246af5c2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "190f683a-e61c-4d61-a127-1057b8d5f9ab", "node_type": "1", "metadata": {}, "hash": "390401396e344d2039d92e288e96e0fca140f19c3ea57879244f473c4f130c01", "class_name": "RelatedNodeInfo"}}, "text": "First,wewanttowatchoutforcaseswhenourtrainingerrorandvalidation\nerror are both substantial but there is a little gap between them. If the model is unable to\nreduce the training error, that could mean that our model is too simple (i.e., insufficiently\nexpressive) to capture the pattern that we are trying to model. Moreover, since the gener-\nalization gap (\ud835\udc45emp\u0000\ud835\udc45) between our training and generalization errors is small, we have\nreason to believe that we could get away with a more complex model. This phenomenon is\nknown as underfitting .\nOn the other hand, as we discussed above, we want to watch out for the cases when our\ntraining error is significantly lower than our validation error, indicating severe overfitting .\nNote that overfitting is not always a bad thing. In deep learning especially, the best pre-\ndictive models often perform far better on training data than on holdout data. Ultimately,\nwe usually care about driving the generalization error lower, and only care about the gap\ninsofar as it becomes an obstacle to that end. Note that if the training error is zero, then the\ngeneralization gap is precisely equal to the generalization error and we can make progress\nonly by reducing the gap.\nPolynomialCurveFitting\nTo illustrate some classical intuition about overfitting and model complexity, consider the\nfollowing: given training data consisting of a single feature \ud835\udc65and a corresponding real-\nvalued label \ud835\udc66, we try to find the polynomial of degree \ud835\udc51\n\u02c6\ud835\udc66=\ud835\udc51\u00d5\n\ud835\udc56=0\ud835\udc65\ud835\udc56\ud835\udc64\ud835\udc56 (3.6.3)\nfor estimating the label \ud835\udc66. This is just a linear regression problem where our features are\ngiven by the powers of \ud835\udc65, the model\u2019s weights are given by \ud835\udc64\ud835\udc56, and the bias is given by \ud835\udc640\nsince\ud835\udc650=1for all\ud835\udc65. Since this is just a linear regression problem, we can use the squared\nerror as our loss function.\nA higher-order polynomial function is more complex than a lower-order polynomial func-\ntion,sincethehigher-orderpolynomialhasmoreparametersandthemodelfunction\u2019sselec-\ntion range is wider. Fixing the training dataset, higher-order polynomial functions should\nalways achieve lower (at worst, equal) training error relative to lower-degree polynomials.\nIn fact, whenever each data example has a distinct value of \ud835\udc65, a polynomial function with\ndegree equal to the number of data examples can fit the training set perfectly. We compare\n116 Linear Neural Networks for Regression\nthe relationship between polynomial degree (model complexity) and both underfitting and\noverfitting in Fig. 3.6.1 .\ntFig. 3.6.1 In\ufb02uence of model complexity on under\ufb01tting and over\ufb01tting.\nDatasetSize\nAs the above bound already indicates, another big consideration to bear in mind is dataset\nsize. Fixing our model, the fewer samples we have in the training dataset, the more likely\n(and more severely) we are to encounter overfitting. As we increase the amount of training\ndata, the generalization error typically decreases. Moreover, in general, more data never\nhurts. For a fixed task and data distribution, model complexity should not increase more\nrapidly than the amount of data. Given more data, we might attempt to fit a more complex\nmodel. Absent sufficient data, simpler models may be more difficult to beat. For many\ntasks, deep learning only outperforms linear models when many thousands of training ex-\namplesareavailable. In part, thecurrent successof deeplearning owesconsiderablytothe\nabundance of massive datasets arising from Internet companies, cheap storage, connected\ndevices, and the broad digitization of the economy.\n3.6.3Model Selection\nTypically,weselectourfinalmodelonlyafterevaluatingmultiplemodelsthatdifferinvari-\nous ways (different architectures, training objectives, selected features, data preprocessing,\nlearning rates, etc.). Choosing among manymodels is aptlycalled modelselection .\nIn principle, we should not touch our test set until after we have chosen all our hyperpa-\nrameters. Werewetousethetestdatainthemodelselectionprocess, thereisariskthatwe\nmight overfit the test data. Then we would be in serious trouble. If we overfit our training\ndata, there is always the evaluation on test data to keep us honest. But if we overfit the test\ndata, how would we ever know? See Ong etal.", "mimetype": "text/plain", "start_char_idx": 317623, "end_char_idx": 321813, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "190f683a-e61c-4d61-a127-1057b8d5f9ab": {"__data__": {"id_": "190f683a-e61c-4d61-a127-1057b8d5f9ab", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a02493ac-e77c-4847-95ce-13836be165e7", "node_type": "1", "metadata": {}, "hash": "f1042b0240b3af1dab788e32acb5f573a45a9e1c455c45b994dedf9536f124e2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3b0e344d-e122-4fc3-9c59-a92fd47539c9", "node_type": "1", "metadata": {}, "hash": "78f45731cf73acafba322f212f63f1a57b60a0cc1ffd7cdffc954d1172c51d46", "class_name": "RelatedNodeInfo"}}, "text": "3.6.3Model Selection\nTypically,weselectourfinalmodelonlyafterevaluatingmultiplemodelsthatdifferinvari-\nous ways (different architectures, training objectives, selected features, data preprocessing,\nlearning rates, etc.). Choosing among manymodels is aptlycalled modelselection .\nIn principle, we should not touch our test set until after we have chosen all our hyperpa-\nrameters. Werewetousethetestdatainthemodelselectionprocess, thereisariskthatwe\nmight overfit the test data. Then we would be in serious trouble. If we overfit our training\ndata, there is always the evaluation on test data to keep us honest. But if we overfit the test\ndata, how would we ever know? See Ong etal.(2005) for an example of how this can lead\nto absurd results even for models where the complexity can be tightly controlled.\nThus, we should never rely on the test data for model selection. And yet we cannot rely\nsolely on the training data for model selection either because we cannot estimate the gen-\neralization error on the very data that we use to train the model.\nIn practical applications, the picture gets muddier. While ideally we would only touch the\n117 Generalization\n81\n82test data once, to assess the very best model or to compare a small number of models with\neach other, real-world test data is seldom discarded after just one use. We can seldom\nafford a new test set for each round of experiments. In fact, recycling benchmark data for\ndecades can have a significant impact on the development of algorithms, e.g., for image\nclassification81andoptical character recognition82.\nThe common practice for addressing the problem of training on the test set is to split our\ndata three ways, incorporating a validation set in addition to the training and test datasets.\nThe result is a murky business where the boundaries between validation and test data are\nworryingly ambiguous. Unless explicitly stated otherwise, in the experiments in this book\nwe are really working with what should rightly be called training data and validation data,\nwith no true test sets. Therefore, the accuracy reported in each experiment of the book is\nreally the validation accuracy and not a true test set accuracy.\nCross-Validation\nWhentrainingdataisscarce,wemightnotevenbeabletoaffordtoholdoutenoughdatato\nconstituteapropervalidationset. Onepopularsolutiontothisproblemistoemploy \ud835\udc3e-fold\ncross-validation . Here, the original training data is split into \ud835\udc3enon-overlapping subsets.\nThen model training and validation are executed \ud835\udc3etimes, each time training on \ud835\udc3e\u00001\nsubsets and validating on a different subset (the one not used for training in that round).\nFinally, the training and validation errors are estimated by averaging over the results from\nthe\ud835\udc3eexperiments.\n3.6.4Summary\nThis section explored some of the underpinnings of generalization in machine learning.\nSomeoftheseideasbecomecomplicatedandcounterintuitivewhenwegettodeepermod-\nels; here, modelsarecapableofoverfittingdatabadly, andtherelevantnotionsofcomplex-\nitycanbebothimplicitandcounterintuitive(e.g.,largerarchitectureswithmoreparameters\ngeneralizing better). We leave you with a few rules of thumb:\n1.Use validation sets (or \ud835\udc3e-foldcross-validation ) for model selection;\n2.More complex models often require more data;\n3.Relevant notions of complexity include both the number of parameters and the range of\nvalues that they are allowed to take;\n4.Keeping all else equal, more data almost always leads to better generalization;\n5.This entire talk of generalization is all predicated on the IID assumption. If we relax\nthis assumption, allowing for distributions to shift between the train and testing peri-\nods, then we cannot say anything about generalization absent a further (perhaps milder)\nassumption.\n3.6.5Exercises\n1.When can you solve the problem of polynomial regression exactly?\n118 Linear Neural Networks for Regression\n832.Giveatleastfiveexampleswheredependentrandomvariablesmaketreatingtheproblem\nas IID data inadvisable.\n3.Can you ever expect to see zero training error? Under which circumstances would you\nsee zero generalization error?\n4.Why is\ud835\udc3e-fold cross-validation very expensive to compute?\n5.Why is the\ud835\udc3e-fold cross-validation error estimate biased?\n6.The VC dimension is defined as the maximum number of points that can be classified\nwith arbitrary labels f\u00061gby a function of a class of functions. Why might this not be\na good idea for measuring how complex the class of functions is?", "mimetype": "text/plain", "start_char_idx": 321132, "end_char_idx": 325576, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3b0e344d-e122-4fc3-9c59-a92fd47539c9": {"__data__": {"id_": "3b0e344d-e122-4fc3-9c59-a92fd47539c9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "190f683a-e61c-4d61-a127-1057b8d5f9ab", "node_type": "1", "metadata": {}, "hash": "390401396e344d2039d92e288e96e0fca140f19c3ea57879244f473c4f130c01", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7c22e814-135e-47d3-9f88-74f42f2f2c47", "node_type": "1", "metadata": {}, "hash": "dccff960361a512e34105c549bd7048bce09dc4523f3e59e9dd5980f57ea8cb7", "class_name": "RelatedNodeInfo"}}, "text": "3.6.5Exercises\n1.When can you solve the problem of polynomial regression exactly?\n118 Linear Neural Networks for Regression\n832.Giveatleastfiveexampleswheredependentrandomvariablesmaketreatingtheproblem\nas IID data inadvisable.\n3.Can you ever expect to see zero training error? Under which circumstances would you\nsee zero generalization error?\n4.Why is\ud835\udc3e-fold cross-validation very expensive to compute?\n5.Why is the\ud835\udc3e-fold cross-validation error estimate biased?\n6.The VC dimension is defined as the maximum number of points that can be classified\nwith arbitrary labels f\u00061gby a function of a class of functions. Why might this not be\na good idea for measuring how complex the class of functions is? Hint: consider the\nmagnitude of the functions.\n7.Your manager gives you a difficult dataset on which your current algorithm does not\nperform so well. How would you justify to him that you need more data? Hint: you\ncannot increase the data but you can decrease it.\nDiscussions83.\n3.7WeightDecay\nNow that we have characterized the problem of overfitting, we can introduce our first reg-\nularization technique. Recall that we can always mitigate overfitting by collecting more\ntraining data. However, that can be costly, time consuming, or entirely out of our control,\nmaking it impossible in the short run. For now, we can assume that we already have as\nmuchhigh-qualitydataasourresourcespermitandfocusthetoolsatourdisposalwhenthe\ndataset is taken as a given.\nRecallthatinourpolynomialregressionexample( Section3.6.2 )wecouldlimitourmodel\u2019s\ncapacity by tweaking the degree of the fitted polynomial. Indeed, limiting the number of\nfeatures is a popular technique for mitigating overfitting. However, simply tossing aside\nfeatures can be too blunt an instrument. Sticking with the polynomial regression example,\nconsider what might happen with high-dimensional input. The natural extensions of poly-\nnomials to multivariate data are called monomials , which are simply products of powers\nof variables. The degree of a monomial is the sum of the powers. For example, \ud835\udc652\n1\ud835\udc652, and\n\ud835\udc653\ud835\udc652\n5are both monomials of degree 3.\nNote that the number of terms with degree \ud835\udc51blows up rapidly as \ud835\udc51grows larger. Given \ud835\udc58\nvariables, the number of monomials of degree \ud835\udc51is\u0000\ud835\udc58\u00001\u00b8\ud835\udc51\n\ud835\udc58\u00001\u0001. Even small changes in degree,\nsay from 2to3, dramatically increase the complexity of our model. Thus we often need a\nmore fine-grained tool for adjusting function complexity.\n119 Weight Decay\n%matplotlib inline\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n3.7.1Normsand WeightDecay\nRather than directly manipulating the number of parameters, weight decay , operates by\nrestrictingthevaluesthattheparameterscantake. Morecommonlycalled \u21132regularization\noutside of deep learning circles when optimized by minibatch stochastic gradient descent,\nweightdecaymightbethemostwidelyusedtechniqueforregularizingparametricmachine\nlearningmodels. Thetechniqueismotivatedbythebasicintuitionthatamongallfunctions\n\ud835\udc53, the function \ud835\udc53=0(assigningthevalue 0toallinputs)isin somesensethe simplest, and\nthat we can measure the complexity of a function by the distance of its parameters from\nzero. But how precisely should we measure the distance between a function and zero?\nThere is no single right answer. In fact, entire branches of mathematics, including parts\nof functional analysis and the theory of Banach spaces, are devoted to addressing such\nissues.\nOne simple interpretation might be to measure the complexity of a linear function \ud835\udc53\u00b9x\u00ba=\nw>xby some norm of its weight vector, e.g., kwk2. Recall that we introduced the \u21132norm\nand\u21131norm, which are special cases of the more general \u2113\ud835\udc5dnorm, in Section 2.3.11 . The\nmost common method for ensuring a small weight vector is to add its norm as a penalty\nterm to the problem of minimizing the loss. Thus we replace our original objective, min-\nimizing the prediction loss on the training labels , with new objective, minimizing the sum\nof the prediction loss and the penalty term .", "mimetype": "text/plain", "start_char_idx": 324877, "end_char_idx": 328865, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7c22e814-135e-47d3-9f88-74f42f2f2c47": {"__data__": {"id_": "7c22e814-135e-47d3-9f88-74f42f2f2c47", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3b0e344d-e122-4fc3-9c59-a92fd47539c9", "node_type": "1", "metadata": {}, "hash": "78f45731cf73acafba322f212f63f1a57b60a0cc1ffd7cdffc954d1172c51d46", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "06bf9afa-d5f5-43e3-b4fa-b2caec574e43", "node_type": "1", "metadata": {}, "hash": "0c45821d59fb68def9abeee00dcb34a2c23836464b6d6c4186a0ca9b2e87378e", "class_name": "RelatedNodeInfo"}}, "text": "But how precisely should we measure the distance between a function and zero?\nThere is no single right answer. In fact, entire branches of mathematics, including parts\nof functional analysis and the theory of Banach spaces, are devoted to addressing such\nissues.\nOne simple interpretation might be to measure the complexity of a linear function \ud835\udc53\u00b9x\u00ba=\nw>xby some norm of its weight vector, e.g., kwk2. Recall that we introduced the \u21132norm\nand\u21131norm, which are special cases of the more general \u2113\ud835\udc5dnorm, in Section 2.3.11 . The\nmost common method for ensuring a small weight vector is to add its norm as a penalty\nterm to the problem of minimizing the loss. Thus we replace our original objective, min-\nimizing the prediction loss on the training labels , with new objective, minimizing the sum\nof the prediction loss and the penalty term . Now, if our weight vector grows too large, our\nlearningalgorithmmightfocusonminimizingtheweightnorm kwk2ratherthanminimiz-\ning the training error. That is exactly what we want. To illustrate things in code, we revive\nour previous example from Section 3.1 for linear regression. There, our loss was given\nby\n\ud835\udc3f\u00b9w,\ud835\udc4f\u00ba=1\n\ud835\udc5b\ud835\udc5b\u00d5\n\ud835\udc56=11\n2\u0010\nw>x\u00b9\ud835\udc56\u00ba\u00b8\ud835\udc4f\u0000\ud835\udc66\u00b9\ud835\udc56\u00ba\u00112\n. (3.7.1)\nRecall that x\u00b9\ud835\udc56\u00baare the features, \ud835\udc66\u00b9\ud835\udc56\u00bais the label for any data example \ud835\udc56, and\u00b9w,\ud835\udc4f\u00baare\nthe weight and bias parameters, respectively. To penalize the size of the weight vector,\nwe must somehow add kwk2to the loss function, but how should the model trade off the\nstandard loss for this new additive penalty? In practice, we characterize this trade-off via\ntheregularization constant \ud835\udf06, a nonnegative hyperparameter that we fit using validation\ndata:\n\ud835\udc3f\u00b9w,\ud835\udc4f\u00ba\u00b8\ud835\udf06\n2kwk2. (3.7.2)\nFor\ud835\udf06=0, we recover our original loss function. For \ud835\udf06 > 0, we restrict the size of kwk.\nWe divide by 2by convention: when we take the derivative of a quadratic function, the\n2and 1\u009d2cancel out, ensuring that the expression for the update looks nice and simple.\nThe astute reader might wonder why we work with the squared norm and not the standard\n120 Linear Neural Networks for Regression\nnorm(i.e.,theEuclideandistance). Wedothisforcomputationalconvenience. Bysquaring\nthe\u21132norm, we remove the square root, leaving the sum of squares of each component of\nthe weight vector. This makes the derivative of the penalty easy to compute: the sum of\nderivatives equals the derivative of the sum.\nMoreover, you might ask why we work with the \u21132norm in the first place and not, say,\nthe\u21131norm. In fact, other choices are valid and popular throughout statistics. While \u21132-\nregularized linear models constitute the classic ridge regression algorithm,\u21131-regularized\nlinear regression is a similarly fundamental method in statistics, popularly known as lasso\nregression . Onereasontoworkwiththe \u21132normisthatitplacesanoutsizepenaltyonlarge\ncomponents of the weight vector. This biases our learning algorithm towards models that\ndistribute weight evenly across a larger number of features. In practice, this might make\nthem more robust to measurement error in a single variable. By contrast, \u21131penalties lead\nto models that concentrate weights on a small set of features by clearing the other weights\nto zero. This gives us an effective method for featureselection , which may be desirable for\nother reasons. For example, if our model only relies on a few features, then we may not\nneed to collect, store, or transmit data for the other (dropped) features.\nUsing the same notation in (3.1.11 ), minibatch stochastic gradient descent updates for \u21132-\nregularized regression as follows:\nw \u00b91\u0000\ud835\udf02\ud835\udf06\u00baw\u0000\ud835\udf02\njBj\u00d5\n\ud835\udc562Bx\u00b9\ud835\udc56\u00ba\u0010\nw>x\u00b9\ud835\udc56\u00ba\u00b8\ud835\udc4f\u0000\ud835\udc66\u00b9\ud835\udc56\u00ba\u0011\n.", "mimetype": "text/plain", "start_char_idx": 328028, "end_char_idx": 331603, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "06bf9afa-d5f5-43e3-b4fa-b2caec574e43": {"__data__": {"id_": "06bf9afa-d5f5-43e3-b4fa-b2caec574e43", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7c22e814-135e-47d3-9f88-74f42f2f2c47", "node_type": "1", "metadata": {}, "hash": "dccff960361a512e34105c549bd7048bce09dc4523f3e59e9dd5980f57ea8cb7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "521ae863-11c5-414e-83ea-61acb4de6393", "node_type": "1", "metadata": {}, "hash": "4d04d9601ae5ad4884804fe7bea95d99f79f43e24009a255379324a945cbac54", "class_name": "RelatedNodeInfo"}}, "text": "In practice, this might make\nthem more robust to measurement error in a single variable. By contrast, \u21131penalties lead\nto models that concentrate weights on a small set of features by clearing the other weights\nto zero. This gives us an effective method for featureselection , which may be desirable for\nother reasons. For example, if our model only relies on a few features, then we may not\nneed to collect, store, or transmit data for the other (dropped) features.\nUsing the same notation in (3.1.11 ), minibatch stochastic gradient descent updates for \u21132-\nregularized regression as follows:\nw \u00b91\u0000\ud835\udf02\ud835\udf06\u00baw\u0000\ud835\udf02\njBj\u00d5\n\ud835\udc562Bx\u00b9\ud835\udc56\u00ba\u0010\nw>x\u00b9\ud835\udc56\u00ba\u00b8\ud835\udc4f\u0000\ud835\udc66\u00b9\ud835\udc56\u00ba\u0011\n.(3.7.3)\nAs before, we update wbased on the amount by which our estimate differs from the ob-\nservation. However, we also shrink the size of wtowards zero. That is why the method is\nsometimescalled\u201cweightdecay\u201d: giventhepenaltytermalone,ouroptimizationalgorithm\ndecaysthe weight at each step of training. In contrast to feature selection, weight decay\noffers us a mechanism for continuously adjusting the complexity of a function. Smaller\nvalues of\ud835\udf06correspond to less constrained w, whereas larger values of \ud835\udf06constrain wmore\nconsiderably. Whether we include a corresponding bias penalty \ud835\udc4f2can vary across imple-\nmentations, and may vary across layers of a neural network. Often, we do not regularize\nthe bias term. Besides, although \u21132regularization may not be equivalent to weight decay\nfor other optimization algorithms, the idea of regularization through shrinking the size of\nweights still holds true.\n3.7.2High-Dimensional Linear Regression\nWe can illustrate the benefits of weight decay through a simple synthetic example.\nFirst, we generate some data as before:\n\ud835\udc66=0.05\u00b8\ud835\udc51\u00d5\n\ud835\udc56=10.01\ud835\udc65\ud835\udc56\u00b8\ud835\udf16where\ud835\udf16\u0018N\u00b9 0,0.012\u00ba. (3.7.4)\nIn this synthetic dataset, our label is given by an underlying linear function of our inputs,\ncorrupted by Gaussian noise with zero mean and standard deviation 0.01. For illustrative\npurposes, we can make the effects of overfitting pronounced, by increasing the dimen-\n121 Weight Decay\nsionality of our problem to \ud835\udc51=200and working with a small training set with only 20\nexamples.\nclass Data (d2l .DataModule):\ndef __init__ (self , num_train, num_val, num_inputs, batch_size):\nself .save_hyperparameters()\nn=num_train +num_val\nself .X=torch .randn(n, num_inputs)\nnoise =torch .randn(n, 1)*0.01\nw, b =torch .ones((num_inputs, 1))*0.01 ,0.05\nself .y=torch .matmul( self .X, w) +b+noise\ndef get_dataloader (self , train):\ni=slice (0,self .num_train) iftrain else slice (self .num_train, None )\nreturn self .get_tensorloader([ self .X,self .y], train, i)\n3.7.3Implementation fromScratch\nNow,let\u2019stryimplementingweightdecayfromscratch. Sinceminibatchstochasticgradient\ndescent is our optimizer, we just need to add the squared \u21132penalty to the original loss\nfunction.\nDefining\u21132NormPenalty\nPerhaps the most convenient way of implementing this penalty is to square all terms in\nplace and sum them.\ndef l2_penalty (w):\nreturn (w**2).sum() /2\nDefiningthe Model\nInthefinalmodel,thelinearregressionandthesquaredlosshavenotchangedsince Section\n3.4,sowewilljustdefineasubclassof d2l.LinearRegressionScratch . Theonlychange\nhere is that our loss now includes the penalty term.", "mimetype": "text/plain", "start_char_idx": 330967, "end_char_idx": 334182, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "521ae863-11c5-414e-83ea-61acb4de6393": {"__data__": {"id_": "521ae863-11c5-414e-83ea-61acb4de6393", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "06bf9afa-d5f5-43e3-b4fa-b2caec574e43", "node_type": "1", "metadata": {}, "hash": "0c45821d59fb68def9abeee00dcb34a2c23836464b6d6c4186a0ca9b2e87378e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b21228bc-4516-406a-a004-ecbc82b1dd31", "node_type": "1", "metadata": {}, "hash": "d411c0a7b1404dc0614abef862492f609bcc46d67876dd0b5ac1e5847bc92ad2", "class_name": "RelatedNodeInfo"}}, "text": "Sinceminibatchstochasticgradient\ndescent is our optimizer, we just need to add the squared \u21132penalty to the original loss\nfunction.\nDefining\u21132NormPenalty\nPerhaps the most convenient way of implementing this penalty is to square all terms in\nplace and sum them.\ndef l2_penalty (w):\nreturn (w**2).sum() /2\nDefiningthe Model\nInthefinalmodel,thelinearregressionandthesquaredlosshavenotchangedsince Section\n3.4,sowewilljustdefineasubclassof d2l.LinearRegressionScratch . Theonlychange\nhere is that our loss now includes the penalty term.\nclass WeightDecayScratch (d2l .LinearRegressionScratch):\ndef __init__ (self , num_inputs, lambd, lr, sigma =0.01 ):\nsuper ().__init__ (num_inputs, lr, sigma)\nself .save_hyperparameters()\ndef loss (self , y_hat, y):\nreturn (super ().loss(y_hat, y) +\nself .lambd *l2_penalty( self .w))\nThe following code fits our model on the training set with 20 examples and evaluates it on\nthe validation set with 100 examples.\n122 Linear Neural Networks for Regression\ndata =Data(num_train =20, num_val =100, num_inputs =200, batch_size =5)\ntrainer =d2l.Trainer(max_epochs =10)\ndef train_scratch (lambd):\nmodel =WeightDecayScratch(num_inputs =200, lambd =lambd, lr =0.01 )\nmodel .board .yscale ='log'\ntrainer .fit(model, data)\nprint ('L2 norm of w: ',float (l2_penalty(model .w)))\nTrainingwithout Regularization\nWe now run this code with lambd = 0 , disabling weight decay. Note that we overfit\nbadly, decreasing the training error but not the validation error\u2014a textbook case of over-\nfitting.\ntrain_scratch( 0)\nL2 norm of w: 0.009948714636266232\nUsing WeightDecay\nBelow, we run with substantial weight decay. Note that the training error increases but\nthe validation error decreases. This is precisely the effect we expect from regulariza-\ntion.\ntrain_scratch( 3)\nL2 norm of w: 0.0017270983662456274\n3.7.4Concise Implementation\nBecause weight decay is ubiquitous in neural network optimization, the deep learning\nframework makes it especially convenient, integrating weight decay into the optimization\n123 Weight Decay\n84algorithm itself for easy use in combination with anyloss function. Moreover, this integra-\ntion serves a computational benefit, allowing implementation tricks to add weight decay\nto the algorithm, without any additional computational overhead. Since the weight decay\nportion of the update depends only on the current value of each parameter, the optimizer\nmust touch each parameter once anyway.\nBelow, we specify the weight decay hyperparameter directly through weight_decay when\ninstantiating our optimizer. By default, PyTorch decays both weights and biases simulta-\nneously, but we can configure the optimizer to handle different parameters according to\ndifferent policies. Here, we only set weight_decay for the weights (the net.weight pa-\nrameters), hence the bias (the net.bias parameter) will not decay.\nclass WeightDecay (d2l .LinearRegression):\ndef __init__ (self , wd, lr):\nsuper ().__init__ (lr)\nself .save_hyperparameters()\nself .wd=wd\ndef configure_optimizers (self ):\nreturn torch .optim .SGD([\n{'params ':self .net.weight, 'weight_decay ':self .wd},\n{'params ':self .net.bias}], lr =self .lr)\nThe plot looks similar to that when we implemented weight decay from scratch. How-\never, this version runs faster and is easier to implement, benefits that will become more\npronounced as you address larger problems and this work becomes more routine.\nmodel =WeightDecay(wd =3, lr =0.01 )\nmodel .board .yscale ='log'\ntrainer .fit(model, data)\nprint ('L2 norm of w: ',float (l2_penalty(model .get_w_b()[ 0])))\nL2 norm of w: 0.013779522851109505\nSofar,wehavetouchedupononenotionofwhatconstitutesasimplelinearfunction. How-\never, even for simple nonlinear functions, the situation can be much more complex. To see\nthis, the concept of reproducing kernel Hilbert space (RKHS)84allows one to apply tools\n124 Linear Neural Networks for Regression\n85introduced for linear functions in a nonlinear context.", "mimetype": "text/plain", "start_char_idx": 333650, "end_char_idx": 337598, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b21228bc-4516-406a-a004-ecbc82b1dd31": {"__data__": {"id_": "b21228bc-4516-406a-a004-ecbc82b1dd31", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "521ae863-11c5-414e-83ea-61acb4de6393", "node_type": "1", "metadata": {}, "hash": "4d04d9601ae5ad4884804fe7bea95d99f79f43e24009a255379324a945cbac54", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2e61a564-ff85-4386-86a0-5c5f76482752", "node_type": "1", "metadata": {}, "hash": "26d26365daac065693451b26bfbe03b96dcaba3ed9f0fea09503032d28547c9b", "class_name": "RelatedNodeInfo"}}, "text": "How-\never, this version runs faster and is easier to implement, benefits that will become more\npronounced as you address larger problems and this work becomes more routine.\nmodel =WeightDecay(wd =3, lr =0.01 )\nmodel .board .yscale ='log'\ntrainer .fit(model, data)\nprint ('L2 norm of w: ',float (l2_penalty(model .get_w_b()[ 0])))\nL2 norm of w: 0.013779522851109505\nSofar,wehavetouchedupononenotionofwhatconstitutesasimplelinearfunction. How-\never, even for simple nonlinear functions, the situation can be much more complex. To see\nthis, the concept of reproducing kernel Hilbert space (RKHS)84allows one to apply tools\n124 Linear Neural Networks for Regression\n85introduced for linear functions in a nonlinear context. Unfortunately, RKHS-based algo-\nrithms tend to scale poorly to large, high-dimensional data. In this book we will often\nadopt the common heuristic whereby weight decay is applied to all layers of a deep net-\nwork.\n3.7.5Summary\nRegularization is a common method for dealing with overfitting. Classical regularization\ntechniquesaddapenaltytermtothelossfunction(whentraining)toreducethecomplexity\nof the learned model. One particular choice for keeping the model simple is using an \u21132\npenalty. This leads to weight decay in the update steps of the minibatch stochastic gradient\ndescent algorithm. In practice, the weight decay functionality is provided in optimizers\nfrom deep learning frameworks. Different sets of parameters can have different update\nbehaviors within the same training loop.\n3.7.6Exercises\n1.Experiment with the value of \ud835\udf06in the estimation problem in this section. Plot training\nand validation accuracy as a function of \ud835\udf06. What do you observe?\n2.Use a validation set to find the optimal value of \ud835\udf06. Is it really the optimal value? Does\nthis matter?\n3.What would the update equations look like if instead of kwk2we used\u00cd\n\ud835\udc56j\ud835\udc64\ud835\udc56jas our\npenalty of choice ( \u21131regularization)?\n4.We know thatkwk2=w>w. Can you find a similar equation for matrices (see the\nFrobenius norm in Section 2.3.11 )?\n5.Review the relationship between training error and generalization error. In addition to\nweight decay, increased training, and the use of a model of suitable complexity, what\nother ways might help us deal with overfitting?\n6.In Bayesian statistics we use the product of prior and likelihood to arrive at a posterior\nvia\ud835\udc43\u00b9\ud835\udc64j\ud835\udc65\u00ba/\ud835\udc43\u00b9\ud835\udc65j\ud835\udc64\u00ba\ud835\udc43\u00b9\ud835\udc64\u00ba. How can you identify \ud835\udc43\u00b9\ud835\udc64\u00bawith regularization?\nDiscussions85.\n4 Linear Neural Networks for Classi\ufb01cation\nNow that you have worked through all of the mechanics you are ready to apply the skills\nyou have learned to broader kinds of tasks. Even as we pivot towards classification, most\nof the plumbing remains the same: loading the data, passing it through the model, generat-\ning output, calculating the loss, taking gradients with respect to weights, and updating the\nmodel. However, the precise form of the targets, the parametrization of the output layer,\nand the choice of loss function will adapt to suit the classification setting.\n4.1SoftmaxRegression\nInSection 3.1 , we introduced linear regression, working through implementations from\nscratch in Section 3.4 and again using high-level APIs of a deep learning framework in\nSection 3.5 to do the heavy lifting.\nRegression is the hammer wereachforwhen wewantto answer howmuch? orhowmany?\nquestions. Ifyouwanttopredictthenumberofdollars(price)atwhichahousewillbesold,\nor the number of wins a baseball team might have, or the number of days that a patient will\nremainhospitalizedbeforebeingdischarged,thenyouareprobablylookingforaregression\nmodel. However, even within regression models, there are important distinctions. For\ninstance, the price of a house will never be negative and changes might often be relative\nto its baseline price. As such, it might be more effective to regress on the logarithm of the\nprice. Likewise, the number of days a patient spends in hospital is a discrete nonnegative\nrandom variable. As such, least mean squares might not be an ideal approach either.", "mimetype": "text/plain", "start_char_idx": 336879, "end_char_idx": 340875, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2e61a564-ff85-4386-86a0-5c5f76482752": {"__data__": {"id_": "2e61a564-ff85-4386-86a0-5c5f76482752", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b21228bc-4516-406a-a004-ecbc82b1dd31", "node_type": "1", "metadata": {}, "hash": "d411c0a7b1404dc0614abef862492f609bcc46d67876dd0b5ac1e5847bc92ad2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7850297b-a989-4039-a16e-2225725936e6", "node_type": "1", "metadata": {}, "hash": "52e1cc9bb32f4a78e0a637207cb8b1fbcf7b5bd30039240607eda6013b4633a5", "class_name": "RelatedNodeInfo"}}, "text": "Regression is the hammer wereachforwhen wewantto answer howmuch? orhowmany?\nquestions. Ifyouwanttopredictthenumberofdollars(price)atwhichahousewillbesold,\nor the number of wins a baseball team might have, or the number of days that a patient will\nremainhospitalizedbeforebeingdischarged,thenyouareprobablylookingforaregression\nmodel. However, even within regression models, there are important distinctions. For\ninstance, the price of a house will never be negative and changes might often be relative\nto its baseline price. As such, it might be more effective to regress on the logarithm of the\nprice. Likewise, the number of days a patient spends in hospital is a discrete nonnegative\nrandom variable. As such, least mean squares might not be an ideal approach either. This\nsortoftime-to-eventmodelingcomeswithahostofothercomplicationsthataredealtwith\nin a specialized subfield called survivalmodeling .\nThe point here is not to overwhelm you but just to let you know that there is a lot more\nto estimation than simply minimizing squared errors. And more broadly, there is a lot\nmore to supervised learning than regression. In this section, we focus on classification\nproblems where we put aside how much? questions and instead focus on which category?\nquestions.\n\u000fDoes this email belong in the spam folder or the inbox?\n\u000fIs this customer more likely to sign up or not to sign up for a subscription service?\n125\n126 Linear Neural Networks for Classi\ufb01cation\n86\n87\u000fDoes this image depict a donkey, a dog, a cat, or a rooster?\n\u000fWhich movie is Aston most likely to watch next?\n\u000fWhich section of the book are you going to read next?\nColloquially, machine learning practitioners overload the word classification to describe\ntwo subtly different problems: (i) those where we are interested only in hard assignments\nofexamplestocategories(classes); and(ii)thosewherewewishtomakesoftassignments,\ni.e.,toassesstheprobabilitythateachcategoryapplies. Thedistinctiontendstogetblurred,\ninpart, becauseoften, evenwhenweonlycareabouthardassignments, westillusemodels\nthat make soft assignments.\nEven more, there are cases where more than one label might be true. For instance, a news\narticle might simultaneously cover the topics of entertainment, business, and space flight,\nbut not the topics of medicine or sports. Thus, categorizing it into one of the above cate-\ngories on their own would not be very useful. This problem is commonly known as multi-\nlabel classification86. See Tsoumakas and Katakis ( 2007) for an overview and Huang et\nal.(2015) for an effective algorithm when tagging images.\n4.1.1Classification\nTo get our feet wet, let\u2019s start with a simple image classification problem. Here, each input\nconsists of a 2\u00022grayscale image. We can represent each pixel value with a single scalar,\ngiving us four features \ud835\udc651,\ud835\udc652,\ud835\udc653,\ud835\udc654. Further, let\u2019s assume that each image belongs to one\namong the categories \u201ccat\u201d, \u201cchicken\u201d, and \u201cdog\u201d.\nNext, we have to choose how to represent the labels. We have two obvious choices. Per-\nhapsthemostnaturalimpulsewouldbetochoose \ud835\udc662f1,2,3g,wheretheintegersrepresent\nfdog,cat,chickengrespectively. This is a great way of storingsuch information on a com-\nputer. If the categories had some natural ordering among them, say if we were trying to\npredictfbaby,toddler,adolescent,young adult,adult,geriatricg, then it might even make\nsense to cast this as an ordinal regression87problem and keep the labels in this format.\nSee Moon et al.(2010) for an overview of different types of ranking loss functions and\nBeutelet al.(2014) for a Bayesian approach that addresses responses with more than one\nmode.\nIn general, classification problems do not come with natural orderings among the classes.\nFortunately, statisticians long ago invented a simple way to represent categorical data: the\none-hot encoding . A one-hot encoding is a vector with as many components as we have\ncategories. Thecomponentcorrespondingtoaparticularinstance\u2019scategoryissetto1and\nallothercomponentsaresetto0.", "mimetype": "text/plain", "start_char_idx": 340105, "end_char_idx": 344106, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7850297b-a989-4039-a16e-2225725936e6": {"__data__": {"id_": "7850297b-a989-4039-a16e-2225725936e6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2e61a564-ff85-4386-86a0-5c5f76482752", "node_type": "1", "metadata": {}, "hash": "26d26365daac065693451b26bfbe03b96dcaba3ed9f0fea09503032d28547c9b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9603abc4-b73c-47f7-97ab-ea8e6fe06ce2", "node_type": "1", "metadata": {}, "hash": "728d6c1ee8612e1be58945a2131991bfd256749e11535266782d1461620ea344", "class_name": "RelatedNodeInfo"}}, "text": "If the categories had some natural ordering among them, say if we were trying to\npredictfbaby,toddler,adolescent,young adult,adult,geriatricg, then it might even make\nsense to cast this as an ordinal regression87problem and keep the labels in this format.\nSee Moon et al.(2010) for an overview of different types of ranking loss functions and\nBeutelet al.(2014) for a Bayesian approach that addresses responses with more than one\nmode.\nIn general, classification problems do not come with natural orderings among the classes.\nFortunately, statisticians long ago invented a simple way to represent categorical data: the\none-hot encoding . A one-hot encoding is a vector with as many components as we have\ncategories. Thecomponentcorrespondingtoaparticularinstance\u2019scategoryissetto1and\nallothercomponentsaresetto0. Inourcase,alabel \ud835\udc66wouldbeathree-dimensionalvector,\nwith\u00b91,0,0\u00bacorresponding to \u201ccat\u201d, \u00b90,1,0\u00bato \u201cchicken\u201d, and\u00b90,0,1\u00bato \u201cdog\u201d:\n\ud835\udc662f\u00b91,0,0\u00ba,\u00b90,1,0\u00ba,\u00b90,0,1\u00bag. (4.1.1)\n127 Softmax Regression\nLinearModel\nIn order to estimate the conditional probabilities associated with all the possible classes,\nwe need a model with multiple outputs, one per class. To address classification with lin-\near models, we will need as many affine functions as we have outputs. Strictly speaking,\nwe only need one fewer, since the final category has to be the difference between 1and\nthe sum of the other categories, but for reasons of symmetry we use a slightly redundant\nparametrization. Each output corresponds to its own affine function. In our case, since\nwe have 4 features and 3 possible output categories, we need 12 scalars to represent the\nweights (\ud835\udc64with subscripts), and 3 scalars to represent the biases ( \ud835\udc4fwith subscripts). This\nyields:\n\ud835\udc5c1=\ud835\udc651\ud835\udc6411\u00b8\ud835\udc652\ud835\udc6412\u00b8\ud835\udc653\ud835\udc6413\u00b8\ud835\udc654\ud835\udc6414\u00b8\ud835\udc4f1,\n\ud835\udc5c2=\ud835\udc651\ud835\udc6421\u00b8\ud835\udc652\ud835\udc6422\u00b8\ud835\udc653\ud835\udc6423\u00b8\ud835\udc654\ud835\udc6424\u00b8\ud835\udc4f2,\n\ud835\udc5c3=\ud835\udc651\ud835\udc6431\u00b8\ud835\udc652\ud835\udc6432\u00b8\ud835\udc653\ud835\udc6433\u00b8\ud835\udc654\ud835\udc6434\u00b8\ud835\udc4f3.(4.1.2)\nThe corresponding neural network diagram is shown in Fig. 4.1.1 . Just as in linear regres-\nsion,weuseasingle-layerneuralnetwork. Andsincethecalculationofeachoutput, \ud835\udc5c1,\ud835\udc5c2,\nand\ud835\udc5c3, depends on every input, \ud835\udc651,\ud835\udc652,\ud835\udc653, and\ud835\udc654, the output layer can also be described as\nafullyconnectedlayer .\ntFig. 4.1.1 Softmax regression is a single-layer neural network.\nForamoreconcisenotationweusevectorsandmatrices: o=Wx\u00b8bismuchbettersuited\nformathematicsandcode. Notethatwehavegatheredallofourweightsintoa 3\u00024matrix\nand all biases b2R3in a vector.\nTheSoftmax\nAssuming a suitable loss function, we could try, directly, to minimize the difference be-\ntweenoand the labels y. While it turns out that treating classification as a vector-valued\nregressionproblemworkssurprisinglywell,itisnonethelessunsatisfactoryinthefollowing\nways:\n\u000fThere is no guarantee that the outputs \ud835\udc5c\ud835\udc56sum up to 1in the way we expect probabilities\nto behave.\n\u000fThere is no guarantee that the outputs \ud835\udc5c\ud835\udc56are even nonnegative, even if their outputs sum\nup to 1, or that they do not exceed 1.\nBoth aspects render the estimation problem difficult to solve and the solution very brittle\nto outliers. For instance, if we assume that there is a positive linear dependency between\nthe number of bedrooms and the likelihood that someone will buy a house, the probability\n128 Linear Neural Networks for Classi\ufb01cation\n88might exceed 1when it comes to buying a mansion! As such, we need a mechanism to\n\u201csquish\u201d the outputs.", "mimetype": "text/plain", "start_char_idx": 343294, "end_char_idx": 346593, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9603abc4-b73c-47f7-97ab-ea8e6fe06ce2": {"__data__": {"id_": "9603abc4-b73c-47f7-97ab-ea8e6fe06ce2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7850297b-a989-4039-a16e-2225725936e6", "node_type": "1", "metadata": {}, "hash": "52e1cc9bb32f4a78e0a637207cb8b1fbcf7b5bd30039240607eda6013b4633a5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f9bbc849-6673-4f2a-877d-64eb24231f9c", "node_type": "1", "metadata": {}, "hash": "b4d420ce1b0770237c3724dbd6c9c2e7d718bd043aab34dbe17489422209fb03", "class_name": "RelatedNodeInfo"}}, "text": "\u000fThere is no guarantee that the outputs \ud835\udc5c\ud835\udc56are even nonnegative, even if their outputs sum\nup to 1, or that they do not exceed 1.\nBoth aspects render the estimation problem difficult to solve and the solution very brittle\nto outliers. For instance, if we assume that there is a positive linear dependency between\nthe number of bedrooms and the likelihood that someone will buy a house, the probability\n128 Linear Neural Networks for Classi\ufb01cation\n88might exceed 1when it comes to buying a mansion! As such, we need a mechanism to\n\u201csquish\u201d the outputs.\nThere are many ways we might accomplish this goal. For instance, we could assume that\nthe outputs oare corrupted versions of y, where the corruption occurs by means of adding\nnoise \ud835\udf50drawnfrom a normal distribution. In other words, y=o\u00b8\ud835\udf50, where\ud835\udf16\ud835\udc56\u0018N\u00b9 0,\ud835\udf0e2\u00ba.\nThis is the so-called probit model88, first introduced by Fechner ( 1860). While appealing,\nit does not work quite as well nor lead to a particularly nice optimization problem, when\ncompared to the softmax.\nAnother way to accomplish this goal (and to ensure nonnegativity) is to use an exponential\nfunction\ud835\udc43\u00b9\ud835\udc66=\ud835\udc56\u00ba/exp\ud835\udc5c\ud835\udc56. This does indeed satisfy the requirement that the conditional\nclass probability increases with increasing \ud835\udc5c\ud835\udc56, it is monotonic, and all probabilities are\nnonnegative. We can then transform these values so that they add up to 1by dividing each\nby their sum. This process is called normalization . Putting these two pieces together gives\nus thesoftmax function:\n\u02c6y=softmax\u00b9o\u00bawhere \u02c6\ud835\udc66\ud835\udc56=exp\u00b9\ud835\udc5c\ud835\udc56\u00ba\u00cd\n\ud835\udc57exp\u00b9\ud835\udc5c\ud835\udc57\u00ba. (4.1.3)\nNote that the largest coordinate of ocorresponds to the most likely class according to \u02c6y.\nMoreover, because the softmax operation preserves the ordering among its arguments, we\ndonotneedtocomputethesoftmaxtodeterminewhichclasshasbeenassignedthehighest\nprobability. Thus,\nargmax\n\ud835\udc57\u02c6\ud835\udc66\ud835\udc57=argmax\n\ud835\udc57\ud835\udc5c\ud835\udc57.(4.1.4)\nTheideaofa softmaxdatesbacktoGibbs( 1902), whoadaptedideasfrom physics. Dating\neven further back, Boltzmann, the father of modern statistical physics, used this trick to\nmodel a distribution over energy states in gas molecules. In particular, he discovered that\ntheprevalenceofastateofenergyinathermodynamicensemble,suchasthemoleculesina\ngas, is proportional to exp\u00b9\u0000\ud835\udc38\u009d\ud835\udc58\ud835\udc47\u00ba. Here,\ud835\udc38is the energy of a state, \ud835\udc47is the temperature,\nand\ud835\udc58is the Boltzmann constant. When statisticians talk about increasing or decreasing\nthe \u201ctemperature\u201d of a statistical system, they refer to changing \ud835\udc47in order to favor lower\nor higher energy states. Following Gibbs\u2019 idea, energy equates to error. Energy-based\nmodels ( Ranzatoet al., 2007) use this point of view when describing problems in deep\nlearning.\nVectorization\nToimprovecomputationalefficiency,wevectorizecalculationsinminibatchesofdata. As-\nsume that we are given a minibatch X2R\ud835\udc5b\u0002\ud835\udc51of\ud835\udc5bexamples with dimensionality (number\nof inputs)\ud835\udc51. Moreover, assume that we have \ud835\udc5ecategories in the output. Then the weights\nsatisfy W2R\ud835\udc51\u0002\ud835\udc5eand the bias satisfies b2R1\u0002\ud835\udc5e.\nO=XW\u00b8b,\n\u02c6Y=softmax\u00b9O\u00ba.(4.1.5)\n129 Softmax Regression\nThis accelerates the dominant operation into a matrix\u2013matrix product XW. Moreover,\nsinceeachrowin Xrepresentsadataexample,thesoftmaxoperationitselfcanbecomputed\nrowwise: for each row of O, exponentiate all entries and then normalize them by the sum.\nNote,though,thatcaremustbetakentoavoidexponentiatingandtakinglogarithmsoflarge\nnumbers,sincethiscancausenumericaloverfloworunderflow. Deeplearningframeworks\ntake care of this automatically.", "mimetype": "text/plain", "start_char_idx": 346043, "end_char_idx": 349468, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f9bbc849-6673-4f2a-877d-64eb24231f9c": {"__data__": {"id_": "f9bbc849-6673-4f2a-877d-64eb24231f9c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9603abc4-b73c-47f7-97ab-ea8e6fe06ce2", "node_type": "1", "metadata": {}, "hash": "728d6c1ee8612e1be58945a2131991bfd256749e11535266782d1461620ea344", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0a750766-c41a-482f-bf7f-7c0474edae91", "node_type": "1", "metadata": {}, "hash": "dd4a9186a5b3f3e873053dc6877ded926511f702aeebf6464a327c3329bbf593", "class_name": "RelatedNodeInfo"}}, "text": "Then the weights\nsatisfy W2R\ud835\udc51\u0002\ud835\udc5eand the bias satisfies b2R1\u0002\ud835\udc5e.\nO=XW\u00b8b,\n\u02c6Y=softmax\u00b9O\u00ba.(4.1.5)\n129 Softmax Regression\nThis accelerates the dominant operation into a matrix\u2013matrix product XW. Moreover,\nsinceeachrowin Xrepresentsadataexample,thesoftmaxoperationitselfcanbecomputed\nrowwise: for each row of O, exponentiate all entries and then normalize them by the sum.\nNote,though,thatcaremustbetakentoavoidexponentiatingandtakinglogarithmsoflarge\nnumbers,sincethiscancausenumericaloverfloworunderflow. Deeplearningframeworks\ntake care of this automatically.\n4.1.2LossFunction\nNow that we have a mapping from features xto probabilities \u02c6 y, we need a way to optimize\nthe accuracy of this mapping. We will rely on maximum likelihood estimation, the very\nsamemethodthatweencounteredwhenprovidingaprobabilisticjustificationforthemean\nsquared error loss in Section 3.1.3 .\nLog-Likelihood\nThe softmax function gives us a vector \u02c6y, which we can interpret as the (estimated) con-\nditional probabilities of each class, given any input x, such as \u02c6\ud835\udc661=\ud835\udc43\u00b9\ud835\udc66=catjx\u00ba. In the\nfollowing we assume that for a dataset with features Xthe labels Yare represented using\na one-hot encoding label vector. We can compare the estimates with reality by checking\nhow probable the actual classes are according to our model, given the features:\n\ud835\udc43\u00b9YjX\u00ba=\ud835\udc5b\u00d6\n\ud835\udc56=1\ud835\udc43\u00b9y\u00b9\ud835\udc56\u00bajx\u00b9\ud835\udc56\u00ba\u00ba. (4.1.6)\nWe are allowed to use the factorization since we assume that each label is drawn indepen-\ndently from its respective distribution \ud835\udc43\u00b9yjx\u00b9\ud835\udc56\u00ba\u00ba. Since maximizing the product of terms\nisawkward,wetakethenegativelogarithmtoobtaintheequivalentproblemofminimizing\nthe negative log-likelihood:\n\u0000log\ud835\udc43\u00b9YjX\u00ba=\ud835\udc5b\u00d5\n\ud835\udc56=1\u0000log\ud835\udc43\u00b9y\u00b9\ud835\udc56\u00bajx\u00b9\ud835\udc56\u00ba\u00ba=\ud835\udc5b\u00d5\n\ud835\udc56=1\ud835\udc59\u00b9y\u00b9\ud835\udc56\u00ba,\u02c6y\u00b9\ud835\udc56\u00ba\u00ba, (4.1.7)\nwhere for any pair of label yand model prediction \u02c6yover\ud835\udc5eclasses, the loss function \ud835\udc59\nis\n\ud835\udc59\u00b9y,\u02c6y\u00ba=\u0000\ud835\udc5e\u00d5\n\ud835\udc57=1\ud835\udc66\ud835\udc57log \u02c6\ud835\udc66\ud835\udc57. (4.1.8)\nFor reasons explained later on, the loss function in (4.1.8 )is commonly called the cross-\nentropyloss . Since yisaone-hotvectoroflength \ud835\udc5e, thesumoverallitscoordinates \ud835\udc57van-\nishesforallbutoneterm. Notethattheloss \ud835\udc59\u00b9y,\u02c6y\u00baisboundedfrombelowby 0whenever \u02c6y\nis a probability vector: no single entry is larger than 1, hence their negative logarithm can-\nnot be lower than 0;\ud835\udc59\u00b9y,\u02c6y\u00ba=0only if we predict the actual label with certainty . This can\nnever happen for any finite setting of the weights because taking a softmax output towards\n1requires taking the corresponding input \ud835\udc5c\ud835\udc56to infinity (or all other outputs \ud835\udc5c\ud835\udc57for\ud835\udc57\u2260\ud835\udc56\nto negative infinity). Even if our model could assign an output probability of 0, any error\nmade when assigning such high confidence would incur infinite loss ( \u0000log 0=1).\n130 Linear Neural Networks for Classi\ufb01cation\nSoftmax and Cross-EntropyLoss\nSince the softmax function and the corresponding cross-entropy loss are so common, it is\nworth understanding a bit better how they are computed.", "mimetype": "text/plain", "start_char_idx": 348914, "end_char_idx": 351741, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0a750766-c41a-482f-bf7f-7c0474edae91": {"__data__": {"id_": "0a750766-c41a-482f-bf7f-7c0474edae91", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f9bbc849-6673-4f2a-877d-64eb24231f9c", "node_type": "1", "metadata": {}, "hash": "b4d420ce1b0770237c3724dbd6c9c2e7d718bd043aab34dbe17489422209fb03", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "652d991d-170b-4da8-a6c9-8038457422e8", "node_type": "1", "metadata": {}, "hash": "8df4e42ead4862000a595ae282fd306d2e2fdad8d666a99ce0dc1c291e7327db", "class_name": "RelatedNodeInfo"}}, "text": "This can\nnever happen for any finite setting of the weights because taking a softmax output towards\n1requires taking the corresponding input \ud835\udc5c\ud835\udc56to infinity (or all other outputs \ud835\udc5c\ud835\udc57for\ud835\udc57\u2260\ud835\udc56\nto negative infinity). Even if our model could assign an output probability of 0, any error\nmade when assigning such high confidence would incur infinite loss ( \u0000log 0=1).\n130 Linear Neural Networks for Classi\ufb01cation\nSoftmax and Cross-EntropyLoss\nSince the softmax function and the corresponding cross-entropy loss are so common, it is\nworth understanding a bit better how they are computed. Plugging (4.1.3 )into the defini-\ntion of the loss in (4.1.8 )and using the definition of the softmax we obtain\n\ud835\udc59\u00b9y,\u02c6y\u00ba=\u0000\ud835\udc5e\u00d5\n\ud835\udc57=1\ud835\udc66\ud835\udc57logexp\u00b9\ud835\udc5c\ud835\udc57\u00ba\n\u00cd\ud835\udc5e\n\ud835\udc58=1exp\u00b9\ud835\udc5c\ud835\udc58\u00ba\n=\ud835\udc5e\u00d5\n\ud835\udc57=1\ud835\udc66\ud835\udc57log\ud835\udc5e\u00d5\n\ud835\udc58=1exp\u00b9\ud835\udc5c\ud835\udc58\u00ba\u0000\ud835\udc5e\u00d5\n\ud835\udc57=1\ud835\udc66\ud835\udc57\ud835\udc5c\ud835\udc57\n=log\ud835\udc5e\u00d5\n\ud835\udc58=1exp\u00b9\ud835\udc5c\ud835\udc58\u00ba\u0000\ud835\udc5e\u00d5\n\ud835\udc57=1\ud835\udc66\ud835\udc57\ud835\udc5c\ud835\udc57.(4.1.9)\nTounderstandabitbetterwhatisgoingon,considerthederivativewithrespecttoanylogit\n\ud835\udc5c\ud835\udc57. We get\n\ud835\udf15\ud835\udc5c\ud835\udc57\ud835\udc59\u00b9y,\u02c6y\u00ba=exp\u00b9\ud835\udc5c\ud835\udc57\u00ba\n\u00cd\ud835\udc5e\n\ud835\udc58=1exp\u00b9\ud835\udc5c\ud835\udc58\u00ba\u0000\ud835\udc66\ud835\udc57=softmax\u00b9o\u00ba\ud835\udc57\u0000\ud835\udc66\ud835\udc57. (4.1.10)\nIn other words, the derivative is the difference between the probability assigned by our\nmodel, as expressed by the softmax operation, and what actually happened, as expressed\nby elements in the one-hot label vector. In this sense, it is very similar to what we saw in\nregression, where the gradient was the difference between the observation \ud835\udc66and estimate\n\u02c6\ud835\udc66. This is not a coincidence. In any exponential family model, the gradients of the log-\nlikelihood are given by precisely this term. This fact makes computing gradients easy in\npractice.\nNowconsiderthecasewhereweobservenotjustasingleoutcomebutanentiredistribution\nover outcomes. We can use the same representation as before for the label y. The only dif-\nferenceisthatratherthanavectorcontainingonlybinaryentries,say \u00b90,0,1\u00ba,wenowhave\nagenericprobabilityvector, say \u00b90.1,0.2,0.7\u00ba. Themaththatweusedpreviouslytodefine\nthe loss\ud835\udc59in(4.1.8 )still works well, just that the interpretation is slightly more general. It\nis the expected value of the loss for a distribution over labels. This loss is called the cross-\nentropyloss anditisoneofthemostcommonlyusedlossesforclassificationproblems. We\ncan demystify the name by introducing just the basics of information theory. In a nutshell,\nitmeasuresthenumberofbitsneededtoencodewhatwesee, y,relativetowhatwepredict\nthat should happen, \u02c6y. We provide a very basic explanation in the following. For further\ndetails on information theory see Cover and Thomas ( 1999) or MacKay ( 2003).\n4.1.3InformationTheory Basics\nManydeeplearningpapersuseintuitionandtermsfrominformationtheory. Tomakesense\nof them, we need some common language. This is a survival guide. Information theory\ndeals with the problem of encoding, decoding, transmitting, and manipulating information\n(also known as data).\n131 Softmax Regression\nEntropy\nThe central idea in information theory is to quantify the amount of information contained\nindata. Thisplacesalimitonourabilitytocompressdata. Foradistribution \ud835\udc43itsentropy,\n\ud835\udc3b\u00bb\ud835\udc43\u00bc, is defined as:\n\ud835\udc3b\u00bb\ud835\udc43\u00bc=\u00d5\n\ud835\udc57\u0000\ud835\udc43\u00b9\ud835\udc57\u00balog\ud835\udc43\u00b9\ud835\udc57\u00ba.", "mimetype": "text/plain", "start_char_idx": 351164, "end_char_idx": 354151, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "652d991d-170b-4da8-a6c9-8038457422e8": {"__data__": {"id_": "652d991d-170b-4da8-a6c9-8038457422e8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0a750766-c41a-482f-bf7f-7c0474edae91", "node_type": "1", "metadata": {}, "hash": "dd4a9186a5b3f3e873053dc6877ded926511f702aeebf6464a327c3329bbf593", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "10254a26-55c2-499f-a709-ec450303e992", "node_type": "1", "metadata": {}, "hash": "46a5fdbfb3d0092080ef167e428e33364c644b00f0fb8906a0e1638647512386", "class_name": "RelatedNodeInfo"}}, "text": "We provide a very basic explanation in the following. For further\ndetails on information theory see Cover and Thomas ( 1999) or MacKay ( 2003).\n4.1.3InformationTheory Basics\nManydeeplearningpapersuseintuitionandtermsfrominformationtheory. Tomakesense\nof them, we need some common language. This is a survival guide. Information theory\ndeals with the problem of encoding, decoding, transmitting, and manipulating information\n(also known as data).\n131 Softmax Regression\nEntropy\nThe central idea in information theory is to quantify the amount of information contained\nindata. Thisplacesalimitonourabilitytocompressdata. Foradistribution \ud835\udc43itsentropy,\n\ud835\udc3b\u00bb\ud835\udc43\u00bc, is defined as:\n\ud835\udc3b\u00bb\ud835\udc43\u00bc=\u00d5\n\ud835\udc57\u0000\ud835\udc43\u00b9\ud835\udc57\u00balog\ud835\udc43\u00b9\ud835\udc57\u00ba.(4.1.11)\nOne of the fundamental theorems of information theory states that in order to encode data\ndrawn randomly from the distribution \ud835\udc43, we need at least \ud835\udc3b\u00bb\ud835\udc43\u00bc\u201cnats\u201d to encode it ( Shan-\nnon, 1948 ). If you wonder what a \u201cnat\u201d is, it is the equivalent of bit but when using a code\nwith base\ud835\udc52rather than one with base 2. Thus, one nat is1\nlog\u00b92\u00ba\u00191.44bit.\nSurprisal\nYoumightbewonderingwhatcompressionhastodowithprediction. Imaginethatwehave\na stream of data that we want to compress. If it is always easy for us to predict the next\ntoken, then this data is easy to compress. Take the extreme example where every token in\nthe stream always takes the same value. That is a very boring data stream! And not only\nit is boring, but it is also easy to predict. Because the tokens are always the same, we do\nnot have to transmit any information to communicate the contents of the stream. Easy to\npredict, easy to compress.\nHoweverifwecannotperfectlypredicteveryevent,thenwemightsometimesbesurprised.\nOursurpriseisgreaterwhenaneventisassignedlowerprobability. ClaudeShannonsettled\nonlog1\n\ud835\udc43\u00b9\ud835\udc57\u00ba=\u0000log\ud835\udc43\u00b9\ud835\udc57\u00batoquantifyone\u2019s surprisal atobservinganevent \ud835\udc57havingassigned\nit a (subjective) probability \ud835\udc43\u00b9\ud835\udc57\u00ba. The entropy defined in (4.1.11 )is then the expected\nsurprisal when one assigned the correct probabilities that truly match the data-generating\nprocess.\nCross-EntropyRevisited\nSo if entropy is the level of surprise experienced by someone who knows the true proba-\nbility, then you might be wondering, what is cross-entropy? The cross-entropy from\ud835\udc43to\n\ud835\udc44, denoted\ud835\udc3b\u00b9\ud835\udc43,\ud835\udc44\u00ba, is the expected surprisal of an observer with subjective probabilities\n\ud835\udc44upon seeing data that was actually generated according to probabilities \ud835\udc43. This is given\nby\ud835\udc3b\u00b9\ud835\udc43,\ud835\udc44\u00badef=\u00cd\n\ud835\udc57\u0000\ud835\udc43\u00b9\ud835\udc57\u00balog\ud835\udc44\u00b9\ud835\udc57\u00ba. The lowest possible cross-entropy is achieved when\n\ud835\udc43=\ud835\udc44. In this case, the cross-entropy from \ud835\udc43to\ud835\udc44is\ud835\udc3b\u00b9\ud835\udc43,\ud835\udc43\u00ba=\ud835\udc3b\u00b9\ud835\udc43\u00ba.\nIn short, we can think of the cross-entropy classification objective in two ways: (i) as max-\nimizing the likelihood of the observed data; and (ii) as minimizing our surprisal (and thus\nthe number of bits) required to communicate the labels.\n4.1.4Summaryand Discussion\nInthissection,weencounteredthefirstnontriviallossfunction,allowingustooptimizeover\ndiscreteoutputspaces. Keyinitsdesignwasthatwetookaprobabilisticapproach,treating\n132 Linear Neural Networks for Classi\ufb01cation\n89\n90discrete categories as instances of draws from a probability distribution. As a side effect,\nwe encountered the softmax, a convenient activation function that transforms outputs of an\nordinary neural network layer into valid discrete probability distributions. We saw that the\nderivative of the cross-entropy loss when combined with softmax behaves very similarly\nto the derivative of squared error; namely by taking the difference between the expected\nbehavior and its prediction.", "mimetype": "text/plain", "start_char_idx": 353460, "end_char_idx": 356974, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "10254a26-55c2-499f-a709-ec450303e992": {"__data__": {"id_": "10254a26-55c2-499f-a709-ec450303e992", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "652d991d-170b-4da8-a6c9-8038457422e8", "node_type": "1", "metadata": {}, "hash": "8df4e42ead4862000a595ae282fd306d2e2fdad8d666a99ce0dc1c291e7327db", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6d7dfe58-0728-43ba-a282-ed63a7e36735", "node_type": "1", "metadata": {}, "hash": "78f30334644b4c7a7ce18e8c5a3bd8fdef7ac9345da0fb7c2db64ac365d2725c", "class_name": "RelatedNodeInfo"}}, "text": "4.1.4Summaryand Discussion\nInthissection,weencounteredthefirstnontriviallossfunction,allowingustooptimizeover\ndiscreteoutputspaces. Keyinitsdesignwasthatwetookaprobabilisticapproach,treating\n132 Linear Neural Networks for Classi\ufb01cation\n89\n90discrete categories as instances of draws from a probability distribution. As a side effect,\nwe encountered the softmax, a convenient activation function that transforms outputs of an\nordinary neural network layer into valid discrete probability distributions. We saw that the\nderivative of the cross-entropy loss when combined with softmax behaves very similarly\nto the derivative of squared error; namely by taking the difference between the expected\nbehavior and its prediction. And, while we were only able to scratch the very surface of it,\nwe encountered exciting connections to statistical physics and information theory.\nWhile this is enough to get you on your way, and hopefully enough to whet your appetite,\nwe hardly dived deep here. Among other things, we skipped over computational con-\nsiderations. Specifically, for any fully connected layer with \ud835\udc51inputs and\ud835\udc5eoutputs, the\nparametrization and computational cost is O\u00b9\ud835\udc51\ud835\udc5e\u00ba, which can be prohibitively high in prac-\ntice. Fortunately, this cost of transforming \ud835\udc51inputs into\ud835\udc5eoutputs can be reduced through\napproximation and compression. For instance Deep Fried Convnets ( Yanget al., 2015)\nuses a combination of permutations, Fourier transforms, and scaling to reduce the cost\nfrom quadratic to log-linear. Similar techniques work for more advanced structural matrix\napproximations ( Sindhwani et al., 2015). Lastly, we can use quaternion-like decomposi-\ntions to reduce the cost to O\u00b9\ud835\udc51\ud835\udc5e\n\ud835\udc5b\u00ba, again if we are willing to trade off a small amount of\naccuracy for computational and storage cost ( Zhanget al., 2021) based on a compression\nfactor\ud835\udc5b. This is an active area of research. What makes it challenging is that we do not\nnecessarily strive for the most compact representation or the smallest number of floating\npoint operations but rather for the solution that can be executed most efficiently on modern\nGPUs.\n4.1.5Exercises\n1.Wecanexploretheconnectionbetweenexponentialfamiliesandsoftmaxinsomemore\ndepth.\n1.Compute the second derivative of the cross-entropy loss \ud835\udc59\u00b9y,\u02c6y\u00bafor softmax.\n2.Computethevarianceofthedistributiongivenby softmax\u00b9o\u00baandshowthatitmatches\nthe second derivative computed above.\n2.Assume that we have three classes which occur with equal probability, i.e., the proba-\nbility vector is\u00b91\n3,1\n3,1\n3\u00ba.\n1.What is the problem if we try to design a binary code for it?\n2.Can you design a better code? Hint: what happens if we try to encode two indepen-\ndent observations? What if we encode \ud835\udc5bobservations jointly?\n3.When encoding signals transmitted over a physical wire, engineers do not always use\nbinary codes. For instance, PAM-389uses three signal levels f\u00001,0,1gas opposed to\ntwo levelsf0,1g. How many ternary units do you need to transmit an integer in the\nrangef0,..., 7g? Why might this be a better idea in terms of electronics?\n4.TheBradley\u2013Terry model90uses a logistic model to capture preferences. For a user to\n133 Softmax Regression\n91\n92choose between apples and oranges one assumes scores \ud835\udc5cappleand\ud835\udc5corange. Our require-\nmentsarethatlargerscoresshouldleadtoahigherlikelihoodinchoosingtheassociated\nitemandthattheitemwiththelargestscoreisthemostlikelyonetobechosen( Bradley\nand Terry, 1952 ).\n1.Prove that softmax satisfies this requirement.\n2.What happens if you want to allow for a default option of choosing neither apples\nnor oranges? Hint: now the user has three choices.\n5.Softmaxgetsitsnamefromthefollowingmapping: RealSoftMax \u00b9\ud835\udc4e,\ud835\udc4f\u00ba=log\u00b9exp\u00b9\ud835\udc4e\u00ba\u00b8\nexp\u00b9\ud835\udc4f\u00ba\u00ba.\n1.Prove that RealSoftMax \u00b9\ud835\udc4e,\ud835\udc4f\u00ba>max\u00b9\ud835\udc4e,\ud835\udc4f\u00ba.\n2.How small can you make the difference between both functions? Hint: without loss\nof generality you can set \ud835\udc4f=0and\ud835\udc4e\u0015\ud835\udc4f.", "mimetype": "text/plain", "start_char_idx": 356252, "end_char_idx": 360103, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6d7dfe58-0728-43ba-a282-ed63a7e36735": {"__data__": {"id_": "6d7dfe58-0728-43ba-a282-ed63a7e36735", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "10254a26-55c2-499f-a709-ec450303e992", "node_type": "1", "metadata": {}, "hash": "46a5fdbfb3d0092080ef167e428e33364c644b00f0fb8906a0e1638647512386", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "030d18ef-2e41-4113-abf5-5e4a1f3eb6ea", "node_type": "1", "metadata": {}, "hash": "44923356bc7d396d343bc836641c2bd603379aca6a1388ebb09ee17a229958cd", "class_name": "RelatedNodeInfo"}}, "text": "1.Prove that softmax satisfies this requirement.\n2.What happens if you want to allow for a default option of choosing neither apples\nnor oranges? Hint: now the user has three choices.\n5.Softmaxgetsitsnamefromthefollowingmapping: RealSoftMax \u00b9\ud835\udc4e,\ud835\udc4f\u00ba=log\u00b9exp\u00b9\ud835\udc4e\u00ba\u00b8\nexp\u00b9\ud835\udc4f\u00ba\u00ba.\n1.Prove that RealSoftMax \u00b9\ud835\udc4e,\ud835\udc4f\u00ba>max\u00b9\ud835\udc4e,\ud835\udc4f\u00ba.\n2.How small can you make the difference between both functions? Hint: without loss\nof generality you can set \ud835\udc4f=0and\ud835\udc4e\u0015\ud835\udc4f.\n3.Prove that this holds for \ud835\udf06\u00001RealSoftMax\u00b9\ud835\udf06\ud835\udc4e,\ud835\udf06\ud835\udc4f\u00ba, provided that \ud835\udf06> 0.\n4.Show that for \ud835\udf06!1we have\ud835\udf06\u00001RealSoftMax\u00b9\ud835\udf06\ud835\udc4e,\ud835\udf06\ud835\udc4f\u00ba! max\u00b9\ud835\udc4e,\ud835\udc4f\u00ba.\n5.Construct an analogous softmin function.\n6.Extend this to more than two numbers.\n6.The function \ud835\udc54\u00b9x\u00badef=log\u00cd\n\ud835\udc56exp\ud835\udc65\ud835\udc56is sometimes also referred to as the log-partition\nfunction91.\n1.Prove that the function is convex. Hint: to do so, use the fact that the first derivative\namounts to the probabilities from the softmax function and show that the second\nderivative is the variance.\n2.Show that\ud835\udc54is translation invariant, i.e., \ud835\udc54\u00b9x\u00b8\ud835\udc4f\u00ba=\ud835\udc54\u00b9x\u00ba.\n3.What happens if some of the coordinates \ud835\udc65\ud835\udc56are very large? What happens if they\u2019re\nall very small?\n4.Show that if we choose \ud835\udc4f=max\ud835\udc56\ud835\udc65\ud835\udc56we end up with a numerically stable implemen-\ntation.\n7.Assume that we have some probability distribution \ud835\udc43. Suppose we pick another distri-\nbution\ud835\udc44with\ud835\udc44\u00b9\ud835\udc56\u00ba/\ud835\udc43\u00b9\ud835\udc56\u00ba\ud835\udefcfor\ud835\udefc> 0.\n1.Which choice of \ud835\udefccorresponds to doubling the temperature? Which choice corre-\nsponds to halving it?\n2.What happens if we let the temperature approach 0?\n3.What happens if we let the temperature approach 1?\nDiscussions92.\n134 Linear Neural Networks for Classi\ufb01cation\n934.2The ImageClassification Dataset\nOne widely used dataset for image classification is the MNIST dataset93(LeCunet al.,\n1998) of handwritten digits. At the time of its release in the 1990s it posed a formidable\nchallenge to most machine learning algorithms, consisting of 60,000 images of 28\u000228\npixelsresolution(plusatestdatasetof10,000images). Toputthingsintoperspective,back\nin1995,aSunSPARCStation5withawhopping64MBofRAMandablistering5MFLOPs\nwasconsideredstateoftheartequipmentformachinelearningatAT&TBellLaboratories.\nAchieving high accuracy on digit recognition was a key component in automating letter\nsorting for the USPS in the 1990s. Deep networks such as LeNet-5 ( LeCunet al., 1995),\nsupport vector machines with invariances ( Sch\u00f6lkopf et al., 1996), and tangent distance\nclassifiers ( Simardetal., 1998) all could reach error rates below 1%.\nFor over a decade, MNIST served as thepoint of reference for comparing machine learn-\ning algorithms. While it had a good run as a benchmark dataset, even simple models by\ntoday\u2019sstandardsachieveclassificationaccuracyover95%, makingitunsuitablefordistin-\nguishing between strong models and weaker ones. Even more, the dataset allows for very\nhigh levels of accuracy, not typically seen in many classification problems. This skewed\nalgorithmic development towards specific families of algorithms that can take advantage\nof clean datasets, such as active set methods and boundary-seeking active set algorithms.\nToday, MNIST serves as more of a sanity check than as a benchmark. ImageNet ( Denget\nal., 2009) poses a much more relevant challenge. Unfortunately, ImageNet is too large for\nmany of the examples and illustrations in this book, as it would take too long to train to\nmake the examples interactive.", "mimetype": "text/plain", "start_char_idx": 359675, "end_char_idx": 363005, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "030d18ef-2e41-4113-abf5-5e4a1f3eb6ea": {"__data__": {"id_": "030d18ef-2e41-4113-abf5-5e4a1f3eb6ea", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6d7dfe58-0728-43ba-a282-ed63a7e36735", "node_type": "1", "metadata": {}, "hash": "78f30334644b4c7a7ce18e8c5a3bd8fdef7ac9345da0fb7c2db64ac365d2725c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d3742376-9ef0-43c6-8fa8-126333c1d06a", "node_type": "1", "metadata": {}, "hash": "37f9a89c46baad80bcd6597696c25cb1c4a559fcd4e205c36745319a635871f0", "class_name": "RelatedNodeInfo"}}, "text": "For over a decade, MNIST served as thepoint of reference for comparing machine learn-\ning algorithms. While it had a good run as a benchmark dataset, even simple models by\ntoday\u2019sstandardsachieveclassificationaccuracyover95%, makingitunsuitablefordistin-\nguishing between strong models and weaker ones. Even more, the dataset allows for very\nhigh levels of accuracy, not typically seen in many classification problems. This skewed\nalgorithmic development towards specific families of algorithms that can take advantage\nof clean datasets, such as active set methods and boundary-seeking active set algorithms.\nToday, MNIST serves as more of a sanity check than as a benchmark. ImageNet ( Denget\nal., 2009) poses a much more relevant challenge. Unfortunately, ImageNet is too large for\nmany of the examples and illustrations in this book, as it would take too long to train to\nmake the examples interactive. As a substitute we will focus our discussion in the coming\nsectionsonthequalitativelysimilar,butmuchsmallerFashion-MNISTdataset( Xiaoetal.,\n2017)whichwasreleasedin2017. Itcontainsimagesof10categoriesofclothingat 28\u000228\npixels resolution.\n%matplotlib inline\nimport time\nimport torch\nimport torchvision\nfrom torchvision import transforms\nfrom d2l import torch asd2l\nd2l.use_svg_display()\n4.2.1Loadingthe Dataset\nSince the Fashion-MNIST dataset is so useful, all major frameworks provide preprocessed\nversions of it. We can download and read it into memory using built-in framework utili-\nties.\n135 The Image Classi\ufb01cation Dataset\nclass FashionMNIST (d2l .DataModule): #@save\n\"\"\"The Fashion-MNIST dataset.\"\"\"\ndef __init__ (self , batch_size =64, resize =(28,28)):\nsuper ().__init__ ()\nself .save_hyperparameters()\ntrans =transforms .Compose([transforms .Resize(resize),\ntransforms .ToTensor()])\nself .train =torchvision .datasets .FashionMNIST(\nroot =self .root, train =True , transform =trans, download =True )\nself .val =torchvision .datasets .FashionMNIST(\nroot =self .root, train =False , transform =trans, download =True )\nFashion-MNIST consists of images from 10 categories, each represented by 6000 images\nin the training dataset and by 1000 in the test dataset. A test dataset is used for evaluating\nmodelperformance(itmustnotbeusedfortraining). Consequentlythetrainingsetandthe\ntest set contain 60,000 and 10,000 images, respectively.\ndata =FashionMNIST(resize =(32,32))\nlen(data .train), len(data .val)\n(60000 ,10000 )\nTheimagesaregrayscaleandupscaledto 32\u000232pixelsinresolutionabove. Thisissimilar\nto the original MNIST dataset which consisted of (binary) black and white images. Note,\nthough, that most modern image data has three channels (red, green, blue) and that hyper-\nspectral images can have in excess of 100 channels (the HyMap sensor has 126 channels).\nBy convention we store an image as a \ud835\udc50\u0002\u210e\u0002\ud835\udc64tensor, where \ud835\udc50is the number of color\nchannels,\u210eis the height and \ud835\udc64is the width.\ndata .train[ 0][0].shape\ntorch .Size([ 1,32,32])\nThecategoriesofFashion-MNISThavehuman-understandablenames. Thefollowingcon-\nvenience method converts between numeric labels and their names.\n@d2l .add_to_class(FashionMNIST) #@save\ndef text_labels (self , indices):\n\"\"\"Return text labels.\"\"\"\nlabels =['t-shirt ','trouser ','pullover ','dress ','coat ',\n'sandal ','shirt ','sneaker ','bag','ankle boot ']\nreturn [labels[ int(i)] for iinindices]\n4.2.2Readinga Minibatch\nTomakeourlifeeasierwhenreadingfromthetrainingandtestsets,weusethebuilt-indata\niterator rather than creating one from scratch. Recall that at each iteration, a data iterator\n136 Linear Neural Networks for Classi\ufb01cation\nreads a minibatch of data with size batch_size . We also randomly shuffle the examples\nfor the training data iterator.\n@d2l .add_to_class(FashionMNIST) #@save\ndef get_dataloader (self , train):\ndata =self .train iftrain else self .val\nreturn torch .utils .data .DataLoader(data, self .batch_size, shuffle =train,\nnum_workers =self .num_workers)\nToseehowthisworks,let\u2019sloadaminibatchofimagesbyinvokingthe train_dataloader\nmethod.", "mimetype": "text/plain", "start_char_idx": 362100, "end_char_idx": 366111, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d3742376-9ef0-43c6-8fa8-126333c1d06a": {"__data__": {"id_": "d3742376-9ef0-43c6-8fa8-126333c1d06a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "030d18ef-2e41-4113-abf5-5e4a1f3eb6ea", "node_type": "1", "metadata": {}, "hash": "44923356bc7d396d343bc836641c2bd603379aca6a1388ebb09ee17a229958cd", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "83738921-b5f1-4c2b-8bcc-9a8562e31053", "node_type": "1", "metadata": {}, "hash": "27877725af25791be4757636de3cd0dce6f18cf23ec94158a004d9f1e01c476b", "class_name": "RelatedNodeInfo"}}, "text": "Recall that at each iteration, a data iterator\n136 Linear Neural Networks for Classi\ufb01cation\nreads a minibatch of data with size batch_size . We also randomly shuffle the examples\nfor the training data iterator.\n@d2l .add_to_class(FashionMNIST) #@save\ndef get_dataloader (self , train):\ndata =self .train iftrain else self .val\nreturn torch .utils .data .DataLoader(data, self .batch_size, shuffle =train,\nnum_workers =self .num_workers)\nToseehowthisworks,let\u2019sloadaminibatchofimagesbyinvokingthe train_dataloader\nmethod. It contains 64 images.\nX, y =next (iter (data .train_dataloader()))\nprint (X.shape, X .dtype, y .shape, y .dtype)\ntorch .Size([ 64,1,32,32]) torch .float32 torch .Size([ 64]) torch .int64\nLet\u2019slookatthetimeittakestoreadtheimages. Eventhoughitisabuilt-inloader,itisnot\nblazingly fast. Nonetheless, this is sufficient since processing images with a deep network\ntakes quite a bit longer. Hence it is good enough that training a network will not be I/O\nconstrained.\ntic =time .time()\nfor X, y indata .train_dataloader():\ncontinue\nf'{time .time() -tic:.2f}sec'\n'4.69 sec '\n4.2.3Visualization\nWe will often be using the Fashion-MNIST dataset. A convenience function show_images\ncan be used to visualize the images and the associated labels. Skipping implementation\ndetails, we just show the interface below: we only need to know how to invoke d2l.\nshow_images rather than how it works for such utility functions.\ndef show_images (imgs, num_rows, num_cols, titles =None , scale =1.5): #@save\n\"\"\"Plot a list of images.\"\"\"\nraise NotImplementedError\nLet\u2019sputittogooduse. Ingeneral,itisagoodideatovisualizeandinspectdatathatyouare\ntraining on. Humans are very good at spotting oddities and because of that, visualization\nserves as an additional safeguard against mistakes and errors in the design of experiments.\nHerearetheimagesandtheircorrespondinglabels(intext)forthefirstfewexamplesinthe\ntraining dataset.\n137 The Image Classi\ufb01cation Dataset\n94@d2l .add_to_class(FashionMNIST) #@save\ndef visualize (self , batch, nrows =1, ncols =8, labels =[]):\nX, y =batch\nifnot labels:\nlabels =self .text_labels(y)\nd2l.show_images(X .squeeze( 1), nrows, ncols, titles =labels)\nbatch =next (iter (data .val_dataloader()))\ndata .visualize(batch)\nWearenowreadytoworkwiththeFashion-MNISTdatasetinthesectionsthatfollow.\n4.2.4Summary\nWenowhaveaslightlymorerealisticdatasettouseforclassification. Fashion-MNISTisan\napparel classification dataset consisting of images representing 10 categories. We will use\nthis dataset in subsequent sections and chapters to evaluate various network designs, from\na simple linear model to advanced residual networks. As we commonly do with images,\nwereadthemasatensorofshape(batchsize,numberofchannels,height,width). Fornow,\nwe only have one channel as the images are grayscale (the visualization above uses a false\ncolor palette for improved visibility).\nLastly,dataiteratorsareakeycomponentforefficientperformance. Forinstance,wemight\nuse GPUs for efficient image decompression, video transcoding, or other preprocessing.\nWhenever possible, you should rely on well-implemented data iterators that exploit high-\nperformance computing to avoid slowing down your training loop.\n4.2.5Exercises\n1.Does reducing the batch_size (for instance, to 1) affect the reading performance?\n2.The data iterator performance is important. Do you think the current implementation\nis fast enough? Explore various options to improve it. Use a system profiler to find out\nwhere the bottlenecks are.\n3.Check out the framework\u2019s online API documentation. Which other datasets are avail-\nable?\nDiscussions94.\n138 Linear Neural Networks for Classi\ufb01cation\n4.3TheBase Classification Model\nYou may have noticed that the implementations from scratch and the concise implementa-\ntion using framework functionality were quite similar in the case of regression. The same\nistrueforclassification. Sincemanymodelsinthisbookdealwithclassification,itisworth\naddingfunctionalitiestosupportthissettingspecifically. Thissectionprovidesabaseclass\nfor classification models to simplify future code.", "mimetype": "text/plain", "start_char_idx": 365591, "end_char_idx": 369676, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "83738921-b5f1-4c2b-8bcc-9a8562e31053": {"__data__": {"id_": "83738921-b5f1-4c2b-8bcc-9a8562e31053", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d3742376-9ef0-43c6-8fa8-126333c1d06a", "node_type": "1", "metadata": {}, "hash": "37f9a89c46baad80bcd6597696c25cb1c4a559fcd4e205c36745319a635871f0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d85e9b53-ca93-4db8-9c45-37496b153e50", "node_type": "1", "metadata": {}, "hash": "4e4de1a451f45510feb7dba29db6d8a445d02e17a11d6086cc3945763f7cd3a4", "class_name": "RelatedNodeInfo"}}, "text": "4.2.5Exercises\n1.Does reducing the batch_size (for instance, to 1) affect the reading performance?\n2.The data iterator performance is important. Do you think the current implementation\nis fast enough? Explore various options to improve it. Use a system profiler to find out\nwhere the bottlenecks are.\n3.Check out the framework\u2019s online API documentation. Which other datasets are avail-\nable?\nDiscussions94.\n138 Linear Neural Networks for Classi\ufb01cation\n4.3TheBase Classification Model\nYou may have noticed that the implementations from scratch and the concise implementa-\ntion using framework functionality were quite similar in the case of regression. The same\nistrueforclassification. Sincemanymodelsinthisbookdealwithclassification,itisworth\naddingfunctionalitiestosupportthissettingspecifically. Thissectionprovidesabaseclass\nfor classification models to simplify future code.\nimport torch\nfrom d2l import torch asd2l\n4.3.1The Classifier Class\nWe define the Classifier class below. In the validation_step we report both the loss\nvalue and the classification accuracy on a validation batch. We draw an update for every\nnum_val_batches batches. This has the benefit of generating the averaged loss and ac-\ncuracy on the whole validation data. These average numbers are not exactly correct if the\nfinal batch contains fewer examples, but we ignore this minor difference to keep the code\nsimple.\nclass Classifier (d2l .Module): #@save\n\"\"\"The base class of classification models.\"\"\"\ndef validation_step (self , batch):\nY_hat =self (*batch[: -1])\nself .plot( 'loss ',self .loss(Y_hat, batch[ -1]), train =False )\nself .plot( 'acc',self .accuracy(Y_hat, batch[ -1]), train =False )\nBy default we use a stochastic gradient descent optimizer, operating on minibatches, just\nas we did in the context of linear regression.\n@d2l .add_to_class(d2l .Module) #@save\ndef configure_optimizers (self ):\nreturn torch .optim .SGD( self .parameters(), lr =self .lr)\n4.3.2Accuracy\nGiven the predicted probability distribution y_hat, we typically choose the class with the\nhighest predicted probability whenever we must output a hard prediction. Indeed, many\napplications require that we make a choice. For instance, Gmail must categorize an email\ninto\u201cPrimary\u201d,\u201cSocial\u201d,\u201cUpdates\u201d,\u201cForums\u201d,or\u201cSpam\u201d. Itmightestimateprobabilities\ninternally, but at the end of the day it has to choose one among the classes.\nWhen predictions are consistent with the label class y, they are correct. The classification\naccuracy is the fraction of all predictions that are correct. Although it can be difficult to\noptimizeaccuracydirectly(itisnotdifferentiable),itisoftentheperformancemeasurethat\n139 The Base Classi\ufb01cation Model\n95we care about the most. It is often therelevant quantity in benchmarks. As such, we will\nnearly always report it when training classifiers.\nAccuracyiscomputedasfollows. First, if y_hatisamatrix, weassumethattheseconddi-\nmensionstorespredictionscoresforeachclass. Weuse argmaxtoobtainthepredictedclass\nby the index for the largest entry in each row. Then we compare the predicted class with\nthe ground truth yelementwise. Since the equality operator ==is sensitive to data types,\nwe convert y_hat\u2019s data type to match that of y. The result is a tensor containing entries\nof 0 (false) and 1 (true). Taking the sum yields the number of correct predictions.\n@d2l .add_to_class(Classifier) #@save\ndef accuracy (self , Y_hat, Y, averaged =True ):\n\"\"\"Compute the number of correct predictions.\"\"\"\nY_hat =Y_hat .reshape(( -1, Y_hat .shape[ -1]))\npreds =Y_hat .argmax(axis =1).type(Y .dtype)\ncompare =(preds ==Y.reshape( -1)).type(torch .float32)\nreturn compare .mean() ifaveraged else compare\n4.3.3Summary\nClassification is a sufficiently common problem that it warrants its own convenience func-\ntions. Of central importance in classification is the accuracy of the classifier. Note that\nwhile we often care primarily about accuracy, we train classifiers to optimize a variety of\nother objectives for statistical and computational reasons. However, regardless of which\nloss function was minimized during training, it is useful to have a convenience method for\nassessing the accuracy of our classifier empirically.", "mimetype": "text/plain", "start_char_idx": 368796, "end_char_idx": 372995, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d85e9b53-ca93-4db8-9c45-37496b153e50": {"__data__": {"id_": "d85e9b53-ca93-4db8-9c45-37496b153e50", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "83738921-b5f1-4c2b-8bcc-9a8562e31053", "node_type": "1", "metadata": {}, "hash": "27877725af25791be4757636de3cd0dce6f18cf23ec94158a004d9f1e01c476b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fe108d59-2465-4bea-a890-61b6ff6585b8", "node_type": "1", "metadata": {}, "hash": "8af7724357677147cc8941e1cdf8a4f2f6bf2f26d52f83e29bae9f9994cee0d3", "class_name": "RelatedNodeInfo"}}, "text": "@d2l .add_to_class(Classifier) #@save\ndef accuracy (self , Y_hat, Y, averaged =True ):\n\"\"\"Compute the number of correct predictions.\"\"\"\nY_hat =Y_hat .reshape(( -1, Y_hat .shape[ -1]))\npreds =Y_hat .argmax(axis =1).type(Y .dtype)\ncompare =(preds ==Y.reshape( -1)).type(torch .float32)\nreturn compare .mean() ifaveraged else compare\n4.3.3Summary\nClassification is a sufficiently common problem that it warrants its own convenience func-\ntions. Of central importance in classification is the accuracy of the classifier. Note that\nwhile we often care primarily about accuracy, we train classifiers to optimize a variety of\nother objectives for statistical and computational reasons. However, regardless of which\nloss function was minimized during training, it is useful to have a convenience method for\nassessing the accuracy of our classifier empirically.\n4.3.4Exercises\n1.Denote by\ud835\udc3fvthe validation loss, and let \ud835\udc3fq\nvbe its quick and dirty estimate computed\nby the loss function averaging in this section. Lastly, denote by \ud835\udc59b\nvthe loss on the last\nminibatch. Express \ud835\udc3fvin terms of\ud835\udc3fq\nv,\ud835\udc59b\nv, and the sample and minibatch sizes.\n2.Show that the quick and dirty estimate \ud835\udc3fq\nvis unbiased. That is, show that \ud835\udc38\u00bb\ud835\udc3fv\u00bc=\n\ud835\udc38\u00bb\ud835\udc3fq\nv\u00bc. Why would you still want to use \ud835\udc3fvinstead?\n3.Given a multiclass classification loss, denoting by \ud835\udc59\u00b9\ud835\udc66,\ud835\udc660\u00bathe penalty of estimating\n\ud835\udc660when we see \ud835\udc66and given a probabilty \ud835\udc5d\u00b9\ud835\udc66j\ud835\udc65\u00ba, formulate the rule for an optimal\nselection of\ud835\udc660. Hint: express the expected loss, using \ud835\udc59and\ud835\udc5d\u00b9\ud835\udc66j\ud835\udc65\u00ba.\nDiscussions95.\n140 Linear Neural Networks for Classi\ufb01cation\n964.4Softmax RegressionImplementation from\nScratch\nBecause softmax regression is so fundamental, we believe that you ought to know how to\nimplement it yourself. Here, we limit ourselves to defining the softmax-specific aspects of\nthemodelandreusetheothercomponentsfromourlinearregressionsection,includingthe\ntraining loop.\nimport torch\nfrom d2l import torch asd2l\n4.4.1The Softmax\nLet\u2019s begin with the most important part: the mapping from scalars to probabilities. For a\nrefresher, recall the operation of the sum operator along specific dimensions in a tensor, as\ndiscussedin Section2.3.6 andSection2.3.7 . Givenamatrix Xwecansumoverallelements\n(by default) or only over elements in the same axis. The axisvariable lets us compute row\nand column sums:\nX=torch .tensor([[ 1.0,2.0,3.0], [ 4.0,5.0,6.0]])\nX.sum( 0, keepdims =True ), X .sum( 1, keepdims =True )\n(tensor([[ 5.,7.,9.]]),\ntensor([[ 6.],\n[15.]]))\nComputing the softmax requires three steps: (i) exponentiation of each term; (ii) a sum\nover each row to compute the normalization constant for each example; (iii) division of\neach row by its normalization constant, ensuring that the result sums to 1:\nsoftmax\u00b9X\u00ba\ud835\udc56\ud835\udc57=exp\u00b9X\ud835\udc56\ud835\udc57\u00ba\u00cd\n\ud835\udc58exp\u00b9X\ud835\udc56\ud835\udc58\u00ba. (4.4.1)\nThe (logarithm of the) denominator is called the (log) partitionfunction . It was introduced\ninstatistical physics96to sum over all possible states in a thermodynamic ensemble. The\nimplementation is straightforward:\ndef softmax (X):\nX_exp =torch .exp(X)\npartition =X_exp .sum( 1, keepdims =True )\nreturn X_exp /partition # The broadcasting mechanism is applied here\nFor any input X, we turn each element into a nonnegative number. Each row sums up to\n1, as is required for a probability. Caution: the code above is notrobust against very large\nor very small arguments. While it is sufficient to illustrate what is happening, you should\n141 Softmax Regression Implementation from Scratch\nnotuse this code verbatim for any serious purpose.", "mimetype": "text/plain", "start_char_idx": 372143, "end_char_idx": 375637, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fe108d59-2465-4bea-a890-61b6ff6585b8": {"__data__": {"id_": "fe108d59-2465-4bea-a890-61b6ff6585b8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d85e9b53-ca93-4db8-9c45-37496b153e50", "node_type": "1", "metadata": {}, "hash": "4e4de1a451f45510feb7dba29db6d8a445d02e17a11d6086cc3945763f7cd3a4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7d6fbfb3-3d5b-4b06-a506-fff0aed113e7", "node_type": "1", "metadata": {}, "hash": "78e8700e729678aff49aea0b02d87f819765422367968299907c7a728313f834", "class_name": "RelatedNodeInfo"}}, "text": "(4.4.1)\nThe (logarithm of the) denominator is called the (log) partitionfunction . It was introduced\ninstatistical physics96to sum over all possible states in a thermodynamic ensemble. The\nimplementation is straightforward:\ndef softmax (X):\nX_exp =torch .exp(X)\npartition =X_exp .sum( 1, keepdims =True )\nreturn X_exp /partition # The broadcasting mechanism is applied here\nFor any input X, we turn each element into a nonnegative number. Each row sums up to\n1, as is required for a probability. Caution: the code above is notrobust against very large\nor very small arguments. While it is sufficient to illustrate what is happening, you should\n141 Softmax Regression Implementation from Scratch\nnotuse this code verbatim for any serious purpose. Deep learning frameworks have such\nprotections built in and we will be using the built-in softmax going forward.\nX=torch .rand(( 2,5))\nX_prob =softmax(X)\nX_prob, X_prob .sum( 1)\n(tensor([[ 0.2511 ,0.1417 ,0.1158 ,0.2529 ,0.2385 ],\n[0.2004 ,0.1419 ,0.1957 ,0.2504 ,0.2117 ]]),\ntensor([ 1.,1.]))\n4.4.2TheModel\nWe now have everything that we need to implement the softmax regression model. As in\nour linear regression example, each instance will be represented by a fixed-length vector.\nSince the raw data here consists of 28\u000228pixel images, we flatten each image, treating\nthem as vectors of length 784. In later chapters, we will introduce convolutional neural\nnetworks, which exploit the spatial structure in a more satisfying way.\nIn softmax regression, the number of outputs from our network should be equal to the\nnumber of classes. Since our dataset has 10 classes, our network has an output dimension\nof 10. Consequently, our weights constitute a 784\u000210matrix plus a 1\u000210row vector for\nthe biases. As with linear regression, we initialize the weights Wwith Gaussian noise. The\nbiases are initialized as zeros.\nclass SoftmaxRegressionScratch (d2l .Classifier):\ndef __init__ (self , num_inputs, num_outputs, lr, sigma =0.01 ):\nsuper ().__init__ ()\nself .save_hyperparameters()\nself .W=torch .normal( 0, sigma, size =(num_inputs, num_outputs),\nrequires_grad =True )\nself .b=torch .zeros(num_outputs, requires_grad =True )\ndef parameters (self ):\nreturn [self .W,self .b]\nThecodebelowdefineshowthenetworkmapseachinputtoanoutput. Notethatweflatten\neach 28\u000228pixel image in the batch into a vector using reshape before passing the data\nthrough our model.\n@d2l .add_to_class(SoftmaxRegressionScratch)\ndef forward (self , X):\nX=X.reshape(( -1,self .W.shape[ 0]))\nreturn softmax(torch .matmul(X, self .W)+self .b)\n4.4.3The Cross-EntropyLoss\nNext we need to implement the cross-entropy loss function (introduced in Section 4.1.2 ).\nThis may be the most common loss function in all of deep learning. At the moment, appli-\n142 Linear Neural Networks for Classi\ufb01cation\ncations of deep learning easily cast as classification problems far outnumber those better\ntreated as regression problems.\nRecall that cross-entropy takes the negative log-likelihood of the predicted probability as-\nsigned to the true label. For efficiency we avoid Python for-loops and use indexing instead.\nIn particular, the one-hot encoding in yallows us to select the matching terms in \u02c6y.\nToseethisinactionwecreatesampledata y_hatwith2examplesofpredictedprobabilities\nover 3 classes and their corresponding labels y. The correct labels are 0and2respectively\n(i.e., the first and third class). Using yas the indices of the probabilities in y_hat, we can\npick out terms efficiently.\ny=torch .tensor([ 0,2])\ny_hat =torch .tensor([[ 0.1,0.3,0.6], [ 0.3,0.2,0.5]])\ny_hat[[ 0,1], y]\ntensor([ 0.1000 ,0.5000 ])\nNowwecanimplementthecross-entropylossfunctionbyaveragingoverthelogarithmsof\nthe selected probabilities.", "mimetype": "text/plain", "start_char_idx": 374892, "end_char_idx": 378612, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7d6fbfb3-3d5b-4b06-a506-fff0aed113e7": {"__data__": {"id_": "7d6fbfb3-3d5b-4b06-a506-fff0aed113e7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fe108d59-2465-4bea-a890-61b6ff6585b8", "node_type": "1", "metadata": {}, "hash": "8af7724357677147cc8941e1cdf8a4f2f6bf2f26d52f83e29bae9f9994cee0d3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bc7569da-4df3-4295-8e16-c6936efa5ed8", "node_type": "1", "metadata": {}, "hash": "95bcdcbfd3005fbb83355f6a73126d1769330d546106e6db6ea076b3af1deb8b", "class_name": "RelatedNodeInfo"}}, "text": "In particular, the one-hot encoding in yallows us to select the matching terms in \u02c6y.\nToseethisinactionwecreatesampledata y_hatwith2examplesofpredictedprobabilities\nover 3 classes and their corresponding labels y. The correct labels are 0and2respectively\n(i.e., the first and third class). Using yas the indices of the probabilities in y_hat, we can\npick out terms efficiently.\ny=torch .tensor([ 0,2])\ny_hat =torch .tensor([[ 0.1,0.3,0.6], [ 0.3,0.2,0.5]])\ny_hat[[ 0,1], y]\ntensor([ 0.1000 ,0.5000 ])\nNowwecanimplementthecross-entropylossfunctionbyaveragingoverthelogarithmsof\nthe selected probabilities.\ndef cross_entropy (y_hat, y):\nreturn -torch .log(y_hat[ list (range (len(y_hat))), y]) .mean()\ncross_entropy(y_hat, y)\ntensor( 1.4979 )\n@d2l .add_to_class(SoftmaxRegressionScratch)\ndef loss (self , y_hat, y):\nreturn cross_entropy(y_hat, y)\n4.4.4Training\nWereusethe fitmethoddefinedin Section3.4 totrainthemodelwith10epochs. Notethat\nthe number of epochs ( max_epochs ), the minibatch size ( batch_size ), and learning rate\n(lr) are adjustable hyperparameters. That means that while these values are not learned\nduring our primary training loop, they still influence the performance of our model, both\nvis-\u00e0-vistrainingandgeneralizationperformance. Inpracticeyouwillwanttochoosethese\nvalues based on the validation split of the data and then, ultimately, to evaluate your final\nmodelonthe testsplit. Asdiscussedin Section3.6.3 ,wewillregardthetestdataofFashion-\nMNIST as the validation set, thus reporting validation loss and validation accuracy on this\nsplit.\n143 Softmax Regression Implementation from Scratch\ndata =d2l.FashionMNIST(batch_size =256)\nmodel =SoftmaxRegressionScratch(num_inputs =784, num_outputs =10, lr =0.1)\ntrainer =d2l.Trainer(max_epochs =10)\ntrainer .fit(model, data)\n4.4.5Prediction\nNow that training is complete, our model is ready to classify some images.\nX, y =next (iter (data .val_dataloader()))\npreds =model(X) .argmax(axis =1)\npreds .shape\ntorch .Size([ 256])\nWearemoreinterestedintheimageswelabel incorrectly . Wevisualizethembycomparing\ntheiractuallabels(firstlineoftextoutput)withthepredictionsfromthemodel(secondline\nof text output).\nwrong =preds .type(y .dtype) !=y\nX, y, preds =X[wrong], y[wrong], preds[wrong]\nlabels =[a+'\\n'+bfor a, b inzip(\ndata .text_labels(y), data .text_labels(preds))]\ndata .visualize([X, y], labels =labels)\n4.4.6Summary\nBy now we are starting to get some experience with solving linear regression and classifi-\ncation problems. With it, we have reached what would arguably be the state of the art of\n144 Linear Neural Networks for Classi\ufb01cation\n971960\u20131970s of statistical modeling. In the next section, we will show you how to leverage\ndeep learning frameworks to implement this model much more efficiently.\n4.4.7Exercises\n1.Inthissection,wedirectlyimplementedthesoftmaxfunctionbasedonthemathematical\ndefinitionofthesoftmaxoperation. Asdiscussedin Section4.1 thiscancausenumerical\ninstabilities.\n1.Test whether softmax still works correctly if an input has a value of 100.\n2.Test whether softmax still works correctly if the largest of all inputs is smaller than\n\u0000100?\n3.Implement a fix by looking at the value relative to the largest entry in the argument.\n2.Implement a cross_entropy function that follows the definition of the cross-entropy\nloss function\u00cd\n\ud835\udc56\ud835\udc66\ud835\udc56log \u02c6\ud835\udc66\ud835\udc56.\n1.Try it out in the code example of this section.\n2.Why do you think it runs more slowly?\n3.Should you use it? When would it make sense to?\n4.What do you need to be careful of? Hint: consider the domain of the logarithm.\n3.Is it always a good idea to return the most likely label? For example, would you do this\nfor medical diagnosis? How would you try to address this?", "mimetype": "text/plain", "start_char_idx": 378008, "end_char_idx": 381715, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bc7569da-4df3-4295-8e16-c6936efa5ed8": {"__data__": {"id_": "bc7569da-4df3-4295-8e16-c6936efa5ed8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7d6fbfb3-3d5b-4b06-a506-fff0aed113e7", "node_type": "1", "metadata": {}, "hash": "78e8700e729678aff49aea0b02d87f819765422367968299907c7a728313f834", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "73bf6874-0f20-4875-accd-a3ff3ff54539", "node_type": "1", "metadata": {}, "hash": "56c87096ca8d0d8b52bab9e1f1751af5df94b6b2b5964f0824a3439e2b0bf9a0", "class_name": "RelatedNodeInfo"}}, "text": "1.Test whether softmax still works correctly if an input has a value of 100.\n2.Test whether softmax still works correctly if the largest of all inputs is smaller than\n\u0000100?\n3.Implement a fix by looking at the value relative to the largest entry in the argument.\n2.Implement a cross_entropy function that follows the definition of the cross-entropy\nloss function\u00cd\n\ud835\udc56\ud835\udc66\ud835\udc56log \u02c6\ud835\udc66\ud835\udc56.\n1.Try it out in the code example of this section.\n2.Why do you think it runs more slowly?\n3.Should you use it? When would it make sense to?\n4.What do you need to be careful of? Hint: consider the domain of the logarithm.\n3.Is it always a good idea to return the most likely label? For example, would you do this\nfor medical diagnosis? How would you try to address this?\n4.Assume that we want to use softmax regression to predict the next word based on some\nfeatures. What are some problems that might arise from a large vocabulary?\n5.Experiment with the hyperparameters of the code in this section. In particular:\n1.Plot how the validation loss changes as you change the learning rate.\n2.Do the validation and training loss change as you change the minibatch size? How\nlarge or small do you need to go before you see an effect?\nDiscussions97.\n4.5ConciseImplementation of Softmax Regression\nJust as high-level deep learning frameworks made it easier to implement linear regression\n(seeSection 3.5 ), they are similarly convenient here.\n145 Concise Implementation of Softmax Regression\nimport torch\nfrom torch import nn\nfrom torch .nnimport functional asF\nfrom d2l import torch asd2l\n4.5.1Definingthe Model\nAsinSection3.5 ,weconstructourfullyconnectedlayerusingthebuilt-inlayer. Thebuilt-\nin__call__ methodtheninvokes forward wheneverweneedtoapplythenetworktosome\ninput.\nWe use a Flatten layer to convert the fourth-order tensor Xto second order by keeping the\ndimensionality along the first axis unchanged.\nclass SoftmaxRegression (d2l .Classifier): #@save\n\"\"\"The softmax regression model.\"\"\"\ndef __init__ (self , num_outputs, lr):\nsuper ().__init__ ()\nself .save_hyperparameters()\nself .net =nn.Sequential(nn .Flatten(),\nnn.LazyLinear(num_outputs))\ndef forward (self , X):\nreturn self .net(X)\n4.5.2Softmax Revisited\nInSection 4.4 we calculated our model\u2019s output and applied the cross-entropy loss. While\nthis is perfectly reasonable mathematically, it is risky computationally, because of numer-\nical underflow and overflow in the exponentiation.\nRecall that the softmax function computes probabilities via \u02c6\ud835\udc66\ud835\udc57=exp\u00b9\ud835\udc5c\ud835\udc57\u00ba\u00cd\n\ud835\udc58exp\u00b9\ud835\udc5c\ud835\udc58\u00ba. If some of the\n\ud835\udc5c\ud835\udc58are very large, i.e., very positive, then exp\u00b9\ud835\udc5c\ud835\udc58\u00bamight be larger than the largest number\nwe can have for certain data types. This is called overflow . Likewise, if every argument is\na very large negative number, we will get underflow . For instance, single precision floating\npoint numbers approximately cover the range of 10\u000038to1038. As such, if the largest term\ninolies outside the interval \u00bb\u000090,90\u00bc, the result will not be stable. A way round this\nproblem is to subtract \u00af\ud835\udc5cdef=max\ud835\udc58\ud835\udc5c\ud835\udc58from all entries:\n\u02c6\ud835\udc66\ud835\udc57=exp\ud835\udc5c\ud835\udc57\u00cd\n\ud835\udc58exp\ud835\udc5c\ud835\udc58=exp\u00b9\ud835\udc5c\ud835\udc57\u0000\u00af\ud835\udc5c\u00baexp \u00af\ud835\udc5c\u00cd\n\ud835\udc58exp\u00b9\ud835\udc5c\ud835\udc58\u0000\u00af\ud835\udc5c\u00baexp \u00af\ud835\udc5c=exp\u00b9\ud835\udc5c\ud835\udc57\u0000\u00af\ud835\udc5c\u00ba\u00cd\n\ud835\udc58exp\u00b9\ud835\udc5c\ud835\udc58\u0000\u00af\ud835\udc5c\u00ba. (4.5.1)\nBy construction we know that \ud835\udc5c\ud835\udc57\u0000\u00af\ud835\udc5c\u00140for all\ud835\udc57. As such, for a \ud835\udc5e-class classification\nproblem, the denominator is contained in the interval \u00bb1,\ud835\udc5e\u00bc. Moreover, the numerator\nnever exceeds 1, thus preventing numerical overflow. Numerical underflow only occurs\nwhen exp\u00b9\ud835\udc5c\ud835\udc57\u0000\u00af\ud835\udc5c\u00banumerically evaluates as 0. Nonetheless, a few steps down the road we\nmight find ourselves in trouble when we want to compute log \u02c6\ud835\udc66\ud835\udc57aslog 0.", "mimetype": "text/plain", "start_char_idx": 380971, "end_char_idx": 384496, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "73bf6874-0f20-4875-accd-a3ff3ff54539": {"__data__": {"id_": "73bf6874-0f20-4875-accd-a3ff3ff54539", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bc7569da-4df3-4295-8e16-c6936efa5ed8", "node_type": "1", "metadata": {}, "hash": "95bcdcbfd3005fbb83355f6a73126d1769330d546106e6db6ea076b3af1deb8b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bc78bc95-5add-48f9-ada8-d124be5d884f", "node_type": "1", "metadata": {}, "hash": "5ce8f4ae5e04aa5845b92c5fcfaf4ae096df65fb0366407613e207566ce62dff", "class_name": "RelatedNodeInfo"}}, "text": "(4.5.1)\nBy construction we know that \ud835\udc5c\ud835\udc57\u0000\u00af\ud835\udc5c\u00140for all\ud835\udc57. As such, for a \ud835\udc5e-class classification\nproblem, the denominator is contained in the interval \u00bb1,\ud835\udc5e\u00bc. Moreover, the numerator\nnever exceeds 1, thus preventing numerical overflow. Numerical underflow only occurs\nwhen exp\u00b9\ud835\udc5c\ud835\udc57\u0000\u00af\ud835\udc5c\u00banumerically evaluates as 0. Nonetheless, a few steps down the road we\nmight find ourselves in trouble when we want to compute log \u02c6\ud835\udc66\ud835\udc57aslog 0. In particular, in\nbackpropagation, we might find ourselves faced with a screenful of the dreaded NaN(Not a\nNumber) results.\n146 Linear Neural Networks for Classi\ufb01cation\n98Fortunately, we are saved by the fact that even though we are computing exponential func-\ntions, we ultimately intend to take their log (when calculating the cross-entropy loss). By\ncombining softmax and cross-entropy, we can escape the numerical stability issues alto-\ngether. We have:\nlog \u02c6\ud835\udc66\ud835\udc57=logexp\u00b9\ud835\udc5c\ud835\udc57\u0000\u00af\ud835\udc5c\u00ba\u00cd\n\ud835\udc58exp\u00b9\ud835\udc5c\ud835\udc58\u0000\u00af\ud835\udc5c\u00ba=\ud835\udc5c\ud835\udc57\u0000\u00af\ud835\udc5c\u0000log\u00d5\n\ud835\udc58exp\u00b9\ud835\udc5c\ud835\udc58\u0000\u00af\ud835\udc5c\u00ba. (4.5.2)\nThis avoids both overflow and underflow. We will want to keep the conventional softmax\nfunction handy in case we ever want to evaluate the output probabilities by our model. But\ninstead of passing softmax probabilities into our new loss function, we just pass the logits\nandcomputethesoftmaxanditslogallatonceinsidethecross-entropylossfunction,which\ndoes smart things like the \u201cLogSumExp trick\u201d98.\n@d2l .add_to_class(d2l .Classifier) #@save\ndef loss (self , Y_hat, Y, averaged =True ):\nY_hat =Y_hat .reshape(( -1, Y_hat .shape[ -1]))\nY=Y.reshape(( -1,))\nreturn F.cross_entropy(\nY_hat, Y, reduction ='mean 'ifaveraged else 'none ')\n4.5.3Training\nNext we train our model. We use Fashion-MNIST images, flattened to 784-dimensional\nfeature vectors.\ndata =d2l.FashionMNIST(batch_size =256)\nmodel =SoftmaxRegression(num_outputs =10, lr =0.1)\ntrainer =d2l.Trainer(max_epochs =10)\ntrainer .fit(model, data)\nAsbefore,thisalgorithmconvergestoasolutionthatisreasonablyaccurate,albeitthistime\nwith fewer lines of code than before.\n4.5.4Summary\nHigh-levelAPIsareveryconvenientathidingfromtheiruserpotentiallydangerousaspects,\nsuch as numerical stability. Moreover, they allow users to design models concisely with\n147 Generalization in Classi\ufb01cation\n99very few lines of code. This is both a blessing and a curse. The obvious benefit is that it\nmakesthingshighlyaccessible,eventoengineerswhonevertookasingleclassofstatistics\nin their life (in fact, they are part of the target audience of the book). But hiding the sharp\nedgesalsocomeswith aprice: a disincentivetoadd newanddifferent componentsonyour\nown, since there is little muscle memory for doing it. Moreover, it makes it more difficult\ntofixthings whenever the protective padding of a framework fails to cover all the corner\ncases entirely. Again, this is due to lack of familiarity.\nAs such, we strongly urge you to review boththe bare bones and the elegant versions of\nmany of the implementations that follow. While we emphasize ease of understanding, the\nimplementations are nonetheless usually quite performant (convolutions are the big excep-\ntionhere). Itisourintentiontoallowyoutobuildonthesewhenyouinventsomethingnew\nthat no framework can give you.\n4.5.5Exercises\n1.Deep learning uses many different number formats, including FP64 double precision\n(used extremely rarely), FP32 single precision, BFLOAT16 (good for compressed rep-\nresentations), FP16 (very unstable), TF32 (a new format from NVIDIA), and INT8.\nCompute the smallest and largest argument of the exponential function for which the\nresult does not lead to numerical underflow or overflow.\n2.INT8 is a very limited format consisting of nonzero numbers from 1to255. How could\nyou extend its dynamic range without using more bits? Do standard multiplication and\naddition still work?", "mimetype": "text/plain", "start_char_idx": 384078, "end_char_idx": 387815, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bc78bc95-5add-48f9-ada8-d124be5d884f": {"__data__": {"id_": "bc78bc95-5add-48f9-ada8-d124be5d884f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "73bf6874-0f20-4875-accd-a3ff3ff54539", "node_type": "1", "metadata": {}, "hash": "56c87096ca8d0d8b52bab9e1f1751af5df94b6b2b5964f0824a3439e2b0bf9a0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1c7c6c78-732b-44ed-b5e0-006632d5c729", "node_type": "1", "metadata": {}, "hash": "5d49a230a2992224c7a0b410896ede40075db70b12196c5906a8db1e0a56091b", "class_name": "RelatedNodeInfo"}}, "text": "While we emphasize ease of understanding, the\nimplementations are nonetheless usually quite performant (convolutions are the big excep-\ntionhere). Itisourintentiontoallowyoutobuildonthesewhenyouinventsomethingnew\nthat no framework can give you.\n4.5.5Exercises\n1.Deep learning uses many different number formats, including FP64 double precision\n(used extremely rarely), FP32 single precision, BFLOAT16 (good for compressed rep-\nresentations), FP16 (very unstable), TF32 (a new format from NVIDIA), and INT8.\nCompute the smallest and largest argument of the exponential function for which the\nresult does not lead to numerical underflow or overflow.\n2.INT8 is a very limited format consisting of nonzero numbers from 1to255. How could\nyou extend its dynamic range without using more bits? Do standard multiplication and\naddition still work?\n3.Increasethenumberofepochsfortraining. Whymightthevalidationaccuracydecrease\nafter a while? How could we fix this?\n4.What happens as you increase the learning rate? Compare the loss curves for several\nlearning rates. Which one works better? When?\nDiscussions99.\n4.6Generalizationin Classification\nSo far, we have focused on how to tackle multiclass classification problems by training\n(linear) neural networks with multiple outputs and softmax functions. Interpreting our\nmodel\u2019s outputs as probabilistic predictions, we motivated and derived the cross-entropy\nloss function, which calculates the negative log likelihood that our model (for a fixed set\nof parameters) assigns to the actual labels. And finally, we put these tools into practice\nby fitting our model to the training set. However, as always, our goal is to learn general\npatterns, as assessed empirically on previously unseen data (the test set). High accuracy\non the training set means nothing. Whenever each of our inputs is unique (and indeed this\nis true for most high-dimensional datasets), we can attain perfect accuracy on the training\n148 Linear Neural Networks for Classi\ufb01cation\nset by just memorizing the dataset on the first training epoch, and subsequently looking up\nthe label whenever we see a new image. And yet, memorizing the exact labels associated\nwith the exact training examples does not tell us how to classify new examples. Absent\nfurther guidance, we might have to fall back on random guessing whenever we encounter\nnew examples.\nA number of burning questions demand immediate attention:\n1.How many test examples do we need to give a good estimate of the accuracy of our\nclassifiers on the underlying population?\n2.What happens if we keep evaluating models on the same test repeatedly?\n3.Why should we expect that fitting our linear models to the training set should fare any\nbetter than our naive memorization scheme?\nWhereas Section3.6 introducedthebasicsofoverfittingandgeneralizationinthecontextof\nlinear regression, this chapter will go a little deeper, introducing some of the foundational\nideas of statistical learning theory. It turns out that we often can guarantee generalization\na priori: for many models, and for any desired upper bound on the generalization gap \ud835\udf16,\nwe can often determine some required number of samples \ud835\udc5bsuch that if our training set\ncontains at least \ud835\udc5bsamples, our empirical error will lie within \ud835\udf16of the true error, for any\ndatageneratingdistribution . Unfortunately, it also turns out that while these sorts of guar-\nantees provide a profound set of intellectual building blocks, they are of limited practical\nutility to the deep learning practitioner. In short, these guarantees suggest that ensuring\ngeneralization of deep neural networks a priori requires an absurd number of examples\n(perhapstrillionsormore), evenwhenwefindthat, onthetaskswecareabout, deepneural\nnetworks typically generalize remarkably well with far fewer examples (thousands). Thus\ndeep learning practitioners often forgo a priori guarantees altogether, instead employing\nmethods that have generalized well on similar problems in the past, and certifying gen-\neralization post hoc through empirical evaluations. When we get to Chapter 5 , we will\nrevisit generalization and provide a light introduction to the vast scientific literature that\nhas sprung in attempts to explain why deep neural networks generalize in practice.\n4.6.1The TestSet\nSince we have already begun to rely on test sets as the gold standard method for assessing\ngeneralization error, let\u2019s get started by discussing the properties of such error estimates.\nLet\u2019s focus on a fixed classifier \ud835\udc53, without worrying about how it was obtained.", "mimetype": "text/plain", "start_char_idx": 386977, "end_char_idx": 391519, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1c7c6c78-732b-44ed-b5e0-006632d5c729": {"__data__": {"id_": "1c7c6c78-732b-44ed-b5e0-006632d5c729", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bc78bc95-5add-48f9-ada8-d124be5d884f", "node_type": "1", "metadata": {}, "hash": "5ce8f4ae5e04aa5845b92c5fcfaf4ae096df65fb0366407613e207566ce62dff", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1d8f84d6-6553-40f1-9a71-5a321f0f4eab", "node_type": "1", "metadata": {}, "hash": "deac98032a1720af88dfb3eaa73e1e5c5ab7f4aff9ddfba98bcdf492a2eede79", "class_name": "RelatedNodeInfo"}}, "text": "Thus\ndeep learning practitioners often forgo a priori guarantees altogether, instead employing\nmethods that have generalized well on similar problems in the past, and certifying gen-\neralization post hoc through empirical evaluations. When we get to Chapter 5 , we will\nrevisit generalization and provide a light introduction to the vast scientific literature that\nhas sprung in attempts to explain why deep neural networks generalize in practice.\n4.6.1The TestSet\nSince we have already begun to rely on test sets as the gold standard method for assessing\ngeneralization error, let\u2019s get started by discussing the properties of such error estimates.\nLet\u2019s focus on a fixed classifier \ud835\udc53, without worrying about how it was obtained. Moreover\nsuppose that we possess a freshdataset of examples D=\u00b9x\u00b9\ud835\udc56\u00ba,\ud835\udc66\u00b9\ud835\udc56\u00ba\u00ba\ud835\udc5b\n\ud835\udc56=1that were not used\nto train the classifier \ud835\udc53. Theempiricalerror of our classifier \ud835\udc53onDis simply the fraction\nofinstancesforwhichtheprediction \ud835\udc53\u00b9x\u00b9\ud835\udc56\u00ba\u00badisagreeswiththetruelabel \ud835\udc66\u00b9\ud835\udc56\u00ba, andisgiven\nby the following expression:\n\ud835\udf16D\u00b9\ud835\udc53\u00ba=1\n\ud835\udc5b\ud835\udc5b\u00d5\n\ud835\udc56=11\u00b9\ud835\udc53\u00b9x\u00b9\ud835\udc56\u00ba\u00ba\u2260\ud835\udc66\u00b9\ud835\udc56\u00ba\u00ba. (4.6.1)\nBycontrast,the populationerror istheexpected fractionofexamplesintheunderlyingpop-\nulation (some distribution \ud835\udc43\u00b9\ud835\udc4b,\ud835\udc4c\u00bacharacterized by probability density function \ud835\udc5d\u00b9x,\ud835\udc66\u00ba)\n149 Generalization in Classi\ufb01cation\nfor which our classifier disagrees with the true label:\n\ud835\udf16\u00b9\ud835\udc53\u00ba=\ud835\udc38\u00b9x,\ud835\udc66\u00ba\u0018\ud835\udc431\u00b9\ud835\udc53\u00b9x\u00ba\u2260\ud835\udc66\u00ba=\u00b9 \u00b9\n1\u00b9\ud835\udc53\u00b9x\u00ba\u2260\ud835\udc66\u00ba\ud835\udc5d\u00b9x,\ud835\udc66\u00ba\ud835\udc51x\ud835\udc51\ud835\udc66. (4.6.2)\nWhile\ud835\udf16\u00b9\ud835\udc53\u00bais the quantity that we actually care about, we cannot observe it directly, just\nas we cannot directly observe the average height in a large population without measuring\nevery single person. We can only estimate this quantity based on samples. Because our\ntest setDis statistically representative of the underlying population, we can view \ud835\udf16D\u00b9\ud835\udc53\u00ba\nas a statistical estimator of the population error \ud835\udf16\u00b9\ud835\udc53\u00ba. Moreover, because our quantity of\ninterest\ud835\udf16\u00b9\ud835\udc53\u00baisanexpectation(oftherandomvariable 1\u00b9\ud835\udc53\u00b9\ud835\udc4b\u00ba\u2260\ud835\udc4c\u00ba)andthecorresponding\nestimator\ud835\udf16D\u00b9\ud835\udc53\u00baisthesampleaverage,estimatingthepopulationerrorissimplytheclassic\nproblem of mean estimation, which you may recall from Section 2.6 .\nAn important classical result from probability theory called the centrallimittheorem guar-\nantees that whenever we possess \ud835\udc5brandom samples \ud835\udc4e1,...,\ud835\udc4e\ud835\udc5bdrawn from any distribution\nwith mean\ud835\udf07and standard deviation \ud835\udf0e, then, as the number of samples \ud835\udc5bapproaches infin-\nity,thesampleaverage \u02c6\ud835\udf07approximatelytendstowardsanormaldistributioncenteredatthe\ntrue mean and with standard deviation \ud835\udf0e\u009dp\ud835\udc5b. Already, this tells us something important:\nasthenumberofexamplesgrowslarge,ourtesterror \ud835\udf16D\u00b9\ud835\udc53\u00bashouldapproachthetrueerror\n\ud835\udf16\u00b9\ud835\udc53\u00baat a rate ofO\u00b91\u009dp\ud835\udc5b\u00ba. Thus, to estimate our test error twice as precisely, we must\ncollect four times as large a test set. To reduce our test error by a factor of one hundred, we\nmust collect ten thousand times as large a test set. In general, such a rate of O\u00b91\u009dp\ud835\udc5b\u00bais\noften the best we can hope for in statistics.\nNow that we know something about the asymptotic rate at which our test error \ud835\udf16D\u00b9\ud835\udc53\u00ba\nconverges to the true error \ud835\udf16\u00b9\ud835\udc53\u00ba, we can zoom in on some important details.", "mimetype": "text/plain", "start_char_idx": 390789, "end_char_idx": 393832, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1d8f84d6-6553-40f1-9a71-5a321f0f4eab": {"__data__": {"id_": "1d8f84d6-6553-40f1-9a71-5a321f0f4eab", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1c7c6c78-732b-44ed-b5e0-006632d5c729", "node_type": "1", "metadata": {}, "hash": "5d49a230a2992224c7a0b410896ede40075db70b12196c5906a8db1e0a56091b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2ca2f478-f27b-409f-a44e-c2c7e6bde926", "node_type": "1", "metadata": {}, "hash": "347b757b13e60edb9bee8cb4e4a9fc162e50cd00f32c9d93dee1f1049ca330c0", "class_name": "RelatedNodeInfo"}}, "text": "Already, this tells us something important:\nasthenumberofexamplesgrowslarge,ourtesterror \ud835\udf16D\u00b9\ud835\udc53\u00bashouldapproachthetrueerror\n\ud835\udf16\u00b9\ud835\udc53\u00baat a rate ofO\u00b91\u009dp\ud835\udc5b\u00ba. Thus, to estimate our test error twice as precisely, we must\ncollect four times as large a test set. To reduce our test error by a factor of one hundred, we\nmust collect ten thousand times as large a test set. In general, such a rate of O\u00b91\u009dp\ud835\udc5b\u00bais\noften the best we can hope for in statistics.\nNow that we know something about the asymptotic rate at which our test error \ud835\udf16D\u00b9\ud835\udc53\u00ba\nconverges to the true error \ud835\udf16\u00b9\ud835\udc53\u00ba, we can zoom in on some important details. Recall that\nthe random variable of interest 1\u00b9\ud835\udc53\u00b9\ud835\udc4b\u00ba\u2260\ud835\udc4c\u00bacan only take values 0and 1and thus is\na Bernoulli random variable, characterized by a parameter indicating the probability that\nit takes value 1. Here, 1means that our classifier made an error, so the parameter of our\nrandomvariableisactuallythetrueerrorrate \ud835\udf16\u00b9\ud835\udc53\u00ba. Thevariance \ud835\udf0e2ofaBernoullidepends\non its parameter (here, \ud835\udf16\u00b9\ud835\udc53\u00ba) according to the expression \ud835\udf16\u00b9\ud835\udc53\u00ba\u00b91\u0000\ud835\udf16\u00b9\ud835\udc53\u00ba\u00ba. While\ud835\udf16\u00b9\ud835\udc53\u00bais\ninitially unknown, we know that it cannot be greater than 1. A little investigation of this\nfunction reveals that our variance is highest when the true error rate is close to 0.5and can\nbe far lower when it is close to 0or close to 1. This tells us that the asymptotic standard\ndeviation of our estimate \ud835\udf16D\u00b9\ud835\udc53\u00baof the error\ud835\udf16\u00b9\ud835\udc53\u00ba(over the choice of the \ud835\udc5btest samples)\ncannot be any greater thanp\n0.25\u009d\ud835\udc5b.\nIf we ignore the fact that this rate characterizes behavior as the test set size approaches\ninfinity rather than when we possess finite samples, this tells us that if we want our test\nerror\ud835\udf16D\u00b9\ud835\udc53\u00bato approximate the population error \ud835\udf16\u00b9\ud835\udc53\u00basuch that one standard deviation\ncorresponds to an interval of \u00060.01, then we should collect roughly 2500 samples. If we\nwant to fit two standard deviations in that range and thus be 95% confident that \ud835\udf16D\u00b9\ud835\udc53\u00ba2\n\ud835\udf16\u00b9\ud835\udc53\u00ba\u00060.01, then we will need 10,000 samples!\nThisturnsouttobethesizeofthetestsetsformanypopularbenchmarksinmachinelearn-\ning. You might be surprised to find out that thousands of applied deep learning papers get\npublished every year making a big deal out of error rate improvements of 0.01or less. Of\n150 Linear Neural Networks for Classi\ufb01cation\ncourse, when the error rates are much closer to 0, then an improvement of 0.01can indeed\nbe a big deal.\nOne pesky feature of our analysis thus far is that it really only tells us about asymptotics,\ni.e., how the relationship between \ud835\udf16Dand\ud835\udf16evolves as our sample size goes to infinity.\nFortunately, because our random variable is bounded, we can obtain valid finite sample\nbounds by applying an inequality due to Hoeffding (1963):\n\ud835\udc43\u00b9\ud835\udf16D\u00b9\ud835\udc53\u00ba\u0000\ud835\udf16\u00b9\ud835\udc53\u00ba\u0015\ud835\udc61\u00ba<exp\u0010\n\u00002\ud835\udc5b\ud835\udc612\u0011\n. (4.6.3)\nSolving for the smallest dataset size that would allow us to conclude with 95% confidence\nthat the distance \ud835\udc61betweenour estimate \ud835\udf16D\u00b9\ud835\udc53\u00baand the true error rate \ud835\udf16\u00b9\ud835\udc53\u00badoes not exceed\n0.01, you will find that roughly 15,000 examples are required as compared to the 10,000\nexamples suggested by the asymptotic analysis above. If you go deeper into statistics you\nwill find that this trend holds generally. Guarantees that hold even in finite samples are\ntypically slightly more conservative.", "mimetype": "text/plain", "start_char_idx": 393235, "end_char_idx": 396410, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2ca2f478-f27b-409f-a44e-c2c7e6bde926": {"__data__": {"id_": "2ca2f478-f27b-409f-a44e-c2c7e6bde926", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1d8f84d6-6553-40f1-9a71-5a321f0f4eab", "node_type": "1", "metadata": {}, "hash": "deac98032a1720af88dfb3eaa73e1e5c5ab7f4aff9ddfba98bcdf492a2eede79", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "dd1469cf-8d89-4c10-b5ac-fff709b77fa1", "node_type": "1", "metadata": {}, "hash": "d4fa128fae1c13dc6dde91ed2121193e3d8796ace5ad92f0fde32158bc4af9cd", "class_name": "RelatedNodeInfo"}}, "text": "(4.6.3)\nSolving for the smallest dataset size that would allow us to conclude with 95% confidence\nthat the distance \ud835\udc61betweenour estimate \ud835\udf16D\u00b9\ud835\udc53\u00baand the true error rate \ud835\udf16\u00b9\ud835\udc53\u00badoes not exceed\n0.01, you will find that roughly 15,000 examples are required as compared to the 10,000\nexamples suggested by the asymptotic analysis above. If you go deeper into statistics you\nwill find that this trend holds generally. Guarantees that hold even in finite samples are\ntypically slightly more conservative. Note that in the scheme of things, these numbers\nare not so far apart, reflecting the general usefulness of asymptotic analysis for giving us\nballpark figures even if they are not guarantees we can take to court.\n4.6.2TestSetReuse\nIn some sense, you are now set up to succeed at conducting empirical machine learning\nresearch. Nearly all practical models are developed and validated based on test set perfor-\nmance and you are now a master of the test set. For any fixed classifier \ud835\udc53, you know how\nto evaluate its test error \ud835\udf16D\u00b9\ud835\udc53\u00ba, and know precisely what can (and cannot) be said about its\npopulation error \ud835\udf16\u00b9\ud835\udc53\u00ba.\nSo let\u2019s say that you take this knowledge and prepare to train your first model \ud835\udc531. Knowing\njusthowconfidentyouneedtobeintheperformanceofyourclassifier\u2019serrorrateyouapply\nour analysis above to determine an appropriate number of examples to set aside for the test\nset. Moreover, let\u2019s assume that you took the lessons from Section 3.6 to heart and made\nsure to preserve the sanctity of the test set by conducting all of your preliminary analysis,\nhyperparameter tuning, and even selection among multiple competing model architectures\nonavalidationset. Finallyyouevaluateyourmodel \ud835\udc531onthetestsetandreportanunbiased\nestimate of the population error with an associated confidence interval.\nSo far everything seems to be going well. However, that night you wake up at 3am with\na brilliant idea for a new modeling approach. The next day, you code up your new model,\ntune its hyperparameters on the validation set and not only are you getting your new model\n\ud835\udc532to work but its error rate appears to be much lower than \ud835\udc531\u2019s. However, the thrill of\ndiscovery suddenly fades as you prepare for the final evaluation. You do not have a test\nset!\nEventhoughtheoriginaltestset Disstillsittingonyourserver,younowfacetwoformidable\nproblems. First, when you collected your test set, you determined the required level of pre-\ncision under the assumption that you were evaluating a single classifier \ud835\udc53. However, if\nyou get into the business of evaluating multiple classifiers \ud835\udc531,..., \ud835\udc53\ud835\udc58on the same test set,\nyou must consider the problem of false discovery. Before, you might have been 95% sure\n151 Generalization in Classi\ufb01cation\nthat\ud835\udf16D\u00b9\ud835\udc53\u00ba2\ud835\udf16\u00b9\ud835\udc53\u00ba\u00060.01for a single classifier \ud835\udc53and thus the probability of a misleading\nresult was a mere 5%. With \ud835\udc58classifiers in the mix, it can be hard to guarantee that there\nis not even one among them whose test set performance is misleading. With 20 classifiers\nunder consideration, you might have no power at all to rule out the possibility that at least\none among them received a misleading score. This problem relates to multiple hypothesis\ntesting, which despite a vast literature in statistics, remains a persistent problem plaguing\nscientific research.\nIf that is not enough to worry you, there is a special reason to distrust the results that you\nget on subsequent evaluations. Recall that our analysis of test set performance rested on\nthe assumption that the classifier was chosen absent any contact with the test set and thus\nwe could view the test set as drawn randomly from the underlying population. Here, not\nonly are you testing multiple functions, the subsequent function \ud835\udc532was chosen after you\nobserved the test set performance of \ud835\udc531. Once information from the test set has leaked\nto the modeler, it can never be a true test set again in the strictest sense. This problem is\ncalledadaptiveoverfitting andhasrecentlyemergedasatopicofintenseinteresttolearning\ntheorists and statisticians ( Dworket al., 2015). Fortunately, while it is possible to leak all\ninformation out of a holdout set, and the theoretical worst case scenarios are bleak, these\nanalyses may be too conservative.", "mimetype": "text/plain", "start_char_idx": 395918, "end_char_idx": 400135, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dd1469cf-8d89-4c10-b5ac-fff709b77fa1": {"__data__": {"id_": "dd1469cf-8d89-4c10-b5ac-fff709b77fa1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2ca2f478-f27b-409f-a44e-c2c7e6bde926", "node_type": "1", "metadata": {}, "hash": "347b757b13e60edb9bee8cb4e4a9fc162e50cd00f32c9d93dee1f1049ca330c0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d4cc47cb-217c-4d71-ae5e-42f74e1fe281", "node_type": "1", "metadata": {}, "hash": "1d0c629420cc491a7054b9b280d14770dbf174efd012d34854dd7837ac603669", "class_name": "RelatedNodeInfo"}}, "text": "Recall that our analysis of test set performance rested on\nthe assumption that the classifier was chosen absent any contact with the test set and thus\nwe could view the test set as drawn randomly from the underlying population. Here, not\nonly are you testing multiple functions, the subsequent function \ud835\udc532was chosen after you\nobserved the test set performance of \ud835\udc531. Once information from the test set has leaked\nto the modeler, it can never be a true test set again in the strictest sense. This problem is\ncalledadaptiveoverfitting andhasrecentlyemergedasatopicofintenseinteresttolearning\ntheorists and statisticians ( Dworket al., 2015). Fortunately, while it is possible to leak all\ninformation out of a holdout set, and the theoretical worst case scenarios are bleak, these\nanalyses may be too conservative. In practice, take care to create real test sets, to consult\nthem as infrequently as possible, to account for multiple hypothesis testing when reporting\nconfidence intervals, and to dial up your vigilance more aggressively when the stakes are\nhigh and your dataset size is small. When running a series of benchmark challenges, it is\noftengoodpracticetomaintainseveraltestsetssothataftereachround, theoldtestsetcan\nbe demoted to a validation set.\n4.6.3Statistical Learning Theory\nPut simply, testsetsareallthatwereallyhave , and yet this fact seems strangely unsatisfy-\ning. First, we seldom possess a true test set \u2014unless we are the ones creating the dataset,\nsomeone else has probably already evaluated their own classifier on our ostensible \u201ctest\nset\u201d. And even when we have first dibs, we soon find ourselves frustrated, wishing we\ncould evaluate our subsequentmodeling attempts without the gnawing feeling that wecan-\nnot trust our numbers. Moreover, even a true test set can only tell us post hoc whether a\nclassifierhasinfactgeneralizedtothepopulation,notwhetherwehaveanyreasontoexpect\napriori that it should generalize.\nWith these misgivings in mind, you might now be sufficiently primed to see the appeal of\nstatistical learning theory , the mathematical subfield of machine learning whose practi-\ntioners aim to elucidate the fundamental principles that explain why/when models trained\non empirical data can/will generalize to unseen data. One of the primary aims of statistical\nlearningresearchershasbeentoboundthegeneralizationgap,relatingthepropertiesofthe\nmodel class to the number of samples in the dataset.\nLearning theorists aim to bound the difference between the empirical error \ud835\udf16S\u00b9\ud835\udc53S\u00baof a\nlearned classifier \ud835\udc53S, both trained and evaluated on the training set S, and the true error\n\ud835\udf16\u00b9\ud835\udc53S\u00baof that same classifier on the underlying population. This might look similar to\nthe evaluation problem that we just addressed but there is a major difference. Earlier, the\n152 Linear Neural Networks for Classi\ufb01cation\nclassifier\ud835\udc53was fixed and we only needed a dataset for evaluative purposes. And indeed,\nanyfixedclassifierdoesgeneralize: itserrorona(previouslyunseen)datasetisanunbiased\nestimate of the population error. But what can we say when a classifier is trained and\nevaluated on the same dataset? Can we ever be confident that the training error will be\nclose to the testing error?\nSuppose that our learned classifier \ud835\udc53Smust be chosen from some pre-specified set of func-\ntionsF. Recallfromourdiscussionoftestsetsthatwhileitiseasytoestimatetheerrorofa\nsingleclassifier, thingsgethairywhenwebegintoconsidercollectionsofclassifiers. Even\nif the empirical error of any one (fixed) classifier will be close to its true error with high\nprobability, once we consider a collection of classifiers, we need to worry about the possi-\nbility that justone of them will receive a badly estimated error. The worry is that we might\npick such a classifier and thereby grossly underestimate the population error. Moreover,\neven for linear models, because their parameters are continuously valued, we are typically\nchoosing from an infinite class of functions ( jFj=1).\nOne ambitious solution to the problem is to develop analytic tools for proving uniform\nconvergence, i.e., that with high probability, the empirical error rate for every classifier\nin the class \ud835\udc532 Fwillsimultaneously converge to its true error rate.", "mimetype": "text/plain", "start_char_idx": 399324, "end_char_idx": 403550, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d4cc47cb-217c-4d71-ae5e-42f74e1fe281": {"__data__": {"id_": "d4cc47cb-217c-4d71-ae5e-42f74e1fe281", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "dd1469cf-8d89-4c10-b5ac-fff709b77fa1", "node_type": "1", "metadata": {}, "hash": "d4fa128fae1c13dc6dde91ed2121193e3d8796ace5ad92f0fde32158bc4af9cd", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7d9a124d-5c1e-48c7-8698-5f2ddc4386a8", "node_type": "1", "metadata": {}, "hash": "da9e923afd42a2e6c37ca4b6de8072a69b8e119885a972873560533f650e7d0d", "class_name": "RelatedNodeInfo"}}, "text": "Even\nif the empirical error of any one (fixed) classifier will be close to its true error with high\nprobability, once we consider a collection of classifiers, we need to worry about the possi-\nbility that justone of them will receive a badly estimated error. The worry is that we might\npick such a classifier and thereby grossly underestimate the population error. Moreover,\neven for linear models, because their parameters are continuously valued, we are typically\nchoosing from an infinite class of functions ( jFj=1).\nOne ambitious solution to the problem is to develop analytic tools for proving uniform\nconvergence, i.e., that with high probability, the empirical error rate for every classifier\nin the class \ud835\udc532 Fwillsimultaneously converge to its true error rate. In other words,\nwe seek a theoretical principle that would allow us to state that with probability at least\n1\u0000\ud835\udeff(for some small \ud835\udeff) no classifier\u2019s error rate \ud835\udf16\u00b9\ud835\udc53\u00ba(among all classifiers in the class\nF) will be misestimated by more than some small amount \ud835\udefc. Clearly, we cannot make\nsuch statements for all model classes F. Recall the class of memorization machines that\nalways achieve empirical error 0but never outperform random guessing on the underlying\npopulation.\nIn a sense the class of memorizers is too flexible. No such a uniform convergence result\ncouldpossiblyhold. Ontheotherhand,afixedclassifierisuseless\u2014itgeneralizesperfectly,\nbut fits neither the training data nor the test data. The central question of learning has\nthus historically been framed as a trade-off between more flexible (higher variance) model\nclasses that better fit the training data but risk overfitting, versus more rigid (higher bias)\nmodel classes that generalize well but risk underfitting. A central question in learning\ntheoryhasbeentodeveloptheappropriatemathematicalanalysistoquantifywhereamodel\nsits along this spectrum, and to provide the associated guarantees.\nIn a series of seminal papers, Vapnik and Chervonenkis extended the theory on the con-\nvergence of relative frequencies to more general classes of functions ( Vapnik and Cher-\nvonenkis, 1964 ,Vapnik and Chervonenkis, 1968 ,Vapnik and Chervonenkis, 1971 ,Vap-\nnik and Chervonenkis, 1981 ,Vapnik and Chervonenkis, 1991 ,Vapnik and Chervonenkis,\n1974). One of the key contributions of this line of work is the Vapnik\u2013Chervonenkis (VC)\ndimension, which measures (one notion of) the complexity (flexibility) of a model class.\nMoreover, one of their key results bounds the difference between the empirical error and\nthe population error as a function of the VC dimension and the number of samples:\n\ud835\udc43\u0000\ud835\udc45\u00bb\ud835\udc5d, \ud835\udc53\u00bc\u0000\ud835\udc45emp\u00bbX,Y, \ud835\udc53\u00bc<\ud835\udefc\u0001\u00151\u0000\ud835\udefffor\ud835\udefc\u0015\ud835\udc50p\n\u00b9VC\u0000log\ud835\udeff\u00ba\u009d\ud835\udc5b. (4.6.4)\nHere\ud835\udeff > 0is the probability that the bound is violated, \ud835\udefcis the upper bound on the\ngeneralization gap, and \ud835\udc5bis the dataset size. Lastly, \ud835\udc50 > 0is a constant that depends only\n153 Generalization in Classi\ufb01cation\non the scale of the loss that can be incurred. One use of the bound might be to plug in\ndesired values of \ud835\udeffand\ud835\udefcto determine how many samples to collect. The VC dimension\nquantifies the largest number of data points for which we can assign any arbitrary (binary)\nlabeling and for each find some model \ud835\udc53in the class that agrees with that labeling. For\nexample, linear models on \ud835\udc51-dimensional inputs have VC dimension \ud835\udc51\u00b81. It is easy to\nsee that a line can assign any possible labeling to three points in two dimensions, but not\nto four. Unfortunately, the theory tends to be overly pessimistic for more complex models\nand obtaining this guarantee typically requires far more examples than are actually needed\nto achieve the desired error rate. Note also that fixing the model class and \ud835\udeff, our error rate\nagain decays with the usual O\u00b91\u009dp\ud835\udc5b\u00barate. It seems unlikely that we could do better in\nterms of\ud835\udc5b. However, as we vary the model class, VC dimension can present a pessimistic\npicture of the generalization gap.", "mimetype": "text/plain", "start_char_idx": 402781, "end_char_idx": 406672, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7d9a124d-5c1e-48c7-8698-5f2ddc4386a8": {"__data__": {"id_": "7d9a124d-5c1e-48c7-8698-5f2ddc4386a8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d4cc47cb-217c-4d71-ae5e-42f74e1fe281", "node_type": "1", "metadata": {}, "hash": "1d0c629420cc491a7054b9b280d14770dbf174efd012d34854dd7837ac603669", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5b36484a-ac86-4c34-8ee1-792a3e784c5c", "node_type": "1", "metadata": {}, "hash": "c892888855e4b4c7aba07a815ac0e483b480c34d12c8968072ba34d71e7721c2", "class_name": "RelatedNodeInfo"}}, "text": "For\nexample, linear models on \ud835\udc51-dimensional inputs have VC dimension \ud835\udc51\u00b81. It is easy to\nsee that a line can assign any possible labeling to three points in two dimensions, but not\nto four. Unfortunately, the theory tends to be overly pessimistic for more complex models\nand obtaining this guarantee typically requires far more examples than are actually needed\nto achieve the desired error rate. Note also that fixing the model class and \ud835\udeff, our error rate\nagain decays with the usual O\u00b91\u009dp\ud835\udc5b\u00barate. It seems unlikely that we could do better in\nterms of\ud835\udc5b. However, as we vary the model class, VC dimension can present a pessimistic\npicture of the generalization gap.\n4.6.4Summary\nThe most straightforward way to evaluate a model is to consult a test set comprised of pre-\nviously unseen data. Test set evaluations provide an unbiased estimate of the true error\nand converge at the desired O\u00b91\u009dp\ud835\udc5b\u00barate as the test set grows. We can provide approx-\nimate confidence intervals based on exact asymptotic distributions or valid finite sample\nconfidence intervals based on (more conservative) finite sample guarantees. Indeed test\nset evaluation is the bedrock of modern machine learning research. However, test sets are\nseldomtruetestsets(used bymultipleresearchersagainand again). Once thesametestset\nis used to evaluate multiple models, controlling for false discovery can be difficult. This\ncancause hugeproblemsin theory. In practice, the significanceof the problem dependson\nthe size of the holdout sets in question and whether they are merely being used to choose\nhyperparameters or if they are leaking information more directly. Nevertheless, it is good\npracticetocuraterealtestsets(ormultiple)andtobeasconservativeaspossibleabouthow\noften they are used.\nHoping to provide a more satisfying solution, statistical learning theorists have developed\nmethodsforguaranteeinguniformconvergenceoveramodelclass. Ifindeedeverymodel\u2019s\nempirical error simultaneously converges to its true error, then we are free to choose the\nmodel that performs best, minimizing the training error, knowing that it too will perform\nsimilarly well on the holdout data. Crucially, any one of such results must depend on some\npropertyofthemodelclass. VladimirVapnikandAlexeyChernovenkisintroducedtheVC\ndimension, presenting uniform convergence results that hold for all models in a VC class.\nThe training errors for all models in the class are (simultaneously) guaranteed to be close\nto their true errors, and guaranteed to grow even closer at O\u00b91\u009dp\ud835\udc5b\u00barates. Following the\nrevolutionarydiscoveryofVCdimension, numerousalternativecomplexitymeasureshave\nbeen proposed, each facilitating an analogous generalization guarantee. See Boucheron\net al.(2005) for a detailed discussion of several advanced ways of measuring function\ncomplexity. Unfortunately, while these complexity measures have become broadly useful\ntools in statistical theory, they turn out to be powerless (as straightforwardly applied) for\nexplainingwhydeepneuralnetworksgeneralize. Deepneuralnetworksoftenhavemillions\nof parameters (or more), and can easily assign random labels to large collections of points.\nNevertheless, they generalize well on practical problems and, surprisingly, they often gen-\n154 Linear Neural Networks for Classi\ufb01cation\n100eralizebetter, when theyare largerand deeper, despite incurring higherVCdimensions. In\nthe next chapter, we will revisit generalization in the context of deep learning.\n4.6.5Exercises\n1.If we wish to estimate the error of a fixed model \ud835\udc53to within 0.0001with probability\ngreater than 99.9%, how many samples do we need?\n2.Supposethatsomebodyelsepossessesalabeledtestset Dandonlymakesavailablethe\nunlabeled inputs (features). Now suppose that you can only access the test set labels by\nrunning a model \ud835\udc53(with no restrictions placed on the model class) on each of the un-\nlabeled inputs and receiving the corresponding error \ud835\udf16D\u00b9\ud835\udc53\u00ba. How many models would\nyou need to evaluate before you leak the entire test set and thus could appear to have\nerror 0, regardless of your true error?\n3.What is the VC dimension of the class of fifth-order polynomials?\n4.What is the VC dimension of axis-aligned rectangles on two-dimensional data?\nDiscussions100.\n4.7Environmentand Distribution Shift\nIntheprevioussections,weworkedthroughanumberofhands-onapplicationsofmachine\nlearning, fitting models to a variety of datasets.", "mimetype": "text/plain", "start_char_idx": 406009, "end_char_idx": 410398, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5b36484a-ac86-4c34-8ee1-792a3e784c5c": {"__data__": {"id_": "5b36484a-ac86-4c34-8ee1-792a3e784c5c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7d9a124d-5c1e-48c7-8698-5f2ddc4386a8", "node_type": "1", "metadata": {}, "hash": "da9e923afd42a2e6c37ca4b6de8072a69b8e119885a972873560533f650e7d0d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "91e1ea5b-a0ea-49bc-b9e7-5ff96fe451a4", "node_type": "1", "metadata": {}, "hash": "d24b9426c3667c7ef8915fa19a540e886bde28fdf68a7fafda3f026c82b8d4f7", "class_name": "RelatedNodeInfo"}}, "text": "2.Supposethatsomebodyelsepossessesalabeledtestset Dandonlymakesavailablethe\nunlabeled inputs (features). Now suppose that you can only access the test set labels by\nrunning a model \ud835\udc53(with no restrictions placed on the model class) on each of the un-\nlabeled inputs and receiving the corresponding error \ud835\udf16D\u00b9\ud835\udc53\u00ba. How many models would\nyou need to evaluate before you leak the entire test set and thus could appear to have\nerror 0, regardless of your true error?\n3.What is the VC dimension of the class of fifth-order polynomials?\n4.What is the VC dimension of axis-aligned rectangles on two-dimensional data?\nDiscussions100.\n4.7Environmentand Distribution Shift\nIntheprevioussections,weworkedthroughanumberofhands-onapplicationsofmachine\nlearning, fitting models to a variety of datasets. And yet, we never stopped to contemplate\neither where data came from in the first place or what we ultimately plan to do with the\noutputs from our models. Too often, machine learning developers in possession of data\nrush to develop models without pausing to consider these fundamental issues.\nMany failed machine learning deployments can be traced back to this failure. Sometimes\nmodelsappeartoperformmarvelouslyasmeasuredbytestsetaccuracybutfailcatastroph-\nicallyindeploymentwhenthedistributionofdatasuddenlyshifts. Moreinsidiously,some-\ntimestheverydeploymentofamodelcanbethecatalystthatperturbsthedatadistribution.\nSay, for example, that we trained a model to predict who will repay rather than default on a\nloan, finding that an applicant\u2019s choice of footwear was associated with the risk of default\n(Oxfords indicate repayment, sneakers indicate default). We might be inclined thereafter\nto grant a loan to any applicant wearing Oxfords and to deny all applicants wearing sneak-\ners.\nIn this case, our ill-considered leap from pattern recognition to decision-making and our\nfailure to critically consider the environment might have disastrous consequences. For\nstarters, as soon as we began making decisions based on footwear, customers would catch\non and change their behavior. Before long, all applicants would be wearing Oxfords, with-\nout any coincident improvement in credit-worthiness. Take a minute to digest this because\n155 Environment and Distribution Shift\nsimilarissuesaboundinmanyapplicationsofmachinelearning: byintroducingourmodel-\nbased decisions to the environment, we might break the model.\nWhilewecannotpossiblygivethesetopicsacompletetreatmentinonesection,weaimhere\nto expose some common concerns, and to stimulate the critical thinking required to detect\nsuch situations early, mitigate damage, and use machine learning responsibly. Some of the\nsolutions are simple (ask for the \u201cright\u201d data), some are technically difficult (implement a\nreinforcement learning system), and others require that we step outside the realm of sta-\ntistical prediction altogether and grapple with difficult philosophical questions concerning\nthe ethical application of algorithms.\n4.7.1Typesof Distribution Shift\nTobegin,westickwiththepassivepredictionsettingconsideringthevariouswaysthatdata\ndistributionsmightshiftandwhatmightbedonetosalvagemodelperformance. Inoneclas-\nsic setup, we assume that our training data was sampled from some distribution \ud835\udc5d\ud835\udc46\u00b9x,\ud835\udc66\u00ba\nbut that our test data will consist of unlabeled examples drawn from some different distri-\nbution\ud835\udc5d\ud835\udc47\u00b9x,\ud835\udc66\u00ba. Already, we must confront a sobering reality. Absent any assumptions on\nhow\ud835\udc5d\ud835\udc46and\ud835\udc5d\ud835\udc47relate to each other, learning a robust classifier is impossible.\nConsider a binary classification problem, where we wish to distinguish between dogs and\ncats. If the distribution can shift in arbitrary ways, then our setup permits the pathological\ncase in which the distribution over inputs remains constant: \ud835\udc5d\ud835\udc46\u00b9x\u00ba=\ud835\udc5d\ud835\udc47\u00b9x\u00ba, but the labels\nare all flipped: \ud835\udc5d\ud835\udc46\u00b9\ud835\udc66jx\u00ba=1\u0000\ud835\udc5d\ud835\udc47\u00b9\ud835\udc66jx\u00ba. In other words, if God can suddenly decide that\nin the future all \u201ccats\u201d are now dogs and what we previously called \u201cdogs\u201d are now cats\u2014\nwithout any change in the distribution of inputs \ud835\udc5d\u00b9x\u00ba, then we cannot possibly distinguish\nthis setting from one in which the distribution did not change at all.", "mimetype": "text/plain", "start_char_idx": 409613, "end_char_idx": 413724, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "91e1ea5b-a0ea-49bc-b9e7-5ff96fe451a4": {"__data__": {"id_": "91e1ea5b-a0ea-49bc-b9e7-5ff96fe451a4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5b36484a-ac86-4c34-8ee1-792a3e784c5c", "node_type": "1", "metadata": {}, "hash": "c892888855e4b4c7aba07a815ac0e483b480c34d12c8968072ba34d71e7721c2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "65d007b3-7b80-4d05-9983-e4ed6e9431dd", "node_type": "1", "metadata": {}, "hash": "62c6e8e832b3c5025cd3a86ed5011cb4911d939374c3a4c4af9e594a4da2072d", "class_name": "RelatedNodeInfo"}}, "text": "Consider a binary classification problem, where we wish to distinguish between dogs and\ncats. If the distribution can shift in arbitrary ways, then our setup permits the pathological\ncase in which the distribution over inputs remains constant: \ud835\udc5d\ud835\udc46\u00b9x\u00ba=\ud835\udc5d\ud835\udc47\u00b9x\u00ba, but the labels\nare all flipped: \ud835\udc5d\ud835\udc46\u00b9\ud835\udc66jx\u00ba=1\u0000\ud835\udc5d\ud835\udc47\u00b9\ud835\udc66jx\u00ba. In other words, if God can suddenly decide that\nin the future all \u201ccats\u201d are now dogs and what we previously called \u201cdogs\u201d are now cats\u2014\nwithout any change in the distribution of inputs \ud835\udc5d\u00b9x\u00ba, then we cannot possibly distinguish\nthis setting from one in which the distribution did not change at all.\nFortunately,undersomerestrictedassumptionsonthewaysourdatamightchangeinthefu-\nture, principledalgorithmscandetectshiftandsometimesevenadaptonthefly, improving\non the accuracy of the original classifier.\nCovariateShift\nAmong categories of distribution shift, covariate shift may be the most widely studied.\nHere, we assume that while the distribution of inputs may change over time, the labeling\nfunction, i.e., the conditional distribution \ud835\udc43\u00b9\ud835\udc66jx\u00badoes not change. Statisticians call this\ncovariate shift because the problem arises due to a shift in the distribution of the covari-\nates (features). While we can sometimes reason about distribution shift without invoking\ncausality, we note that covariate shift is the natural assumption to invoke in settings where\nwe believe that xcauses\ud835\udc66.\nConsider the challenge of distinguishing cats and dogs. Our training data might consist of\nimages of the kind in Fig. 4.7.1 .\nAt test time we are asked to classify the images in Fig. 4.7.2 .\nThe training set consists of photos, while the test set contains only cartoons. Training on a\n156 Linear Neural Networks for Classi\ufb01cation\ntFig. 4.7.1 Training data for distinguishing cats and dogs (illustrations: Lafeez Hossain / 500px /\nGetty Images; ilkermetinkursova / iStock / Getty Images Plus; GlobalP / iStock / Getty\nImages Plus; Musthafa Aboobakuru / 500px / Getty Images).\ntFig. 4.7.2 Test data for distinguishing cats and dogs (illustrations: SIBAS_minich / iStock / Getty\nImages Plus; Ghrzuzudu / iStock / Getty Images Plus; id-work / DigitalVision Vectors /\nGetty Images; Yime / iStock / Getty Images Plus).\ndataset with substantially different characteristics from the test set can spell trouble absent\na coherent plan for how to adapt to the new domain.\nLabel Shift\nLabel shift describes the converse problem. Here, we assume that the label marginal \ud835\udc43\u00b9\ud835\udc66\u00ba\ncan change but the class-conditional distribution \ud835\udc43\u00b9xj\ud835\udc66\u00baremains fixed across domains.\nLabel shift is a reasonable assumption to make when we believe that \ud835\udc66causes x. For ex-\nample, we may want to predict diagnoses given their symptoms (or other manifestations),\neven as the relative prevalence of diagnoses are changing over time. Label shift is the ap-\npropriateassumptionherebecausediseasescausesymptoms. Insomedegeneratecasesthe\nlabelshiftandcovariateshiftassumptionscanholdsimultaneously. Forexample,whenthe\nlabel is deterministic, the covariate shift assumption will be satisfied, even when \ud835\udc66causes\nx. Interestingly, in these cases, it is often advantageous to work with methods that flow\nfrom the label shift assumption. That is because these methods tend to involve manipulat-\ning objects that look like labels (often low-dimensional), as opposed to objects that look\nlike inputs, which tend to be high-dimensional in deep learning.\n157 Environment and Distribution Shift\nConceptShift\nWe may also encounter the related problem of concept shift , which arises when the very\ndefinitions of labels can change. This sounds weird\u2014a catis acat, no? However, other\ncategories are subject to changes in usage over time. Diagnostic criteria for mental illness,\nwhat passes for fashionable, and job titles, are all subject to considerable amounts of con-\ncept shift. It turns out that if we navigate around the United States, shifting the source of\nour data by geography, wewill find considerable concept shift regardingthe distribution of\nnames for soft drinks as shown in Fig. 4.7.3 .\ntFig.", "mimetype": "text/plain", "start_char_idx": 413118, "end_char_idx": 417164, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "65d007b3-7b80-4d05-9983-e4ed6e9431dd": {"__data__": {"id_": "65d007b3-7b80-4d05-9983-e4ed6e9431dd", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "91e1ea5b-a0ea-49bc-b9e7-5ff96fe451a4", "node_type": "1", "metadata": {}, "hash": "d24b9426c3667c7ef8915fa19a540e886bde28fdf68a7fafda3f026c82b8d4f7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a557c721-a73a-40a0-9599-4e5ae44f26f9", "node_type": "1", "metadata": {}, "hash": "bfa83bc6a69c886932989a6f4b6d94907865e633226d7b400cae55fe5036f8c5", "class_name": "RelatedNodeInfo"}}, "text": "That is because these methods tend to involve manipulat-\ning objects that look like labels (often low-dimensional), as opposed to objects that look\nlike inputs, which tend to be high-dimensional in deep learning.\n157 Environment and Distribution Shift\nConceptShift\nWe may also encounter the related problem of concept shift , which arises when the very\ndefinitions of labels can change. This sounds weird\u2014a catis acat, no? However, other\ncategories are subject to changes in usage over time. Diagnostic criteria for mental illness,\nwhat passes for fashionable, and job titles, are all subject to considerable amounts of con-\ncept shift. It turns out that if we navigate around the United States, shifting the source of\nour data by geography, wewill find considerable concept shift regardingthe distribution of\nnames for soft drinks as shown in Fig. 4.7.3 .\ntFig. 4.7.3 Concept shift for soft drink names in the United States (CC-BY: Alan McConchie,\nPopVsSoda.com).\nIf we were to build a machine translation system, the distribution \ud835\udc43\u00b9\ud835\udc66jx\u00bamight be dif-\nferent depending on our location. This problem can be tricky to spot. We might hope to\nexploit knowledge that shift only takes place gradually either in a temporal or geographic\nsense.\n4.7.2Examplesof Distribution Shift\nBefore delving into formalism and algorithms, we can discuss some concrete situations\nwhere covariate or concept shift might not be obvious.\nMedical Diagnostics\nImaginethatyouwanttodesignanalgorithmtodetectcancer. Youcollectdatafromhealthy\nand sick people and you train your algorithm. It works fine, giving you high accuracy and\nyou conclude that you are ready for a successful career in medical diagnostics. Not so\nfast.\nThedistributionsthatgaverisetothetrainingdataandthoseyouwillencounterinthewild\n158 Linear Neural Networks for Classi\ufb01cation\nmightdifferconsiderably. Thishappenedtoanunfortunatestartupthatsomeofweauthors\nworked with years ago. They were developing a blood test for a disease that predominantly\naffects older men and hoped to study it using blood samples that they had collected from\npatients. However, it is considerably more difficult to obtain blood samples from healthy\nmen than from sick patients already in the system. To compensate, the startup solicited\nblood donations from students on a university campus to serve as healthy controls in de-\nveloping their test. Then they asked whether we could help them to build a classifier for\ndetecting the disease.\nAs we explained to them, it would indeed be easy to distinguish between the healthy and\nsick cohorts with near-perfect accuracy. However, that is because the test subjects differed\nin age, hormone levels, physical activity, diet, alcohol consumption, and many more fac-\ntors unrelated to the disease. This was unlikely to be the case with real patients. Due to\ntheir sampling procedure, we could expect to encounter extreme covariate shift. Moreover,\nthis case was unlikely to be correctable via conventional methods. In short, they wasted a\nsignificant sum of money.\nSelf-Driving Cars\nSay a company wanted to leverage machine learning for developing self-driving cars. One\nkey component here is a roadside detector. Since real annotated data is expensive to get,\nthey had the (smart and questionable) idea to use synthetic data from a game rendering\nengine as additional training data. This worked really well on \u201ctest data\u201d drawn from the\nrenderingengine. Alas, insidearealcaritwasadisaster. Asitturnedout, theroadsidehad\nbeen rendered with a very simplistic texture. More importantly, allthe roadside had been\nrendered with the sametexture and the roadside detector learned about this \u201cfeature\u201d very\nquickly.\nA similar thing happened to the US Army when they first tried to detect tanks in the forest.\nTheytookaerialphotographsoftheforestwithouttanks,thendrovethetanksintotheforest\nandtookanothersetofpictures. Theclassifierappearedtowork perfectly . Unfortunately,it\nhadmerelylearnedhowtodistinguishtreeswithshadowsfromtreeswithoutshadows\u2014the\nfirst set of pictures was taken in the early morning, the second set at noon.\nNonstationary Distributions\nA much more subtle situation arises when the distribution changes slowly (also known\nasnonstationary distribution ) and the model is not updated adequately. Below are some\ntypical cases.\n\u000fWetrainacomputationaladvertisingmodelandthenfailtoupdateitfrequently(e.g.,we\nforget to incorporate that an obscure new device called an iPad was just launched).\n\u000fWe build a spam filter.", "mimetype": "text/plain", "start_char_idx": 416302, "end_char_idx": 420785, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a557c721-a73a-40a0-9599-4e5ae44f26f9": {"__data__": {"id_": "a557c721-a73a-40a0-9599-4e5ae44f26f9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "65d007b3-7b80-4d05-9983-e4ed6e9431dd", "node_type": "1", "metadata": {}, "hash": "62c6e8e832b3c5025cd3a86ed5011cb4911d939374c3a4c4af9e594a4da2072d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "47eb288e-8199-4459-b13e-07115c044be8", "node_type": "1", "metadata": {}, "hash": "314d89929de012bd0519962964f32c44f2ee029ba9e3efd8b78b34ca45ccf018", "class_name": "RelatedNodeInfo"}}, "text": "A similar thing happened to the US Army when they first tried to detect tanks in the forest.\nTheytookaerialphotographsoftheforestwithouttanks,thendrovethetanksintotheforest\nandtookanothersetofpictures. Theclassifierappearedtowork perfectly . Unfortunately,it\nhadmerelylearnedhowtodistinguishtreeswithshadowsfromtreeswithoutshadows\u2014the\nfirst set of pictures was taken in the early morning, the second set at noon.\nNonstationary Distributions\nA much more subtle situation arises when the distribution changes slowly (also known\nasnonstationary distribution ) and the model is not updated adequately. Below are some\ntypical cases.\n\u000fWetrainacomputationaladvertisingmodelandthenfailtoupdateitfrequently(e.g.,we\nforget to incorporate that an obscure new device called an iPad was just launched).\n\u000fWe build a spam filter. It works well at detecting all spam that we have seen so far. But\nthen the spammers wise up and craft new messages that look unlike anything we have\nseen before.\n159 Environment and Distribution Shift\n\u000fWe build a product recommendation system. It works throughout the winter but then\ncontinues to recommend Santa hats long after Christmas.\nMoreAnecdotes\n\u000fWe build a face detector. It works well on all benchmarks. Unfortunately it fails on test\ndata\u2014the offending examples are close-ups where the face fills the entire image (no\nsuch data was in the training set).\n\u000fWe build a web search engine for the US market and want to deploy it in the UK.\n\u000fWe train an image classifier by compiling a large dataset where each among a large set\nof classes is equally represented in the dataset, say 1000 categories, represented by\n1000 images each. Then we deploy the system in the real world, where the actual\nlabel distribution of photographs is decidedly non-uniform.\n4.7.3Correctionof Distribution Shift\nAs we have discussed, there are many cases where training and test distributions \ud835\udc43\u00b9x,\ud835\udc66\u00ba\nare different. In some cases, we get lucky and the models work despite covariate, label,\nor concept shift. In other cases, we can do better by employing principled strategies to\ncope with the shift. The remainder of this section grows considerably more technical. The\nimpatient reader could continue on to the next section as this material is not prerequisite to\nsubsequent concepts.\nEmpiricalRisk and Risk\nLet\u2019s first reflect on what exactly is happening during model training: we iterate over fea-\ntures and associated labels of training data f\u00b9x1,\ud835\udc661\u00ba,...,\u00b9x\ud835\udc5b,\ud835\udc66\ud835\udc5b\u00bagand update the param-\neters of a model \ud835\udc53after every minibatch. For simplicity we do not consider regularization,\nso we largely minimize the loss on the training:\nminimize\n\ud835\udc531\n\ud835\udc5b\ud835\udc5b\u00d5\n\ud835\udc56=1\ud835\udc59\u00b9\ud835\udc53\u00b9x\ud835\udc56\u00ba,\ud835\udc66\ud835\udc56\u00ba, (4.7.1)\nwhere\ud835\udc59is the loss function measuring \u201chow bad\u201d the prediction \ud835\udc53\u00b9x\ud835\udc56\u00bais given the associ-\nated label\ud835\udc66\ud835\udc56. Statisticians call the term in (4.7.1 )empirical risk . Theempirical risk is an\naverage loss over the training data for approximating the risk, which is the expectation of\nthelossovertheentirepopulationofdatadrawnfromtheirtruedistribution \ud835\udc5d\u00b9x,\ud835\udc66\u00ba:\n\ud835\udc38\ud835\udc5d\u00b9x,\ud835\udc66\u00ba\u00bb\ud835\udc59\u00b9\ud835\udc53\u00b9x\u00ba,\ud835\udc66\u00ba\u00bc=\u00b9 \u00b9\n\ud835\udc59\u00b9\ud835\udc53\u00b9x\u00ba,\ud835\udc66\u00ba\ud835\udc5d\u00b9x,\ud835\udc66\u00ba\ud835\udc51x\ud835\udc51\ud835\udc66. (4.7.2)\nHowever, in practice we typically cannot obtain the entire population of data. Thus, em-\npirical risk minimization , which is minimizing the empirical risk in (4.7.1 ), is a practical\nstrategy for machine learning, with the hope of approximately minimizing the risk.\n160 Linear Neural Networks for Classi\ufb01cation\nCovariateShift Correction\nAssumethatwewanttoestimatesomedependency \ud835\udc43\u00b9\ud835\udc66jx\u00baforwhichwehavelabeleddata\n\u00b9x\ud835\udc56,\ud835\udc66\ud835\udc56\u00ba. Unfortunately, the observations x\ud835\udc56are drawn from some sourcedistribution \ud835\udc5e\u00b9x\u00ba\nrather than the target distribution \ud835\udc5d\u00b9x\u00ba.", "mimetype": "text/plain", "start_char_idx": 419971, "end_char_idx": 423579, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "47eb288e-8199-4459-b13e-07115c044be8": {"__data__": {"id_": "47eb288e-8199-4459-b13e-07115c044be8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a557c721-a73a-40a0-9599-4e5ae44f26f9", "node_type": "1", "metadata": {}, "hash": "bfa83bc6a69c886932989a6f4b6d94907865e633226d7b400cae55fe5036f8c5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9603a88f-476c-4920-81d6-3a884142cd88", "node_type": "1", "metadata": {}, "hash": "63cc6e77a1a753240e2165599f0014ee73b49598264d09e5302a8815f0929c26", "class_name": "RelatedNodeInfo"}}, "text": "(4.7.2)\nHowever, in practice we typically cannot obtain the entire population of data. Thus, em-\npirical risk minimization , which is minimizing the empirical risk in (4.7.1 ), is a practical\nstrategy for machine learning, with the hope of approximately minimizing the risk.\n160 Linear Neural Networks for Classi\ufb01cation\nCovariateShift Correction\nAssumethatwewanttoestimatesomedependency \ud835\udc43\u00b9\ud835\udc66jx\u00baforwhichwehavelabeleddata\n\u00b9x\ud835\udc56,\ud835\udc66\ud835\udc56\u00ba. Unfortunately, the observations x\ud835\udc56are drawn from some sourcedistribution \ud835\udc5e\u00b9x\u00ba\nrather than the target distribution \ud835\udc5d\u00b9x\u00ba. Fortunately, the dependency assumption means\nthat the conditional distribution does not change: \ud835\udc5d\u00b9\ud835\udc66jx\u00ba=\ud835\udc5e\u00b9\ud835\udc66jx\u00ba. If the source\ndistribution\ud835\udc5e\u00b9x\u00bais\u201cwrong\u201d, wecan correct forthatbyusing thefollowingsimple identity\nin the risk:\n\u00b9 \u00b9\n\ud835\udc59\u00b9\ud835\udc53\u00b9x\u00ba,\ud835\udc66\u00ba\ud835\udc5d\u00b9\ud835\udc66jx\u00ba\ud835\udc5d\u00b9x\u00ba\ud835\udc51x\ud835\udc51\ud835\udc66=\u00b9 \u00b9\n\ud835\udc59\u00b9\ud835\udc53\u00b9x\u00ba,\ud835\udc66\u00ba\ud835\udc5e\u00b9\ud835\udc66jx\u00ba\ud835\udc5e\u00b9x\u00ba\ud835\udc5d\u00b9x\u00ba\n\ud835\udc5e\u00b9x\u00ba\ud835\udc51x\ud835\udc51\ud835\udc66.\n(4.7.3)\nIn other words, we need to reweigh each data example by the ratio of the probability that it\nwould have been drawn from the correct distribution to that from the wrong one:\n\ud835\udefd\ud835\udc56def=\ud835\udc5d\u00b9x\ud835\udc56\u00ba\n\ud835\udc5e\u00b9x\ud835\udc56\u00ba. (4.7.4)\nPlugging in the weight \ud835\udefd\ud835\udc56for each data example \u00b9x\ud835\udc56,\ud835\udc66\ud835\udc56\u00bawe can train our model using\nweightedempirical risk minimization :\nminimize\n\ud835\udc531\n\ud835\udc5b\ud835\udc5b\u00d5\n\ud835\udc56=1\ud835\udefd\ud835\udc56\ud835\udc59\u00b9\ud835\udc53\u00b9x\ud835\udc56\u00ba,\ud835\udc66\ud835\udc56\u00ba. (4.7.5)\nAlas, we do not know that ratio, so before we can do anything useful we need to estimate\nit. Many methods are available, including some fancy operator-theoretic approaches that\nattempt to recalibrate the expectation operator directly using a minimum-norm or a maxi-\nmumentropyprinciple. Notethatforanysuchapproach,weneedsamplesdrawnfromboth\ndistributions\u2014the \u201ctrue\u201d \ud835\udc5d, e.g., by access to test data, and the one used for generating the\ntraining set\ud835\udc5e(the latter is trivially available). Note however, that we only need features\nx\u0018\ud835\udc5d\u00b9x\u00ba; we do not need to access labels \ud835\udc66\u0018\ud835\udc5d\u00b9\ud835\udc66\u00ba.\nIn this case, there exists a very effective approach that will give almost as good results\nas the original: namely, logistic regression, which is a special case of softmax regression\n(seeSection 4.1 ) for binary classification. This is all that is needed to compute estimated\nprobability ratios. We learn a classifier to distinguish between data drawn from \ud835\udc5d\u00b9x\u00baand\ndata drawn from \ud835\udc5e\u00b9x\u00ba. If it is impossible to distinguish between the two distributions then\nit means that the associated instances are equally likely to come from either one of those\ntwo distributions. On the other hand, any instances that can be well discriminated should\nbe significantly overweighted or underweighted accordingly.\nForsimplicity\u2019ssakeassumethatwehaveanequalnumberofinstancesfrombothdistribu-\ntions\ud835\udc5d\u00b9x\u00baand\ud835\udc5e\u00b9x\u00ba, respectively. Now denote by \ud835\udc67labels that are 1for data drawn from \ud835\udc5d\nand\u00001for data drawn from \ud835\udc5e. Then the probability in a mixed dataset is given by\n\ud835\udc43\u00b9\ud835\udc67=1jx\u00ba=\ud835\udc5d\u00b9x\u00ba\n\ud835\udc5d\u00b9x\u00ba\u00b8\ud835\udc5e\u00b9x\u00baand hence\ud835\udc43\u00b9\ud835\udc67=1jx\u00ba\n\ud835\udc43\u00b9\ud835\udc67=\u00001jx\u00ba=\ud835\udc5d\u00b9x\u00ba\n\ud835\udc5e\u00b9x\u00ba.", "mimetype": "text/plain", "start_char_idx": 423032, "end_char_idx": 425815, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9603a88f-476c-4920-81d6-3a884142cd88": {"__data__": {"id_": "9603a88f-476c-4920-81d6-3a884142cd88", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "47eb288e-8199-4459-b13e-07115c044be8", "node_type": "1", "metadata": {}, "hash": "314d89929de012bd0519962964f32c44f2ee029ba9e3efd8b78b34ca45ccf018", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c01c977f-bd47-4ca6-a32a-f3eb3b608a7d", "node_type": "1", "metadata": {}, "hash": "04cf76486f651ac4b96e88a804ed32c46eeae18b8bfcf447cba0752d8edd453d", "class_name": "RelatedNodeInfo"}}, "text": "On the other hand, any instances that can be well discriminated should\nbe significantly overweighted or underweighted accordingly.\nForsimplicity\u2019ssakeassumethatwehaveanequalnumberofinstancesfrombothdistribu-\ntions\ud835\udc5d\u00b9x\u00baand\ud835\udc5e\u00b9x\u00ba, respectively. Now denote by \ud835\udc67labels that are 1for data drawn from \ud835\udc5d\nand\u00001for data drawn from \ud835\udc5e. Then the probability in a mixed dataset is given by\n\ud835\udc43\u00b9\ud835\udc67=1jx\u00ba=\ud835\udc5d\u00b9x\u00ba\n\ud835\udc5d\u00b9x\u00ba\u00b8\ud835\udc5e\u00b9x\u00baand hence\ud835\udc43\u00b9\ud835\udc67=1jx\u00ba\n\ud835\udc43\u00b9\ud835\udc67=\u00001jx\u00ba=\ud835\udc5d\u00b9x\u00ba\n\ud835\udc5e\u00b9x\u00ba. (4.7.6)\nThus, if we use a logistic regression approach, where \ud835\udc43\u00b9\ud835\udc67=1jx\u00ba=1\n1\u00b8exp\u00b9\u0000\u210e\u00b9x\u00ba\u00ba(\u210eis a\n161 Environment and Distribution Shift\nparametrized function), it follows that\n\ud835\udefd\ud835\udc56=1\u009d\u00b91\u00b8exp\u00b9\u0000\u210e\u00b9x\ud835\udc56\u00ba\u00ba\u00ba\nexp\u00b9\u0000\u210e\u00b9x\ud835\udc56\u00ba\u00ba\u009d\u00b91\u00b8exp\u00b9\u0000\u210e\u00b9x\ud835\udc56\u00ba\u00ba\u00ba=exp\u00b9\u210e\u00b9x\ud835\udc56\u00ba\u00ba. (4.7.7)\nAs a result, we need to solve two problems: the first, to distinguish between data drawn\nfrombothdistributions,andthenaweightedempiricalriskminimizationproblemin (4.7.5 )\nwhere we weigh terms by \ud835\udefd\ud835\udc56.\nNow we are ready to describe a correction algorithm. Suppose that we have a training set\nf\u00b9x1,\ud835\udc661\u00ba,...,\u00b9x\ud835\udc5b,\ud835\udc66\ud835\udc5b\u00bagand an unlabeled test set fu1,...,u\ud835\udc5ag. For covariate shift, we\nassume that x\ud835\udc56for all 1\u0014\ud835\udc56\u0014\ud835\udc5bare drawn from some source distribution and u\ud835\udc56for all\n1\u0014\ud835\udc56\u0014\ud835\udc5aare drawn from the target distribution. Here is a prototypical algorithm for\ncorrecting covariate shift:\n1.Createabinary-classificationtrainingset: f\u00b9x1,\u00001\u00ba,...,\u00b9x\ud835\udc5b,\u00001\u00ba,\u00b9u1,1\u00ba,...,\u00b9u\ud835\udc5a,1\u00bag.\n2.Train a binary classifier using logistic regression to get the function \u210e.\n3.Weigh training data using \ud835\udefd\ud835\udc56=exp\u00b9\u210e\u00b9x\ud835\udc56\u00ba\u00baor better\ud835\udefd\ud835\udc56=min\u00b9exp\u00b9\u210e\u00b9x\ud835\udc56\u00ba\u00ba,\ud835\udc50\u00bafor some\nconstant\ud835\udc50.\n4.Use weights \ud835\udefd\ud835\udc56for training onf\u00b9x1,\ud835\udc661\u00ba,...,\u00b9x\ud835\udc5b,\ud835\udc66\ud835\udc5b\u00bagin(4.7.5 ).\nNote that the above algorithm relies on a crucial assumption. For this scheme to work, we\nneed that each data example in the target (e.g., test time) distribution had nonzero proba-\nbility of occurring at training time. If we find a point where \ud835\udc5d\u00b9x\u00ba>0but\ud835\udc5e\u00b9x\u00ba=0, then\nthe corresponding importance weight should be infinity.\nLabelShift Correction\nAssume that we are dealing with a classification task with \ud835\udc58categories. Using the same\nnotation in Section 4.7.3 ,\ud835\udc5eand\ud835\udc5dare the source distribution (e.g., training time) and target\ndistribution (e.g., test time), respectively. Assume that the distribution of labels shifts over\ntime:\ud835\udc5e\u00b9\ud835\udc66\u00ba\u2260\ud835\udc5d\u00b9\ud835\udc66\u00ba, but the class-conditional distribution stays the same: \ud835\udc5e\u00b9xj\ud835\udc66\u00ba=\ud835\udc5d\u00b9xj\n\ud835\udc66\u00ba.", "mimetype": "text/plain", "start_char_idx": 425380, "end_char_idx": 427642, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c01c977f-bd47-4ca6-a32a-f3eb3b608a7d": {"__data__": {"id_": "c01c977f-bd47-4ca6-a32a-f3eb3b608a7d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9603a88f-476c-4920-81d6-3a884142cd88", "node_type": "1", "metadata": {}, "hash": "63cc6e77a1a753240e2165599f0014ee73b49598264d09e5302a8815f0929c26", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e76e09cd-e8e0-404a-b37b-3af88b692632", "node_type": "1", "metadata": {}, "hash": "dfe1a20fb2d132fc7c1b51d30fcc2e9a992e3a0a672ed1ed69207486e9cae13c", "class_name": "RelatedNodeInfo"}}, "text": "If we find a point where \ud835\udc5d\u00b9x\u00ba>0but\ud835\udc5e\u00b9x\u00ba=0, then\nthe corresponding importance weight should be infinity.\nLabelShift Correction\nAssume that we are dealing with a classification task with \ud835\udc58categories. Using the same\nnotation in Section 4.7.3 ,\ud835\udc5eand\ud835\udc5dare the source distribution (e.g., training time) and target\ndistribution (e.g., test time), respectively. Assume that the distribution of labels shifts over\ntime:\ud835\udc5e\u00b9\ud835\udc66\u00ba\u2260\ud835\udc5d\u00b9\ud835\udc66\u00ba, but the class-conditional distribution stays the same: \ud835\udc5e\u00b9xj\ud835\udc66\u00ba=\ud835\udc5d\u00b9xj\n\ud835\udc66\u00ba. If the source distribution \ud835\udc5e\u00b9\ud835\udc66\u00bais \u201cwrong\u201d, we can correct for that according to the\nfollowing identity in the risk as defined in (4.7.2 ):\n\u00b9 \u00b9\n\ud835\udc59\u00b9\ud835\udc53\u00b9x\u00ba,\ud835\udc66\u00ba\ud835\udc5d\u00b9xj\ud835\udc66\u00ba\ud835\udc5d\u00b9\ud835\udc66\u00ba\ud835\udc51x\ud835\udc51\ud835\udc66=\u00b9 \u00b9\n\ud835\udc59\u00b9\ud835\udc53\u00b9x\u00ba,\ud835\udc66\u00ba\ud835\udc5e\u00b9xj\ud835\udc66\u00ba\ud835\udc5e\u00b9\ud835\udc66\u00ba\ud835\udc5d\u00b9\ud835\udc66\u00ba\n\ud835\udc5e\u00b9\ud835\udc66\u00ba\ud835\udc51x\ud835\udc51\ud835\udc66.\n(4.7.8)\nHere, our importance weights will correspond to the label likelihood ratios:\n\ud835\udefd\ud835\udc56def=\ud835\udc5d\u00b9\ud835\udc66\ud835\udc56\u00ba\n\ud835\udc5e\u00b9\ud835\udc66\ud835\udc56\u00ba. (4.7.9)\nOne nice thing about label shift is that if we have a reasonably good model on the source\ndistribution, then we can get consistent estimates of these weights without ever having to\ndeal with the ambient dimension. In deep learning, the inputs tend to be high-dimensional\nobjects like images, while the labels are often simpler objects like categories.\nTo estimate the target label distribution, we first take our reasonably good off-the-shelf\n162 Linear Neural Networks for Classi\ufb01cation\nclassifier (typically trained on the training data) and compute its \u201cconfusion\u201d matrix using\nthevalidationset(alsofromthetrainingdistribution). The confusionmatrix ,C,issimplya\n\ud835\udc58\u0002\ud835\udc58matrix, whereeachcolumncorrespondstothelabelcategory(groundtruth)andeach\nrow corresponds to our model\u2019s predicted category. Each cell\u2019s value \ud835\udc50\ud835\udc56\ud835\udc57is the fraction of\ntotal predictions on the validation set where the true label was \ud835\udc57and our model predicted\n\ud835\udc56.\nNow, we cannot calculate the confusion matrix on the target data directly because we do\nnot get to see the labels for the examples that we see in the wild, unless we invest in a\ncomplex real-time annotation pipeline. What we can do, however, is average all of our\nmodel\u2019s predictions at test time together, yielding the mean model outputs \ud835\udf07\u00b9\u02c6y\u00ba 2R\ud835\udc58,\nwhere the\ud835\udc56thelement\ud835\udf07\u00b9\u02c6\ud835\udc66\ud835\udc56\u00bais the fraction of the total predictions on the test set where our\nmodel predicted \ud835\udc56.\nIt turns out that under some mild conditions\u2014if our classifier was reasonably accurate in\nthe first place, and if the target data contains only categories that we have seen before, and\nif the label shift assumption holds in the first place (the strongest assumption here)\u2014we\ncan estimate the test set label distribution by solving a simple linear system\nC\ud835\udc5d\u00b9y\u00ba=\ud835\udf07\u00b9\u02c6y\u00ba, (4.7.10)\nbecause as an estimate\u00cd\ud835\udc58\n\ud835\udc57=1\ud835\udc50\ud835\udc56\ud835\udc57\ud835\udc5d\u00b9\ud835\udc66\ud835\udc57\u00ba=\ud835\udf07\u00b9\u02c6\ud835\udc66\ud835\udc56\u00baholds for all 1\u0014\ud835\udc56\u0014\ud835\udc58, where\ud835\udc5d\u00b9\ud835\udc66\ud835\udc57\u00bais\nthe\ud835\udc57thelement of the \ud835\udc58-dimensional label distribution vector \ud835\udc5d\u00b9y\u00ba. If our classifier is\nsufficiently accurate to begin with, then the confusion matrix Cwill be invertible, and we\nget a solution \ud835\udc5d\u00b9y\u00ba=C\u00001\ud835\udf07\u00b9\u02c6y\u00ba.\nBecause we observe the labels on the source data, it is easy to estimate the distribution\n\ud835\udc5e\u00b9\ud835\udc66\u00ba.", "mimetype": "text/plain", "start_char_idx": 427154, "end_char_idx": 430103, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e76e09cd-e8e0-404a-b37b-3af88b692632": {"__data__": {"id_": "e76e09cd-e8e0-404a-b37b-3af88b692632", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c01c977f-bd47-4ca6-a32a-f3eb3b608a7d", "node_type": "1", "metadata": {}, "hash": "04cf76486f651ac4b96e88a804ed32c46eeae18b8bfcf447cba0752d8edd453d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9cb8a305-a433-47c5-b154-30bf23c973c0", "node_type": "1", "metadata": {}, "hash": "972bfd1b22e77822f1228d5bd54239253152342371b7b95421e3177cff67631c", "class_name": "RelatedNodeInfo"}}, "text": "If our classifier is\nsufficiently accurate to begin with, then the confusion matrix Cwill be invertible, and we\nget a solution \ud835\udc5d\u00b9y\u00ba=C\u00001\ud835\udf07\u00b9\u02c6y\u00ba.\nBecause we observe the labels on the source data, it is easy to estimate the distribution\n\ud835\udc5e\u00b9\ud835\udc66\u00ba. Then, for any training example \ud835\udc56with label\ud835\udc66\ud835\udc56, we can take the ratio of our esti-\nmated\ud835\udc5d\u00b9\ud835\udc66\ud835\udc56\u00ba\u009d\ud835\udc5e\u00b9\ud835\udc66\ud835\udc56\u00bato calculate the weight \ud835\udefd\ud835\udc56, and plug this into weighted empirical risk\nminimization in (4.7.5 ).\nConceptShift Correction\nConceptshiftismuchhardertofixinaprincipledmanner. Forinstance,inasituationwhere\nsuddenly the problem changes from distinguishing cats from dogs to one of distinguishing\nwhite from black animals, it will be unreasonable to assume that we can do much better\nthan just collecting new labels and training from scratch. Fortunately, in practice, such\nextreme shifts are rare. Instead, what usually happens is that the task keeps on changing\nslowly. To make things more concrete, here are some examples:\n\u000fIncomputationaladvertising,newproductsarelaunched,oldproductsbecomelesspop-\nular. This means that the distribution over ads and their popularity changes gradually\nand any click-through rate predictor needs to change gradually with it.\n\u000fTraffic camera lenses degrade gradually due to environmental wear, affecting image\nquality progressively.\n\u000fNews content changes gradually (i.e., most of the news remains unchanged but new sto-\nries appear).\n163 Environment and Distribution Shift\nIn such cases, we can use the same approach that we used for training networks to make\nthem adapt to the change in the data. In other words, we use the existing network weights\nandsimplyperformafewupdatestepswiththenewdataratherthantrainingfromscratch.\n4.7.4A Taxonomyof Learning Problems\nArmed with knowledge about how to deal with changes in distributions, we can now con-\nsider some other aspects of machine learning problem formulation.\nBatchLearning\nInbatch learning , we have access to training features and labels f\u00b9x1,\ud835\udc661\u00ba,...,\u00b9x\ud835\udc5b,\ud835\udc66\ud835\udc5b\u00bag,\nwhichweusetotrainamodel \ud835\udc53\u00b9x\u00ba. Lateron,wedeploythismodeltoscorenewdata \u00b9x,\ud835\udc66\u00ba\ndrawn from the same distribution. This is the default assumption for any of the problems\nthat we discuss here. For instance, we might train a cat detector based on lots of pictures\nof cats and dogs. Once we have trained it, we ship it as part of a smart catdoor computer\nvision system that lets only cats in. This is then installed in a customer\u2019s home and is never\nupdated again (barring extreme circumstances).\nOnline Learning\nNow imagine that the data \u00b9x\ud835\udc56,\ud835\udc66\ud835\udc56\u00baarrives one sample at a time. More specifically, assume\nthat we first observe x\ud835\udc56, then we need to come up with an estimate \ud835\udc53\u00b9x\ud835\udc56\u00ba. Only once\nwe have done this do we observe \ud835\udc66\ud835\udc56and so receive a reward or incur a loss, given our\ndecision. Many real problems fall into this category. For example, we need to predict\ntomorrow\u2019s stock price, which allows us to trade based on that estimate and at the end\nof the day we find out whether our estimate made us a profit. In other words, in online\nlearning , we have the following cycle where we are continuously improving our model\ngiven new observations:\nmodel\ud835\udc53\ud835\udc61\u0000!datax\ud835\udc61\u0000!estimate\ud835\udc53\ud835\udc61\u00b9x\ud835\udc61\u00ba\u0000!\nobservation\ud835\udc66\ud835\udc61\u0000!loss\ud835\udc59\u00b9\ud835\udc66\ud835\udc61, \ud835\udc53\ud835\udc61\u00b9x\ud835\udc61\u00ba\u00ba\u0000!model\ud835\udc53\ud835\udc61\u00b81(4.7.11)\nBandits\nBanditsare a special case of the problem above. While in most learning problems we have\na continuously parametrized function \ud835\udc53where we want to learn its parameters (e.g., a deep\nnetwork), in a banditproblem we only have a finite number of arms that we can pull, i.e.,\na finite number of actions that we can take. It is not very surprising that for this simpler\nproblem stronger theoretical guarantees in terms of optimality can be obtained. We list\nit mainly since this problem is often (confusingly) treated as if it were a distinct learning\nsetting.", "mimetype": "text/plain", "start_char_idx": 429866, "end_char_idx": 433625, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9cb8a305-a433-47c5-b154-30bf23c973c0": {"__data__": {"id_": "9cb8a305-a433-47c5-b154-30bf23c973c0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e76e09cd-e8e0-404a-b37b-3af88b692632", "node_type": "1", "metadata": {}, "hash": "dfe1a20fb2d132fc7c1b51d30fcc2e9a992e3a0a672ed1ed69207486e9cae13c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1a5c4e0f-33ae-41a1-8356-d09cf4d65000", "node_type": "1", "metadata": {}, "hash": "39797076f98cb12beee9c8416ddaec49d4d243b47bf74c7c05ba71791c22303e", "class_name": "RelatedNodeInfo"}}, "text": "observation\ud835\udc66\ud835\udc61\u0000!loss\ud835\udc59\u00b9\ud835\udc66\ud835\udc61, \ud835\udc53\ud835\udc61\u00b9x\ud835\udc61\u00ba\u00ba\u0000!model\ud835\udc53\ud835\udc61\u00b81(4.7.11)\nBandits\nBanditsare a special case of the problem above. While in most learning problems we have\na continuously parametrized function \ud835\udc53where we want to learn its parameters (e.g., a deep\nnetwork), in a banditproblem we only have a finite number of arms that we can pull, i.e.,\na finite number of actions that we can take. It is not very surprising that for this simpler\nproblem stronger theoretical guarantees in terms of optimality can be obtained. We list\nit mainly since this problem is often (confusingly) treated as if it were a distinct learning\nsetting.\n164 Linear Neural Networks for Classi\ufb01cation\nControl\nIn many cases the environment remembers what we did. Not necessarily in an adversarial\nmanner but it will just remember and the response will depend on what happened before.\nFor instance, a coffee boiler controller will observe different temperatures depending on\nwhether it was heating the boiler previously. PID (proportional-integral-derivative) con-\ntroller algorithms are a popular choice there. Likewise, a user\u2019s behavior on a news site\nwilldependonwhatweshowedthempreviously(e.g.,theywillreadmostnewsonlyonce).\nMany such algorithms form a model of the environment in which they act so as to make\ntheir decisions appear less random. Recently, control theory (e.g., PID variants) has also\nbeenusedtoautomaticallytunehyperparameterstoachievebetterdisentanglingandrecon-\nstruction quality, and improve the diversity of generated text and the reconstruction quality\nof generated images ( Shaoetal., 2020).\nReinforcementLearning\nIn the more general case of an environment with memory, we may encounter situations\nwhere the environment is trying to cooperate with us (cooperative games, in particular\nfor non-zero-sum games), or others where the environment will try to win. Chess, Go,\nBackgammon, or StarCraft are some of the cases in reinforcement learning . Likewise, we\nmightwanttobuildagoodcontrollerforautonomouscars. Othercarsarelikelytorespond\nto the autonomous car\u2019s driving style in nontrivial ways, e.g., trying to avoid it, trying to\ncause an accident, or trying to cooperate with it.\nConsidering the Environment\nOne key distinction between the different situations above is that a strategy that might have\nworked throughout in the case of a stationary environment, might not work throughout in\nanenvironmentthatcanadapt. Forinstance,anarbitrageopportunitydiscoveredbyatrader\nis likely to disappear once it is exploited. The speed and manner at which the environment\nchanges determines to a large extent the type of algorithms that we can bring to bear. For\ninstance, if we know that things may only change slowly, we can force any estimate to\nchange only slowly, too. If we know that the environment might change instantaneously,\nbut only very infrequently, we can make allowances for that. These types of knowledge are\ncrucial for the aspiring data scientist in dealing with concept shift, i.e., when the problem\nthat is being solved can change over time.\n4.7.5Fairness,Accountability,and Transparencyin Machine\nLearning\nFinally, it is important to remember that when you deploy machine learning systems you\nare not merely optimizing a predictive model\u2014you are typically providing a tool that will\nbe used to (partially or fully) automate decisions. These technical systems can impact the\nlives of individuals who are subject to the resulting decisions. The leap from considering\npredictions to making decisions raises not only new technical questions, but also a slew of\n165 Environment and Distribution Shift\nethicalquestionsthatmustbecarefullyconsidered. Ifwearedeployingamedicaldiagnos-\ntic system, we need to know for which populations it may work and for which it may not.\nOverlooking foreseeable risks to the welfare of a subpopulation could cause us to adminis-\nter inferior care. Moreover, once we contemplate decision-making systems, we must step\nback and reconsider how we evaluate our technology. Among other consequences of this\nchangeofscope,wewillfindthat accuracy isseldomtherightmeasure. Forinstance,when\ntranslatingpredictionsintoactions,wewilloftenwanttotakeintoaccountthepotentialcost\nsensitivity of erring in various ways.", "mimetype": "text/plain", "start_char_idx": 433014, "end_char_idx": 437237, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1a5c4e0f-33ae-41a1-8356-d09cf4d65000": {"__data__": {"id_": "1a5c4e0f-33ae-41a1-8356-d09cf4d65000", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9cb8a305-a433-47c5-b154-30bf23c973c0", "node_type": "1", "metadata": {}, "hash": "972bfd1b22e77822f1228d5bd54239253152342371b7b95421e3177cff67631c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d4473a1d-7cd1-4c8d-b261-cd482db417fa", "node_type": "1", "metadata": {}, "hash": "21cb816fa6763a09bf117b9eb09834223aa7ae523789b4137c063a06a84dd413", "class_name": "RelatedNodeInfo"}}, "text": "These technical systems can impact the\nlives of individuals who are subject to the resulting decisions. The leap from considering\npredictions to making decisions raises not only new technical questions, but also a slew of\n165 Environment and Distribution Shift\nethicalquestionsthatmustbecarefullyconsidered. Ifwearedeployingamedicaldiagnos-\ntic system, we need to know for which populations it may work and for which it may not.\nOverlooking foreseeable risks to the welfare of a subpopulation could cause us to adminis-\nter inferior care. Moreover, once we contemplate decision-making systems, we must step\nback and reconsider how we evaluate our technology. Among other consequences of this\nchangeofscope,wewillfindthat accuracy isseldomtherightmeasure. Forinstance,when\ntranslatingpredictionsintoactions,wewilloftenwanttotakeintoaccountthepotentialcost\nsensitivity of erring in various ways. If one way of misclassifying an image could be per-\nceived as a racial sleight of hand, while misclassification to a different category would be\nharmless, then we might want to adjust our thresholds accordingly, accounting for societal\nvalues in designing the decision-making protocol. We also want to be careful about how\nprediction systems can lead to feedback loops. For example, consider predictive policing\nsystems, which allocate patrol officers to areas with high forecasted crime. It is easy to see\nhow a worrying pattern can emerge:\n1.Neighborhoods with more crime get more patrols.\n2.Consequently,morecrimesarediscoveredintheseneighborhoods,enteringthetraining\ndata available for future iterations.\n3.Exposed to more positives, the model predicts yet more crime in these neighborhoods.\n4.In the next iteration, the updated model targets the same neighborhood even more heav-\nily leading to yet more crimes discovered, etc.\nOften,thevariousmechanismsbywhichamodel\u2019spredictionsbecomecoupledtoitstrain-\ning data are unaccounted for in the modeling process. This can lead to what researchers\ncallrunaway feedback loops . Additionally, we want to be careful about whether we are\naddressing the right problem in the first place. Predictive algorithms now play an outsize\nrole in mediating the dissemination of information. Should the news that an individual en-\ncounters be determined by the set of Facebook pages they have Liked? These are just a few\namongthemanypressingethicaldilemmasthatyoumightencounterinacareerinmachine\nlearning.\n4.7.6Summary\nIn many cases training and test sets do not come from the same distribution. This is called\ndistribution shift. The risk is the expectation of the loss over the entire population of data\ndrawn from their true distribution. However, this entire population is usually unavailable.\nEmpirical risk is an average loss over the training data to approximate the risk. In practice,\nwe perform empirical risk minimization.\nUnder the corresponding assumptions, covariate and label shift can be detected and cor-\nrected for at test time. Failure to account for this bias can become problematic at test time.\nInsomecases,theenvironmentmayrememberautomatedactionsandrespondinsurprising\nways. We must account for this possibility when building models and continue to moni-\ntor live systems, open to the possibility that our models and the environment will become\nentangled in unanticipated ways.\n166 Linear Neural Networks for Classi\ufb01cation\n1014.7.7Exercises\n1.What could happen when we change the behavior of a search engine? What might the\nusers do? What about the advertisers?\n2.Implement a covariate shift detector. Hint: build a classifier.\n3.Implement a covariate shift corrector.\n4.Besides distribution shift, what else could affect how the empirical risk approximates\nthe risk?\nDiscussions101.\n5 Multilayer Perceptrons\nInthischapter,wewillintroduceyourfirsttruly deepnetwork. Thesimplestdeepnetworks\nare called multilayerperceptrons , and they consist of multiple layers of neurons each fully\nconnected to those in the layer below (from which they receive input) and those above\n(which they, in turn, influence). Although automatic differentiation significantly simplifies\nthe implementation of deep learning algorithms, we will dive deep into how these gradi-\nents are calculated in deep networks. Then we will be ready to discuss issues relating to\nnumerical stability and parameter initialization that are key to successfully training deep\nnetworks. When we train such high-capacity models we run the risk of overfitting. Thus,\nwe will revisit regularization and generalization for deep networks. Throughout, we aim to\ngiveyouafirmgraspnotjustoftheconceptsbutalsoofthepracticeofusingdeepnetworks.", "mimetype": "text/plain", "start_char_idx": 436344, "end_char_idx": 440985, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d4473a1d-7cd1-4c8d-b261-cd482db417fa": {"__data__": {"id_": "d4473a1d-7cd1-4c8d-b261-cd482db417fa", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1a5c4e0f-33ae-41a1-8356-d09cf4d65000", "node_type": "1", "metadata": {}, "hash": "39797076f98cb12beee9c8416ddaec49d4d243b47bf74c7c05ba71791c22303e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "46041e36-7a56-47d3-ab2c-abbbf8494045", "node_type": "1", "metadata": {}, "hash": "4a35b441347d063e15f81377affa983e7e1cac99259df9c04c21a942c0646e3b", "class_name": "RelatedNodeInfo"}}, "text": "Thesimplestdeepnetworks\nare called multilayerperceptrons , and they consist of multiple layers of neurons each fully\nconnected to those in the layer below (from which they receive input) and those above\n(which they, in turn, influence). Although automatic differentiation significantly simplifies\nthe implementation of deep learning algorithms, we will dive deep into how these gradi-\nents are calculated in deep networks. Then we will be ready to discuss issues relating to\nnumerical stability and parameter initialization that are key to successfully training deep\nnetworks. When we train such high-capacity models we run the risk of overfitting. Thus,\nwe will revisit regularization and generalization for deep networks. Throughout, we aim to\ngiveyouafirmgraspnotjustoftheconceptsbutalsoofthepracticeofusingdeepnetworks.\nAt the end of this chapter, we apply what we have introduced so far to a real case: house\nprice prediction. We punt matters relating to the computational performance, scalability,\nand efficiency of our models to subsequent chapters.\n5.1MultilayerPerceptrons\nInSection4.1 ,weintroducedsoftmaxregression,implementingthealgorithmfromscratch\n(Section4.4 )andusinghigh-levelAPIs( Section4.5 ). Thisallowedustotrainclassifiersca-\npableofrecognizing10categoriesofclothingfromlow-resolutionimages. Alongtheway,\nwe learned how to wrangle data, coerce our outputs into a valid probability distribution,\napplyanappropriatelossfunction,andminimizeitwithrespecttoourmodel\u2019sparameters.\nNow that we have mastered these mechanics in the context of simple linear models, we\ncanlaunchourexplorationofdeepneuralnetworks,thecomparativelyrichclassofmodels\nwith which this book is primarily concerned.\n%matplotlib inline\nimport torch\nfrom d2l import torch asd2l\n5.1.1Hidden Layers\nWe described affine transformations in Section 3.1.1 as linear transformations with added\nbias. To begin, recall the model architecture corresponding to our softmax regression ex-\n167\n168 Multilayer Perceptrons\nample, illustrated in Fig. 4.1.1 . This model maps inputs directly to outputs via a single\naffine transformation, followed by a softmax operation. If our labels truly were related to\nthe input data by a simple affine transformation, then this approach would be sufficient.\nHowever, linearity (in affine transformations) is a strongassumption.\nLimitations of Linear Models\nFor example, linearity implies the weakerassumption of monotonicity , i.e., that any in-\ncrease in our feature must either always cause an increase in our model\u2019s output (if the\ncorresponding weight is positive), or always cause a decrease in our model\u2019s output (if\nthe corresponding weight is negative). Sometimes that makes sense. For example, if we\nweretryingtopredictwhetheranindividualwillrepayaloan,wemightreasonablyassume\nthat all other things being equal, an applicant with a higher income would always be more\nlikely to repay than one with a lower income. While monotonic, this relationship likely\nis not linearly associated with the probability of repayment. An increase in income from\n$0 to $50,000 likely corresponds to a bigger increase in likelihood of repayment than an\nincrease from $1 million to $1.05 million. One way to handle this might be to postprocess\nour outcome such that linearity becomes more plausible, by using the logistic map (and\nthus the logarithm of the probability of outcome).\nNote that we can easily come up with examples that violate monotonicity. Say for example\nthat we want to predict health as a function of body temperature. For individuals with a\nnormal body temperature above 37\u00b0C (98.6\u00b0F), higher temperatures indicate greater risk.\nHowever, if the body temperatures drops below 37\u00b0C, lower temperatures indicate greater\nrisk! Again, we might resolve the problem with some clever preprocessing, such as using\nthe distance from 37\u00b0C as a feature.\nBut what about classifying images of cats and dogs? Should increasing the intensity of the\npixelatlocation(13, 17)alwaysincrease(oralwaysdecrease)thelikelihoodthattheimage\ndepicts a dog? Reliance on a linear model corresponds to the implicit assumption that the\nonly requirement for differentiating cats and dogs is to assess the brightness of individual\npixels. This approach is doomed to fail in a world where inverting an image preserves the\ncategory.\nAnd yet despite the apparent absurdity of linearity here, as compared with our previous\nexamples, it is less obvious that we could address the problem with a simple preprocessing\nfix.", "mimetype": "text/plain", "start_char_idx": 440162, "end_char_idx": 444658, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "46041e36-7a56-47d3-ab2c-abbbf8494045": {"__data__": {"id_": "46041e36-7a56-47d3-ab2c-abbbf8494045", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d4473a1d-7cd1-4c8d-b261-cd482db417fa", "node_type": "1", "metadata": {}, "hash": "21cb816fa6763a09bf117b9eb09834223aa7ae523789b4137c063a06a84dd413", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "533b1447-356b-48a6-9e37-97f14a4d57ce", "node_type": "1", "metadata": {}, "hash": "66e7d1813f13745104bdd57e1aece5d01c2a2eb8d691f1cc3840b3aba7b16e3c", "class_name": "RelatedNodeInfo"}}, "text": "However, if the body temperatures drops below 37\u00b0C, lower temperatures indicate greater\nrisk! Again, we might resolve the problem with some clever preprocessing, such as using\nthe distance from 37\u00b0C as a feature.\nBut what about classifying images of cats and dogs? Should increasing the intensity of the\npixelatlocation(13, 17)alwaysincrease(oralwaysdecrease)thelikelihoodthattheimage\ndepicts a dog? Reliance on a linear model corresponds to the implicit assumption that the\nonly requirement for differentiating cats and dogs is to assess the brightness of individual\npixels. This approach is doomed to fail in a world where inverting an image preserves the\ncategory.\nAnd yet despite the apparent absurdity of linearity here, as compared with our previous\nexamples, it is less obvious that we could address the problem with a simple preprocessing\nfix. That is, because the significance of any pixel depends in complex ways on its context\n(the values of the surrounding pixels). While there might exist a representation of our data\nthat would take into account the relevant interactions among our features, on top of which\na linear model wouldbe suitable, we simplydo not knowhow to calculate it byhand. With\ndeep neural networks, we used observational data to jointly learn both a representation via\nhidden layers and a linear predictor that acts upon that representation.\nThis problem of nonlinearity has been studied for at least a century ( Fisher, 1925 ). For\ninstance, decision trees in their most basic form use a sequence of binary decisions to de-\ncide upon class membership ( Quinlan, 1993 ). Likewise, kernel methods have been used\nfor many decades to model nonlinear dependencies ( Aronszajn, 1950 ). This has found its\n169 Multilayer Perceptrons\nway into nonparametric spline models ( Wahba, 1990 ) and kernel methods ( Sch\u00f6lkopf and\nSmola, 2002 ). It is also something that the brain solves quite naturally. After all, neu-\nrons feed into other neurons which, in turn, feed into other neurons again ( Ram\u00f3n y Cajal\nand Azoulay, 1894 ). Consequently we have a sequence of relatively simple transforma-\ntions.\nIncorporatingHidden Layers\nWe can overcome the limitations of linear models by incorporating one or more hidden\nlayers. The easiest way to do this is to stack many fully connected layers on top of one\nanother. Eachlayerfeedsinto thelayeraboveit, untilwegenerateoutputs. Wecanthinkof\nthe first\ud835\udc3f\u00001layers as our representation and the final layer as our linear predictor. This\narchitecture is commonly called a multilayer perceptron , often abbreviated as MLP(Fig.\n5.1.1).\ntFig. 5.1.1 An MLP with a hidden layer of \ufb01ve hidden units.\nThis MLP has four inputs, three outputs, and its hidden layer contains five hidden units.\nSincetheinputlayerdoesnotinvolveanycalculations,producingoutputswiththisnetwork\nrequires implementing the computations for both the hidden and output layers; thus, the\nnumber of layers in this MLP is two. Note that both layers are fully connected. Every\ninputinfluenceseveryneuroninthehiddenlayer,andeachoftheseinturninfluencesevery\nneuron in the output layer. Alas, we are not quite done yet.\nFromLinear to Nonlinear\nAsbefore,wedenotebythematrix X2R\ud835\udc5b\u0002\ud835\udc51aminibatchof \ud835\udc5bexampleswhereeachexam-\nple has\ud835\udc51inputs (features). For a one-hidden-layer MLP whose hidden layer has \u210ehidden\nunits, we denote by H2R\ud835\udc5b\u0002\u210ethe outputs of the hidden layer, which are hidden represen-\ntations. Since the hidden and output layers are both fully connected, we have hidden-layer\nweights W\u00b91\u00ba2R\ud835\udc51\u0002\u210eand biases b\u00b91\u00ba2R1\u0002\u210eand output-layer weights W\u00b92\u00ba2R\u210e\u0002\ud835\udc5eand\nbiases b\u00b92\u00ba2R1\u0002\ud835\udc5e. This allows us to calculate the outputs O2R\ud835\udc5b\u0002\ud835\udc5eof the one-hidden-\nlayer MLP as follows:\nH=XW\u00b91\u00ba\u00b8b\u00b91\u00ba,\nO=HW\u00b92\u00ba\u00b8b\u00b92\u00ba.(5.1.1)\nNote that after adding the hidden layer, our model now requires us to track and update\nadditionalsetsofparameters. Sowhathavewegainedinexchange?", "mimetype": "text/plain", "start_char_idx": 443807, "end_char_idx": 447659, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "533b1447-356b-48a6-9e37-97f14a4d57ce": {"__data__": {"id_": "533b1447-356b-48a6-9e37-97f14a4d57ce", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "46041e36-7a56-47d3-ab2c-abbbf8494045", "node_type": "1", "metadata": {}, "hash": "4a35b441347d063e15f81377affa983e7e1cac99259df9c04c21a942c0646e3b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0f9f8736-85cd-43c5-8c06-04754b3973e3", "node_type": "1", "metadata": {}, "hash": "24350aba1ebb1f58293ae81bee26e627f89066ef0dd3908cf2d35b3d5ac6c409", "class_name": "RelatedNodeInfo"}}, "text": "Since the hidden and output layers are both fully connected, we have hidden-layer\nweights W\u00b91\u00ba2R\ud835\udc51\u0002\u210eand biases b\u00b91\u00ba2R1\u0002\u210eand output-layer weights W\u00b92\u00ba2R\u210e\u0002\ud835\udc5eand\nbiases b\u00b92\u00ba2R1\u0002\ud835\udc5e. This allows us to calculate the outputs O2R\ud835\udc5b\u0002\ud835\udc5eof the one-hidden-\nlayer MLP as follows:\nH=XW\u00b91\u00ba\u00b8b\u00b91\u00ba,\nO=HW\u00b92\u00ba\u00b8b\u00b92\u00ba.(5.1.1)\nNote that after adding the hidden layer, our model now requires us to track and update\nadditionalsetsofparameters. Sowhathavewegainedinexchange? Youmightbesurprised\n170 Multilayer Perceptrons\ntofindoutthat\u2014inthemodeldefinedabove\u2014 wegainnothingforourtroubles ! Thereason\nisplain. Thehiddenunitsabovearegivenbyanaffinefunctionoftheinputs,andtheoutputs\n(pre-softmax) are just an affine function of the hidden units. An affine function of an affine\nfunction is itself an affine function. Moreover, our linear model was already capable of\nrepresenting any affine function.\nToseethisformallywecanjustcollapseoutthehiddenlayerintheabovedefinition,yielding\nan equivalent single-layer model with parameters W=W\u00b91\u00baW\u00b92\u00baandb=b\u00b91\u00baW\u00b92\u00ba\u00b8\nb\u00b92\u00ba:\nO=\u00b9XW\u00b91\u00ba\u00b8b\u00b91\u00ba\u00baW\u00b92\u00ba\u00b8b\u00b92\u00ba=XW\u00b91\u00baW\u00b92\u00ba\u00b8b\u00b91\u00baW\u00b92\u00ba\u00b8b\u00b92\u00ba=XW\u00b8b.\n(5.1.2)\nIn order to realize the potential of multilayer architectures, we need one more key ingre-\ndient: a nonlinear activation function \ud835\udf0eto be applied to each hidden unit following the\naffine transformation. For instance, a popular choice is the ReLU (rectified linear unit) ac-\ntivation function ( Nair and Hinton, 2010 )\ud835\udf0e\u00b9\ud835\udc65\u00ba=max\u00b90,\ud835\udc65\u00baoperating on its arguments\nelementwise. The outputs of activation functions \ud835\udf0e\u00b9\u0001\u00baare called activations . In general,\nwith activation functions in place, it is no longer possible to collapse our MLP into a linear\nmodel:\nH=\ud835\udf0e\u00b9XW\u00b91\u00ba\u00b8b\u00b91\u00ba\u00ba,\nO=HW\u00b92\u00ba\u00b8b\u00b92\u00ba.(5.1.3)\nSince each row in Xcorresponds to an example in the minibatch, with some abuse of\nnotation, we define the nonlinearity \ud835\udf0eto apply to its inputs in a rowwise fashion, i.e., one\nexample at a time. Note that we used the same notation for softmax when we denoted a\nrowwise operation in Section 4.1.1 . Quite frequently the activation functions we use apply\nnotmerelyrowwisebutelementwise. Thatmeansthataftercomputingthelinearportionof\nthe layer, we can calculate each activation without looking at the values taken by the other\nhidden units.\nTo build more general MLPs, we can continue stacking such hidden layers, e.g., H\u00b91\u00ba=\n\ud835\udf0e1\u00b9XW\u00b91\u00ba\u00b8b\u00b91\u00ba\u00baandH\u00b92\u00ba=\ud835\udf0e2\u00b9H\u00b91\u00baW\u00b92\u00ba\u00b8b\u00b92\u00ba\u00ba,oneatopanother,yieldingevermore\nexpressive models.\nUniversalApproximators\nWe know that the brain is capable of very sophisticated statistical analysis. As such, it is\nworthasking,just howpowerful adeepnetworkcouldbe. Thisquestionhasbeenanswered\nmultiple times, e.g., in Cybenko ( 1989) in the context of MLPs, and in Micchelli ( 1984) in\nthe context of reproducing kernel Hilbert spaces in a way that could be seen as radial basis\nfunction(RBF)networkswithasinglehiddenlayer. These(andrelatedresults)suggestthat\neven with a single-hidden-layer network, given enough nodes (possibly absurdly many),\nand the right set of weights, we can model any function. Actually learning that function\nis the hard part, though. You might think of your neural network as being a bit like the\nC programming language. The language, like any other modern language, is capable of\n171 Multilayer Perceptrons\nexpressing any computable program. But actually coming up with a program that meets\nyour specifications is the hard part.", "mimetype": "text/plain", "start_char_idx": 447218, "end_char_idx": 450562, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0f9f8736-85cd-43c5-8c06-04754b3973e3": {"__data__": {"id_": "0f9f8736-85cd-43c5-8c06-04754b3973e3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "533b1447-356b-48a6-9e37-97f14a4d57ce", "node_type": "1", "metadata": {}, "hash": "66e7d1813f13745104bdd57e1aece5d01c2a2eb8d691f1cc3840b3aba7b16e3c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2ed174eb-26fb-4e1d-a551-23eb0479a4b7", "node_type": "1", "metadata": {}, "hash": "a98fb549b4dd9e33abff1d668db9301771e969f4767608f3ae081ca99e48b7f6", "class_name": "RelatedNodeInfo"}}, "text": "Thisquestionhasbeenanswered\nmultiple times, e.g., in Cybenko ( 1989) in the context of MLPs, and in Micchelli ( 1984) in\nthe context of reproducing kernel Hilbert spaces in a way that could be seen as radial basis\nfunction(RBF)networkswithasinglehiddenlayer. These(andrelatedresults)suggestthat\neven with a single-hidden-layer network, given enough nodes (possibly absurdly many),\nand the right set of weights, we can model any function. Actually learning that function\nis the hard part, though. You might think of your neural network as being a bit like the\nC programming language. The language, like any other modern language, is capable of\n171 Multilayer Perceptrons\nexpressing any computable program. But actually coming up with a program that meets\nyour specifications is the hard part.\nMoreover,justbecauseasingle-hidden-layernetwork canlearnanyfunctiondoesnotmean\nthat you should try to solve all of your problems with one. In fact, in this case kernel\nmethodsarewaymoreeffective,sincetheyarecapableofsolvingtheproblem exactlyeven\nin infinite dimensional spaces ( Kimeldorf and Wahba, 1971 ,Sch\u00f6lkopf et al., 2001). In\nfact, we can approximate many functions much more compactly by using deeper (rather\nthanwider)networks( SimonyanandZisserman,2014 ). Wewilltouchuponmorerigorous\narguments in subsequent chapters.\n5.1.2ActivationFunctions\nActivation functions decide whether a neuron should be activated or not by calculating the\nweighted sum and further adding bias to it. They are differentiable operators for trans-\nforming input signals to outputs, while most of them add nonlinearity. Because activation\nfunctionsarefundamentaltodeeplearning,let\u2019sbrieflysurveysomecommonones.\nReLUFunction\nThe most popular choice, due to both simplicity of implementation and its good perfor-\nmance on a variety of predictive tasks, is the rectifiedlinearunit (ReLU) (Nairand Hinton,\n2010). ReLU provides a very simple nonlinear transformation. Given an element \ud835\udc65, the\nfunction is defined as the maximum of that element and 0:\nReLU\u00b9\ud835\udc65\u00ba=max\u00b9\ud835\udc65,0\u00ba. (5.1.4)\nInformally, the ReLU function retains only positive elements and discards all negative el-\nements by setting the corresponding activations to 0. To gain some intuition, we can plot\nthe function. As you can see, the activation function is piecewise linear.\nx=torch .arange( -8.0,8.0,0.1, requires_grad =True )\ny=torch .relu(x)\nd2l.plot(x .detach(), y .detach(), 'x','relu(x) ', figsize =(5,2.5))\nWhen the input is negative, the derivative of the ReLU function is 0, and when the input\nis positive, the derivative of the ReLU function is 1. Note that the ReLU function is not\n172 Multilayer Perceptrons\ndifferentiable when the input takes value precisely equal to 0. In these cases, we default to\nthe left-hand-side derivative and say that the derivative is 0 when the input is 0. We can\ngetawaywiththisbecausetheinputmayneveractuallybezero(mathematicianswouldsay\nthat it is nondifferentiable on a set of measure zero). There is an old adage that if subtle\nboundary conditions matter, we are probably doing ( real) mathematics, not engineering.\nThat conventional wisdom may apply here, or at least, the fact that we are not performing\nconstrained optimization ( Mangasarian, 1965 ,Rockafellar, 1970 ). We plot the derivative\nof the ReLU function below.\ny.backward(torch .ones_like(x), retain_graph =True )\nd2l.plot(x .detach(), x .grad, 'x','grad of relu ', figsize =(5,2.5))\nThe reason for using ReLU is that its derivatives are particularly well behaved: either they\nvanish or they just let the argument through. This makes optimization better behaved and\nit mitigated the well-documented problem of vanishing gradients that plagued previous\nversions of neural networks (more on this later).\nNote that there are many variants to the ReLU function, including the parametrized ReLU\n(pReLU) function ( Heet al., 2015).", "mimetype": "text/plain", "start_char_idx": 449771, "end_char_idx": 453634, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2ed174eb-26fb-4e1d-a551-23eb0479a4b7": {"__data__": {"id_": "2ed174eb-26fb-4e1d-a551-23eb0479a4b7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0f9f8736-85cd-43c5-8c06-04754b3973e3", "node_type": "1", "metadata": {}, "hash": "24350aba1ebb1f58293ae81bee26e627f89066ef0dd3908cf2d35b3d5ac6c409", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e52f0545-4c18-4c46-aac1-03b7a67a2325", "node_type": "1", "metadata": {}, "hash": "cabbcfad5a5f30204eb49781acef4b3dbb134e00b3146249e3563b345b51b484", "class_name": "RelatedNodeInfo"}}, "text": "That conventional wisdom may apply here, or at least, the fact that we are not performing\nconstrained optimization ( Mangasarian, 1965 ,Rockafellar, 1970 ). We plot the derivative\nof the ReLU function below.\ny.backward(torch .ones_like(x), retain_graph =True )\nd2l.plot(x .detach(), x .grad, 'x','grad of relu ', figsize =(5,2.5))\nThe reason for using ReLU is that its derivatives are particularly well behaved: either they\nvanish or they just let the argument through. This makes optimization better behaved and\nit mitigated the well-documented problem of vanishing gradients that plagued previous\nversions of neural networks (more on this later).\nNote that there are many variants to the ReLU function, including the parametrized ReLU\n(pReLU) function ( Heet al., 2015). This variation adds a linear term to ReLU, so some\ninformation still gets through, even when the argument is negative:\npReLU\u00b9\ud835\udc65\u00ba=max\u00b90,\ud835\udc65\u00ba\u00b8\ud835\udefcmin\u00b90,\ud835\udc65\u00ba. (5.1.5)\nSigmoid Function\nThesigmoidfunction transforms those inputs whose values lie in the domain R, to outputs\nthat lie on the interval (0, 1). For that reason, the sigmoid is often called a squashingfunc-\ntion: it squashes any input in the range (-inf, inf) to some value in the range (0, 1):\nsigmoid\u00b9\ud835\udc65\u00ba=1\n1\u00b8exp\u00b9\u0000\ud835\udc65\u00ba. (5.1.6)\nIn the earliest neural networks, scientists were interested in modeling biological neurons\nthat either fireordo not fire . Thus the pioneers of this field, going all the way back to\nMcCulloch and Pitts, the inventors of the artificial neuron, focused on thresholding units\n(McCulloch and Pitts, 1943 ). A thresholding activation takes value 0 when its input is\nbelow some threshold and value 1 when the input exceeds the threshold.\n173 Multilayer Perceptrons\nWhenattentionshiftedtogradient-basedlearning,thesigmoidfunctionwasanaturalchoice\nbecause it is a smooth, differentiable approximation to a thresholding unit. Sigmoids are\nstill widely used as activation functions on the output units when we want to interpret the\noutputsasprobabilitiesforbinaryclassificationproblems: youcanthinkofthesigmoidasa\nspecialcaseofthesoftmax. However, thesigmoidhaslargelybeenreplacedbythesimpler\nand more easily trainable ReLU for most use in hidden layers. Much of this has to do with\nthe fact that the sigmoid poses challenges for optimization ( LeCunet al., 1998) since its\ngradient vanishes for large positive andnegative arguments. This can lead to plateaus that\nare difficult to escape from. Nonetheless sigmoids are important. In later chapters (e.g.,\nSection 10.1 ) on recurrent neural networks, we will describe architectures that leverage\nsigmoid units to control the flow of information across time.\nBelow, we plot the sigmoid function. Note that when the input is close to 0, the sigmoid\nfunction approaches a linear transformation.\ny=torch .sigmoid(x)\nd2l.plot(x .detach(), y .detach(), 'x','sigmoid(x) ', figsize =(5,2.5))\nThe derivative of the sigmoid function is given by the following equation:\n\ud835\udc51\n\ud835\udc51\ud835\udc65sigmoid\u00b9\ud835\udc65\u00ba=exp\u00b9\u0000\ud835\udc65\u00ba\n\u00b91\u00b8exp\u00b9\u0000\ud835\udc65\u00ba\u00ba2=sigmoid\u00b9\ud835\udc65\u00ba\u00b91\u0000sigmoid\u00b9\ud835\udc65\u00ba\u00ba. (5.1.7)\nThe derivative of the sigmoid function is plotted below. Note that when the input is 0, the\nderivative of the sigmoid function reaches a maximum of 0.25. As the input diverges from\n0 in either direction, the derivative approaches 0.\n# Clear out previous gradients\nx.grad .data .zero_()\ny.backward(torch .ones_like(x),retain_graph =True )\nd2l.plot(x .detach(), x .grad, 'x','grad of sigmoid ', figsize =(5,2.5))\nTanhFunction\nLike the sigmoid function, the tanh (hyperbolic tangent) function also squashes its inputs,\ntransforming them into elements on the interval between \u00001and1:\ntanh\u00b9\ud835\udc65\u00ba=1\u0000exp\u00b9\u00002\ud835\udc65\u00ba\n1\u00b8exp\u00b9\u00002\ud835\udc65\u00ba. (5.1.8)\n174 Multilayer Perceptrons\nWe plot the tanh function below.", "mimetype": "text/plain", "start_char_idx": 452862, "end_char_idx": 456558, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e52f0545-4c18-4c46-aac1-03b7a67a2325": {"__data__": {"id_": "e52f0545-4c18-4c46-aac1-03b7a67a2325", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2ed174eb-26fb-4e1d-a551-23eb0479a4b7", "node_type": "1", "metadata": {}, "hash": "a98fb549b4dd9e33abff1d668db9301771e969f4767608f3ae081ca99e48b7f6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f2093f11-86bb-4398-a654-bebe23434c35", "node_type": "1", "metadata": {}, "hash": "6c5a612d74feb94574d173472fa1f1ea47d901c5274d1fec481ec81529c68ca1", "class_name": "RelatedNodeInfo"}}, "text": "Note that when the input is 0, the\nderivative of the sigmoid function reaches a maximum of 0.25. As the input diverges from\n0 in either direction, the derivative approaches 0.\n# Clear out previous gradients\nx.grad .data .zero_()\ny.backward(torch .ones_like(x),retain_graph =True )\nd2l.plot(x .detach(), x .grad, 'x','grad of sigmoid ', figsize =(5,2.5))\nTanhFunction\nLike the sigmoid function, the tanh (hyperbolic tangent) function also squashes its inputs,\ntransforming them into elements on the interval between \u00001and1:\ntanh\u00b9\ud835\udc65\u00ba=1\u0000exp\u00b9\u00002\ud835\udc65\u00ba\n1\u00b8exp\u00b9\u00002\ud835\udc65\u00ba. (5.1.8)\n174 Multilayer Perceptrons\nWe plot the tanh function below. Note that as input nears 0, the tanh function approaches a\nlinear transformation. Although the shape of the function is similar to that of the sigmoid\nfunction, the tanh function exhibits point symmetry about the origin of the coordinate sys-\ntem (Kalman and Kwasny, 1992 ).\ny=torch .tanh(x)\nd2l.plot(x .detach(), y .detach(), 'x','tanh(x) ', figsize =(5,2.5))\nThe derivative of the tanh function is:\n\ud835\udc51\n\ud835\udc51\ud835\udc65tanh\u00b9\ud835\udc65\u00ba=1\u0000tanh2\u00b9\ud835\udc65\u00ba. (5.1.9)\nIt is plotted below. As the input nears 0, the derivative of the tanh function approaches a\nmaximum of 1. And as we saw with the sigmoid function, as input moves away from 0 in\neither direction, the derivative of the tanh function approaches 0.\n# Clear out previous gradients\nx.grad .data .zero_()\ny.backward(torch .ones_like(x),retain_graph =True )\nd2l.plot(x .detach(), x .grad, 'x','grad of tanh ', figsize =(5,2.5))\n5.1.3Summaryand Discussion\nWe now know how to incorporate nonlinearities to build expressive multilayer neural net-\nwork architectures. As a side note, your knowledge already puts you in command of a sim-\nilar toolkit to a practitioner circa 1990. In some ways, you have an advantage over anyone\n175 Multilayer Perceptrons\n102working back then, because you can leverage powerful open-source deep learning frame-\nworks to build models rapidly, using only a few lines of code. Previously, training these\nnetworks required researchers to code up layers and derivatives explicitly in C, Fortran, or\neven Lisp (in the case of LeNet).\nA secondary benefit is that ReLU is significantly more amenable to optimization than the\nsigmoid or the tanh function. One could argue that this was one of the key innovations that\nhelped the resurgence of deep learning over the past decade. Note, though, that research in\nactivation functions has not stopped. For instance, the GELU (Gaussian error linear unit)\nactivationfunction \ud835\udc65\u03a6\u00b9\ud835\udc65\u00babyHendrycksandGimpel( 2016)(\u03a6\u00b9\ud835\udc65\u00baisthestandardGaussian\ncumulative distribution function) and the Swish activation function \ud835\udf0e\u00b9\ud835\udc65\u00ba=\ud835\udc65sigmoid\u00b9\ud835\udefd\ud835\udc65\u00ba\nasproposedinRamachandran etal.(2017)canyieldbetteraccuracyinmanycases.\n5.1.4Exercises\n1.Show that adding layers to a lineardeep network, i.e., a network without nonlinearity\n\ud835\udf0ecan never increase the expressive power of the network. Give an example where it\nactively reduces it.\n2.Compute the derivative of the pReLU activation function.\n3.Compute the derivative of the Swish activation function \ud835\udc65sigmoid\u00b9\ud835\udefd\ud835\udc65\u00ba.\n4.Show that an MLP using only ReLU (or pReLU) constructs a continuous piecewise\nlinear function.\n5.Sigmoid and tanh are very similar.\n1.Show that tanh\u00b9\ud835\udc65\u00ba\u00b81=2 sigmoid\u00b92\ud835\udc65\u00ba.\n2.Prove that the function classes parametrized by both nonlinearities are identical.\nHint: affine layers have bias terms, too.\n6.Assume that we have a nonlinearity that applies to one minibatch at a time, such as the\nbatch normalization ( Ioffe and Szegedy, 2015 ). What kinds of problems do you expect\nthis to cause?\n7.Provide an example where the gradients vanish for the sigmoid activation function.\nDiscussions102.", "mimetype": "text/plain", "start_char_idx": 455937, "end_char_idx": 459565, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f2093f11-86bb-4398-a654-bebe23434c35": {"__data__": {"id_": "f2093f11-86bb-4398-a654-bebe23434c35", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e52f0545-4c18-4c46-aac1-03b7a67a2325", "node_type": "1", "metadata": {}, "hash": "cabbcfad5a5f30204eb49781acef4b3dbb134e00b3146249e3563b345b51b484", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3ab35daa-7256-412f-8002-02e9b91c77d8", "node_type": "1", "metadata": {}, "hash": "9f84361667124332d307d0b9386f74b2ad49329df3d77e80fa934fad7d302573", "class_name": "RelatedNodeInfo"}}, "text": "Give an example where it\nactively reduces it.\n2.Compute the derivative of the pReLU activation function.\n3.Compute the derivative of the Swish activation function \ud835\udc65sigmoid\u00b9\ud835\udefd\ud835\udc65\u00ba.\n4.Show that an MLP using only ReLU (or pReLU) constructs a continuous piecewise\nlinear function.\n5.Sigmoid and tanh are very similar.\n1.Show that tanh\u00b9\ud835\udc65\u00ba\u00b81=2 sigmoid\u00b92\ud835\udc65\u00ba.\n2.Prove that the function classes parametrized by both nonlinearities are identical.\nHint: affine layers have bias terms, too.\n6.Assume that we have a nonlinearity that applies to one minibatch at a time, such as the\nbatch normalization ( Ioffe and Szegedy, 2015 ). What kinds of problems do you expect\nthis to cause?\n7.Provide an example where the gradients vanish for the sigmoid activation function.\nDiscussions102.\n176 Multilayer Perceptrons\n5.2Implementation of MultilayerPerceptrons\nMultilayerperceptrons(MLPs)arenotmuchmorecomplextoimplementthansimplelinear\nmodels. The key conceptual difference is that we now concatenate multiple layers.\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n5.2.1Implementation fromScratch\nLet\u2019s begin again by implementing such a network from scratch.\nInitializingModel Parameters\nRecall that Fashion-MNIST contains 10 classes, and that each image consists of a 28\u0002\n28=784grid of grayscale pixel values. As before we will disregard the spatial structure\namong the pixels for now, so we can think of this as a classification dataset with 784 input\nfeaturesand10classes. Tobegin,wewillimplementanMLPwithonehiddenlayerand256\nhidden units. Both the number of layersand their width are adjustable(theyare considered\nhyperparameters). Typically, wechoosethelayerwidthstobedivisiblebylargerpowersof\n2. This is computationally efficient due to the way memory is allocated and addressed in\nhardware.\nAgain, we will represent our parameters with several tensors. Note that foreverylayer , we\nmust keep track of one weight matrix and one bias vector. As always, we allocate memory\nfor the gradients of the loss with respect to these parameters.\nIn the code below we use nn.Parameter to automatically register a class attribute as a\nparameter to be tracked by autograd (Section 2.5 ).\nclass MLPScratch (d2l .Classifier):\ndef __init__ (self , num_inputs, num_outputs, num_hiddens, lr, sigma =0.01 ):\nsuper ().__init__ ()\nself .save_hyperparameters()\nself .W1=nn.Parameter(torch .randn(num_inputs, num_hiddens) *sigma)\nself .b1=nn.Parameter(torch .zeros(num_hiddens))\nself .W2=nn.Parameter(torch .randn(num_hiddens, num_outputs) *sigma)\nself .b2=nn.Parameter(torch .zeros(num_outputs))\nModel\nTo make sure we know how everything works, we will implement the ReLU activation\nourselves rather than invoking the built-in relufunction directly.\n177 Implementation of Multilayer Perceptrons\ndef relu (X):\na=torch .zeros_like(X)\nreturn torch .max(X, a)\nSince we are disregarding spatial structure, we reshape each two-dimensional image into\na flat vector of length num_inputs . Finally, we implement our model with just a few lines\nof code. Since we use the framework built-in autograd this is all that it takes.\n@d2l .add_to_class(MLPScratch)\ndef forward (self , X):\nX=X.reshape(( -1,self .num_inputs))\nH=relu(torch .matmul(X, self .W1) +self .b1)\nreturn torch .matmul(H, self .W2) +self .b2\nTraining\nFortunately, the training loop for MLPs is exactly the same as for softmax regression.\nWe define the model, data, and trainer, then finally invoke the fitmethod on model and\ndata.\nmodel =MLPScratch(num_inputs =784, num_outputs =10, num_hiddens =256, lr =0.1)\ndata =d2l.FashionMNIST(batch_size =256)\ntrainer =d2l.Trainer(max_epochs =10)\ntrainer .fit(model, data)\n5.2.2Concise Implementation\nAs you might expect, by relying on the high-level APIs, we can implement MLPs even\nmore concisely.", "mimetype": "text/plain", "start_char_idx": 458799, "end_char_idx": 462568, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3ab35daa-7256-412f-8002-02e9b91c77d8": {"__data__": {"id_": "3ab35daa-7256-412f-8002-02e9b91c77d8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f2093f11-86bb-4398-a654-bebe23434c35", "node_type": "1", "metadata": {}, "hash": "6c5a612d74feb94574d173472fa1f1ea47d901c5274d1fec481ec81529c68ca1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d6691739-074e-48f3-9292-85590786444e", "node_type": "1", "metadata": {}, "hash": "b25a3cdcf20c893a4c6f9b3c869625c66801a0ca9354d2119689475d5cca5f31", "class_name": "RelatedNodeInfo"}}, "text": "We define the model, data, and trainer, then finally invoke the fitmethod on model and\ndata.\nmodel =MLPScratch(num_inputs =784, num_outputs =10, num_hiddens =256, lr =0.1)\ndata =d2l.FashionMNIST(batch_size =256)\ntrainer =d2l.Trainer(max_epochs =10)\ntrainer .fit(model, data)\n5.2.2Concise Implementation\nAs you might expect, by relying on the high-level APIs, we can implement MLPs even\nmore concisely.\nModel\nComparedwithourconciseimplementationofsoftmaxregressionimplementation( Section\n4.5),theonlydifferenceisthatweadd twofullyconnectedlayerswherewepreviouslyadded\nonlyone. The first is the hidden layer, the second is the output layer.\n178 Multilayer Perceptrons\nclass MLP(d2l .Classifier):\ndef __init__ (self , num_outputs, num_hiddens, lr):\nsuper ().__init__ ()\nself .save_hyperparameters()\nself .net =nn.Sequential(nn .Flatten(), nn .LazyLinear(num_hiddens),\nnn.ReLU(), nn .LazyLinear(num_outputs))\nPreviously, we defined forward methods for models to transform input using the model\nparameters. These operations are essentially a pipeline: you take an input and apply a\ntransformation (e.g., matrix multiplication with weights followed by bias addition), then\nrepetitively use the output of the current transformation as input to the next transforma-\ntion. However, you may have noticed that no forward method is defined here. In fact,\nMLPinherits the forward method from the Moduleclass (Section 3.2.2 ) to simply invoke\nself.net(X) (Xis input), which is now defined as a sequence of transformations via the\nSequential class. The Sequential class abstracts the forward process enabling us to fo-\ncus on the transformations. We will further discuss how the Sequential class works in\nSection 6.1.2 .\nTraining\nThe training loop is exactly the same as when we implemented softmax regression. This\nmodularity enables us to separate matters concerning the model architecture from orthog-\nonal considerations.\nmodel =MLP(num_outputs =10, num_hiddens =256, lr =0.1)\ntrainer .fit(model, data)\n5.2.3Summary\nNow that we have more practice in designing deep networks, the step from a single to mul-\ntiple layers of deep networks does not pose such a significant challenge any longer. In\nparticular, we can reuse the training algorithm and data loader. Note, though, that imple-\nmenting MLPs from scratch is nonetheless messy: naming and keeping track of the model\nparameters makes it difficult to extend models. For instance, imagine wanting to insert\nanotherlayerbetweenlayers42and43. Thismightnowbelayer42b,unlesswearewilling\n179 Implementation of Multilayer Perceptrons\n103to perform sequential renaming. Moreover, if we implement the network from scratch, it\nis much more difficult for the framework to perform meaningful performance optimiza-\ntions.\nNonetheless, you have now reached the state of the art of the late 1980s when fully con-\nnected deep networks were the method of choice for neural network modeling. Our next\nconceptual step will be to consider images. Before we do so, we need to review a number\nof statistical basics and details on how to compute models efficiently.\n5.2.4Exercises\n1.Change the number of hidden units num_hiddens and plot how its number affects the\naccuracy of the model. What is the best value of this hyperparameter?\n2.Try adding a hidden layer to see how it affects the results.\n3.Whyisitabadideatoinsertahiddenlayerwithasingleneuron? Whatcouldgowrong?\n4.Howdoeschangingthelearningratealteryourresults? Withallotherparametersfixed,\nwhich learning rate gives you the best results? How does this relate to the number of\nepochs?\n5.Let\u2019s optimize over all hyperparameters jointly, i.e., learning rate, number of epochs,\nnumber of hidden layers, and number of hidden units per layer.\n1.What is the best result you can get by optimizing over all of them?\n2.Why it is much more challenging to deal with multiple hyperparameters?\n3.Describe an efficient strategy for optimizing over multiple parameters jointly.\n6.Compare the speed of the framework and the from-scratch implementation for a chal-\nlenging problem. How does it change with the complexity of the network?\n7.Measure the speed of tensor\u2013matrix multiplications for well-aligned and misaligned\nmatrices.", "mimetype": "text/plain", "start_char_idx": 462167, "end_char_idx": 466360, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d6691739-074e-48f3-9292-85590786444e": {"__data__": {"id_": "d6691739-074e-48f3-9292-85590786444e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3ab35daa-7256-412f-8002-02e9b91c77d8", "node_type": "1", "metadata": {}, "hash": "9f84361667124332d307d0b9386f74b2ad49329df3d77e80fa934fad7d302573", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2e72b2fb-798d-4849-9166-c72eca0958aa", "node_type": "1", "metadata": {}, "hash": "716f01897b38b3bd0f39c1c27c8a34b23bd2cff3db5fe3b15f5ad8ef1defe5f8", "class_name": "RelatedNodeInfo"}}, "text": "3.Whyisitabadideatoinsertahiddenlayerwithasingleneuron? Whatcouldgowrong?\n4.Howdoeschangingthelearningratealteryourresults? Withallotherparametersfixed,\nwhich learning rate gives you the best results? How does this relate to the number of\nepochs?\n5.Let\u2019s optimize over all hyperparameters jointly, i.e., learning rate, number of epochs,\nnumber of hidden layers, and number of hidden units per layer.\n1.What is the best result you can get by optimizing over all of them?\n2.Why it is much more challenging to deal with multiple hyperparameters?\n3.Describe an efficient strategy for optimizing over multiple parameters jointly.\n6.Compare the speed of the framework and the from-scratch implementation for a chal-\nlenging problem. How does it change with the complexity of the network?\n7.Measure the speed of tensor\u2013matrix multiplications for well-aligned and misaligned\nmatrices. For instance, test for matrices with dimension 1024, 1025, 1026, 1028, and\n1032.\n1.How does this change between GPUs and CPUs?\n2.Determine the memory bus width of your CPU and GPU.\n8.Try out different activation functions. Which one works best?\n9.Is there a difference between weight initializations of the network? Does it matter?\nDiscussions103.\n180 Multilayer Perceptrons\n5.3ForwardPropagation,BackwardPropagation,\nand Computational Graphs\nSo far, we have trained our models with minibatch stochastic gradient descent. However,\nwhen we implemented the algorithm, we only worried about the calculations involved in\nforwardpropagation through the model. When it came time to calculate the gradients, we\njustinvokedthebackpropagationfunctionprovidedbythedeeplearningframework.\nThe automatic calculation of gradients profoundly simplifies the implementation of deep\nlearning algorithms. Before automatic differentiation, even small changes to complicated\nmodels required recalculating complicated derivatives by hand. Surprisingly often, aca-\ndemic papers had to allocate numerous pages to deriving update rules. While we must\ncontinue to rely on automatic differentiation so we can focus on the interesting parts, you\nought to know how these gradients are calculated under the hood if you want to go beyond\na shallow understanding of deep learning.\nIn this section, we take a deep dive into the details of backward propagation (more com-\nmonly called backpropagation ). To convey some insight for both the techniques and their\nimplementations, we rely on some basic mathematics and computational graphs. To start,\nwe focus our exposition on a one-hidden-layer MLP with weight decay ( \u21132regularization,\nto be described in subsequent chapters).\n5.3.1ForwardPropagation\nForwardpropagation (orforwardpass )referstothecalculationandstorageofintermediate\nvariables(includingoutputs)foraneuralnetworkinorderfromtheinputlayertotheoutput\nlayer. We now work step-by-step through the mechanics of a neural network with one\nhiddenlayer. ThismayseemtediousbutintheeternalwordsoffunkvirtuosoJamesBrown,\nyou must \u201cpay the cost to be the boss\u201d.\nForthesakeofsimplicity,let\u2019sassumethattheinputexampleis x2R\ud835\udc51andthatourhidden\nlayer does not include a bias term. Here the intermediate variable is:\nz=W\u00b91\u00bax, (5.3.1)\nwhere W\u00b91\u00ba2R\u210e\u0002\ud835\udc51is the weight parameter of the hidden layer. After running the inter-\nmediate variable z2R\u210ethrough the activation function \ud835\udf19we obtain our hidden activation\nvector of length \u210e:\nh=\ud835\udf19\u00b9z\u00ba. (5.3.2)\nThe hidden layer output his also an intermediate variable. Assuming that the parameters\nof the output layer possess only a weight of W\u00b92\u00ba2R\ud835\udc5e\u0002\u210e, we can obtain an output layer\nvariable with a vector of length \ud835\udc5e:\no=W\u00b92\u00bah. (5.3.3)\n181 Forward Propagation, Backward Propagation, and Computational Graphs\nAssuming that the loss function is \ud835\udc59and the example label is \ud835\udc66, we can then calculate the\nloss term for a single data example,\n\ud835\udc3f=\ud835\udc59\u00b9o,\ud835\udc66\u00ba.", "mimetype": "text/plain", "start_char_idx": 465484, "end_char_idx": 469297, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2e72b2fb-798d-4849-9166-c72eca0958aa": {"__data__": {"id_": "2e72b2fb-798d-4849-9166-c72eca0958aa", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d6691739-074e-48f3-9292-85590786444e", "node_type": "1", "metadata": {}, "hash": "b25a3cdcf20c893a4c6f9b3c869625c66801a0ca9354d2119689475d5cca5f31", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "34d82bf9-550f-4600-b65f-91b0e3c2f36a", "node_type": "1", "metadata": {}, "hash": "27fa44f948eed926aa0e41730fce13ad43235877bc2849349a62d436f48e92d9", "class_name": "RelatedNodeInfo"}}, "text": "After running the inter-\nmediate variable z2R\u210ethrough the activation function \ud835\udf19we obtain our hidden activation\nvector of length \u210e:\nh=\ud835\udf19\u00b9z\u00ba. (5.3.2)\nThe hidden layer output his also an intermediate variable. Assuming that the parameters\nof the output layer possess only a weight of W\u00b92\u00ba2R\ud835\udc5e\u0002\u210e, we can obtain an output layer\nvariable with a vector of length \ud835\udc5e:\no=W\u00b92\u00bah. (5.3.3)\n181 Forward Propagation, Backward Propagation, and Computational Graphs\nAssuming that the loss function is \ud835\udc59and the example label is \ud835\udc66, we can then calculate the\nloss term for a single data example,\n\ud835\udc3f=\ud835\udc59\u00b9o,\ud835\udc66\u00ba. (5.3.4)\nAs we will see the definition of \u21132regularization to be introduced later, given the hyperpa-\nrameter\ud835\udf06, the regularization term is\n\ud835\udc60=\ud835\udf06\n2\u0010\nkW\u00b91\u00bak2\nF\u00b8kW\u00b92\u00bak2\nF\u0011\n, (5.3.5)\nwhere the Frobenius norm of the matrix is simply the \u21132norm applied after flattening the\nmatrixintoavector. Finally,themodel\u2019sregularizedlossonagivendataexampleis:\n\ud835\udc3d=\ud835\udc3f\u00b8\ud835\udc60. (5.3.6)\nWe refer to\ud835\udc3das theobjectivefunction in the following discussion.\n5.3.2Computational Graph of ForwardPropagation\nPlottingcomputational graphs helps us visualize the dependencies of operators and vari-\nables within the calculation. Fig. 5.3.1 contains the graph associated with the simple net-\nwork described above, where squares denote variables and circles denote operators. The\nlower-left corner signifies the input and the upper-right corner is the output. Notice that\nthe directions of the arrows (which illustrate data flow) are primarily rightward and up-\nward.\ntFig. 5.3.1 Computational graph of forward propagation.\n5.3.3Backpropagation\nBackpropagation refers to the method of calculating the gradient of neural network param-\neters. In short, the method traverses the network in reverse order, from the output to the\ninput layer, according to the chain rule from calculus. The algorithm stores any interme-\ndiate variables (partial derivatives) required while calculating the gradient with respect to\nsome parameters. Assume that we have functions Y=\ud835\udc53\u00b9X\u00baandZ=\ud835\udc54\u00b9Y\u00ba, in which the\ninputandtheoutput X,Y,Zaretensorsofarbitraryshapes. Byusingthechainrule,wecan\ncompute the derivative of Zwith respect to Xvia\n\ud835\udf15Z\n\ud835\udf15X=prod\u0012\ud835\udf15Z\n\ud835\udf15Y,\ud835\udf15Y\n\ud835\udf15X\u0013\n. (5.3.7)\nHere we use the prod operator to multiply its arguments after the necessary operations,\nsuch as transposition and swapping input positions, have been carried out. For vectors,\nthis is straightforward: it is simply matrix\u2013matrix multiplication. For higher dimensional\n182 Multilayer Perceptrons\ntensors, we use the appropriate counterpart. The operator prod hides all the notational\noverhead.\nRecall that the parameters of the simple network with one hidden layer, whose computa-\ntional graph is in Fig. 5.3.1 , areW\u00b91\u00baandW\u00b92\u00ba. The objective of backpropagation is to\ncalculate the gradients \ud835\udf15\ud835\udc3d\u009d\ud835\udf15W\u00b91\u00baand\ud835\udf15\ud835\udc3d\u009d\ud835\udf15W\u00b92\u00ba. To accomplish this, we apply the chain\nrule and calculate, in turn, the gradient of each intermediate variable and parameter. The\norderofcalculationsarereversedrelativetothoseperformedinforwardpropagation, since\nwe need to start with the outcome of the computational graph and work our way towards\ntheparameters. Thefirststepistocalculatethegradientsoftheobjectivefunction \ud835\udc3d=\ud835\udc3f\u00b8\ud835\udc60\nwith respect to the loss term \ud835\udc3fand the regularization term \ud835\udc60:\n\ud835\udf15\ud835\udc3d\n\ud835\udf15\ud835\udc3f=1and\ud835\udf15\ud835\udc3d\n\ud835\udf15\ud835\udc60=1.", "mimetype": "text/plain", "start_char_idx": 468715, "end_char_idx": 471969, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "34d82bf9-550f-4600-b65f-91b0e3c2f36a": {"__data__": {"id_": "34d82bf9-550f-4600-b65f-91b0e3c2f36a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2e72b2fb-798d-4849-9166-c72eca0958aa", "node_type": "1", "metadata": {}, "hash": "716f01897b38b3bd0f39c1c27c8a34b23bd2cff3db5fe3b15f5ad8ef1defe5f8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bf905f9e-d201-4976-9232-93deab333e01", "node_type": "1", "metadata": {}, "hash": "e0d6deac08c0bb31f4f628e8f2dcac22e93d61dcd63f741d577b96ad93c7a074", "class_name": "RelatedNodeInfo"}}, "text": "The objective of backpropagation is to\ncalculate the gradients \ud835\udf15\ud835\udc3d\u009d\ud835\udf15W\u00b91\u00baand\ud835\udf15\ud835\udc3d\u009d\ud835\udf15W\u00b92\u00ba. To accomplish this, we apply the chain\nrule and calculate, in turn, the gradient of each intermediate variable and parameter. The\norderofcalculationsarereversedrelativetothoseperformedinforwardpropagation, since\nwe need to start with the outcome of the computational graph and work our way towards\ntheparameters. Thefirststepistocalculatethegradientsoftheobjectivefunction \ud835\udc3d=\ud835\udc3f\u00b8\ud835\udc60\nwith respect to the loss term \ud835\udc3fand the regularization term \ud835\udc60:\n\ud835\udf15\ud835\udc3d\n\ud835\udf15\ud835\udc3f=1and\ud835\udf15\ud835\udc3d\n\ud835\udf15\ud835\udc60=1. (5.3.8)\nNext, we compute the gradient of the objective function with respect to variable of the\noutput layer oaccording to the chain rule:\n\ud835\udf15\ud835\udc3d\n\ud835\udf15o=prod\u0012\ud835\udf15\ud835\udc3d\n\ud835\udf15\ud835\udc3f,\ud835\udf15\ud835\udc3f\n\ud835\udf15o\u0013\n=\ud835\udf15\ud835\udc3f\n\ud835\udf15o2R\ud835\udc5e. (5.3.9)\nNext, we calculate the gradients of the regularization term with respect to both parame-\nters:\n\ud835\udf15\ud835\udc60\n\ud835\udf15W\u00b91\u00ba=\ud835\udf06W\u00b91\u00baand\ud835\udf15\ud835\udc60\n\ud835\udf15W\u00b92\u00ba=\ud835\udf06W\u00b92\u00ba. (5.3.10)\nNow we are able to calculate the gradient \ud835\udf15\ud835\udc3d\u009d\ud835\udf15W\u00b92\u00ba2R\ud835\udc5e\u0002\u210eof the model parameters\nclosest to the output layer. Using the chain rule yields:\n\ud835\udf15\ud835\udc3d\n\ud835\udf15W\u00b92\u00ba=prod\u0012\ud835\udf15\ud835\udc3d\n\ud835\udf15o,\ud835\udf15o\n\ud835\udf15W\u00b92\u00ba\u0013\n\u00b8prod\u0012\ud835\udf15\ud835\udc3d\n\ud835\udf15\ud835\udc60,\ud835\udf15\ud835\udc60\n\ud835\udf15W\u00b92\u00ba\u0013\n=\ud835\udf15\ud835\udc3d\n\ud835\udf15oh>\u00b8\ud835\udf06W\u00b92\u00ba. (5.3.11)\nTo obtain the gradient with respect to W\u00b91\u00bawe need to continue backpropagation along\nthe output layer to the hidden layer. The gradient with respect to the hidden layer output\n\ud835\udf15\ud835\udc3d\u009d\ud835\udf15h2R\u210eis given by\n\ud835\udf15\ud835\udc3d\n\ud835\udf15h=prod\u0012\ud835\udf15\ud835\udc3d\n\ud835\udf15o,\ud835\udf15o\n\ud835\udf15h\u0013\n=W\u00b92\u00ba>\ud835\udf15\ud835\udc3d\n\ud835\udf15o. (5.3.12)\nSince the activation function \ud835\udf19applies elementwise, calculating the gradient \ud835\udf15\ud835\udc3d\u009d\ud835\udf15z2R\u210e\noftheintermediatevariable zrequiresthatweusetheelementwisemultiplicationoperator,\nwhich we denote by \f:\n\ud835\udf15\ud835\udc3d\n\ud835\udf15z=prod\u0012\ud835\udf15\ud835\udc3d\n\ud835\udf15h,\ud835\udf15h\n\ud835\udf15z\u0013\n=\ud835\udf15\ud835\udc3d\n\ud835\udf15h\f\ud835\udf190\u00b9z\u00ba. (5.3.13)\nFinally, we can obtain the gradient \ud835\udf15\ud835\udc3d\u009d\ud835\udf15W\u00b91\u00ba2R\u210e\u0002\ud835\udc51of the model parameters closest to\nthe input layer. According to the chain rule, we get\n\ud835\udf15\ud835\udc3d\n\ud835\udf15W\u00b91\u00ba=prod\u0012\ud835\udf15\ud835\udc3d\n\ud835\udf15z,\ud835\udf15z\n\ud835\udf15W\u00b91\u00ba\u0013\n\u00b8prod\u0012\ud835\udf15\ud835\udc3d\n\ud835\udf15\ud835\udc60,\ud835\udf15\ud835\udc60\n\ud835\udf15W\u00b91\u00ba\u0013\n=\ud835\udf15\ud835\udc3d\n\ud835\udf15zx>\u00b8\ud835\udf06W\u00b91\u00ba. (5.3.14)\n183 Forward Propagation, Backward Propagation, and Computational Graphs\n5.3.4TrainingNeuralNetworks\nWhen training neural networks, forward and backward propagation depend on each other.\nIn particular, for forward propagation, we traverse the computational graph in the direc-\ntion of dependencies and compute all the variables on its path. These are then used for\nbackpropagation where the compute order on the graph is reversed.", "mimetype": "text/plain", "start_char_idx": 471426, "end_char_idx": 473625, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bf905f9e-d201-4976-9232-93deab333e01": {"__data__": {"id_": "bf905f9e-d201-4976-9232-93deab333e01", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "34d82bf9-550f-4600-b65f-91b0e3c2f36a", "node_type": "1", "metadata": {}, "hash": "27fa44f948eed926aa0e41730fce13ad43235877bc2849349a62d436f48e92d9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a57bbc41-33ce-4b4f-8054-4e67b9c22e1b", "node_type": "1", "metadata": {}, "hash": "4826c3bc1e8d4a81342015c835300a4101d81a6ae67532c165afff837381964b", "class_name": "RelatedNodeInfo"}}, "text": "(5.3.14)\n183 Forward Propagation, Backward Propagation, and Computational Graphs\n5.3.4TrainingNeuralNetworks\nWhen training neural networks, forward and backward propagation depend on each other.\nIn particular, for forward propagation, we traverse the computational graph in the direc-\ntion of dependencies and compute all the variables on its path. These are then used for\nbackpropagation where the compute order on the graph is reversed.\nTaketheaforementionedsimplenetworkasanillustrativeexample. Ontheonehand,com-\nputing the regularization term (5.3.5 )during forward propagation depends on the current\nvaluesofmodelparameters W\u00b91\u00baandW\u00b92\u00ba. Theyaregivenbytheoptimizationalgorithm\naccording to backpropagation in the most recent iteration. On the other hand, the gradient\ncalculationfortheparameter (5.3.11 )duringbackpropagationdependsonthecurrentvalue\nof the hidden layer output h, which is given by forward propagation.\nTherefore when training neural networks, once model parameters are initialized, we alter-\nnate forward propagation with backpropagation, updating model parameters using gradi-\nents given by backpropagation. Note that backpropagation reuses the stored intermediate\nvalues from forward propagation to avoid duplicate calculations. One of the consequences\nis that we need to retain the intermediate values until backpropagation is complete. This is\nalso one of the reasons whytraining requires significantly more memory than plain predic-\ntion. Besides, thesizeofsuchintermediatevaluesisroughlyproportionaltothenumberof\nnetwork layers and the batch size. Thus, training deeper networks using larger batch sizes\nmore easily leads to out-of-memory errors.\n5.3.5Summary\nForward propagation sequentially calculates and stores intermediate variables within the\ncomputational graph defined by the neural network. It proceeds from the input to the out-\nput layer. Backpropagation sequentially calculates and stores the gradients of intermediate\nvariables and parameters within the neural network in the reversed order. When training\ndeep learning models, forward propagation and backpropagation are interdependent, and\ntraining requires significantly more memory than prediction.\n5.3.6Exercises\n1.Assume that the inputs Xto some scalar function \ud835\udc53are\ud835\udc5b\u0002\ud835\udc5amatrices. What is the\ndimensionality of the gradient of \ud835\udc53with respect to X?\n2.Add a bias to the hidden layer of the model described in this section (you do not need\nto include bias in the regularization term).\n1.Draw the corresponding computational graph.\n2.Derive the forward and backward propagation equations.\n3.Computethememoryfootprintfortrainingandpredictioninthemodeldescribedinthis\nsection.\n4.Assume that you want to compute second derivatives. What happens to the computa-\ntional graph? How long do you expect the calculation to take?\n184 Multilayer Perceptrons\n1045.Assume that the computational graph is too large for your GPU.\n1.Can you partition it over more than one GPU?\n2.What are the advantages and disadvantages over training on a smaller minibatch?\nDiscussions104.\n5.4NumericalStability and Initialization\nThus far, every model that we have implemented required that we initialize its parameters\naccording to some pre-specified distribution. Until now, we took the initialization scheme\nfor granted, glossing over the details of how these choices are made. You might have even\ngotten the impression that these choices are not especially important. On the contrary, the\nchoice of initialization scheme plays a significant role in neural network learning, and it\ncan be crucial for maintaining numerical stability. Moreover, these choices can be tied up\nin interesting ways with the choice of the nonlinear activation function. Which function\nwe choose and how we initialize parameters can determine how quickly our optimization\nalgorithm converges. Poor choices here can cause us to encounter exploding or vanishing\ngradients while training. In this section, we delve into these topics in greater detail and\ndiscuss some useful heuristics that you will find useful throughout your career in deep\nlearning.", "mimetype": "text/plain", "start_char_idx": 473187, "end_char_idx": 477275, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a57bbc41-33ce-4b4f-8054-4e67b9c22e1b": {"__data__": {"id_": "a57bbc41-33ce-4b4f-8054-4e67b9c22e1b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bf905f9e-d201-4976-9232-93deab333e01", "node_type": "1", "metadata": {}, "hash": "e0d6deac08c0bb31f4f628e8f2dcac22e93d61dcd63f741d577b96ad93c7a074", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "216bc339-c5f9-4b5d-b18b-6fb154833903", "node_type": "1", "metadata": {}, "hash": "d6a4ecc8767b7a350bd03515a795688c10544eedf070c14742ec7b45688cfaf2", "class_name": "RelatedNodeInfo"}}, "text": "Until now, we took the initialization scheme\nfor granted, glossing over the details of how these choices are made. You might have even\ngotten the impression that these choices are not especially important. On the contrary, the\nchoice of initialization scheme plays a significant role in neural network learning, and it\ncan be crucial for maintaining numerical stability. Moreover, these choices can be tied up\nin interesting ways with the choice of the nonlinear activation function. Which function\nwe choose and how we initialize parameters can determine how quickly our optimization\nalgorithm converges. Poor choices here can cause us to encounter exploding or vanishing\ngradients while training. In this section, we delve into these topics in greater detail and\ndiscuss some useful heuristics that you will find useful throughout your career in deep\nlearning.\n%matplotlib inline\nimport torch\nfrom d2l import torch asd2l\n5.4.1Vanishingand Exploding Gradients\nConsider a deep network with \ud835\udc3flayers, input xand output o. With each layer \ud835\udc59defined by\na transformation \ud835\udc53\ud835\udc59parametrized by weights W\u00b9\ud835\udc59\u00ba, whose hidden layer output is h\u00b9\ud835\udc59\u00ba(let\nh\u00b90\u00ba=x), our network can be expressed as:\nh\u00b9\ud835\udc59\u00ba=\ud835\udc53\ud835\udc59\u00b9h\u00b9\ud835\udc59\u00001\u00ba\u00baand thus o=\ud835\udc53\ud835\udc3f\u000e\u0001\u0001\u0001\u000e\ud835\udc531\u00b9x\u00ba. (5.4.1)\nIf all the hidden layer output and the input are vectors, we can write the gradient of owith\nrespect to any set of parameters W\u00b9\ud835\udc59\u00baas follows:\n\ud835\udf15W\u00b9\ud835\udc59\u00bao=\ud835\udf15h\u00b9\ud835\udc3f\u00001\u00bah\u00b9\ud835\udc3f\u00ba\n|        {z        }\nM\u00b9\ud835\udc3f\u00badef=\u0001\u0001\u0001\ud835\udf15h\u00b9\ud835\udc59\u00bah\u00b9\ud835\udc59\u00b81\u00ba\n|      {z      }\nM\u00b9\ud835\udc59\u00b81\u00badef=\ud835\udf15W\u00b9\ud835\udc59\u00bah\u00b9\ud835\udc59\u00ba\n|     {z     }\nv\u00b9\ud835\udc59\u00badef=.\n(5.4.2)\nIn other words, this gradient is the product of \ud835\udc3f\u0000\ud835\udc59matrices M\u00b9\ud835\udc3f\u00ba\u0001\u0001\u0001M\u00b9\ud835\udc59\u00b81\u00baand the\ngradientvector v\u00b9\ud835\udc59\u00ba. Thuswearesusceptibletothesameproblemsofnumericalunderflow\nthat often crop up when multiplying together too many probabilities. When dealing with\nprobabilities, a common trick is to switch into log-space, i.e., shifting pressure from the\n185 Numerical Stability and Initialization\nmantissatotheexponentofthenumericalrepresentation. Unfortunately,ourproblemabove\nis more serious: initially the matrices M\u00b9\ud835\udc59\u00bamay have a wide variety of eigenvalues. They\nmight be small or large, and their product might be very large orvery small .\nThe risks posed by unstable gradients go beyond numerical representation. Gradients of\nunpredictablemagnitudealsothreatenthestabilityofouroptimizationalgorithms. Wemay\nbe facing parameter updates that are either (i) excessively large, destroying our model (the\nexploding gradient problem); or (ii) excessively small (the vanishing gradient problem),\nrendering learning impossible as parameters hardly move on each update.\nVanishingGradients\nOne frequent culprit causing the vanishing gradient problem is the choice of the activation\nfunction\ud835\udf0ethat is appended following each layer\u2019s linear operations. Historically, the sig-\nmoidfunction 1\u009d\u00b91\u00b8exp\u00b9\u0000\ud835\udc65\u00ba\u00ba(introducedin Section5.1 )waspopularbecauseitresembles\na thresholding function. Since early artificial neural networks were inspired by biological\nneural networks, the idea of neurons that fire either fullyornot at all (like biological neu-\nrons) seemed appealing. Let\u2019s take a closer look at the sigmoid to see why it can cause\nvanishing gradients.\nx=torch .arange( -8.0,8.0,0.1, requires_grad =True )\ny=torch .sigmoid(x)\ny.backward(torch .ones_like(x))\nd2l.plot(x .detach() .numpy(), [y .detach() .numpy(), x .grad .numpy()],\nlegend =['sigmoid ','gradient '], figsize =(4.5,2.5))\nAs you can see, the sigmoid\u2019s gradient vanishes both when its inputs are large and when\ntheyaresmall.", "mimetype": "text/plain", "start_char_idx": 476413, "end_char_idx": 479876, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "216bc339-c5f9-4b5d-b18b-6fb154833903": {"__data__": {"id_": "216bc339-c5f9-4b5d-b18b-6fb154833903", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a57bbc41-33ce-4b4f-8054-4e67b9c22e1b", "node_type": "1", "metadata": {}, "hash": "4826c3bc1e8d4a81342015c835300a4101d81a6ae67532c165afff837381964b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c9b34d9f-6621-4f1d-a83c-d2b41d78b178", "node_type": "1", "metadata": {}, "hash": "ffe4cd8df7d7ea2fc4c2c66fbce34ba0e600b06ac1a932a417f22d5f54576718", "class_name": "RelatedNodeInfo"}}, "text": "Since early artificial neural networks were inspired by biological\nneural networks, the idea of neurons that fire either fullyornot at all (like biological neu-\nrons) seemed appealing. Let\u2019s take a closer look at the sigmoid to see why it can cause\nvanishing gradients.\nx=torch .arange( -8.0,8.0,0.1, requires_grad =True )\ny=torch .sigmoid(x)\ny.backward(torch .ones_like(x))\nd2l.plot(x .detach() .numpy(), [y .detach() .numpy(), x .grad .numpy()],\nlegend =['sigmoid ','gradient '], figsize =(4.5,2.5))\nAs you can see, the sigmoid\u2019s gradient vanishes both when its inputs are large and when\ntheyaresmall. Moreover, whenbackpropagatingthroughmanylayers, unlessweareinthe\nGoldilocks zone, where the inputs to many of the sigmoids are close to zero, the gradients\nof the overall product may vanish. When our network boasts many layers, unless we are\ncareful,thegradientwilllikelybecutoffatsomelayer. Indeed,thisproblemusedtoplague\ndeep network training. Consequently, ReLUs, which are more stable (but less neurally\nplausible), have emerged as the default choice for practitioners.\n186 Multilayer Perceptrons\nExplodingGradients\nThe opposite problem, when gradients explode, can be similarly vexing. To illustrate this\na bit better, we draw 100 Gaussian random matrices and multiply them with some initial\nmatrix. Forthescalethatwepicked(thechoiceofthevariance \ud835\udf0e2=1),thematrixproduct\nexplodes. When this happens because of the initialization of a deep network, we have no\nchance of getting a gradient descent optimizer to converge.\nM=torch .normal( 0,1, size =(4,4))\nprint ('a single matrix \\n',M)\nfor iinrange (100):\nM=M@torch .normal( 0,1, size =(4,4))\nprint ('after multiplying 100 matrices \\n', M)\na single matrix\ntensor([[ -0.8755 ,-1.2171 ,1.3316 ,0.1357 ],\n[0.4399 ,1.4073 ,-1.9131 ,-0.4608 ],\n[-2.1420 ,0.3643 ,-0.5267 ,1.0277 ],\n[-0.1734 ,-0.7549 ,2.3024 ,1.3085 ]])\nafter multiplying 100 matrices\ntensor([[ -2.9185e+23 ,1.3915e+25 ,-1.1865e+25 ,1.4354e+24 ],\n[4.9142e+23 ,-2.3430e+25 ,1.9979e+25 ,-2.4169e+24 ],\n[2.6578e+23 ,-1.2672e+25 ,1.0805e+25 ,-1.3072e+24 ],\n[-5.2223e+23 ,2.4899e+25 ,-2.1231e+25 ,2.5684e+24 ]])\nBreakingthe Symmetry\nAnother problem in neural network design is the symmetry inherent in their parametriza-\ntion. Assume that we have a simple MLP with one hidden layer and two units. In this case,\nwe could permute the weights W\u00b91\u00baof the first layer and likewise permute the weights of\nthe output layer to obtain the same function. There is nothing special differentiating the\nfirst and second hidden units. In other words, we have permutation symmetry among the\nhidden units of each layer.\nThis is more than just a theoretical nuisance. Consider the aforementioned one-hidden-\nlayer MLP with two hidden units. For illustration, suppose that the output layer transforms\nthetwohiddenunitsintoonlyoneoutputunit. Imaginewhatwouldhappenifweinitialized\nalltheparameters ofthe hiddenlayeras W\u00b91\u00ba=\ud835\udc50forsomeconstant \ud835\udc50. In thiscase, during\nforwardpropagationeitherhiddenunittakesthesameinputsandparametersproducingthe\nsameactivationwhichisfedtotheoutputunit. Duringbackpropagation,differentiatingthe\noutput unit with respect to parameters W\u00b91\u00bagives a gradient all of whose elements take\nthesamevalue. Thus,aftergradient-basediteration(e.g.,minibatchstochasticgradientde-\nscent),alltheelementsof W\u00b91\u00bastilltakethesamevalue. Suchiterationswouldnever break\nthe symmetry on their own and we might never be able to realize the network\u2019s expressive\npower. The hidden layer would behave as if it had only a single unit.", "mimetype": "text/plain", "start_char_idx": 479273, "end_char_idx": 482799, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c9b34d9f-6621-4f1d-a83c-d2b41d78b178": {"__data__": {"id_": "c9b34d9f-6621-4f1d-a83c-d2b41d78b178", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "216bc339-c5f9-4b5d-b18b-6fb154833903", "node_type": "1", "metadata": {}, "hash": "d6a4ecc8767b7a350bd03515a795688c10544eedf070c14742ec7b45688cfaf2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2d51534e-9765-4938-be84-43bd55158e08", "node_type": "1", "metadata": {}, "hash": "d1f00baeae1e4d414cfade1953711199173a29148b3c2207fd66c2afba0b761d", "class_name": "RelatedNodeInfo"}}, "text": "Imaginewhatwouldhappenifweinitialized\nalltheparameters ofthe hiddenlayeras W\u00b91\u00ba=\ud835\udc50forsomeconstant \ud835\udc50. In thiscase, during\nforwardpropagationeitherhiddenunittakesthesameinputsandparametersproducingthe\nsameactivationwhichisfedtotheoutputunit. Duringbackpropagation,differentiatingthe\noutput unit with respect to parameters W\u00b91\u00bagives a gradient all of whose elements take\nthesamevalue. Thus,aftergradient-basediteration(e.g.,minibatchstochasticgradientde-\nscent),alltheelementsof W\u00b91\u00bastilltakethesamevalue. Suchiterationswouldnever break\nthe symmetry on their own and we might never be able to realize the network\u2019s expressive\npower. The hidden layer would behave as if it had only a single unit. Note that while mini-\nbatch stochastic gradient descent would not break this symmetry, dropout regularization\n(to be introduced later) would!\n187 Numerical Stability and Initialization\n5.4.2ParameterInitialization\nOne way of addressing\u2014or at least mitigating\u2014the issues raised above is through care-\nful initialization. As we will see later, additional care during optimization and suitable\nregularization can further enhance stability.\nDefaultInitialization\nIn the previous sections, e.g., in Section 3.5 , we used a normal distribution to initialize the\nvalues of our weights. If we do not specify the initialization method, the framework will\nuseadefaultrandominitializationmethod,whichoftenworkswellinpracticeformoderate\nproblem sizes.\nXavierInitialization\nLet\u2019s look at the scale distribution of an output \ud835\udc5c\ud835\udc56for some fully connected layer without\nnonlinearities . With\ud835\udc5bininputs\ud835\udc65\ud835\udc57and their associated weights \ud835\udc64\ud835\udc56\ud835\udc57for this layer, an output\nis given by\n\ud835\udc5c\ud835\udc56=\ud835\udc5bin\u00d5\n\ud835\udc57=1\ud835\udc64\ud835\udc56\ud835\udc57\ud835\udc65\ud835\udc57. (5.4.3)\nTheweights \ud835\udc64\ud835\udc56\ud835\udc57arealldrawnindependentlyfromthesamedistribution. Furthermore,let\u2019s\nassume that this distribution has zero mean and variance \ud835\udf0e2. Note that this does not mean\nthat the distribution has to be Gaussian, just that the mean and variance need to exist. For\nnow,let\u2019sassumethattheinputstothelayer \ud835\udc65\ud835\udc57alsohavezeromeanandvariance \ud835\udefe2andthat\nthey are independent of \ud835\udc64\ud835\udc56\ud835\udc57and independent of each other. In this case, we can compute\nthe mean of\ud835\udc5c\ud835\udc56:\n\ud835\udc38\u00bb\ud835\udc5c\ud835\udc56\u00bc=\ud835\udc5bin\u00d5\n\ud835\udc57=1\ud835\udc38\u00bb\ud835\udc64\ud835\udc56\ud835\udc57\ud835\udc65\ud835\udc57\u00bc\n=\ud835\udc5bin\u00d5\n\ud835\udc57=1\ud835\udc38\u00bb\ud835\udc64\ud835\udc56\ud835\udc57\u00bc\ud835\udc38\u00bb\ud835\udc65\ud835\udc57\u00bc\n=0,(5.4.4)\nand the variance:\nVar\u00bb\ud835\udc5c\ud835\udc56\u00bc=\ud835\udc38\u00bb\ud835\udc5c2\n\ud835\udc56\u00bc\u0000\u00b9\ud835\udc38\u00bb\ud835\udc5c\ud835\udc56\u00bc\u00ba2\n=\ud835\udc5bin\u00d5\n\ud835\udc57=1\ud835\udc38\u00bb\ud835\udc642\n\ud835\udc56\ud835\udc57\ud835\udc652\n\ud835\udc57\u00bc\u00000\n=\ud835\udc5bin\u00d5\n\ud835\udc57=1\ud835\udc38\u00bb\ud835\udc642\n\ud835\udc56\ud835\udc57\u00bc\ud835\udc38\u00bb\ud835\udc652\n\ud835\udc57\u00bc\n=\ud835\udc5bin\ud835\udf0e2\ud835\udefe2.(5.4.5)\nOne way to keep the variance fixed is to set \ud835\udc5bin\ud835\udf0e2=1. Now consider backpropagation.\nThere we face a similar problem, albeit with gradients being propagated from the layers\n188 Multilayer Perceptrons\ncloser to the output. Using the same reasoning as for forward propagation, we see that the\ngradients\u2019 variance can blow up unless \ud835\udc5bout\ud835\udf0e2=1, where\ud835\udc5boutis the number of outputs\nof this layer. This leaves us in a dilemma: we cannot possibly satisfy both conditions\nsimultaneously. Instead, we simply try to satisfy:\n1\n2\u00b9\ud835\udc5bin\u00b8\ud835\udc5bout\u00ba\ud835\udf0e2=1or equivalently \ud835\udf0e=r\n2\n\ud835\udc5bin\u00b8\ud835\udc5bout.", "mimetype": "text/plain", "start_char_idx": 482108, "end_char_idx": 484948, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2d51534e-9765-4938-be84-43bd55158e08": {"__data__": {"id_": "2d51534e-9765-4938-be84-43bd55158e08", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c9b34d9f-6621-4f1d-a83c-d2b41d78b178", "node_type": "1", "metadata": {}, "hash": "ffe4cd8df7d7ea2fc4c2c66fbce34ba0e600b06ac1a932a417f22d5f54576718", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "569c9fb6-0bed-49ad-a6bc-f656dc91324d", "node_type": "1", "metadata": {}, "hash": "ba02e9a9130af07c0d2195c9ebd85e88ed9eef64bf1dfcf6b55e835c9603034b", "class_name": "RelatedNodeInfo"}}, "text": "(5.4.5)\nOne way to keep the variance fixed is to set \ud835\udc5bin\ud835\udf0e2=1. Now consider backpropagation.\nThere we face a similar problem, albeit with gradients being propagated from the layers\n188 Multilayer Perceptrons\ncloser to the output. Using the same reasoning as for forward propagation, we see that the\ngradients\u2019 variance can blow up unless \ud835\udc5bout\ud835\udf0e2=1, where\ud835\udc5boutis the number of outputs\nof this layer. This leaves us in a dilemma: we cannot possibly satisfy both conditions\nsimultaneously. Instead, we simply try to satisfy:\n1\n2\u00b9\ud835\udc5bin\u00b8\ud835\udc5bout\u00ba\ud835\udf0e2=1or equivalently \ud835\udf0e=r\n2\n\ud835\udc5bin\u00b8\ud835\udc5bout. (5.4.6)\nThis is the reasoning underlying the now-standard and practically beneficial Xavierinitial-\nization,namedafterthefirstauthorofitscreators( GlorotandBengio,2010 ). Typically,the\nXavierinitializationsamplesweightsfromaGaussiandistributionwithzeromeanandvari-\nance\ud835\udf0e2=2\n\ud835\udc5bin\u00b8\ud835\udc5bout. We can also adapt this to choose the variance when sampling weights\nfrom a uniform distribution. Note that the uniform distribution \ud835\udc48\u00b9\u0000\ud835\udc4e,\ud835\udc4e\u00bahas variance\ud835\udc4e2\n3.\nPlugging\ud835\udc4e2\n3into our condition on \ud835\udf0e2prompts us to initialize according to\n\ud835\udc48\u00a9\u00ad\n\u00ab\u0000s\n6\n\ud835\udc5bin\u00b8\ud835\udc5bout,s\n6\n\ud835\udc5bin\u00b8\ud835\udc5bout\u00aa\u00ae\n\u00ac. (5.4.7)\nThough the assumption for nonexistence of nonlinearities in the above mathematical rea-\nsoning can be easily violated in neural networks, the Xavier initialization method turns out\nto work well in practice.\nBeyond\nThe reasoning above barely scratches the surface of modern approaches to parameter ini-\ntialization. A deep learning framework often implements over a dozen different heuristics.\nMoreover, parameter initialization continues to be a hot area of fundamental research in\ndeep learning. Among these are heuristics specialized for tied (shared) parameters, super-\nresolution, sequence models, and other situations. For instance, Xiao etal.(2018) demon-\nstrated the possibility of training 10,000-layer neural networks without architectural tricks\nby using a carefully-designed initialization method.\nIf the topic interests you we suggest a deep dive into this module\u2019s offerings, reading the\npapersthatproposedandanalyzedeachheuristic,andthenexploringthelatestpublications\non the topic. Perhaps you will stumble across or even invent a clever idea and contribute\nan implementation to deep learning frameworks.\n5.4.3Summary\nVanishing and exploding gradients are common issues in deep networks. Great care in\nparameter initialization is required to ensure that gradients and parameters remain well\ncontrolled. Initializationheuristicsareneededtoensurethattheinitialgradientsareneither\ntoo large nor too small. Random initialization is key to ensuring that symmetry is broken\nbefore optimization. Xavier initialization suggests that, for each layer, variance of any\noutputisnotaffectedbythenumberofinputs,andvarianceofanygradientisnotaffectedby\nthenumberofoutputs. ReLUactivationfunctionsmitigatethevanishinggradientproblem.\nThis can accelerate convergence.\n189 Generalization in Deep Learning\n1055.4.4Exercises\n1.Can you design other cases where a neural network might exhibit symmetry that needs\nbreaking, besides the permutation symmetry in an MLP\u2019s layers?\n2.Can we initialize all weight parameters in linear regression or in softmax regression to\nthe same value?\n3.Look up analytic bounds on the eigenvalues of the product of two matrices. What does\nthis tell you about ensuring that gradients are well conditioned?\n4.If we know that some terms diverge, can we fix this after the fact? Look at the paper on\nlayerwise adaptive rate scaling for inspiration ( Youetal., 2017).\nDiscussions105.\n5.5Generalizationin Deep Learning\nInChapter 3 andChapter 4 , we tackled regression and classification problems by fitting\nlinear models to training data. In both cases, we provided practical algorithms for finding\nthe parameters that maximized the likelihood of the observed training labels. And then,\ntowards the end of each chapter, we recalled that fitting the training data was only an in-\ntermediate goal. Our real quest all along was to discover general patterns on the basis\nof which we can make accurate predictions even on new examples drawn from the same\nunderlying population.", "mimetype": "text/plain", "start_char_idx": 484381, "end_char_idx": 488497, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "569c9fb6-0bed-49ad-a6bc-f656dc91324d": {"__data__": {"id_": "569c9fb6-0bed-49ad-a6bc-f656dc91324d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2d51534e-9765-4938-be84-43bd55158e08", "node_type": "1", "metadata": {}, "hash": "d1f00baeae1e4d414cfade1953711199173a29148b3c2207fd66c2afba0b761d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "04a44e49-a82d-43f5-bcec-484fd8b2dd9b", "node_type": "1", "metadata": {}, "hash": "1df28a4ccd79e1a356200c240a310c321304c3427a26b743a0eed55289f3b280", "class_name": "RelatedNodeInfo"}}, "text": "3.Look up analytic bounds on the eigenvalues of the product of two matrices. What does\nthis tell you about ensuring that gradients are well conditioned?\n4.If we know that some terms diverge, can we fix this after the fact? Look at the paper on\nlayerwise adaptive rate scaling for inspiration ( Youetal., 2017).\nDiscussions105.\n5.5Generalizationin Deep Learning\nInChapter 3 andChapter 4 , we tackled regression and classification problems by fitting\nlinear models to training data. In both cases, we provided practical algorithms for finding\nthe parameters that maximized the likelihood of the observed training labels. And then,\ntowards the end of each chapter, we recalled that fitting the training data was only an in-\ntermediate goal. Our real quest all along was to discover general patterns on the basis\nof which we can make accurate predictions even on new examples drawn from the same\nunderlying population. Machine learning researchers are consumers of optimization algo-\nrithms. Sometimes, we must even develop new optimization algorithms. But at the end\nof the day, optimization is merely a means to an end. At its core, machine learning is a\nstatistical discipline and we wish to optimize training loss only insofar as some statistical\nprinciple (known or unknown) leads the resulting models to generalize beyond the training\nset.\nOn the bright side, it turns out that deep neural networks trained by stochastic gradient de-\nscent generalize remarkably well across myriad prediction problems, spanning computer\nvision; natural language processing; time series data; recommender systems; electronic\nhealth records; protein folding; value function approximation in video games and board\ngames; and numerous other domains. On the downside, if you were looking for a straight-\nforward account of either the optimization story (why we can fit them to training data) or\nthegeneralizationstory(whytheresultingmodelsgeneralizetounseenexamples),thenyou\nmight want to pour yourself a drink. While our procedures for optimizing linear models\nand the statistical properties of the solutions are both described well by a comprehensive\nbody of theory, our understanding of deep learning still resembles the wild west on both\nfronts.\nBoth the theory and practice of deep learning are rapidly evolving, with theorists adopting\nnew strategies to explain what\u2019s going on, even as practitioners continue to innovate at\n190 Multilayer Perceptrons\na blistering pace, building arsenals of heuristics for training deep networks and a body of\nintuitionsandfolkknowledgethatprovideguidancefordecidingwhichtechniquestoapply\nin which situations.\nThe summary of the present moment is that the theory of deep learning has produced\npromising lines of attack and scattered fascinating results, but still appears far from a com-\nprehensive account of both (i) why we are able to optimize neural networks and (ii) how\nmodelslearnedbygradientdescentmanagetogeneralizesowell,evenonhigh-dimensional\ntasks. However,inpractice,(i)isseldomaproblem(wecanalwaysfindparametersthatwill\nfit all of our training data) and thus understanding generalization is far the bigger problem.\nOn the other hand, even absent the comfort of a coherent scientific theory, practitioners\nhave developed a large collection of techniques that may help you to produce models that\ngeneralize well in practice. While no pithy summary can possibly do justice to the vast\ntopic of generalization in deep learning, and while the overall state of research is far from\nresolved, we hope, in this section, to present a broad overview of the state of research and\npractice.\n5.5.1RevisitingOverfittingand Regularization\nAccording to the \u201cno free lunch\u201d theorem of Wolpert and Macready ( 1995), any learn-\ning algorithm generalizes better on data with certain distributions, and worse with other\ndistributions. Thus, given a finite training set, a model relies on certain assumptions: to\nachieve human-level performance it may be useful to identify inductive biases that reflect\nhow humans think about the world. Such inductive biases show preferences for solutions\nwith certain properties. For example, a deep MLP has an inductive bias towards building\nup a complicated function by the composition of simpler functions.\nWith machine learning models encoding inductive biases, our approach to training them\ntypicallyconsistsoftwophases: (i)fitthetrainingdata; and(ii)estimatethe generalization\nerror(thetrueerrorontheunderlyingpopulation)byevaluatingthemodelonholdoutdata.\nThe difference between our fit on the training data and our fit on the test data is called the\ngeneralizationgap andwhenthisislarge,wesaythatourmodels overfittothetrainingdata.", "mimetype": "text/plain", "start_char_idx": 487583, "end_char_idx": 492269, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "04a44e49-a82d-43f5-bcec-484fd8b2dd9b": {"__data__": {"id_": "04a44e49-a82d-43f5-bcec-484fd8b2dd9b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "569c9fb6-0bed-49ad-a6bc-f656dc91324d", "node_type": "1", "metadata": {}, "hash": "ba02e9a9130af07c0d2195c9ebd85e88ed9eef64bf1dfcf6b55e835c9603034b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f958c009-805c-42d2-addb-becbda52d561", "node_type": "1", "metadata": {}, "hash": "b6efed729f13fac837cfc9acdf40714a33524a322b16611d664d799444699b1f", "class_name": "RelatedNodeInfo"}}, "text": "Thus, given a finite training set, a model relies on certain assumptions: to\nachieve human-level performance it may be useful to identify inductive biases that reflect\nhow humans think about the world. Such inductive biases show preferences for solutions\nwith certain properties. For example, a deep MLP has an inductive bias towards building\nup a complicated function by the composition of simpler functions.\nWith machine learning models encoding inductive biases, our approach to training them\ntypicallyconsistsoftwophases: (i)fitthetrainingdata; and(ii)estimatethe generalization\nerror(thetrueerrorontheunderlyingpopulation)byevaluatingthemodelonholdoutdata.\nThe difference between our fit on the training data and our fit on the test data is called the\ngeneralizationgap andwhenthisislarge,wesaythatourmodels overfittothetrainingdata.\nIn extreme cases of overfitting, we might exactly fit the training data, even when the test\nerrorremainssignificant. Andintheclassicalview,theinterpretationisthatourmodelsare\ntoocomplex, requiringthatweeithershrinkthenumberoffeatures, thenumberofnonzero\nparameters learned, or the size of the parameters as quantified. Recall the plot of model\ncomplexity compared with loss ( Fig. 3.6.1 ) fromSection 3.6 .\nHowever deep learning complicates this picture in counterintuitive ways. First, for classifi-\ncation problems, our models are typically expressive enough to perfectly fit every training\nexample, even in datasets consisting of millions ( Zhanget al., 2021). In the classical pic-\nture, we might think that this setting lies on the far right extreme of the model complexity\naxis, and that any improvements in generalization error must come by way of regulariza-\ntion,eitherbyreducingthecomplexityofthemodelclass,orbyapplyingapenalty,severely\nconstraining the set of values that our parameters might take. But that is where things start\nto get weird.\n191 Generalization in Deep Learning\nStrangely, for many deep learning tasks (e.g., image recognition and text classification) we\nare typically choosing among model architectures, all of which can achieve arbitrarily low\ntraining loss (and zero training error). Because all models under consideration achieve\nzero training error, theonlyavenueforfurthergainsistoreduceoverfitting . Even stranger,\nit is often the case that despite fitting the training data perfectly, we can actually reduce\nthe generalization error further by making the model even more expressive , e.g., adding\nlayers, nodes, or training for a larger number of epochs. Stranger yet, the pattern relating\nthegeneralizationgaptothe complexity ofthemodel(ascaptured,forexample,inthedepth\nor width of the networks) can be non-monotonic, with greater complexity hurting at first\nbut subsequently helping in a so-called \u201cdouble-descent\u201d pattern ( Nakkiran et al., 2021).\nThus the deep learning practitioner possesses a bag of tricks, some of which seemingly\nrestrict the model in some fashion and others that seemingly make it even more expressive,\nand all of which, in some sense, are applied to mitigate overfitting.\nComplicating things even further, while the guarantees provided by classical learning the-\nory can be conservative even for classical models, they appear powerless to explain why\nit is that deep neural networks generalize in the first place. Because deep neural networks\nare capable of fitting arbitrary labels even for large datasets, and despite the use of famil-\niar methods such as \u21132regularization, traditional complexity-based generalization bounds,\ne.g., those based on the VC dimension or Rademacher complexity of a hypothesis class\ncannot explain why neural networks generalize.\n5.5.2InspirationfromNonparametrics\nApproaching deep learning for the first time, it is tempting to think of them as parametric\nmodels. Afterall,themodels dohavemillionsofparameters. Whenweupdatethemodels,\nwe update their parameters. When we save the models, we write their parameters to disk.\nHowever, mathematics and computer science are riddled with counterintuitive changes of\nperspective, and surprising isomorphisms between seemingly different problems. While\nneural networks clearly haveparameters, in some ways it can be more fruitful to think of\nthem as behaving like nonparametric models. So what precisely makes a model nonpara-\nmetric? While the name covers a diverse set of approaches, one common theme is that\nnonparametric methods tend to have a level of complexity that grows as the amount of\navailable data grows.", "mimetype": "text/plain", "start_char_idx": 491431, "end_char_idx": 495923, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f958c009-805c-42d2-addb-becbda52d561": {"__data__": {"id_": "f958c009-805c-42d2-addb-becbda52d561", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "04a44e49-a82d-43f5-bcec-484fd8b2dd9b", "node_type": "1", "metadata": {}, "hash": "1df28a4ccd79e1a356200c240a310c321304c3427a26b743a0eed55289f3b280", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fc10d8df-97bd-4f0e-98d8-417aa7304325", "node_type": "1", "metadata": {}, "hash": "717ba89e615b663de286977efc0ccc8a06cdce2017d00ab0437fe3a11739e1ef", "class_name": "RelatedNodeInfo"}}, "text": "5.5.2InspirationfromNonparametrics\nApproaching deep learning for the first time, it is tempting to think of them as parametric\nmodels. Afterall,themodels dohavemillionsofparameters. Whenweupdatethemodels,\nwe update their parameters. When we save the models, we write their parameters to disk.\nHowever, mathematics and computer science are riddled with counterintuitive changes of\nperspective, and surprising isomorphisms between seemingly different problems. While\nneural networks clearly haveparameters, in some ways it can be more fruitful to think of\nthem as behaving like nonparametric models. So what precisely makes a model nonpara-\nmetric? While the name covers a diverse set of approaches, one common theme is that\nnonparametric methods tend to have a level of complexity that grows as the amount of\navailable data grows.\nPerhapsthesimplestexampleofanonparametricmodelisthe \ud835\udc58-nearestneighboralgorithm\n(we will cover more nonparametric models later, for example in Section 11.2 ). Here, at\ntraining time, the learner simply memorizes the dataset. Then, at prediction time, when\nconfronted with a new point x, the learner looks up the \ud835\udc58nearest neighbors (the \ud835\udc58points\nx0\n\ud835\udc56that minimize some distance \ud835\udc51\u00b9x,x0\n\ud835\udc56\u00ba). When\ud835\udc58=1, this algorithm is called 1-nearest\nneighbors, and the algorithm will always achieve a training error of zero. That however,\ndoes not mean that the algorithm will not generalize. In fact, it turns out that under some\nmild conditions, the 1-nearest neighbor algorithm is consistent (eventually converging to\nthe optimal predictor).\nNote that 1-nearest neighbor requires that we specify some distance function \ud835\udc51, or equiva-\nlently, that we specify some vector-valued basis function \ud835\udf19\u00b9x\u00bafor featurizing our data. For\n192 Multilayer Perceptrons\nany choice of the distance metric, we will achieve zero training error and eventually reach\nan optimal predictor, but different distance metrics \ud835\udc51encode different inductive biases and\nwith a finite amount of available data will yield different predictors. Different choices of\nthe distance metric \ud835\udc51represent different assumptions about the underlying patterns and the\nperformanceofthedifferentpredictorswilldependonhowcompatibletheassumptionsare\nwith the observed data.\nInasense, becauseneuralnetworksareover-parametrized, possessingmanymoreparame-\ntersthanareneededtofitthetrainingdata, theytendto interpolate thetrainingdata(fitting\nit perfectly) and thus behave, in some ways, more like nonparametric models. More re-\ncent theoretical research has established deep connection between large neural networks\nand nonparametric methods, notably kernel methods. In particular, Jacot et al.(2018)\ndemonstrated that in the limit, as multilayer perceptrons with randomly initialized weights\ngrow infinitely wide, they become equivalent to (nonparametric) kernel methods for a spe-\ncific choice of the kernel function (essentially, a distance function), which they call the\nneural tangent kernel. While current neural tangent kernel models may not fully explain\nthe behavior of modern deep networks, their success as an analytical tool underscores the\nusefulnessofnonparametricmodelingforunderstandingthebehaviorofover-parametrized\ndeep networks.\n5.5.3EarlyStopping\nWhile deep neural networks are capable of fitting arbitrary labels, even when labels are\nassigned incorrectly or randomly ( Zhanget al., 2021), this capability only emerges over\nmany iterations of training. A new line of work ( Rolnicket al., 2017) has revealed that\nin the setting of label noise, neural networks tend to fit cleanly labeled data first and only\nsubsequently to interpolate the mislabeled data. Moreover, it has been established that this\nphenomenon translates directly into a guarantee on generalization: whenever a model has\nfitted the cleanly labeled data but not randomly labeled examples included in the training\nset, it has in fact generalized ( Gargetal., 2021).\nTogetherthesefindingshelptomotivate earlystopping ,aclassictechniqueforregularizing\ndeepneuralnetworks. Here,ratherthandirectlyconstrainingthevaluesoftheweights,one\nconstrains the number of epochs of training.", "mimetype": "text/plain", "start_char_idx": 495094, "end_char_idx": 499215, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fc10d8df-97bd-4f0e-98d8-417aa7304325": {"__data__": {"id_": "fc10d8df-97bd-4f0e-98d8-417aa7304325", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f958c009-805c-42d2-addb-becbda52d561", "node_type": "1", "metadata": {}, "hash": "b6efed729f13fac837cfc9acdf40714a33524a322b16611d664d799444699b1f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "91ac4010-9545-4d67-ab47-6d48fe5b0da0", "node_type": "1", "metadata": {}, "hash": "4137c0dee9cb58b7c76b30567bf3a76c7c83f8270dbef10fc5973a632f8166ed", "class_name": "RelatedNodeInfo"}}, "text": "A new line of work ( Rolnicket al., 2017) has revealed that\nin the setting of label noise, neural networks tend to fit cleanly labeled data first and only\nsubsequently to interpolate the mislabeled data. Moreover, it has been established that this\nphenomenon translates directly into a guarantee on generalization: whenever a model has\nfitted the cleanly labeled data but not randomly labeled examples included in the training\nset, it has in fact generalized ( Gargetal., 2021).\nTogetherthesefindingshelptomotivate earlystopping ,aclassictechniqueforregularizing\ndeepneuralnetworks. Here,ratherthandirectlyconstrainingthevaluesoftheweights,one\nconstrains the number of epochs of training. The most common way to determine the\nstopping criterion is to monitor validation error throughout training (typically by checking\nonce after each epoch) and to cut off training when the validation error has not decreased\nby more than some small amount \ud835\udf16for some number of epochs. This is sometimes called a\npatiencecriterion . As well as the potential to lead to better generalization in the setting of\nnoisylabels,anotherbenefitofearlystoppingisthetimesaved. Oncethepatiencecriterion\nis met, one can terminate training. For large models that might require days of training\nsimultaneously across eight or more GPUs, well-tuned early stopping can save researchers\ndays of time and can save their employers many thousands of dollars.\nNotably, when there is no label noise and datasets are realizable (the classes are truly sep-\narable, e.g., distinguishing cats from dogs), early stopping tends not to lead to significant\nimprovements in generalization. On the other hand, when there is label noise, or intrinsic\n193 Generalization in Deep Learning\nvariabilityinthelabel(e.g., predictingmortalityamongpatients), earlystoppingiscrucial.\nTraining models until they interpolate noisy data is typically a bad idea.\n5.5.4Classical RegularizationMethodsforDeep Networks\nInChapter 3 , we described several classical regularization techniques for constraining the\ncomplexity of our models. In particular, Section 3.7 introduced a method called weight\ndecay,whichconsistsofaddingaregularizationtermtothelossfunctioninordertopenalize\nlarge values of the weights. Depending on which weight norm is penalized this technique\nis known either as ridge regularization (for \u21132penalty) or lasso regularization (for an \u21131\npenalty). In the classical analysis of these regularizers, they are considered as sufficiently\nrestrictiveonthevaluesthattheweightscantaketopreventthemodelfromfittingarbitrary\nlabels.\nIn deep learning implementations, weight decay remains a popular tool. However, re-\nsearchershavenotedthattypicalstrengthsof \u21132regularizationareinsufficienttopreventthe\nnetworksfrominterpolatingthedata( Zhangetal.,2021)andthusthebenefitsifinterpreted\nas regularization might only make sense in combination with the early stopping criterion.\nAbsent early stopping, it is possible that just like the number of layers or number of nodes\n(indeeplearning)orthedistancemetric(in1-nearestneighbor),thesemethodsmayleadto\nbetter generalization not because they meaningfully constrain the power of the neural net-\nwork but rather because they somehow encode inductive biases that are better compatible\nwith the patterns found in datasets of interests. Thus, classical regularizers remain popular\nin deep learning implementations, even if the theoretical rationale for their efficacy may be\nradically different.\nNotably, deep learning researchers have also built on techniques first popularized in classi-\ncalregularizationcontexts,suchasaddingnoisetomodelinputs. Inthenextsectionwewill\nintroduce the famous dropout technique (invented by Srivastava et al.(2014)), which has\nbecome a mainstay of deep learning, even as the theoretical basis for its efficacy remains\nsimilarly mysterious.\n5.5.5Summary\nUnlike classical linear models, which tend to have fewer parameters than examples, deep\nnetworks tend to be over-parametrized, and for most tasks are capable of perfectly fitting\nthetrainingset. This interpolationregime challengesmanyhardfast-heldintuitions. Func-\ntionally, neural networks look like parametric models. But thinking of them as nonpara-\nmetric models can sometimes be a more reliable source of intuition. Because it is often\nthe case that all deep networks under consideration are capable of fitting all of the train-\ning labels, nearly all gains must come by mitigating overfitting (closing the generalization\ngap).", "mimetype": "text/plain", "start_char_idx": 498527, "end_char_idx": 503023, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "91ac4010-9545-4d67-ab47-6d48fe5b0da0": {"__data__": {"id_": "91ac4010-9545-4d67-ab47-6d48fe5b0da0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fc10d8df-97bd-4f0e-98d8-417aa7304325", "node_type": "1", "metadata": {}, "hash": "717ba89e615b663de286977efc0ccc8a06cdce2017d00ab0437fe3a11739e1ef", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e7af3b22-90e0-4e78-b84e-115132b95cdf", "node_type": "1", "metadata": {}, "hash": "7bd4dd4d89680ef968686d3812882dbdebb162755f998a812670a13e72021ce6", "class_name": "RelatedNodeInfo"}}, "text": "Inthenextsectionwewill\nintroduce the famous dropout technique (invented by Srivastava et al.(2014)), which has\nbecome a mainstay of deep learning, even as the theoretical basis for its efficacy remains\nsimilarly mysterious.\n5.5.5Summary\nUnlike classical linear models, which tend to have fewer parameters than examples, deep\nnetworks tend to be over-parametrized, and for most tasks are capable of perfectly fitting\nthetrainingset. This interpolationregime challengesmanyhardfast-heldintuitions. Func-\ntionally, neural networks look like parametric models. But thinking of them as nonpara-\nmetric models can sometimes be a more reliable source of intuition. Because it is often\nthe case that all deep networks under consideration are capable of fitting all of the train-\ning labels, nearly all gains must come by mitigating overfitting (closing the generalization\ngap). Paradoxically, the interventions that reduce the generalization gap sometimes appear\nto increase model complexity and at other times appear to decrease complexity. However,\nthese methods seldom decrease complexity sufficiently for classical theory to explain the\ngeneralization of deep networks, and why certain choices lead to improved generalization\nremains for the most part a massive open question despite the concerted efforts of many\nbrilliant researchers.\n194 Multilayer Perceptrons\n1065.5.6Exercises\n1.Inwhatsensedotraditionalcomplexity-basedmeasuresfailtoaccountforgeneralization\nof deep neural networks?\n2.Why might earlystopping be considered a regularization technique?\n3.How do researchers typically determine the stopping criterion?\n4.What important factor seems to differentiate cases when early stopping leads to big\nimprovements in generalization?\n5.Beyond generalization, describe another benefit of early stopping.\nDiscussions106.\n5.6Dropout\nLet\u2019s think briefly about what we expect from a good predictive model. We want it to pe-\nform well on unseen data. Classical generalization theory suggests that to close the gap\nbetween train and test performance, we should aim for a simple model. Simplicity can\ncome in the form of a small number of dimensions. We explored this when discussing the\nmonomial basis functions of linear models in Section 3.6 . Additionally, as we saw when\ndiscussingweightdecay( \u21132regularization)in Section3.7 ,the(inverse)normoftheparam-\neters also represents a useful measure of simplicity. Another useful notion of simplicity\nis smoothness, i.e., that the function should not be sensitive to small changes to its inputs.\nFor instance, when we classify images, we would expect that adding some random noise to\nthe pixels should be mostly harmless.\nBishop( 1995)formalizedthisideawhenheprovedthattrainingwithinputnoiseisequiva-\nlent to Tikhonov regularization. This work drew a clear mathematical connection between\nthe requirement that a function be smooth (and thus simple), and the requirement that it be\nresilient to perturbations in the input.\nThen, Srivastava etal.(2014)developedacleverideaforhowtoapplyBishop\u2019sideatothe\ninternal layers of a network, too. Their idea, called dropout, involves injecting noise while\ncomputing each internal layer during forward propagation, and it has become a standard\ntechnique for training neural networks. The method is called dropout because we literally\ndrop out some neurons during training. Throughout training, on each iteration, standard\ndropout consists of zeroing out some fraction of the nodes in each layer before calculating\nthe subsequent layer.\nTo be clear, we are imposing our own narrative with the link to Bishop. The original pa-\nper on dropout offers intuition through a surprising analogy to sexual reproduction. The\nauthors argue that neural network overfitting is characterized by a state in which each layer\n195 Dropout\nrelies on a specific pattern of activations in the previous layer, calling this condition co-\nadaptation . Dropout, they claim, breaks up co-adaptation just as sexual reproduction is\nargued to break up co-adapted genes. While such an justification of this theory is cer-\ntainlyupfordebate, thedropouttechniqueitselfhasprovedenduring, andvariousformsof\ndropout are implemented in most deep learning libraries.\nThekeychallengeishowto injectthisnoise. Oneidea istoinjectitin an unbiased manner\nsothattheexpectedvalueofeachlayer\u2014whilefixingtheothers\u2014equalsthevalueitwould\nhavetakenabsentnoise. InBishop\u2019swork,headdedGaussiannoisetotheinputstoalinear\nmodel.", "mimetype": "text/plain", "start_char_idx": 502154, "end_char_idx": 506605, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e7af3b22-90e0-4e78-b84e-115132b95cdf": {"__data__": {"id_": "e7af3b22-90e0-4e78-b84e-115132b95cdf", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "91ac4010-9545-4d67-ab47-6d48fe5b0da0", "node_type": "1", "metadata": {}, "hash": "4137c0dee9cb58b7c76b30567bf3a76c7c83f8270dbef10fc5973a632f8166ed", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7730bfa3-9986-46fa-a1dd-befa1def170e", "node_type": "1", "metadata": {}, "hash": "06f927594d3966eb98bf79ab692791201340ab2dd28572618812ec47e47bb3d9", "class_name": "RelatedNodeInfo"}}, "text": "The\nauthors argue that neural network overfitting is characterized by a state in which each layer\n195 Dropout\nrelies on a specific pattern of activations in the previous layer, calling this condition co-\nadaptation . Dropout, they claim, breaks up co-adaptation just as sexual reproduction is\nargued to break up co-adapted genes. While such an justification of this theory is cer-\ntainlyupfordebate, thedropouttechniqueitselfhasprovedenduring, andvariousformsof\ndropout are implemented in most deep learning libraries.\nThekeychallengeishowto injectthisnoise. Oneidea istoinjectitin an unbiased manner\nsothattheexpectedvalueofeachlayer\u2014whilefixingtheothers\u2014equalsthevalueitwould\nhavetakenabsentnoise. InBishop\u2019swork,headdedGaussiannoisetotheinputstoalinear\nmodel. At each training iteration, he added noise sampled from a distribution with mean\nzero\ud835\udf16\u0018N\u00b9 0,\ud835\udf0e2\u00bato the input x, yielding a perturbed point x0=x\u00b8\ud835\udf16. In expectation,\n\ud835\udc38\u00bbx0\u00bc=x.\nIn standard dropout regularization, one zeros out some fraction of the nodes in each layer\nandthendebiases eachlayerbynormalizingbythefractionofnodesthatwereretained(not\ndropped out). In other words, with dropoutprobability \ud835\udc5d, each intermediate activation \u210eis\nreplaced by a random variable \u210e0as follows:\n\u210e0=(\n0with probability \ud835\udc5d\n\u210e\n1\u0000\ud835\udc5dotherwise(5.6.1)\nBy design, the expectation remains unchanged, i.e., \ud835\udc38\u00bb\u210e0\u00bc=\u210e.\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n5.6.1Dropoutin Practice\nRecall the MLP with a hidden layer and five hidden units from Fig. 5.1.1 . When we apply\ndropout to a hidden layer, zeroing out each hidden unit with probability \ud835\udc5d, the result can\nbe viewed as a network containing only a subset of the original neurons. In Fig. 5.6.1 ,\u210e2\nand\u210e5are removed. Consequently, the calculation of the outputs no longer depends on \u210e2\nor\u210e5andtheirrespectivegradientalsovanisheswhenperformingbackpropagation. Inthis\nway, the calculation of the output layer cannot be overly dependent on any one element of\n\u210e1,...,\u210e 5.\ntFig. 5.6.1 MLP before and after dropout.\n196 Multilayer Perceptrons\nTypically, we disable dropout at test time. Given a trained model and a new example,\nwe do not drop out any nodes and thus do not need to normalize. However, there are\nsomeexceptions: someresearchersusedropoutattesttimeasaheuristicforestimatingthe\nuncertainty of neural network predictions: if the predictions agree across many different\ndropout outputs, then we might say that the network is more confident.\n5.6.2Implementation fromScratch\nToimplementthedropoutfunctionforasinglelayer,wemustdrawasmanysamplesfroma\nBernoulli(binary)randomvariableasourlayerhasdimensions,wheretherandomvariable\ntakes value 1(keep) with probability 1\u0000\ud835\udc5dand0(drop) with probability \ud835\udc5d. One easy way\nto implement this is to first draw samples from the uniform distribution \ud835\udc48\u00bb0,1\u00bc. Then we\ncan keep those nodes for which the corresponding sample is greater than \ud835\udc5d, dropping the\nrest.\nInthefollowingcode,weimplementa dropout_layer functionthatdropsouttheelements\ninthetensorinput Xwithprobability dropout , rescalingtheremainderasdescribedabove:\ndividing the survivors by 1.0-dropout .\ndef dropout_layer (X, dropout):\nassert 0<=dropout <=1\nifdropout ==1:return torch .zeros_like(X)\nmask =(torch .rand(X .shape) >dropout) .float()\nreturn mask *X/(1.0 -dropout)\nWe can test out the dropout_layer function on a few examples. In the following lines of\ncode, we pass our input Xthrough the dropout operation, with probabilities 0, 0.5, and 1,\nrespectively.", "mimetype": "text/plain", "start_char_idx": 505843, "end_char_idx": 509310, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7730bfa3-9986-46fa-a1dd-befa1def170e": {"__data__": {"id_": "7730bfa3-9986-46fa-a1dd-befa1def170e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e7af3b22-90e0-4e78-b84e-115132b95cdf", "node_type": "1", "metadata": {}, "hash": "7bd4dd4d89680ef968686d3812882dbdebb162755f998a812670a13e72021ce6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b8ed9649-0992-4a76-bca5-2ccfaa454ea7", "node_type": "1", "metadata": {}, "hash": "290752932fdc7063c435ec7c9bc4ff8770f98558d465f1b9b4efe19b2aece296", "class_name": "RelatedNodeInfo"}}, "text": "Then we\ncan keep those nodes for which the corresponding sample is greater than \ud835\udc5d, dropping the\nrest.\nInthefollowingcode,weimplementa dropout_layer functionthatdropsouttheelements\ninthetensorinput Xwithprobability dropout , rescalingtheremainderasdescribedabove:\ndividing the survivors by 1.0-dropout .\ndef dropout_layer (X, dropout):\nassert 0<=dropout <=1\nifdropout ==1:return torch .zeros_like(X)\nmask =(torch .rand(X .shape) >dropout) .float()\nreturn mask *X/(1.0 -dropout)\nWe can test out the dropout_layer function on a few examples. In the following lines of\ncode, we pass our input Xthrough the dropout operation, with probabilities 0, 0.5, and 1,\nrespectively.\nX=torch .arange( 16, dtype =torch .float32) .reshape(( 2,8))\nprint ('dropout_p = 0: ', dropout_layer(X, 0))\nprint ('dropout_p = 0.5: ', dropout_layer(X, 0.5))\nprint ('dropout_p = 1: ', dropout_layer(X, 1))\ndropout_p =0: tensor([[ 0.,1.,2.,3.,4.,5.,6.,7.],\n[8.,9.,10.,11.,12.,13.,14.,15.]])\ndropout_p =0.5: tensor([[ 0.,2.,0.,6.,8.,0.,0.,0.],\n[16.,18.,20.,22.,24.,26.,28.,30.]])\ndropout_p =1: tensor([[ 0.,0.,0.,0.,0.,0.,0.,0.],\n[0.,0.,0.,0.,0.,0.,0.,0.]])\nDefiningthe Model\nThemodelbelowappliesdropouttotheoutputofeachhiddenlayer(followingtheactivation\nfunction). We can set dropout probabilities for each layer separately. A common choice is\nto set a lower dropout probability closer to the input layer. We ensure that dropout is only\nactive during training.\n197 Dropout\nclass DropoutMLPScratch (d2l .Classifier):\ndef __init__ (self , num_outputs, num_hiddens_1, num_hiddens_2,\ndropout_1, dropout_2, lr):\nsuper ().__init__ ()\nself .save_hyperparameters()\nself .lin1 =nn.LazyLinear(num_hiddens_1)\nself .lin2 =nn.LazyLinear(num_hiddens_2)\nself .lin3 =nn.LazyLinear(num_outputs)\nself .relu =nn.ReLU()\ndef forward (self , X):\nH1=self .relu( self .lin1(X .reshape((X .shape[ 0],-1))))\nifself .training:\nH1=dropout_layer(H1, self .dropout_1)\nH2=self .relu( self .lin2(H1))\nifself .training:\nH2=dropout_layer(H2, self .dropout_2)\nreturn self .lin3(H2)\nTraining\nThe following is similar to the training of MLPs described previously.\nhparams ={'num_outputs ':10,'num_hiddens_1 ':256,'num_hiddens_2 ':256,\n'dropout_1 ':0.5,'dropout_2 ':0.5,'lr':0.1}\nmodel =DropoutMLPScratch( **hparams)\ndata =d2l.FashionMNIST(batch_size =256)\ntrainer =d2l.Trainer(max_epochs =10)\ntrainer .fit(model, data)\n5.6.3Concise Implementation\nWith high-level APIs, all we need to do is add a Dropout layer after each fully connected\nlayer, passing in the dropout probability as the only argument to its constructor. During\ntraining, the Dropout layer will randomly drop out outputs of the previous layer (or equiv-\nalently, the inputs to the subsequent layer) according to the specified dropout probability.\nWhen not in training mode, the Dropout layer simply passes the data through during test-\ning.\n198 Multilayer Perceptrons\nclass DropoutMLP (d2l .Classifier):\ndef __init__ (self , num_outputs, num_hiddens_1, num_hiddens_2,\ndropout_1, dropout_2, lr):\nsuper ().__init__ ()\nself .save_hyperparameters()\nself .net =nn.Sequential(\nnn.Flatten(), nn .LazyLinear(num_hiddens_1), nn .ReLU(),\nnn.Dropout(dropout_1), nn .LazyLinear(num_hiddens_2), nn .ReLU(),\nnn.Dropout(dropout_2), nn .LazyLinear(num_outputs))\nNext, we train the model.", "mimetype": "text/plain", "start_char_idx": 508642, "end_char_idx": 511909, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b8ed9649-0992-4a76-bca5-2ccfaa454ea7": {"__data__": {"id_": "b8ed9649-0992-4a76-bca5-2ccfaa454ea7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7730bfa3-9986-46fa-a1dd-befa1def170e", "node_type": "1", "metadata": {}, "hash": "06f927594d3966eb98bf79ab692791201340ab2dd28572618812ec47e47bb3d9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fa841011-abcf-4258-a6a0-90f3c89e2132", "node_type": "1", "metadata": {}, "hash": "0f8386e42e8ebc3a51c8e47fb0af719de617ec67310bfc4e4d0ca9c9f4068f26", "class_name": "RelatedNodeInfo"}}, "text": "During\ntraining, the Dropout layer will randomly drop out outputs of the previous layer (or equiv-\nalently, the inputs to the subsequent layer) according to the specified dropout probability.\nWhen not in training mode, the Dropout layer simply passes the data through during test-\ning.\n198 Multilayer Perceptrons\nclass DropoutMLP (d2l .Classifier):\ndef __init__ (self , num_outputs, num_hiddens_1, num_hiddens_2,\ndropout_1, dropout_2, lr):\nsuper ().__init__ ()\nself .save_hyperparameters()\nself .net =nn.Sequential(\nnn.Flatten(), nn .LazyLinear(num_hiddens_1), nn .ReLU(),\nnn.Dropout(dropout_1), nn .LazyLinear(num_hiddens_2), nn .ReLU(),\nnn.Dropout(dropout_2), nn .LazyLinear(num_outputs))\nNext, we train the model.\nmodel =DropoutMLP( **hparams)\ntrainer .fit(model, data)\n5.6.4Summary\nBeyond controlling the number of dimensions and the size of the weight vector, dropout is\nyet another tool for avoiding overfitting. Often tools are used jointly. Note that dropout is\nused only during training: it replaces an activation \u210ewith a random variable with expected\nvalue\u210e.\n5.6.5Exercises\n1.What happens if you change the dropout probabilities for the first and second layers?\nIn particular, what happens if you switch the ones for both layers? Design an experi-\nment to answer these questions, describe your results quantitatively, and summarize the\nqualitative takeaways.\n2.Increase the number of epochs and compare the results obtained when using dropout\nwith those when not using it.\n3.What is the variance of the activations in each hidden layer when dropout is and is not\napplied? Draw a plot to show how this quantity evolves over time for both models.\n4.Why is dropout not typically used at test time?\n5.Usingthemodelinthissectionasanexample, comparetheeffectsofusingdropoutand\n199 Predicting House Prices on Kaggle\n107\n108weightdecay. Whathappenswhendropoutandweightdecayareusedatthesametime?\nAre the results additive? Are there diminished returns (or worse)? Do they cancel each\nother out?\n6.What happens if we apply dropout to the individual weights of the weight matrix rather\nthan the activations?\n7.Invent another technique for injecting random noise at each layer that is different from\nthestandarddropouttechnique. Canyoudevelopamethodthatoutperformsdropouton\nthe Fashion-MNIST dataset (for a fixed architecture)?\nDiscussions107.\n5.7PredictingHouse Prices on Kaggle\nNow that we have introduced some basic tools for building and training deep networks and\nregularizing them with techniques including weight decay and dropout, we are ready to\nput all this knowledge into practice by participating in a Kaggle competition. The house\nprice prediction competition is a great place to start. The data is fairly generic and do not\nexhibit exotic structure that might require specialized models (as audio or video might).\nThis dataset, collected by De Cock ( 2011), covers house prices in Ames, Iowa from the\nperiod 2006\u20132010. It is considerably larger than the famous Boston housing dataset108of\nHarrison and Rubinfeld (1978), boasting both more examples and more features.\nIn this section, we will walk you through details of data preprocessing, model design, and\nhyperparameter selection. We hope that through a hands-on approach, you will gain some\nintuitions that will guide you in your career as a data scientist.\n%matplotlib inline\nimport pandas aspd\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n5.7.1DownloadingData\nThroughout the book, we will train and test models on various downloaded datasets. Here,\nwe implement two utility functions for downloading and extracting zip or tar files. Again,\nwe skip implementation details of such utility functions.\ndef download (url, folder, sha1_hash =None ):\n\"\"\"Download a file to folder and return the local filepath.\"\"\"\ndef extract (filename, folder):\n\"\"\"Extract a zip/tar file into folder.\"\"\"\n200 Multilayer Perceptrons\n1095.7.2Kaggle\nKaggle109is a popular platform that hosts machine learning competitions. Each com-\npetition centers on a dataset and many are sponsored by stakeholders who offer prizes to\nthe winning solutions. The platform helps users to interact via forums and shared code,\nfostering both collaboration and competition.", "mimetype": "text/plain", "start_char_idx": 511193, "end_char_idx": 515405, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fa841011-abcf-4258-a6a0-90f3c89e2132": {"__data__": {"id_": "fa841011-abcf-4258-a6a0-90f3c89e2132", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b8ed9649-0992-4a76-bca5-2ccfaa454ea7", "node_type": "1", "metadata": {}, "hash": "290752932fdc7063c435ec7c9bc4ff8770f98558d465f1b9b4efe19b2aece296", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1cc979c3-3c13-42e9-b015-8d38be4c5c59", "node_type": "1", "metadata": {}, "hash": "845326605fbdac6a9f44aff54921bfad38d488f17076b2cba0e83bc501b6a378", "class_name": "RelatedNodeInfo"}}, "text": "Here,\nwe implement two utility functions for downloading and extracting zip or tar files. Again,\nwe skip implementation details of such utility functions.\ndef download (url, folder, sha1_hash =None ):\n\"\"\"Download a file to folder and return the local filepath.\"\"\"\ndef extract (filename, folder):\n\"\"\"Extract a zip/tar file into folder.\"\"\"\n200 Multilayer Perceptrons\n1095.7.2Kaggle\nKaggle109is a popular platform that hosts machine learning competitions. Each com-\npetition centers on a dataset and many are sponsored by stakeholders who offer prizes to\nthe winning solutions. The platform helps users to interact via forums and shared code,\nfostering both collaboration and competition. While leaderboard chasing often spirals out\nof control, with researchers focusing myopically on preprocessing steps rather than asking\nfundamental questions, there is also tremendous value in the objectivity of a platform that\nfacilitates direct quantitative comparisons among competing approaches as well as code\nsharing so that everyone can learn what did and did not work. If you want to participate in\na Kaggle competition, you will first need to register for an account (see Fig. 5.7.1 ).\ntFig. 5.7.1 The Kaggle website.\nOn the house price prediction competition page, as illustrated in Fig. 5.7.2 , you can find\nthe dataset (under the \u201cData\u201d tab), submit predictions, and see your ranking, The URL is\nright here:\nhttps://www.kaggle.com/c/house-prices-advanced-regression-techniques\ntFig. 5.7.2 The house price prediction competition page.\n5.7.3Accessingand Readingthe Dataset\n201 Predicting House Prices on Kaggle\nNote that the competition data is separated into training and test sets. Each record includes\nthe property value of the house and attributes such as street type, year of construction, roof\ntype, basement condition, etc. The features consist of various data types. For example,\nthe year of construction is represented by an integer, the roof type by discrete categorical\nassignments, and other features by floating point numbers. And here is where reality com-\nplicates things: for some examples, some data is altogether missing with the missing value\nmarked simply as \u201cna\u201d. The price of each house is included for the training set only (it is\na competition after all). We will want to partition the training set to create a validation set,\nbut we only get to evaluate our models on the official test set after uploading predictions to\nKaggle. The \u201cData\u201d tab on the competition tab in Fig. 5.7.2 has links for downloading the\ndata.\nTo get started, we will read in and process the data using pandas, which we introduced\ninSection 2.2 . For convenience, we can download and cache the Kaggle housing dataset.\nIf a file corresponding to this dataset already exists in the cache directory and its SHA-1\nmatches sha1_hash , our code will use the cached file to avoid clogging up your Internet\nwith redundant downloads.\nclass KaggleHouse (d2l .DataModule):\ndef __init__ (self , batch_size, train =None , val =None ):\nsuper ().__init__ ()\nself .save_hyperparameters()\nifself .train isNone :\nself .raw_train =pd.read_csv(d2l .download(\nd2l.DATA_URL +'kaggle_house_pred_train.csv ',self .root,\nsha1_hash ='585e9cc93e70b39160e7921475f9bcd7d31219ce '))\nself .raw_val =pd.read_csv(d2l .download(\nd2l.DATA_URL +'kaggle_house_pred_test.csv ',self .root,\nsha1_hash ='fa19780a7b011d9b009e8bff8e99922a8ee2eb90 '))\nThetrainingdatasetincludes1460examples,80features,andonelabel,whilethevalidation\ndata contains 1459 examples and 80 features.\ndata =KaggleHouse(batch_size =64)\nprint (data .raw_train .shape)\nprint (data .raw_val .shape)\nDownloading ../data /kaggle_house_pred_train .csv from http ://d2l-data .s3-\n\u21a9!accelerate .amazonaws .com/kaggle_house_pred_train .csv...\nDownloading ../data /kaggle_house_pred_test .csv from http ://d2l-data .s3-\n\u21a9!accelerate .amazonaws .com/kaggle_house_pred_test .csv...\n(1460 ,81)\n(1459 ,80)\n5.7.4Data Preprocessing\nLet\u2019s take a look at the first four and final two features as well as the label (SalePrice) from\nthe first four examples.", "mimetype": "text/plain", "start_char_idx": 514720, "end_char_idx": 518782, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1cc979c3-3c13-42e9-b015-8d38be4c5c59": {"__data__": {"id_": "1cc979c3-3c13-42e9-b015-8d38be4c5c59", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fa841011-abcf-4258-a6a0-90f3c89e2132", "node_type": "1", "metadata": {}, "hash": "0f8386e42e8ebc3a51c8e47fb0af719de617ec67310bfc4e4d0ca9c9f4068f26", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f4d39709-e689-4591-968f-5e9429df58fa", "node_type": "1", "metadata": {}, "hash": "5cc28546553f7d2753ec5842b3a54eec333066466f704d2b4b3edf053d4a5e2f", "class_name": "RelatedNodeInfo"}}, "text": "data =KaggleHouse(batch_size =64)\nprint (data .raw_train .shape)\nprint (data .raw_val .shape)\nDownloading ../data /kaggle_house_pred_train .csv from http ://d2l-data .s3-\n\u21a9!accelerate .amazonaws .com/kaggle_house_pred_train .csv...\nDownloading ../data /kaggle_house_pred_test .csv from http ://d2l-data .s3-\n\u21a9!accelerate .amazonaws .com/kaggle_house_pred_test .csv...\n(1460 ,81)\n(1459 ,80)\n5.7.4Data Preprocessing\nLet\u2019s take a look at the first four and final two features as well as the label (SalePrice) from\nthe first four examples.\n202 Multilayer Perceptrons\nprint (data .raw_train .iloc[: 4, [0,1,2,3,-3,-2,-1]])\nId MSSubClass MSZoning LotFrontage SaleType SaleCondition SalePrice\n0 1 60 RL 65.0 WD Normal 208500\n1 2 20 RL 80.0 WD Normal 181500\n2 3 60 RL 68.0 WD Normal 223500\n3 4 70 RL 60.0 WD Abnorml 140000\nWe can see that in each example, the first feature is the identifier. This helps the model\ndetermineeachtrainingexample. Whilethisisconvenient,itdoesnotcarryanyinformation\nfor prediction purposes. Hence, we will remove it from the dataset before feeding the data\nintothemodel. Furthermore,givenawidevarietyofdatatypes,wewillneedtopreprocess\nthe data before we can start modeling.\nLet\u2019s start with the numerical features. First, we apply a heuristic, replacing all missing\nvalues by the corresponding feature\u2019s mean. Then, to put all features on a common scale,\nwestandardize the data by rescaling features to zero mean and unit variance:\n\ud835\udc65 \ud835\udc65\u0000\ud835\udf07\n\ud835\udf0e, (5.7.1)\nwhere\ud835\udf07and\ud835\udf0edenotemeanandstandarddeviation, respectively. Toverifythatthisindeed\ntransforms our feature (variable) such that it has zero mean and unit variance, note that\n\ud835\udc38\u00bb\ud835\udc65\u0000\ud835\udf07\n\ud835\udf0e\u00bc=\ud835\udf07\u0000\ud835\udf07\n\ud835\udf0e=0and that\ud835\udc38\u00bb\u00b9\ud835\udc65\u0000\ud835\udf07\u00ba2\u00bc=\u00b9\ud835\udf0e2\u00b8\ud835\udf072\u00ba\u00002\ud835\udf072\u00b8\ud835\udf072=\ud835\udf0e2. Intuitively, we\nstandardize the data for two reasons. First, it proves convenient for optimization. Second,\nbecausewedonotknow aprioriwhichfeatureswillberelevant,wedonotwanttopenalize\ncoefficients assigned to one feature more than any other.\nNextwedealwithdiscretevalues. Theseincludefeaturessuchas\u201cMSZoning\u201d. Wereplace\nthem by a one-hot encoding in the same way that we earlier transformed multiclass labels\ninto vectors (see Section 4.1.1 ). For instance, \u201cMSZoning\u201d assumes the values \u201cRL\u201d and\n\u201cRM\u201d. Dropping the \u201cMSZoning\u201d feature, two new indicator features \u201cMSZoning_RL\u201d\nand \u201cMSZoning_RM\u201d are created with values being either 0 or 1. According to one-hot\nencoding, if the original value of \u201cMSZoning\u201d is \u201cRL\u201d, then \u201cMSZoning_RL\u201d is 1 and\n\u201cMSZoning_RM\u201d is 0. The pandaspackage does this automatically for us.", "mimetype": "text/plain", "start_char_idx": 518247, "end_char_idx": 520752, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f4d39709-e689-4591-968f-5e9429df58fa": {"__data__": {"id_": "f4d39709-e689-4591-968f-5e9429df58fa", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1cc979c3-3c13-42e9-b015-8d38be4c5c59", "node_type": "1", "metadata": {}, "hash": "845326605fbdac6a9f44aff54921bfad38d488f17076b2cba0e83bc501b6a378", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "12137bef-3990-46e8-b25f-5a7f26ab2187", "node_type": "1", "metadata": {}, "hash": "f889eb912f80b3ab376b15996a6ca1f6a575f65aef380ce6159beeeeb8c2e89a", "class_name": "RelatedNodeInfo"}}, "text": "Nextwedealwithdiscretevalues. Theseincludefeaturessuchas\u201cMSZoning\u201d. Wereplace\nthem by a one-hot encoding in the same way that we earlier transformed multiclass labels\ninto vectors (see Section 4.1.1 ). For instance, \u201cMSZoning\u201d assumes the values \u201cRL\u201d and\n\u201cRM\u201d. Dropping the \u201cMSZoning\u201d feature, two new indicator features \u201cMSZoning_RL\u201d\nand \u201cMSZoning_RM\u201d are created with values being either 0 or 1. According to one-hot\nencoding, if the original value of \u201cMSZoning\u201d is \u201cRL\u201d, then \u201cMSZoning_RL\u201d is 1 and\n\u201cMSZoning_RM\u201d is 0. The pandaspackage does this automatically for us.\n@d2l .add_to_class(KaggleHouse)\ndef preprocess (self ):\n# Remove the ID and label columns\nlabel ='SalePrice '\nfeatures =pd.concat(\n(self .raw_train .drop(columns =['Id', label]),\nself .raw_val .drop(columns =['Id'])))\n# Standardize numerical columns\nnumeric_features =features .dtypes[features .dtypes !='object '].index\nfeatures[numeric_features] =features[numeric_features] .apply(\nlambda x: (x -x.mean()) /(x.std()))\n# Replace NAN numerical features by 0\nfeatures[numeric_features] =features[numeric_features] .fillna( 0)\n(continues on next page)\n203 Predicting House Prices on Kaggle\n(continued from previous page)\n# Replace discrete features by one-hot encoding\nfeatures =pd.get_dummies(features, dummy_na =True )\n# Save preprocessed features\nself .train =features[: self .raw_train .shape[ 0]].copy()\nself .train[label] =self .raw_train[label]\nself .val =features[ self .raw_train .shape[ 0]:].copy()\nYoucanseethatthisconversionincreasesthenumberoffeaturesfrom79to331(excluding\nID and label columns).\ndata .preprocess()\ndata .train .shape\n(1460 ,331)\n5.7.5ErrorMeasure\nTo get started we will train a linear model with squared loss. Not surprisingly, our linear\nmodelwillnotleadtoacompetition-winningsubmissionbutitdoesprovideasanitycheck\nto see whether there is meaningful information in the data. If we cannot do better than\nrandom guessing here, then there might be a good chance that we have a data processing\nbug. And if things work, the linear model will serve as a baseline giving us some intuition\nabout how close the simple model gets to the best reported models, giving us a sense of\nhow much gain we should expect from fancier models.\nWith house prices, as with stock prices, we care about relative quantities more than ab-\nsolute quantities. Thus we tend to care more about the relative error\ud835\udc66\u0000\u02c6\ud835\udc66\n\ud835\udc66than about the\nabsolute error \ud835\udc66\u0000\u02c6\ud835\udc66. For instance, if our prediction is off by $100,000 when estimating the\nprice of a house in rural Ohio, where the value of a typical house is $125,000, then we are\nprobably doing a horrible job. On the other hand, if we err by this amount in Los Altos\nHills, California, this might represent a stunningly accurate prediction (there, the median\nhouse price exceeds $4 million).\nOnewaytoaddressthisproblemistomeasurethediscrepancyinthelogarithmoftheprice\nestimates. In fact, this is also the official error measure used by the competition to evaluate\nthe quality of submissions. After all, a small value \ud835\udeffforjlog\ud835\udc66\u0000log \u02c6\ud835\udc66j\u0014\ud835\udefftranslates into\n\ud835\udc52\u0000\ud835\udeff\u0014\u02c6\ud835\udc66\n\ud835\udc66\u0014\ud835\udc52\ud835\udeff. Thisleadstothefollowingroot-mean-squared-errorbetweenthelogarithm\nof the predicted price and the logarithm of the label price:\nvt\n1\n\ud835\udc5b\ud835\udc5b\u00d5\n\ud835\udc56=1\u00b9log\ud835\udc66\ud835\udc56\u0000log \u02c6\ud835\udc66\ud835\udc56\u00ba2.", "mimetype": "text/plain", "start_char_idx": 520181, "end_char_idx": 523409, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "12137bef-3990-46e8-b25f-5a7f26ab2187": {"__data__": {"id_": "12137bef-3990-46e8-b25f-5a7f26ab2187", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f4d39709-e689-4591-968f-5e9429df58fa", "node_type": "1", "metadata": {}, "hash": "5cc28546553f7d2753ec5842b3a54eec333066466f704d2b4b3edf053d4a5e2f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "51a8835b-34e3-4736-afb3-79865b481727", "node_type": "1", "metadata": {}, "hash": "f2058806e14261e4efd8504d9ce6b185a2c92860a2082f10d639dcdc81c4ac1a", "class_name": "RelatedNodeInfo"}}, "text": "Onewaytoaddressthisproblemistomeasurethediscrepancyinthelogarithmoftheprice\nestimates. In fact, this is also the official error measure used by the competition to evaluate\nthe quality of submissions. After all, a small value \ud835\udeffforjlog\ud835\udc66\u0000log \u02c6\ud835\udc66j\u0014\ud835\udefftranslates into\n\ud835\udc52\u0000\ud835\udeff\u0014\u02c6\ud835\udc66\n\ud835\udc66\u0014\ud835\udc52\ud835\udeff. Thisleadstothefollowingroot-mean-squared-errorbetweenthelogarithm\nof the predicted price and the logarithm of the label price:\nvt\n1\n\ud835\udc5b\ud835\udc5b\u00d5\n\ud835\udc56=1\u00b9log\ud835\udc66\ud835\udc56\u0000log \u02c6\ud835\udc66\ud835\udc56\u00ba2. (5.7.2)\n@d2l .add_to_class(KaggleHouse)\ndef get_dataloader (self , train):\n(continues on next page)\n204 Multilayer Perceptrons\n(continued from previous page)\nlabel ='SalePrice '\ndata =self .train iftrain else self .val\niflabel not indata: return\nget_tensor =lambda x: torch .tensor(x .values .astype( float ),\ndtype =torch .float32)\n# Logarithm of prices\ntensors =(get_tensor(data .drop(columns =[label])), # X\ntorch .log(get_tensor(data[label])) .reshape(( -1,1))) # Y\nreturn self .get_tensorloader(tensors, train)\n5.7.6\ud835\udc3e-FoldCross-Validation\nYou might recall that we introduced cross-validation in Section 3.6.3 , where we discussed\nhow to deal with model selection. We will put this to good use to select the model design\nand to adjust the hyperparameters. We first need a function that returns the \ud835\udc56thfold of the\ndata in a\ud835\udc3e-fold cross-validation procedure. It proceeds by slicing out the \ud835\udc56thsegment as\nvalidationdataandreturningtherestastrainingdata. Notethatthisisnotthemostefficient\nwayofhandlingdataandwewoulddefinitelydosomethingmuchsmarterifourdatasetwas\nconsiderably larger. But this added complexity might obfuscate our code unnecessarily so\nwe can safely omit it here owing to the simplicity of our problem.\ndef k_fold_data (data, k):\nrets =[]\nfold_size =data .train .shape[ 0]//k\nfor jinrange (k):\nidx =range (j*fold_size, (j +1)*fold_size)\nrets .append(KaggleHouse(data .batch_size, data .train .drop(index =idx),\ndata .train .loc[idx]))\nreturn rets\nTheaveragevalidationerrorisreturnedwhenwetrain \ud835\udc3etimesinthe\ud835\udc3e-foldcross-validation.\ndef k_fold (trainer, data, k, lr):\nval_loss, models =[], []\nfor i, data_fold inenumerate (k_fold_data(data, k)):\nmodel =d2l.LinearRegression(lr)\nmodel .board .yscale ='log'\nifi!=0: model .board .display =False\ntrainer .fit(model, data_fold)\nval_loss .append( float (model .board .data[ 'val_loss '][-1].y))\nmodels .append(model)\nprint (f'average validation log mse = {sum(val_loss) /len(val_loss) }')\nreturn models\n5.7.7Model Selection\nIn this example, we pick an untuned set of hyperparameters and leave it up to the reader to\nimprovethemodel. Findingagoodchoicecantaketime,dependingonhowmanyvariables\none optimizes over. With a large enough dataset, and the normal sorts of hyperparameters,\n205 Predicting House Prices on Kaggle\n\ud835\udc3e-fold cross-validation tends to be reasonably resilient against multiple testing. However,\nif we try an unreasonably large number of options we might find that our validation perfor-\nmance is no longer representative of the true error.\ntrainer =d2l.Trainer(max_epochs =10)\nmodels =k_fold(trainer, data, k =5, lr =0.01 )\naverage validation log mse =0.17325432986021042\nNoticethatsometimesthenumberoftrainingerrorsforasetofhyperparameterscanbevery\nlow, even as the number of errors on \ud835\udc3e-fold cross-validation grows considerably higher.\nThis indicates that we are overfitting. Throughout training you will want to monitor both\nnumbers. Less overfitting might indicate that our data can support a more powerful model.\nMassive overfitting might suggest that we can gain by incorporating regularization tech-\nniques.", "mimetype": "text/plain", "start_char_idx": 522980, "end_char_idx": 526498, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "51a8835b-34e3-4736-afb3-79865b481727": {"__data__": {"id_": "51a8835b-34e3-4736-afb3-79865b481727", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "12137bef-3990-46e8-b25f-5a7f26ab2187", "node_type": "1", "metadata": {}, "hash": "f889eb912f80b3ab376b15996a6ca1f6a575f65aef380ce6159beeeeb8c2e89a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3c200dda-f51a-4e20-9fdf-20a7cdfc5a91", "node_type": "1", "metadata": {}, "hash": "304f77ade5810a56b58b794e08f1f72e2b6c52bb522a30d9a1625b82f78b90d6", "class_name": "RelatedNodeInfo"}}, "text": "However,\nif we try an unreasonably large number of options we might find that our validation perfor-\nmance is no longer representative of the true error.\ntrainer =d2l.Trainer(max_epochs =10)\nmodels =k_fold(trainer, data, k =5, lr =0.01 )\naverage validation log mse =0.17325432986021042\nNoticethatsometimesthenumberoftrainingerrorsforasetofhyperparameterscanbevery\nlow, even as the number of errors on \ud835\udc3e-fold cross-validation grows considerably higher.\nThis indicates that we are overfitting. Throughout training you will want to monitor both\nnumbers. Less overfitting might indicate that our data can support a more powerful model.\nMassive overfitting might suggest that we can gain by incorporating regularization tech-\nniques.\n5.7.8SubmittingPredictionson Kaggle\nNow that we know what a good choice of hyperparameters should be, we might calculate\nthe average predictions on the test set by all the \ud835\udc3emodels. Saving the predictions in a csv\nfile will simplify uploading the results to Kaggle. The following code will generate a file\ncalled submission.csv .\npreds =[model(torch .tensor(data .val.values .astype( float ), dtype =torch .\n\u21a9!float32))\nfor model inmodels]\n# Taking exponentiation of predictions in the logarithm scale\nensemble_preds =torch .exp(torch .cat(preds, 1)).mean( 1)\nsubmission =pd.DataFrame({ 'Id':data .raw_val .Id,\n'SalePrice ':ensemble_preds .detach() .numpy()})\nsubmission .to_csv( 'submission.csv ', index =False )\nNext, as demonstrated in Fig. 5.7.3 , we can submit our predictions on Kaggle and see how\nthey compare with the actual house prices (labels) on the test set. The steps are quite\nsimple:\n\u000fLog in to the Kaggle website and visit the house price prediction competition page.\n206 Multilayer Perceptrons\n110\u000fClick the \u201cSubmit Predictions\u201d or \u201cLate Submission\u201d button.\n\u000fClick the \u201cUpload Submission File\u201d button in the dashed box at the bottom of the page\nand select the prediction file you wish to upload.\n\u000fClick the \u201cMake Submission\u201d button at the bottom of the page to view your results.\ntFig. 5.7.3 Submitting data to Kaggle\n5.7.9Summaryand Discussion\nRealdataoftencontainsamixofdifferentdatatypesandneedstobepreprocessed. Rescal-\ning real-valued data to zero mean and unit variance is a good default. So is replacing miss-\ning values with their mean. Furthermore, transforming categorical features into indicator\nfeatures allows us to treat them like one-hot vectors. When we tend to care more about the\nrelative error than about the absolute error, we can measure the discrepancy in the loga-\nrithm of the prediction. To select the model and adjust the hyperparameters, we can use\n\ud835\udc3e-fold cross-validation .\n5.7.10Exercises\n1.Submit your predictions for this section to Kaggle. How good are they?\n2.Is it always a good idea to replace missing values by a mean? Hint: can you construct a\nsituation where the values are not missing at random?\n3.Improve the score by tuning the hyperparameters through \ud835\udc3e-fold cross-validation.\n4.Improve the score by improving the model (e.g., layers, weight decay, and dropout).\n5.What happens if we do not standardize the continuous numerical features as we have\ndone in this section?\nDiscussions110.\n6 Builders\u2019 Guide\nAlongside giant datasets and powerful hardware, great software tools have played an in-\ndispensable role in the rapid progress of deep learning. Starting with the pathbreaking\nTheano library released in 2007, flexible open-source tools have enabled researchers to\nrapidly prototype models, avoiding repetitive work when recycling standard components\nwhile still maintaining the ability to make low-level modifications. Over time, deep learn-\ning\u2019slibrarieshaveevolvedtoofferincreasinglycoarseabstractions. Justassemiconductor\ndesigners went from specifying transistors to logical circuits to writing code, neural net-\nworksresearchershavemovedfromthinkingaboutthebehaviorofindividualartificialneu-\nronstoconceivingofnetworksintermsofwholelayers,andnowoftendesignarchitectures\nwith far coarser blocksin mind.\nSo far, we have introduced some basic machine learning concepts, ramping up to fully-\nfunctional deep learning models. In the last chapter, we implemented each component of\nan MLP from scratch and even showed how to leverage high-level APIs to roll out the\nsame models effortlessly.", "mimetype": "text/plain", "start_char_idx": 525770, "end_char_idx": 530051, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3c200dda-f51a-4e20-9fdf-20a7cdfc5a91": {"__data__": {"id_": "3c200dda-f51a-4e20-9fdf-20a7cdfc5a91", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "51a8835b-34e3-4736-afb3-79865b481727", "node_type": "1", "metadata": {}, "hash": "f2058806e14261e4efd8504d9ce6b185a2c92860a2082f10d639dcdc81c4ac1a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4286f418-ca59-4f91-879b-ddc181bf4748", "node_type": "1", "metadata": {}, "hash": "a66e5bc59b444b678473a3cfc6b0c61618fc26991c2fecaaa2cdbb5d8fc3ce10", "class_name": "RelatedNodeInfo"}}, "text": "Over time, deep learn-\ning\u2019slibrarieshaveevolvedtoofferincreasinglycoarseabstractions. Justassemiconductor\ndesigners went from specifying transistors to logical circuits to writing code, neural net-\nworksresearchershavemovedfromthinkingaboutthebehaviorofindividualartificialneu-\nronstoconceivingofnetworksintermsofwholelayers,andnowoftendesignarchitectures\nwith far coarser blocksin mind.\nSo far, we have introduced some basic machine learning concepts, ramping up to fully-\nfunctional deep learning models. In the last chapter, we implemented each component of\nan MLP from scratch and even showed how to leverage high-level APIs to roll out the\nsame models effortlessly. To get you that far that fast, we called upon the libraries, but\nskipped over more advanced details about how they work . In this chapter, we will peel\nback the curtain, digging deeper into the key components of deep learning computation,\nnamely model construction, parameter access and initialization, designing custom layers\nand blocks, reading and writing models to disk, and leveraging GPUs to achieve dramatic\nspeedups. These insights will move you from enduser topoweruser , giving you the tools\nneededtoreapthebenefitsofamaturedeeplearninglibrarywhileretainingtheflexibilityto\nimplement more complex models, including those you invent yourself! While this chapter\ndoesnotintroduceanynewmodelsordatasets,theadvancedmodelingchaptersthatfollow\nrely heavily on these techniques.\n6.1Layersand Modules\nWhen we first introduced neural networks, we focused on linear models with a single out-\nput. Here, the entire model consists of just a single neuron. Note that a single neuron (i)\ntakes some set of inputs; (ii) generates a corresponding scalar output; and (iii) has a set of\nassociated parameters that can be updated to optimize some objective function of interest.\nThen, once we started thinking about networks with multiple outputs, we leveraged vec-\ntorized arithmetic to characterize an entire layer of neurons. Just like individual neurons,\n207\n208 Builders\u2019 Guide\nlayers (i) take a set of inputs, (ii) generate corresponding outputs, and (iii) are described by\na set of tunable parameters. When we worked through softmax regression, a single layer\nwas itself the model. However, even when we subsequently introduced MLPs, we could\nstill think of the model as retaining this same basic structure.\nInterestingly,forMLPs,boththeentiremodelanditsconstituentlayerssharethisstructure.\nTheentiremodeltakesinrawinputs(thefeatures), generatesoutputs(thepredictions), and\npossesses parameters (the combined parameters from all constituent layers). Likewise,\neach individual layer ingests inputs (supplied by the previous layer) generates outputs (the\ninputs to the subsequent layer), and possesses a set of tunable parameters that are updated\naccording to the signal that flows backwards from the subsequent layer.\nWhile you might think that neurons, layers, and models give us enough abstractions to go\nabout our business, it turns out that we often find it convenient to speak about components\nthat are larger than an individual layer but smaller than the entire model. For example, the\nResNet-152architecture,whichiswildlypopularincomputervision,possesseshundredsof\nlayers. These layers consist of repeating patterns of groups of layers . Implementing such\na network one layer at a time can grow tedious. This concern is not just hypothetical\u2014\nsuch design patterns are common in practice. The ResNet architecture mentioned above\nwonthe2015ImageNetandCOCOcomputervisioncompetitionsforbothrecognitionand\ndetection ( Heetal., 2016) and remains a go-to architecture for many vision tasks. Similar\narchitectures in which layers are arranged in various repeating patterns are now ubiquitous\nin other domains, including natural language processing and speech.\nTo implement these complex networks, we introduce the concept of a neural network mod-\nule. A module could describe a single layer, a component consisting of multiple layers,\nor the entire model itself! One benefit of working with the module abstraction is that they\ncan be combined into larger artifacts, often recursively. This is illustrated in Fig. 6.1.1 .\nBy defining code to generate modules of arbitrary complexity on demand, we can write\nsurprisingly compact code and still implement complex neural networks.\ntFig. 6.1.1 Multiple layers are combined into modules, forming repeating patterns of larger models.\nFrom a programming standpoint, a module is represented by a class. Any subclass of it\nmust define a forward propagation method that transforms its input into output and must\nstore any necessary parameters. Note that some modules do not require any parameters at\n209 Layers and Modules\nall.", "mimetype": "text/plain", "start_char_idx": 529380, "end_char_idx": 534114, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4286f418-ca59-4f91-879b-ddc181bf4748": {"__data__": {"id_": "4286f418-ca59-4f91-879b-ddc181bf4748", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3c200dda-f51a-4e20-9fdf-20a7cdfc5a91", "node_type": "1", "metadata": {}, "hash": "304f77ade5810a56b58b794e08f1f72e2b6c52bb522a30d9a1625b82f78b90d6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cc220c01-464e-484b-bffe-85f301700500", "node_type": "1", "metadata": {}, "hash": "bb0d134e917fb19be12732b50cde1b1923ed2de1a28a74aa92ed2b2605d3aa91", "class_name": "RelatedNodeInfo"}}, "text": "To implement these complex networks, we introduce the concept of a neural network mod-\nule. A module could describe a single layer, a component consisting of multiple layers,\nor the entire model itself! One benefit of working with the module abstraction is that they\ncan be combined into larger artifacts, often recursively. This is illustrated in Fig. 6.1.1 .\nBy defining code to generate modules of arbitrary complexity on demand, we can write\nsurprisingly compact code and still implement complex neural networks.\ntFig. 6.1.1 Multiple layers are combined into modules, forming repeating patterns of larger models.\nFrom a programming standpoint, a module is represented by a class. Any subclass of it\nmust define a forward propagation method that transforms its input into output and must\nstore any necessary parameters. Note that some modules do not require any parameters at\n209 Layers and Modules\nall. Finally a module must possess a backpropagation method, for purposes of calculating\ngradients. Fortunately,duetosomebehind-the-scenesmagicsuppliedbytheautodifferen-\ntiation (introduced in Section 2.5 ) when defining our own module, we only need to worry\nabout parameters and the forward propagation method.\nimport torch\nfrom torch import nn\nfrom torch .nnimport functional asF\nTo begin, we revisit the code that we used to implement MLPs ( Section 5.1 ). The follow-\ning code generates a network with one fully connected hidden layer with 256 units and\nReLU activation, followed by a fully connected output layer with ten units (no activation\nfunction).\nnet =nn.Sequential(nn .LazyLinear( 256), nn .ReLU(), nn .LazyLinear( 10))\nX=torch .rand( 2,20)\nnet(X) .shape\ntorch .Size([ 2,10])\nIn this example, we constructed our model by instantiating an nn.Sequential , with layers\nin the order that they should be executed passed as arguments. In short, nn.Sequential\ndefines a special kind of Module, the class that presents a module in PyTorch. It maintains\nanorderedlistofconstituent Modules. Notethateachofthetwofullyconnectedlayersisan\ninstanceofthe Linearclasswhichis itselfa subclassof Module. The forwardpropagation\n(forward ) method is also remarkably simple: it chains each module in the list together,\npassing the output of each as input to the next. Note that until now, we have been invok-\ning our models via the construction net(X)to obtain their outputs. This is actually just\nshorthand for net.__call__(X) .\n6.1.1A Custom Module\nPerhaps the easiest way to develop intuition about how a module works is to implement\none ourselves. Before we do that, we briefly summarize the basic functionality that each\nmodule must provide:\n1.Ingest input data as arguments to its forward propagation method.\n2.Generate an output by having the forward propagation method return a value. Note\nthat the output may have a different shape from the input. For example, the first fully\nconnected layer in our model above ingests an input of arbitrary dimension but returns\nan output of dimension 256.\n3.Calculate the gradient of its output with respect to its input, which can be accessed via\nits backpropagation method. Typically this happens automatically.\n210 Builders\u2019 Guide\n4.Store and provide access to those parameters necessary for executing the forward prop-\nagation computation.\n5.Initialize model parameters as needed.\nIn the following snippet, we code up a module from scratch corresponding to an MLP\nwith one hidden layer with 256 hidden units, and a 10-dimensional output layer. Note that\ntheMLPclass below inherits the class that represents a module. We will heavily rely on\nthe parent class\u2019s methods, supplying only our own constructor (the __init__ method in\nPython) and the forward propagation method.\nclass MLP(nn.Module):\ndef __init__ (self ):\n# Call the constructor of the parent class nn.Module to perform\n# the necessary initialization\nsuper ().__init__ ()\nself .hidden =nn.LazyLinear( 256)\nself .out =nn.LazyLinear( 10)\n# Define the forward propagation of the model, that is, how to return the\n# required model output based on the input X\ndef forward (self , X):\nreturn self .out(F .relu( self .hidden(X)))\nLet\u2019s first focus on the forward propagation method. Note that it takes Xas input, calcu-\nlates the hidden representation with the activation function applied, and outputs its logits.\nIn this MLPimplementation, both layers are instance variables. To see why this is reason-\nable, imagine instantiating two MLPs, net1andnet2, and training them on different data.", "mimetype": "text/plain", "start_char_idx": 533208, "end_char_idx": 537695, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cc220c01-464e-484b-bffe-85f301700500": {"__data__": {"id_": "cc220c01-464e-484b-bffe-85f301700500", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4286f418-ca59-4f91-879b-ddc181bf4748", "node_type": "1", "metadata": {}, "hash": "a66e5bc59b444b678473a3cfc6b0c61618fc26991c2fecaaa2cdbb5d8fc3ce10", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "14bb583a-fd06-45c0-86ea-863a9e175427", "node_type": "1", "metadata": {}, "hash": "41723816da94ddbbd0d3368e659b52247805ed3125ce666ea8321fa3ab065a73", "class_name": "RelatedNodeInfo"}}, "text": "class MLP(nn.Module):\ndef __init__ (self ):\n# Call the constructor of the parent class nn.Module to perform\n# the necessary initialization\nsuper ().__init__ ()\nself .hidden =nn.LazyLinear( 256)\nself .out =nn.LazyLinear( 10)\n# Define the forward propagation of the model, that is, how to return the\n# required model output based on the input X\ndef forward (self , X):\nreturn self .out(F .relu( self .hidden(X)))\nLet\u2019s first focus on the forward propagation method. Note that it takes Xas input, calcu-\nlates the hidden representation with the activation function applied, and outputs its logits.\nIn this MLPimplementation, both layers are instance variables. To see why this is reason-\nable, imagine instantiating two MLPs, net1andnet2, and training them on different data.\nNaturally, we would expect them to represent two different learned models.\nWe instantiate the MLP\u2019s layers in the constructor and subsequently invoke these layers on\neach call to the forward propagation method. Note a few key details. First, our customized\n__init__ method invokes the parent class\u2019s __init__ method via super().__init__()\nsparing us the pain of restating boilerplate code applicable to most modules. We then\ninstantiate our two fully connected layers, assigning them to self.hidden andself.out .\nNote that unless we implement a new layer, we need not worry about the backpropagation\nmethod or parameter initialization. The system will generate these methods automatically.\nLet\u2019s try this out.\nnet =MLP()\nnet(X) .shape\ntorch .Size([ 2,10])\nAkeyvirtueofthemoduleabstractionisitsversatility. Wecansubclassamoduletocreate\nlayers(suchasthefullyconnectedlayerclass), entiremodels(suchasthe MLPclassabove),\nor various components of intermediate complexity. We exploit this versatility throughout\nthe coming chapters, such as when addressing convolutional neural networks.\n211 Layers and Modules\n6.1.2The SequentialModule\nWe can now take a closer look at how the Sequential class works. Recall that Sequen-\ntialwas designed to daisy-chain other modules together. To build our own simplified\nMySequential , we just need to define two key methods:\n1.A method for appending modules one by one to a list.\n2.Aforwardpropagationmethodforpassinganinputthroughthechainofmodules,inthe\nsame order as they were appended.\nThe following MySequential class delivers the same functionality of the default Sequen-\ntialclass.\nclass MySequential (nn.Module):\ndef __init__ (self ,*args):\nsuper ().__init__ ()\nfor idx, module inenumerate (args):\nself .add_module( str(idx), module)\ndef forward (self , X):\nfor module inself .children():\nX=module(X)\nreturn X\nInthe __init__ method,weaddeverymodulebycallingthe add_modules method. These\nmodules can be accessed by the children method at a later date. In this way the system\nknows the added modules, and it will properly initialize each module\u2019s parameters.\nWhen our MySequential \u2019s forward propagation method is invoked, each added module is\nexecuted in the order in which they were added. We can now reimplement an MLP using\nourMySequential class.\nnet =MySequential(nn .LazyLinear( 256), nn .ReLU(), nn .LazyLinear( 10))\nnet(X) .shape\ntorch .Size([ 2,10])\nNote that this use of MySequential is identical to the code we previously wrote for the\nSequential class (as described in Section 5.1 ).\n6.1.3ExecutingCode in the ForwardPropagationMethod\nTheSequential class makes model construction easy, allowing us to assemble new archi-\ntectures without having to define our own class. However, not all architectures are simple\ndaisy chains. When greater flexibility is required, we will want to define our own blocks.\nFor example, we might want to execute Python\u2019s control flow within the forward propaga-\ntion method. Moreover, we might want to perform arbitrary mathematical operations, not\nsimply relying on predefined neural network layers.\n212 Builders\u2019 Guide\nYou may have noticed that until now, all of the operations in our networks have acted upon\nour network\u2019s activations and its parameters. Sometimes, however, we might want to in-\ncorporate terms that are neither the result of previous layers nor updatable parameters. We\ncall these constant parameters . Say for example that we want a layer that calculates the\nfunction\ud835\udc53\u00b9x,w\u00ba=\ud835\udc50\u0001w>x, where xis the input, wis our parameter, and \ud835\udc50is some speci-\nfiedconstantthatisnotupdatedduringoptimization.", "mimetype": "text/plain", "start_char_idx": 536923, "end_char_idx": 541282, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "14bb583a-fd06-45c0-86ea-863a9e175427": {"__data__": {"id_": "14bb583a-fd06-45c0-86ea-863a9e175427", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cc220c01-464e-484b-bffe-85f301700500", "node_type": "1", "metadata": {}, "hash": "bb0d134e917fb19be12732b50cde1b1923ed2de1a28a74aa92ed2b2605d3aa91", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "90bded7c-0a2e-48b5-b6d6-075dadb2e012", "node_type": "1", "metadata": {}, "hash": "d6bde4b775ff5f866bf78e5f24db1b506d5dc954be24f245b1d78bac24ca4853", "class_name": "RelatedNodeInfo"}}, "text": "However, not all architectures are simple\ndaisy chains. When greater flexibility is required, we will want to define our own blocks.\nFor example, we might want to execute Python\u2019s control flow within the forward propaga-\ntion method. Moreover, we might want to perform arbitrary mathematical operations, not\nsimply relying on predefined neural network layers.\n212 Builders\u2019 Guide\nYou may have noticed that until now, all of the operations in our networks have acted upon\nour network\u2019s activations and its parameters. Sometimes, however, we might want to in-\ncorporate terms that are neither the result of previous layers nor updatable parameters. We\ncall these constant parameters . Say for example that we want a layer that calculates the\nfunction\ud835\udc53\u00b9x,w\u00ba=\ud835\udc50\u0001w>x, where xis the input, wis our parameter, and \ud835\udc50is some speci-\nfiedconstantthatisnotupdatedduringoptimization. Soweimplementa FixedHiddenMLP\nclass as follows.\nclass FixedHiddenMLP (nn.Module):\ndef __init__ (self ):\nsuper ().__init__ ()\n# Random weight parameters that will not compute gradients and\n# therefore keep constant during training\nself .rand_weight =torch .rand(( 20,20))\nself .linear =nn.LazyLinear( 20)\ndef forward (self , X):\nX=self .linear(X)\nX=F.relu(X @self .rand_weight +1)\n# Reuse the fully connected layer. This is equivalent to sharing\n# parameters with two fully connected layers\nX=self .linear(X)\n# Control flow\nwhile X.abs() .sum() >1:\nX/=2\nreturn X.sum()\nIn this model, we implement a hidden layer whose weights ( self.rand_weight ) are ini-\ntialized randomly at instantiation and are thereafter constant. This weight is not a model\nparameter and thus it is never updated by backpropagation. The network then passes the\noutput of this \u201cfixed\u201d layer through a fully connected layer.\nNote that before returning the output, our model did something unusual. We ran a while-\nloop, testing on the condition its \u21131norm is larger than 1, and dividing our output vector\nby2until it satisfied the condition. Finally, we returned the sum of the entries in X. To our\nknowledge, no standard neural network performs this operation. Note that this particular\noperation may not be useful in any real-world task. Our point is only to show you how to\nintegrate arbitrary code into the flow of your neural network computations.\nnet =FixedHiddenMLP()\nnet(X)\ntensor( -0.3836 , grad_fn =<SumBackward0 >)\nWe can mix and match various ways of assembling modules together. In the following\nexample, we nest modules in some creative ways.\nclass NestMLP (nn.Module):\n(continues on next page)\n213 Parameter Management\n111(continued from previous page)\ndef __init__ (self ):\nsuper ().__init__ ()\nself .net =nn.Sequential(nn .LazyLinear( 64), nn .ReLU(),\nnn.LazyLinear( 32), nn .ReLU())\nself .linear =nn.LazyLinear( 16)\ndef forward (self , X):\nreturn self .linear( self .net(X))\nchimera =nn.Sequential(NestMLP(), nn .LazyLinear( 20), FixedHiddenMLP())\nchimera(X)\ntensor( 0.0679 , grad_fn =<SumBackward0 >)\n6.1.4Summary\nIndividuallayerscanbemodules. Manylayerscancompriseamodule. Manymodulescan\ncomprise a module.\nA module can contain code. Modules take care of lots of housekeeping, including param-\neter initialization and backpropagation. Sequential concatenations of layers and modules\nare handled by the Sequential module.\n6.1.5Exercises\n1.What kinds of problems will occur if you change MySequential to store modules in a\nPython list?\n2.Implement a module that takes two modules as an argument, say net1andnet2and\nreturns the concatenated output of both networks in the forward propagation. This is\nalso called a parallelmodule .\n3.Assume that you want to concatenate multiple instances of the same network. Imple-\nment a factory function that generates multiple instances of the same module and build\na larger network from it.\nDiscussions111.\n6.2ParameterManagement\nOnce we have chosen an architecture and set our hyperparameters, we proceed to the train-\ning loop, where our goal is to find parameter values that minimize our loss function. After\ntraining, we will need these parameters in order to make future predictions.", "mimetype": "text/plain", "start_char_idx": 540413, "end_char_idx": 544496, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "90bded7c-0a2e-48b5-b6d6-075dadb2e012": {"__data__": {"id_": "90bded7c-0a2e-48b5-b6d6-075dadb2e012", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "14bb583a-fd06-45c0-86ea-863a9e175427", "node_type": "1", "metadata": {}, "hash": "41723816da94ddbbd0d3368e659b52247805ed3125ce666ea8321fa3ab065a73", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7aa8b595-d077-4205-8a57-fb408a906c94", "node_type": "1", "metadata": {}, "hash": "36a003fc052b894757f146589484337616a2e554076795fcd63d265547a9e897", "class_name": "RelatedNodeInfo"}}, "text": "Sequential concatenations of layers and modules\nare handled by the Sequential module.\n6.1.5Exercises\n1.What kinds of problems will occur if you change MySequential to store modules in a\nPython list?\n2.Implement a module that takes two modules as an argument, say net1andnet2and\nreturns the concatenated output of both networks in the forward propagation. This is\nalso called a parallelmodule .\n3.Assume that you want to concatenate multiple instances of the same network. Imple-\nment a factory function that generates multiple instances of the same module and build\na larger network from it.\nDiscussions111.\n6.2ParameterManagement\nOnce we have chosen an architecture and set our hyperparameters, we proceed to the train-\ning loop, where our goal is to find parameter values that minimize our loss function. After\ntraining, we will need these parameters in order to make future predictions. Additionally,\nwe will sometimes wish to extract the parameters perhaps to reuse them in some other\n214 Builders\u2019 Guide\ncontext, to save our model to disk so that it may be executed in other software, or for ex-\namination in the hope of gaining scientific understanding.\nMost of the time, we will be able to ignore the nitty-gritty details of how parameters are\ndeclared and manipulated, relying on deep learning frameworks to do the heavy lifting.\nHowever, when we move away from stacked architectures with standard layers, we will\nsometimes need to get into the weeds of declaring and manipulating parameters. In this\nsection, we cover the following:\n\u000fAccessing parameters for debugging, diagnostics, and visualizations.\n\u000fSharing parameters across different model components.\nimport torch\nfrom torch import nn\nWe start by focusing on an MLP with one hidden layer.\nnet =nn.Sequential(nn .LazyLinear( 8),\nnn.ReLU(),\nnn.LazyLinear( 1))\nX=torch .rand(size =(2,4))\nnet(X) .shape\ntorch .Size([ 2,1])\n6.2.1ParameterAccess\nLet\u2019s start with how to access parameters from the models that you already know.\nWhenamodelisdefinedviathe Sequential class,wecanfirstaccessanylayerbyindexing\ninto the model as though it were a list. Each layer\u2019s parameters are conveniently located in\nits attribute.\nWe can inspect the parameters of the second fully connected layer as follows.\nnet[ 2].state_dict()\nOrderedDict([( 'weight ',\ntensor([[ -0.1649 ,0.0605 ,0.1694 ,-0.2524 ,0.3526 ,-0.3414 ,-\n\u21a9!0.2322 ,0.0822 ]])),\n('bias ', tensor([ 0.0709 ]))])\nWe can see that this fully connected layer contains two parameters, corresponding to that\nlayer\u2019s weights and biases, respectively.\n215 Parameter Management\nTargetedParameters\nNote that each parameter is represented as an instance of the parameter class. To do any-\nthing useful with the parameters, we first need to access the underlying numerical values.\nThere are several ways to do this. Some are simpler while others are more general. The\nfollowing code extracts the bias from the second neural network layer, which returns a\nparameter class instance, and further accesses that parameter\u2019s value.\ntype (net[ 2].bias), net[ 2].bias .data\n(torch .nn.parameter .Parameter, tensor([ 0.0709 ]))\nParameters are complex objects, containing values, gradients, and additional information.\nThat is why we need to request the value explicitly.\nIn addition to the value, each parameter also allows us to access the gradient. Because we\nhave not invoked backpropagation for this network yet, it is in its initial state.\nnet[ 2].weight .grad ==None\nTrue\nAllParametersat Once\nWhen we need to perform operations on all parameters, accessing them one-by-one can\ngrow tedious. The situation can grow especially unwieldy when we work with more com-\nplex,e.g.,nested,modules,sincewewouldneedtorecursethroughtheentiretreetoextract\neach sub-module\u2019s parameters. Below we demonstrate accessing the parameters of all lay-\ners.\n[(name, param .shape) for name, param innet.named_parameters()]\n[('0.weight ', torch .Size([ 8,4])),\n('0.bias ', torch .Size([ 8])),\n('2.weight ', torch .Size([ 1,8])),\n('2.bias ', torch .Size([ 1]))]\n6.2.2TiedParameters\nOften,wewanttoshareparametersacrossmultiplelayers. Let\u2019sseehowtodothiselegantly.\nIn the following we allocate a fully connected layer and then use its parameters specifically\nto set those of another layer. Here we need to run the forward propagation net(X)before\naccessing the parameters.", "mimetype": "text/plain", "start_char_idx": 543607, "end_char_idx": 547940, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7aa8b595-d077-4205-8a57-fb408a906c94": {"__data__": {"id_": "7aa8b595-d077-4205-8a57-fb408a906c94", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "90bded7c-0a2e-48b5-b6d6-075dadb2e012", "node_type": "1", "metadata": {}, "hash": "d6bde4b775ff5f866bf78e5f24db1b506d5dc954be24f245b1d78bac24ca4853", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1ecb85cf-23fb-4794-8b19-b0090b1fd607", "node_type": "1", "metadata": {}, "hash": "5c8c695f1dd9e67344685ec8477cb8231de58f300cbe5d72dbf171107e0c9f53", "class_name": "RelatedNodeInfo"}}, "text": "Below we demonstrate accessing the parameters of all lay-\ners.\n[(name, param .shape) for name, param innet.named_parameters()]\n[('0.weight ', torch .Size([ 8,4])),\n('0.bias ', torch .Size([ 8])),\n('2.weight ', torch .Size([ 1,8])),\n('2.bias ', torch .Size([ 1]))]\n6.2.2TiedParameters\nOften,wewanttoshareparametersacrossmultiplelayers. Let\u2019sseehowtodothiselegantly.\nIn the following we allocate a fully connected layer and then use its parameters specifically\nto set those of another layer. Here we need to run the forward propagation net(X)before\naccessing the parameters.\n216 Builders\u2019 Guide\n112# We need to give the shared layer a name so that we can refer to its\n# parameters\nshared =nn.LazyLinear( 8)\nnet =nn.Sequential(nn .LazyLinear( 8), nn .ReLU(),\nshared, nn .ReLU(),\nshared, nn .ReLU(),\nnn.LazyLinear( 1))\nnet(X)\n# Check whether the parameters are the same\nprint (net[ 2].weight .data[ 0]==net[ 4].weight .data[ 0])\nnet[ 2].weight .data[ 0,0]=100\n# Make sure that they are actually the same object rather than just having the\n# same value\nprint (net[ 2].weight .data[ 0]==net[ 4].weight .data[ 0])\ntensor([ True ,True ,True ,True ,True ,True ,True ,True ])\ntensor([ True ,True ,True ,True ,True ,True ,True ,True ])\nThis example shows that the parameters of the second and third layer are tied. They are\nnot just equal, they are represented by the same exact tensor. Thus, if we change one of the\nparameters, the other one changes, too.\nYou might wonder, when parameters are tied what happens to the gradients? Since the\nmodel parameters contain gradients, the gradients of the second hidden layer and the third\nhidden layer are added together during backpropagation.\n6.2.3Summary\nWe have several ways of accessing and tying model parameters.\n6.2.4Exercises\n1.Use the NestMLP model defined in Section 6.1 and access the parameters of the various\nlayers.\n2.Construct an MLP containing a shared parameter layer and train it. During the training\nprocess, observe the model parameters and gradients of each layer.\n3.Why is sharing parameters a good idea?\nDiscussions112.\n6.3ParameterInitialization\nNow that we know how to access the parameters, let\u2019s look at how to initialize them prop-\nerly. We discussed the need for proper initialization in Section 5.4 . The deep learning\n217 Parameter Initialization\nframework provides default random initializations to its layers. However, we often want to\ninitialize our weights according to various other protocols. The framework provides most\ncommonly used protocols, and also allows to create a custom initializer.\nimport torch\nfrom torch import nn\nBydefault,PyTorchinitializesweightandbiasmatricesuniformlybydrawingfromarange\nthat is computed according to the input and output dimension. PyTorch\u2019s nn.init module\nprovides a variety of preset initialization methods.\nnet =nn.Sequential(nn .LazyLinear( 8), nn .ReLU(), nn .LazyLinear( 1))\nX=torch .rand(size =(2,4))\nnet(X) .shape\ntorch .Size([ 2,1])\n6.3.1Built-in Initialization\nLet\u2019sbeginbycallingonbuilt-ininitializers. Thecodebelowinitializesallweightparame-\nters as Gaussian random variables with standard deviation 0.01, while bias parameters are\ncleared to zero.\ndef init_normal (module):\niftype (module) ==nn.Linear:\nnn.init .normal_(module .weight, mean =0, std =0.01 )\nnn.init .zeros_(module .bias)\nnet.apply(init_normal)\nnet[ 0].weight .data[ 0], net[ 0].bias .data[ 0]\n(tensor([ -0.0129 ,-0.0007 ,-0.0033 ,0.0276 ]), tensor( 0.))\nWe can also initialize all the parameters to a given constant value (say, 1).\ndef init_constant (module):\niftype (module) ==nn.Linear:\nnn.init .constant_(module .weight, 1)\nnn.init .zeros_(module .bias)\nnet.apply(init_constant)\nnet[ 0].weight .data[ 0], net[ 0].bias .data[ 0]\n(tensor([ 1.,1.,1.,1.]), tensor( 0.))", "mimetype": "text/plain", "start_char_idx": 547368, "end_char_idx": 551121, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1ecb85cf-23fb-4794-8b19-b0090b1fd607": {"__data__": {"id_": "1ecb85cf-23fb-4794-8b19-b0090b1fd607", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7aa8b595-d077-4205-8a57-fb408a906c94", "node_type": "1", "metadata": {}, "hash": "36a003fc052b894757f146589484337616a2e554076795fcd63d265547a9e897", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "382ef4a6-f79f-435d-ae5a-c80858947111", "node_type": "1", "metadata": {}, "hash": "24a3b78de680252131732cffbfdb1692272dc97806493f2c645af8ab4fda426d", "class_name": "RelatedNodeInfo"}}, "text": "We can also initialize all the parameters to a given constant value (say, 1).\ndef init_constant (module):\niftype (module) ==nn.Linear:\nnn.init .constant_(module .weight, 1)\nnn.init .zeros_(module .bias)\nnet.apply(init_constant)\nnet[ 0].weight .data[ 0], net[ 0].bias .data[ 0]\n(tensor([ 1.,1.,1.,1.]), tensor( 0.))\nWe can also apply different initializers for certain blocks. For example, below we initialize\n218 Builders\u2019 Guide\nthe first layer with the Xavier initializer and initialize the second layer to a constant value\nof 42.\ndef init_xavier (module):\niftype (module) ==nn.Linear:\nnn.init .xavier_uniform_(module .weight)\ndef init_42 (module):\niftype (module) ==nn.Linear:\nnn.init .constant_(module .weight, 42)\nnet[ 0].apply(init_xavier)\nnet[ 2].apply(init_42)\nprint (net[ 0].weight .data[ 0])\nprint (net[ 2].weight .data)\ntensor([ -0.0974 ,0.1707 ,0.5840 ,-0.5032 ])\ntensor([[ 42.,42.,42.,42.,42.,42.,42.,42.]])\nCustomInitialization\nSometimes,theinitializationmethodsweneedarenotprovidedbythedeeplearningframe-\nwork. In the example below, we define an initializer for any weight parameter \ud835\udc64using the\nfollowing strange distribution:\n\ud835\udc64\u00188>>> <\n>>>:\ud835\udc48\u00b95,10\u00bawith probability1\n4\n0 with probability1\n2\n\ud835\udc48\u00b9\u000010,\u00005\u00bawith probability1\n4(6.3.1)\nAgain, we implement a my_init function to apply to net.\ndef my_init (module):\niftype (module) ==nn.Linear:\nprint (\"Init \",*[(name, param .shape)\nfor name, param inmodule .named_parameters()][ 0])\nnn.init .uniform_(module .weight, -10,10)\nmodule .weight .data *=module .weight .data .abs() >=5\nnet.apply(my_init)\nnet[ 0].weight[: 2]\nInit weight torch .Size([ 8,4])\nInit weight torch .Size([ 1,8])\ntensor([[ 0.0000 ,-7.6364 ,-0.0000 ,-6.1206 ],\n[9.3516 ,-0.0000 ,5.1208 ,-8.4003 ]], grad_fn =<SliceBackward0 >)\nNote that we always have the option of setting parameters directly.\n219 Lazy Initialization\n113net[ 0].weight .data[:] +=1\nnet[ 0].weight .data[ 0,0]=42\nnet[ 0].weight .data[ 0]\ntensor([ 42.0000 ,-6.6364 ,1.0000 ,-5.1206 ])\n6.3.2Summary\nWe can initialize parameters using built-in and custom initializers.\n6.3.3Exercises\nLook up the online documentation for more built-in initializers.\nDiscussions113.\n6.4Lazy Initialization\nSofar,itmightseemthatwegotawaywithbeingsloppyinsettingupournetworks. Specif-\nically, we did the following unintuitive things, which might not seem like they should\nwork:\n\u000fWe defined the network architectures without specifying the input dimensionality.\n\u000fWe added layers without specifying the output dimension of the previous layer.\n\u000fWe even \u201cinitialized\u201d these parameters before providing enough information to deter-\nmine how many parameters our models should contain.\nYoumightbesurprisedthatourcoderunsatall. Afterall,thereisnowaythedeeplearning\nframework could tell what the input dimensionality of a network would be. The trick here\nis that the framework defersinitialization , waiting until the first time we pass data through\nthe model, to infer the sizes of each layer on the fly.\nLater on, when working with convolutional neural networks, this technique will become\neven more convenient since the input dimensionality (e.g., the resolution of an image) will\naffect the dimensionality of each subsequent layer. Hence the ability to set parameters\nwithout the need to know, at the time of writing the code, the value of the dimension can\ngreatly simplify the task of specifying and subsequently modifying our models. Next, we\ngo deeper into the mechanics of initialization.\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n220 Builders\u2019 Guide\nTo begin, let\u2019s instantiate an MLP.", "mimetype": "text/plain", "start_char_idx": 550807, "end_char_idx": 554377, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "382ef4a6-f79f-435d-ae5a-c80858947111": {"__data__": {"id_": "382ef4a6-f79f-435d-ae5a-c80858947111", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1ecb85cf-23fb-4794-8b19-b0090b1fd607", "node_type": "1", "metadata": {}, "hash": "5c8c695f1dd9e67344685ec8477cb8231de58f300cbe5d72dbf171107e0c9f53", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "44ac21c8-1e03-4669-bdf7-816b0b3393cf", "node_type": "1", "metadata": {}, "hash": "3078bf73fe126c81ac8e22b37b6203a0a7be2f39052341475b62117e40a74956", "class_name": "RelatedNodeInfo"}}, "text": "Afterall,thereisnowaythedeeplearning\nframework could tell what the input dimensionality of a network would be. The trick here\nis that the framework defersinitialization , waiting until the first time we pass data through\nthe model, to infer the sizes of each layer on the fly.\nLater on, when working with convolutional neural networks, this technique will become\neven more convenient since the input dimensionality (e.g., the resolution of an image) will\naffect the dimensionality of each subsequent layer. Hence the ability to set parameters\nwithout the need to know, at the time of writing the code, the value of the dimension can\ngreatly simplify the task of specifying and subsequently modifying our models. Next, we\ngo deeper into the mechanics of initialization.\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n220 Builders\u2019 Guide\nTo begin, let\u2019s instantiate an MLP.\nnet =nn.Sequential(nn .LazyLinear( 256), nn .ReLU(), nn .LazyLinear( 10))\nAtthispoint,thenetworkcannotpossiblyknowthedimensionsoftheinputlayer\u2019sweights\nbecause the input dimension remains unknown.\nConsequently the framework has not yet initialized any parameters. We confirm by at-\ntempting to access the parameters below.\nnet[ 0].weight\n<UninitializedParameter >\nNext let\u2019s pass data through the network to make the framework finally initialize parame-\nters.\nX=torch .rand( 2,20)\nnet(X)\nnet[ 0].weight .shape\ntorch .Size([ 256,20])\nAs soon as we know the input dimensionality, 20, the framework can identify the shape of\nthe first layer\u2019s weight matrix by plugging in the value of 20. Having recognized the first\nlayer\u2019s shape, the framework proceeds to the second layer, and so on through the computa-\ntional graph until all shapes are known. Note that in this case, only the first layer requires\nlazy initialization, but the framework initializes sequentially. Once all parameter shapes\nare known, the framework can finally initialize the parameters.\nThe following method passes in dummy inputs through the network for a dry run to infer\nallparametershapesandsubsequentlyinitializestheparameters. Itwillbeusedlaterwhen\ndefault random initializations are not desired.\n@d2l .add_to_class(d2l .Module) #@save\ndef apply_init (self , inputs, init =None ):\nself .forward( *inputs)\nifinit isnot None :\nself .net.apply(init)\n6.4.1Summary\nLazy initialization can be convenient, allowing the framework to infer parameter shapes\nautomatically, making it easy to modify architectures and eliminating one common source\nof errors. We can pass data through the model to make the framework finally initialize\nparameters.\n221 Custom Layers\n1146.4.2Exercises\n1.Whathappensifyouspecifytheinputdimensionstothefirstlayerbutnottosubsequent\nlayers? Do you get immediate initialization?\n2.What happens if you specify mismatching dimensions?\n3.What would you need to do if you have input of varying dimensionality? Hint: look at\nthe parameter tying.\nDiscussions114.\n6.5Custom Layers\nOne factor behind deep learning\u2019s success is the availability of a wide range of layers that\ncan be composed in creative ways to design architectures suitable for a wide variety of\ntasks. For instance, researchers have invented layers specifically for handling images, text,\nlooping over sequential data, and performing dynamic programming. Sooner or later, you\nwill need a layer that does not exist yet in the deep learning framework. In these cases, you\nmust build a custom layer. In this section, we show you how.\nimport torch\nfrom torch import nn\nfrom torch .nnimport functional asF\nfrom d2l import torch asd2l\n6.5.1Layerswithout Parameters\nTo start, we construct a custom layer that does not have any parameters of its own. This\nshouldlookfamiliarifyourecallourintroductiontomodulesin Section6.1 . Thefollowing\nCenteredLayer classsimplysubtractsthemeanfromitsinput. Tobuildit,wesimplyneed\ntoinheritfromthebaselayerclassandimplementtheforwardpropagationfunction.\nclass CenteredLayer (nn.Module):\ndef __init__ (self ):\nsuper ().__init__ ()\ndef forward (self , X):\nreturn X-X.mean()\nLet\u2019s verify that our layer works as intended by feeding some data through it.\nlayer =CenteredLayer()\nlayer(torch .tensor([ 1.0,2,3,4,5]))\n222 Builders\u2019 Guide\ntensor([ -2.,-1.,0.,1.,2.])", "mimetype": "text/plain", "start_char_idx": 553491, "end_char_idx": 557710, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "44ac21c8-1e03-4669-bdf7-816b0b3393cf": {"__data__": {"id_": "44ac21c8-1e03-4669-bdf7-816b0b3393cf", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "382ef4a6-f79f-435d-ae5a-c80858947111", "node_type": "1", "metadata": {}, "hash": "24a3b78de680252131732cffbfdb1692272dc97806493f2c645af8ab4fda426d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d96ce7ce-d17d-4866-bcf8-431b7b6a6cc1", "node_type": "1", "metadata": {}, "hash": "a3912bf72a500c6634cb5b3cc90000b8e23e22389df00f8ae08b5b7da3cb38df", "class_name": "RelatedNodeInfo"}}, "text": "This\nshouldlookfamiliarifyourecallourintroductiontomodulesin Section6.1 . Thefollowing\nCenteredLayer classsimplysubtractsthemeanfromitsinput. Tobuildit,wesimplyneed\ntoinheritfromthebaselayerclassandimplementtheforwardpropagationfunction.\nclass CenteredLayer (nn.Module):\ndef __init__ (self ):\nsuper ().__init__ ()\ndef forward (self , X):\nreturn X-X.mean()\nLet\u2019s verify that our layer works as intended by feeding some data through it.\nlayer =CenteredLayer()\nlayer(torch .tensor([ 1.0,2,3,4,5]))\n222 Builders\u2019 Guide\ntensor([ -2.,-1.,0.,1.,2.])\nWe can now incorporate our layer as a component in constructing more complex mod-\nels.\nnet =nn.Sequential(nn .LazyLinear( 128), CenteredLayer())\nAs an extra sanity check, we can send random data through the network and check that the\nmean is in fact 0. Because we are dealing with floating point numbers, we may still see a\nvery small nonzero number due to quantization.\nY=net(torch .rand( 4,8))\nY.mean()\ntensor( -6.5193e-09 , grad_fn =<MeanBackward0 >)\n6.5.2Layerswith Parameters\nNow that we know how to define simple layers, let\u2019s move on to defining layers with pa-\nrameters that can be adjusted through training. We can use built-in functions to create\nparameters, which provide some basic housekeeping functionality. In particular, they gov-\nern access, initialization, sharing, saving, and loading model parameters. This way, among\nother benefits, we will not need to write custom serialization routines for every custom\nlayer.\nNow let\u2019s implement our own version of the fully connected layer. Recall that this layer\nrequires two parameters, one to represent the weight and the other for the bias. In this im-\nplementation, we bake in the ReLU activation as a default. This layer requires two input\narguments: in_units andunits, which denote the number of inputs and outputs, respec-\ntively.\nclass MyLinear (nn.Module):\ndef __init__ (self , in_units, units):\nsuper ().__init__ ()\nself .weight =nn.Parameter(torch .randn(in_units, units))\nself .bias =nn.Parameter(torch .randn(units,))\ndef forward (self , X):\nlinear =torch .matmul(X, self .weight .data) +self .bias .data\nreturn F.relu(linear)\nNext, we instantiate the MyLinear class and access its model parameters.\nlinear =MyLinear( 5,3)\nlinear .weight\n223 File I/O\n115Parameter containing:\ntensor([[ 0.4783 ,0.4284 ,-0.0899 ],\n[-0.6347 ,0.2913 ,-0.0822 ],\n[-0.4325 ,-0.1645 ,-0.3274 ],\n[1.1898 ,0.6482 ,-1.2384 ],\n[-0.1479 ,0.0264 ,-0.9597 ]], requires_grad =True )\nWe can directly carry out forward propagation calculations using custom layers.\nlinear(torch .rand( 2,5))\ntensor([[ 0.0000 ,0.9316 ,0.0000 ],\n[0.1808 ,1.4208 ,0.0000 ]])\nWe can also construct models using custom layers. Once we have that we can use it just\nlike the built-in fully connected layer.\nnet =nn.Sequential(MyLinear( 64,8), MyLinear( 8,1))\nnet(torch .rand( 2,64))\ntensor([[ 0.0000 ],\n[13.0800 ]])\n6.5.3Summary\nWe can design custom layers via the basic layer class. This allows us to define flexible\nnew layers that behave differently from any existing layers in the library. Once defined,\ncustom layers can be invoked in arbitrary contexts and architectures. Layers can have local\nparameters, which can be created through built-in functions.\n6.5.4Exercises\n1.Design a layer that takes an input and computes a tensor reduction, i.e., it returns \ud835\udc66\ud835\udc58=\u00cd\n\ud835\udc56,\ud835\udc57\ud835\udc4a\ud835\udc56\ud835\udc57\ud835\udc58\ud835\udc65\ud835\udc56\ud835\udc65\ud835\udc57.\n2.Design a layer that returns the leading half of the Fourier coefficients of the data.\nDiscussions115.\n6.6File I/O\nSo far we have discussed how to process data and how to build, train, and test deep learn-\ning models.", "mimetype": "text/plain", "start_char_idx": 557168, "end_char_idx": 560726, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d96ce7ce-d17d-4866-bcf8-431b7b6a6cc1": {"__data__": {"id_": "d96ce7ce-d17d-4866-bcf8-431b7b6a6cc1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "44ac21c8-1e03-4669-bdf7-816b0b3393cf", "node_type": "1", "metadata": {}, "hash": "3078bf73fe126c81ac8e22b37b6203a0a7be2f39052341475b62117e40a74956", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b4f1a3e9-3c70-42af-b6a3-088863b927d1", "node_type": "1", "metadata": {}, "hash": "ed873ad1fe95ccf64be4e6f199cb2e3a130971d4112a32a3765d4ee9da700be9", "class_name": "RelatedNodeInfo"}}, "text": "This allows us to define flexible\nnew layers that behave differently from any existing layers in the library. Once defined,\ncustom layers can be invoked in arbitrary contexts and architectures. Layers can have local\nparameters, which can be created through built-in functions.\n6.5.4Exercises\n1.Design a layer that takes an input and computes a tensor reduction, i.e., it returns \ud835\udc66\ud835\udc58=\u00cd\n\ud835\udc56,\ud835\udc57\ud835\udc4a\ud835\udc56\ud835\udc57\ud835\udc58\ud835\udc65\ud835\udc56\ud835\udc65\ud835\udc57.\n2.Design a layer that returns the leading half of the Fourier coefficients of the data.\nDiscussions115.\n6.6File I/O\nSo far we have discussed how to process data and how to build, train, and test deep learn-\ning models. However, at some point we will hopefully be happy enough with the learned\n224 Builders\u2019 Guide\nmodels that we will want to save the results for later use in various contexts (perhaps even\nto make predictions in deployment). Additionally, when running a long training process,\nthe best practice is to periodically save intermediate results (checkpointing) to ensure that\nwe do not lose several days\u2019 worth of computation if we trip over the power cord of our\nserver. Thus it is time to learn how to load and store both individual weight vectors and\nentire models. This section addresses both issues.\nimport torch\nfrom torch import nn\nfrom torch .nnimport functional asF\n6.6.1Loading and SavingTensors\nFor individual tensors, we can directly invoke the loadandsavefunctions to read and\nwrite them respectively. Both functions require that we supply a name, and saverequires\nas input the variable to be saved.\nx=torch .arange( 4)\ntorch .save(x, 'x-file ')\nWe can now read the data from the stored file back into memory.\nx2=torch .load( 'x-file ')\nx2\ntensor([ 0,1,2,3])\nWe can store a list of tensors and read them back into memory.\ny=torch .zeros( 4)\ntorch .save([x, y], 'x-files ')\nx2, y2 =torch .load( 'x-files ')\n(x2, y2)\n(tensor([ 0,1,2,3]), tensor([ 0.,0.,0.,0.]))\nWe can even write and read a dictionary that maps from strings to tensors. This is conve-\nnient when we want to read or write all the weights in a model.\nmydict ={'x': x, 'y': y}\ntorch .save(mydict, 'mydict ')\nmydict2 =torch .load( 'mydict ')\nmydict2\n225 File I/O\n{'x': tensor([ 0,1,2,3]), 'y': tensor([ 0.,0.,0.,0.])}\n6.6.2Loading and SavingModel Parameters\nSaving individual weight vectors (or other tensors) is useful, but it gets very tedious if we\nwant to save (and later load) an entire model. After all, we might have hundreds of param-\neter groups sprinkled throughout. For this reason the deep learning framework provides\nbuilt-in functionalities to load and save entire networks. An important detail to note is that\nthis saves model parameters and not the entire model. For example, if we have a 3-layer\nMLP, we need to specify the architecture separately. The reason for this is that the models\nthemselves can contain arbitrary code, hence they cannot be serialized as naturally. Thus,\nin order to reinstate a model, we need to generate the architecture in code and then load the\nparameters from disk. Let\u2019s start with our familiar MLP.\nclass MLP(nn.Module):\ndef __init__ (self ):\nsuper ().__init__ ()\nself .hidden =nn.LazyLinear( 256)\nself .output =nn.LazyLinear( 10)\ndef forward (self , x):\nreturn self .output(F .relu( self .hidden(x)))\nnet =MLP()\nX=torch .randn(size =(2,20))\nY=net(X)\nNext, we store the parameters of the model as a file with the name \u201cmlp.params\u201d.\ntorch .save(net .state_dict(), 'mlp.params ')\nTo recover the model, we instantiate a clone of the original MLP model. Instead of ran-\ndomlyinitializingthemodelparameters,wereadtheparametersstoredinthefiledirectly.", "mimetype": "text/plain", "start_char_idx": 560111, "end_char_idx": 563687, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b4f1a3e9-3c70-42af-b6a3-088863b927d1": {"__data__": {"id_": "b4f1a3e9-3c70-42af-b6a3-088863b927d1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d96ce7ce-d17d-4866-bcf8-431b7b6a6cc1", "node_type": "1", "metadata": {}, "hash": "a3912bf72a500c6634cb5b3cc90000b8e23e22389df00f8ae08b5b7da3cb38df", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d4ad6ff8-e157-430a-b5fe-41ab311c782c", "node_type": "1", "metadata": {}, "hash": "4551c9ad2ca27adec7781ad33a331d2243432f4f61731a74c3bd4212eba9ca7e", "class_name": "RelatedNodeInfo"}}, "text": "Thus,\nin order to reinstate a model, we need to generate the architecture in code and then load the\nparameters from disk. Let\u2019s start with our familiar MLP.\nclass MLP(nn.Module):\ndef __init__ (self ):\nsuper ().__init__ ()\nself .hidden =nn.LazyLinear( 256)\nself .output =nn.LazyLinear( 10)\ndef forward (self , x):\nreturn self .output(F .relu( self .hidden(x)))\nnet =MLP()\nX=torch .randn(size =(2,20))\nY=net(X)\nNext, we store the parameters of the model as a file with the name \u201cmlp.params\u201d.\ntorch .save(net .state_dict(), 'mlp.params ')\nTo recover the model, we instantiate a clone of the original MLP model. Instead of ran-\ndomlyinitializingthemodelparameters,wereadtheparametersstoredinthefiledirectly.\nclone =MLP()\nclone .load_state_dict(torch .load( 'mlp.params '))\nclone .eval()\nMLP(\n(hidden): LazyLinear(in_features =0, out_features =256, bias =True )\n(output): LazyLinear(in_features =0, out_features =10, bias =True )\n)\nSincebothinstanceshavethesamemodelparameters,thecomputationalresultofthesame\ninput Xshould be the same. Let\u2019s verify this.\n226 Builders\u2019 Guide\n116\n117Y_clone =clone(X)\nY_clone ==Y\ntensor([[ True ,True ,True ,True ,True ,True ,True ,True ,True ,True ],\n[True ,True ,True ,True ,True ,True ,True ,True ,True ,True ]])\n6.6.3Summary\nThesaveandloadfunctions can be used to perform file I/O for tensor objects. We can\nsaveandloadtheentiresetsofparametersforanetworkviaaparameterdictionary. Saving\nthe architecture has to be done in code rather than in parameters.\n6.6.4Exercises\n1.Even if there is no need to deploy trained models to a different device, what are the\npractical benefits of storing model parameters?\n2.Assume that we want to reuse only parts of a network to be incorporated into a network\nhaving a different architecture. How would you go about using, say the first two layers\nfrom a previous network in a new network?\n3.Howwouldyougoaboutsavingthenetworkarchitectureandparameters? Whatrestric-\ntions would you impose on the architecture?\nDiscussions116.\n6.7GPUs\nIntab_intro_decade , we illustrated the rapid growth of computation over the past two\ndecades. In a nutshell, GPU performance has increased by a factor of 1000 every decade\nsince 2000. This offers great opportunities but it also suggests that there was significant\ndemand for such performance.\nInthissection,webegintodiscusshowtoharnessthiscomputationalperformanceforyour\nresearch. First by using a single GPU and at a later point, how to use multiple GPUs and\nmultiple servers (with multiple GPUs).\nSpecifically, we will discuss how to use a single NVIDIA GPU for calculations. First,\nmake sure you have at least one NVIDIA GPU installed. Then, download the NVIDIA\ndriverandCUDA117andfollowthepromptstosettheappropriatepath. Oncetheseprepa-\nrations are complete, the nvidia-smi command can be used to view the graphics card\ninformation.\nIn PyTorch, every array has a device; we often refer it as a context. So far, by default, all\n227 GPUs\nvariables and associated computation have been assigned to the CPU. Typically, other con-\ntextsmightbevariousGPUs. Thingscangetevenhairierwhenwedeployjobsacrossmul-\ntiple servers. By assigning arrays to contexts intelligently, we can minimize the time spent\ntransferring data between devices. For example, when training neural networks on a server\nwith a GPU, we typically prefer for the model\u2019s parameters to live on the GPU.\nTo run the programs in this section, you need at least two GPUs. Note that this might\nbe extravagant for most desktop computers but it is easily available in the cloud, e.g., by\nusingtheAWSEC2multi-GPUinstances. Almostallothersectionsdo notrequiremultiple\nGPUs, but here we simply wish to illustrate data flow between different devices.\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n6.7.1ComputingDevices\nWe can specify devices, such as CPUs and GPUs, for storage and calculation. By default,\ntensors are created in the main memory and then the CPU is used for calculations.", "mimetype": "text/plain", "start_char_idx": 562984, "end_char_idx": 566941, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d4ad6ff8-e157-430a-b5fe-41ab311c782c": {"__data__": {"id_": "d4ad6ff8-e157-430a-b5fe-41ab311c782c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b4f1a3e9-3c70-42af-b6a3-088863b927d1", "node_type": "1", "metadata": {}, "hash": "ed873ad1fe95ccf64be4e6f199cb2e3a130971d4112a32a3765d4ee9da700be9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6647ce3b-1e0d-4fbb-ad02-ff9d14ea1e11", "node_type": "1", "metadata": {}, "hash": "a6755888c88a847c2edfaf99e3415c3d0a79981b4443893efea7ce191d9ff8da", "class_name": "RelatedNodeInfo"}}, "text": "By assigning arrays to contexts intelligently, we can minimize the time spent\ntransferring data between devices. For example, when training neural networks on a server\nwith a GPU, we typically prefer for the model\u2019s parameters to live on the GPU.\nTo run the programs in this section, you need at least two GPUs. Note that this might\nbe extravagant for most desktop computers but it is easily available in the cloud, e.g., by\nusingtheAWSEC2multi-GPUinstances. Almostallothersectionsdo notrequiremultiple\nGPUs, but here we simply wish to illustrate data flow between different devices.\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n6.7.1ComputingDevices\nWe can specify devices, such as CPUs and GPUs, for storage and calculation. By default,\ntensors are created in the main memory and then the CPU is used for calculations.\nIn PyTorch, the CPU and GPU can be indicated by torch.device('cpu') andtorch.\ndevice('cuda') . It should be noted that the cpudevice means all physical CPUs and\nmemory. This means that PyTorch\u2019s calculations will try to use all CPU cores. However, a\ngpudevice only represents one card and the corresponding memory. If there are multiple\nGPUs, we use torch.device(f'cuda:{i}') to represent the \ud835\udc56thGPU (\ud835\udc56starts at 0). Also,\ngpu:0andgpuare equivalent.\ndef cpu(): #@save\n\"\"\"Get the CPU device.\"\"\"\nreturn torch .device( 'cpu')\ndef gpu(i=0): #@save\n\"\"\"Get a GPU device.\"\"\"\nreturn torch .device( f'cuda: {i}')\ncpu(), gpu(), gpu( 1)\n(device( type ='cpu'),\ndevice( type ='cuda ', index =0),\ndevice( type ='cuda ', index =1))\nWe can query the number of available GPUs.\ndef num_gpus (): #@save\n\"\"\"Get the number of available GPUs.\"\"\"\nreturn torch .cuda .device_count()\nnum_gpus()\n228 Builders\u2019 Guide\n2\nNow we define two convenient functions that allow us to run code even if the requested\nGPUs do not exist.\ndef try_gpu (i=0): #@save\n\"\"\"Return gpu(i) if exists, otherwise return cpu().\"\"\"\nifnum_gpus() >=i+1:\nreturn gpu(i)\nreturn cpu()\ndef try_all_gpus (): #@save\n\"\"\"Return all available GPUs, or [cpu(),] if no GPU exists.\"\"\"\nreturn [gpu(i) for iinrange (num_gpus())]\ntry_gpu(), try_gpu( 10), try_all_gpus()\n(device( type ='cuda ', index =0),\ndevice( type ='cpu'),\n[device( type ='cuda ', index =0), device( type ='cuda ', index =1)])\n6.7.2Tensorsand GPUs\nBy default, tensors are created on the CPU. We can query the device where the tensor is\nlocated.\nx=torch .tensor([ 1,2,3])\nx.device\ndevice( type ='cpu')\nIt is important to note that whenever we want to operate on multiple terms, they need to be\non the same device. For instance, if we sum two tensors, we need to make sure that both\narguments live on the same device\u2014otherwise the framework would not know where to\nstore the result or even how to decide where to perform the computation.\nStorageon the GPU\nThere are several ways to store a tensor on the GPU. For example, we can specify a stor-\nage device when creating a tensor. Next, we create the tensor variable Xon the first gpu.\nThe tensor created on a GPU only consumes the memory of this GPU. We can use the\nnvidia-smi command to view GPU memory usage. In general, we need to make sure that\nwe do not create data that exceeds the GPU memory limit.\nX=torch .ones( 2,3, device =try_gpu())\nX\n229 GPUs\ntensor([[ 1.,1.,1.],\n[1.,1.,1.]], device ='cuda:0 ')\nAssuming that you have at least two GPUs, the following code will create a random tensor,\nY, on the second GPU.\nY=torch .rand( 2,3, device =try_gpu( 1))\nY\ntensor([[ 0.0022 ,0.5723 ,0.2890 ],\n[0.1456 ,0.3537 ,0.7359 ]], device ='cuda:1 ')\nCopying\nIf we want to compute X + Y, we need to decide where to perform this operation. For\ninstance, as shown in Fig. 6.7.1 , we can transfer Xto the second GPU and perform the\noperation there.", "mimetype": "text/plain", "start_char_idx": 566104, "end_char_idx": 569829, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6647ce3b-1e0d-4fbb-ad02-ff9d14ea1e11": {"__data__": {"id_": "6647ce3b-1e0d-4fbb-ad02-ff9d14ea1e11", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d4ad6ff8-e157-430a-b5fe-41ab311c782c", "node_type": "1", "metadata": {}, "hash": "4551c9ad2ca27adec7781ad33a331d2243432f4f61731a74c3bd4212eba9ca7e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b9a48fc4-e5aa-4a64-a594-c14003264340", "node_type": "1", "metadata": {}, "hash": "86357e7bc09c3eaf4b9e4fd3233914bd3692f1594db1d7d12d49fa5c96744a1c", "class_name": "RelatedNodeInfo"}}, "text": "X=torch .ones( 2,3, device =try_gpu())\nX\n229 GPUs\ntensor([[ 1.,1.,1.],\n[1.,1.,1.]], device ='cuda:0 ')\nAssuming that you have at least two GPUs, the following code will create a random tensor,\nY, on the second GPU.\nY=torch .rand( 2,3, device =try_gpu( 1))\nY\ntensor([[ 0.0022 ,0.5723 ,0.2890 ],\n[0.1456 ,0.3537 ,0.7359 ]], device ='cuda:1 ')\nCopying\nIf we want to compute X + Y, we need to decide where to perform this operation. For\ninstance, as shown in Fig. 6.7.1 , we can transfer Xto the second GPU and perform the\noperation there. Do notsimply add XandY, since this will result in an exception. The\nruntime engine would not know what to do: it cannot find data on the same device and it\nfails. Since Ylives on the second GPU, we need to move Xthere before we can add the\ntwo.\ntFig. 6.7.1 Copy data to perform an operation on the same device.\nZ=X.cuda( 1)\nprint (X)\nprint (Z)\ntensor([[ 1.,1.,1.],\n[1.,1.,1.]], device ='cuda:0 ')\ntensor([[ 1.,1.,1.],\n[1.,1.,1.]], device ='cuda:1 ')\nNow that the data (both ZandY) are on the same GPU), we can add them up.\nY+Z\ntensor([[ 1.0022 ,1.5723 ,1.2890 ],\n[1.1456 ,1.3537 ,1.7359 ]], device ='cuda:1 ')\n230 Builders\u2019 Guide\nButwhatifyourvariable ZalreadylivedonyoursecondGPU?Whathappensifwestillcall\nZ.cuda(1) ? It will return Zinstead of making a copy and allocating new memory.\nZ.cuda( 1)isZ\nTrue\nSide Notes\nPeople use GPUs to do machine learning because they expect them to be fast. But trans-\nferring variables between devices is slow: much slower than computation. So we want you\nto be 100% certain that you want to do something slow before we let you do it. If the deep\nlearning framework just did the copy automatically without crashing then you might not\nrealize that you had written some slow code.\nTransferring data is not only slow, it also makes parallelization a lot more difficult, since\nwe have to wait for data to be sent (or rather to be received) before we can proceed with\nmore operations. This is why copy operations should be taken with great care. As a rule of\nthumb, many small operations are much worse than one big operation. Moreover, several\noperations at a time are much better than many single operations interspersed in the code\nunless you know what you are doing. This is the case since such operations can block if\none device has to wait for the other before it can do something else. It is a bit like ordering\nyour coffee in a queue rather than pre-ordering it by phone and finding out that it is ready\nwhen you are.\nLast, whenweprinttensorsorconverttensorstotheNumPyformat, ifthedataisnotinthe\nmain memory, the framework will copy it to the main memory first, resulting in additional\ntransmission overhead. Even worse, it is now subject to the dreaded global interpreter lock\nthat makes everything wait for Python to complete.\n6.7.3NeuralNetworksand GPUs\nSimilarly, a neural network model can specify devices. The following code puts the model\nparameters on the GPU.\nnet =nn.Sequential(nn .LazyLinear( 1))\nnet =net.to(device =try_gpu())\nWewillseemanymoreexamplesofhowtorunmodelsonGPUsinthefollowingchapters,\nsimplybecausethemodelswillbecomesomewhatmorecomputationallyintensive.\nFor example, when the input is a tensor on the GPU, the model will calculate the result on\nthe same GPU.\nnet(X)\n231 GPUs\ntensor([[ 0.7802 ],\n[0.7802 ]], device ='cuda:0 ', grad_fn =<AddmmBackward0 >)\nLet\u2019s confirm that the model parameters are stored on the same GPU.\nnet[ 0].weight .data .device\ndevice( type ='cuda ', index =0)\nLet the trainer support GPU.", "mimetype": "text/plain", "start_char_idx": 569294, "end_char_idx": 572806, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b9a48fc4-e5aa-4a64-a594-c14003264340": {"__data__": {"id_": "b9a48fc4-e5aa-4a64-a594-c14003264340", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6647ce3b-1e0d-4fbb-ad02-ff9d14ea1e11", "node_type": "1", "metadata": {}, "hash": "a6755888c88a847c2edfaf99e3415c3d0a79981b4443893efea7ce191d9ff8da", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "04d7a591-36bb-4f6d-b509-044ce1cdc3d2", "node_type": "1", "metadata": {}, "hash": "3ff30c3d1659fc2aff5ead6dac67c741023194ec3530bab0da0121b8e25b7b89", "class_name": "RelatedNodeInfo"}}, "text": "The following code puts the model\nparameters on the GPU.\nnet =nn.Sequential(nn .LazyLinear( 1))\nnet =net.to(device =try_gpu())\nWewillseemanymoreexamplesofhowtorunmodelsonGPUsinthefollowingchapters,\nsimplybecausethemodelswillbecomesomewhatmorecomputationallyintensive.\nFor example, when the input is a tensor on the GPU, the model will calculate the result on\nthe same GPU.\nnet(X)\n231 GPUs\ntensor([[ 0.7802 ],\n[0.7802 ]], device ='cuda:0 ', grad_fn =<AddmmBackward0 >)\nLet\u2019s confirm that the model parameters are stored on the same GPU.\nnet[ 0].weight .data .device\ndevice( type ='cuda ', index =0)\nLet the trainer support GPU.\n@d2l .add_to_class(d2l .Trainer) #@save\ndef __init__ (self , max_epochs, num_gpus =0, gradient_clip_val =0):\nself .save_hyperparameters()\nself .gpus =[d2l .gpu(i) for iinrange (min(num_gpus, d2l .num_gpus()))]\n@d2l .add_to_class(d2l .Trainer) #@save\ndef prepare_batch (self , batch):\nifself .gpus:\nbatch =[a.to(self .gpus[ 0])for ainbatch]\nreturn batch\n@d2l .add_to_class(d2l .Trainer) #@save\ndef prepare_model (self , model):\nmodel .trainer =self\nmodel .board .xlim =[0,self .max_epochs]\nifself .gpus:\nmodel .to(self .gpus[ 0])\nself .model =model\nIn short, as long as all data and parameters are on the same device, we can learn models\nefficiently. In the following chapters we will see several such examples.\n6.7.4Summary\nWe can specify devices for storage and calculation, such as the CPU or GPU. By default,\ndata is created in the main memory and then uses the CPU for calculations. The deep\nlearning framework requires all input data for calculation to be on the same device, be it\nCPU or the same GPU. You can lose significant performance by moving data without care.\nA typical mistake is as follows: computing the loss for every minibatch on the GPU and\nreporting it back to the user on the command line (or logging it in a NumPy ndarray ) will\ntriggeraglobalinterpreterlockwhichstallsallGPUs. Itismuchbettertoallocatememory\nfor logging inside the GPU and only move larger logs.\n6.7.5Exercises\n1.Try a larger computation task, such as the multiplication of large matrices, and see the\ndifference in speed between the CPU and GPU. What about a task with a small number\nof calculations?\n232 Builders\u2019 Guide\n1182.How should we read and write model parameters on the GPU?\n3.Measure the time it takes to compute 1000 matrix\u2013matrix multiplications of 100\u0002100\nmatricesandlogtheFrobeniusnormoftheoutputmatrixoneresultatatime. Compare\nit with keeping a log on the GPU and transferring only the final result.\n4.Measure how much time it takes to perform two matrix\u2013matrix multiplications on two\nGPUs at the same time. Compare it with computing in in sequence on one GPU. Hint:\nyou should see almost linear scaling.\nDiscussions118.\n7 Convolutional Neural Networks\nImage data is represented as a two-dimensional grid of pixels, be the image monochro-\nmatic or in color. Accordingly each pixel corresponds to one or multiple numerical values\nrespectively. So far we have ignored this rich structure and treated images as vectors of\nnumbersby flattening them, irrespectiveofthe spatial relation betweenpixels. This deeply\nunsatisfyingapproachwasnecessaryinordertofeedtheresultingone-dimensionalvectors\nthrough a fully connected MLP.\nBecause these networks are invariant to the order of the features, we could get similar\nresults regardless of whether we preserve an order corresponding to the spatial structure\nof the pixels or if we permute the columns of our design matrix before fitting the MLP\u2019s\nparameters. Ideally,wewouldleverageourpriorknowledgethatnearbypixelsaretypically\nrelated to each other, to build efficient models for learning from image data.\nThis chapter introduces convolutional neural networks (CNNs) ( LeCunet al., 1995), a\npowerful family of neural networks that are designed for precisely this purpose. CNN-\nbased architectures are now ubiquitous in the field of computer vision.", "mimetype": "text/plain", "start_char_idx": 572180, "end_char_idx": 576101, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "04d7a591-36bb-4f6d-b509-044ce1cdc3d2": {"__data__": {"id_": "04d7a591-36bb-4f6d-b509-044ce1cdc3d2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b9a48fc4-e5aa-4a64-a594-c14003264340", "node_type": "1", "metadata": {}, "hash": "86357e7bc09c3eaf4b9e4fd3233914bd3692f1594db1d7d12d49fa5c96744a1c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fc776d3e-ecea-4d0c-a3d3-a96ee8dd6a19", "node_type": "1", "metadata": {}, "hash": "09436890d3a443b2f8baeef1fce0d56228a3660e81b4fd264374d60177a04eaa", "class_name": "RelatedNodeInfo"}}, "text": "This deeply\nunsatisfyingapproachwasnecessaryinordertofeedtheresultingone-dimensionalvectors\nthrough a fully connected MLP.\nBecause these networks are invariant to the order of the features, we could get similar\nresults regardless of whether we preserve an order corresponding to the spatial structure\nof the pixels or if we permute the columns of our design matrix before fitting the MLP\u2019s\nparameters. Ideally,wewouldleverageourpriorknowledgethatnearbypixelsaretypically\nrelated to each other, to build efficient models for learning from image data.\nThis chapter introduces convolutional neural networks (CNNs) ( LeCunet al., 1995), a\npowerful family of neural networks that are designed for precisely this purpose. CNN-\nbased architectures are now ubiquitous in the field of computer vision. For instance, on the\nImagnetcollection( Dengetal.,2009)itwasonlytheuseofconvolutionalneuralnetworks,\nin short Convnets, that provided significant performance improvements ( Krizhevsky etal.,\n2012).\nModern CNNs, as they are called colloquially, owe their design to inspirations from biol-\nogy,grouptheory,andahealthydoseofexperimentaltinkering. Inadditiontotheirsample\nefficiency in achieving accurate models, CNNs tend to be computationally efficient, both\nbecause they require fewer parameters than fully connected architectures and because con-\nvolutions are easy to parallelize across GPU cores ( Chetluret al., 2014). Consequently,\npractitioners often apply CNNs whenever possible, and increasingly they have emerged\nas credible competitors even on tasks with a one-dimensional sequence structure, such as\naudio (Abdel-Hamid et al., 2014), text (Kalchbrenner et al., 2014), and time series analy-\nsis (LeCunet al., 1995), where recurrent neural networks are conventionally used. Some\nclever adaptations of CNNs have also brought them to bear on graph-structured data ( Kipf\nand Welling, 2016 ) and in recommender systems.\nFirst, wewilldivemoredeeplyintothemotivationforconvolutionalneuralnetworks. This\nis followed by a walk through the basic operations that comprise the backbone of all con-\nvolutional networks. These include the convolutional layersthemselves, nitty-gritty details\nincluding padding and stride, the pooling layers used to aggregate information across ad-\njacent spatial regions, the use of multiple channels at each layer, and a careful discussion\n233\n234 Convolutional Neural Networks\nof the structure of modern architectures. We will conclude the chapter with a full working\nexample of LeNet, the first convolutional network successfully deployed, long before the\nriseofmoderndeeplearning. Inthenextchapter, wewilldiveintofullimplementationsof\nsome popular and comparatively recent CNN architectures whose designs represent most\nof the techniques commonly used by modern practitioners.\n7.1FromFullyConnected Layersto Convolutions\nTo this day, the models that we have discussed so far remain appropriate options when we\nare dealing with tabular data. By tabular, we mean that the data consist of rows corre-\nsponding to examples and columns corresponding to features. With tabular data, we might\nanticipate that the patterns we seek could involve interactions among the features, but we\ndo not assume any structure a priori concerning how the features interact.\nSometimes, we truly lack the knowledge to be able to guide the construction of fancier\narchitectures. In these cases, an MLP may be the best that we can do. However, for high-\ndimensional perceptual data, such structureless networks can grow unwieldy.\nFor instance, let\u2019s return to our running example of distinguishing cats from dogs. Say that\nwe do a thorough job in data collection, collecting an annotated dataset of one-megapixel\nphotographs. This means that each input to the network has one million dimensions. Even\nanaggressivereductiontoonethousandhiddendimensionswouldrequireafullyconnected\nlayercharacterizedby 106\u0002103=109parameters. UnlesswehavelotsofGPUs,atalentfor\ndistributed optimization, and an extraordinary amount of patience, learning the parameters\nof this network may turn out to be infeasible.\nA careful reader might object to this argument on the basis that one megapixel resolution\nmay not be necessary.", "mimetype": "text/plain", "start_char_idx": 575309, "end_char_idx": 579517, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fc776d3e-ecea-4d0c-a3d3-a96ee8dd6a19": {"__data__": {"id_": "fc776d3e-ecea-4d0c-a3d3-a96ee8dd6a19", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "04d7a591-36bb-4f6d-b509-044ce1cdc3d2", "node_type": "1", "metadata": {}, "hash": "3ff30c3d1659fc2aff5ead6dac67c741023194ec3530bab0da0121b8e25b7b89", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0b7c6787-0bc0-429d-b3cf-ccda2220549d", "node_type": "1", "metadata": {}, "hash": "73212779a8f9b82ee5deea05eee6119f4eb639ed8c8347b2abb4fdf826a00058", "class_name": "RelatedNodeInfo"}}, "text": "In these cases, an MLP may be the best that we can do. However, for high-\ndimensional perceptual data, such structureless networks can grow unwieldy.\nFor instance, let\u2019s return to our running example of distinguishing cats from dogs. Say that\nwe do a thorough job in data collection, collecting an annotated dataset of one-megapixel\nphotographs. This means that each input to the network has one million dimensions. Even\nanaggressivereductiontoonethousandhiddendimensionswouldrequireafullyconnected\nlayercharacterizedby 106\u0002103=109parameters. UnlesswehavelotsofGPUs,atalentfor\ndistributed optimization, and an extraordinary amount of patience, learning the parameters\nof this network may turn out to be infeasible.\nA careful reader might object to this argument on the basis that one megapixel resolution\nmay not be necessary. However, while we might be able to get away with one hundred\nthousand pixels, our hidden layer of size 1000 grossly underestimates the number of hid-\nden units that it takes to learn good representations of images, so a practical system will\nstill require billions of parameters. Moreover, learning a classifier by fitting so many pa-\nrameters might require collecting an enormous dataset. And yet today both humans and\ncomputers are able to distinguish cats from dogs quite well, seemingly contradicting these\nintuitions. That is because images exhibit rich structure that can be exploited by humans\nand machine learning models alike. Convolutional neural networks (CNNs) are one cre-\native way that machine learning has embraced for exploiting some of the known structure\nin natural images.\n7.1.1Invariance\nImagine that we want to detect an object in an image. It seems reasonable that whatever\nmethodweusetorecognizeobjectsshouldnotbeoverlyconcernedwiththepreciselocation\nof the object in the image. Ideally, our system should exploit this knowledge. Pigs usually\ndo not fly and planes usually do not swim. Nonetheless, we should still recognize a pig\n235 From Fully Connected Layers to Convolutions\nwere one to appear at the top of the image. We can draw some inspiration here from the\nchildren\u2019sgame\u201cWhere\u2019sWaldo\u201d(whichitselfhasinspiredmanyreal-lifeimitations,such\nas that depicted in Fig. 7.1.1 ). The game consists of a number of chaotic scenes bursting\nwith activities. Waldo shows up somewhere in each, typically lurking in some unlikely\nlocation. The reader\u2019s goal is to locate him. Despite his characteristic outfit, this can be\nsurprisingly difficult, due to the large number of distractions. However, what Waldo looks\nlikedoesnotdependupon whereWaldoislocated . WecouldsweeptheimagewithaWaldo\ndetector that could assign a score to each patch, indicating the likelihood that the patch\ncontains Waldo. In fact, many object detection and segmentation algorithms are based\non this approach ( Longet al., 2015). CNNs systematize this idea of spatial invariance ,\nexploiting it to learn useful representations with fewer parameters.\ntFig. 7.1.1 Can you \ufb01nd Waldo (image courtesy of William Murphy (Infomatique))?\nWe can now make these intuitions more concrete by enumerating a few desiderata to guide\nour design of a neural network architecture suitable for computer vision:\n1.Intheearliestlayers,ournetworkshouldrespondsimilarlytothesamepatch,regardless\nof where it appears in the image. This principle is called translation invariance (or\ntranslationequivariance ).\n2.The earliest layers of the network should focus on local regions, without regard for the\ncontents of the image in distant regions. This is the localityprinciple. Eventually, these\nlocal representations can be aggregated to make predictions at the whole image level.\n3.As we proceed, deeper layers should be able to capture longer-range features of the\nimage, in a way similar to higher level vision in nature.\nLet\u2019s see how this translates into mathematics.\n7.1.2Constraining the MLP\nTostartoff,wecanconsideranMLPwithtwo-dimensionalimages Xasinputsandtheirim-\nmediatehiddenrepresentations Hsimilarlyrepresentedasmatrices(theyaretwo-dimensional\n236 Convolutional Neural Networks\ntensors in code), where both XandHhave the same shape. Let that sink in. We now\nimagine that not only the inputs but also the hidden representations possess spatial struc-\nture.", "mimetype": "text/plain", "start_char_idx": 578691, "end_char_idx": 582950, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0b7c6787-0bc0-429d-b3cf-ccda2220549d": {"__data__": {"id_": "0b7c6787-0bc0-429d-b3cf-ccda2220549d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fc776d3e-ecea-4d0c-a3d3-a96ee8dd6a19", "node_type": "1", "metadata": {}, "hash": "09436890d3a443b2f8baeef1fce0d56228a3660e81b4fd264374d60177a04eaa", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b55b4cc7-426f-498a-a206-8b60cd584741", "node_type": "1", "metadata": {}, "hash": "3a7374d944ae3ab167a84ae808fe31f7ef6b7a901bcf737b95982da2e04090ba", "class_name": "RelatedNodeInfo"}}, "text": "2.The earliest layers of the network should focus on local regions, without regard for the\ncontents of the image in distant regions. This is the localityprinciple. Eventually, these\nlocal representations can be aggregated to make predictions at the whole image level.\n3.As we proceed, deeper layers should be able to capture longer-range features of the\nimage, in a way similar to higher level vision in nature.\nLet\u2019s see how this translates into mathematics.\n7.1.2Constraining the MLP\nTostartoff,wecanconsideranMLPwithtwo-dimensionalimages Xasinputsandtheirim-\nmediatehiddenrepresentations Hsimilarlyrepresentedasmatrices(theyaretwo-dimensional\n236 Convolutional Neural Networks\ntensors in code), where both XandHhave the same shape. Let that sink in. We now\nimagine that not only the inputs but also the hidden representations possess spatial struc-\nture.\nLet\u00bbX\u00bc\ud835\udc56,\ud835\udc57and\u00bbH\u00bc\ud835\udc56,\ud835\udc57denote the pixel at location \u00b9\ud835\udc56,\ud835\udc57\u00bain the input image and hidden rep-\nresentation,respectively. Consequently,tohaveeachofthehiddenunitsreceiveinputfrom\neachoftheinputpixels,wewouldswitchfromusingweightmatrices(aswedidpreviously\nin MLPs) to representing our parameters as fourth-order weight tensors W. Suppose that\nUcontains biases, we could formally express the fully connected layer as\n\u00bbH\u00bc\ud835\udc56,\ud835\udc57=\u00bbU\u00bc\ud835\udc56,\ud835\udc57\u00b8\u00d5\n\ud835\udc58\u00d5\n\ud835\udc59\u00bbW\u00bc\ud835\udc56,\ud835\udc57,\ud835\udc58,\ud835\udc59\u00bbX\u00bc\ud835\udc58,\ud835\udc59\n=\u00bbU\u00bc\ud835\udc56,\ud835\udc57\u00b8\u00d5\n\ud835\udc4e\u00d5\n\ud835\udc4f\u00bbV\u00bc\ud835\udc56,\ud835\udc57,\ud835\udc4e,\ud835\udc4f\u00bbX\u00bc\ud835\udc56\u00b8\ud835\udc4e,\ud835\udc57\u00b8\ud835\udc4f.(7.1.1)\nTheswitchfrom WtoVisentirelycosmeticfornowsincethereisaone-to-onecorrespon-\ndence between coefficients in both fourth-order tensors. We simply re-index the subscripts\n\u00b9\ud835\udc58,\ud835\udc59\u00basuch that\ud835\udc58=\ud835\udc56\u00b8\ud835\udc4eand\ud835\udc59=\ud835\udc57\u00b8\ud835\udc4f. In other words, we set \u00bbV\u00bc\ud835\udc56,\ud835\udc57,\ud835\udc4e,\ud835\udc4f =\u00bbW\u00bc\ud835\udc56,\ud835\udc57,\ud835\udc56\u00b8\ud835\udc4e,\ud835\udc57\u00b8\ud835\udc4f.\nThe indices\ud835\udc4eand\ud835\udc4frun over both positive and negative offsets, covering the entire image.\nFor any given location ( \ud835\udc56,\ud835\udc57) in the hidden representation \u00bbH\u00bc\ud835\udc56,\ud835\udc57, we compute its value by\nsumming over pixels in \ud835\udc65, centered around\u00b9\ud835\udc56,\ud835\udc57\u00baand weighted by\u00bbV\u00bc\ud835\udc56,\ud835\udc57,\ud835\udc4e,\ud835\udc4f. Before we\ncarry on, let\u2019s consider the total number of parameters required for a singlelayer in this\nparametrization: a 1000\u00021000image (1 megapixel) is mapped to a 1000\u00021000hidden\nrepresentation. This requires 1012parameters, far beyond what computers currently can\nhandle.\nTranslationInvariance\nNow let\u2019s invoke the first principle established above: translation invariance ( Zhanget al.,\n1988). This implies that a shift in the input Xshould simply lead to a shift in the hidden\nrepresentation H. This is only possible if VandUdo not actually depend on \u00b9\ud835\udc56,\ud835\udc57\u00ba. As\nsuch, we have\u00bbV\u00bc\ud835\udc56,\ud835\udc57,\ud835\udc4e,\ud835\udc4f =\u00bbV\u00bc\ud835\udc4e,\ud835\udc4fandUis a constant, say \ud835\udc62. As a result, we can simplify\nthe definition for H:\n\u00bbH\u00bc\ud835\udc56,\ud835\udc57=\ud835\udc62\u00b8\u00d5\n\ud835\udc4e\u00d5\n\ud835\udc4f\u00bbV\u00bc\ud835\udc4e,\ud835\udc4f\u00bbX\u00bc\ud835\udc56\u00b8\ud835\udc4e,\ud835\udc57\u00b8\ud835\udc4f.(7.1.2)\nThis is aconvolution !", "mimetype": "text/plain", "start_char_idx": 582093, "end_char_idx": 584670, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b55b4cc7-426f-498a-a206-8b60cd584741": {"__data__": {"id_": "b55b4cc7-426f-498a-a206-8b60cd584741", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0b7c6787-0bc0-429d-b3cf-ccda2220549d", "node_type": "1", "metadata": {}, "hash": "73212779a8f9b82ee5deea05eee6119f4eb639ed8c8347b2abb4fdf826a00058", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7522c200-552d-4278-bc4e-4c6f2a57cd1d", "node_type": "1", "metadata": {}, "hash": "86ead281a72320229b306b479e13ad7ceb1894bf49c68a7c1eaad368ad6c88e0", "class_name": "RelatedNodeInfo"}}, "text": "This implies that a shift in the input Xshould simply lead to a shift in the hidden\nrepresentation H. This is only possible if VandUdo not actually depend on \u00b9\ud835\udc56,\ud835\udc57\u00ba. As\nsuch, we have\u00bbV\u00bc\ud835\udc56,\ud835\udc57,\ud835\udc4e,\ud835\udc4f =\u00bbV\u00bc\ud835\udc4e,\ud835\udc4fandUis a constant, say \ud835\udc62. As a result, we can simplify\nthe definition for H:\n\u00bbH\u00bc\ud835\udc56,\ud835\udc57=\ud835\udc62\u00b8\u00d5\n\ud835\udc4e\u00d5\n\ud835\udc4f\u00bbV\u00bc\ud835\udc4e,\ud835\udc4f\u00bbX\u00bc\ud835\udc56\u00b8\ud835\udc4e,\ud835\udc57\u00b8\ud835\udc4f.(7.1.2)\nThis is aconvolution ! We are effectively weighting pixels at \u00b9\ud835\udc56\u00b8\ud835\udc4e,\ud835\udc57\u00b8\ud835\udc4f\u00bain the vicinity of\nlocation\u00b9\ud835\udc56,\ud835\udc57\u00bawith coefficients\u00bbV\u00bc\ud835\udc4e,\ud835\udc4fto obtain the value\u00bbH\u00bc\ud835\udc56,\ud835\udc57. Note that\u00bbV\u00bc\ud835\udc4e,\ud835\udc4fneeds\nmany fewer coefficients than \u00bbV\u00bc\ud835\udc56,\ud835\udc57,\ud835\udc4e,\ud835\udc4fsince it no longer depends on the location within\nthe image. Consequently, the number of parameters required is no longer 1012but a much\nmore reasonable 4\u0002106: we still have the dependency on \ud835\udc4e,\ud835\udc4f2\u00b9\u0000 1000,1000\u00ba. In short,\nwe have made significant progress. Time-delay neural networks (TDNNs) are some of the\nfirst examples to exploit this idea ( Waibeletal., 1989).\nLocality\nNow let\u2019s invoke the second principle: locality. As motivated above, we believe that we\nshould not have to look very far away from location \u00b9\ud835\udc56,\ud835\udc57\u00bain order to glean relevant infor-\n237 From Fully Connected Layers to Convolutions\nmation to assess what is going on at \u00bbH\u00bc\ud835\udc56,\ud835\udc57. This means that outside some range j\ud835\udc4ej>\u0394\norj\ud835\udc4fj>\u0394, we should set\u00bbV\u00bc\ud835\udc4e,\ud835\udc4f=0. Equivalently, we can rewrite \u00bbH\u00bc\ud835\udc56,\ud835\udc57as\n\u00bbH\u00bc\ud835\udc56,\ud835\udc57=\ud835\udc62\u00b8\u0394\u00d5\n\ud835\udc4e=\u0000\u0394\u0394\u00d5\n\ud835\udc4f=\u0000\u0394\u00bbV\u00bc\ud835\udc4e,\ud835\udc4f\u00bbX\u00bc\ud835\udc56\u00b8\ud835\udc4e,\ud835\udc57\u00b8\ud835\udc4f. (7.1.3)\nThisreducesthenumberofparametersfrom 4\u0002106to4\u03942,where \u0394istypicallysmallerthan\n10. As such, we reduced the number of parameters by another four orders of magnitude.\nNote that (7.1.3 ), is what is called, in a nutshell, a convolutional layer .Convolutional\nneuralnetworks (CNNs) are a special family of neural networks that contain convolutional\nlayers. In the deep learning research community, Vis referred to as a convolution kernel ,\nafilter, or simply the layer\u2019s weightsthat are learnable parameters.\nWhile previously, we might have required billions of parameters to represent just a single\nlayer in an image-processing network, we now typically need just a few hundred, without\naltering the dimensionality of either the inputs or the hidden representations. The price\npaidforthisdrasticreductioninparametersisthatourfeaturesarenowtranslationinvariant\nand that our layer can only incorporate local information, when determining the value of\neach hidden activation. All learning depends on imposing inductive bias. When that bias\nagrees with reality, we get sample-efficient models that generalize well to unseen data. But\nof course, if those biases do not agree with reality, e.g., if images turned out not to be\ntranslation invariant, our models might struggle even to fit our training data.\nThisdramaticreductioninparametersbringsustoourlastdesideratum,namelythatdeeper\nlayersshouldrepresentlargerandmorecomplexaspectsofanimage. Thiscanbeachieved\nby interleaving nonlinearities and convolutional layers repeatedly.\n7.1.3Convolutions\nLet\u2019s briefly review why (7.1.3 )is called a convolution.", "mimetype": "text/plain", "start_char_idx": 584332, "end_char_idx": 587263, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7522c200-552d-4278-bc4e-4c6f2a57cd1d": {"__data__": {"id_": "7522c200-552d-4278-bc4e-4c6f2a57cd1d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b55b4cc7-426f-498a-a206-8b60cd584741", "node_type": "1", "metadata": {}, "hash": "3a7374d944ae3ab167a84ae808fe31f7ef6b7a901bcf737b95982da2e04090ba", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2d291ee0-29a1-4d16-a769-8a750eab2eca", "node_type": "1", "metadata": {}, "hash": "193665734460e58963fc5bfc8933956301af650df072b53317243f9abb0a1268", "class_name": "RelatedNodeInfo"}}, "text": "The price\npaidforthisdrasticreductioninparametersisthatourfeaturesarenowtranslationinvariant\nand that our layer can only incorporate local information, when determining the value of\neach hidden activation. All learning depends on imposing inductive bias. When that bias\nagrees with reality, we get sample-efficient models that generalize well to unseen data. But\nof course, if those biases do not agree with reality, e.g., if images turned out not to be\ntranslation invariant, our models might struggle even to fit our training data.\nThisdramaticreductioninparametersbringsustoourlastdesideratum,namelythatdeeper\nlayersshouldrepresentlargerandmorecomplexaspectsofanimage. Thiscanbeachieved\nby interleaving nonlinearities and convolutional layers repeatedly.\n7.1.3Convolutions\nLet\u2019s briefly review why (7.1.3 )is called a convolution. In mathematics, the convolution\nbetween two functions ( Rudin, 1973 ), say\ud835\udc53,\ud835\udc54:R\ud835\udc51!Ris defined as\n\u00b9\ud835\udc53\u0003\ud835\udc54\u00ba\u00b9x\u00ba=\u00b9\n\ud835\udc53\u00b9z\u00ba\ud835\udc54\u00b9x\u0000z\u00ba\ud835\udc51z. (7.1.4)\nThatis,wemeasuretheoverlapbetween \ud835\udc53and\ud835\udc54whenonefunctionis\u201cflipped\u201dandshifted\nbyx. Whenever we have discrete objects, the integral turns into a sum. For instance, for\nvectors from the set of square-summable infinite-dimensional vectors with index running\noverZwe obtain the following definition:\n\u00b9\ud835\udc53\u0003\ud835\udc54\u00ba\u00b9\ud835\udc56\u00ba=\u00d5\n\ud835\udc4e\ud835\udc53\u00b9\ud835\udc4e\u00ba\ud835\udc54\u00b9\ud835\udc56\u0000\ud835\udc4e\u00ba.(7.1.5)\nFor two-dimensional tensors, we have a corresponding sum with indices \u00b9\ud835\udc4e,\ud835\udc4f\u00bafor\ud835\udc53and\n\u00b9\ud835\udc56\u0000\ud835\udc4e,\ud835\udc57\u0000\ud835\udc4f\u00bafor\ud835\udc54, respectively:\n\u00b9\ud835\udc53\u0003\ud835\udc54\u00ba\u00b9\ud835\udc56,\ud835\udc57\u00ba=\u00d5\n\ud835\udc4e\u00d5\n\ud835\udc4f\ud835\udc53\u00b9\ud835\udc4e,\ud835\udc4f\u00ba\ud835\udc54\u00b9\ud835\udc56\u0000\ud835\udc4e,\ud835\udc57\u0000\ud835\udc4f\u00ba.(7.1.6)\nThis looks similar to (7.1.3 ), with one major difference. Rather than using \u00b9\ud835\udc56\u00b8\ud835\udc4e,\ud835\udc57\u00b8\ud835\udc4f\u00ba,\nwe are using the difference instead. Note, though, that this distinction is mostly cosmetic\n238 Convolutional Neural Networks\nsincewecanalwaysmatchthenotationbetween (7.1.3 )and(7.1.6 ). Ouroriginaldefinition\nin(7.1.3 )more properly describes a cross-correlation . We will come back to this in the\nfollowing section.\n7.1.4Channels\nReturningtoourWaldodetector,let\u2019sseewhatthislookslike. Theconvolutionallayerpicks\nwindows of a given size and weighs intensities according to the filter V, as demonstrated\ninFig. 7.1.2 . We might aim to learn a model so that wherever the \u201cwaldoness\u201d is highest,\nwe should find a peak in the hidden layer representations.\ntFig. 7.1.2 Detect Waldo (image courtesy of William Murphy (Infomatique)).\nThere is just one problem with this approach. So far, we blissfully ignored that images\nconsist of three channels: red, green, and blue. In sum, images are not two-dimensional\nobjects but rather third-order tensors, characterized by a height, width, and channel, e.g.,\nwithshape 1024\u00021024\u00023pixels. Whilethefirsttwooftheseaxesconcernspatialrelation-\nships,thethirdcanberegardedasassigningamultidimensionalrepresentationtoeachpixel\nlocation. We thus index Xas\u00bbX\u00bc\ud835\udc56,\ud835\udc57,\ud835\udc58. The convolutional filter has to adapt accordingly.\nInstead of\u00bbV\u00bc\ud835\udc4e,\ud835\udc4f, we now have\u00bbV\u00bc\ud835\udc4e,\ud835\udc4f,\ud835\udc50.\nMoreover, just as our input consists of a third-order tensor, it turns out to be a good idea\nto similarly formulate our hidden representations as third-order tensors H. In other words,\nratherthanjusthavingasinglehiddenrepresentationcorrespondingtoeachspatiallocation,\nwe want an entire vector of hidden representations corresponding to each spatial location.", "mimetype": "text/plain", "start_char_idx": 586430, "end_char_idx": 589602, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2d291ee0-29a1-4d16-a769-8a750eab2eca": {"__data__": {"id_": "2d291ee0-29a1-4d16-a769-8a750eab2eca", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7522c200-552d-4278-bc4e-4c6f2a57cd1d", "node_type": "1", "metadata": {}, "hash": "86ead281a72320229b306b479e13ad7ceb1894bf49c68a7c1eaad368ad6c88e0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "45f09d6a-a8c1-4e17-85f3-6c4b1a6c1eac", "node_type": "1", "metadata": {}, "hash": "95a52e8b816320ce83e41a2ccc76731c39e2af86a0c0e2e7fec202cc4f70852c", "class_name": "RelatedNodeInfo"}}, "text": "Whilethefirsttwooftheseaxesconcernspatialrelation-\nships,thethirdcanberegardedasassigningamultidimensionalrepresentationtoeachpixel\nlocation. We thus index Xas\u00bbX\u00bc\ud835\udc56,\ud835\udc57,\ud835\udc58. The convolutional filter has to adapt accordingly.\nInstead of\u00bbV\u00bc\ud835\udc4e,\ud835\udc4f, we now have\u00bbV\u00bc\ud835\udc4e,\ud835\udc4f,\ud835\udc50.\nMoreover, just as our input consists of a third-order tensor, it turns out to be a good idea\nto similarly formulate our hidden representations as third-order tensors H. In other words,\nratherthanjusthavingasinglehiddenrepresentationcorrespondingtoeachspatiallocation,\nwe want an entire vector of hidden representations corresponding to each spatial location.\nWe could think of the hidden representations as comprising a number of two-dimensional\ngrids stacked on top of each other. As in the inputs, these are sometimes called channels .\nThey are also sometimes called feature maps , as each provides a spatialized set of learned\nfeaturesforthesubsequentlayer. Intuitively,youmightimaginethatatlowerlayersthatare\ncloser to inputs, some channels could become specialized to recognize edges while others\ncould recognize textures.\nTosupportmultiplechannelsinbothinputs( X)andhiddenrepresentations( H),wecanadd\n239 From Fully Connected Layers to Convolutions\na fourth coordinate to V:\u00bbV\u00bc\ud835\udc4e,\ud835\udc4f,\ud835\udc50,\ud835\udc51. Putting everything together we have:\n\u00bbH\u00bc\ud835\udc56,\ud835\udc57,\ud835\udc51=\u0394\u00d5\n\ud835\udc4e=\u0000\u0394\u0394\u00d5\n\ud835\udc4f=\u0000\u0394\u00d5\n\ud835\udc50\u00bbV\u00bc\ud835\udc4e,\ud835\udc4f,\ud835\udc50,\ud835\udc51\u00bbX\u00bc\ud835\udc56\u00b8\ud835\udc4e,\ud835\udc57\u00b8\ud835\udc4f,\ud835\udc50, (7.1.7)\nwhere\ud835\udc51indexes the output channels in the hidden representations H. The subsequent con-\nvolutionallayerwillgoontotakeathird-ordertensor, H,asinput. Wetake (7.1.7 ),because\nof its generality, as the definition of a convolutional layer for multiple channels, where V\nis a kernel or filter of the layer.\nThereare still manyoperations that weneed to address. Forinstance, weneed to figure out\nhow to combine all the hidden representations to a single output, e.g., whether there is a\nWaldoanywhere in the image. We also need to decide how to compute things efficiently,\nhowtocombinemultiplelayers, appropriateactivationfunctions, andhowtomakereason-\nable design choices to yield networks that are effective in practice. We turn to these issues\nin the remainder of the chapter.\n7.1.5Summaryand Discussion\nIn this section we derived the structure of convolutional neural networks from first prin-\nciples. While it is unclear whether this was the route taken to the invention of CNNs, it\nis satisfying to know that they are the rightchoice when applying reasonable principles\nto how image processing and computer vision algorithms should operate, at least at lower\nlevels. In particular, translation invariance in images implies that all patches of an image\nwill be treated in the same manner. Locality means that only a small neighborhood of pix-\nels will be used to compute the corresponding hidden representations. Some of the earliest\nreferences to CNNs are in the form of the Neocognitron ( Fukushima, 1982 ).\nA second principle that we encountered in our reasoning is how to reduce the number of\nparameters in a function class without limiting its expressive power, at least, whenever\ncertain assumptions on the model hold. We saw a dramatic reduction of complexity as a\nresult of this restriction, turning computationally and statistically infeasible problems into\ntractable models.\nAddingchannelsallowedustobringbacksomeofthecomplexitythatwaslostduetothere-\nstrictions imposed on the convolutional kernel by locality and translation invariance. Note\nthat it is quite natural to add channels other than just red, green, and blue. Many satellite\nimages, in particular for agriculture and meteorology, have tens to hundreds of channels,\ngenerating hyperspectral images instead. They report data on many different wavelengths.\nIn the following we will see how to use convolutions effectively to manipulate the dimen-\nsionalityoftheimagestheyoperateon, howtomovefromlocation-basedtochannel-based\nrepresentations, and how to deal with large numbers of categories efficiently.\n7.1.6Exercises\n1.Assume that the size of the convolution kernel is \u0394 = 0.", "mimetype": "text/plain", "start_char_idx": 588985, "end_char_idx": 592974, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "45f09d6a-a8c1-4e17-85f3-6c4b1a6c1eac": {"__data__": {"id_": "45f09d6a-a8c1-4e17-85f3-6c4b1a6c1eac", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2d291ee0-29a1-4d16-a769-8a750eab2eca", "node_type": "1", "metadata": {}, "hash": "193665734460e58963fc5bfc8933956301af650df072b53317243f9abb0a1268", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7aee0d06-2203-47da-afba-028df6d37ce2", "node_type": "1", "metadata": {}, "hash": "7a49da4dd8fc8426e36a62e2ba96453c84e0bc5ad7631db1fe76868b3e20400c", "class_name": "RelatedNodeInfo"}}, "text": "Addingchannelsallowedustobringbacksomeofthecomplexitythatwaslostduetothere-\nstrictions imposed on the convolutional kernel by locality and translation invariance. Note\nthat it is quite natural to add channels other than just red, green, and blue. Many satellite\nimages, in particular for agriculture and meteorology, have tens to hundreds of channels,\ngenerating hyperspectral images instead. They report data on many different wavelengths.\nIn the following we will see how to use convolutions effectively to manipulate the dimen-\nsionalityoftheimagestheyoperateon, howtomovefromlocation-basedtochannel-based\nrepresentations, and how to deal with large numbers of categories efficiently.\n7.1.6Exercises\n1.Assume that the size of the convolution kernel is \u0394 = 0. Show that in this case the\nconvolution kernel implements an MLP independently for each set of channels. This\nleads to the Network in Network architectures ( Linetal., 2013).\n240 Convolutional Neural Networks\n1192.Audio data is often represented as a one-dimensional sequence.\n1.When might you want to impose locality and translation invariance for audio?\n2.Derive the convolution operations for audio.\n3.Can you treat audio using the same tools as computer vision? Hint: use the spectro-\ngram.\n3.Why might translation invariance not be a good idea after all? Give an example.\n4.Do you think that convolutional layers might also be applicable for text data? Which\nproblems might you encounter with language?\n5.What happens with convolutions when an object is at the boundary of an image?\n6.Prove that the convolution is symmetric, i.e., \ud835\udc53\u0003\ud835\udc54=\ud835\udc54\u0003\ud835\udc53.\nDiscussions119.\n7.2ConvolutionsforImages\nNow that we understand how convolutional layers work in theory, we are ready to see how\nthey work in practice. Building on our motivation of convolutional neural networks as\nefficient architectures for exploring structure in image data, we stick with images as our\nrunning example.\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n7.2.1The Cross-CorrelationOperation\nRecallthatstrictlyspeaking,convolutionallayersareamisnomer,sincetheoperationsthey\nexpress are more accurately described as cross-correlations. Based on our descriptions of\nconvolutional layers in Section 7.1 , in such a layer, an input tensor and a kernel tensor are\ncombined to produce an output tensor through a cross-correlation operation.\nLet\u2019signorechannelsfornowandseehowthisworkswithtwo-dimensionaldataandhidden\nrepresentations. In Fig. 7.2.1 , the input is a two-dimensional tensor with a height of 3 and\nwidth of 3. We mark the shape of the tensor as 3\u00023or (3,3). The height and width of the\nkernel are both 2. The shape of the kernelwindow (orconvolutionwindow ) is given by the\nheight and width of the kernel (here it is 2\u00022).\nInthetwo-dimensionalcross-correlationoperation,webeginwiththeconvolutionwindow\npositioned at the upper-left corner of the input tensor and slide it across the input tensor,\nboth from left to right and top to bottom. When the convolution window slides to a certain\n241 Convolutions for Images\ntFig. 7.2.1 Two-dimensional cross-correlation operation. The shaded portions are the \ufb01rst output\nelement as well as the input and kernel tensor elements used for the output computation:\n0\u00020\u00b81\u00021\u00b83\u00022\u00b84\u00023=19.\nposition, the input subtensor contained in that window and the kernel tensor are multiplied\nelementwise and the resulting tensor is summed up yielding a single scalar value. This\nresult gives the value of the output tensor at the corresponding location. Here, the output\ntensor has a height of 2 and width of 2 and the four elements are derived from the two-\ndimensional cross-correlation operation:\n0\u00020\u00b81\u00021\u00b83\u00022\u00b84\u00023=19,\n1\u00020\u00b82\u00021\u00b84\u00022\u00b85\u00023=25,\n3\u00020\u00b84\u00021\u00b86\u00022\u00b87\u00023=37,\n4\u00020\u00b85\u00021\u00b87\u00022\u00b88\u00023=43.(7.2.1)\nNote that along each axis, the output size is slightly smaller than the input size.", "mimetype": "text/plain", "start_char_idx": 592213, "end_char_idx": 596047, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7aee0d06-2203-47da-afba-028df6d37ce2": {"__data__": {"id_": "7aee0d06-2203-47da-afba-028df6d37ce2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "45f09d6a-a8c1-4e17-85f3-6c4b1a6c1eac", "node_type": "1", "metadata": {}, "hash": "95a52e8b816320ce83e41a2ccc76731c39e2af86a0c0e2e7fec202cc4f70852c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "87f81415-a5ea-4cf7-bae7-24ca4c4f5dcb", "node_type": "1", "metadata": {}, "hash": "5f306725746fa50ccc744a2a13f51ea87308437380a0c09a309b1cf24d050e78", "class_name": "RelatedNodeInfo"}}, "text": "position, the input subtensor contained in that window and the kernel tensor are multiplied\nelementwise and the resulting tensor is summed up yielding a single scalar value. This\nresult gives the value of the output tensor at the corresponding location. Here, the output\ntensor has a height of 2 and width of 2 and the four elements are derived from the two-\ndimensional cross-correlation operation:\n0\u00020\u00b81\u00021\u00b83\u00022\u00b84\u00023=19,\n1\u00020\u00b82\u00021\u00b84\u00022\u00b85\u00023=25,\n3\u00020\u00b84\u00021\u00b86\u00022\u00b87\u00023=37,\n4\u00020\u00b85\u00021\u00b87\u00022\u00b88\u00023=43.(7.2.1)\nNote that along each axis, the output size is slightly smaller than the input size. Because\nthe kernel has width and height greater than 1, we can only properly compute the cross-\ncorrelation for locations where the kernel fits wholly within the image, the output size is\ngiven by the input size \ud835\udc5bh\u0002\ud835\udc5bwminus the size of the convolution kernel \ud835\udc58h\u0002\ud835\udc58wvia\n\u00b9\ud835\udc5bh\u0000\ud835\udc58h\u00b81\u00ba\u0002\u00b9\ud835\udc5bw\u0000\ud835\udc58w\u00b81\u00ba. (7.2.2)\nThis is the case since we need enough space to \u201cshift\u201d the convolution kernel across the\nimage. Later we will see how to keep the size unchanged by padding the image with zeros\naround its boundary so that there is enough space to shift the kernel. Next, we implement\nthis process in the corr2dfunction, which accepts an input tensor Xand a kernel tensor K\nand returns an output tensor Y.\ndef corr2d (X, K): #@save\n\"\"\"Compute 2D cross-correlation.\"\"\"\nh, w =K.shape\nY=torch .zeros((X .shape[ 0]-h+1, X.shape[ 1]-w+1))\nfor iinrange (Y.shape[ 0]):\nfor jinrange (Y.shape[ 1]):\nY[i, j] =(X[i:i +h, j:j +w]*K).sum()\nreturn Y\nWe can construct the input tensor Xand the kernel tensor KfromFig. 7.2.1 to validate\nthe output of the above implementation of the two-dimensional cross-correlation opera-\ntion.\nX=torch .tensor([[ 0.0,1.0,2.0], [ 3.0,4.0,5.0], [ 6.0,7.0,8.0]])\n(continues on next page)\n242 Convolutional Neural Networks\n(continued from previous page)\nK=torch .tensor([[ 0.0,1.0], [ 2.0,3.0]])\ncorr2d(X, K)\ntensor([[ 19.,25.],\n[37.,43.]])\n7.2.2ConvolutionalLayers\nAconvolutionallayercross-correlatestheinputandkernelandaddsascalarbiastoproduce\nan output. The two parameters of a convolutional layer are the kernel and the scalar bias.\nWhen training models based on convolutional layers, we typically initialize the kernels\nrandomly, just as we would with a fully connected layer.\nWearenowreadytoimplementatwo-dimensionalconvolutionallayerbasedonthe corr2d\nfunction defined above. In the __init__ constructor method, wedeclare weightandbias\nas the two model parameters. The forward propagation method calls the corr2dfunction\nand adds the bias.\nclass Conv2D (nn.Module):\ndef __init__ (self , kernel_size):\nsuper ().__init__ ()\nself .weight =nn.Parameter(torch .rand(kernel_size))\nself .bias =nn.Parameter(torch .zeros( 1))\ndef forward (self , x):\nreturn corr2d(x, self .weight) +self .bias\nIn\u210e\u0002\ud835\udc64convolutionoran \u210e\u0002\ud835\udc64convolutionkernel,theheightandwidthoftheconvolution\nkernel are\u210eand\ud835\udc64, respectively. We also refer to a convolutional layer with an \u210e\u0002\ud835\udc64\nconvolution kernel simply as an \u210e\u0002\ud835\udc64convolutional layer.\n7.2.3Object EdgeDetectionin Images\nLet\u2019s take a moment to parse a simple application of a convolutional layer: detecting the\nedgeofanobjectinanimagebyfindingthelocationofthepixelchange. First,weconstruct\nan \u201cimage\u201d of 6\u00028pixels. The middle four columns are black ( 0) and the rest are white\n(1).", "mimetype": "text/plain", "start_char_idx": 595477, "end_char_idx": 598742, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "87f81415-a5ea-4cf7-bae7-24ca4c4f5dcb": {"__data__": {"id_": "87f81415-a5ea-4cf7-bae7-24ca4c4f5dcb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7aee0d06-2203-47da-afba-028df6d37ce2", "node_type": "1", "metadata": {}, "hash": "7a49da4dd8fc8426e36a62e2ba96453c84e0bc5ad7631db1fe76868b3e20400c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b4c6f59b-a442-40b5-ac2c-d43005a6d1b5", "node_type": "1", "metadata": {}, "hash": "8bdbf23603f453ab498118204503107fe159d65c3ccb0c0354a56c85088e8979", "class_name": "RelatedNodeInfo"}}, "text": "We also refer to a convolutional layer with an \u210e\u0002\ud835\udc64\nconvolution kernel simply as an \u210e\u0002\ud835\udc64convolutional layer.\n7.2.3Object EdgeDetectionin Images\nLet\u2019s take a moment to parse a simple application of a convolutional layer: detecting the\nedgeofanobjectinanimagebyfindingthelocationofthepixelchange. First,weconstruct\nan \u201cimage\u201d of 6\u00028pixels. The middle four columns are black ( 0) and the rest are white\n(1).\nX=torch .ones(( 6,8))\nX[:, 2:6]=0\nX\ntensor([[ 1.,1.,0.,0.,0.,0.,1.,1.],\n[1.,1.,0.,0.,0.,0.,1.,1.],\n[1.,1.,0.,0.,0.,0.,1.,1.],\n(continues on next page)\n243 Convolutions for Images\n(continued from previous page)\n[1.,1.,0.,0.,0.,0.,1.,1.],\n[1.,1.,0.,0.,0.,0.,1.,1.],\n[1.,1.,0.,0.,0.,0.,1.,1.]])\nNext, we construct a kernel Kwith a height of 1 and a width of 2. When we perform\nthe cross-correlation operation with the input, if the horizontally adjacent elements are\nthe same, the output is 0. Otherwise, the output is nonzero. Note that this kernel is a\nspecial case of a finite difference operator. At location \u00b9\ud835\udc56,\ud835\udc57\u00bait computes \ud835\udc65\ud835\udc56,\ud835\udc57\u0000\ud835\udc65\u00b9\ud835\udc56\u00b81\u00ba,\ud835\udc57,\ni.e., it computes the difference between the values of horizontally adjacent pixels. This is\na discrete approximation of the first derivative in the horizontal direction. After all, for\na function\ud835\udc53\u00b9\ud835\udc56,\ud835\udc57\u00baits derivative\u0000\ud835\udf15\ud835\udc56\ud835\udc53\u00b9\ud835\udc56,\ud835\udc57\u00ba=lim\ud835\udf16!0\ud835\udc53\u00b9\ud835\udc56,\ud835\udc57\u00ba\u0000\ud835\udc53\u00b9\ud835\udc56\u00b8\ud835\udf16,\ud835\udc57\u00ba\n\ud835\udf16. Let\u2019s see how this\nworks in practice.\nK=torch .tensor([[ 1.0,-1.0]])\nWe are ready to perform the cross-correlation operation with arguments X(our input) and\nK(our kernel). As you can see, we detect 1for the edge from white to black and \u00001for the\nedge from black to white. All other outputs take value 0.\nY=corr2d(X, K)\nY\ntensor([[ 0.,1.,0.,0.,0.,-1.,0.],\n[0.,1.,0.,0.,0.,-1.,0.],\n[0.,1.,0.,0.,0.,-1.,0.],\n[0.,1.,0.,0.,0.,-1.,0.],\n[0.,1.,0.,0.,0.,-1.,0.],\n[0.,1.,0.,0.,0.,-1.,0.]])\nWecannowapplythekerneltothetransposedimage. Asexpected, itvanishes. Thekernel\nKonly detects vertical edges.\ncorr2d(X .t(), K)\ntensor([[ 0.,0.,0.,0.,0.],\n[0.,0.,0.,0.,0.],\n[0.,0.,0.,0.,0.],\n[0.,0.,0.,0.,0.],\n[0.,0.,0.,0.,0.],\n[0.,0.,0.,0.,0.],\n[0.,0.,0.,0.,0.],\n[0.,0.,0.,0.,0.]])\n7.2.4Learning a Kernel\n244 Convolutional Neural Networks\nDesigninganedgedetectorbyfinitedifferences [1, -1] isneatifweknowthisisprecisely\nwhat we are looking for. However, as we look at larger kernels, and consider successive\nlayers of convolutions, it might be impossible to specify precisely what each filter should\nbe doing manually.\nNow let\u2019s see whether we can learn the kernel that generated Yfrom Xby looking at the\ninput\u2013output pairs only. We first construct a convolutional layer and initialize its kernel as\narandomtensor. Next,ineachiteration,wewillusethesquarederrortocompare Ywiththe\noutput of the convolutional layer. We can then calculate the gradient to update the kernel.", "mimetype": "text/plain", "start_char_idx": 598340, "end_char_idx": 601085, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b4c6f59b-a442-40b5-ac2c-d43005a6d1b5": {"__data__": {"id_": "b4c6f59b-a442-40b5-ac2c-d43005a6d1b5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "87f81415-a5ea-4cf7-bae7-24ca4c4f5dcb", "node_type": "1", "metadata": {}, "hash": "5f306725746fa50ccc744a2a13f51ea87308437380a0c09a309b1cf24d050e78", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "36ac5c8c-8e14-4cae-bf86-710a0218d847", "node_type": "1", "metadata": {}, "hash": "571b638ee3ed3dd9525722624762b7708cb7ea8807852c3f5e556666c3c43854", "class_name": "RelatedNodeInfo"}}, "text": "],\n[0.,0.,0.,0.,0.],\n[0.,0.,0.,0.,0.]])\n7.2.4Learning a Kernel\n244 Convolutional Neural Networks\nDesigninganedgedetectorbyfinitedifferences [1, -1] isneatifweknowthisisprecisely\nwhat we are looking for. However, as we look at larger kernels, and consider successive\nlayers of convolutions, it might be impossible to specify precisely what each filter should\nbe doing manually.\nNow let\u2019s see whether we can learn the kernel that generated Yfrom Xby looking at the\ninput\u2013output pairs only. We first construct a convolutional layer and initialize its kernel as\narandomtensor. Next,ineachiteration,wewillusethesquarederrortocompare Ywiththe\noutput of the convolutional layer. We can then calculate the gradient to update the kernel.\nFor the sake of simplicity, in the following we use the built-in class for two-dimensional\nconvolutional layers and ignore the bias.\n# Construct a two-dimensional convolutional layer with 1 output channel and a\n# kernel of shape (1, 2). For the sake of simplicity, we ignore the bias here\nconv2d =nn.LazyConv2d( 1, kernel_size =(1,2), bias =False )\n# The two-dimensional convolutional layer uses four-dimensional input and\n# output in the format of (example, channel, height, width), where the batch\n# size (number of examples in the batch) and the number of channels are both 1\nX=X.reshape(( 1,1,6,8))\nY=Y.reshape(( 1,1,6,7))\nlr=3e-2 # Learning rate\nfor iinrange (10):\nY_hat =conv2d(X)\nl=(Y_hat -Y)**2\nconv2d .zero_grad()\nl.sum() .backward()\n# Update the kernel\nconv2d .weight .data[:] -=lr*conv2d .weight .grad\nif(i+1)%2==0:\nprint (f'epoch {i+1}, loss {l.sum() :.3f}')\nepoch 2, loss 16.481\nepoch 4, loss 5.069\nepoch 6, loss 1.794\nepoch 8, loss 0.688\nepoch 10, loss 0.274\nNotethattheerrorhasdroppedtoasmallvalueafter10iterations. Nowwewilltakealook\nat the kernel tensor we learned.\nconv2d .weight .data .reshape(( 1,2))\ntensor([[ 1.0398 ,-0.9328 ]])\nIndeed, the learned kernel tensor is remarkably close to the kernel tensor Kwe defined\nearlier.\n245 Convolutions for Images\n7.2.5Cross-Correlationand Convolution\nRecallourobservationfrom Section7.1 ofthecorrespondencebetweenthecross-correlation\nandconvolutionoperations. Herelet\u2019scontinuetoconsidertwo-dimensionalconvolutional\nlayers. What if such layers perform strict convolution operations as defined in (7.1.6 )in-\nsteadofcross-correlations? Inordertoobtaintheoutputofthestrict convolution operation,\nweonlyneedtoflipthetwo-dimensionalkerneltensorbothhorizontallyandvertically,and\nthen perform the cross-correlation operation with the input tensor.\nIt is noteworthy that since kernels are learned from data in deep learning, the outputs of\nconvolutional layers remain unaffected no matter such layers perform either the strict con-\nvolution operations or the cross-correlation operations.\nTo illustrate this, suppose that a convolutional layer performs cross-correlation and learns\nthe kernel in Fig. 7.2.1 , which is here denoted as the matrix K. Assuming that other con-\nditions remain unchanged, when this layer instead performs strict convolution , the learned\nkernel K0will be the same as KafterK0is flipped both horizontally and vertically. That\nis to say, when the convolutional layer performs strict convolution for the input in Fig.\n7.2.1andK0, the same output in Fig. 7.2.1 (cross-correlation of the input and K) will be\nobtained.\nInkeepingwithstandardterminologyindeeplearningliterature,wewillcontinuetoreferto\nthecross-correlationoperationasaconvolutioneventhough,strictly-speaking,itisslightly\ndifferent. Furthermore, we use the term element to refer to an entry (or component) of any\ntensor representing a layer representation or a convolution kernel.\n7.2.6FeatureMap and ReceptiveField\nAs described in Section 7.1.4 , the convolutional layer output in Fig.", "mimetype": "text/plain", "start_char_idx": 600357, "end_char_idx": 604112, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "36ac5c8c-8e14-4cae-bf86-710a0218d847": {"__data__": {"id_": "36ac5c8c-8e14-4cae-bf86-710a0218d847", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b4c6f59b-a442-40b5-ac2c-d43005a6d1b5", "node_type": "1", "metadata": {}, "hash": "8bdbf23603f453ab498118204503107fe159d65c3ccb0c0354a56c85088e8979", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "298adf03-6580-46c5-b487-d672be177bb5", "node_type": "1", "metadata": {}, "hash": "a2e388b74e1c019e44955947135aaf95384de142fbd82647ba6c841a3af30d9e", "class_name": "RelatedNodeInfo"}}, "text": "That\nis to say, when the convolutional layer performs strict convolution for the input in Fig.\n7.2.1andK0, the same output in Fig. 7.2.1 (cross-correlation of the input and K) will be\nobtained.\nInkeepingwithstandardterminologyindeeplearningliterature,wewillcontinuetoreferto\nthecross-correlationoperationasaconvolutioneventhough,strictly-speaking,itisslightly\ndifferent. Furthermore, we use the term element to refer to an entry (or component) of any\ntensor representing a layer representation or a convolution kernel.\n7.2.6FeatureMap and ReceptiveField\nAs described in Section 7.1.4 , the convolutional layer output in Fig. 7.2.1 is sometimes\ncalled afeature map , as it can be regarded as the learned representations (features) in the\nspatial dimensions (e.g., width and height) to the subsequent layer. In CNNs, for any el-\nement\ud835\udc65of some layer, its receptive field refers to all the elements (from all the previous\nlayers) that may affect the calculation of \ud835\udc65during the forward propagation. Note that the\nreceptive field may be larger than the actual size of the input.\nLet\u2019s continue to use Fig. 7.2.1 to explain the receptive field. Given the 2\u00022convolution\nkernel, the receptive field of the shaded output element (of value 19) is the four elements\nin the shaded portion of the input. Now let\u2019s denote the 2\u00022output as Yand consider a\ndeeperCNNwithanadditional 2\u00022convolutionallayerthattakes Yasitsinput,outputting\na single element \ud835\udc67. In this case, the receptive field of \ud835\udc67onYincludes all the four elements\nofY,whilethereceptivefieldontheinputincludesallthenineinputelements. Thus,when\nany element in a feature map needs a larger receptive field to detect input features over a\nbroader area, we can build a deeper network.\nReceptive fields derive their name from neurophysiology. A series of experiments on a\nrangeofanimalsusingdifferentstimuli( HubelandWiesel, 1959 ,HubelandWiesel, 1962 ,\nHubel and Wiesel, 1968 ) explored the response of what is called the visual cortex on said\nstimuli. By and large they found that lower levels respond to edges and related shapes.\n246 Convolutional Neural Networks\nLateron,Field( 1987)illustratedthiseffectonnaturalimageswith,whatcanonlybecalled,\nconvolutional kernels. We reprint a key figure in Fig. 7.2.2 to illustrate the striking simi-\nlarities.\ntFig. 7.2.2 Figure and caption taken from Field ( 1987 ): An example of coding with six different\nchannels. (Left) Examples of the six types of sensor associated with each channel. (Right)\nConvolution of the image in (Middle) with the six sensors shown in (Left). The response\nof the individual sensors is determined by sampling these \ufb01ltered images at a distance\nproportional to the size of the sensor (shown with dots). This diagram shows the response\nof only the even symmetric sensors.\nAs it turns out, this relation even holds for the features computed by deeper layers of net-\nworks trained on image classification tasks, as demonstrated in, for example, Kuzovkin et\nal.(2018). Suffice it to say, convolutions have proven to be an incredibly powerful tool for\ncomputer vision, both in biology and in code. As such, it is not surprising (in hindsight)\nthat they heralded the recent success in deep learning.\n7.2.7Summary\nThe core computation required for a convolutional layer is a cross-correlation operation.\nWe saw that a simple nested for-loop is all that is required to compute its value. If we\nhave multiple input and multiple output channels, we are performing a matrix\u2013matrix op-\neration between channels. As can be seen, the computation is straightforward and, most\nimportantly, highly local. This affords significant hardware optimization and many recent\nresults in computer vision are only possible because of that. After all, it means that chip\ndesigners can invest in fast computation rather than memory when it comes to optimizing\nfor convolutions. While this may not lead to optimal designs for other applications, it does\nopen the door to ubiquitous and affordable computer vision.\n247 Padding and Stride\n120In terms of convolutions themselves, they can be used for many purposes, for example\ndetecting edges and lines, blurring images, or sharpening them.", "mimetype": "text/plain", "start_char_idx": 603488, "end_char_idx": 607661, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "298adf03-6580-46c5-b487-d672be177bb5": {"__data__": {"id_": "298adf03-6580-46c5-b487-d672be177bb5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "36ac5c8c-8e14-4cae-bf86-710a0218d847", "node_type": "1", "metadata": {}, "hash": "571b638ee3ed3dd9525722624762b7708cb7ea8807852c3f5e556666c3c43854", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9ce42bbf-0e9b-4e4c-a33a-fd041051140c", "node_type": "1", "metadata": {}, "hash": "406befe55788e30ded0df94dc48e3d9672a8684a58610d400917e59320648909", "class_name": "RelatedNodeInfo"}}, "text": "We saw that a simple nested for-loop is all that is required to compute its value. If we\nhave multiple input and multiple output channels, we are performing a matrix\u2013matrix op-\neration between channels. As can be seen, the computation is straightforward and, most\nimportantly, highly local. This affords significant hardware optimization and many recent\nresults in computer vision are only possible because of that. After all, it means that chip\ndesigners can invest in fast computation rather than memory when it comes to optimizing\nfor convolutions. While this may not lead to optimal designs for other applications, it does\nopen the door to ubiquitous and affordable computer vision.\n247 Padding and Stride\n120In terms of convolutions themselves, they can be used for many purposes, for example\ndetecting edges and lines, blurring images, or sharpening them. Most importantly, it is\nnot necessary that the statistician (or engineer) invents suitable filters. Instead, we can\nsimplylearnthem from data. This replaces feature engineering heuristics by evidence-\nbased statistics. Lastly, and quite delightfully, these filters are not just advantageous for\nbuilding deep networks but they also correspond to receptive fields and feature maps in the\nbrain. This gives us confidence that we are on the right track.\n7.2.8Exercises\n1.Construct an image Xwith diagonal edges.\n1.What happens if you apply the kernel Kin this section to it?\n2.What happens if you transpose X?\n3.What happens if you transpose K?\n2.Design some kernels manually.\n1.Given a directional vector v=\u00b9\ud835\udc631,\ud835\udc632\u00ba, derive an edge-detection kernel that detects\nedges orthogonal to v, i.e., edges in the direction \u00b9\ud835\udc632,\u0000\ud835\udc631\u00ba.\n2.Derive a finite difference operator for the second derivative. What is the minimum\nsize of the convolutional kernel associated with it? Which structures in images re-\nspond most strongly to it?\n3.How would you design a blur kernel? Why might you want to use such a kernel?\n4.What is the minimum size of a kernel to obtain a derivative of order \ud835\udc51?\n3.When you try to automatically find the gradient for the Conv2Dclass we created, what\nkind of error message do you see?\n4.Howdoyourepresentacross-correlationoperationasamatrixmultiplicationbychang-\ning the input and kernel tensors?\nDiscussions120.\n7.3Paddingand Stride\nRecall the example of a convolution in Fig. 7.2.1 . The input had both a height and width of\n3and the convolutionkernel hadboth a height and width of2, yielding anoutput represen-\ntation with dimension 2\u00022. Assuming that the input shape is \ud835\udc5bh\u0002\ud835\udc5bwand the convolution\nkernel shape is \ud835\udc58h\u0002\ud835\udc58w, the output shape will be \u00b9\ud835\udc5bh\u0000\ud835\udc58h\u00b81\u00ba\u0002\u00b9\ud835\udc5bw\u0000\ud835\udc58w\u00b81\u00ba: we can\nonly shift the convolution kernel so far until it runs out of pixels to apply the convolution\nto.\n248 Convolutional Neural Networks\nIn the following we will explore a number of techniques, including padding and strided\nconvolutions, that offer more control over the size of the output. As motivation, note that\nsincekernelsgenerallyhavewidthandheightgreaterthan 1,afterapplyingmanysuccessive\nconvolutions, wetendtowindupwithoutputsthatareconsiderablysmallerthanourinput.\nIf we start with a 240\u0002240pixel image, ten layers of 5\u00025convolutions reduce the image\nto200\u0002200pixels, slicing off 30%of the image and with it obliterating any interesting\ninformation on the boundaries of the original image. Padding is the most popular tool for\nhandling this issue. In other cases, we may want to reduce the dimensionality drastically,\ne.g., if we find the original input resolution to be unwieldy. Strided convolutions are a\npopular technique that can help in these instances.\nimport torch\nfrom torch import nn\n7.3.1Padding\nAs described above, one tricky issue when applying convolutional layers is that we tend\nto lose pixels on the perimeter of our image. Consider Fig. 7.3.1 that depicts the pixel\nutilization as a function of the convolution kernel size and the position within the image.\nThe pixels in the corners are hardly used at all.\ntFig. 7.3.1 Pixel utilization for convolutions of size 1 \u00021, 2\u00022, and 3\u00023 respectively.", "mimetype": "text/plain", "start_char_idx": 606800, "end_char_idx": 610862, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9ce42bbf-0e9b-4e4c-a33a-fd041051140c": {"__data__": {"id_": "9ce42bbf-0e9b-4e4c-a33a-fd041051140c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "298adf03-6580-46c5-b487-d672be177bb5", "node_type": "1", "metadata": {}, "hash": "a2e388b74e1c019e44955947135aaf95384de142fbd82647ba6c841a3af30d9e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "24f0f93c-6afd-4467-ae71-e58cae9526f2", "node_type": "1", "metadata": {}, "hash": "3e5fdfce02df5d125e984ff6722eefd09def783bb8ac91959453c83239b7f8f4", "class_name": "RelatedNodeInfo"}}, "text": "Padding is the most popular tool for\nhandling this issue. In other cases, we may want to reduce the dimensionality drastically,\ne.g., if we find the original input resolution to be unwieldy. Strided convolutions are a\npopular technique that can help in these instances.\nimport torch\nfrom torch import nn\n7.3.1Padding\nAs described above, one tricky issue when applying convolutional layers is that we tend\nto lose pixels on the perimeter of our image. Consider Fig. 7.3.1 that depicts the pixel\nutilization as a function of the convolution kernel size and the position within the image.\nThe pixels in the corners are hardly used at all.\ntFig. 7.3.1 Pixel utilization for convolutions of size 1 \u00021, 2\u00022, and 3\u00023 respectively.\nSince we typically use small kernels, for any given convolution we might only lose a few\npixels but this can add up as we apply many successive convolutional layers. One straight-\nforward solution to this problem is to add extra pixels of filler around the boundary of our\ninput image, thus increasing the effective size of the image. Typically, we set the values of\nthe extra pixels to zero. In Fig. 7.3.2 , we pad a 3\u00023input, increasing its size to 5\u00025. The\ncorrespondingoutputthenincreasestoa 4\u00024matrix. Theshadedportionsarethefirstout-\nputelementaswellastheinputandkerneltensorelementsusedfortheoutputcomputation:\n0\u00020\u00b80\u00021\u00b80\u00022\u00b80\u00023=0.\ntFig. 7.3.2 Two-dimensional cross-correlation with padding.\n249 Padding and Stride\nIn general, if we add a total of \ud835\udc5dhrows of padding (roughly half on top and half on bottom)\nand a total of \ud835\udc5dwcolumns of padding (roughly half on the left and half on the right), the\noutput shape will be\n\u00b9\ud835\udc5bh\u0000\ud835\udc58h\u00b8\ud835\udc5dh\u00b81\u00ba\u0002\u00b9\ud835\udc5bw\u0000\ud835\udc58w\u00b8\ud835\udc5dw\u00b81\u00ba. (7.3.1)\nThis means that the height and width of the output will increase by \ud835\udc5dhand\ud835\udc5dw, respec-\ntively.\nIn many cases, we will want to set \ud835\udc5dh=\ud835\udc58h\u00001and\ud835\udc5dw=\ud835\udc58w\u00001to give the input and\noutput the same height and width. This will make it easier to predict the output shape of\neach layer when constructing the network. Assuming that \ud835\udc58his odd here, we will pad \ud835\udc5dh\u009d2\nrows on both sides of the height. If \ud835\udc58his even, one possibility is to pad d\ud835\udc5dh\u009d2erows on the\ntop of the input and b\ud835\udc5dh\u009d2crows on the bottom. We will pad both sides of the width in the\nsame way.\nCNNs commonly use convolution kernels with odd height and width values, such as 1, 3,\n5, or 7. Choosing odd kernel sizes has the benefit that we can preserve the dimensionality\nwhile padding with the same number of rows on top and bottom, and the same number of\ncolumns on left and right.\nMoreover, this practice of using odd kernels and padding to precisely preserve dimension-\nality offers a clerical benefit. For any two-dimensional tensor X, when the kernel\u2019s size is\nodd and the number of padding rows and columns on all sides are the same, thereby pro-\nducinganoutputwiththesameheightandwidthastheinput,weknowthattheoutput Y[i,\nj]is calculated by cross-correlation of the input and convolution kernel with the window\ncentered on X[i, j] .\nIn the following example, we create a two-dimensional convolutional layer with a height\nand width of 3 and apply 1 pixel of padding on all sides. Given an input with a height and\nwidth of 8, we find that the height and width of the output is also 8.\n# We define a helper function to calculate convolutions.", "mimetype": "text/plain", "start_char_idx": 610139, "end_char_idx": 613409, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "24f0f93c-6afd-4467-ae71-e58cae9526f2": {"__data__": {"id_": "24f0f93c-6afd-4467-ae71-e58cae9526f2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9ce42bbf-0e9b-4e4c-a33a-fd041051140c", "node_type": "1", "metadata": {}, "hash": "406befe55788e30ded0df94dc48e3d9672a8684a58610d400917e59320648909", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7dbd256a-c916-4366-8227-abb1b7f2da4d", "node_type": "1", "metadata": {}, "hash": "ec4c1b1df59d17c8e630ea361bc5b760872f4a1d069b6709e3cf3b8c316bd987", "class_name": "RelatedNodeInfo"}}, "text": "Moreover, this practice of using odd kernels and padding to precisely preserve dimension-\nality offers a clerical benefit. For any two-dimensional tensor X, when the kernel\u2019s size is\nodd and the number of padding rows and columns on all sides are the same, thereby pro-\nducinganoutputwiththesameheightandwidthastheinput,weknowthattheoutput Y[i,\nj]is calculated by cross-correlation of the input and convolution kernel with the window\ncentered on X[i, j] .\nIn the following example, we create a two-dimensional convolutional layer with a height\nand width of 3 and apply 1 pixel of padding on all sides. Given an input with a height and\nwidth of 8, we find that the height and width of the output is also 8.\n# We define a helper function to calculate convolutions. It initializes the\n# convolutional layer weights and performs corresponding dimensionality\n# elevations and reductions on the input and output\ndef comp_conv2d (conv2d, X):\n# (1, 1) indicates that batch size and the number of channels are both 1\nX=X.reshape(( 1,1)+X.shape)\nY=conv2d(X)\n# Strip the first two dimensions: examples and channels\nreturn Y.reshape(Y .shape[ 2:])\n# 1 row and column is padded on either side, so a total of 2 rows or columns\n# are added\nconv2d =nn.LazyConv2d( 1, kernel_size =3, padding =1)\nX=torch .rand(size =(8,8))\ncomp_conv2d(conv2d, X) .shape\ntorch .Size([ 8,8])\n250 Convolutional Neural Networks\nWhen the height and width of the convolution kernel are different, we can make the output\nand input have the same height and width by setting different padding numbers for height\nand width.\n# We use a convolution kernel with height 5 and width 3. The padding on either\n# side of the height and width are 2 and 1, respectively\nconv2d =nn.LazyConv2d( 1, kernel_size =(5,3), padding =(2,1))\ncomp_conv2d(conv2d, X) .shape\ntorch .Size([ 8,8])\n7.3.2Stride\nWhen computing the cross-correlation, we start with the convolution window at the upper-\nleft corner of the input tensor, and then slide it over all locations both down and to the\nright. In the previous examples, we defaulted to sliding one element at a time. However,\nsometimes, either for computational efficiency or because we wish to downsample, we\nmove our window more than one element at a time, skipping the intermediate locations.\nThis is particularly useful if the convolution kernel is large since it captures a large area of\nthe underlying image.\nWe refer to the number of rows and columns traversed per slide as stride. So far, we have\nusedstridesof1,bothforheightandwidth. Sometimes,wemaywanttousealargerstride.\nFig. 7.3.3 shows a two-dimensional cross-correlation operation with a stride of 3 vertically\nand 2 horizontally. The shaded portions are the output elements as well as the input and\nkernel tensor elements used for the output computation: 0\u00020\u00b80\u00021\u00b81\u00022\u00b82\u00023=8,\n0\u00020\u00b86\u00021\u00b80\u00022\u00b80\u00023=6. Wecanseethatwhenthesecondelementofthefirstcolumnis\ngenerated,theconvolutionwindowslidesdownthreerows. Theconvolutionwindowslides\ntwo columns to the right when the second element of the first row is generated. When the\nconvolution window continues to slide two columns to the right on the input, there is no\noutput because the input element cannot fill the window (unless we add another column of\npadding).\ntFig. 7.3.3 Cross-correlation with strides of 3 and 2 for height and width, respectively.\nIn general, when the stride for the height is \ud835\udc60hand the stride for the width is \ud835\udc60w, the output\nshape is\nb\u00b9\ud835\udc5bh\u0000\ud835\udc58h\u00b8\ud835\udc5dh\u00b8\ud835\udc60h\u00ba\u009d\ud835\udc60hc\u0002b\u00b9\ud835\udc5bw\u0000\ud835\udc58w\u00b8\ud835\udc5dw\u00b8\ud835\udc60w\u00ba\u009d\ud835\udc60wc.", "mimetype": "text/plain", "start_char_idx": 612647, "end_char_idx": 616126, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7dbd256a-c916-4366-8227-abb1b7f2da4d": {"__data__": {"id_": "7dbd256a-c916-4366-8227-abb1b7f2da4d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "24f0f93c-6afd-4467-ae71-e58cae9526f2", "node_type": "1", "metadata": {}, "hash": "3e5fdfce02df5d125e984ff6722eefd09def783bb8ac91959453c83239b7f8f4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d426c44b-034c-4d79-9af0-23847b9b11bd", "node_type": "1", "metadata": {}, "hash": "11f47b336644f81d70f05f5aaca318558794bac5a6109de5cafcb8ba9f331413", "class_name": "RelatedNodeInfo"}}, "text": "Theconvolutionwindowslides\ntwo columns to the right when the second element of the first row is generated. When the\nconvolution window continues to slide two columns to the right on the input, there is no\noutput because the input element cannot fill the window (unless we add another column of\npadding).\ntFig. 7.3.3 Cross-correlation with strides of 3 and 2 for height and width, respectively.\nIn general, when the stride for the height is \ud835\udc60hand the stride for the width is \ud835\udc60w, the output\nshape is\nb\u00b9\ud835\udc5bh\u0000\ud835\udc58h\u00b8\ud835\udc5dh\u00b8\ud835\udc60h\u00ba\u009d\ud835\udc60hc\u0002b\u00b9\ud835\udc5bw\u0000\ud835\udc58w\u00b8\ud835\udc5dw\u00b8\ud835\udc60w\u00ba\u009d\ud835\udc60wc. (7.3.2)\nIf we set\ud835\udc5dh=\ud835\udc58h\u00001and\ud835\udc5dw=\ud835\udc58w\u00001, then the output shape can be simplified to b\u00b9\ud835\udc5bh\u00b8\n251 Padding and Stride\n\ud835\udc60h\u00001\u00ba\u009d\ud835\udc60hc\u0002b\u00b9\ud835\udc5bw\u00b8\ud835\udc60w\u00001\u00ba\u009d\ud835\udc60wc. Going a step further, if the input height and width are\ndivisible by the strides on the height and width, then the output shape will be \u00b9\ud835\udc5bh\u009d\ud835\udc60h\u00ba\u0002\n\u00b9\ud835\udc5bw\u009d\ud835\udc60w\u00ba.\nBelow, we set the strides on both the height and width to 2, thus halving the input height\nand width.\nconv2d =nn.LazyConv2d( 1, kernel_size =3, padding =1, stride =2)\ncomp_conv2d(conv2d, X) .shape\ntorch .Size([ 4,4])\nLet\u2019s look at a slightly more complicated example.\nconv2d =nn.LazyConv2d( 1, kernel_size =(3,5), padding =(0,1), stride =(3,4))\ncomp_conv2d(conv2d, X) .shape\ntorch .Size([ 2,2])\n7.3.3Summaryand Discussion\nPadding can increase the height and width of the output. This is often used to give the\noutput the same height and width as the input to avoid undesirable shrinkage of the output.\nMoreover,itensuresthatallpixelsareusedequallyfrequently. Typicallywepicksymmetric\npadding on both sides of the input height and width. In this case we refer to \u00b9\ud835\udc5dh,\ud835\udc5dw\u00ba\npadding. Most commonly we set \ud835\udc5dh=\ud835\udc5dw, in which case we simply state that we choose\npadding\ud835\udc5d.\nA similar convention applies to strides. When horizontal stride \ud835\udc60hand vertical stride \ud835\udc60w\nmatch, we simply talk about stride \ud835\udc60. The stride can reduce the resolution of the output, for\nexample reducing the height and width of the output to only 1\u009d\ud835\udc5bof the height and width of\nthe input for \ud835\udc5b> 1. By default, the padding is 0 and the stride is 1.\nSo far all padding that we discussed simply extended images with zeros. This has signif-\nicant computational benefit since it is trivial to accomplish. Moreover, operators can be\nengineered to take advantage of this padding implicitly without the need to allocate addi-\ntional memory. At the same time, it allows CNNs to encode implicit position information\nwithinanimage,simplybylearningwherethe\u201cwhitespace\u201dis. Therearemanyalternatives\nto zero-padding. Alsallakh et al.(2020) provided an extensive overview of those (albeit\nwithout a clear case for when to use nonzero paddings unless artifacts occur).\n7.3.4Exercises\n1.Given the final code example in this section with kernel size \u00b93,5\u00ba, padding\u00b90,1\u00ba, and\nstride\u00b93,4\u00ba, calculate the output shape to check if it is consistent with the experimental\nresult.\n252 Convolutional Neural Networks\n1212.For audio signals, what does a stride of 2 correspond to?\n3.Implement mirror padding, i.e., padding where the border values are simply mirrored\nto extend tensors.\n4.What are the computational benefits of a stride larger than 1?\n5.What might be statistical benefits of a stride larger than 1?\n6.Howwouldyouimplementastrideof1\n2? Whatdoesitcorrespondto? Whenwouldthis\nbe useful?\nDiscussions121.", "mimetype": "text/plain", "start_char_idx": 615590, "end_char_idx": 618858, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d426c44b-034c-4d79-9af0-23847b9b11bd": {"__data__": {"id_": "d426c44b-034c-4d79-9af0-23847b9b11bd", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7dbd256a-c916-4366-8227-abb1b7f2da4d", "node_type": "1", "metadata": {}, "hash": "ec4c1b1df59d17c8e630ea361bc5b760872f4a1d069b6709e3cf3b8c316bd987", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3cf444a2-9039-4b72-86ec-ed55fa6f1676", "node_type": "1", "metadata": {}, "hash": "ef059c2f449b71606e842e48b9d268274d4d1f1fef0dd3446b91281a40c98931", "class_name": "RelatedNodeInfo"}}, "text": "Alsallakh et al.(2020) provided an extensive overview of those (albeit\nwithout a clear case for when to use nonzero paddings unless artifacts occur).\n7.3.4Exercises\n1.Given the final code example in this section with kernel size \u00b93,5\u00ba, padding\u00b90,1\u00ba, and\nstride\u00b93,4\u00ba, calculate the output shape to check if it is consistent with the experimental\nresult.\n252 Convolutional Neural Networks\n1212.For audio signals, what does a stride of 2 correspond to?\n3.Implement mirror padding, i.e., padding where the border values are simply mirrored\nto extend tensors.\n4.What are the computational benefits of a stride larger than 1?\n5.What might be statistical benefits of a stride larger than 1?\n6.Howwouldyouimplementastrideof1\n2? Whatdoesitcorrespondto? Whenwouldthis\nbe useful?\nDiscussions121.\n7.4MultipleInputand Multiple Output Channels\nWhile we described the multiple channels that comprise each image (e.g., color images\nhave the standard RGB channels to indicate the amount of red, green and blue) and con-\nvolutional layers for multiple channels in Section 7.1.4 , until now, we simplified all of our\nnumerical examples by working with just a single input and a single output channel. This\nallowedustothinkofourinputs,convolutionkernels,andoutputseachastwo-dimensional\ntensors.\nWhen we add channels into the mix, our inputs and hidden representations both become\nthree-dimensional tensors. For example, each RGB input image has shape 3\u0002\u210e\u0002\ud835\udc64. We\nrefer to this axis, with a size of 3, as the channel dimension. The notion of channels is\nas old as CNNs themselves: for instance LeNet-5 ( LeCunet al., 1995) uses them. In this\nsection, we will take a deeper look at convolution kernels with multiple input and multiple\noutput channels.\nimport torch\nfrom d2l import torch asd2l\n7.4.1Multiple InputChannels\nWhen the input data contains multiple channels, we need to construct a convolution kernel\nwith the same number of input channels as the input data, so that it can perform cross-\ncorrelation with the input data. Assuming that the number of channels for the input data\nis\ud835\udc50i, the number of input channels of the convolution kernel also needs to be \ud835\udc50i. If our\nconvolution kernel\u2019s window shape is \ud835\udc58h\u0002\ud835\udc58w, then, when \ud835\udc50i=1, we can think of our\nconvolution kernel as just a two-dimensional tensor of shape \ud835\udc58h\u0002\ud835\udc58w.\nHowever, when \ud835\udc50i>1, we need a kernel that contains a tensor of shape \ud835\udc58h\u0002\ud835\udc58wforev-\neryinput channel. Concatenating these \ud835\udc50itensors together yields a convolution kernel of\nshape\ud835\udc50i\u0002\ud835\udc58h\u0002\ud835\udc58w. Since the input and convolution kernel each have \ud835\udc50ichannels, we can\n253 Multiple Input and Multiple Output Channels\nperform a cross-correlation operation on the two-dimensional tensor of the input and the\ntwo-dimensional tensor of the convolution kernel for each channel, adding the \ud835\udc50iresults\ntogether (summing over the channels) to yield a two-dimensional tensor. This is the result\nof a two-dimensional cross-correlation between a multi-channel input and a multi-input-\nchannel convolution kernel.\nFig.7.4.1 providesanexampleofatwo-dimensionalcross-correlationwithtwoinputchan-\nnels. The shaded portions are the first output element as well as the input and kernel tensor\nelements used for the output computation: \u00b91\u00021\u00b82\u00022\u00b84\u00023\u00b85\u00024\u00ba\u00b8\u00b9 0\u00020\u00b81\u00021\u00b8\n3\u00022\u00b84\u00023\u00ba=56.\ntFig. 7.4.1 Cross-correlation computation with two input channels.\nTomakesurewereallyunderstandwhatisgoingonhere,wecanimplementcross-correlation\noperations with multiple input channels ourselves. Notice that all we are doing is perform-\ning a cross-correlation operation per channel and then adding up the results.\ndef corr2d_multi_in (X, K):\n# Iterate through the 0th dimension (channel) of K first, then add them up\nreturn sum(d2l .corr2d(x, k) for x, k inzip(X, K))\nWe can construct the input tensor Xand the kernel tensor Kcorresponding to the values in\nFig. 7.4.1 to validate the output of the cross-correlation operation.", "mimetype": "text/plain", "start_char_idx": 618074, "end_char_idx": 621945, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3cf444a2-9039-4b72-86ec-ed55fa6f1676": {"__data__": {"id_": "3cf444a2-9039-4b72-86ec-ed55fa6f1676", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d426c44b-034c-4d79-9af0-23847b9b11bd", "node_type": "1", "metadata": {}, "hash": "11f47b336644f81d70f05f5aaca318558794bac5a6109de5cafcb8ba9f331413", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fd714e9f-2a9d-475f-b06a-005be7fcb008", "node_type": "1", "metadata": {}, "hash": "92766ff857df48928faa8c2638702cd3ad5a3f851e3ad653b8cbbaed0abab034", "class_name": "RelatedNodeInfo"}}, "text": "tFig. 7.4.1 Cross-correlation computation with two input channels.\nTomakesurewereallyunderstandwhatisgoingonhere,wecanimplementcross-correlation\noperations with multiple input channels ourselves. Notice that all we are doing is perform-\ning a cross-correlation operation per channel and then adding up the results.\ndef corr2d_multi_in (X, K):\n# Iterate through the 0th dimension (channel) of K first, then add them up\nreturn sum(d2l .corr2d(x, k) for x, k inzip(X, K))\nWe can construct the input tensor Xand the kernel tensor Kcorresponding to the values in\nFig. 7.4.1 to validate the output of the cross-correlation operation.\nX=torch .tensor([[[ 0.0,1.0,2.0], [ 3.0,4.0,5.0], [ 6.0,7.0,8.0]],\n[[1.0,2.0,3.0], [ 4.0,5.0,6.0], [ 7.0,8.0,9.0]]])\nK=torch .tensor([[[ 0.0,1.0], [ 2.0,3.0]], [[ 1.0,2.0], [ 3.0,4.0]]])\ncorr2d_multi_in(X, K)\ntensor([[ 56.,72.],\n[104. ,120. ]])\n7.4.2MultipleOutput Channels\nRegardless of the number of input channels, so far we always ended up with one output\nchannel. However, as we discussed in Section 7.1.4 , it turns out to be essential to have\nmultiple channels at each layer. In the most popular neural network architectures, we actu-\nallyincreasethechanneldimensionaswegodeeperintheneuralnetwork, typicallydown-\nsampling to trade off spatial resolution for greater channel depth . Intuitively, you could\n254 Convolutional Neural Networks\nthink of each channel as responding to a different set of features. The reality is a bit more\ncomplicatedthanthis. Anaiveinterpretationwouldsuggestthatrepresentationsarelearned\nindependentlyperpixelorperchannel. Instead,channelsareoptimizedtobejointlyuseful.\nThis means that rather than mapping a single channel to an edge detector, it may simply\nmean that some direction in channel space corresponds to detecting edges.\nDenoteby\ud835\udc50iand\ud835\udc50othenumberofinputandoutputchannels,respectively,andby \ud835\udc58hand\ud835\udc58w\nthe height and width of the kernel. To get an output with multiple channels, we can create\na kernel tensor of shape \ud835\udc50i\u0002\ud835\udc58h\u0002\ud835\udc58wforeveryoutput channel. We concatenate them on the\noutput channel dimension, so that the shape of the convolution kernel is \ud835\udc50o\u0002\ud835\udc50i\u0002\ud835\udc58h\u0002\ud835\udc58w.\nIn cross-correlation operations, the result on each output channel is calculated from the\nconvolution kernel corresponding to that output channel and takes input from all channels\nin the input tensor.\nWe implement a cross-correlation function to calculate the output of multiple channels as\nshown below.\ndef corr2d_multi_in_out (X, K):\n# Iterate through the 0th dimension of K, and each time, perform\n# cross-correlation operations with input X. All of the results are\n# stacked together\nreturn torch .stack([corr2d_multi_in(X, k) for kinK], 0)\nWe construct a trivial convolution kernel with three output channels by concatenating the\nkernel tensor for Kwith K+1andK+2.\nK=torch .stack((K, K +1, K +2),0)\nK.shape\ntorch .Size([ 3,2,2,2])\nBelow,weperformcross-correlationoperationsontheinputtensor Xwiththekerneltensor\nK. Now the output contains three channels. The result of the first channel is consistent with\nthe result of the previous input tensor Xand the multi-input channel, single-output channel\nkernel.\ncorr2d_multi_in_out(X, K)\ntensor([[[ 56.,72.],\n[104. ,120. ]],\n[[76.,100. ],\n[148. ,172. ]],\n[[96.,128. ],\n[192. ,224. ]]])\n255 Multiple Input and Multiple Output Channels\n7.4.3 1\u00021ConvolutionalLayer\nAt first, a 1\u00021convolution, i.e., \ud835\udc58h=\ud835\udc58w=1, does not seem to make much sense.\nAfter all, a convolution correlates adjacent pixels.", "mimetype": "text/plain", "start_char_idx": 621318, "end_char_idx": 624789, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fd714e9f-2a9d-475f-b06a-005be7fcb008": {"__data__": {"id_": "fd714e9f-2a9d-475f-b06a-005be7fcb008", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3cf444a2-9039-4b72-86ec-ed55fa6f1676", "node_type": "1", "metadata": {}, "hash": "ef059c2f449b71606e842e48b9d268274d4d1f1fef0dd3446b91281a40c98931", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4a82dddf-fb11-4bd6-b022-781d59ab7ef7", "node_type": "1", "metadata": {}, "hash": "5407c2edd467d8cea2c7bd718417f49a3b92057d8ebbc35caf1bfe985acb0f53", "class_name": "RelatedNodeInfo"}}, "text": "The result of the first channel is consistent with\nthe result of the previous input tensor Xand the multi-input channel, single-output channel\nkernel.\ncorr2d_multi_in_out(X, K)\ntensor([[[ 56.,72.],\n[104. ,120. ]],\n[[76.,100. ],\n[148. ,172. ]],\n[[96.,128. ],\n[192. ,224. ]]])\n255 Multiple Input and Multiple Output Channels\n7.4.3 1\u00021ConvolutionalLayer\nAt first, a 1\u00021convolution, i.e., \ud835\udc58h=\ud835\udc58w=1, does not seem to make much sense.\nAfter all, a convolution correlates adjacent pixels. A 1\u00021convolution obviously does\nnot. Nonetheless, they are popular operations that are sometimes included in the designs\nof complex deep networks ( Linetal., 2013,Szegedyetal., 2017). Let\u2019s see in some detail\nwhat it actually does.\nBecausetheminimumwindowisused, the 1\u00021convolutionlosestheabilityoflargercon-\nvolutional layers to recognize patterns consisting of interactions among adjacent elements\nin the height and width dimensions. The only computation of the 1\u00021convolution occurs\non the channel dimension.\nFig.7.4.2 showsthecross-correlationcomputationusingthe 1\u00021convolutionkernelwith3\ninputchannelsand2outputchannels. Notethattheinputsandoutputshavethesameheight\nand width. Each element in the output is derived from a linear combination of elements at\nthe same position in the input image. You could think of the 1\u00021convolutional layer as\nconstituting a fully connected layer applied at every single pixel location to transform the\n\ud835\udc50icorresponding input values into \ud835\udc50ooutput values. Because this is still a convolutional\nlayer, the weights are tied across pixel location. Thus the 1\u00021convolutional layer requires\n\ud835\udc50o\u0002\ud835\udc50iweights (plus the bias). Also note that convolutional layers are typically followed\nby nonlinearities. This ensures that 1\u00021convolutions cannot simply be folded into other\nconvolutions.\ntFig. 7.4.2 The cross-correlation computation uses the 1 \u00021 convolution kernel with three input\nchannels and two output channels. The input and output have the same height and width.\nLet\u2019s check whether this works in practice: we implement a 1\u00021convolution using a fully\nconnectedlayer. Theonlythingisthatweneedtomakesomeadjustmentstothedatashape\nbefore and after the matrix multiplication.\ndef corr2d_multi_in_out_1x1 (X, K):\nc_i, h, w =X.shape\nc_o =K.shape[ 0]\nX=X.reshape((c_i, h *w))\nK=K.reshape((c_o, c_i))\n# Matrix multiplication in the fully connected layer\nY=torch .matmul(K, X)\nreturn Y.reshape((c_o, h, w))\nWhenperforming 1\u00021convolutions,theabovefunctionisequivalenttothepreviouslyim-\nplemented cross-correlation function corr2d_multi_in_out . Let\u2019s check this with some\nsample data.\n256 Convolutional Neural Networks\nX=torch .normal( 0,1, (3,3,3))\nK=torch .normal( 0,1, (2,3,1,1))\nY1=corr2d_multi_in_out_1x1(X, K)\nY2=corr2d_multi_in_out(X, K)\nassert float (torch .abs(Y1 -Y2).sum()) <1e-6\n7.4.4Discussion\nChannels allow us to combine the best of both worlds: MLPs that allow for significant\nnonlinearities and convolutions that allow for localized analysis of features. In particular,\nchannels allow the CNN to reason with multiple features, such as edge and shape detec-\ntors at the same time. They also offer a practical trade-off between the drastic parameter\nreduction arising from translation invariance and locality, and the need for expressive and\ndiverse models in computer vision.\nNote, though, that thisflexibilitycomes ata price. Givenanimageofsize \u00b9\u210e\u0002\ud835\udc64\u00ba, thecost\nfor computing a \ud835\udc58\u0002\ud835\udc58convolution isO\u00b9\u210e\u0001\ud835\udc64\u0001\ud835\udc582\u00ba. For\ud835\udc50iand\ud835\udc50oinput and output channels\nrespectively this increases to O\u00b9\u210e\u0001\ud835\udc64\u0001\ud835\udc582\u0001\ud835\udc50i\u0001\ud835\udc50o\u00ba.", "mimetype": "text/plain", "start_char_idx": 624309, "end_char_idx": 627816, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4a82dddf-fb11-4bd6-b022-781d59ab7ef7": {"__data__": {"id_": "4a82dddf-fb11-4bd6-b022-781d59ab7ef7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fd714e9f-2a9d-475f-b06a-005be7fcb008", "node_type": "1", "metadata": {}, "hash": "92766ff857df48928faa8c2638702cd3ad5a3f851e3ad653b8cbbaed0abab034", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "182ef506-6e97-4f72-8044-68eb2b2e2f7c", "node_type": "1", "metadata": {}, "hash": "f66f5c73139eef1a12ada1aa1965a123bda10c56987d497490e7202a546c4856", "class_name": "RelatedNodeInfo"}}, "text": "In particular,\nchannels allow the CNN to reason with multiple features, such as edge and shape detec-\ntors at the same time. They also offer a practical trade-off between the drastic parameter\nreduction arising from translation invariance and locality, and the need for expressive and\ndiverse models in computer vision.\nNote, though, that thisflexibilitycomes ata price. Givenanimageofsize \u00b9\u210e\u0002\ud835\udc64\u00ba, thecost\nfor computing a \ud835\udc58\u0002\ud835\udc58convolution isO\u00b9\u210e\u0001\ud835\udc64\u0001\ud835\udc582\u00ba. For\ud835\udc50iand\ud835\udc50oinput and output channels\nrespectively this increases to O\u00b9\u210e\u0001\ud835\udc64\u0001\ud835\udc582\u0001\ud835\udc50i\u0001\ud835\udc50o\u00ba. For a 256\u0002256pixel image with a\n5\u00025kernel and 128input and output channels respectively this amounts to over 53 billion\noperations (we count multiplications and additions separately). Later on we will encounter\neffective strategies to cut down on the cost, e.g., by requiring the channel-wise operations\nto be block-diagonal, leading to architectures such as ResNeXt ( Xieetal., 2017).\n7.4.5Exercises\n1.Assume that we have two convolution kernels of size \ud835\udc581and\ud835\udc582, respectively (with no\nnonlinearity in between).\n1.Prove that the result of the operation can be expressed by a single convolution.\n2.What is the dimensionality of the equivalent single convolution?\n3.Is the converse true, i.e., can you always decompose a convolution into two smaller\nones?\n2.Assumeaninputofshape \ud835\udc50i\u0002\u210e\u0002\ud835\udc64andaconvolutionkernelofshape \ud835\udc50o\u0002\ud835\udc50i\u0002\ud835\udc58h\u0002\ud835\udc58w,\npadding of\u00b9\ud835\udc5dh,\ud835\udc5dw\u00ba, and stride of\u00b9\ud835\udc60h,\ud835\udc60w\u00ba.\n1.What is the computational cost (multiplications and additions) for the forward prop-\nagation?\n2.What is the memory footprint?\n3.What is the memory footprint for the backward computation?\n4.What is the computational cost for the backpropagation?\n3.By what factor does the number of calculations increase if we double both the number\nof input channels \ud835\udc50iand the number of output channels \ud835\udc50o? What happens if we double\nthe padding?\n257 Pooling\n1224.Are the variables Y1andY2in the final example of this section exactly the same? Why?\n5.Express convolutions as a matrix multiplication, even when the convolution window is\nnot1\u00021.\n6.Your task is to implement fast convolutions with a \ud835\udc58\u0002\ud835\udc58kernel. One of the algorithm\ncandidates is to scan horizontally across the source, reading a \ud835\udc58-wide strip and comput-\ning the 1-wide output strip one value at a time. The alternative is to read a \ud835\udc58\u00b8\u0394wide\nstrip and compute a \u0394-wide output strip. Why is the latter preferable? Is there a limit to\nhow large you should choose \u0394?\n7.Assume that we have a \ud835\udc50\u0002\ud835\udc50matrix.\n1.Howmuchfasterisittomultiplywithablock-diagonalmatrixifthematrixisbroken\nup into\ud835\udc4fblocks?\n2.What is the downside of having \ud835\udc4fblocks? How could you fix it, at least partly?\nDiscussions122.\n7.5Pooling\nIn many cases our ultimate task asks some global question about the image, e.g., does it\ncontain a cat? Consequently, the units of our final layer should be sensitive to the entire\ninput. By gradually aggregating information, yielding coarser and coarser maps, we ac-\ncomplish this goal of ultimately learning a global representation, while keeping all of the\nadvantages of convolutional layers at the intermediate layers of processing. The deeper\nwe go in the network, the larger the receptive field (relative to the input) to which each\nhidden node is sensitive. Reducing spatial resolution accelerates this process, since the\nconvolution kernels cover a larger effective area.\nMoreover, when detecting lower-level features, such as edges (as discussed in Section 7.2 ),\nwe often want our representations to be somewhat invariant to translation. For instance,\nif we take the image Xwith a sharp delineation between black and white and shift the\nwhole image by one pixel to the right, i.e., Z[i, j] = X[i, j + 1] , then the output\nfor the new image Zmight be vastly different. The edge will have shifted by one pixel. In\nreality, objects hardly ever occur exactly at the same place.", "mimetype": "text/plain", "start_char_idx": 627284, "end_char_idx": 631109, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "182ef506-6e97-4f72-8044-68eb2b2e2f7c": {"__data__": {"id_": "182ef506-6e97-4f72-8044-68eb2b2e2f7c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4a82dddf-fb11-4bd6-b022-781d59ab7ef7", "node_type": "1", "metadata": {}, "hash": "5407c2edd467d8cea2c7bd718417f49a3b92057d8ebbc35caf1bfe985acb0f53", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b5aa3cc3-a817-4330-b6ce-2d3e8cdca1e2", "node_type": "1", "metadata": {}, "hash": "8aae878a3524ead8fe0cb4d26810567821bae0a9d7a7c6f808606002a5fa59d2", "class_name": "RelatedNodeInfo"}}, "text": "The deeper\nwe go in the network, the larger the receptive field (relative to the input) to which each\nhidden node is sensitive. Reducing spatial resolution accelerates this process, since the\nconvolution kernels cover a larger effective area.\nMoreover, when detecting lower-level features, such as edges (as discussed in Section 7.2 ),\nwe often want our representations to be somewhat invariant to translation. For instance,\nif we take the image Xwith a sharp delineation between black and white and shift the\nwhole image by one pixel to the right, i.e., Z[i, j] = X[i, j + 1] , then the output\nfor the new image Zmight be vastly different. The edge will have shifted by one pixel. In\nreality, objects hardly ever occur exactly at the same place. In fact, even with a tripod and\na stationary object, vibration of the camera due to the movement of the shutter might shift\neverything by a pixel or so (high-end cameras are loaded with special features to address\nthis problem).\nThis section introduces pooling layers , which serve the dual purposes of mitigating the\nsensitivity of convolutional layers to location and of spatially downsampling representa-\ntions.\n258 Convolutional Neural Networks\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n7.5.1Maximum Poolingand AveragePooling\nLike convolutional layers, pooling operators consist of a fixed-shape window that is slid\nover all regions in the input according to its stride, computing a single output for each lo-\ncation traversed by the fixed-shape window (sometimes known as the pooling window ).\nHowever, unlike the cross-correlation computation of the inputs and kernels in the con-\nvolutional layer, the pooling layer contains no parameters (there is no kernel). Instead,\npooling operators are deterministic, typically calculating either the maximum or the aver-\nage value of the elements in the pooling window. These operations are called maximum\npooling(max-pooling for short) and averagepooling , respectively.\nAveragepooling isessentiallyasoldasCNNs. Theideaisakintodownsamplinganimage.\nRather than just taking the value of every second (or third) pixel for the lower resolution\nimage, we can average over adjacent pixels to obtain an image with better signal-to-noise\nratio since we are combining the information from multiple adjacent pixels. Max-pooling\nwas introduced in Riesenhuber and Poggio ( 1999) in the context of cognitive neuroscience\ntodescribehowinformationaggregationmightbeaggregatedhierarchicallyforthepurpose\nofobjectrecognition;therealreadywasanearlierversioninspeechrecognition( Yamaguchi\net al., 1990). In almost all cases, max-pooling, as it is also referred to, is preferable to\naverage pooling.\nIn both cases, as with the cross-correlation operator, we can think of the pooling window\nas starting from the upper-left of the input tensor and sliding across it from left to right and\ntop to bottom. At each location that the pooling window hits, it computes the maximum or\naverage value of the input subtensor in the window, depending on whether max or average\npooling is employed.\ntFig. 7.5.1 Max-pooling with a pooling window shape of 2 \u00022. The shaded portions are the \ufb01rst\noutput element as well as the input tensor elements used for the output computation:\nmax\u00b90,1,3,4\u00ba=4.\nThe output tensor in Fig. 7.5.1 has a height of 2 and a width of 2. The four elements are\n259 Pooling\nderived from the maximum value in each pooling window:\nmax\u00b90,1,3,4\u00ba=4,\nmax\u00b91,2,4,5\u00ba=5,\nmax\u00b93,4,6,7\u00ba=7,\nmax\u00b94,5,7,8\u00ba=8.(7.5.1)\nMore generally, we can define a \ud835\udc5d\u0002\ud835\udc5epooling layer by aggregating over a region of said\nsize. Returning to the problem of edge detection, we use the output of the convolutional\nlayer as input for 2\u00022max-pooling. Denote by Xthe input of the convolutional layer input\nandYthe pooling layer output. Regardless of whether or not the values of X[i, j] ,X[i,\nj + 1],X[i+1, j] andX[i+1, j + 1] are different, the pooling layer always outputs\nY[i, j] = 1 .", "mimetype": "text/plain", "start_char_idx": 630363, "end_char_idx": 634312, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b5aa3cc3-a817-4330-b6ce-2d3e8cdca1e2": {"__data__": {"id_": "b5aa3cc3-a817-4330-b6ce-2d3e8cdca1e2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "182ef506-6e97-4f72-8044-68eb2b2e2f7c", "node_type": "1", "metadata": {}, "hash": "f66f5c73139eef1a12ada1aa1965a123bda10c56987d497490e7202a546c4856", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a070f35b-5bcb-40f1-80d3-01dc3819e51a", "node_type": "1", "metadata": {}, "hash": "3d5dedc21035640ead91620a044c5f58de3c0280c746cd308f00f91624aa6275", "class_name": "RelatedNodeInfo"}}, "text": "(7.5.1)\nMore generally, we can define a \ud835\udc5d\u0002\ud835\udc5epooling layer by aggregating over a region of said\nsize. Returning to the problem of edge detection, we use the output of the convolutional\nlayer as input for 2\u00022max-pooling. Denote by Xthe input of the convolutional layer input\nandYthe pooling layer output. Regardless of whether or not the values of X[i, j] ,X[i,\nj + 1],X[i+1, j] andX[i+1, j + 1] are different, the pooling layer always outputs\nY[i, j] = 1 . That is to say, using the 2\u00022max-pooling layer, we can still detect if the\npattern recognized by the convolutional layer movesno more than one element in height or\nwidth.\nInthecodebelow,weimplementtheforwardpropagationofthepoolinglayerinthe pool2d\nfunction. Thisfunctionissimilartothe corr2dfunctionin Section7.2 . However,nokernel\nisneeded, computingtheoutputaseitherthemaximumortheaverageofeachregioninthe\ninput.\ndef pool2d (X, pool_size, mode ='max'):\np_h, p_w =pool_size\nY=torch .zeros((X .shape[ 0]-p_h +1, X.shape[ 1]-p_w +1))\nfor iinrange (Y.shape[ 0]):\nfor jinrange (Y.shape[ 1]):\nifmode =='max':\nY[i, j] =X[i: i +p_h, j: j +p_w] .max()\nelif mode =='avg':\nY[i, j] =X[i: i +p_h, j: j +p_w] .mean()\nreturn Y\nWecanconstructtheinputtensor XinFig.7.5.1 tovalidatetheoutputofthetwo-dimensional\nmax-pooling layer.\nX=torch .tensor([[ 0.0,1.0,2.0], [ 3.0,4.0,5.0], [ 6.0,7.0,8.0]])\npool2d(X, ( 2,2))\ntensor([[ 4.,5.],\n[7.,8.]])\nAlso, we can experiment with the average pooling layer.\npool2d(X, ( 2,2),'avg')\ntensor([[ 2.,3.],\n[5.,6.]])\n260 Convolutional Neural Networks\n7.5.2Paddingand Stride\nAswithconvolutionallayers,poolinglayerschangetheoutputshape. Andasbefore,wecan\nadjusttheoperationtoachieveadesiredoutputshapebypaddingtheinputandadjustingthe\nstride. We can demonstrate the use of padding and strides in pooling layers via the built-in\ntwo-dimensional max-pooling layer from the deep learning framework. We first construct\nan input tensor Xwhose shape has four dimensions, where the number of examples (batch\nsize) and number of channels are both 1.\nX=torch .arange( 16, dtype =torch .float32) .reshape(( 1,1,4,4))\nX\ntensor([[[[ 0.,1.,2.,3.],\n[4.,5.,6.,7.],\n[8.,9.,10.,11.],\n[12.,13.,14.,15.]]]])\nSince pooling aggregates information from an area, deep learning frameworks default to\nmatching pooling window sizes and stride. For instance, if we use a pooling window of\nshape (3, 3)we get a stride shape of (3, 3)by default.\npool2d =nn.MaxPool2d( 3)\n# Pooling has no model parameters, hence it needs no initialization\npool2d(X)\ntensor([[[[ 10.]]]])\nNeedless to say, the stride and padding can be manually specified to override framework\ndefaults if required.\npool2d =nn.MaxPool2d( 3, padding =1, stride =2)\npool2d(X)\ntensor([[[[ 5.,7.],\n[13.,15.]]]])\nOf course, we can specify an arbitrary rectangular pooling window with arbitrary height\nand width respectively, as the example below shows.\npool2d =nn.MaxPool2d(( 2,3), stride =(2,3), padding =(0,1))\npool2d(X)\ntensor([[[[ 5.,7.],\n[13.,15.]]]])\n261 Pooling\n7.5.3Multiple Channels\nWhen processing multi-channel input data, the pooling layer pools each input channel sep-\narately, rather than summing the inputs up over channels as in a convolutional layer.", "mimetype": "text/plain", "start_char_idx": 633858, "end_char_idx": 637025, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a070f35b-5bcb-40f1-80d3-01dc3819e51a": {"__data__": {"id_": "a070f35b-5bcb-40f1-80d3-01dc3819e51a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b5aa3cc3-a817-4330-b6ce-2d3e8cdca1e2", "node_type": "1", "metadata": {}, "hash": "8aae878a3524ead8fe0cb4d26810567821bae0a9d7a7c6f808606002a5fa59d2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d6d7be01-150c-455d-b559-f2568193ae2e", "node_type": "1", "metadata": {}, "hash": "01fdd3483568444421775469a19945bdcf55a7c50e055de15084bb3ab7c28777", "class_name": "RelatedNodeInfo"}}, "text": "Needless to say, the stride and padding can be manually specified to override framework\ndefaults if required.\npool2d =nn.MaxPool2d( 3, padding =1, stride =2)\npool2d(X)\ntensor([[[[ 5.,7.],\n[13.,15.]]]])\nOf course, we can specify an arbitrary rectangular pooling window with arbitrary height\nand width respectively, as the example below shows.\npool2d =nn.MaxPool2d(( 2,3), stride =(2,3), padding =(0,1))\npool2d(X)\ntensor([[[[ 5.,7.],\n[13.,15.]]]])\n261 Pooling\n7.5.3Multiple Channels\nWhen processing multi-channel input data, the pooling layer pools each input channel sep-\narately, rather than summing the inputs up over channels as in a convolutional layer. This\nmeansthatthenumberofoutputchannelsforthepoolinglayeristhesameasthenumberof\ninput channels. Below, we will concatenate tensors XandX + 1on the channel dimension\nto construct an input with two channels.\nX=torch .cat((X, X +1),1)\nX\ntensor([[[[ 0.,1.,2.,3.],\n[4.,5.,6.,7.],\n[8.,9.,10.,11.],\n[12.,13.,14.,15.]],\n[[1.,2.,3.,4.],\n[5.,6.,7.,8.],\n[9.,10.,11.,12.],\n[13.,14.,15.,16.]]]])\nAs we can see, the number of output channels is still two after pooling.\npool2d =nn.MaxPool2d( 3, padding =1, stride =2)\npool2d(X)\ntensor([[[[ 5.,7.],\n[13.,15.]],\n[[6.,8.],\n[14.,16.]]]])\n7.5.4Summary\nPooling is an exceedingly simple operation. It does exactly what its name indicates, ag-\ngregate results over a window of values. All convolution semantics, such as strides and\npadding apply in the same way as they did previously. Note that pooling is indifferent to\nchannels, i.e., it leaves the number of channels unchanged and it applies to each channel\nseparately. Lastly,ofthetwopopularpoolingchoices,max-poolingispreferabletoaverage\npooling, as it confers some degree of invariance to output. A popular choice is to pick a\npooling window size of 2\u00022to quarter the spatial resolution of output.\nNotethattherearemanymorewaysofreducingresolutionbeyondpooling. Forinstance,in\nstochastic pooling ( Zeiler and Fergus, 2013 ) and fractional max-pooling ( Graham, 2014 )\naggregation is combined with randomization. This can slightly improve the accuracy in\nsome cases. Lastly, as we will see later with the attention mechanism, there are more\nrefined ways of aggregating over outputs, e.g., by using the alignment between a query and\nrepresentation vectors.\n262 Convolutional Neural Networks\n1237.5.5Exercises\n1.Implement average pooling through a convolution.\n2.Prove that max-pooling cannot be implemented through a convolution alone.\n3.Max-pooling can be accomplished using ReLU operations, i.e., ReLU \u00b9\ud835\udc65\u00ba=max\u00b90,\ud835\udc65\u00ba.\n1.Express max\u00b9\ud835\udc4e,\ud835\udc4f\u00baby using only ReLU operations.\n2.Use this to implement max-pooling by means of convolutions and ReLU layers.\n3.How many channels and layers do you need for a 2\u00022convolution? How many for\na3\u00023convolution?\n4.Whatisthecomputationalcostofthepoolinglayer? Assumethattheinputtothepooling\nlayer is of size \ud835\udc50\u0002\u210e\u0002\ud835\udc64, the pooling window has a shape of \ud835\udc5dh\u0002\ud835\udc5dwwith a padding of\n\u00b9\ud835\udc5dh,\ud835\udc5dw\u00baand a stride of\u00b9\ud835\udc60h,\ud835\udc60w\u00ba.\n5.Why do you expect max-pooling and average pooling to work differently?\n6.Do we need a separate minimum pooling layer? Can you replace it with another opera-\ntion?\n7.We could use the softmax operation for pooling. Why might it not be so popular?\nDiscussions123.", "mimetype": "text/plain", "start_char_idx": 636369, "end_char_idx": 639600, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d6d7be01-150c-455d-b559-f2568193ae2e": {"__data__": {"id_": "d6d7be01-150c-455d-b559-f2568193ae2e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a070f35b-5bcb-40f1-80d3-01dc3819e51a", "node_type": "1", "metadata": {}, "hash": "3d5dedc21035640ead91620a044c5f58de3c0280c746cd308f00f91624aa6275", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cceff5f6-4491-4d94-a19c-32f160f07ba6", "node_type": "1", "metadata": {}, "hash": "6a96e970c252b0790bf782971b4d553775fb69ece92550d6004cb04a8065553e", "class_name": "RelatedNodeInfo"}}, "text": "2.Use this to implement max-pooling by means of convolutions and ReLU layers.\n3.How many channels and layers do you need for a 2\u00022convolution? How many for\na3\u00023convolution?\n4.Whatisthecomputationalcostofthepoolinglayer? Assumethattheinputtothepooling\nlayer is of size \ud835\udc50\u0002\u210e\u0002\ud835\udc64, the pooling window has a shape of \ud835\udc5dh\u0002\ud835\udc5dwwith a padding of\n\u00b9\ud835\udc5dh,\ud835\udc5dw\u00baand a stride of\u00b9\ud835\udc60h,\ud835\udc60w\u00ba.\n5.Why do you expect max-pooling and average pooling to work differently?\n6.Do we need a separate minimum pooling layer? Can you replace it with another opera-\ntion?\n7.We could use the softmax operation for pooling. Why might it not be so popular?\nDiscussions123.\n7.6ConvolutionalNeuralNetworks(LeNet)\nWenowhavealltheingredientsrequiredtoassembleafully-functionalCNN.Inourearlier\nencounterwithimagedata,weappliedalinearmodelwithsoftmaxregression( Section4.4 )\nand an MLP ( Section 5.2 ) to pictures of clothing in the Fashion-MNIST dataset. To make\nsuch data amenable we first flattened each image from a 28\u000228matrix into a fixed-length\n784-dimensional vector, and thereafter processed them in fully connected layers. Now that\nwe have a handle on convolutional layers, we can retain the spatial structure in our images.\nAs an additional benefit of replacing fully connected layers with convolutional layers, we\nwill enjoy more parsimonious models that require far fewer parameters.\nIn this section, we will introduce LeNet, among the first published CNNs to capture wide\nattention for its performance on computer vision tasks. The model was introduced by (and\nnamed for) Yann LeCun, then a researcher at AT&T Bell Labs, for the purpose of rec-\nognizing handwritten digits in images ( LeCunet al., 1998). This work represented the\nculmination of a decade of research developing the technology; LeCun\u2019s team published\nthefirststudytosuccessfullytrainCNNsviabackpropagation( LeCunetal.,1989).\nAtthetimeLeNetachievedoutstandingresultsmatchingtheperformanceofsupportvector\nmachines, then a dominant approach in supervised learning, achieving an error rate of less\n263 Convolutional Neural Networks (LeNet)\nthan1%perdigit. LeNetwaseventuallyadaptedtorecognizedigitsforprocessingdeposits\nin ATM machines. To this day, some ATMs still run the code that Yann LeCun and his\ncolleague Leon Bottou wrote in the 1990s!\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n7.6.1LeNet\nAt a high level, LeNet (LeNet-5) consists of two parts: (i) a convolutional encoder consist-\ning of two convolutional layers; and (ii) a dense block consisting of three fully connected\nlayers. The architecture is summarized in Fig. 7.6.1 .\ntFig. 7.6.1 Data \ufb02ow in LeNet. The input is a handwritten digit, the output is a probability over 10\npossible outcomes.\nThe basic units in each convolutional block are a convolutional layer, a sigmoid activation\nfunction, and a subsequent average pooling operation. Note that while ReLUs and max-\npoolingworkbetter,theyhadnotyetbeendiscovered. Eachconvolutionallayerusesa 5\u00025\nkernel and a sigmoid activation function. These layers map spatially arranged inputs to a\nnumberoftwo-dimensionalfeaturemaps,typicallyincreasingthenumberofchannels. The\nfirstconvolutionallayerhas6outputchannels,whilethesecondhas16. Each 2\u00022pooling\noperation (stride 2) reduces dimensionality by a factor of 4via spatial downsampling. The\nconvolutional block emits an output with shape given by (batch size, number of channel,\nheight, width).\nInordertopassoutputfromtheconvolutionalblocktothedenseblock,wemustflatteneach\nexampleintheminibatch. Inotherwords,wetakethisfour-dimensionalinputandtransform\nitintothetwo-dimensionalinputexpectedbyfullyconnectedlayers: asareminder,thetwo-\ndimensional representation that we desire uses the first dimension to index examples in the\nminibatch and the second to give the flat vector representation of each example.", "mimetype": "text/plain", "start_char_idx": 638975, "end_char_idx": 642785, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cceff5f6-4491-4d94-a19c-32f160f07ba6": {"__data__": {"id_": "cceff5f6-4491-4d94-a19c-32f160f07ba6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d6d7be01-150c-455d-b559-f2568193ae2e", "node_type": "1", "metadata": {}, "hash": "01fdd3483568444421775469a19945bdcf55a7c50e055de15084bb3ab7c28777", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1c074884-7cbc-4cbc-ba86-41a59e0b6b0b", "node_type": "1", "metadata": {}, "hash": "44002f6740cd3749e33408de916894a85a45049105442cb6a8e39fdb5576d04f", "class_name": "RelatedNodeInfo"}}, "text": "These layers map spatially arranged inputs to a\nnumberoftwo-dimensionalfeaturemaps,typicallyincreasingthenumberofchannels. The\nfirstconvolutionallayerhas6outputchannels,whilethesecondhas16. Each 2\u00022pooling\noperation (stride 2) reduces dimensionality by a factor of 4via spatial downsampling. The\nconvolutional block emits an output with shape given by (batch size, number of channel,\nheight, width).\nInordertopassoutputfromtheconvolutionalblocktothedenseblock,wemustflatteneach\nexampleintheminibatch. Inotherwords,wetakethisfour-dimensionalinputandtransform\nitintothetwo-dimensionalinputexpectedbyfullyconnectedlayers: asareminder,thetwo-\ndimensional representation that we desire uses the first dimension to index examples in the\nminibatch and the second to give the flat vector representation of each example. LeNet\u2019s\ndense block has three fully connected layers, with 120, 84, and 10 outputs, respectively.\nBecausewearestillperformingclassification,the10-dimensionaloutputlayercorresponds\nto the number of possible output classes.\n264 Convolutional Neural Networks\nWhile getting to the point where you truly understand what is going on inside LeNet may\nhave taken a bit of work, we hope that the following code snippet will convince you that\nimplementing such models with modern deep learning frameworks is remarkably simple.\nWe need only to instantiate a Sequential block and chain together the appropriate layers,\nusing Xavier initialization as introduced in Section 5.4.2 .\ndef init_cnn (module): #@save\n\"\"\"Initialize weights for CNNs.\"\"\"\niftype (module) ==nn.Linear ortype (module) ==nn.Conv2d:\nnn.init .xavier_uniform_(module .weight)\nclass LeNet (d2l .Classifier): #@save\n\"\"\"The LeNet-5 model.\"\"\"\ndef __init__ (self , lr =0.1, num_classes =10):\nsuper ().__init__ ()\nself .save_hyperparameters()\nself .net =nn.Sequential(\nnn.LazyConv2d( 6, kernel_size =5, padding =2), nn .Sigmoid(),\nnn.AvgPool2d(kernel_size =2, stride =2),\nnn.LazyConv2d( 16, kernel_size =5), nn .Sigmoid(),\nnn.AvgPool2d(kernel_size =2, stride =2),\nnn.Flatten(),\nnn.LazyLinear( 120), nn .Sigmoid(),\nnn.LazyLinear( 84), nn .Sigmoid(),\nnn.LazyLinear(num_classes))\nWe have taken some liberty in the reproduction of LeNet insofar as we have replaced the\nGaussian activation layer by a softmax layer. This greatly simplifies the implementation,\nnotleastdue tothefactthatthe Gaussiandecoderis rarelyused nowadays. Other thanthat,\nthis network matches the original LeNet-5 architecture.\nLet\u2019s see what happens inside the network. By passing a single-channel (black and white)\n28\u000228imagethroughthenetworkandprintingtheoutputshapeateachlayer,wecaninspect\nthe model to ensure that its operations line up with what we expect from Fig. 7.6.2 .\ntFig. 7.6.2 Compressed notation for LeNet-5.", "mimetype": "text/plain", "start_char_idx": 641974, "end_char_idx": 644726, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1c074884-7cbc-4cbc-ba86-41a59e0b6b0b": {"__data__": {"id_": "1c074884-7cbc-4cbc-ba86-41a59e0b6b0b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cceff5f6-4491-4d94-a19c-32f160f07ba6", "node_type": "1", "metadata": {}, "hash": "6a96e970c252b0790bf782971b4d553775fb69ece92550d6004cb04a8065553e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0d26815e-76c0-4860-8864-1c296ba46899", "node_type": "1", "metadata": {}, "hash": "4d10e1c0dfc7c1f26ca88219492e5e093fcc0630fd251e8f64b8173123e29f18", "class_name": "RelatedNodeInfo"}}, "text": "This greatly simplifies the implementation,\nnotleastdue tothefactthatthe Gaussiandecoderis rarelyused nowadays. Other thanthat,\nthis network matches the original LeNet-5 architecture.\nLet\u2019s see what happens inside the network. By passing a single-channel (black and white)\n28\u000228imagethroughthenetworkandprintingtheoutputshapeateachlayer,wecaninspect\nthe model to ensure that its operations line up with what we expect from Fig. 7.6.2 .\ntFig. 7.6.2 Compressed notation for LeNet-5.\n265 Convolutional Neural Networks (LeNet)\n@d2l .add_to_class(d2l .Classifier) #@save\ndef layer_summary (self , X_shape):\nX=torch .randn( *X_shape)\nfor layer inself .net:\nX=layer(X)\nprint (layer .__class__ .__name__ ,'output shape: \\t', X.shape)\nmodel =LeNet()\nmodel .layer_summary(( 1,1,28,28))\nConv2d output shape: torch .Size([ 1,6,28,28])\nSigmoid output shape: torch .Size([ 1,6,28,28])\nAvgPool2d output shape: torch .Size([ 1,6,14,14])\nConv2d output shape: torch .Size([ 1,16,10,10])\nSigmoid output shape: torch .Size([ 1,16,10,10])\nAvgPool2d output shape: torch .Size([ 1,16,5,5])\nFlatten output shape: torch .Size([ 1,400])\nLinear output shape: torch .Size([ 1,120])\nSigmoid output shape: torch .Size([ 1,120])\nLinear output shape: torch .Size([ 1,84])\nSigmoid output shape: torch .Size([ 1,84])\nLinear output shape: torch .Size([ 1,10])\nNote that the height and width of the representation at each layer throughout the convolu-\ntional block is reduced (compared with the previous layer). The first convolutional layer\nuses two pixels of padding to compensate for the reduction in height and width that would\notherwise result from using a 5\u00025kernel. As an aside, the image size of 28\u000228pixels in\ntheoriginalMNISTOCRdatasetisaresultof trimming twopixelrows(andcolumns)from\nthe original scans that measured 32\u000232pixels. This was done primarily to save space (a\n30% reduction) at a time when megabytes mattered.\nIn contrast, the second convolutional layer forgoes padding, and thus the height and width\nare both reduced by four pixels. As we go up the stack of layers, the number of channels\nincreases layer-over-layer from 1 in the input to 6 after the first convolutional layer and\n16 after the second convolutional layer. However, each pooling layer halves the height and\nwidth. Finally,eachfullyconnectedlayerreducesdimensionality,finallyemittinganoutput\nwhose dimension matches the number of classes.\n7.6.2Training\nNow that we have implemented the model, let\u2019s run an experiment to see how the LeNet-5\nmodel fares on Fashion-MNIST.\nWhile CNNs have fewer parameters, they can still be more expensive to compute than\nsimilarly deep MLPs because each parameter participates in many more multiplications.\nIf you have access to a GPU, this might be a good time to put it into action to speed up\ntraining. Note that the d2l.Trainer class takes care of all details. By default, it initializes\nthe model parameters on the available devices. Just as with MLPs, our loss function is\ncross-entropy, and we minimize it via minibatch stochastic gradient descent.\n266 Convolutional Neural Networks\ntrainer =d2l.Trainer(max_epochs =10, num_gpus =1)\ndata =d2l.FashionMNIST(batch_size =128)\nmodel =LeNet(lr =0.1)\nmodel .apply_init([ next (iter (data .get_dataloader( True )))[ 0]], init_cnn)\ntrainer .fit(model, data)\n7.6.3Summary\nWe have made significant progress in this chapter. We moved from the MLPs of the 1980s\nto the CNNs of the 1990s and early 2000s. The architectures proposed, e.g., in the form\nof LeNet-5 remain meaningful, even to this day.", "mimetype": "text/plain", "start_char_idx": 644246, "end_char_idx": 647771, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0d26815e-76c0-4860-8864-1c296ba46899": {"__data__": {"id_": "0d26815e-76c0-4860-8864-1c296ba46899", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1c074884-7cbc-4cbc-ba86-41a59e0b6b0b", "node_type": "1", "metadata": {}, "hash": "44002f6740cd3749e33408de916894a85a45049105442cb6a8e39fdb5576d04f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3a033a10-4c0b-44f9-b798-fd96c01070f2", "node_type": "1", "metadata": {}, "hash": "76fffd6ddf0dc641c9cf8a46270b55643832cad00a3bbe585a951da70466eca1", "class_name": "RelatedNodeInfo"}}, "text": "By default, it initializes\nthe model parameters on the available devices. Just as with MLPs, our loss function is\ncross-entropy, and we minimize it via minibatch stochastic gradient descent.\n266 Convolutional Neural Networks\ntrainer =d2l.Trainer(max_epochs =10, num_gpus =1)\ndata =d2l.FashionMNIST(batch_size =128)\nmodel =LeNet(lr =0.1)\nmodel .apply_init([ next (iter (data .get_dataloader( True )))[ 0]], init_cnn)\ntrainer .fit(model, data)\n7.6.3Summary\nWe have made significant progress in this chapter. We moved from the MLPs of the 1980s\nto the CNNs of the 1990s and early 2000s. The architectures proposed, e.g., in the form\nof LeNet-5 remain meaningful, even to this day. It is worth comparing the error rates on\nFashion-MNISTachievablewithLeNet-5bothtotheverybestpossiblewithMLPs( Section\n5.2)andthosewithsignificantlymoreadvancedarchitecturessuchasResNet( Section8.6 ).\nLeNetismuchmoresimilartothelatterthantotheformer. Oneoftheprimarydifferences,\nasweshallsee, isthatgreateramountsofcomputationenabledsignificantlymorecomplex\narchitectures.\nAseconddifferenceistherelativeeasewithwhichwewereabletoimplementLeNet. What\nused to be an engineering challenge worth months of C++ and assembly code, engineering\nto improve SN, an early Lisp-based deep learning tool ( Bottou and Le Cun, 1988 ), and fi-\nnallyexperimentationwithmodelscannowbeaccomplishedinminutes. Itisthisincredible\nproductivity boost that has democratized deep learning model development tremendously.\nIn the next chapter we will journey down this rabbit to hole to see where it takes us.\n7.6.4Exercises\n1.Let\u2019s modernize LeNet. Implement and test the following changes:\n1.Replace average pooling with max-pooling.\n2.Replace the softmax layer with ReLU.\n2.Try to change the size of the LeNet style network to improve its accuracy in addition to\nmax-pooling and ReLU.\n1.Adjust the convolution window size.\n2.Adjust the number of output channels.\n267 Convolutional Neural Networks (LeNet)\n1243.Adjust the number of convolution layers.\n4.Adjust the number of fully connected layers.\n5.Adjustthe learning rates and other training details (e.g., initialization and number of\nepochs).\n3.Try out the improved network on the original MNIST dataset.\n4.Display the activations of the first and second layer of LeNet for different inputs (e.g.,\nsweaters and coats).\n5.What happens to the activations when you feed significantly different images into the\nnetwork (e.g., cats, cars, or even random noise)?\nDiscussions124.\n125\n8 Modern Convolutional Neural Networks\nNow that we understand the basics of wiring together CNNs, let\u2019s take a tour of modern\nCNN architectures. This tour is, by necessity, incomplete, thanks to the plethora of excit-\ningnewdesignsbeingadded. Theirimportancederivesfromthefactthatnotonlycanthey\nbe used directly for vision tasks, but they also serve as basic feature generators for more\nadvancedtaskssuchastracking( Zhangetal., 2021), segmentation( Longetal., 2015), ob-\nject detection ( Redmon and Farhadi, 2018 ), or style transformation ( Gatysetal., 2016). In\nthis chapter, most sections correspond to a significant CNN architecture that was at some\npoint (or currently) the base model upon which many research projects and deployed sys-\ntemswerebuilt. Eachofthesenetworkswasbrieflyadominantarchitectureandmanywere\nwinners or runners-up in the ImageNet competition125which has served as a barometer\nof progress on supervised learning in computer vision since 2010. It is only recently that\nTransformers have begun to displace CNNs, starting with Dosovitskiy et al.(2021) and\nfollowed by the Swin Transformer ( Liuet al., 2021). We will cover this development later\ninChapter 11 .\nWhile the idea of deepneural networks is quite simple (stack together a bunch of layers),\nperformance can vary wildly across architectures and hyperparameter choices. The neural\nnetworksdescribedinthischapteraretheproductofintuition,afewmathematicalinsights,\nandalotoftrialanderror.", "mimetype": "text/plain", "start_char_idx": 647094, "end_char_idx": 651042, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3a033a10-4c0b-44f9-b798-fd96c01070f2": {"__data__": {"id_": "3a033a10-4c0b-44f9-b798-fd96c01070f2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0d26815e-76c0-4860-8864-1c296ba46899", "node_type": "1", "metadata": {}, "hash": "4d10e1c0dfc7c1f26ca88219492e5e093fcc0630fd251e8f64b8173123e29f18", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "12b81399-52e7-4549-8a65-92a2fc91d9a8", "node_type": "1", "metadata": {}, "hash": "d3e208bd51873b8c99381104768b61040ed84a23d380be6f10c84091fe4d0ad0", "class_name": "RelatedNodeInfo"}}, "text": "Eachofthesenetworkswasbrieflyadominantarchitectureandmanywere\nwinners or runners-up in the ImageNet competition125which has served as a barometer\nof progress on supervised learning in computer vision since 2010. It is only recently that\nTransformers have begun to displace CNNs, starting with Dosovitskiy et al.(2021) and\nfollowed by the Swin Transformer ( Liuet al., 2021). We will cover this development later\ninChapter 11 .\nWhile the idea of deepneural networks is quite simple (stack together a bunch of layers),\nperformance can vary wildly across architectures and hyperparameter choices. The neural\nnetworksdescribedinthischapteraretheproductofintuition,afewmathematicalinsights,\nandalotoftrialanderror. Wepresentthesemodelsinchronologicalorder,partlytoconvey\na sense of the history so that you can form your own intuitions about where the field is\nheadingandperhapsdevelopyourownarchitectures. Forinstance,batchnormalizationand\nresidual connections described in this chapter have offered two popular ideas for training\nand designing deep models, both of which have since also been applied to architectures\nbeyond computer vision.\nWe begin our tour of modern CNNs with AlexNet ( Krizhevsky etal., 2012), the firstlarge-\nscale network deployed to beat conventional computer vision methods on a large-scale vi-\nsion challenge; the VGG network ( Simonyan and Zisserman, 2014 ), which makes use of a\nnumberofrepeatingblocksofelements;thenetworkinnetwork(NiN)thatconvolveswhole\nneural networks patch-wise over inputs ( Linet al., 2013); GoogLeNet that uses networks\nwith multi-branch convolutions ( Szegedyet al., 2015); the residual network (ResNet) ( He\netal.,2016),whichremainsoneofthemostpopularoff-the-shelfarchitecturesincomputer\nvision; ResNeXt blocks ( Xieet al., 2017) for sparser connections; and DenseNet ( Huang\net al., 2017) for a generalization of the residual architecture. Over time many special opti-\nmizations for efficient networks have been developed, such as coordinate shifts (ShiftNet)\n(Wuet al., 2018). This culminated in the automatic search for efficient architectures such\n268\n269 Deep Convolutional Neural Networks (AlexNet)\nas MobileNet v3 ( Howardet al., 2019). It also includes the semi-automatic design explo-\nration of Radosavovic et al.(2020) that led to the RegNetX/Y which we will discuss later\nin this chapter. The work is instructive insofar as it offers a path for marrying brute force\ncomputationwiththeingenuityofanexperimenterinthesearchforefficientdesignspaces.\nOf note is also the work of Liu et al.(2022) as it shows that training techniques (e.g., op-\ntimizers, data augmentation, and regularization) play a pivotal role in improving accuracy.\nIt also shows that long-held assumptions, such as the size of a convolution window, may\nneed to be revisited, given the increase in computation and data. We will cover this and\nmany more questions in due course throughout this chapter.\n8.1DeepConvolutionalNeuralNetworks(AlexNet)\nAlthough CNNs were well known in the computer vision and machine learning commu-\nnities following the introduction of LeNet ( LeCunet al., 1995), they did not immediately\ndominate the field. Although LeNet achieved good results on early small datasets, the per-\nformance and feasibility of training CNNs on larger, more realistic datasets had yet to be\nestablished. In fact, for much of the intervening time between the early 1990s and the wa-\ntershed results of 2012 ( Krizhevsky et al., 2012), neural networks were often surpassed\nby other machine learning methods, such as kernel methods ( Sch\u00f6lkopf and Smola, 2002 ),\nensemble methods ( Freund and Schapire, 1996 ), and structured estimation ( Taskaret al.,\n2004).\nFor computer vision, this comparison is perhaps not entirely accurate. That is, although\nthe inputs to convolutional networks consist of raw or lightly-processed (e.g., by center-\ning) pixel values, practitioners would never feed raw pixels into traditional models.", "mimetype": "text/plain", "start_char_idx": 650333, "end_char_idx": 654288, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "12b81399-52e7-4549-8a65-92a2fc91d9a8": {"__data__": {"id_": "12b81399-52e7-4549-8a65-92a2fc91d9a8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3a033a10-4c0b-44f9-b798-fd96c01070f2", "node_type": "1", "metadata": {}, "hash": "76fffd6ddf0dc641c9cf8a46270b55643832cad00a3bbe585a951da70466eca1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5a9eef3e-586f-4353-a345-9c02dc25dbf9", "node_type": "1", "metadata": {}, "hash": "ecb96783de3f0474e4f08a63aaad6b4acf922d5cd028fc826c8e2b76decd33b3", "class_name": "RelatedNodeInfo"}}, "text": "Although LeNet achieved good results on early small datasets, the per-\nformance and feasibility of training CNNs on larger, more realistic datasets had yet to be\nestablished. In fact, for much of the intervening time between the early 1990s and the wa-\ntershed results of 2012 ( Krizhevsky et al., 2012), neural networks were often surpassed\nby other machine learning methods, such as kernel methods ( Sch\u00f6lkopf and Smola, 2002 ),\nensemble methods ( Freund and Schapire, 1996 ), and structured estimation ( Taskaret al.,\n2004).\nFor computer vision, this comparison is perhaps not entirely accurate. That is, although\nthe inputs to convolutional networks consist of raw or lightly-processed (e.g., by center-\ning) pixel values, practitioners would never feed raw pixels into traditional models. In-\nstead, typical computer vision pipelines consisted of manually engineering feature extrac-\ntion pipelines, such as SIFT ( Lowe, 2004 ), SURF ( Bayet al., 2006), and bags of visual\nwords (Sivic and Zisserman, 2003 ). Rather than learning the features, the features were\ncrafted. Most of the progress came from having more clever ideas for feature extraction on\nthe one hand and deep insight into geometry ( Hartley and Zisserman, 2000 ) on the other.\nThe learning algorithm was often considered an afterthought.\nAlthough some neural network accelerators were available in the 1990s, they were not yet\nsufficiently powerful to make deep multichannel, multilayer CNNs with a large number\nof parameters. For instance, NVIDIA\u2019s GeForce 256 from 1999 was able to process at\nmost 480 million floating-point operations, such as additions and multiplications, per sec-\nond (MFLOPS), without any meaningful programming framework for operations beyond\ngames. Today\u2019s accelerators are able to perform in excess of 1000 TFLOPs per device.\nMoreover, datasets were still relatively small: OCR on 60,000 low-resolution 28\u000228pixel\nimages was considered a highly challenging task. Added to these obstacles, key tricks for\ntraining neural networks including parameter initialization heuristics ( Glorot and Bengio,\n2010),clevervariantsofstochasticgradientdescent( KingmaandBa,2014 ),non-squashing\n270 Modern Convolutional Neural Networks\n126activation functions ( Nair and Hinton, 2010 ), and effective regularization techniques ( Sri-\nvastavaetal., 2014) were still missing.\nThus, rather than training end-to-end (pixel to classification) systems, classical pipelines\nlooked more like this:\n1.Obtain an interesting dataset. In the early days, these datasets required expensive sen-\nsors. For instance, the Apple QuickTake 100126of 1994 sported a whopping 0.3\nmegapixel(VGA)resolution,capableofstoringupto8images,allforthepriceof$1000.\n2.Preprocess the dataset with hand-crafted features based on some knowledge of optics,\ngeometry, other analytic tools, and occasionally on the serendipitous discoveries by\nlucky graduate students.\n3.Feed the data through a standard set of feature extractors such as the SIFT (scale-\ninvariant feature transform) ( Lowe, 2004 ), the SURF (speeded up robust features) ( Bay\netal., 2006), or anynumber of other hand-tuned pipelines. OpenCV stillprovidesSIFT\nextractors to this day!\n4.Dump the resulting representations into your favorite classifier, likely a linear model or\nkernel method, to train a classifier.\nIf you spoke to machine learning researchers, they would reply that machine learning was\nboth important and beautiful. Elegant theories proved the properties of various classifiers\n(Boucheron et al., 2005) and convex optimization ( Boyd and Vandenberghe, 2004 ) had\nbecome the mainstay for obtaining them. The field of machine learning was thriving, rig-\norous, and eminently useful. However, if you spoke to a computer vision researcher, you\nwould hear a very different story. The dirty truth of image recognition, they would tell\nyou, is that features, geometry ( Hartley and Zisserman, 2000 ,Hartley and Kahl, 2009 ),\nand engineering, rather than novel learning algorithms, drove progress. Computer vision\nresearchers justifiably believed that a slightly bigger or cleaner dataset or a slightly im-\nprovedfeature-extractionpipelinematteredfarmoretothefinalaccuracythananylearning\nalgorithm.", "mimetype": "text/plain", "start_char_idx": 653495, "end_char_idx": 657713, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5a9eef3e-586f-4353-a345-9c02dc25dbf9": {"__data__": {"id_": "5a9eef3e-586f-4353-a345-9c02dc25dbf9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "12b81399-52e7-4549-8a65-92a2fc91d9a8", "node_type": "1", "metadata": {}, "hash": "d3e208bd51873b8c99381104768b61040ed84a23d380be6f10c84091fe4d0ad0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4b6e6cd7-a76e-4ca6-8d14-f08a68501b91", "node_type": "1", "metadata": {}, "hash": "f00d27a4edabe88206cd09119df622b25107c125220a3332d9c5711f30cd5dfc", "class_name": "RelatedNodeInfo"}}, "text": "Elegant theories proved the properties of various classifiers\n(Boucheron et al., 2005) and convex optimization ( Boyd and Vandenberghe, 2004 ) had\nbecome the mainstay for obtaining them. The field of machine learning was thriving, rig-\norous, and eminently useful. However, if you spoke to a computer vision researcher, you\nwould hear a very different story. The dirty truth of image recognition, they would tell\nyou, is that features, geometry ( Hartley and Zisserman, 2000 ,Hartley and Kahl, 2009 ),\nand engineering, rather than novel learning algorithms, drove progress. Computer vision\nresearchers justifiably believed that a slightly bigger or cleaner dataset or a slightly im-\nprovedfeature-extractionpipelinematteredfarmoretothefinalaccuracythananylearning\nalgorithm.\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n8.1.1Representation Learning\nAnotherwaytocastthestateofaffairsisthatthemostimportantpartofthepipelinewasthe\nrepresentation. And up until 2012 the representation was calculated mostly mechanically.\nIn fact, engineering a new set of feature functions, improving results, and writing up the\nmethod all featured prominently in papers. SIFT ( Lowe, 2004 ), SURF ( Bayet al., 2006),\nHOG (histograms of oriented gradient) ( Dalal and Triggs, 2005 ), bags of visual words\n(Sivic and Zisserman, 2003 ), and similar feature extractors ruled the roost.\nAnother group of researchers, including Yann LeCun, Geoff Hinton, Yoshua Bengio, An-\ndrew Ng, Shun-ichi Amari, and Juergen Schmidhuber, had different plans. They believed\n271 Deep Convolutional Neural Networks (AlexNet)\nthat features themselves ought to be learned. Moreover, they believed that to be reasonably\ncomplex, the features ought to be hierarchically composed with multiple jointly learned\nlayers, each with learnable parameters. In the case of an image, the lowest layers might\ncome to detect edges, colors, and textures, by analogy with how the visual system in ani-\nmalsprocessesitsinput. Inparticular, theautomaticdesignofvisualfeaturessuchasthose\nobtained by sparse coding ( Olshausen and Field, 1996 ) remained an open challenge until\nthe advent of modern CNNs. It was not until Dean etal.(2012), Le (2013) that the idea of\ngenerating features from image data automatically gained significant traction.\nThe first modern CNN ( Krizhevsky etal., 2012), namedAlexNet after one of its inventors,\nAlex Krizhevsky, is largely an evolutionary improvementoverLeNet. It achievedexcellent\nperformance in the 2012 ImageNet challenge.\ntFig. 8.1.1 Image \ufb01lters learned by the \ufb01rst layer of AlexNet. Reproduction courtesy of Krizhevsky\net al. ( 2012 ).\nInterestingly, in the lowest layers of the network, the model learned feature extractors that\nresembled some traditional filters. Fig. 8.1.1 shows lower-level image descriptors. Higher\nlayers in the network might build upon these representations to represent larger structures,\nlike eyes, noses, blades of grass, and so on. Even higher layers might represent whole\nobjects like people, airplanes, dogs, or frisbees. Ultimately, the final hidden state learns a\ncompact representation of the image that summarizes its contents such that data belonging\nto different categories can be easily separated.\nAlexNet (2012) and its precursor LeNet (1995) share many architectural elements. This\nbegsthequestion: whydidittakesolong? Akeydifferencewasthat,overtheprevioustwo\ndecades,theamountofdataandthecomputingpoweravailablehadincreasedsignificantly.\nAs such AlexNet was much larger: it was trained on much more data, and on much faster\nGPUs compared to the CPUs available in 1995.\n272 Modern Convolutional Neural Networks\nMissing Ingredient: Data\nDeep models with many layers require large amounts of data in order to enter the regime\nwhere they significantly outperform traditional methods based on convex optimizations\n(e.g.,linearandkernelmethods). However,giventhelimitedstoragecapacityofcomputers,\nthe relative expense of (imaging) sensors, and the comparatively tighter research budgets\nin the 1990s, most research relied on tiny datasets.", "mimetype": "text/plain", "start_char_idx": 656939, "end_char_idx": 661010, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4b6e6cd7-a76e-4ca6-8d14-f08a68501b91": {"__data__": {"id_": "4b6e6cd7-a76e-4ca6-8d14-f08a68501b91", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5a9eef3e-586f-4353-a345-9c02dc25dbf9", "node_type": "1", "metadata": {}, "hash": "ecb96783de3f0474e4f08a63aaad6b4acf922d5cd028fc826c8e2b76decd33b3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b3d4a14b-7cb4-4b47-96df-be0f4d0d5cd6", "node_type": "1", "metadata": {}, "hash": "5734935572227d13eff3cb2827672f6627060ff54c010cce7100d9cde5b99990", "class_name": "RelatedNodeInfo"}}, "text": "AlexNet (2012) and its precursor LeNet (1995) share many architectural elements. This\nbegsthequestion: whydidittakesolong? Akeydifferencewasthat,overtheprevioustwo\ndecades,theamountofdataandthecomputingpoweravailablehadincreasedsignificantly.\nAs such AlexNet was much larger: it was trained on much more data, and on much faster\nGPUs compared to the CPUs available in 1995.\n272 Modern Convolutional Neural Networks\nMissing Ingredient: Data\nDeep models with many layers require large amounts of data in order to enter the regime\nwhere they significantly outperform traditional methods based on convex optimizations\n(e.g.,linearandkernelmethods). However,giventhelimitedstoragecapacityofcomputers,\nthe relative expense of (imaging) sensors, and the comparatively tighter research budgets\nin the 1990s, most research relied on tiny datasets. Numerous papers relied on the UCI\ncollection of datasets, many of which contained only hundreds or (a few) thousands of\nimages captured in low resolution and often with an artificially clean background.\nIn 2009, the ImageNet dataset was released ( Denget al., 2009), challenging researchers\nto learn models from 1 million examples, 1000 each from 1000 distinct categories of ob-\njects. The categories themselves were based on the most popular noun nodes in WordNet\n(Miller, 1995 ). The ImageNet team used Google Image Search to prefilter large candidate\nsets foreachcategory and employedthe Amazon MechanicalTurkcrowdsourcingpipeline\ntoconfirmforeachimagewhetheritbelongedtotheassociatedcategory. Thisscalewasun-\nprecedented, exceeding others by over an order of magnitude (e.g., CIFAR-100 has 60,000\nimages). Anotheraspectwasthattheimageswereatrelativelyhighresolutionof 224\u0002224\npixels, unlike the 80 million-sized TinyImages dataset ( Torralbaet al., 2008), consisting\nof32\u000232pixel thumbnails. This allowed for the formation of higher-level features. The\nassociated competition, dubbed the ImageNet Large Scale Visual Recognition Challenge\n(Russakovsky et al., 2015), pushed computer vision and machine learning research for-\nward, challenging researchers to identify which models performed best at a greater scale\nthanacademicshadpreviouslyconsidered. Thelargestvisiondatasets, suchasLAION-5B\n(Schuhmann etal., 2022) contain billions of images with additional metadata.\nMissing Ingredient: Hardware\nDeep learning models are voracious consumers of compute cycles. Training can take hun-\ndreds of epochs, and each iteration requires passing data through many layers of compu-\ntationally expensive linear algebra operations. This is one of the main reasons why in the\n1990s and early 2000s, simple algorithms based on the more-efficiently optimized convex\nobjectives were preferred.\nGraphical processing units (GPUs) proved to be a game changer in making deep learn-\ning feasible. These chips had earlier been developed for accelerating graphics processing\nto benefit computer games. In particular, they were optimized for high throughput 4\u00024\nmatrix\u2013vector products, which are needed for many computer graphics tasks. Fortunately,\nthe math is strikingly similar to that required for calculating convolutional layers. Around\nthat time, NVIDIA and ATI had begun optimizing GPUs for general computing opera-\ntions (Fernando, 2004 ), going as far as to market them as general-purpose GPUs (GPG-\nPUs).\nTo provide some intuition, consider the cores of a modern microprocessor (CPU). Each\nof the cores is fairly powerful running at a high clock frequency and sporting large caches\n(up to several megabytes of L3). Each core is well-suited to executing a wide range of in-\nstructions, with branch predictors, a deep pipeline, specialized execution units, speculative\n273 Deep Convolutional Neural Networks (AlexNet)\n127execution, and many other bells and whistles that enable it to run a large variety of pro-\ngrams with sophisticated control flow. This apparent strength, however, is also its Achilles\nheel: general-purpose cores are very expensive to build. They excel at general-purpose\ncode with lots of control flow. This requires lots of chip area, not just for the actual ALU\n(arithmetic logical unit) where computation happens, but also for all the aforementioned\nbells and whistles, plus memory interfaces, caching logic between cores, high-speed in-\nterconnects, and so on. CPUs are comparatively bad at any single task when compared\nwithdedicatedhardware.", "mimetype": "text/plain", "start_char_idx": 660172, "end_char_idx": 664569, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b3d4a14b-7cb4-4b47-96df-be0f4d0d5cd6": {"__data__": {"id_": "b3d4a14b-7cb4-4b47-96df-be0f4d0d5cd6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4b6e6cd7-a76e-4ca6-8d14-f08a68501b91", "node_type": "1", "metadata": {}, "hash": "f00d27a4edabe88206cd09119df622b25107c125220a3332d9c5711f30cd5dfc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fed390c8-3e08-4d00-88c1-15b05dbb52a9", "node_type": "1", "metadata": {}, "hash": "4628eeab8e4528a32a5a20529ffbcfaeee6d992a833afeaade3a65970ac45b4b", "class_name": "RelatedNodeInfo"}}, "text": "Each core is well-suited to executing a wide range of in-\nstructions, with branch predictors, a deep pipeline, specialized execution units, speculative\n273 Deep Convolutional Neural Networks (AlexNet)\n127execution, and many other bells and whistles that enable it to run a large variety of pro-\ngrams with sophisticated control flow. This apparent strength, however, is also its Achilles\nheel: general-purpose cores are very expensive to build. They excel at general-purpose\ncode with lots of control flow. This requires lots of chip area, not just for the actual ALU\n(arithmetic logical unit) where computation happens, but also for all the aforementioned\nbells and whistles, plus memory interfaces, caching logic between cores, high-speed in-\nterconnects, and so on. CPUs are comparatively bad at any single task when compared\nwithdedicatedhardware. Modernlaptopshave4\u20138cores,andevenhigh-endserversrarely\nexceed 64 cores per socket, simply because it is not cost-effective.\nBy comparison, GPUs can consist of thousands of small processing elements (NIVIDA\u2019s\nlatestAmperechipshaveupto6912CUDAcores),oftengroupedintolargergroups(NVIDIA\ncalls them warps). The details differ somewhat between NVIDIA, AMD, ARM and other\nchip vendors. While each core is relatively weak, running at about 1GHz clock frequency,\nit is the total number of such cores that makes GPUs orders of magnitude faster than\nCPUs. For instance, NVIDIA\u2019s recent Ampere A100 GPU offers over 300 TFLOPs per\nchip for specialized 16-bit precision (BFLOAT16) matrix-matrix multiplications, and up\nto 20 TFLOPs for more general-purpose floating point operations (FP32). At the same\ntime, floating point performance of CPUs rarely exceeds 1 TFLOPs. For instance, Ama-\nzon\u2019s Graviton 3 reaches 2 TFLOPs peak performance for 16-bit precision operations, a\nnumber similar to the GPU performance of Apple\u2019s M1 processor.\nThere are many reasons why GPUs are much faster than CPUs in terms of FLOPs. First,\npowerconsumptiontendstogrow quadratically withclockfrequency. Hence,forthepower\nbudget of a CPU core that runs four times faster (a typical number), you can use 16 GPU\ncoresat1\n4thespeed,whichyields 16\u00021\n4=4timestheperformance. Second,GPUcoresare\nmuch simpler (in fact, for a long time they were not even ableto execute general-purpose\ncode), which makes them more energy efficient. For instance, (i) they tend not to support\nspeculative evaluation, (ii) it typically is not possible to program each processing element\nindividually, and (iii) the caches per core tend to be much smaller. Last, many operations\nin deep learning require high memory bandwidth. Again, GPUs shine here with buses that\nare at least 10 times as wide as many CPUs.\nBack to 2012. A major breakthrough came when Alex Krizhevsky and Ilya Sutskever im-\nplemented a deep CNN that could run on GPUs. They realized that the computational bot-\ntlenecksinCNNs, convolutionsandmatrixmultiplications, arealloperationsthatcouldbe\nparallelized in hardware. Using two NVIDIA GTX 580s with 3GB of memory, either of\nwhichwascapableof1.5TFLOPs(stillachallengeformostCPUsadecadelater),theyim-\nplemented fast convolutions. The cuda-convnet127code was good enough that for several\nyearsitwastheindustrystandardandpoweredthefirstcoupleofyearsofthedeeplearning\nboom.\n8.1.2AlexNet\nAlexNet, which employed an 8-layer CNN, won the ImageNet Large Scale Visual Recog-\nnition Challenge 2012 by a large margin ( Russakovsky etal., 2013). This network showed,\n274 Modern Convolutional Neural Networks\nfor the first time, that the features obtained by learning can transcend manually-designed\nfeatures, breaking the previous paradigm in computer vision.\nThearchitecturesofAlexNetandLeNetarestrikinglysimilar,as Fig.8.1.2 illustrates. Note\nthat we provide a slightly streamlined version of AlexNet removing some of the design\nquirks that were needed in 2012 to make the model fit on two small GPUs.\ntFig. 8.1.2 From LeNet (left) to AlexNet (right).\nThere are also significant differences between AlexNet and LeNet. First, AlexNet is much\ndeeper than the comparatively small LeNet-5.", "mimetype": "text/plain", "start_char_idx": 663718, "end_char_idx": 667804, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fed390c8-3e08-4d00-88c1-15b05dbb52a9": {"__data__": {"id_": "fed390c8-3e08-4d00-88c1-15b05dbb52a9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b3d4a14b-7cb4-4b47-96df-be0f4d0d5cd6", "node_type": "1", "metadata": {}, "hash": "5734935572227d13eff3cb2827672f6627060ff54c010cce7100d9cde5b99990", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "45897cfe-f088-425e-b3ed-d4763fd766ed", "node_type": "1", "metadata": {}, "hash": "0620f8c778829b3025e2156a814351896ddf143c261630c5824e901268987d71", "class_name": "RelatedNodeInfo"}}, "text": "This network showed,\n274 Modern Convolutional Neural Networks\nfor the first time, that the features obtained by learning can transcend manually-designed\nfeatures, breaking the previous paradigm in computer vision.\nThearchitecturesofAlexNetandLeNetarestrikinglysimilar,as Fig.8.1.2 illustrates. Note\nthat we provide a slightly streamlined version of AlexNet removing some of the design\nquirks that were needed in 2012 to make the model fit on two small GPUs.\ntFig. 8.1.2 From LeNet (left) to AlexNet (right).\nThere are also significant differences between AlexNet and LeNet. First, AlexNet is much\ndeeper than the comparatively small LeNet-5. AlexNet consists of eight layers: five con-\nvolutional layers, two fully connected hidden layers, and one fully connected output layer.\nSecond, AlexNet used the ReLU instead of the sigmoid as its activation function. Let\u2019s\ndelve into the details below.\nArchitecture\nIn AlexNet\u2019s first layer, the convolution window shape is 11\u000211. Since the images in\nImageNet are eight times taller and wider than the MNIST images, objects in ImageNet\ndatatendtooccupymorepixelswithmorevisualdetail. Consequently,alargerconvolution\nwindow is needed to capture the object. The convolution window shape in the second\nlayer is reduced to 5\u00025, followed by 3\u00023. In addition, after the first, second, and fifth\nconvolutional layers, the network adds max-pooling layers with a window shape of 3\u0002\n3and a stride of 2. Moreover, AlexNet has ten times more convolution channels than\nLeNet.\nAfterthefinalconvolutionallayer,therearetwohugefullyconnectedlayerswith4096out-\nputs. These layers require nearly 1GB model parameters. Because of the limited memory\n275 Deep Convolutional Neural Networks (AlexNet)\nin early GPUs, the original AlexNet used a dual data stream design, so that each of their\ntwoGPUscouldberesponsibleforstoringandcomputingonlyitshalfofthemodel. Fortu-\nnately,GPUmemoryiscomparativelyabundantnow,sowerarelyneedtobreakupmodels\nacrossGPUsthesedays(ourversionoftheAlexNetmodeldeviatesfromtheoriginalpaper\nin this aspect).\nActivationFunctions\nFurthermore, AlexNet changed the sigmoid activation function to a simpler ReLU activa-\ntionfunction. Ontheonehand,thecomputationoftheReLUactivationfunctionissimpler.\nFor example, it does not have the exponentiation operation found in the sigmoid activation\nfunction. On the other hand, the ReLU activation function makes model training easier\nwhen using different parameter initialization methods. This is because, when the output\nof the sigmoid activation function is very close to 0 or 1, the gradient of these regions is\nalmost0,sothatbackpropagationcannotcontinuetoupdatesomeofthemodelparameters.\nBycontrast,thegradientoftheReLUactivationfunctioninthepositiveintervalisalways1\n(Section5.1.2 ). Therefore,ifthemodelparametersarenotproperlyinitialized,thesigmoid\nfunction may obtain a gradient of almost 0 in the positive interval, meaning that the model\ncannot be effectively trained.\nCapacity Controland Preprocessing\nAlexNet controls the model complexity of the fully connected layer by dropout ( Section\n5.6), while LeNet only uses weight decay. To augment the data even further, the training\nloop of AlexNet added a great deal of image augmentation, such as flipping, clipping, and\ncolor changes. This makes the model more robust and the larger sample size effectively\nreduces overfitting. See Buslaev etal.(2020) for an in-depth review of such preprocessing\nsteps.", "mimetype": "text/plain", "start_char_idx": 667163, "end_char_idx": 670608, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "45897cfe-f088-425e-b3ed-d4763fd766ed": {"__data__": {"id_": "45897cfe-f088-425e-b3ed-d4763fd766ed", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fed390c8-3e08-4d00-88c1-15b05dbb52a9", "node_type": "1", "metadata": {}, "hash": "4628eeab8e4528a32a5a20529ffbcfaeee6d992a833afeaade3a65970ac45b4b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5e2f4c66-8ac8-4a1d-96e2-07185610c734", "node_type": "1", "metadata": {}, "hash": "26c225150baf99081e477f870b14f01f97c768b65e1a28272efaa76c3381cc26", "class_name": "RelatedNodeInfo"}}, "text": "Bycontrast,thegradientoftheReLUactivationfunctioninthepositiveintervalisalways1\n(Section5.1.2 ). Therefore,ifthemodelparametersarenotproperlyinitialized,thesigmoid\nfunction may obtain a gradient of almost 0 in the positive interval, meaning that the model\ncannot be effectively trained.\nCapacity Controland Preprocessing\nAlexNet controls the model complexity of the fully connected layer by dropout ( Section\n5.6), while LeNet only uses weight decay. To augment the data even further, the training\nloop of AlexNet added a great deal of image augmentation, such as flipping, clipping, and\ncolor changes. This makes the model more robust and the larger sample size effectively\nreduces overfitting. See Buslaev etal.(2020) for an in-depth review of such preprocessing\nsteps.\nclass AlexNet (d2l .Classifier):\ndef __init__ (self , lr =0.1, num_classes =10):\nsuper ().__init__ ()\nself .save_hyperparameters()\nself .net =nn.Sequential(\nnn.LazyConv2d( 96, kernel_size =11, stride =4, padding =1),\nnn.ReLU(), nn .MaxPool2d(kernel_size =3, stride =2),\nnn.LazyConv2d( 256, kernel_size =5, padding =2), nn .ReLU(),\nnn.MaxPool2d(kernel_size =3, stride =2),\nnn.LazyConv2d( 384, kernel_size =3, padding =1), nn .ReLU(),\nnn.LazyConv2d( 384, kernel_size =3, padding =1), nn .ReLU(),\nnn.LazyConv2d( 256, kernel_size =3, padding =1), nn .ReLU(),\nnn.MaxPool2d(kernel_size =3, stride =2), nn .Flatten(),\nnn.LazyLinear( 4096 ), nn .ReLU(), nn .Dropout(p =0.5),\nnn.LazyLinear( 4096 ), nn .ReLU(),nn .Dropout(p =0.5),\nnn.LazyLinear(num_classes))\nself .net.apply(d2l .init_cnn)\nWe construct a single-channel data example with both height and width of 224 to observe\nthe output shape of each layer. It matches the AlexNet architecture in Fig. 8.1.2 .\n276 Modern Convolutional Neural Networks\nAlexNet() .layer_summary(( 1,1,224,224))\nConv2d output shape: torch .Size([ 1,96,54,54])\nReLU output shape: torch .Size([ 1,96,54,54])\nMaxPool2d output shape: torch .Size([ 1,96,26,26])\nConv2d output shape: torch .Size([ 1,256,26,26])\nReLU output shape: torch .Size([ 1,256,26,26])\nMaxPool2d output shape: torch .Size([ 1,256,12,12])\nConv2d output shape: torch .Size([ 1,384,12,12])\nReLU output shape: torch .Size([ 1,384,12,12])\nConv2d output shape: torch .Size([ 1,384,12,12])\nReLU output shape: torch .Size([ 1,384,12,12])\nConv2d output shape: torch .Size([ 1,256,12,12])\nReLU output shape: torch .Size([ 1,256,12,12])\nMaxPool2d output shape: torch .Size([ 1,256,5,5])\nFlatten output shape: torch .Size([ 1,6400 ])\nLinear output shape: torch .Size([ 1,4096 ])\nReLU output shape: torch .Size([ 1,4096 ])\nDropout output shape: torch .Size([ 1,4096 ])\nLinear output shape: torch .Size([ 1,4096 ])\nReLU output shape: torch .Size([ 1,4096 ])\nDropout output shape: torch .Size([ 1,4096 ])\nLinear output shape: torch .Size([ 1,10])\n8.1.3Training\nAlthough AlexNet was trained on ImageNet in Krizhevsky et al.(2012), we use Fashion-\nMNIST here since training an ImageNet model to convergence could take hours or days\neven on a modern GPU. One of the problems with applying AlexNet directly on Fashion-\nMNIST is that its images have lower resolution ( 28\u000228pixels) than ImageNet images. To\nmakethingswork,weupsamplethemto 224\u0002224. Thisisgenerallynotasmartpractice,as\nitsimplyincreasesthecomputationalcomplexitywithoutaddinginformation.", "mimetype": "text/plain", "start_char_idx": 669837, "end_char_idx": 673131, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5e2f4c66-8ac8-4a1d-96e2-07185610c734": {"__data__": {"id_": "5e2f4c66-8ac8-4a1d-96e2-07185610c734", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "45897cfe-f088-425e-b3ed-d4763fd766ed", "node_type": "1", "metadata": {}, "hash": "0620f8c778829b3025e2156a814351896ddf143c261630c5824e901268987d71", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "09900028-e59a-4225-9d3e-636b0028bb0d", "node_type": "1", "metadata": {}, "hash": "c7010f76ea10723b7c29302085c150dc770a034a386bc65701f7d5b726c8d0dc", "class_name": "RelatedNodeInfo"}}, "text": "(2012), we use Fashion-\nMNIST here since training an ImageNet model to convergence could take hours or days\neven on a modern GPU. One of the problems with applying AlexNet directly on Fashion-\nMNIST is that its images have lower resolution ( 28\u000228pixels) than ImageNet images. To\nmakethingswork,weupsamplethemto 224\u0002224. Thisisgenerallynotasmartpractice,as\nitsimplyincreasesthecomputationalcomplexitywithoutaddinginformation. Nonetheless,\nwe do it here to be faithful to the AlexNet architecture. We perform this resizing with the\nresizeargument in the d2l.FashionMNIST constructor.\nNow, we can start training AlexNet. Compared to LeNet in Section 7.6 , the main change\nhere is the use of a smaller learning rate and much slower training due to the deeper and\nwider network, the higher image resolution, and the more costly convolutions.\nmodel =AlexNet(lr =0.01 )\ndata =d2l.FashionMNIST(batch_size =128, resize =(224,224))\ntrainer =d2l.Trainer(max_epochs =10, num_gpus =1)\ntrainer .fit(model, data)\n8.1.4Discussion\nAlexNet\u2019s structure bears a striking resemblance to LeNet, with a number of critical im-\nprovements, both for accuracy (dropout) and for ease of training (ReLU). What is equally\nstriking is the amount of progress that has been made in terms of deep learning tooling.\n277 Deep Convolutional Neural Networks (AlexNet)\nWhat was several months of work in 2012 can now be accomplished in a dozen lines of\ncode using any modern framework.\nReviewingthe architecture, wesee thatAlexNethas anAchillesheel whenit comes toeffi-\nciency: thelasttwohiddenlayersrequirematricesofsize 6400\u00024096and4096\u00024096,re-\nspectively. This corresponds to 164 MB of memory and 81 MFLOPs of computation, both\nofwhichareanontrivialoutlay,especiallyonsmallerdevices,suchasmobilephones. This\nisoneofthereasonswhyAlexNethasbeensurpassedbymuchmoreeffectivearchitectures\nthat we will cover in the following sections. Nonetheless, it is a key step from shallow to\ndeep networks that are used nowadays. Note that even though the number of parameters\nexceedsbyfartheamountoftrainingdatainourexperiments(thelasttwolayershavemore\nthan 40 million parameters, trained on a datasets of 60 thousand images), there is hardly\nanyoverfitting: trainingandvalidationlossarevirtuallyidenticalthroughouttraining. This\nis due to the improved regularization, such as dropout, inherent in modern deep network\ndesigns.\nAlthough it seems that there are only a few more lines in AlexNet\u2019s implementation than\ninLeNet\u2019s, ittooktheacademiccommunitymanyyearstoembracethisconceptualchange\nand take advantage of its excellent experimental results. This was also due to the lack of\nefficient computational tools. At the time neither DistBelief ( Deanet al., 2012) nor Caffe\n(Jiaetal.,2014)existed,andTheano( Bergstraetal.,2010)stilllackedmanydistinguishing\nfeatures. ItwastheavailabilityofTensorFlow( Abadietal.,2016)thatdramaticallychanged\nthe situation.\n8.1.5Exercises\n1.Followinguponthediscussionabove,analyzethecomputationalpropertiesofAlexNet.\n1.Compute the memory footprint for convolutions and fully connected layers, respec-\ntively. Which one dominates?\n2.Calculatethecomputationalcostfortheconvolutionsandthefullyconnectedlayers.\n3.Howdoesthememory(readandwritebandwidth,latency,size)affectcomputation?\nIs there any difference in its effects for training and inference?\n2.You are a chip designer and need to trade off computation and memory bandwidth.\nFor example, a faster chip requires more power and possibly a larger chip area. More\n278 Modern Convolutional Neural Networks\n128memory bandwidth requires more pins and control logic, thus also more area. How do\nyou optimize?\n3.Why do engineers no longer report performance benchmarks on AlexNet?\n4.Try increasing the number of epochs when training AlexNet. Compared with LeNet,\nhow do the results differ? Why?\n5.AlexNet may be too complex for the Fashion-MNIST dataset, in particular due to the\nlow resolution of the initial images.\n1.Try simplifying the model to make the training faster, while ensuring that the accu-\nracy does not drop significantly.", "mimetype": "text/plain", "start_char_idx": 672706, "end_char_idx": 676772, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "09900028-e59a-4225-9d3e-636b0028bb0d": {"__data__": {"id_": "09900028-e59a-4225-9d3e-636b0028bb0d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5e2f4c66-8ac8-4a1d-96e2-07185610c734", "node_type": "1", "metadata": {}, "hash": "26c225150baf99081e477f870b14f01f97c768b65e1a28272efaa76c3381cc26", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "01356ff9-3de9-4b85-a286-ea2d0cff02dc", "node_type": "1", "metadata": {}, "hash": "c1ec60e9d83750cba1e048d4299fc4d3ff05e731df6b92693b7c25b1d5597d06", "class_name": "RelatedNodeInfo"}}, "text": "3.Howdoesthememory(readandwritebandwidth,latency,size)affectcomputation?\nIs there any difference in its effects for training and inference?\n2.You are a chip designer and need to trade off computation and memory bandwidth.\nFor example, a faster chip requires more power and possibly a larger chip area. More\n278 Modern Convolutional Neural Networks\n128memory bandwidth requires more pins and control logic, thus also more area. How do\nyou optimize?\n3.Why do engineers no longer report performance benchmarks on AlexNet?\n4.Try increasing the number of epochs when training AlexNet. Compared with LeNet,\nhow do the results differ? Why?\n5.AlexNet may be too complex for the Fashion-MNIST dataset, in particular due to the\nlow resolution of the initial images.\n1.Try simplifying the model to make the training faster, while ensuring that the accu-\nracy does not drop significantly.\n2.Design a better model that works directly on 28\u000228images.\n6.Modify the batch size, and observe the changes in throughput (images/s), accuracy, and\nGPU memory.\n7.ApplydropoutandReLUtoLeNet-5. Doesitimprove? Canyouimprovethingsfurther\nby preprocessing to take advantage of the invariances inherent in the images?\n8.CanyoumakeAlexNetoverfit? Whichfeaturedoyouneedtoremoveorchangetobreak\ntraining?\nDiscussions128.\n8.2NetworksUsing Blocks(VGG)\nWhile AlexNet offered empirical evidence that deep CNNs can achieve good results, it did\nnot provide a general template to guide subsequent researchers in designing new networks.\nIn the following sections, we will introduce several heuristic concepts commonly used to\ndesign deep networks.\nProgressinthisfieldmirrorsthatofVLSI(verylargescaleintegration)inchipdesignwhere\nengineersmovedfromplacingtransistorstologicalelementstologicblocks( Mead,1980 ).\nSimilarly,thedesignofneuralnetworkarchitectureshasgrownprogressivelymoreabstract,\nwith researchers moving from thinking in terms of individual neurons to whole layers,\nand now to blocks, repeating patterns of layers. A decade later, this has now progressed\nto researchers using entire trained models to repurpose them for different, albeit related,\ntasks. Such large pretrained models are typically called foundationmodels (Bommasani et\nal., 2021).\nBack to network design. The idea of using blocks first emerged from the Visual Geometry\nGroup(VGG)atOxfordUniversity,intheireponymously-named VGGnetwork( Simonyan\nand Zisserman, 2014 ). It is easy to implement these repeated structures in code with any\nmodern deep learning framework by using loops and subroutines.\n279 Networks Using Blocks (VGG)\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n8.2.1VGGBlocks\nThe basic building block of CNNs is a sequence of the following: (i) a convolutional layer\nwith padding to maintain the resolution, (ii) a nonlinearity such as a ReLU, (iii) a pooling\nlayersuchasmax-poolingtoreducetheresolution. Oneoftheproblemswiththisapproach\nis that the spatial resolution decreases quite rapidly. In particular, this imposes a hard limit\noflog2\ud835\udc51convolutional layers on the network before all dimensions ( \ud835\udc51) are used up. For\ninstance,inthecaseofImageNet,itwouldbeimpossibletohavemorethan8convolutional\nlayers in this way.\nThe key idea of Simonyan and Zisserman ( 2014) was to use multiple convolutions in be-\ntween downsampling via max-pooling in the form of a block. They were primarily in-\nterested in whether deep or wide networks perform better. For instance, the successive\napplication of two 3\u00023convolutions touches the same pixels as a single 5\u00025convolution\ndoes. At the same time, the latter uses approximately as many parameters ( 25\u0001\ud835\udc502) as three\n3\u00023convolutionsdo( 3\u00019\u0001\ud835\udc502). Inaratherdetailedanalysistheyshowedthatdeepandnar-\nrow networks significantly outperform their shallow counterparts. This set deep learning\non a quest for ever deeper networks with over 100 layers for typical applications. Stacking\n3\u00023convolutions has become a gold standard in later deep networks (a design decision\nonly to be revisited recently by Liu et al.(2022)). Consequently, fast implementations for\nsmall convolutions have become a staple on GPUs ( Lavin and Gray, 2016 ).", "mimetype": "text/plain", "start_char_idx": 675896, "end_char_idx": 680026, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "01356ff9-3de9-4b85-a286-ea2d0cff02dc": {"__data__": {"id_": "01356ff9-3de9-4b85-a286-ea2d0cff02dc", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "09900028-e59a-4225-9d3e-636b0028bb0d", "node_type": "1", "metadata": {}, "hash": "c7010f76ea10723b7c29302085c150dc770a034a386bc65701f7d5b726c8d0dc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "944d2286-9133-41f9-9b88-0d2922b66104", "node_type": "1", "metadata": {}, "hash": "deafe76d0b536041e29931409c831e508c164d2f9fc7e4b41a3c214e389f31ed", "class_name": "RelatedNodeInfo"}}, "text": "They were primarily in-\nterested in whether deep or wide networks perform better. For instance, the successive\napplication of two 3\u00023convolutions touches the same pixels as a single 5\u00025convolution\ndoes. At the same time, the latter uses approximately as many parameters ( 25\u0001\ud835\udc502) as three\n3\u00023convolutionsdo( 3\u00019\u0001\ud835\udc502). Inaratherdetailedanalysistheyshowedthatdeepandnar-\nrow networks significantly outperform their shallow counterparts. This set deep learning\non a quest for ever deeper networks with over 100 layers for typical applications. Stacking\n3\u00023convolutions has become a gold standard in later deep networks (a design decision\nonly to be revisited recently by Liu et al.(2022)). Consequently, fast implementations for\nsmall convolutions have become a staple on GPUs ( Lavin and Gray, 2016 ).\nBack to VGG: a VGG block consists of a sequence of convolutions with 3\u00023kernels with\npadding of 1 (keeping height and width) followed by a 2\u00022max-pooling layer with stride\nof 2 (halving height and width after each block). In the code below, we define a function\ncalled vgg_block to implement one VGG block.\nThe function below takes two arguments, corresponding to the number of convolutional\nlayers num_convs and the number of output channels num_channels .\ndef vgg_block (num_convs, out_channels):\nlayers =[]\nfor _inrange (num_convs):\nlayers .append(nn .LazyConv2d(out_channels, kernel_size =3, padding =1))\nlayers .append(nn .ReLU())\nlayers .append(nn .MaxPool2d(kernel_size =2,stride =2))\nreturn nn.Sequential( *layers)\n8.2.2VGGNetwork\nLike AlexNet and LeNet, the VGG Network can be partitioned into two parts: the first\nconsisting mostly of convolutional and pooling layers and the second consisting of fully\n280 Modern Convolutional Neural Networks\nconnected layers that are identical to those in AlexNet. The key difference is that the con-\nvolutional layers are grouped in nonlinear transformations that leave the dimensonality un-\nchanged, followed by a resolution-reduction step, as depicted in Fig. 8.2.1 .\ntFig. 8.2.1 From AlexNet to VGG. The key difference is that VGG consists of blocks of layers,\nwhereas AlexNet\u2019s layers are all designed individually.\nThe convolutional part of the network connects several VGG blocks from Fig. 8.2.1 (also\ndefined in the vgg_block function) in succession. This grouping of convolutions is a pat-\ntern that has remained almost unchanged over the past decade, although the specific choice\nof operations has undergone considerable modifications. The variable archconsists of a\nlist of tuples (one per block), where eachcontains two values: the number of convolutional\nlayers and the number of output channels, which are precisely the arguments required to\ncall the vgg_block function. As such, VGG defines a familyof networks rather than just a\nspecific manifestation. To build a specific network we simply iterate over archto compose\nthe blocks.\nclass VGG(d2l .Classifier):\ndef __init__ (self , arch, lr =0.1, num_classes =10):\nsuper ().__init__ ()\nself .save_hyperparameters()\nconv_blks =[]\nfor (num_convs, out_channels) inarch:\nconv_blks .append(vgg_block(num_convs, out_channels))\nself .net =nn.Sequential(\n*conv_blks, nn .Flatten(),\n(continues on next page)\n281 Networks Using Blocks (VGG)\n(continued from previous page)\nnn.LazyLinear( 4096 ), nn .ReLU(), nn .Dropout( 0.5),\nnn.LazyLinear( 4096 ), nn .ReLU(), nn .Dropout( 0.5),\nnn.LazyLinear(num_classes))\nself .net.apply(d2l .init_cnn)\nThe original VGG network had five convolutional blocks, among which the first two have\noneconvolutionallayereachandthelatterthreecontaintwoconvolutionallayerseach. The\nfirst blockhas 64 output channelsand each subsequentblockdoubles the number of output\nchannels,untilthatnumberreaches512. Sincethisnetworkuseseightconvolutionallayers\nand three fully connected layers, it is often called VGG-11.", "mimetype": "text/plain", "start_char_idx": 679229, "end_char_idx": 683061, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "944d2286-9133-41f9-9b88-0d2922b66104": {"__data__": {"id_": "944d2286-9133-41f9-9b88-0d2922b66104", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "01356ff9-3de9-4b85-a286-ea2d0cff02dc", "node_type": "1", "metadata": {}, "hash": "c1ec60e9d83750cba1e048d4299fc4d3ff05e731df6b92693b7c25b1d5597d06", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "64f8e839-7502-4a3d-b88d-d2aaea3e8513", "node_type": "1", "metadata": {}, "hash": "6d4e20b9376352be4a20fbf52a0b6adefe6d91be06c0b41e946829ee84bec093", "class_name": "RelatedNodeInfo"}}, "text": "The\nfirst blockhas 64 output channelsand each subsequentblockdoubles the number of output\nchannels,untilthatnumberreaches512. Sincethisnetworkuseseightconvolutionallayers\nand three fully connected layers, it is often called VGG-11.\nVGG(arch =((1,64), ( 1,128), ( 2,256), ( 2,512), ( 2,512))).layer_summary(\n(1,1,224,224))\nSequential output shape: torch .Size([ 1,64,112,112])\nSequential output shape: torch .Size([ 1,128,56,56])\nSequential output shape: torch .Size([ 1,256,28,28])\nSequential output shape: torch .Size([ 1,512,14,14])\nSequential output shape: torch .Size([ 1,512,7,7])\nFlatten output shape: torch .Size([ 1,25088 ])\nLinear output shape: torch .Size([ 1,4096 ])\nReLU output shape: torch .Size([ 1,4096 ])\nDropout output shape: torch .Size([ 1,4096 ])\nLinear output shape: torch .Size([ 1,4096 ])\nReLU output shape: torch .Size([ 1,4096 ])\nDropout output shape: torch .Size([ 1,4096 ])\nLinear output shape: torch .Size([ 1,10])\nAsyoucansee,wehalveheightandwidthateachblock,finallyreachingaheightandwidth\nof 7 before flattening the representations for processing by the fully connected part of the\nnetwork. Simonyan and Zisserman ( 2014) described several other variants of VGG. In\nfact,ithasbecomethenormtopropose families ofnetworkswithdifferentspeed\u2013accuracy\ntrade-off when introducing a new architecture.\n8.2.3Training\nSince VGG-11 is computationally more demanding than AlexNet we construct a network\nwith a smaller number of channels. This is more than sufficient for training on Fashion-\nMNIST. The model training process is similar to that of AlexNet in Section 8.1 . Again ob-\nservetheclosematchbetweenvalidationandtrainingloss, suggestingonlyasmallamount\nof overfitting.\nmodel =VGG(arch =((1,16), ( 1,32), ( 2,64), ( 2,128), ( 2,128)), lr =0.01 )\ntrainer =d2l.Trainer(max_epochs =10, num_gpus =1)\ndata =d2l.FashionMNIST(batch_size =128, resize =(224,224))\nmodel .apply_init([ next (iter (data .get_dataloader( True )))[ 0]], d2l .init_cnn)\ntrainer .fit(model, data)\n282 Modern Convolutional Neural Networks\n8.2.4Summary\nOne might argue that VGG is the first truly modern convolutional neural network. While\nAlexNetintroducedmanyofthecomponentsofwhatmakedeeplearningeffectiveatscale,\nit is VGG that arguably introduced key properties such as blocks of multiple convolutions\nand a preference for deep and narrow networks. It is also the first network that is actually\nan entire family of similarly parametrized models, giving the practitioner ample trade-off\nbetween complexity and speed. This is also the place where modern deep learning frame-\nworks shine. It is no longer necessary to generate XML configuration files to specify a\nnetwork but rather, to assemble said networks through simple Python code.\nMore recently ParNet ( Goyalet al., 2021) demonstrated that it is possible to achieve com-\npetitive performance using a much more shallow architecture through a large number of\nparallel computations. This is an exciting development and there is hope that it will influ-\nence architecture designs in the future. For the remainder of the chapter, though, we will\nfollow the path of scientific progress over the past decade.\n8.2.5Exercises\n1.ComparedwithAlexNet,VGGismuchslowerintermsofcomputation,anditalsoneeds\nmore GPU memory.\n1.Compare the number of parameters needed for AlexNet and VGG.\n2.Compare the number of floating point operations used in the convolutional layers\nand in the fully connected layers.\n3.How could you reduce the computational cost created by the fully connected layers?\n2.When displaying the dimensions associated with the various layers of the network, we\nonly see the information associated with eight blocks (plus some auxiliary transforms),\neven though the network has 11 layers. Where did the remaining three layers go?", "mimetype": "text/plain", "start_char_idx": 682830, "end_char_idx": 686607, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "64f8e839-7502-4a3d-b88d-d2aaea3e8513": {"__data__": {"id_": "64f8e839-7502-4a3d-b88d-d2aaea3e8513", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "944d2286-9133-41f9-9b88-0d2922b66104", "node_type": "1", "metadata": {}, "hash": "deafe76d0b536041e29931409c831e508c164d2f9fc7e4b41a3c214e389f31ed", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "78b814a9-6089-45aa-abdc-b6e1787db1b7", "node_type": "1", "metadata": {}, "hash": "25b6b3154b0d712216b23fe1177c983eb704c56bd9e23ce6ae4c2ce570c3bcd8", "class_name": "RelatedNodeInfo"}}, "text": "This is an exciting development and there is hope that it will influ-\nence architecture designs in the future. For the remainder of the chapter, though, we will\nfollow the path of scientific progress over the past decade.\n8.2.5Exercises\n1.ComparedwithAlexNet,VGGismuchslowerintermsofcomputation,anditalsoneeds\nmore GPU memory.\n1.Compare the number of parameters needed for AlexNet and VGG.\n2.Compare the number of floating point operations used in the convolutional layers\nand in the fully connected layers.\n3.How could you reduce the computational cost created by the fully connected layers?\n2.When displaying the dimensions associated with the various layers of the network, we\nonly see the information associated with eight blocks (plus some auxiliary transforms),\neven though the network has 11 layers. Where did the remaining three layers go?\n3.UseTable1intheVGGpaper( SimonyanandZisserman,2014 )toconstructothercom-\nmon models, such as VGG-16 or VGG-19.\n4.Upsampling the resolution in Fashion-MNIST eight-fold from 28\u000228to224\u0002224\ndimensions is very wasteful. Try modifying the network architecture and resolution\nconversion, e.g., to 56 or to 84 dimensions for its input instead. Can you do so without\n283 Network in Network (NiN)\n129reducing the accuracy of the network? Consult the VGG paper ( Simonyan and Zisser-\nman, 2014 ) for ideas on adding more nonlinearities prior to downsampling.\nDiscussions129.\n8.3Networkin Network(NiN)\nLeNet, AlexNet, and VGG all share a common design pattern: extract features exploiting\nspatialstructure via a sequence of convolutions and pooling layers and post-process the\nrepresentations via fully connected layers. The improvements upon LeNet by AlexNet and\nVGG mainly lie in how these later networks widen and deepen these two modules.\nThis design poses two major challenges. First, the fully connected layers at the end of\nthe architecture consume tremendous numbers of parameters. For instance, even a simple\nmodel such as VGG-11 requires a monstrous matrix, occupying almost 400MB of RAM\nin single precision (FP32). This is a significant impediment to computation, in particular\non mobile and embedded devices. After all, even high-end mobile phones sport no more\nthan 8GB of RAM. At the time VGG was invented, this was an order of magnitude less\n(the iPhone 4S had 512MB). As such, it would have been difficult to justify spending the\nmajority of memory on an image classifier.\nSecond, it is equally impossible to add fully connected layers earlier in the network to\nincreasethedegreeofnonlinearity: doingsowoulddestroythespatialstructureandrequire\npotentially even more memory.\nThenetwork in network (NiN) blocks ( Linet al., 2013) offer an alternative, capable of\nsolving both problems in one simple strategy. They were proposed based on a very simple\ninsight: (i) use 1\u00021convolutions to add local nonlinearities across the channel activations\nand(ii)useglobalaveragepoolingtointegrateacrossalllocationsinthelastrepresentation\nlayer. Note that global average pooling would not be effective, were it not for the added\nnonlinearities. Let\u2019s dive into this in detail.\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n8.3.1NiN Blocks\nRecallSection7.4.3 . Initwesaidthattheinputsandoutputsofconvolutionallayersconsist\nof four-dimensional tensors with axes corresponding to the example, channel, height, and\nwidth. Also recall that the inputs and outputs of fully connected layers are typically two-\ndimensional tensors corresponding to the example and feature. The idea behind NiN is\nto apply a fully connected layer at each pixel location (for each height and width). The\n284 Modern Convolutional Neural Networks\nresulting 1\u00021convolutioncanbethoughtofasafullyconnectedlayeractingindependently\non each pixel location.\nFig.8.3.1 illustratesthemainstructuraldifferencesbetweenVGGandNiN,andtheirblocks.\nNoteboththedifferenceintheNiNblocks(theinitialconvolutionisfollowedby 1\u00021con-\nvolutions, whereas VGG retains 3\u00023convolutions) and at the end where we no longer\nrequire a giant fully connected layer.\ntFig. 8.3.1 Comparing the architectures of VGG and NiN, and of their blocks.", "mimetype": "text/plain", "start_char_idx": 685760, "end_char_idx": 689894, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "78b814a9-6089-45aa-abdc-b6e1787db1b7": {"__data__": {"id_": "78b814a9-6089-45aa-abdc-b6e1787db1b7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "64f8e839-7502-4a3d-b88d-d2aaea3e8513", "node_type": "1", "metadata": {}, "hash": "6d4e20b9376352be4a20fbf52a0b6adefe6d91be06c0b41e946829ee84bec093", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "12c17f23-ca2a-4b5d-a896-8bfcef37b213", "node_type": "1", "metadata": {}, "hash": "b3360aeafe2ad36f6dd4ff9b970dae1078433d9e12a9bddf1d4b9cbf4bfff69e", "class_name": "RelatedNodeInfo"}}, "text": "Also recall that the inputs and outputs of fully connected layers are typically two-\ndimensional tensors corresponding to the example and feature. The idea behind NiN is\nto apply a fully connected layer at each pixel location (for each height and width). The\n284 Modern Convolutional Neural Networks\nresulting 1\u00021convolutioncanbethoughtofasafullyconnectedlayeractingindependently\non each pixel location.\nFig.8.3.1 illustratesthemainstructuraldifferencesbetweenVGGandNiN,andtheirblocks.\nNoteboththedifferenceintheNiNblocks(theinitialconvolutionisfollowedby 1\u00021con-\nvolutions, whereas VGG retains 3\u00023convolutions) and at the end where we no longer\nrequire a giant fully connected layer.\ntFig. 8.3.1 Comparing the architectures of VGG and NiN, and of their blocks.\ndef nin_block (out_channels, kernel_size, strides, padding):\nreturn nn.Sequential(\nnn.LazyConv2d(out_channels, kernel_size, strides, padding), nn .ReLU(),\nnn.LazyConv2d(out_channels, kernel_size =1), nn .ReLU(),\nnn.LazyConv2d(out_channels, kernel_size =1), nn .ReLU())\n8.3.2NiN Model\nNiNusesthesameinitialconvolutionsizesasAlexNet(itwasproposedshortlythereafter).\nThe kernel sizes are 11\u000211,5\u00025, and 3\u00023, respectively, and the numbers of output\n285 Network in Network (NiN)\nchannelsmatchthoseofAlexNet. EachNiNblockisfollowedbyamax-poolinglayerwith\na stride of 2 and a window shape of 3\u00023.\nThe second significant difference between NiN and both AlexNet and VGG is that NiN\navoids fully connected layers altogether. Instead, NiN uses a NiN block with a number of\noutput channels equal to the number of label classes, followed by a globalaverage pooling\nlayer, yielding a vector of logits. This design significantly reduces the number of required\nmodel parameters, albeit at the expense of a potential increase in training time.\nclass NiN(d2l .Classifier):\ndef __init__ (self , lr =0.1, num_classes =10):\nsuper ().__init__ ()\nself .save_hyperparameters()\nself .net =nn.Sequential(\nnin_block( 96, kernel_size =11, strides =4, padding =0),\nnn.MaxPool2d( 3, stride =2),\nnin_block( 256, kernel_size =5, strides =1, padding =2),\nnn.MaxPool2d( 3, stride =2),\nnin_block( 384, kernel_size =3, strides =1, padding =1),\nnn.MaxPool2d( 3, stride =2),\nnn.Dropout( 0.5),\nnin_block(num_classes, kernel_size =3, strides =1, padding =1),\nnn.AdaptiveAvgPool2d(( 1,1)),\nnn.Flatten())\nself .net.apply(d2l .init_cnn)\nWe create a data example to see the output shape of each block.\nNiN() .layer_summary(( 1,1,224,224))\nSequential output shape: torch .Size([ 1,96,54,54])\nMaxPool2d output shape: torch .Size([ 1,96,26,26])\nSequential output shape: torch .Size([ 1,256,26,26])\nMaxPool2d output shape: torch .Size([ 1,256,12,12])\nSequential output shape: torch .Size([ 1,384,12,12])\nMaxPool2d output shape: torch .Size([ 1,384,5,5])\nDropout output shape: torch .Size([ 1,384,5,5])\nSequential output shape: torch .Size([ 1,10,5,5])\nAdaptiveAvgPool2d output shape: torch .Size([ 1,10,1,1])\nFlatten output shape: torch .Size([ 1,10])\n8.3.3Training\nAsbeforeweuseFashion-MNISTtotrainthemodelusingthesameoptimizerthatweused\nfor AlexNet and VGG.\nmodel =NiN(lr =0.05 )\ntrainer =d2l.Trainer(max_epochs =10, num_gpus =1)\ndata =d2l.FashionMNIST(batch_size =128, resize =(224,224))\nmodel .apply_init([ next (iter (data .get_dataloader( True )))[ 0]], d2l .init_cnn)\ntrainer .fit(model, data)\n286 Modern Convolutional Neural Networks\n8.3.4Summary\nNiN has dramatically fewer parameters than AlexNet and VGG.", "mimetype": "text/plain", "start_char_idx": 689133, "end_char_idx": 692561, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "12c17f23-ca2a-4b5d-a896-8bfcef37b213": {"__data__": {"id_": "12c17f23-ca2a-4b5d-a896-8bfcef37b213", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "78b814a9-6089-45aa-abdc-b6e1787db1b7", "node_type": "1", "metadata": {}, "hash": "25b6b3154b0d712216b23fe1177c983eb704c56bd9e23ce6ae4c2ce570c3bcd8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a2303d8e-5a77-4073-9fc4-08424723d347", "node_type": "1", "metadata": {}, "hash": "29a2998570e0106de59bf4a7ab0523fb643d339fe9deafef891e2fa2e6dce992", "class_name": "RelatedNodeInfo"}}, "text": "model =NiN(lr =0.05 )\ntrainer =d2l.Trainer(max_epochs =10, num_gpus =1)\ndata =d2l.FashionMNIST(batch_size =128, resize =(224,224))\nmodel .apply_init([ next (iter (data .get_dataloader( True )))[ 0]], d2l .init_cnn)\ntrainer .fit(model, data)\n286 Modern Convolutional Neural Networks\n8.3.4Summary\nNiN has dramatically fewer parameters than AlexNet and VGG. This stems primarily from\nthefactthatitneedsnogiantfullyconnectedlayers. Instead, itusesglobalaveragepooling\nto aggregate across all image locations after the last stage of the network body. This obvi-\nates the need for expensive (learned) reduction operations and replaces them by a simple\naverage. What surprised researchers at the time was the fact that this averaging operation\ndid not harm accuracy. Note that averaging across a low-resolution representation (with\nmany channels) also adds to the amount of translation invariance that the network can han-\ndle.\nChoosing fewer convolutions with wide kernels and replacing them by 1\u00021convolutions\naids the quest for fewer parameters further. It can cater for a significant amount of non-\nlinearity across channels within any given location. Both 1\u00021convolutions and global\naverage pooling significantly influenced subsequent CNN designs.\n8.3.5Exercises\n1.Why are there two 1\u00021convolutional layers per NiN block? Increase their number to\nthree. Reduce their number to one. What changes?\n2.What changes if you replace the 1\u00021convolutions by 3\u00023convolutions?\n3.What happens if you replace the global average pooling by a fully connected layer\n(speed, accuracy, number of parameters)?\n4.Calculate the resource usage for NiN.\n1.What is the number of parameters?\n2.What is the amount of computation?\n3.What is the amount of memory needed during training?\n4.What is the amount of memory needed during prediction?\n5.What are possible problems with reducing the 384\u00025\u00025representation to a 10\u00025\u00025\nrepresentation in one step?\n6.Use the structural design decisions in VGG that led to VGG-11, VGG-16, and VGG-19\nto design a family of NiN-like networks.\n287 Multi-Branch Networks (GoogLeNet)\n130Discussions130.\n8.4Multi-BranchNetworks(GoogLeNet)\nIn 2014,GoogLeNet won the ImageNet Challenge ( Szegedyetal., 2015), using a structure\nthat combined the strengths of NiN ( Linetal., 2013), repeated blocks ( Simonyan and Zis-\nserman, 2014 ), and a cocktail of convolution kernels. It was arguablyalso the firstnetwork\nthat exhibited a clear distinction among the stem (data ingest), body (data processing), and\nhead (prediction) in a CNN. This design pattern has persisted ever since in the design of\ndeep networks: the stemis given by the first two or three convolutions that operate on the\nimage. They extract low-level features from the underlying images. This is followed by a\nbodyof convolutional blocks. Finally, the headmaps the features obtained so far to the\nrequired classification, segmentation, detection, or tracking problem at hand.\nThekeycontributioninGoogLeNetwasthedesignofthenetworkbody. Itsolvedtheprob-\nlem of selecting convolution kernels in an ingenious way. While other works tried to iden-\ntifywhichconvolution,rangingfrom 1\u00021to11\u000211wouldbebest,itsimply concatenated\nmulti-branch convolutions. In what follows we introduce a slightly simplified version of\nGoogLeNet: theoriginaldesignincludedanumberoftricksforstabilizingtrainingthrough\nintermediate loss functions, applied to multiple layers of the network. They are no longer\nnecessary due to the availability of improved training algorithms.\nimport torch\nfrom torch import nn\nfrom torch .nnimport functional asF\nfrom d2l import torch asd2l\n8.4.1InceptionBlocks\nThe basic convolutional block in GoogLeNet is called an Inception block , stemming from\nthe meme \u201cwe need to go deeper\u201d from the movie Inception .\ntFig. 8.4.1 Structure of the Inception block.\nAs depicted in Fig. 8.4.1 , the inception block consists of four parallel branches. The first\nthree branches use convolutional layers with window sizes of 1\u00021,3\u00023, and 5\u00025to\nextract information from different spatial sizes.", "mimetype": "text/plain", "start_char_idx": 692207, "end_char_idx": 696251, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a2303d8e-5a77-4073-9fc4-08424723d347": {"__data__": {"id_": "a2303d8e-5a77-4073-9fc4-08424723d347", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "12c17f23-ca2a-4b5d-a896-8bfcef37b213", "node_type": "1", "metadata": {}, "hash": "b3360aeafe2ad36f6dd4ff9b970dae1078433d9e12a9bddf1d4b9cbf4bfff69e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7ae2bcb6-feed-484d-a118-812617939f33", "node_type": "1", "metadata": {}, "hash": "0b5c9a7d96d4d4b3d92dee6209342b9f90ad4464564f7d5cebbbdd234d297302", "class_name": "RelatedNodeInfo"}}, "text": "They are no longer\nnecessary due to the availability of improved training algorithms.\nimport torch\nfrom torch import nn\nfrom torch .nnimport functional asF\nfrom d2l import torch asd2l\n8.4.1InceptionBlocks\nThe basic convolutional block in GoogLeNet is called an Inception block , stemming from\nthe meme \u201cwe need to go deeper\u201d from the movie Inception .\ntFig. 8.4.1 Structure of the Inception block.\nAs depicted in Fig. 8.4.1 , the inception block consists of four parallel branches. The first\nthree branches use convolutional layers with window sizes of 1\u00021,3\u00023, and 5\u00025to\nextract information from different spatial sizes. The middle two branches also add a 1\u00021\n288 Modern Convolutional Neural Networks\nconvolution of the input to reduce the number of channels, reducing the model\u2019s complex-\nity. The fourth branch uses a 3\u00023max-pooling layer, followed by a 1\u00021convolutional\nlayer to change the number of channels. The four branches all use appropriate padding\nto give the input and output the same height and width. Finally, the outputs along each\nbranchareconcatenatedalongthechanneldimensionandcomprisetheblock\u2019soutput. The\ncommonly-tunedhyperparametersoftheInceptionblockarethenumberofoutputchannels\nper layer, i.e., how to allocate capacity among convolutions of different size.\nclass Inception (nn.Module):\n# c1--c4 are the number of output channels for each branch\ndef __init__ (self , c1, c2, c3, c4, **kwargs):\nsuper (Inception, self ).__init__ (**kwargs)\n# Branch 1\nself .b1_1 =nn.LazyConv2d(c1, kernel_size =1)\n# Branch 2\nself .b2_1 =nn.LazyConv2d(c2[ 0], kernel_size =1)\nself .b2_2 =nn.LazyConv2d(c2[ 1], kernel_size =3, padding =1)\n# Branch 3\nself .b3_1 =nn.LazyConv2d(c3[ 0], kernel_size =1)\nself .b3_2 =nn.LazyConv2d(c3[ 1], kernel_size =5, padding =2)\n# Branch 4\nself .b4_1 =nn.MaxPool2d(kernel_size =3, stride =1, padding =1)\nself .b4_2 =nn.LazyConv2d(c4, kernel_size =1)\ndef forward (self , x):\nb1=F.relu( self .b1_1(x))\nb2=F.relu( self .b2_2(F .relu( self .b2_1(x))))\nb3=F.relu( self .b3_2(F .relu( self .b3_1(x))))\nb4=F.relu( self .b4_2( self .b4_1(x)))\nreturn torch .cat((b1, b2, b3, b4), dim =1)\nTo gain some intuition for why this network works so well, consider the combination of\nthe filters. They explore the image in a variety of filter sizes. This means that details at\ndifferentextentscanberecognizedefficientlybyfiltersofdifferentsizes. Atthesametime,\nwe can allocate different amounts of parameters for different filters.\n8.4.2GoogLeNetModel\nAs shown in Fig. 8.4.2 , GoogLeNet uses a stack of a total of 9 inception blocks, arranged\ninto three groups with max-pooling in between, and global average pooling in its head to\ngenerate its estimates. Max-pooling between inception blocks reduces the dimensionality.\nAt its stem, the first module is similar to AlexNet and LeNet.\ntFig. 8.4.2 The GoogLeNet architecture.\n289 Multi-Branch Networks (GoogLeNet)\nWe can now implement GoogLeNet piece by piece. Let\u2019s begin with the stem. The first\nmodule uses a 64-channel 7\u00027convolutional layer.\nclass GoogleNet (d2l .Classifier):\ndef b1(self ):\nreturn nn.Sequential(\nnn.LazyConv2d( 64, kernel_size =7, stride =2, padding =3),\nnn.ReLU(), nn .MaxPool2d(kernel_size =3, stride =2, padding =1))\nThe second module uses two convolutional layers: first, a 64-channel 1\u00021convolutional\nlayer, followed by a 3\u00023convolutional layer that triples the number of channels.", "mimetype": "text/plain", "start_char_idx": 695630, "end_char_idx": 699007, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7ae2bcb6-feed-484d-a118-812617939f33": {"__data__": {"id_": "7ae2bcb6-feed-484d-a118-812617939f33", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a2303d8e-5a77-4073-9fc4-08424723d347", "node_type": "1", "metadata": {}, "hash": "29a2998570e0106de59bf4a7ab0523fb643d339fe9deafef891e2fa2e6dce992", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "daefad5b-2b0b-45b0-b15e-ee3eb591a175", "node_type": "1", "metadata": {}, "hash": "c761b3e349d08f132d3c95616c5a4ce55e4a83bec1cb08201d65d3ef9057be6b", "class_name": "RelatedNodeInfo"}}, "text": "At its stem, the first module is similar to AlexNet and LeNet.\ntFig. 8.4.2 The GoogLeNet architecture.\n289 Multi-Branch Networks (GoogLeNet)\nWe can now implement GoogLeNet piece by piece. Let\u2019s begin with the stem. The first\nmodule uses a 64-channel 7\u00027convolutional layer.\nclass GoogleNet (d2l .Classifier):\ndef b1(self ):\nreturn nn.Sequential(\nnn.LazyConv2d( 64, kernel_size =7, stride =2, padding =3),\nnn.ReLU(), nn .MaxPool2d(kernel_size =3, stride =2, padding =1))\nThe second module uses two convolutional layers: first, a 64-channel 1\u00021convolutional\nlayer, followed by a 3\u00023convolutional layer that triples the number of channels. This\ncorresponds to the second branch in the Inception block and concludes the design of the\nbody. At this point we have 192 channels.\n@d2l .add_to_class(GoogleNet)\ndef b2(self ):\nreturn nn.Sequential(\nnn.LazyConv2d( 64, kernel_size =1), nn .ReLU(),\nnn.LazyConv2d( 192, kernel_size =3, padding =1), nn .ReLU(),\nnn.MaxPool2d(kernel_size =3, stride =2, padding =1))\nThe third module connects two complete Inception blocks in series. The number of output\nchannels of the first Inception block is 64\u00b8128\u00b832\u00b832=256. This amounts to a ratio of\nthe number of output channels among the four branches of 2 : 4 : 1 : 1 . To achieve this, we\nfirstreducetheinputdimensionsby1\n2andby1\n12inthesecondandthirdbranchrespectively\nto arrive at 96=192\u009d2and16=192\u009d12channels respectively.\nThe number of output channels of the second Inception block is increased to 128\u00b8192\u00b8\n96\u00b864=480, yielding a ratio of 128 : 192 : 96 : 64 =4 : 6 : 3 : 2 . As before, we need to\nreduce the number of intermediate dimensions in the second and third channel. A scale of\n1\n2and1\n8respectively suffices, yielding 128and32channels respectively. This is captured\nby the arguments of the following Inception block constructors.\n@d2l .add_to_class(GoogleNet)\ndef b3(self ):\nreturn nn.Sequential(Inception( 64, (96,128), ( 16,32),32),\nInception( 128, (128,192), ( 32,96),64),\nnn.MaxPool2d(kernel_size =3, stride =2, padding =1))\nThe fourth module is more complicated. It connects five Inception blocks in series, and\nthey have 192\u00b8208\u00b848\u00b864=512,160\u00b8224\u00b864\u00b864=512,128\u00b8256\u00b864\u00b864=512,\n112\u00b8288\u00b864\u00b864=528, and 256\u00b8320\u00b8128\u00b8128=832output channels, respectively.\nThe number of channels assigned to these branches is similar to that in the third module:\nthesecondbranchwiththe 3\u00023convolutionallayeroutputsthelargestnumberofchannels,\nfollowed by the first branch with only the 1\u00021convolutional layer, the third branch with\nthe5\u00025convolutional layer, and the fourth branch with the 3\u00023max-pooling layer. The\nsecond and third branches will first reduce the number of channels according to the ratio.\nThese ratios are slightly different in different Inception blocks.\n290 Modern Convolutional Neural Networks\n@d2l .add_to_class(GoogleNet)\ndef b4(self ):\nreturn nn.Sequential(Inception( 192, (96,208), ( 16,48),64),\nInception( 160, (112,224), ( 24,64),64),\nInception( 128, (128,256), ( 24,64),64),\nInception( 112, (144,288), ( 32,64),64),\nInception( 256, (160,320), ( 32,128),128),\nnn.MaxPool2d(kernel_size =3, stride =2, padding =1))\nThefifthmodulehastwoInceptionblockswith 256\u00b8320\u00b8128\u00b8128=832and384\u00b8384\u00b8\n128\u00b8128=1024output channels.", "mimetype": "text/plain", "start_char_idx": 698371, "end_char_idx": 701583, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "daefad5b-2b0b-45b0-b15e-ee3eb591a175": {"__data__": {"id_": "daefad5b-2b0b-45b0-b15e-ee3eb591a175", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7ae2bcb6-feed-484d-a118-812617939f33", "node_type": "1", "metadata": {}, "hash": "0b5c9a7d96d4d4b3d92dee6209342b9f90ad4464564f7d5cebbbdd234d297302", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8f818552-857e-45b5-8b95-39bf6167d197", "node_type": "1", "metadata": {}, "hash": "88412691840314907b6f1809e8890b4a7ef9990f6b5aeab8921bfc94452f8e79", "class_name": "RelatedNodeInfo"}}, "text": "These ratios are slightly different in different Inception blocks.\n290 Modern Convolutional Neural Networks\n@d2l .add_to_class(GoogleNet)\ndef b4(self ):\nreturn nn.Sequential(Inception( 192, (96,208), ( 16,48),64),\nInception( 160, (112,224), ( 24,64),64),\nInception( 128, (128,256), ( 24,64),64),\nInception( 112, (144,288), ( 32,64),64),\nInception( 256, (160,320), ( 32,128),128),\nnn.MaxPool2d(kernel_size =3, stride =2, padding =1))\nThefifthmodulehastwoInceptionblockswith 256\u00b8320\u00b8128\u00b8128=832and384\u00b8384\u00b8\n128\u00b8128=1024output channels. The number of channels assigned to each branch is the\nsame as that in the third and fourth modules, but differs in specific values. It should be\nnotedthat thefifth blockis followedbytheoutput layer. Thisblockusesthe globalaverage\npooling layer to change the height and width of each channel to 1, just as in NiN. Finally,\nwe turn the output into a two-dimensional array followed by a fully connected layer whose\nnumber of outputs is the number of label classes.\n@d2l .add_to_class(GoogleNet)\ndef b5(self ):\nreturn nn.Sequential(Inception( 256, (160,320), ( 32,128),128),\nInception( 384, (192,384), ( 48,128),128),\nnn.AdaptiveAvgPool2d(( 1,1)), nn .Flatten())\nNowthatwedefinedallblocks b1through b5, itisjustamatterofassemblingthemallinto\na full network.\n@d2l .add_to_class(GoogleNet)\ndef __init__ (self , lr =0.1, num_classes =10):\nsuper (GoogleNet, self ).__init__ ()\nself .save_hyperparameters()\nself .net =nn.Sequential( self .b1(), self .b2(), self .b3(), self .b4(),\nself .b5(), nn .LazyLinear(num_classes))\nself .net.apply(d2l .init_cnn)\nThe GoogLeNet model is computationally complex. Note the large number of relatively\narbitraryhyperparametersintermsofthenumberofchannelschosen,thenumberofblocks\nprior to dimensionality reduction, the relative partitioning of capacity across channels, etc.\nMuch of it is due to the fact that at the time when GoogLeNet was introduced, automatic\ntools for network definition or design exploration were not yet available. For instance, by\nnowwetakeitforgrantedthatacompetentdeeplearningframeworkiscapableofinferring\ndimensionalities of input tensors automatically. At the time, many such configurations had\nto be specified explicitly by the experimenter, thus often slowing down active experimen-\ntation. Moreover, the tools needed for automatic exploration were still in flux and initial\nexperiments largely amounted to costly brute-force exploration, genetic algorithms, and\nsimilar strategies.\nFor now the only modification we will carry out is to reduce the input height and width\nfrom 224 to 96 to have a reasonable training time on Fashion-MNIST. This simplifies the\n291 Multi-Branch Networks (GoogLeNet)\ncomputation. Let\u2019shavealookatthechangesintheshapeoftheoutputbetweenthevarious\nmodules.\nmodel =GoogleNet() .layer_summary(( 1,1,96,96))\nSequential output shape: torch .Size([ 1,64,24,24])\nSequential output shape: torch .Size([ 1,192,12,12])\nSequential output shape: torch .Size([ 1,480,6,6])\nSequential output shape: torch .Size([ 1,832,3,3])\nSequential output shape: torch .Size([ 1,1024 ])\nLinear output shape: torch .Size([ 1,10])\n8.4.3Training\nAsbefore,wetrainourmodelusingtheFashion-MNISTdataset. Wetransformitto 96\u000296\npixel resolution before invoking the training procedure.", "mimetype": "text/plain", "start_char_idx": 701051, "end_char_idx": 704315, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8f818552-857e-45b5-8b95-39bf6167d197": {"__data__": {"id_": "8f818552-857e-45b5-8b95-39bf6167d197", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "daefad5b-2b0b-45b0-b15e-ee3eb591a175", "node_type": "1", "metadata": {}, "hash": "c761b3e349d08f132d3c95616c5a4ce55e4a83bec1cb08201d65d3ef9057be6b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c4ea145d-ddf2-44a8-b129-bcf29ba6e028", "node_type": "1", "metadata": {}, "hash": "a6fe6b2ab4e17ea3fd4cd916bf0aac9775f2131d5d54394a2ddb233de5e99a9f", "class_name": "RelatedNodeInfo"}}, "text": "This simplifies the\n291 Multi-Branch Networks (GoogLeNet)\ncomputation. Let\u2019shavealookatthechangesintheshapeoftheoutputbetweenthevarious\nmodules.\nmodel =GoogleNet() .layer_summary(( 1,1,96,96))\nSequential output shape: torch .Size([ 1,64,24,24])\nSequential output shape: torch .Size([ 1,192,12,12])\nSequential output shape: torch .Size([ 1,480,6,6])\nSequential output shape: torch .Size([ 1,832,3,3])\nSequential output shape: torch .Size([ 1,1024 ])\nLinear output shape: torch .Size([ 1,10])\n8.4.3Training\nAsbefore,wetrainourmodelusingtheFashion-MNISTdataset. Wetransformitto 96\u000296\npixel resolution before invoking the training procedure.\nmodel =GoogleNet(lr =0.01 )\ntrainer =d2l.Trainer(max_epochs =10, num_gpus =1)\ndata =d2l.FashionMNIST(batch_size =128, resize =(96,96))\nmodel .apply_init([ next (iter (data .get_dataloader( True )))[ 0]], d2l .init_cnn)\ntrainer .fit(model, data)\n8.4.4Discussion\nA key feature of GoogLeNet is that it is actually cheaper to compute than its predecessors\nwhile simultaneously providing improved accuracy. This marks the beginning of a much\nmoredeliberatenetworkdesignthattradesoffthecostofevaluatinganetworkwithareduc-\ntion in errors. It also marks the beginning of experimentation at a block level with network\ndesignhyperparameters,eventhoughitwasentirelymanualatthetime. Wewillrevisitthis\ntopic inSection 8.8 when discussing strategies for network structure exploration.\nOver the following sections we will encounter a number of design choices (e.g., batch nor-\nmalization, residual connections, and channel grouping) that allow us to improve networks\nsignificantly. For now, you can be proud to have implemented what is arguably the first\ntruly modern CNN.\n292 Modern Convolutional Neural Networks\n1318.4.5Exercises\n1.GoogLeNetwasso successfulthat it wentthrough a numberof iterations, progressively\nimproving speed and accuracy. Try to implement and run some of them. They include\nthe following:\n1.Add a batch normalization layer ( Ioffe and Szegedy, 2015 ), as described later in\nSection 8.5 .\n2.Make adjustments to the Inception block (width, choice and order of convolutions),\nas described in Szegedy etal.(2016).\n3.Uselabelsmoothingformodelregularization, asdescribedinSzegedy etal.(2016).\n4.MakefurtheradjustmentstotheInceptionblockbyaddingresidualconnection( Szegedy\netal., 2017), as described later in Section 8.6 .\n2.What is the minimum image size needed for GoogLeNet to work?\n3.Can you design a variant of GoogLeNet that works on Fashion-MNIST\u2019s native resolu-\ntion of 28\u000228pixels? How would you need to change the stem, the body, and the head\nof the network, if anything at all?\n4.Compare the model parameter sizes of AlexNet, VGG, NiN, and GoogLeNet. How do\nthe latter two network architectures significantly reduce the model parameter size?\n5.ComparetheamountofcomputationneededinGoogLeNetandAlexNet. Howdoesthis\naffect the design of an accelerator chip, e.g., in terms of memory size, memory band-\nwidth,cachesize,theamountofcomputation,andthebenefitofspecializedoperations?\nDiscussions131.\n8.5BatchNormalization\nTrainingdeepneuralnetworksisdifficult. Gettingthemtoconvergeinareasonableamount\nof time can be tricky. In this section, we describe batch normalization , a popular and\neffective technique that consistently accelerates the convergence of deep networks ( Ioffe\nand Szegedy, 2015 ). Together with residual blocks\u2014covered later in Section 8.6 \u2014batch\nnormalization has made it possible for practitioners to routinely train networks with over\n100 layers. A secondary (serendipitous) benefit of batch normalization lies in its inherent\nregularization.\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n293 Batch Normalization\n8.5.1TrainingDeep Networks\nWhen working with data, we often preprocess before training. Choices regarding data pre-\nprocessingoftenmakeanenormousdifferenceinthefinalresults.", "mimetype": "text/plain", "start_char_idx": 703678, "end_char_idx": 707549, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c4ea145d-ddf2-44a8-b129-bcf29ba6e028": {"__data__": {"id_": "c4ea145d-ddf2-44a8-b129-bcf29ba6e028", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8f818552-857e-45b5-8b95-39bf6167d197", "node_type": "1", "metadata": {}, "hash": "88412691840314907b6f1809e8890b4a7ef9990f6b5aeab8921bfc94452f8e79", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ce668fd0-8521-4d37-a084-5dc2aebc58ae", "node_type": "1", "metadata": {}, "hash": "a6b8e93e425ed887eddb43d9e0f7503016a22690f55f21bf998cf0a33fb2c12e", "class_name": "RelatedNodeInfo"}}, "text": "Discussions131.\n8.5BatchNormalization\nTrainingdeepneuralnetworksisdifficult. Gettingthemtoconvergeinareasonableamount\nof time can be tricky. In this section, we describe batch normalization , a popular and\neffective technique that consistently accelerates the convergence of deep networks ( Ioffe\nand Szegedy, 2015 ). Together with residual blocks\u2014covered later in Section 8.6 \u2014batch\nnormalization has made it possible for practitioners to routinely train networks with over\n100 layers. A secondary (serendipitous) benefit of batch normalization lies in its inherent\nregularization.\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n293 Batch Normalization\n8.5.1TrainingDeep Networks\nWhen working with data, we often preprocess before training. Choices regarding data pre-\nprocessingoftenmakeanenormousdifferenceinthefinalresults. Recallourapplicationof\nMLPs to predicting house prices ( Section 5.7 ). Our first step when working with real data\nwastostandardizeourinputfeaturestohavezeromean \ud835\udf41=0andunitvariance \ud835\udeba=1across\nmultiple observations ( Friedman, 1987 ), frequently rescaling the latter so that the diagonal\nis unity, i.e., \u03a3\ud835\udc56\ud835\udc56=1. Yet another strategy is to rescale vectors to unit length, possibly\nzero mean per observation . This can work well, e.g., for spatial sensor data. These pre-\nprocessing techniques and many others, are beneficial for keeping the estimation problem\nwell controlled. For a review of feature selection and extraction see the article of Guyon et\nal.(2008), for example. Standardizing vectors also has the nice side-effect of constraining\nthe function complexity of functions that act upon it. For instance, the celebrated radius-\nmargin bound ( Vapnik, 1995 ) in support vector machines and the Perceptron Convergence\nTheorem ( Novikoff, 1962 ) rely on inputs of bounded norm.\nIntuitively,thisstandardizationplaysnicelywithouroptimizerssinceitputstheparameters\na priori on a similar scale. As such, it is only natural to ask whether a corresponding\nnormalization step insidea deep network might not be beneficial. While this is not quite\nthe reasoning that led to the invention of batch normalization ( Ioffe and Szegedy, 2015 ),\nit is a useful way of understanding it and its cousin, layer normalization ( Baet al., 2016),\nwithin a unified framework.\nSecond, for a typical MLP or CNN, as we train, the variables in intermediate layers (e.g.,\naffine transformation outputs in MLP) may take values with widely varying magnitudes:\nwhether along the layers from input to output, across units in the same layer, and over\ntime due to our updates to the model parameters. The inventors of batch normalization\npostulated informally that this drift in the distribution of such variables could hamper the\nconvergence of the network. Intuitively, we might conjecture that if one layer has variable\nactivations that are 100 times that of another layer, this might necessitate compensatory\nadjustments in the learning rates. Adaptive solvers such as AdaGrad ( Duchiet al., 2011),\nAdam (Kingma and Ba, 2014 ), Yogi ( Zaheeret al., 2018), or Distributed Shampoo ( Anil\netal., 2020)aimtoaddressthisfromtheviewpointofoptimization, e.g., byaddingaspects\nofsecond-ordermethods. Thealternativeistopreventtheproblemfromoccurring, simply\nby adaptive normalization.\nThird, deeper networks are complex and tend to be more liable to overfitting. This means\nthat regularization becomes more critical. A common technique for regularization is noise\ninjection. This has been known for a long time, e.g., with regard to noise injection for\nthe inputs ( Bishop, 1995 ). It also forms the basis of dropout in Section 5.6 . As it turns\nout, quite serendipitously, batch normalization conveys all three benefits: preprocessing,\nnumerical stability, and regularization.\nBatch normalization is applied to individual layers, or optionally, to all of them: In each\ntrainingiteration,wefirstnormalizetheinputs(ofbatchnormalization)bysubtractingtheir\nmeananddividingbytheirstandarddeviation,wherebothareestimatedbasedonthestatis-\ntics of the current minibatch. Next, we apply a scale coefficient and an offset to recover the\n294 Modern Convolutional Neural Networks\nlost degrees of freedom.", "mimetype": "text/plain", "start_char_idx": 706707, "end_char_idx": 710906, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ce668fd0-8521-4d37-a084-5dc2aebc58ae": {"__data__": {"id_": "ce668fd0-8521-4d37-a084-5dc2aebc58ae", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c4ea145d-ddf2-44a8-b129-bcf29ba6e028", "node_type": "1", "metadata": {}, "hash": "a6fe6b2ab4e17ea3fd4cd916bf0aac9775f2131d5d54394a2ddb233de5e99a9f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "42ed2599-f8c2-4949-8b6e-faad0d133eed", "node_type": "1", "metadata": {}, "hash": "58daa6eacb0569fb6fc95dc51b7ed09ee0f5b95cb73af2181a407138106bbf2e", "class_name": "RelatedNodeInfo"}}, "text": "This means\nthat regularization becomes more critical. A common technique for regularization is noise\ninjection. This has been known for a long time, e.g., with regard to noise injection for\nthe inputs ( Bishop, 1995 ). It also forms the basis of dropout in Section 5.6 . As it turns\nout, quite serendipitously, batch normalization conveys all three benefits: preprocessing,\nnumerical stability, and regularization.\nBatch normalization is applied to individual layers, or optionally, to all of them: In each\ntrainingiteration,wefirstnormalizetheinputs(ofbatchnormalization)bysubtractingtheir\nmeananddividingbytheirstandarddeviation,wherebothareestimatedbasedonthestatis-\ntics of the current minibatch. Next, we apply a scale coefficient and an offset to recover the\n294 Modern Convolutional Neural Networks\nlost degrees of freedom. It is precisely due to this normalization based on batchstatistics\nthatbatchnormalization derives its name.\nNote that if wetried to applybatch normalization with minibatches of size 1, wewouldnot\nbe able to learn anything. That is because after subtracting the means, each hidden unit\nwould take value 0. As you might guess, since we are devoting a whole section to batch\nnormalization, with large enough minibatches the approach proves effective and stable.\nOne takeaway here is that when applying batch normalization, the choice of batch size is\neven more significant than without batch normalization, or at least, suitable calibration is\nneeded as we might adjust batch size.\nDenote byBa minibatch and let x2Bbe an input to batch normalization (BN). In this\ncase the batch normalization is defined as follows:\nBN\u00b9x\u00ba=\ud835\udf38\fx\u0000\u02c6\ud835\udf41B\n\u02c6\ud835\udf48B\u00b8\ud835\udf37. (8.5.1)\nIn(8.5.1 ),\u02c6\ud835\udf41Bisthesamplemeanand \u02c6\ud835\udf48Bisthesamplestandarddeviationoftheminibatch\nB. Afterapplyingstandardization,theresultingminibatchhaszeromeanandunitvariance.\nThechoiceofunitvariance(ratherthansomeothermagicnumber)isarbitrary. Werecover\nthisdegreeoffreedombyincludinganelementwise scaleparameter \ud835\udf38andshiftparameter\n\ud835\udf37that have the same shape as x. Both are parameters that need to be learned as part of\nmodel training.\nThe variable magnitudes for intermediate layers cannot diverge during training since batch\nnormalizationactivelycentersandrescalesthembacktoagivenmeanandsize(via \u02c6\ud835\udf41Band\n\u02c6\ud835\udf48B). Practical experience confirms that, as alluded to when discussing feature rescaling,\nbatch normalization seems to allow for more aggressive learning rates. We calculate \u02c6\ud835\udf41B\nand \u02c6\ud835\udf48Bin(8.5.1 )as follows:\n\u02c6\ud835\udf41B=1\njBj\u00d5\nx2Bxand \u02c6\ud835\udf482\nB=1\njBj\u00d5\nx2B\u00b9x\u0000\u02c6\ud835\udf41B\u00ba2\u00b8\ud835\udf16. (8.5.2)\nNote that we add a small constant \ud835\udf16 > 0to the variance estimate to ensure that we never\nattempt division by zero, even in cases where the empirical variance estimate might be\nverysmallorvanish. Theestimates \u02c6\ud835\udf41Band \u02c6\ud835\udf48Bcounteractthescalingissuebyusingnoisy\nestimates of mean and variance. You might think that this noisiness should be a problem.\nOn the contrary, it is actually beneficial.\nThis turns out to be a recurring theme in deep learning. For reasons that are not yet well-\ncharacterized theoretically, various sources of noise in optimization often lead to faster\ntraining and less overfitting: this variation appears to act as a form of regularization. Teye\netal.(2018)andLuo etal.(2018)relatedthepropertiesofbatchnormalizationtoBayesian\npriors and penalties, respectively. In particular, this sheds some light on the puzzle of why\nbatch normalization works best for moderate minibatch sizes in the 50\u2013100 range. This\nparticular size of minibatch seems to inject just the \u201cright amount\u201d of noise per layer, both\nintermsofscalevia \u02c6\ud835\udf48, and intermsofoffsetvia \u02c6\ud835\udf41: a largerminibatchregularizeslessdue\nto the more stable estimates, whereas tiny minibatches destroy useful signal due to high\nvariance.", "mimetype": "text/plain", "start_char_idx": 710076, "end_char_idx": 713803, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "42ed2599-f8c2-4949-8b6e-faad0d133eed": {"__data__": {"id_": "42ed2599-f8c2-4949-8b6e-faad0d133eed", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ce668fd0-8521-4d37-a084-5dc2aebc58ae", "node_type": "1", "metadata": {}, "hash": "a6b8e93e425ed887eddb43d9e0f7503016a22690f55f21bf998cf0a33fb2c12e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f85b1783-0912-432c-8656-fd774eda57de", "node_type": "1", "metadata": {}, "hash": "3c62bcf147a33c59b45916e140bfaaa4041da5b9d46405167a2648cc4c70cad1", "class_name": "RelatedNodeInfo"}}, "text": "For reasons that are not yet well-\ncharacterized theoretically, various sources of noise in optimization often lead to faster\ntraining and less overfitting: this variation appears to act as a form of regularization. Teye\netal.(2018)andLuo etal.(2018)relatedthepropertiesofbatchnormalizationtoBayesian\npriors and penalties, respectively. In particular, this sheds some light on the puzzle of why\nbatch normalization works best for moderate minibatch sizes in the 50\u2013100 range. This\nparticular size of minibatch seems to inject just the \u201cright amount\u201d of noise per layer, both\nintermsofscalevia \u02c6\ud835\udf48, and intermsofoffsetvia \u02c6\ud835\udf41: a largerminibatchregularizeslessdue\nto the more stable estimates, whereas tiny minibatches destroy useful signal due to high\nvariance. Exploring this direction further, considering alternative types of preprocessing\nand filtering may yet lead to other effective types of regularization.\n295 Batch Normalization\nFixing a trained model, you might think that we would prefer using the entire dataset to\nestimate the mean and variance. Once training is complete, why would we want the same\nimage to be classified differently, depending on the batch in which it happens to reside?\nDuring training, such exact calculation is infeasible because the intermediate variables for\nall data examples change every time we update our model. However, once the model is\ntrained, we can calculate the means and variances of each layer\u2019s variables based on the\nentire dataset. Indeed this is standard practice for models employing batch normalization;\nthusbatchnormalizationlayersfunctiondifferentlyin trainingmode (normalizingbymini-\nbatchstatistics)thanin predictionmode (normalizingbydatasetstatistics). Inthisformthey\nclosely resemble the behavior of dropout regularization of Section 5.6 , where noise is only\ninjected during training.\n8.5.2BatchNormalizationLayers\nBatch normalization implementations for fully connected layers and convolutional layers\nare slightly different. One key difference between batch normalization and other layers is\nthat because the former operates on a full minibatch at a time, we cannot just ignore the\nbatch dimension as we did before when introducing other layers.\nFullyConnected Layers\nWhenapplyingbatchnormalizationtofullyconnectedlayers, IoffeandSzegedy( 2015), in\ntheir original paper inserted batch normalization after the affine transformation and before\nthe nonlinear activation function. Later applications experimented with inserting batch\nnormalization right afteractivation functions. Denoting the input to the fully connected\nlayer by x, the affine transformation by Wx\u00b8b(with the weight parameter Wand the\nbias parameter b), and the activation function by \ud835\udf19, we can express the computation of a\nbatch-normalization-enabled, fully connected layer output has follows:\nh=\ud835\udf19\u00b9BN\u00b9Wx\u00b8b\u00ba\u00ba. (8.5.3)\nRecall that mean and variance are computed on the sameminibatch on which the transfor-\nmation is applied.\nConvolutionalLayers\nSimilarly,withconvolutionallayers,wecanapplybatchnormalizationaftertheconvolution\nbut before the nonlinear activation function. The key difference from batch normalization\nin fully connected layers is that we apply the operation on a per-channel basis across all\nlocations . This is compatible with our assumption of translation invariance that led to\nconvolutions: we assumed that the specific location of a pattern within an image was not\ncritical for the purpose of understanding.\nAssume that our minibatches contain \ud835\udc5aexamples and that for each channel, the output\nof the convolution has height \ud835\udc5dand width\ud835\udc5e. For convolutional layers, we carry out each\nbatch normalization over the \ud835\udc5a\u0001\ud835\udc5d\u0001\ud835\udc5eelements per output channel simultaneously. Thus,\n296 Modern Convolutional Neural Networks\nwe collect the values over all spatial locations when computing the mean and variance and\nconsequently apply the same mean and variance within a given channel to normalize the\nvalue at each spatial location. Each channel has its own scale and shift parameters, both of\nwhich are scalars.\nLayerNormalization\nNote that in the context of convolutions the batch normalization is well defined even for\nminibatches of size 1: after all, we have all the locations across an image to average. Con-\nsequently, mean and variance are well defined, even if it is just within a single observation.\nThis consideration led Ba et al.(2016) to introduce the notion of layer normalization . It\nworks just like a batch norm, only that it is applied to one observation at a time. Conse-\nquently both the offset and the scaling factor are scalars.", "mimetype": "text/plain", "start_char_idx": 713045, "end_char_idx": 717623, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f85b1783-0912-432c-8656-fd774eda57de": {"__data__": {"id_": "f85b1783-0912-432c-8656-fd774eda57de", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "42ed2599-f8c2-4949-8b6e-faad0d133eed", "node_type": "1", "metadata": {}, "hash": "58daa6eacb0569fb6fc95dc51b7ed09ee0f5b95cb73af2181a407138106bbf2e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b6c68a12-fc00-4985-ad3a-10d0077a5981", "node_type": "1", "metadata": {}, "hash": "0cc5824cbf89a886da26ea471e83c4e85553020635a524c23183752620a2e17d", "class_name": "RelatedNodeInfo"}}, "text": "Thus,\n296 Modern Convolutional Neural Networks\nwe collect the values over all spatial locations when computing the mean and variance and\nconsequently apply the same mean and variance within a given channel to normalize the\nvalue at each spatial location. Each channel has its own scale and shift parameters, both of\nwhich are scalars.\nLayerNormalization\nNote that in the context of convolutions the batch normalization is well defined even for\nminibatches of size 1: after all, we have all the locations across an image to average. Con-\nsequently, mean and variance are well defined, even if it is just within a single observation.\nThis consideration led Ba et al.(2016) to introduce the notion of layer normalization . It\nworks just like a batch norm, only that it is applied to one observation at a time. Conse-\nquently both the offset and the scaling factor are scalars. For an \ud835\udc5b-dimensional vector x,\nlayer norms are given by\nx!LN\u00b9x\u00ba=x\u0000\u02c6\ud835\udf07\n\u02c6\ud835\udf0e, (8.5.4)\nwhere scaling and offset are applied coefficient-wise and given by\n\u02c6\ud835\udf07def=1\n\ud835\udc5b\ud835\udc5b\u00d5\n\ud835\udc56=1\ud835\udc65\ud835\udc56and \u02c6\ud835\udf0e2def=1\n\ud835\udc5b\ud835\udc5b\u00d5\n\ud835\udc56=1\u00b9\ud835\udc65\ud835\udc56\u0000\u02c6\ud835\udf07\u00ba2\u00b8\ud835\udf16. (8.5.5)\nAsbeforeweaddasmalloffset \ud835\udf16 >0topreventdivisionbyzero. Oneofthemajorbenefits\nof using layer normalization is that it prevents divergence. After all, ignoring \ud835\udf16, the output\nofthelayernormalizationisscaleindependent. Thatis, wehaveLN \u00b9x\u00ba\u0019LN\u00b9\ud835\udefcx\u00baforany\nchoice of\ud835\udefc\u22600. This becomes an equality for j\ud835\udefcj!1(the approximate equality is due\nto the offset\ud835\udf16for the variance).\nAnother advantage of the layer normalization is that it does not depend on the minibatch\nsize. Itisalsoindependentofwhetherweareintrainingortestregime. Inotherwords,itis\nsimplyadeterministictransformationthatstandardizestheactivationstoagivenscale. This\ncanbeverybeneficialinpreventingdivergenceinoptimization. Weskipfurtherdetailsand\nrecommend that interested readers consult the original paper.\nBatchNormalization During Prediction\nAswementionedearlier,batchnormalizationtypicallybehavesdifferentlyintrainingmode\nthaninpredictionmode. First,thenoiseinthesamplemeanandthesamplevariancearising\nfromestimatingeachonminibatchesisnolongerdesirableoncewehavetrainedthemodel.\nSecond, we might not have the luxury of computing per-batch normalization statistics. For\nexample, we might need to apply our model to make one prediction at a time.\nTypically, after training, we use the entire dataset to compute stable estimates of the vari-\nable statistics and then fix them at prediction time. Hence, batch normalization behaves\ndifferently during training than at test time. Recall that dropout also exhibits this charac-\nteristic.\n297 Batch Normalization\n8.5.3Implementation fromScratch\nTo see how batch normalization works in practice, we implement one from scratch be-\nlow.\ndef batch_norm (X, gamma, beta, moving_mean, moving_var, eps, momentum):\n# Use is_grad_enabled to determine whether we are in training mode\nifnot torch .is_grad_enabled():\n# In prediction mode, use mean and variance obtained by moving average\nX_hat =(X-moving_mean) /torch .sqrt(moving_var +eps)\nelse :\nassert len(X.shape) in(2,4)\niflen(X.shape) ==2:\n# When using a fully connected layer, calculate the mean and\n# variance on the feature dimension\nmean =X.mean(dim =0)\nvar =((X -mean) **2).mean(dim =0)\nelse :\n# When using a two-dimensional convolutional layer, calculate the\n# mean and variance on the channel dimension (axis=1).", "mimetype": "text/plain", "start_char_idx": 716750, "end_char_idx": 720091, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b6c68a12-fc00-4985-ad3a-10d0077a5981": {"__data__": {"id_": "b6c68a12-fc00-4985-ad3a-10d0077a5981", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f85b1783-0912-432c-8656-fd774eda57de", "node_type": "1", "metadata": {}, "hash": "3c62bcf147a33c59b45916e140bfaaa4041da5b9d46405167a2648cc4c70cad1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d830fd03-a3f0-4228-a89b-5cba2c25fc4f", "node_type": "1", "metadata": {}, "hash": "ab22d00159d397626bc94c00cc5c9039350ebbb9fb05bcda6a37f07ccde76952", "class_name": "RelatedNodeInfo"}}, "text": "297 Batch Normalization\n8.5.3Implementation fromScratch\nTo see how batch normalization works in practice, we implement one from scratch be-\nlow.\ndef batch_norm (X, gamma, beta, moving_mean, moving_var, eps, momentum):\n# Use is_grad_enabled to determine whether we are in training mode\nifnot torch .is_grad_enabled():\n# In prediction mode, use mean and variance obtained by moving average\nX_hat =(X-moving_mean) /torch .sqrt(moving_var +eps)\nelse :\nassert len(X.shape) in(2,4)\niflen(X.shape) ==2:\n# When using a fully connected layer, calculate the mean and\n# variance on the feature dimension\nmean =X.mean(dim =0)\nvar =((X -mean) **2).mean(dim =0)\nelse :\n# When using a two-dimensional convolutional layer, calculate the\n# mean and variance on the channel dimension (axis=1). Here we\n# need to maintain the shape of X, so that the broadcasting\n# operation can be carried out later\nmean =X.mean(dim =(0,2,3), keepdim =True )\nvar =((X -mean) **2).mean(dim =(0,2,3), keepdim =True )\n# In training mode, the current mean and variance are used\nX_hat =(X-mean) /torch .sqrt(var +eps)\n# Update the mean and variance using moving average\nmoving_mean =(1.0 -momentum) *moving_mean +momentum *mean\nmoving_var =(1.0 -momentum) *moving_var +momentum *var\nY=gamma *X_hat +beta # Scale and shift\nreturn Y, moving_mean .data, moving_var .data\nWecannowcreateaproper BatchNorm layer. Ourlayerwillmaintainproperparametersfor\nscale gammaand shift beta, both of which will be updated in the course of training. Addi-\ntionally,ourlayerwillmaintainmovingaveragesofthemeansandvariancesforsubsequent\nuse during model prediction.\nPuttingasidethealgorithmicdetails,notethedesignpatternunderlyingourimplementation\nof the layer. Typically, we define the mathematics in a separate function, say batch_norm .\nWethenintegratethisfunctionalityintoacustomlayer,whosecodemostlyaddressesbook-\nkeepingmatters, suchasmovingdatatotherightdevicecontext, allocatingandinitializing\nany required variables, keeping track of moving averages (here for mean and variance),\nand so on. This pattern enables a clean separation of mathematics from boilerplate code.\nAlso note that for the sake of convenience we did not worry about automatically inferring\nthe input shape here; thus we need to specify the number of features throughout. By now\nall modern deep learning frameworks offer automatic detection of size and shape in the\nhigh-level batch normalization APIs (in practice we will use this instead).\nclass BatchNorm (nn.Module):\n# num_features: the number of outputs for a fully connected layer or the\n# number of output channels for a convolutional layer. num_dims: 2 for a\n(continues on next page)\n298 Modern Convolutional Neural Networks\n(continued from previous page)\n# fully connected layer and 4 for a convolutional layer\ndef __init__ (self , num_features, num_dims):\nsuper ().__init__ ()\nifnum_dims ==2:\nshape =(1, num_features)\nelse :\nshape =(1, num_features, 1,1)\n# The scale parameter and the shift parameter (model parameters) are\n# initialized to 1 and 0, respectively\nself .gamma =nn.Parameter(torch .ones(shape))\nself .beta =nn.Parameter(torch .zeros(shape))\n# The variables that are not model parameters are initialized to 0 and\n# 1\nself .moving_mean =torch .zeros(shape)\nself .moving_var =torch .ones(shape)\ndef forward (self , X):\n# If X is not on the main memory, copy moving_mean and moving_var to\n# the device where X is located\nifself .moving_mean .device !=X.device:\nself .moving_mean =self .moving_mean .to(X .device)\nself .moving_var =self .moving_var .to(X .device)\n# Save the updated moving_mean and moving_var\nY,self .moving_mean, self .moving_var =batch_norm(\nX,self .gamma, self .beta, self .moving_mean,\nself .moving_var, eps =1e-5 , momentum =0.1)\nreturn Y\nWe used momentum to govern the aggregation over past mean and variance estimates. This\nis somewhat of a misnomer as it has nothing whatsoever to do with the momentum term of\noptimization.", "mimetype": "text/plain", "start_char_idx": 719316, "end_char_idx": 723249, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d830fd03-a3f0-4228-a89b-5cba2c25fc4f": {"__data__": {"id_": "d830fd03-a3f0-4228-a89b-5cba2c25fc4f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b6c68a12-fc00-4985-ad3a-10d0077a5981", "node_type": "1", "metadata": {}, "hash": "0cc5824cbf89a886da26ea471e83c4e85553020635a524c23183752620a2e17d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7fb35b1c-69b8-4300-b8fb-e118c65cfbfc", "node_type": "1", "metadata": {}, "hash": "e8353e9e416f1c3c6da21b6341beb2d4574f6ec4f58b5af868e51dc808482856", "class_name": "RelatedNodeInfo"}}, "text": "This\nis somewhat of a misnomer as it has nothing whatsoever to do with the momentum term of\noptimization. Nonetheless, itisthecommonlyadoptednameforthistermandindeference\nto API naming convention we use the same variable name in our code.\n8.5.4LeNetwith BatchNormalization\nTo see how to apply BatchNorm in context, below we apply it to a traditional LeNet model\n(Section 7.6 ). Recall that batch normalization is applied after the convolutional layers or\nfully connected layers but before the corresponding activation functions.\nclass BNLeNetScratch (d2l .Classifier):\ndef __init__ (self , lr =0.1, num_classes =10):\nsuper ().__init__ ()\nself .save_hyperparameters()\nself .net =nn.Sequential(\nnn.LazyConv2d( 6, kernel_size =5), BatchNorm( 6, num_dims =4),\nnn.Sigmoid(), nn .AvgPool2d(kernel_size =2, stride =2),\nnn.LazyConv2d( 16, kernel_size =5), BatchNorm( 16, num_dims =4),\nnn.Sigmoid(), nn .AvgPool2d(kernel_size =2, stride =2),\nnn.Flatten(), nn .LazyLinear( 120),\nBatchNorm( 120, num_dims =2), nn .Sigmoid(), nn .LazyLinear( 84),\nBatchNorm( 84, num_dims =2), nn .Sigmoid(),\nnn.LazyLinear(num_classes))\n299 Batch Normalization\nAs before, we will train our network on the Fashion-MNIST dataset. This code is virtually\nidentical to that when we first trained LeNet.\ntrainer =d2l.Trainer(max_epochs =10, num_gpus =1)\ndata =d2l.FashionMNIST(batch_size =128)\nmodel =BNLeNetScratch(lr =0.1)\nmodel .apply_init([ next (iter (data .get_dataloader( True )))[ 0]], d2l .init_cnn)\ntrainer .fit(model, data)\nLet\u2019s have a look at the scale parameter gammaand the shift parameter betalearned from\nthe first batch normalization layer.\nmodel .net[ 1].gamma .reshape(( -1,)), model .net[ 1].beta .reshape(( -1,))\n(tensor([ 1.4334 ,1.9905 ,1.8584 ,2.0740 ,2.0522 ,1.8877 ], device ='cuda:0 ',\ngrad_fn =<ViewBackward0 >),\ntensor([ 0.7354 ,-1.3538 ,-0.2567 ,-0.9991 ,-0.3028 ,1.3125 ], device ='cuda:0\n\u21a9!',\ngrad_fn =<ViewBackward0 >))\n8.5.5Concise Implementation\nCompared with the BatchNorm class, which we just defined ourselves, we can use the\nBatchNorm class defined in high-level APIs from the deep learning framework directly.\nThe code looks virtually identical to our implementation above, except that we no longer\nneed to provide additional arguments for it to get the dimensions right.\nclass BNLeNet (d2l .Classifier):\ndef __init__ (self , lr =0.1, num_classes =10):\nsuper ().__init__ ()\nself .save_hyperparameters()\nself .net =nn.Sequential(\nnn.LazyConv2d( 6, kernel_size =5), nn .LazyBatchNorm2d(),\nnn.Sigmoid(), nn .AvgPool2d(kernel_size =2, stride =2),\nnn.LazyConv2d( 16, kernel_size =5), nn .LazyBatchNorm2d(),\nnn.Sigmoid(), nn .AvgPool2d(kernel_size =2, stride =2),\nnn.Flatten(), nn .LazyLinear( 120), nn .LazyBatchNorm1d(),\n(continues on next page)\n300 Modern Convolutional Neural Networks\n(continued from previous page)\nnn.Sigmoid(), nn .LazyLinear( 84), nn .LazyBatchNorm1d(),\nnn.Sigmoid(), nn .LazyLinear(num_classes))\nBelow, we use the same hyperparameters to train our model. Note that as usual, the high-\nlevel API variant runs much faster because its code has been compiled to C++ or CUDA\nwhile our custom implementation must be interpreted by Python.\ntrainer =d2l.Trainer(max_epochs =10, num_gpus =1)\ndata =d2l.FashionMNIST(batch_size =128)\nmodel =BNLeNet(lr =0.1)\nmodel .apply_init([ next (iter (data .get_dataloader( True )))[ 0]], d2l .init_cnn)\ntrainer .fit(model, data)\n8.5.6Discussion\nIntuitively, batch normalization is thought to make the optimization landscape smoother.", "mimetype": "text/plain", "start_char_idx": 723144, "end_char_idx": 726629, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7fb35b1c-69b8-4300-b8fb-e118c65cfbfc": {"__data__": {"id_": "7fb35b1c-69b8-4300-b8fb-e118c65cfbfc", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d830fd03-a3f0-4228-a89b-5cba2c25fc4f", "node_type": "1", "metadata": {}, "hash": "ab22d00159d397626bc94c00cc5c9039350ebbb9fb05bcda6a37f07ccde76952", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "37fa0b59-53d7-4741-8c21-e2b8daaac836", "node_type": "1", "metadata": {}, "hash": "d433f94646937d3c66fa58986be8e390401fb0ce87399dd730e9b1d61e6f7b73", "class_name": "RelatedNodeInfo"}}, "text": "Note that as usual, the high-\nlevel API variant runs much faster because its code has been compiled to C++ or CUDA\nwhile our custom implementation must be interpreted by Python.\ntrainer =d2l.Trainer(max_epochs =10, num_gpus =1)\ndata =d2l.FashionMNIST(batch_size =128)\nmodel =BNLeNet(lr =0.1)\nmodel .apply_init([ next (iter (data .get_dataloader( True )))[ 0]], d2l .init_cnn)\ntrainer .fit(model, data)\n8.5.6Discussion\nIntuitively, batch normalization is thought to make the optimization landscape smoother.\nHowever, we must be careful to distinguish between speculative intuitions and true expla-\nnations for the phenomena that we observe when training deep models. Recall that we do\nnotevenknowwhysimplerdeepneuralnetworks(MLPsandconventionalCNNs)general-\nize well in the first place. Even with dropout and weight decay, they remain so flexible that\ntheir ability to generalize to unseen data likely needs significantly more refined learning-\ntheoretic generalization guarantees.\nTheoriginalpaperproposingbatchnormalization( IoffeandSzegedy, 2015 ), inadditionto\nintroducingapowerfulandusefultool,offeredanexplanationforwhyitworks: byreducing\ninternal covariate shift . Presumably by internal covariate shift they meant something like\nthe intuition expressed above\u2014the notion that the distribution of variable values changes\noverthecourseoftraining. However,thereweretwoproblemswiththisexplanation: i)This\ndrift is very different from covariate shift , rendering the name a misnomer. If anything, it\nis closer to concept drift. ii) The explanation offers an under-specified intuition but leaves\nthe question of whypreciselythistechniqueworks an open question wanting for a rigorous\nexplanation. Throughoutthisbook,weaimtoconveytheintuitionsthatpractitionersuseto\nguide their development of deep neural networks. However, we believe that it is important\nto separate these guiding intuitions from established scientific fact. Eventually, when you\n301 Batch Normalization\nmaster this material and start writing your own research papers you will want to be clear to\ndelineate between technical claims and hunches.\nFollowingthesuccessofbatchnormalization,itsexplanationintermsof internalcovariate\nshifthas repeatedly surfaced in debates in the technical literature and broader discourse\nabout how to present machine learning research. In a memorable speech given while ac-\ncepting a Test of Time Award at the 2017 NeurIPS conference, Ali Rahimi used internal\ncovariateshift asafocalpointinanargumentlikeningthemodernpracticeofdeeplearning\nto alchemy. Subsequently, the example was revisited in detail in a position paper outlining\ntroubling trends in machine learning ( Lipton and Steinhardt, 2018 ). Other authors have\nproposed alternative explanations for the success of batch normalization, some ( Santurkar\netal.,2018)claimingthatbatchnormalization\u2019ssuccesscomesdespiteexhibitingbehavior\nthat is in some ways opposite to those claimed in the original paper.\nWe note that the internal covariate shift is no more worthy of criticism than any of thou-\nsandsofsimilarlyvagueclaimsmadeeveryyearinthetechnicalmachinelearningliterature.\nLikely, its resonance as a focal point of these debates owes to its broad recognizability for\nthe target audience. Batch normalization has proven an indispensable method, applied in\nnearlyalldeployedimageclassifiers,earningthepaperthatintroducedthetechniquetensof\nthousandsofcitations. Weconjecture, though, thattheguidingprinciplesofregularization\nthrough noise injection, acceleration through rescaling and lastly preprocessing may well\nlead to further inventions of layers and techniques in the future.\nOn a more practical note, there are a number of aspects worth remembering about batch\nnormalization:\n\u000fDuringmodeltraining,batchnormalizationcontinuouslyadjuststheintermediateoutput\nof the network by utilizing the mean and standard deviation of the minibatch, so that\nthe values of the intermediate output in each layer throughout the neural network are\nmore stable.\n\u000fBatchnormalizationisslightlydifferentforfullyconnectedlayersthanforconvolutional\nlayers. In fact, for convolutional layers, layer normalization can sometimes be used as\nan alternative.\n\u000fLikeadropoutlayer,batchnormalizationlayershavedifferentbehaviorsintrainingmode\nthan in prediction mode.\n\u000fBatchnormalizationisusefulforregularizationandimprovingconvergenceinoptimiza-\ntion.", "mimetype": "text/plain", "start_char_idx": 726123, "end_char_idx": 730500, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "37fa0b59-53d7-4741-8c21-e2b8daaac836": {"__data__": {"id_": "37fa0b59-53d7-4741-8c21-e2b8daaac836", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7fb35b1c-69b8-4300-b8fb-e118c65cfbfc", "node_type": "1", "metadata": {}, "hash": "e8353e9e416f1c3c6da21b6341beb2d4574f6ec4f58b5af868e51dc808482856", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2c3e176c-92cf-41a7-b046-c0112f546fcb", "node_type": "1", "metadata": {}, "hash": "854f52f292d2367664f87fcf8a90c3c5b65b4283b6d35b1187fb1eaef834f6ab", "class_name": "RelatedNodeInfo"}}, "text": "On a more practical note, there are a number of aspects worth remembering about batch\nnormalization:\n\u000fDuringmodeltraining,batchnormalizationcontinuouslyadjuststheintermediateoutput\nof the network by utilizing the mean and standard deviation of the minibatch, so that\nthe values of the intermediate output in each layer throughout the neural network are\nmore stable.\n\u000fBatchnormalizationisslightlydifferentforfullyconnectedlayersthanforconvolutional\nlayers. In fact, for convolutional layers, layer normalization can sometimes be used as\nan alternative.\n\u000fLikeadropoutlayer,batchnormalizationlayershavedifferentbehaviorsintrainingmode\nthan in prediction mode.\n\u000fBatchnormalizationisusefulforregularizationandimprovingconvergenceinoptimiza-\ntion. By contrast, the original motivation of reducing internal covariate shift seems\nnot to be a valid explanation.\n\u000fFor more robust models that are less sensitive to input perturbations, consider removing\nbatch normalization ( Wangetal., 2022).\n8.5.7Exercises\n1.Shouldweremovethebiasparameterfromthefullyconnectedlayerortheconvolutional\nlayer before the batch normalization? Why?\n302 Modern Convolutional Neural Networks\n1322.Compare the learning rates for LeNet with and without batch normalization.\n1.Plot the increase in validation accuracy.\n2.Howlargecanyoumakethelearningratebeforetheoptimizationfailsinbothcases?\n3.Do we need batch normalization in every layer? Experiment with it.\n4.Implement a \u201clite\u201d version of batch normalization that only removes the mean, or alter-\nnatively one that only removes the variance. How does it behave?\n5.Fix the parameters betaandgamma. Observe and analyze the results.\n6.Can you replace dropout by batch normalization? How does the behavior change?\n7.Research ideas: think of other normalization transforms that you can apply:\n1.Can you apply the probability integral transform?\n2.Can you use a full-rank covariance estimate? Why should you probably not do that?\n3.Can you use other compact matrix variants (block-diagonal, low-displacement rank,\nMonarch, etc.)?\n4.Does a sparsification compression act as a regularizer?\n5.Are there other projections (e.g., convex cone, symmetry group-specific transforms)\nthat you can use?\nDiscussions132.\n8.6ResidualNetworks(ResNet)and ResNeXt\nAs we design ever deeper networks it becomes imperative to understand how adding layers\ncan increase the complexity and expressiveness of the network. Even more important is\ntheabilitytodesignnetworkswhereaddinglayersmakesnetworksstrictlymoreexpressive\nrather than just different. To make some progress we need a bit of mathematics.\nimport torch\nfrom torch import nn\nfrom torch .nnimport functional asF\nfrom d2l import torch asd2l\n8.6.1Function Classes\nConsiderF,theclassoffunctionsthataspecificnetworkarchitecture(togetherwithlearn-\ning rates and other hyperparameter settings) can reach. That is, for all \ud835\udc532Fthere exists\nsome set of parameters (e.g., weights and biases) that can be obtained through training on\na suitable dataset. Let\u2019s assume that \ud835\udc53\u0003is the \u201ctruth\u201d function that we really would like to\n303 Residual Networks (ResNet) and ResNeXt\nfind. If it is inF, we are in good shape but typically we will not be quite so lucky. Instead,\nwe will try to find some \ud835\udc53\u0003\nFwhich is our best bet within F. For instance, given a dataset\nwith features Xand labels y, we might try finding it by solving the following optimization\nproblem:\n\ud835\udc53\u0003\nFdef=argmin\n\ud835\udc53\ud835\udc3f\u00b9X,y, \ud835\udc53\u00basubject to\ud835\udc532F. (8.6.1)\nWe know that regularization ( Morozov, 1984 ,Tikhonov and Arsenin, 1977 ) may control\ncomplexityofFandachieveconsistency,soalargersizeoftrainingdatagenerallyleadsto\nbetter\ud835\udc53\u0003\nF. It is only reasonable to assume that if we design a different and more powerful\narchitectureF0we should arrive at a better outcome. In other words, we would expect\nthat\ud835\udc53\u0003\nF0is \u201cbetter\u201d than \ud835\udc53\u0003\nF. However, ifF\u2288F0there is no guarantee that this should\neven happen. In fact, \ud835\udc53\u0003\nF0might well be worse. As illustrated by Fig.", "mimetype": "text/plain", "start_char_idx": 729759, "end_char_idx": 733700, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2c3e176c-92cf-41a7-b046-c0112f546fcb": {"__data__": {"id_": "2c3e176c-92cf-41a7-b046-c0112f546fcb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "37fa0b59-53d7-4741-8c21-e2b8daaac836", "node_type": "1", "metadata": {}, "hash": "d433f94646937d3c66fa58986be8e390401fb0ce87399dd730e9b1d61e6f7b73", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7937e5a7-db35-4dc5-ad90-6b8a729aa4b0", "node_type": "1", "metadata": {}, "hash": "0a480f012e95577aab76d0a84d15e375c747e59d27333109e0e1f9075d0e7916", "class_name": "RelatedNodeInfo"}}, "text": "(8.6.1)\nWe know that regularization ( Morozov, 1984 ,Tikhonov and Arsenin, 1977 ) may control\ncomplexityofFandachieveconsistency,soalargersizeoftrainingdatagenerallyleadsto\nbetter\ud835\udc53\u0003\nF. It is only reasonable to assume that if we design a different and more powerful\narchitectureF0we should arrive at a better outcome. In other words, we would expect\nthat\ud835\udc53\u0003\nF0is \u201cbetter\u201d than \ud835\udc53\u0003\nF. However, ifF\u2288F0there is no guarantee that this should\neven happen. In fact, \ud835\udc53\u0003\nF0might well be worse. As illustrated by Fig. 8.6.1 , for non-nested\nfunctionclasses, alargerfunctionclassdoesnotalwaysmoveclosertothe\u201ctruth\u201dfunction\n\ud835\udc53\u0003. Forinstance, ontheleftof Fig.8.6.1 , thoughF3iscloserto\ud835\udc53\u0003thanF1,F6movesaway\nand there is no guarantee that further increasing the complexity can reduce the distance\nfrom\ud835\udc53\u0003. With nested function classes where F1\u0012\u0001\u0001\u0001\u0012F 6on the right of Fig. 8.6.1 , we\ncan avoid the aforementioned issue from the non-nested function classes.\ntFig. 8.6.1 For non-nested function classes, a larger (indicated by area) function class does not\nguarantee we will get closer to the \u201ctruth\u201d function ( f\u0003). This does not happen in nested\nfunction classes.\nThus,onlyiflargerfunctionclassescontainthesmalleronesareweguaranteedthatincreas-\ning them strictly increases the expressive power of the network. For deep neural networks,\nif we can train the newly-added layer into an identity function \ud835\udc53\u00b9x\u00ba=x, the new model\nwill be as effective as the original model. As the new model may get a better solution to fit\nthe training dataset, the added layer might make it easier to reduce training errors.\nThis is the question that He et al.(2016) considered when working on very deep com-\nputer vision models. At the heart of their proposed residual network (ResNet) is the idea\nthat every additional layer should more easily contain the identity function as one of its\nelements. These considerations are rather profound but they led to a surprisingly simple\nsolution, a residualblock . With it, ResNet won the ImageNet Large Scale Visual Recogni-\ntion Challenge in 2015. The design had a profound influence on how to build deep neural\nnetworks. For instance, residual blocks have been added to recurrent networks ( Kimetal.,\n2017,Prakashet al., 2016). Likewise, Transformers ( Vaswaniet al., 2017) use them to\n304 Modern Convolutional Neural Networks\nstack many layers of networks efficiently. It is also used in graph neural networks ( Kipf\nandWelling, 2016 )and, asabasicconcept, ithasbeenusedextensivelyincomputervision\n(Redmonand Farhadi, 2018 ,Renetal., 2015). Notethat residual networksare predated by\nhighwaynetworks( Srivastava etal.,2015)thatsharesomeofthemotivation,albeitwithout\nthe elegant parametrization around the identity function.\n8.6.2ResidualBlocks\nLet\u2019s focus on a local part of a neural network, as depicted in Fig. 8.6.2 . Denote the input\nbyx. Weassumethat \ud835\udc53\u00b9x\u00ba,thedesiredunderlyingmappingwewanttoobtainbylearning,\nistobeusedasinputtotheactivationfunctiononthetop. Ontheleft,theportionwithinthe\ndotted-line box must directly learn \ud835\udc53\u00b9x\u00ba. On the right, the portion within the dotted-line\nbox needs to learn the residualmapping \ud835\udc54\u00b9x\u00ba=\ud835\udc53\u00b9x\u00ba\u0000x, which is how the residual block\nderives its name. If the identity mapping \ud835\udc53\u00b9x\u00ba=xis the desired underlying mapping, the\nresidualmappingamountsto \ud835\udc54\u00b9x\u00ba=0anditisthuseasiertolearn: weonlyneedtopushthe\nweights and biases of the upper weight layer (e.g., fully connected layer and convolutional\nlayer) within the dotted-line box to zero. The right figure illustrates the residual block of\nResNet, where the solid line carrying the layer input xto the addition operator is called\naresidual connection (orshortcut connection ).", "mimetype": "text/plain", "start_char_idx": 733195, "end_char_idx": 736852, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7937e5a7-db35-4dc5-ad90-6b8a729aa4b0": {"__data__": {"id_": "7937e5a7-db35-4dc5-ad90-6b8a729aa4b0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2c3e176c-92cf-41a7-b046-c0112f546fcb", "node_type": "1", "metadata": {}, "hash": "854f52f292d2367664f87fcf8a90c3c5b65b4283b6d35b1187fb1eaef834f6ab", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "65ec2c99-5c01-4c5f-b6fa-096d2f356a14", "node_type": "1", "metadata": {}, "hash": "f07815050a19ade9181d85c62f61030f145fd8c973b057d139bf01a564c69242", "class_name": "RelatedNodeInfo"}}, "text": "Ontheleft,theportionwithinthe\ndotted-line box must directly learn \ud835\udc53\u00b9x\u00ba. On the right, the portion within the dotted-line\nbox needs to learn the residualmapping \ud835\udc54\u00b9x\u00ba=\ud835\udc53\u00b9x\u00ba\u0000x, which is how the residual block\nderives its name. If the identity mapping \ud835\udc53\u00b9x\u00ba=xis the desired underlying mapping, the\nresidualmappingamountsto \ud835\udc54\u00b9x\u00ba=0anditisthuseasiertolearn: weonlyneedtopushthe\nweights and biases of the upper weight layer (e.g., fully connected layer and convolutional\nlayer) within the dotted-line box to zero. The right figure illustrates the residual block of\nResNet, where the solid line carrying the layer input xto the addition operator is called\naresidual connection (orshortcut connection ). With residual blocks, inputs can forward\npropagate faster through the residual connections across layers. In fact, the residual block\ncanbethoughtofasaspecialcaseofthemulti-branchInceptionblock: ithastwobranches\none of which is the identity mapping.\ntFig. 8.6.2 In a regular block (left), the portion within the dotted-line box must directly learn the\nmapping f\u00b9x\u00ba. In a residual block (right), the portion within the dotted-line box needs to\nlearn the residual mapping g\u00b9x\u00ba=f\u00b9x\u00ba\u0000x, making the identity mapping f\u00b9x\u00ba=xeasier\nto learn.\nResNet has VGG\u2019s full 3\u00023convolutional layer design. The residual block has two 3\u00023\nconvolutional layers with the same number of output channels. Each convolutional layer\nis followed by a batch normalization layer and a ReLU activation function. Then, we skip\nthesetwoconvolutionoperationsandaddtheinputdirectlybeforethefinalReLUactivation\nfunction. This kind of design requires that the output of the twoconvolutional layers has to\nbe of the same shape as the input, so that they can be added together. If we want to change\nthe number of channels, we need to introduce an additional 1\u00021convolutional layer to\n305 Residual Networks (ResNet) and ResNeXt\ntransform the input into the desired shape for the addition operation. Let\u2019s have a look at\nthe code below.\nclass Residual (nn.Module): #@save\n\"\"\"The Residual block of ResNet models.\"\"\"\ndef __init__ (self , num_channels, use_1x1conv =False , strides =1):\nsuper ().__init__ ()\nself .conv1 =nn.LazyConv2d(num_channels, kernel_size =3, padding =1,\nstride =strides)\nself .conv2 =nn.LazyConv2d(num_channels, kernel_size =3, padding =1)\nifuse_1x1conv:\nself .conv3 =nn.LazyConv2d(num_channels, kernel_size =1,\nstride =strides)\nelse :\nself .conv3 =None\nself .bn1 =nn.LazyBatchNorm2d()\nself .bn2 =nn.LazyBatchNorm2d()\ndef forward (self , X):\nY=F.relu( self .bn1( self .conv1(X)))\nY=self .bn2( self .conv2(Y))\nifself .conv3:\nX=self .conv3(X)\nY+=X\nreturn F.relu(Y)\nThiscodegeneratestwotypesofnetworks: onewhereweaddtheinputtotheoutputbefore\napplying the ReLU nonlinearity whenever use_1x1conv=False ; and one where we adjust\nchannelsandresolutionbymeansofa 1\u00021convolutionbeforeadding. Fig.8.6.3 illustrates\nthis.\ntFig. 8.6.3 ResNet block with and without 1 \u00021 convolution, which transforms the input into the\ndesired shape for the addition operation.\nNow let\u2019s look at a situation where the input and output are of the same shape, where 1\u00021\nconvolution is not needed.\n306 Modern Convolutional Neural Networks\nblk =Residual( 3)\nX=torch .randn( 4,3,6,6)\nblk(X) .shape\ntorch .Size([ 4,3,6,6])\nWe also have the option to halve the output height and width while increasing the number\nof output channels. In this case we use 1\u00021convolutions via use_1x1conv=True . This\ncomes in handy at the beginning of each ResNet block to reduce the spatial dimensionality\nviastrides=2 .", "mimetype": "text/plain", "start_char_idx": 736161, "end_char_idx": 739696, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "65ec2c99-5c01-4c5f-b6fa-096d2f356a14": {"__data__": {"id_": "65ec2c99-5c01-4c5f-b6fa-096d2f356a14", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7937e5a7-db35-4dc5-ad90-6b8a729aa4b0", "node_type": "1", "metadata": {}, "hash": "0a480f012e95577aab76d0a84d15e375c747e59d27333109e0e1f9075d0e7916", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0771d6b2-a553-471e-a058-0f9ad4e469b1", "node_type": "1", "metadata": {}, "hash": "9f23e0e95ed9f2c6ff4220757c179405aefeb57921cc2edf25a512690fda76d4", "class_name": "RelatedNodeInfo"}}, "text": "Fig.8.6.3 illustrates\nthis.\ntFig. 8.6.3 ResNet block with and without 1 \u00021 convolution, which transforms the input into the\ndesired shape for the addition operation.\nNow let\u2019s look at a situation where the input and output are of the same shape, where 1\u00021\nconvolution is not needed.\n306 Modern Convolutional Neural Networks\nblk =Residual( 3)\nX=torch .randn( 4,3,6,6)\nblk(X) .shape\ntorch .Size([ 4,3,6,6])\nWe also have the option to halve the output height and width while increasing the number\nof output channels. In this case we use 1\u00021convolutions via use_1x1conv=True . This\ncomes in handy at the beginning of each ResNet block to reduce the spatial dimensionality\nviastrides=2 .\nblk =Residual( 6, use_1x1conv =True , strides =2)\nblk(X) .shape\ntorch .Size([ 4,6,3,3])\n8.6.3ResNetModel\nThefirsttwolayersofResNetarethesameasthoseoftheGoogLeNetwedescribedbefore:\nthe7\u00027convolutional layer with 64 output channels and a stride of 2 is followed by the\n3\u00023max-pooling layer with a stride of 2. The difference is the batch normalization layer\nadded after each convolutional layer in ResNet.\nclass ResNet (d2l .Classifier):\ndef b1(self ):\nreturn nn.Sequential(\nnn.LazyConv2d( 64, kernel_size =7, stride =2, padding =3),\nnn.LazyBatchNorm2d(), nn .ReLU(),\nnn.MaxPool2d(kernel_size =3, stride =2, padding =1))\nGoogLeNet uses four modules made up of Inception blocks. However, ResNet uses four\nmodules made up of residual blocks, each of which uses several residual blocks with the\nsame number of output channels. The number of channels in the first module is the same\nas the number of input channels. Since a max-pooling layer with a stride of 2 has already\nbeen used, it is not necessary to reduce the height and width. In the first residual block for\neach of the subsequent modules, the number of channels is doubled compared with that of\nthe previous module, and the height and width are halved.\n@d2l .add_to_class(ResNet)\ndef block (self , num_residuals, num_channels, first_block =False ):\nblk =[]\nfor iinrange (num_residuals):\nifi==0and not first_block:\nblk.append(Residual(num_channels, use_1x1conv =True , strides =2))\nelse :\n(continues on next page)\n307 Residual Networks (ResNet) and ResNeXt\n(continued from previous page)\nblk.append(Residual(num_channels))\nreturn nn.Sequential( *blk)\nThen, we add all the modules to ResNet. Here, two residual blocks are used for each mod-\nule. Lastly, just like GoogLeNet, we add a global average pooling layer, followed by the\nfully connected layer output.\n@d2l .add_to_class(ResNet)\ndef __init__ (self , arch, lr =0.1, num_classes =10):\nsuper (ResNet, self ).__init__ ()\nself .save_hyperparameters()\nself .net =nn.Sequential( self .b1())\nfor i, b inenumerate (arch):\nself .net.add_module( f'b{i+2}',self .block( *b, first_block =(i==0)))\nself .net.add_module( 'last ', nn .Sequential(\nnn.AdaptiveAvgPool2d(( 1,1)), nn .Flatten(),\nnn.LazyLinear(num_classes)))\nself .net.apply(d2l .init_cnn)\nTherearefourconvolutionallayersineachmodule(excludingthe 1\u00021convolutionallayer).\nTogetherwiththefirst 7\u00027convolutionallayerandthefinalfullyconnectedlayer,thereare\n18layersintotal. Therefore,thismodeliscommonlyknownasResNet-18. Byconfiguring\ndifferent numbers of channels and residual blocks in the module, we can create different\nResNet models, such as the deeper 152-layer ResNet-152. Although the main architecture\nofResNetissimilartothatofGoogLeNet, ResNet\u2019sstructureissimplerandeasiertomod-\nify. All these factors have resulted in the rapid and widespread use of ResNet. Fig. 8.6.4\ndepicts the full ResNet-18.\ntFig.", "mimetype": "text/plain", "start_char_idx": 739014, "end_char_idx": 742563, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0771d6b2-a553-471e-a058-0f9ad4e469b1": {"__data__": {"id_": "0771d6b2-a553-471e-a058-0f9ad4e469b1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "65ec2c99-5c01-4c5f-b6fa-096d2f356a14", "node_type": "1", "metadata": {}, "hash": "f07815050a19ade9181d85c62f61030f145fd8c973b057d139bf01a564c69242", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ce89d424-a04b-4f9b-b9aa-4276768e844b", "node_type": "1", "metadata": {}, "hash": "eca67b20cbaccdbb87bad62f85acc9709ae4d143735e15752e7eb43d0bf78b9d", "class_name": "RelatedNodeInfo"}}, "text": "Togetherwiththefirst 7\u00027convolutionallayerandthefinalfullyconnectedlayer,thereare\n18layersintotal. Therefore,thismodeliscommonlyknownasResNet-18. Byconfiguring\ndifferent numbers of channels and residual blocks in the module, we can create different\nResNet models, such as the deeper 152-layer ResNet-152. Although the main architecture\nofResNetissimilartothatofGoogLeNet, ResNet\u2019sstructureissimplerandeasiertomod-\nify. All these factors have resulted in the rapid and widespread use of ResNet. Fig. 8.6.4\ndepicts the full ResNet-18.\ntFig. 8.6.4 The ResNet-18 architecture.\nBeforetrainingResNet,let\u2019sobservehowtheinputshapechangesacrossdifferentmodules\nin ResNet. As in all the previous architectures, the resolution decreases while the number\nof channels increases up until the point where a global average pooling layer aggregates all\nfeatures.\nclass ResNet18 (ResNet):\ndef __init__ (self , lr =0.1, num_classes =10):\nsuper ().__init__ (((2,64), ( 2,128), ( 2,256), ( 2,512)),\nlr, num_classes)\n308 Modern Convolutional Neural Networks\nResNet18() .layer_summary(( 1,1,96,96))\nSequential output shape: torch .Size([ 1,64,24,24])\nSequential output shape: torch .Size([ 1,64,24,24])\nSequential output shape: torch .Size([ 1,128,12,12])\nSequential output shape: torch .Size([ 1,256,6,6])\nSequential output shape: torch .Size([ 1,512,3,3])\nSequential output shape: torch .Size([ 1,10])\n8.6.4Training\nWe train ResNet on the Fashion-MNIST dataset, just like before. ResNet is quite a pow-\nerful and flexible architecture. The plot capturing training and validation loss illustrates a\nsignificant gap between both graphs, with the training loss being considerably lower. For\na network of this flexibility, more training data would offer distinct benefit in closing the\ngap and improving accuracy.\nmodel =ResNet18(lr =0.01 )\ntrainer =d2l.Trainer(max_epochs =10, num_gpus =1)\ndata =d2l.FashionMNIST(batch_size =128, resize =(96,96))\nmodel .apply_init([ next (iter (data .get_dataloader( True )))[ 0]], d2l .init_cnn)\ntrainer .fit(model, data)\n8.6.5ResNeXt\nOne of the challenges one encounters in the design of ResNet is the trade-off between non-\nlinearity and dimensionality within a given block. That is, we could add more nonlinearity\nby increasing the number of layers, or by increasing the width of the convolutions. An al-\nternative strategy is to increase the number of channels that can carry information between\nblocks. Unfortunately, the latter comes with a quadratic penalty since the computational\ncost of ingesting \ud835\udc50ichannels and emitting \ud835\udc50ochannels is proportional to O\u00b9\ud835\udc50i\u0001\ud835\udc50o\u00ba(see our\ndiscussion in Section 7.4 ).\nWe can take some inspiration from the Inception block of Fig. 8.4.1 which has informa-\ntion flowing through the block in separate groups. Applying the idea of multiple indepen-\ndent groups to the ResNet block of Fig. 8.6.3 led to the design of ResNeXt ( Xieet al.,\n309 Residual Networks (ResNet) and ResNeXt\n2017). Different from the smorgasbord of transformations in Inception, ResNeXt adopts\nthesametransformation in all branches, thus minimizing the need for manual tuning of\neach branch.\ntFig. 8.6.5 The ResNeXt block. The use of grouped convolution with ggroups is gtimes faster than\na dense convolution. It is a bottleneck residual block when the number of intermediate\nchannels bis less than c.\nBreaking up a convolution from \ud835\udc50ito\ud835\udc50ochannels into one of \ud835\udc54groups of size \ud835\udc50i\u009d\ud835\udc54gener-\nating\ud835\udc54outputs of size \ud835\udc50o\u009d\ud835\udc54is called, quite fittingly, a groupedconvolution .", "mimetype": "text/plain", "start_char_idx": 742025, "end_char_idx": 745506, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ce89d424-a04b-4f9b-b9aa-4276768e844b": {"__data__": {"id_": "ce89d424-a04b-4f9b-b9aa-4276768e844b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0771d6b2-a553-471e-a058-0f9ad4e469b1", "node_type": "1", "metadata": {}, "hash": "9f23e0e95ed9f2c6ff4220757c179405aefeb57921cc2edf25a512690fda76d4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0c069235-9fae-4900-bdef-87327737ab9e", "node_type": "1", "metadata": {}, "hash": "6d0c3c4c06561d5cc259ce7a9f26ac478cbff7b08826ff99febc4923c67fa5a8", "class_name": "RelatedNodeInfo"}}, "text": "8.6.3 led to the design of ResNeXt ( Xieet al.,\n309 Residual Networks (ResNet) and ResNeXt\n2017). Different from the smorgasbord of transformations in Inception, ResNeXt adopts\nthesametransformation in all branches, thus minimizing the need for manual tuning of\neach branch.\ntFig. 8.6.5 The ResNeXt block. The use of grouped convolution with ggroups is gtimes faster than\na dense convolution. It is a bottleneck residual block when the number of intermediate\nchannels bis less than c.\nBreaking up a convolution from \ud835\udc50ito\ud835\udc50ochannels into one of \ud835\udc54groups of size \ud835\udc50i\u009d\ud835\udc54gener-\nating\ud835\udc54outputs of size \ud835\udc50o\u009d\ud835\udc54is called, quite fittingly, a groupedconvolution . The computa-\ntionalcost(proportionally)isreducedfrom O\u00b9\ud835\udc50i\u0001\ud835\udc50o\u00batoO\u00b9\ud835\udc54\u0001\u00b9\ud835\udc50i\u009d\ud835\udc54\u00ba\u0001\u00b9\ud835\udc50o\u009d\ud835\udc54\u00ba\u00ba=O\u00b9\ud835\udc50i\u0001\ud835\udc50o\u009d\ud835\udc54\u00ba,\ni.e.,itis\ud835\udc54timesfaster. Evenbetter,thenumberofparametersneededtogeneratetheoutput\nis also reduced from a \ud835\udc50i\u0002\ud835\udc50omatrix to\ud835\udc54smaller matrices of size \u00b9\ud835\udc50i\u009d\ud835\udc54\u00ba\u0002\u00b9\ud835\udc50o\u009d\ud835\udc54\u00ba, again a\n\ud835\udc54timesreduction. Inwhatfollowsweassumethatboth \ud835\udc50iand\ud835\udc50oaredivisibleby \ud835\udc54.\nTheonlychallengeinthisdesignisthatnoinformationisexchangedbetweenthe \ud835\udc54groups.\nThe ResNeXt block of Fig. 8.6.5 amends this in two ways: the grouped convolution with\na3\u00023kernel is sandwiched in between two 1\u00021convolutions. The second one serves\ndouble duty in changing the number of channels back. The benefit is that we only pay the\nO\u00b9\ud835\udc50\u0001\ud835\udc4f\u00bacost for 1\u00021kernels and can make do with an O\u00b9\ud835\udc4f2\u009d\ud835\udc54\u00bacost for 3\u00023kernels.\nSimilar to the residual block implementation in Section 8.6.2 , the residual connection is\nreplaced (thus generalized) by a 1\u00021convolution.\nTheright-handfigurein Fig.8.6.5 providesamuchmoreconcisesummaryoftheresulting\nnetwork block. It will also play a major role in the design of generic modern CNNs in\nSection 8.8 . Note that the idea of grouped convolutions dates back to the implementation\nof AlexNet ( Krizhevsky et al., 2012). When distributing the network across two GPUs\nwith limited memory, the implementation treated each GPU as its own channel with no ill\neffects.\nThe following implementation of the ResNeXtBlock class takes as argument groups(\ud835\udc54),\nwith bot_channels (\ud835\udc4f)intermediate(bottleneck)channels. Lastly,whenweneedtoreduce\n310 Modern Convolutional Neural Networks\ntheheightandwidthoftherepresentation,weaddastrideof 2bysetting use_1x1conv=True,\nstrides=2 .\nclass ResNeXtBlock (nn.Module): #@save\n\"\"\"The ResNeXt block.\"\"\"", "mimetype": "text/plain", "start_char_idx": 744860, "end_char_idx": 747188, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0c069235-9fae-4900-bdef-87327737ab9e": {"__data__": {"id_": "0c069235-9fae-4900-bdef-87327737ab9e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ce89d424-a04b-4f9b-b9aa-4276768e844b", "node_type": "1", "metadata": {}, "hash": "eca67b20cbaccdbb87bad62f85acc9709ae4d143735e15752e7eb43d0bf78b9d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a21095e3-c318-46b5-8081-2cec8514ebcc", "node_type": "1", "metadata": {}, "hash": "5ee2f81c1c865de9a3f0637a4715483cce05db885b2dc8fd19989900b15133e2", "class_name": "RelatedNodeInfo"}}, "text": "It will also play a major role in the design of generic modern CNNs in\nSection 8.8 . Note that the idea of grouped convolutions dates back to the implementation\nof AlexNet ( Krizhevsky et al., 2012). When distributing the network across two GPUs\nwith limited memory, the implementation treated each GPU as its own channel with no ill\neffects.\nThe following implementation of the ResNeXtBlock class takes as argument groups(\ud835\udc54),\nwith bot_channels (\ud835\udc4f)intermediate(bottleneck)channels. Lastly,whenweneedtoreduce\n310 Modern Convolutional Neural Networks\ntheheightandwidthoftherepresentation,weaddastrideof 2bysetting use_1x1conv=True,\nstrides=2 .\nclass ResNeXtBlock (nn.Module): #@save\n\"\"\"The ResNeXt block.\"\"\"\ndef __init__ (self , num_channels, groups, bot_mul, use_1x1conv =False ,\nstrides =1):\nsuper ().__init__ ()\nbot_channels =int(round (num_channels *bot_mul))\nself .conv1 =nn.LazyConv2d(bot_channels, kernel_size =1, stride =1)\nself .conv2 =nn.LazyConv2d(bot_channels, kernel_size =3,\nstride =strides, padding =1,\ngroups =bot_channels //groups)\nself .conv3 =nn.LazyConv2d(num_channels, kernel_size =1, stride =1)\nself .bn1 =nn.LazyBatchNorm2d()\nself .bn2 =nn.LazyBatchNorm2d()\nself .bn3 =nn.LazyBatchNorm2d()\nifuse_1x1conv:\nself .conv4 =nn.LazyConv2d(num_channels, kernel_size =1,\nstride =strides)\nself .bn4 =nn.LazyBatchNorm2d()\nelse :\nself .conv4 =None\ndef forward (self , X):\nY=F.relu( self .bn1( self .conv1(X)))\nY=F.relu( self .bn2( self .conv2(Y)))\nY=self .bn3( self .conv3(Y))\nifself .conv4:\nX=self .bn4( self .conv4(X))\nreturn F.relu(Y +X)\nItsuseisentirelyanalogoustothatofthe ResNetBlock discussedpreviously. Forinstance,\nwhen using ( use_1x1conv=False, strides=1 ), the input and output are of the same\nshape. Alternatively, setting use_1x1conv=True, strides=2 halves the output height\nand width.\nblk =ResNeXtBlock( 32,16,1)\nX=torch .randn( 4,32,96,96)\nblk(X) .shape\ntorch .Size([ 4,32,96,96])\n8.6.6Summaryand Discussion\nNested function classes are desirable since they allow us to obtain strictly more power-\nfulrather than also subtly different function classes when adding capacity. One way of\naccomplishing this is by letting additional layers to simply pass through the input to the\noutput. Residual connections allow for this. As a consequence, this changes the inductive\nbias from simple functions being of the form \ud835\udc53\u00b9x\u00ba=0to simple functions looking like\n\ud835\udc53\u00b9x\u00ba=x.\n311 Residual Networks (ResNet) and ResNeXt\nThe residual mapping can learn the identity function more easily, such as pushing param-\neters in the weight layer to zero. We can train an effective deepneural network by having\nresidualblocks. Inputscanforwardpropagatefasterthroughtheresidualconnectionsacross\nlayers. Asaconsequence, wecanthustrainmuchdeepernetworks. Forinstance, theorigi-\nnal ResNetpaper ( Heetal., 2016) allowedforup to 152 layers. Another benefit of residual\nnetworks is that it allows us to add layers, initialized as the identity function, duringthe\ntraining process. After all, the default behavior of a layer is to let the data pass through\nunchanged. This can accelerate the training of very large networks in some cases.\nPrior to residual connections, bypassing paths with gating units were introduced to effec-\ntively train highway networks with over 100 layers ( Srivastava etal., 2015). Using identity\nfunctions as bypassing paths, ResNet performed remarkably well on multiple computer vi-\nsion tasks. Residual connections had a major influence on the design of subsequent deep\nneural networks, of either convolutional or sequential nature.", "mimetype": "text/plain", "start_char_idx": 746483, "end_char_idx": 750030, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a21095e3-c318-46b5-8081-2cec8514ebcc": {"__data__": {"id_": "a21095e3-c318-46b5-8081-2cec8514ebcc", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0c069235-9fae-4900-bdef-87327737ab9e", "node_type": "1", "metadata": {}, "hash": "6d0c3c4c06561d5cc259ce7a9f26ac478cbff7b08826ff99febc4923c67fa5a8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b3defebc-c3f9-49a0-9978-7566398756b9", "node_type": "1", "metadata": {}, "hash": "ba565d1ed7687ebaa90be53feb036644d283c2c132dd8d2bc9c424f3c5caeab1", "class_name": "RelatedNodeInfo"}}, "text": "Asaconsequence, wecanthustrainmuchdeepernetworks. Forinstance, theorigi-\nnal ResNetpaper ( Heetal., 2016) allowedforup to 152 layers. Another benefit of residual\nnetworks is that it allows us to add layers, initialized as the identity function, duringthe\ntraining process. After all, the default behavior of a layer is to let the data pass through\nunchanged. This can accelerate the training of very large networks in some cases.\nPrior to residual connections, bypassing paths with gating units were introduced to effec-\ntively train highway networks with over 100 layers ( Srivastava etal., 2015). Using identity\nfunctions as bypassing paths, ResNet performed remarkably well on multiple computer vi-\nsion tasks. Residual connections had a major influence on the design of subsequent deep\nneural networks, of either convolutional or sequential nature. As we will introduce later,\nthe Transformer architecture ( Vaswaniet al., 2017) adopts residual connections (together\nwith other design choices) and is pervasive in areas as diverse as language, vision, speech,\nand reinforcement learning.\nResNeXt is an example for how the design of convolutional neural networks has evolved\nover time: by being more frugal with computation and trading it off against the size of the\nactivations (number of channels), it allows for faster and more accurate networks at lower\ncost. An alternative way of viewing grouped convolutions is to think of a block-diagonal\nmatrix for the convolutional weights. Note that there are quite a few such \u201ctricks\u201d that lead\nto more efficient networks. For instance, ShiftNet ( Wuet al., 2018) mimicks the effects of\na3\u00023convolution,simplybyaddingshiftedactivationstothechannels,offeringincreased\nfunction complexity, this time without any computational cost.\nA common feature of the designs we have discussed so far is that the network design is\nfairlymanual, primarilyrelyingontheingenuityofthedesignertofindthe\u201cright\u201dnetwork\nhyperparameters. While clearly feasible, it is also very costly in terms of human time and\nthereisnoguaranteethattheoutcomeisoptimalinanysense. In Section8.8 wewilldiscuss\na number of strategies for obtaining high quality networks in a more automated fashion. In\nparticular, we will review the notion of network design spaces that led to the RegNetX/Y\nmodels ( Radosavovic etal., 2020).\n8.6.7Exercises\n1.WhatarethemajordifferencesbetweentheInceptionblockin Fig.8.4.1 andtheresidual\nblock? How do they compare in terms of computation, accuracy, and the classes of\nfunctions they can describe?\n2.Refer to Table 1 in the ResNet paper ( Heetal., 2016) to implement different variants of\nthe network.\n3.For deeper networks, ResNet introduces a \u201cbottleneck\u201d architecture to reduce model\ncomplexity. Try to implement it.\n4.In subsequent versions of ResNet, the authors changed the \u201cconvolution, batch normal-\n312 Modern Convolutional Neural Networks\n133ization, and activation\u201d structure to the \u201cbatch normalization, activation, and convolu-\ntion\u201d structure. Make this improvement yourself. See Figure 1 in He et al.(2016) for\ndetails.\n5.Why can\u2019t we just increase the complexity of functions without bound, even if the func-\ntion classes are nested?\nDiscussions133.\n8.7DenselyConnected Networks(DenseNet)\nResNet significantly changed the view of how to parametrize the functions in deep net-\nworks.DenseNet (dense convolutional network) is to some extent the logical extension of\nthis(Huangetal.,2017). DenseNetischaracterizedbyboththeconnectivitypatternwhere\neach layer connects to all the preceding layers and the concatenation operation (rather than\nthe addition operator in ResNet) to preserve and reuse features from earlier layers. To un-\nderstand how to arrive at it, let\u2019s take a small detour to mathematics.\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n8.7.1FromResNetto DenseNet\nRecall the Taylor expansion for functions. At the point \ud835\udc65=0it can be written as\n\ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc53\u00b90\u00ba\u00b8\ud835\udc65\u0001\u0014\n\ud835\udc530\u00b90\u00ba\u00b8\ud835\udc65\u0001\u0014\ud835\udc5300\u00b90\u00ba\n2!\u00b8\ud835\udc65\u0001\u0014\ud835\udc53000\u00b90\u00ba\n3!\u00b8\u0001\u0001\u0001\u0015\u0015\u0015\n.", "mimetype": "text/plain", "start_char_idx": 749178, "end_char_idx": 753160, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b3defebc-c3f9-49a0-9978-7566398756b9": {"__data__": {"id_": "b3defebc-c3f9-49a0-9978-7566398756b9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a21095e3-c318-46b5-8081-2cec8514ebcc", "node_type": "1", "metadata": {}, "hash": "5ee2f81c1c865de9a3f0637a4715483cce05db885b2dc8fd19989900b15133e2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ede0064d-4a3a-4281-b41e-a7632ba5f776", "node_type": "1", "metadata": {}, "hash": "22710dd4611603029c1609f645e85dbbf1c0cad3331178fd851886273e32f253", "class_name": "RelatedNodeInfo"}}, "text": "DenseNetischaracterizedbyboththeconnectivitypatternwhere\neach layer connects to all the preceding layers and the concatenation operation (rather than\nthe addition operator in ResNet) to preserve and reuse features from earlier layers. To un-\nderstand how to arrive at it, let\u2019s take a small detour to mathematics.\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n8.7.1FromResNetto DenseNet\nRecall the Taylor expansion for functions. At the point \ud835\udc65=0it can be written as\n\ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc53\u00b90\u00ba\u00b8\ud835\udc65\u0001\u0014\n\ud835\udc530\u00b90\u00ba\u00b8\ud835\udc65\u0001\u0014\ud835\udc5300\u00b90\u00ba\n2!\u00b8\ud835\udc65\u0001\u0014\ud835\udc53000\u00b90\u00ba\n3!\u00b8\u0001\u0001\u0001\u0015\u0015\u0015\n. (8.7.1)\nThe key point is that it decomposes a function into terms of increasingly higher order. In a\nsimilar vein, ResNet decomposes functions into\n\ud835\udc53\u00b9x\u00ba=x\u00b8\ud835\udc54\u00b9x\u00ba. (8.7.2)\nThatis,ResNetdecomposes \ud835\udc53intoasimplelineartermandamorecomplexnonlinearone.\nWhat if we wanted to capture (not necessarily add) information beyond two terms? One\nsuch solution is DenseNet ( Huangetal., 2017).\ntFig. 8.7.1 The main difference between ResNet (left) and DenseNet (right) in cross-layer\nconnections: use of addition and use of concatenation.\n313 Densely Connected Networks (DenseNet)\nAs shown in Fig. 8.7.1 , the key difference between ResNet and DenseNet is that in the\nlatter case outputs are concatenated (denoted by\u00bb,\u00bc) rather than added. As a result, we\nperform a mapping from xto its values after applying an increasingly complex sequence\nof functions:\nx!\u00bbx, \ud835\udc531\u00b9x\u00ba, \ud835\udc532\u00b9\u00bbx, \ud835\udc531\u00b9x\u00ba\u00bc\u00ba, \ud835\udc533\u00b9\u00bbx, \ud835\udc531\u00b9x\u00ba, \ud835\udc532\u00b9\u00bbx, \ud835\udc531\u00b9x\u00ba\u00bc\u00ba\u00bc\u00ba,...\u00bc. (8.7.3)\nIntheend,allthesefunctionsarecombinedinMLPtoreducethenumberoffeaturesagain.\nIn terms of implementation this is quite simple: rather than adding terms, we concatenate\nthem. ThenameDenseNetarisesfromthefactthatthedependencygraphbetweenvariables\nbecomes quite dense. The final layer of such a chain is densely connected to all previous\nlayers. The dense connections are shown in Fig. 8.7.2 .\ntFig. 8.7.2 Dense connections in DenseNet. Note how the dimensionality increases with depth.\nThemaincomponentsthatcompriseaDenseNetare denseblocks andtransitionlayers . The\nformerdefinehowtheinputsandoutputsareconcatenated,whilethelattercontrolthenum-\nberofchannelssothatitisnottoolarge,sincetheexpansion x!\u00bbx, \ud835\udc531\u00b9x\u00ba, \ud835\udc532\u00b9\u00bbx, \ud835\udc531\u00b9x\u00ba\u00bc\u00ba,...\u00bc\ncan be quite high-dimensional.\n8.7.2DenseBlocks\nDenseNet uses the modified \u201cbatch normalization, activation, and convolution\u201d structure\nof ResNet (see the exercise in Section 8.6 ). First, we implement this convolution block\nstructure.\ndef conv_block (num_channels):\nreturn nn.Sequential(\nnn.LazyBatchNorm2d(), nn .ReLU(),\nnn.LazyConv2d(num_channels, kernel_size =3, padding =1))\nAdense block consists of multiple convolution blocks, each using the same number of\noutput channels. In the forward propagation, however, weconcatenate the input and output\nof each convolution block on the channel dimension. Lazy evaluation allows us to adjust\nthe dimensionality automatically.", "mimetype": "text/plain", "start_char_idx": 752622, "end_char_idx": 755474, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ede0064d-4a3a-4281-b41e-a7632ba5f776": {"__data__": {"id_": "ede0064d-4a3a-4281-b41e-a7632ba5f776", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b3defebc-c3f9-49a0-9978-7566398756b9", "node_type": "1", "metadata": {}, "hash": "ba565d1ed7687ebaa90be53feb036644d283c2c132dd8d2bc9c424f3c5caeab1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ed0cfaef-602b-43f1-8596-3f03d96edd4f", "node_type": "1", "metadata": {}, "hash": "7eaab1817c741b34f41b174c6d4ee0743a74722d34a19611358545fd56788d61", "class_name": "RelatedNodeInfo"}}, "text": "8.7.2DenseBlocks\nDenseNet uses the modified \u201cbatch normalization, activation, and convolution\u201d structure\nof ResNet (see the exercise in Section 8.6 ). First, we implement this convolution block\nstructure.\ndef conv_block (num_channels):\nreturn nn.Sequential(\nnn.LazyBatchNorm2d(), nn .ReLU(),\nnn.LazyConv2d(num_channels, kernel_size =3, padding =1))\nAdense block consists of multiple convolution blocks, each using the same number of\noutput channels. In the forward propagation, however, weconcatenate the input and output\nof each convolution block on the channel dimension. Lazy evaluation allows us to adjust\nthe dimensionality automatically.\nclass DenseBlock (nn.Module):\ndef __init__ (self , num_convs, num_channels):\nsuper (DenseBlock, self ).__init__ ()\nlayer =[]\nfor iinrange (num_convs):\nlayer .append(conv_block(num_channels))\nself .net =nn.Sequential( *layer)\n(continues on next page)\n314 Modern Convolutional Neural Networks\n(continued from previous page)\ndef forward (self , X):\nfor blk inself .net:\nY=blk(X)\n# Concatenate input and output of each block along the channels\nX=torch .cat((X, Y), dim =1)\nreturn X\nInthefollowingexample,wedefinea DenseBlock instancewithtwoconvolutionblocksof\n10 output channels. When using an input with three channels, we will get an output with\n3\u00b810\u00b810=23channels. The number of convolution block channels controls the growth\nin the number of output channels relative to the number of input channels. This is also\nreferred to as the growthrate .\nblk =DenseBlock( 2,10)\nX=torch .randn( 4,3,8,8)\nY=blk(X)\nY.shape\ntorch .Size([ 4,23,8,8])\n8.7.3TransitionLayers\nSinceeachdenseblockwillincreasethenumberofchannels,addingtoomanyofthemwill\nlead to an excessively complex model. A transitionlayer is used to control the complexity\nof the model. It reduces the number of channels by using a 1\u00021convolution. Moreover, it\nhalves the height and width via average pooling with a stride of 2.\ndef transition_block (num_channels):\nreturn nn.Sequential(\nnn.LazyBatchNorm2d(), nn .ReLU(),\nnn.LazyConv2d(num_channels, kernel_size =1),\nnn.AvgPool2d(kernel_size =2, stride =2))\nApply a transition layer with 10 channels to the output of the dense block in the previous\nexample. This reduces the number of output channels to 10, and halves the height and\nwidth.\nblk =transition_block( 10)\nblk(Y) .shape\ntorch .Size([ 4,10,4,4])\n8.7.4DenseNetModel\n315 Densely Connected Networks (DenseNet)\nNext, we will construct a DenseNet model. DenseNet first uses the same single convolu-\ntional layer and max-pooling layer as in ResNet.\nclass DenseNet (d2l .Classifier):\ndef b1(self ):\nreturn nn.Sequential(\nnn.LazyConv2d( 64, kernel_size =7, stride =2, padding =3),\nnn.LazyBatchNorm2d(), nn .ReLU(),\nnn.MaxPool2d(kernel_size =3, stride =2, padding =1))\nThen, similar to the four modules made up of residual blocks that ResNet uses, DenseNet\nusesfourdenseblocks. AswithResNet,wecansetthenumberofconvolutionallayersused\nin each dense block. Here, we set it to 4, consistent with the ResNet-18 model in Section\n8.6. Furthermore, we set the number of channels (i.e., growth rate) for the convolutional\nlayers in the dense block to 32, so 128 channels will be added to each dense block.\nIn ResNet, the height and width are reduced between each module by a residual block with\na stride of 2. Here, we use the transition layer to halve the height and width and halve the\nnumber of channels. Similar to ResNet, a global pooling layer and a fully connected layer\nare connected at the end to produce the output.", "mimetype": "text/plain", "start_char_idx": 754831, "end_char_idx": 758343, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ed0cfaef-602b-43f1-8596-3f03d96edd4f": {"__data__": {"id_": "ed0cfaef-602b-43f1-8596-3f03d96edd4f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ede0064d-4a3a-4281-b41e-a7632ba5f776", "node_type": "1", "metadata": {}, "hash": "22710dd4611603029c1609f645e85dbbf1c0cad3331178fd851886273e32f253", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5d741aad-6968-4ba2-8105-8f15ccdf5529", "node_type": "1", "metadata": {}, "hash": "b1f3b9ab5120d811e90ed25ac94b0c912983cfa53e7b02ec7b3d8a69d37609f2", "class_name": "RelatedNodeInfo"}}, "text": "AswithResNet,wecansetthenumberofconvolutionallayersused\nin each dense block. Here, we set it to 4, consistent with the ResNet-18 model in Section\n8.6. Furthermore, we set the number of channels (i.e., growth rate) for the convolutional\nlayers in the dense block to 32, so 128 channels will be added to each dense block.\nIn ResNet, the height and width are reduced between each module by a residual block with\na stride of 2. Here, we use the transition layer to halve the height and width and halve the\nnumber of channels. Similar to ResNet, a global pooling layer and a fully connected layer\nare connected at the end to produce the output.\n@d2l .add_to_class(DenseNet)\ndef __init__ (self , num_channels =64, growth_rate =32, arch =(4,4,4,4),\nlr=0.1, num_classes =10):\nsuper (DenseNet, self ).__init__ ()\nself .save_hyperparameters()\nself .net =nn.Sequential( self .b1())\nfor i, num_convs inenumerate (arch):\nself .net.add_module( f'dense_blk {i+1}', DenseBlock(num_convs,\ngrowth_rate))\n# The number of output channels in the previous dense block\nnum_channels +=num_convs *growth_rate\n# A transition layer that halves the number of channels is added\n# between the dense blocks\nifi!=len(arch) -1:\nnum_channels //=2\nself .net.add_module( f'tran_blk {i+1}', transition_block(\nnum_channels))\nself .net.add_module( 'last ', nn .Sequential(\nnn.LazyBatchNorm2d(), nn .ReLU(),\nnn.AdaptiveAvgPool2d(( 1,1)), nn .Flatten(),\nnn.LazyLinear(num_classes)))\nself .net.apply(d2l .init_cnn)\n8.7.5Training\nSince we are using a deeper network here, in this section, we will reduce the input height\nand width from 224 to 96 to simplify the computation.\n316 Modern Convolutional Neural Networks\n134model =DenseNet(lr =0.01 )\ntrainer =d2l.Trainer(max_epochs =10, num_gpus =1)\ndata =d2l.FashionMNIST(batch_size =128, resize =(96,96))\ntrainer .fit(model, data)\n8.7.6Summaryand Discussion\nThe main components that comprise DenseNet are dense blocks and transition layers. For\nthe latter, we need to keep the dimensionality under control when composing the net-\nwork by adding transition layers that shrink the number of channels again. In terms of\ncross-layer connections, in contrast to ResNet, where inputs and outputs are added to-\ngether, DenseNet concatenates inputs and outputs on the channel dimension. Although\nthese concatenation operations reuse features to achieve computational efficiency, unfortu-\nnately they lead to heavy GPU memory consumption. As a result, applying DenseNet may\nrequire more memory-efficient implementations that may increase training time ( Pleisset\nal., 2017).\n8.7.7Exercises\n1.Why do we use average pooling rather than max-pooling in the transition layer?\n2.OneoftheadvantagesmentionedintheDenseNetpaperisthatitsmodelparametersare\nsmaller than those of ResNet. Why is this the case?\n3.One problem for which DenseNet has been criticized is its high memory consumption.\n1.Is this really the case? Try to change the input shape to 224\u0002224to compare the\nactual GPU memory consumption empirically.\n2.Can you think of an alternative means of reducing the memory consumption? How\nwould you need to change the framework?\n4.Implement the various DenseNet versions presented in Table 1 of the DenseNet paper\n(Huangetal., 2017).\n5.Design an MLP-based model by applying the DenseNet idea. Apply it to the housing\nprice prediction task in Section 5.7 .\nDiscussions134.\n317 Designing Convolution Network Architectures\n8.8DesigningConvolutionNetworkArchitectures\nThe previous sections have taken us on a tour of modern network design for computer\nvision. Common to all the work we covered was that it greatly relied on the intuition of\nscientists. Many of the architectures are heavily informed by human creativity and to a\nmuch lesser extent by systematic exploration of the design space that deep networks offer.\nNonetheless, this networkengineering approachhasbeentremendouslysuccessful.\nEver since AlexNet ( Section 8.1 ) beat conventional computer vision models on ImageNet,\nit has become popular to construct very deep networks by stacking blocks of convolutions,\nall designed according to the same pattern.", "mimetype": "text/plain", "start_char_idx": 757704, "end_char_idx": 761813, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5d741aad-6968-4ba2-8105-8f15ccdf5529": {"__data__": {"id_": "5d741aad-6968-4ba2-8105-8f15ccdf5529", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ed0cfaef-602b-43f1-8596-3f03d96edd4f", "node_type": "1", "metadata": {}, "hash": "7eaab1817c741b34f41b174c6d4ee0743a74722d34a19611358545fd56788d61", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "067a7c2d-52a2-49d2-80a3-9f3b081a64b6", "node_type": "1", "metadata": {}, "hash": "bab1a42ce4a7555a4ab0cfdddc14a9f4a7db240ae4f265b5b9b3f5a217c79337", "class_name": "RelatedNodeInfo"}}, "text": "5.Design an MLP-based model by applying the DenseNet idea. Apply it to the housing\nprice prediction task in Section 5.7 .\nDiscussions134.\n317 Designing Convolution Network Architectures\n8.8DesigningConvolutionNetworkArchitectures\nThe previous sections have taken us on a tour of modern network design for computer\nvision. Common to all the work we covered was that it greatly relied on the intuition of\nscientists. Many of the architectures are heavily informed by human creativity and to a\nmuch lesser extent by systematic exploration of the design space that deep networks offer.\nNonetheless, this networkengineering approachhasbeentremendouslysuccessful.\nEver since AlexNet ( Section 8.1 ) beat conventional computer vision models on ImageNet,\nit has become popular to construct very deep networks by stacking blocks of convolutions,\nall designed according to the same pattern. In particular, 3\u00023convolutions were popular-\nized by VGG networks ( Section 8.2 ). NiN ( Section 8.3 ) showed that even 1\u00021convolu-\ntionscouldbebeneficialbyaddinglocalnonlinearities. Moreover,NiNsolvedtheproblem\nof aggregating information at the head of a network by aggregating across all locations.\nGoogLeNet ( Section 8.4 ) added multiple branches of different convolution width, combin-\ning the advantages of VGG and NiN in its Inception block. ResNets ( Section 8.6 ) changed\nthe inductive bias towards the identity mapping (from \ud835\udc53\u00b9\ud835\udc65\u00ba=0). This allowed for very\ndeep networks. Almost a decade later, the ResNet design is still popular, a testament to\nits design. Lastly, ResNeXt ( Section 8.6.5 ) added grouped convolutions, offering a better\ntrade-off between parameters and computation. A precursor to Transformers for vision,\nthe Squeeze-and-Excitation Networks (SENets) allow for efficient information transfer be-\ntween locations ( Huet al., 2018). This was accomplished by computing a per-channel\nglobal attention function.\nUp to now we have omitted networks obtained via neural architecture search (NAS) (Liu\net al., 2018,Zoph and Le, 2016 ). We chose to do so since their cost is usually enormous,\nrelying on brute-force search, genetic algorithms, reinforcement learning, or some other\nform of hyperparameter optimization. Given a fixed search space, NAS uses a search strat-\negy to automatically select an architecture based on the returned performance estimation.\nThe outcome of NAS is a single network instance. EfficientNets are a notable outcome of\nthis search ( Tan and Le, 2019 ).\nIn the following we discuss an idea that is quite different to the quest for the single best\nnetwork. It is computationally relatively inexpensive, it leads to scientific insights on the\nway, and it is quite effective in terms of the quality of outcomes. Let\u2019s review the strategy\nby Radosavovic et al.(2020) todesign network design spaces . The strategy combines the\nstrength of manual design and NAS. It accomplishes this by operating on distributions of\nnetworks and optimizing the distributions in a way to obtain good performance for entire\nfamilies of networks. The outcome of it are RegNets, specifically RegNetX and RegNetY,\nplus a range of guiding principles for the design of performant CNNs.\nimport torch\nfrom torch import nn\n(continues on next page)\n318 Modern Convolutional Neural Networks\n(continued from previous page)\nfrom torch .nnimport functional asF\nfrom d2l import torch asd2l\n8.8.1TheAnyNetDesign Space\nThedescriptionbelowcloselyfollowsthereasoninginRadosavovic etal.(2020)withsome\nabbreviations to make it fit in the scope of the book. To begin, we need a template for the\nfamily of networks to explore. One of the commonalities of the designs in this chapter is\nthat the networks consist of a stem, abodyand ahead. The stem performs initial image\nprocessing, often through convolutions with a larger window size. The body consists of\nmultipleblocks,carryingoutthebulkofthetransformationsneededtogofromrawimages\nto object representations. Lastly, the head converts this into the desired outputs, such as\nviaasoftmaxregressorformulticlassclassification. Thebody, inturn, consistsofmultiple\nstages, operating on the image at decreasing resolutions. In fact, both the stem and each\nsubsequent stage quarter the spatial resolution. Lastly, each stage consists of one or more\nblocks.", "mimetype": "text/plain", "start_char_idx": 760933, "end_char_idx": 765216, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "067a7c2d-52a2-49d2-80a3-9f3b081a64b6": {"__data__": {"id_": "067a7c2d-52a2-49d2-80a3-9f3b081a64b6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5d741aad-6968-4ba2-8105-8f15ccdf5529", "node_type": "1", "metadata": {}, "hash": "b1f3b9ab5120d811e90ed25ac94b0c912983cfa53e7b02ec7b3d8a69d37609f2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "dda8ba92-a80d-41b8-b3d7-adbf79c3fd5c", "node_type": "1", "metadata": {}, "hash": "4d671c61e97d056479087b4381a8bf7f2beae78296d8b22cc6ef67966bfc84e9", "class_name": "RelatedNodeInfo"}}, "text": "(2020)withsome\nabbreviations to make it fit in the scope of the book. To begin, we need a template for the\nfamily of networks to explore. One of the commonalities of the designs in this chapter is\nthat the networks consist of a stem, abodyand ahead. The stem performs initial image\nprocessing, often through convolutions with a larger window size. The body consists of\nmultipleblocks,carryingoutthebulkofthetransformationsneededtogofromrawimages\nto object representations. Lastly, the head converts this into the desired outputs, such as\nviaasoftmaxregressorformulticlassclassification. Thebody, inturn, consistsofmultiple\nstages, operating on the image at decreasing resolutions. In fact, both the stem and each\nsubsequent stage quarter the spatial resolution. Lastly, each stage consists of one or more\nblocks. This pattern is common to all networks, from VGG to ResNeXt. Indeed, for the\ndesign of generic AnyNet networks, Radosavovic etal.(2020) used the ResNeXt block of\nFig. 8.6.5 .\ntFig. 8.8.1 The AnyNet design space. The numbers \u00b9c,r\u00baalong each arrow indicate the number of\nchannels c and the resolution r\u0002rof the images at that point. From left to right: generic\nnetwork structure composed of stem, body, and head; body composed of four stages;\ndetailed structure of a stage; two alternative structures for blocks, one without\ndownsampling and one that halves the resolution in each dimension. Design choices\ninclude depth di, the number of output channels ci, the number of groups gi, and\nbottleneck ratio kifor any stage i.\nLet\u2019sreviewthestructureoutlinedin Fig.8.8.1 indetail. Asmentioned,anAnyNetconsists\nof a stem, body, and head. The stem takes as its input RGB images (3 channels), using a\n3\u00023convolution with a stride of 2, followed by a batch norm, to halve the resolution from\n\ud835\udc5f\u0002\ud835\udc5fto\ud835\udc5f\u009d2\u0002\ud835\udc5f\u009d2. Moreover,itgenerates \ud835\udc500channelsthatserveasinputtothebody.\n319 Designing Convolution Network Architectures\nSince the network is designed to work well with ImageNet images of shape 224\u0002224\u00023,\nthe body serves to reduce this to 7\u00027\u0002\ud835\udc504through 4 stages (recall that 224\u009d21\u00b84=7),\neach with an eventual stride of 2. Lastly, the head employs an entirely standard design via\nglobal average pooling, similar to NiN ( Section 8.3 ), followed by a fully connected layer to\nemit an\ud835\udc5b-dimensional vector for \ud835\udc5b-class classification.\nMostoftherelevantdesigndecisionsareinherenttothebodyofthenetwork. Itproceedsin\nstages, where each stage is composed of the same type of ResNeXt blocks as we discussed\ninSection 8.6.5 . The design there is again entirely generic: we begin with a block that\nhalves the resolution by using a stride of 2(the rightmost in Fig. 8.8.1 ). To match this, the\nresidualbranchoftheResNeXtblockneedstopassthrougha 1\u00021convolution. Thisblock\nis followed by a variable number of additional ResNeXt blocks that leave both resolution\nand the number of channels unchanged. Note that a common design practice is to add\na slight bottleneck in the design of convolutional blocks. As such, with bottleneck ratio\n\ud835\udc58\ud835\udc56\u00151we afford some number of channels, \ud835\udc50\ud835\udc56\u009d\ud835\udc58\ud835\udc56, within each block for stage \ud835\udc56(as the\nexperiments show, this is not really effective and should be skipped). Lastly, since we are\ndealing with ResNeXt blocks, we also need to pick the number of groups \ud835\udc54\ud835\udc56for grouped\nconvolutions at stage \ud835\udc56.\nThis seemingly generic design space provides us nonetheless with many parameters: we\ncan set the block width (number of channels) \ud835\udc500,...\ud835\udc50 4, the depth (number of blocks) per\nstage\ud835\udc511,...\ud835\udc51 4, the bottleneck ratios \ud835\udc581,...\ud835\udc58 4, and the group widths (numbers of groups)\n\ud835\udc541,...\ud835\udc54 4.", "mimetype": "text/plain", "start_char_idx": 764404, "end_char_idx": 767979, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dda8ba92-a80d-41b8-b3d7-adbf79c3fd5c": {"__data__": {"id_": "dda8ba92-a80d-41b8-b3d7-adbf79c3fd5c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "067a7c2d-52a2-49d2-80a3-9f3b081a64b6", "node_type": "1", "metadata": {}, "hash": "bab1a42ce4a7555a4ab0cfdddc14a9f4a7db240ae4f265b5b9b3f5a217c79337", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d6a201b0-d2f1-4e35-aa3d-c78a9d683b49", "node_type": "1", "metadata": {}, "hash": "1fab1148476d6c8325167b110dcd9ad8dcff704fac0d7ba991944fa89e078339", "class_name": "RelatedNodeInfo"}}, "text": "As such, with bottleneck ratio\n\ud835\udc58\ud835\udc56\u00151we afford some number of channels, \ud835\udc50\ud835\udc56\u009d\ud835\udc58\ud835\udc56, within each block for stage \ud835\udc56(as the\nexperiments show, this is not really effective and should be skipped). Lastly, since we are\ndealing with ResNeXt blocks, we also need to pick the number of groups \ud835\udc54\ud835\udc56for grouped\nconvolutions at stage \ud835\udc56.\nThis seemingly generic design space provides us nonetheless with many parameters: we\ncan set the block width (number of channels) \ud835\udc500,...\ud835\udc50 4, the depth (number of blocks) per\nstage\ud835\udc511,...\ud835\udc51 4, the bottleneck ratios \ud835\udc581,...\ud835\udc58 4, and the group widths (numbers of groups)\n\ud835\udc541,...\ud835\udc54 4. Intotalthisaddsupto17parameters, resultinginanunreasonablylargenumber\nof configurations that would warrant exploring. We need some tools to reduce this huge\ndesign space effectively. This is where the conceptual beauty of design spaces comes in.\nBefore we do so, let\u2019s implement the generic design first.\nclass AnyNet (d2l .Classifier):\ndef stem (self , num_channels):\nreturn nn.Sequential(\nnn.LazyConv2d(num_channels, kernel_size =3, stride =2, padding =1),\nnn.LazyBatchNorm2d(), nn .ReLU())\nEach stage consists of depthResNeXt blocks, where num_channels specifies the block\nwidth. Note that the first block halves the height and width of input images.\n@d2l .add_to_class(AnyNet)\ndef stage (self , depth, num_channels, groups, bot_mul):\nblk =[]\nfor iinrange (depth):\nifi==0:\nblk.append(d2l .ResNeXtBlock(num_channels, groups, bot_mul,\nuse_1x1conv =True , strides =2))\nelse :\nblk.append(d2l .ResNeXtBlock(num_channels, groups, bot_mul))\nreturn nn.Sequential( *blk)\nPutting the network stem, body, and head together, we complete the implementation of\nAnyNet.\n320 Modern Convolutional Neural Networks\n@d2l .add_to_class(AnyNet)\ndef __init__ (self , arch, stem_channels, lr =0.1, num_classes =10):\nsuper (AnyNet, self ).__init__ ()\nself .save_hyperparameters()\nself .net =nn.Sequential( self .stem(stem_channels))\nfor i, s inenumerate (arch):\nself .net.add_module( f'stage {i+1}',self .stage( *s))\nself .net.add_module( 'head ', nn .Sequential(\nnn.AdaptiveAvgPool2d(( 1,1)), nn .Flatten(),\nnn.LazyLinear(num_classes)))\nself .net.apply(d2l .init_cnn)\n8.8.2Distributions and Parametersof Design Spaces\nAs just discussed in Section 8.8.1 , parameters of a design space are hyperparameters of\nnetworks in that design space. Consider the problem of identifying good parameters in the\nAnyNet design space. We could try finding the single best parameter choice for a given\namount of computation (e.g., FLOPs and compute time). If we allowed for even only two\npossible choices for each parameter, we would have to explore 217=131072combinations\nto find the best solution. This is clearly infeasible because of its exorbitant cost. Even\nworse,wedonotreallylearnanythingfromthisexerciseintermsofhowoneshoulddesign\nanetwork. Nexttimeweadd,say,anX-stage,orashiftoperation,orsimilar,wewouldneed\nto start from scratch. Even worse, due to the stochasticity in training (rounding, shuffling,\nbit errors), no two runs are likely to produce exactly the same results. A better strategy\nwould be to try to determine general guidelines of how the choices of parameters should\nbe related. For instance, the bottleneck ratio, the number of channels, blocks, groups, or\ntheirchangebetweenlayersshouldideallybegovernedbyacollectionofsimplerules. The\napproach in Radosavovic etal.(2019) relies on the following four assumptions:\n1.We assume that general design principles actually exist, so that many networks satis-\nfying these requirements should offer good performance. Consequently, identifying a\ndistribution over networks can be a sensible strategy. In other words, we assume that\nthere are many good needles in the haystack.\n2.We need not train networks to convergence before we can assess whether a network is\ngood.", "mimetype": "text/plain", "start_char_idx": 767389, "end_char_idx": 771174, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d6a201b0-d2f1-4e35-aa3d-c78a9d683b49": {"__data__": {"id_": "d6a201b0-d2f1-4e35-aa3d-c78a9d683b49", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "dda8ba92-a80d-41b8-b3d7-adbf79c3fd5c", "node_type": "1", "metadata": {}, "hash": "4d671c61e97d056479087b4381a8bf7f2beae78296d8b22cc6ef67966bfc84e9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f4e32fb4-2876-4510-8630-08136a9554c1", "node_type": "1", "metadata": {}, "hash": "09ccee323210d03915d0e893108c5007c57b66aae59203f78a79004cd06177b3", "class_name": "RelatedNodeInfo"}}, "text": "Even worse, due to the stochasticity in training (rounding, shuffling,\nbit errors), no two runs are likely to produce exactly the same results. A better strategy\nwould be to try to determine general guidelines of how the choices of parameters should\nbe related. For instance, the bottleneck ratio, the number of channels, blocks, groups, or\ntheirchangebetweenlayersshouldideallybegovernedbyacollectionofsimplerules. The\napproach in Radosavovic etal.(2019) relies on the following four assumptions:\n1.We assume that general design principles actually exist, so that many networks satis-\nfying these requirements should offer good performance. Consequently, identifying a\ndistribution over networks can be a sensible strategy. In other words, we assume that\nthere are many good needles in the haystack.\n2.We need not train networks to convergence before we can assess whether a network is\ngood. Instead, it is sufficient to use the intermediate results as reliable guidance for\nfinal accuracy. Using (approximate) proxies to optimize an objective is referred to as\nmulti-fidelityoptimization( Forrester etal.,2007). Consequently,designoptimizationis\ncarried out, based on the accuracy achieved after only a few passes through the dataset,\nreducing the cost significantly.\n3.Resultsobtainedatasmallerscale(forsmallernetworks)generalizetolargerones. Con-\nsequently, optimization is carried out for networks that are structurally similar, but with\na smaller number of blocks, fewer channels, etc. Only in the end will we need to verify\nthat the so-found networks also offer good performance at scale.\n4.Aspects of the design can be approximately factorized so that it is possible to infer\n321 Designing Convolution Network Architectures\ntheir effect on the quality of the outcome somewhat independently. In other words, the\noptimization problem is moderately easy.\nThese assumptions allow us to test many networks cheaply. In particular, we can sample\nuniformly from the space of configurations and evaluate their performance. Subsequently,\nwe can evaluate the quality of the choice of parameters by reviewing the distribution of\nerror/accuracy that can be achieved with said networks. Denote by \ud835\udc39\u00b9\ud835\udc52\u00bathe cumulative\ndistribution function (CDF) for errors committed by networks of a given design space,\ndrawn using probability disribution \ud835\udc5d. That is,\n\ud835\udc39\u00b9\ud835\udc52,\ud835\udc5d\u00badef=\ud835\udc43net\u0018\ud835\udc5df\ud835\udc52\u00b9net\u00ba\u0014\ud835\udc52g. (8.8.1)\nOur goal is now to find a distribution \ud835\udc5dovernetworks such that most networks have a very\nlow error rate and where the support of \ud835\udc5dis concise. Of course, this is computationally\ninfeasible to perform accurately. We resort to a sample of networks Zdef=fnet1,...net\ud835\udc5bg\n(witherrors\ud835\udc521,...,\ud835\udc52\ud835\udc5b,respectively)from \ud835\udc5dandusetheempiricalCDF \u02c6\ud835\udc39\u00b9\ud835\udc52,Z\u00bainstead:\n\u02c6\ud835\udc39\u00b9\ud835\udc52,Z\u00ba=1\n\ud835\udc5b\ud835\udc5b\u00d5\n\ud835\udc56=11\u00b9\ud835\udc52\ud835\udc56\u0014\ud835\udc52\u00ba. (8.8.2)\nWhenever the CDF for one set of choices majorizes (or matches) another CDF it follows\nthat its choice of parameters is superior (or indifferent). Accordingly Radosavovic et al.\n(2020) experimented with a shared network bottleneck ratio \ud835\udc58\ud835\udc56=\ud835\udc58for all stages \ud835\udc56of the\nnetwork. This gets rid of three of the four parameters governing the bottleneck ratio. To\nassess whether this (negatively) affects the performance one can draw networks from the\nconstrained and from the unconstrained distribution and compare the corresonding CDFs.\nIt turns out that this constraint does not affect the accuracy of the distribution of networks\nat all, as can be seen in the first panel of Fig. 8.8.2 . Likewise, we could choose to pick\nthe same group width \ud835\udc54\ud835\udc56=\ud835\udc54occurring at the various stages of the network. Again, this\ndoes not affect performance, as can be seen in the second panel of Fig. 8.8.2 . Both steps\ncombined reduce the number of free parameters by six.\ntFig. 8.8.2 Comparing error empirical distribution functions of design spaces.", "mimetype": "text/plain", "start_char_idx": 770282, "end_char_idx": 774062, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f4e32fb4-2876-4510-8630-08136a9554c1": {"__data__": {"id_": "f4e32fb4-2876-4510-8630-08136a9554c1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d6a201b0-d2f1-4e35-aa3d-c78a9d683b49", "node_type": "1", "metadata": {}, "hash": "1fab1148476d6c8325167b110dcd9ad8dcff704fac0d7ba991944fa89e078339", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9cd6319e-f239-4045-8650-2ffb30c28565", "node_type": "1", "metadata": {}, "hash": "4cd606f380fe515d14846b089df1c0eca983dc06f2ffb39d6a3998d89a26ba6b", "class_name": "RelatedNodeInfo"}}, "text": "This gets rid of three of the four parameters governing the bottleneck ratio. To\nassess whether this (negatively) affects the performance one can draw networks from the\nconstrained and from the unconstrained distribution and compare the corresonding CDFs.\nIt turns out that this constraint does not affect the accuracy of the distribution of networks\nat all, as can be seen in the first panel of Fig. 8.8.2 . Likewise, we could choose to pick\nthe same group width \ud835\udc54\ud835\udc56=\ud835\udc54occurring at the various stages of the network. Again, this\ndoes not affect performance, as can be seen in the second panel of Fig. 8.8.2 . Both steps\ncombined reduce the number of free parameters by six.\ntFig. 8.8.2 Comparing error empirical distribution functions of design spaces. AnyNetAis the\noriginal design space; AnyNetBties the bottleneck ratios, AnyNetCalso ties group\nwidths,AnyNetDincreases the network depth across stages. From left to right: (i) tying\nbottleneck ratios has no effect on performance; (ii) tying group widths has no effect on\nperformance; (iii) increasing network widths (channels) across stages improves\nperformance; (iv) increasing network depths across stages improves performance. Figure\ncourtesy of Radosavovic et al. ( 2020 ).\nNextwelookforwaystoreducethemultitudeofpotentialchoicesforwidthanddepthofthe\n322 Modern Convolutional Neural Networks\nstages. It is a reasonable assumption that, as we go deeper, the number of channels should\nincrease, i.e., \ud835\udc50\ud835\udc56\u0015\ud835\udc50\ud835\udc56\u00001(\ud835\udc64\ud835\udc56\u00b81\u0015\ud835\udc64\ud835\udc56per their notation in Fig. 8.8.2 ), yielding AnyNetX\ud835\udc37.\nLikewise,itisequallyreasonabletoassumethatasthestagesprogress,theyshouldbecome\ndeeper,i.e.,\ud835\udc51\ud835\udc56\u0015\ud835\udc51\ud835\udc56\u00001,yieldingAnyNetX\ud835\udc38. Thiscanbeexperimentallyverifiedinthethird\nand fourth panel of Fig. 8.8.2 , respectively.\n8.8.3RegNet\nTheresultingAnyNetX\ud835\udc38designspaceconsistsofsimplenetworksfollowingeasy-to-interpret\ndesign principles:\n\u000fShare the bottleneck ratio \ud835\udc58\ud835\udc56=\ud835\udc58for all stages \ud835\udc56;\n\u000fShare the group width \ud835\udc54\ud835\udc56=\ud835\udc54for all stages \ud835\udc56;\n\u000fIncrease network width across stages: \ud835\udc50\ud835\udc56\u0014\ud835\udc50\ud835\udc56\u00b81;\n\u000fIncrease network depth across stages: \ud835\udc51\ud835\udc56\u0014\ud835\udc51\ud835\udc56\u00b81.\nThis leaves us with a final set of choices: how to pick the specific values for the above\nparameters of the eventual AnyNetX\ud835\udc38design space. By studying the best-performing\nnetworks from the distribution in AnyNetX\ud835\udc38one can observe the following: the width\nof the network ideally increases linearly with the block index across the network, i.e.,\n\ud835\udc50\ud835\udc57\u0019\ud835\udc500\u00b8\ud835\udc50\ud835\udc4e\ud835\udc57, where\ud835\udc57is the block index and slope \ud835\udc50\ud835\udc4e>0. Given that we get to choose a\ndifferent block width only per stage, wearrive at a piecewise constantfunction, engineered\nto match this dependence. Furthermore, experiments also show that a bottleneck ratio of\n\ud835\udc58=1performs best, i.e., we are advised not to use bottlenecks at all.\nWe recommend the interested reader reviews further details in the design of specific net-\nworks for different amounts of computation by perusing Radosavovic et al.(2020). For\ninstance, an effective 32-layer RegNetX variant is given by \ud835\udc58=1(no bottleneck), \ud835\udc54=16\n(group width is 16), \ud835\udc501=32and\ud835\udc502=80channels for the first and second stage, respec-\ntively, chosen to be \ud835\udc511=4and\ud835\udc512=6blocks deep. The astonishing insight from the\ndesign is that it still applies, even when investigating networks at a larger scale. Even bet-\nter, it even holds for Squeeze-and-Excitation (SE) network designs (RegNetY) that have a\nglobal channel activation ( Huetal., 2018).", "mimetype": "text/plain", "start_char_idx": 773311, "end_char_idx": 776668, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9cd6319e-f239-4045-8650-2ffb30c28565": {"__data__": {"id_": "9cd6319e-f239-4045-8650-2ffb30c28565", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f4e32fb4-2876-4510-8630-08136a9554c1", "node_type": "1", "metadata": {}, "hash": "09ccee323210d03915d0e893108c5007c57b66aae59203f78a79004cd06177b3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ae457299-c48f-4275-a94f-79b808571acb", "node_type": "1", "metadata": {}, "hash": "8f4974672fc8205e071dd636c87e1bc0307ee23e8b83304b5aecaf67cb7f8fc5", "class_name": "RelatedNodeInfo"}}, "text": "We recommend the interested reader reviews further details in the design of specific net-\nworks for different amounts of computation by perusing Radosavovic et al.(2020). For\ninstance, an effective 32-layer RegNetX variant is given by \ud835\udc58=1(no bottleneck), \ud835\udc54=16\n(group width is 16), \ud835\udc501=32and\ud835\udc502=80channels for the first and second stage, respec-\ntively, chosen to be \ud835\udc511=4and\ud835\udc512=6blocks deep. The astonishing insight from the\ndesign is that it still applies, even when investigating networks at a larger scale. Even bet-\nter, it even holds for Squeeze-and-Excitation (SE) network designs (RegNetY) that have a\nglobal channel activation ( Huetal., 2018).\nclass RegNetX32 (AnyNet):\ndef __init__ (self , lr =0.1, num_classes =10):\nstem_channels, groups, bot_mul =32,16,1\ndepths, channels =(4,6), ( 32,80)\nsuper ().__init__ (\n((depths[ 0], channels[ 0], groups, bot_mul),\n(depths[ 1], channels[ 1], groups, bot_mul)),\nstem_channels, lr, num_classes)\nWe can see that each RegNetX stage progressively reduces resolution and increases output\nchannels.\n323 Designing Convolution Network Architectures\nRegNetX32() .layer_summary(( 1,1,96,96))\nSequential output shape: torch .Size([ 1,32,48,48])\nSequential output shape: torch .Size([ 1,32,24,24])\nSequential output shape: torch .Size([ 1,80,12,12])\nSequential output shape: torch .Size([ 1,10])\n8.8.4Training\nTraining the 32-layer RegNetX on the Fashion-MNIST dataset is just like before.\nmodel =RegNetX32(lr =0.05 )\ntrainer =d2l.Trainer(max_epochs =10, num_gpus =1)\ndata =d2l.FashionMNIST(batch_size =128, resize =(96,96))\ntrainer .fit(model, data)\n8.8.5Discussion\nWith desirable inductive biases (assumptions or preferences) like locality and translation\ninvariance( Section7.1 )forvision,CNNshavebeenthedominantarchitecturesinthisarea.\nThis remained the case from LeNet up until Transformers ( Section 11.7 ) (Dosovitskiy et\nal.,2021,Touvronetal.,2021)startedsurpassingCNNsintermsofaccuracy. Whilemuch\nof the recent progress in terms of vision Transformers canbe backported into CNNs ( Liu\net al., 2022), it is only possible at a higher computational cost. Just as importantly, recent\nhardwareoptimizations(NVIDIAAmpereandHopper)haveonlywidenedthegapinfavor\nof Transformers.\nIt is worth noting that Transformers have a significantly lower degree of inductive bias to-\nwards locality and translation invariance than CNNs. That learned structures prevailed is\ndue, not least, to the availability of large image collections, such as LAION-400m and\nLAION-5B ( Schuhmann et al., 2022) with up to 5 billion images. Quite surprisingly,\nsome of the more relevant work in this context even includes MLPs ( Tolstikhin et al.,\n2021).\nIn sum, vision Transformers ( Section 11.8 ) by now lead in terms of state-of-the-art perfor-\nmance in large-scale image classification, showing that scalabilitytrumpsinductivebiases\n324 Modern Convolutional Neural Networks\n135(Dosovitskiy et al., 2021). This includes pretraining large-scale Transformers ( Section\n11.9) with multi-head self-attention ( Section 11.5 ). We invite the readers to dive into these\nchapters for a much more detailed discussion.\n8.8.6Exercises\n1.Increase the number of stages to four. Can you design a deeper RegNetX that performs\nbetter?\n2.De-ResNeXt-ify RegNets by replacing the ResNeXt block with the ResNet block. How\ndoes your new model perform?\n3.Implementmultipleinstancesofa\u201cVioNet\u201dfamilyby violating thedesignprinciplesof\nRegNetX. How do they perform? Which of ( \ud835\udc51\ud835\udc56,\ud835\udc50\ud835\udc56,\ud835\udc54\ud835\udc56,\ud835\udc4f\ud835\udc56) is the most important factor?\n4.Your goal is to design the \u201cperfect\u201d MLP.", "mimetype": "text/plain", "start_char_idx": 776020, "end_char_idx": 779569, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ae457299-c48f-4275-a94f-79b808571acb": {"__data__": {"id_": "ae457299-c48f-4275-a94f-79b808571acb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9cd6319e-f239-4045-8650-2ffb30c28565", "node_type": "1", "metadata": {}, "hash": "4cd606f380fe515d14846b089df1c0eca983dc06f2ffb39d6a3998d89a26ba6b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "df9e68bd-2ecf-49a5-81db-e6c7260409c2", "node_type": "1", "metadata": {}, "hash": "b23fada5f33e5acc9eb91b5f2e4cc7c14583722ed662dc2039d7a475e1dca9f1", "class_name": "RelatedNodeInfo"}}, "text": "This includes pretraining large-scale Transformers ( Section\n11.9) with multi-head self-attention ( Section 11.5 ). We invite the readers to dive into these\nchapters for a much more detailed discussion.\n8.8.6Exercises\n1.Increase the number of stages to four. Can you design a deeper RegNetX that performs\nbetter?\n2.De-ResNeXt-ify RegNets by replacing the ResNeXt block with the ResNet block. How\ndoes your new model perform?\n3.Implementmultipleinstancesofa\u201cVioNet\u201dfamilyby violating thedesignprinciplesof\nRegNetX. How do they perform? Which of ( \ud835\udc51\ud835\udc56,\ud835\udc50\ud835\udc56,\ud835\udc54\ud835\udc56,\ud835\udc4f\ud835\udc56) is the most important factor?\n4.Your goal is to design the \u201cperfect\u201d MLP. Can you use the design principles introduced\nabove to find good architectures? Is it possible to extrapolate from small to large net-\nworks?\nDiscussions135.\n9 Recurrent Neural Networks\nUpuntilnow,wehavefocusedprimarilyonfixed-lengthdata. Whenintroducinglinearand\nlogistic regression in Chapter 3 andChapter 4 and multilayer perceptrons in Chapter 5 , we\nwerehappytoassumethateachfeaturevector x\ud835\udc56consistedofafixednumberofcomponents\n\ud835\udc651,...,\ud835\udc65\ud835\udc51, where each numerical feature \ud835\udc65\ud835\udc57corresponded to a particular attribute. These\ndatasets are sometimes called tabular, because they can be arranged in tables, where each\nexample\ud835\udc56gets its own row, and each attribute gets its own column. Crucially, with tabular\ndata, we seldom assume any particular structure over the columns.\nSubsequently, in Chapter 7 , we moved on to image data, where inputs consist of the raw\npixelvaluesateachcoordinateinanimage. Imagedatahardlyfittedthebillofaprotypical\ntabular dataset. There, we needed to call upon convolutional neural networks (CNNs) to\nhandle the hierarchical structure and invariances. However, our data were still of fixed\nlength. Every Fashion-MNIST image is represented as a 28\u000228grid of pixel values.\nMoreover,ourgoalwastodevelopamodelthatlookedatjustoneimageandthenoutputted\na single prediction. But what should we do when faced with a sequence of images, as in a\nvideo, or when tasked with producing a sequentiallystructured prediction, as in the case of\nimage captioning?\nAgreatmanylearningtasksrequiredealingwithsequentialdata. Imagecaptioning,speech\nsynthesis, and music generation all require that models produce outputs consisting of se-\nquences. In other domains, such as time series prediction, video analysis, and musical\ninformation retrieval, a model must learn from inputs that are sequences. These demands\noften arise simultaneously: tasks such as translating passages of text from one natural lan-\nguage to another, engaging in dialogue, or controlling a robot, demand that models both\ningest and output sequentially structured data.\nRecurrent neural networks (RNNs) are deep learning models that capture the dynamics of\nsequences via recurrent connections, which can be thought of as cycles in the network of\nnodes. This might seem counterintuitive at first. After all, it is the feedforward nature of\nneural networks that makes the order of computation unambiguous. However, recurrent\nedges are defined in a precise way that ensures that no such ambiguity can arise. Recurrent\nneural networks are unrolled across time steps (or sequence steps), with the sameunder-\nlying parameters applied at each step. While the standard connections are applied syn-\nchronously to propagate each layer\u2019s activations to the subsequent layer at the same time\nstep,therecurrentconnectionsare dynamic ,passinginformationacrossadjacenttimesteps.\nAs the unfolded view in Fig. 9.1 reveals, RNNs can be thought of as feedforward neural\n325\n326 Recurrent Neural Networks\nnetworkswhereeachlayer\u2019sparameters(bothconventionalandrecurrent)aresharedacross\ntime steps.\ntFig. 9.1 On the left recurrent connections are depicted via cyclic edges. On the right, we unfold\nthe RNN over time steps. Here, recurrent edges span adjacent time steps, while\nconventional connections are computed synchronously.\nLike neural networks more broadly, RNNs have a long discipline-spanning history, origi-\nnating as models of the brain popularized by cognitive scientists and subsequently adopted\nas practical modeling tools employed by the machine learning community.", "mimetype": "text/plain", "start_char_idx": 778937, "end_char_idx": 783096, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "df9e68bd-2ecf-49a5-81db-e6c7260409c2": {"__data__": {"id_": "df9e68bd-2ecf-49a5-81db-e6c7260409c2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ae457299-c48f-4275-a94f-79b808571acb", "node_type": "1", "metadata": {}, "hash": "8f4974672fc8205e071dd636c87e1bc0307ee23e8b83304b5aecaf67cb7f8fc5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b3c0c935-51bf-46d3-9c70-fae814ab7935", "node_type": "1", "metadata": {}, "hash": "f989df0b83db938208e99972d3be25db8900356bd2fd9412608a3bfbce054a43", "class_name": "RelatedNodeInfo"}}, "text": "While the standard connections are applied syn-\nchronously to propagate each layer\u2019s activations to the subsequent layer at the same time\nstep,therecurrentconnectionsare dynamic ,passinginformationacrossadjacenttimesteps.\nAs the unfolded view in Fig. 9.1 reveals, RNNs can be thought of as feedforward neural\n325\n326 Recurrent Neural Networks\nnetworkswhereeachlayer\u2019sparameters(bothconventionalandrecurrent)aresharedacross\ntime steps.\ntFig. 9.1 On the left recurrent connections are depicted via cyclic edges. On the right, we unfold\nthe RNN over time steps. Here, recurrent edges span adjacent time steps, while\nconventional connections are computed synchronously.\nLike neural networks more broadly, RNNs have a long discipline-spanning history, origi-\nnating as models of the brain popularized by cognitive scientists and subsequently adopted\nas practical modeling tools employed by the machine learning community. As we do for\ndeeplearningmorebroadly,inthisbookweadoptthemachinelearningperspective,focus-\ning on RNNs as practical tools that rose to popularity in the 2010s owing to breakthrough\nresults on such diverse tasks as handwriting recognition ( Graveset al., 2008), machine\ntranslation( Sutskever etal.,2014),andrecognizingmedicaldiagnoses( Liptonetal.,2016).\nWepointthereaderinterestedinmorebackgroundmaterialtoapubliclyavailablecompre-\nhensivereview( Liptonetal.,2015). WealsonotethatsequentialityisnotuniquetoRNNs.\nForexample,theCNNsthatwealreadyintroducedcanbeadaptedtohandledataofvarying\nlength, e.g., images of varying resolution. Moreover, RNNs have recently ceded consider-\nable market share to Transformer models, which will be covered in Chapter 11 . However,\nRNNs rose to prominence as the default models for handling complex sequential structure\nin deep learning, and remain staple models for sequential modeling to this day. The stories\nof RNNs and of sequence modeling are inextricably linked, and this is as much a chapter\nabout the ABCs of sequence modeling problems as it is a chapter about RNNs.\nOne key insight paved the way for a revolution in sequence modeling. While the inputs\nand targets for many fundamental tasks in machine learning cannot easily be represented\nas fixed-length vectors, they can often nevertheless be represented as varying-length se-\nquences of fixed-length vectors. For example, documents can be represented as sequences\nof words; medical records can often be represented as sequences of events (encounters,\nmedications,procedures,labtests,diagnoses); videoscanberepresentedasvarying-length\nsequences of still images.\nWhilesequencemodelshavepoppedupinnumerousapplicationareas,basicresearchinthe\nareahasbeendrivenpredominantlybyadvancesoncoretasksinnaturallanguageprocess-\ning. Thus, throughout this chapter, we will focus our exposition and examples on text data.\nIf you get the hang of these examples, then applying the models to other data modalities\nshould be relatively straightforward. In the next few sections, we introduce basic notation\nforsequencesandsomeevaluationmeasuresforassessingthequalityofsequentiallystruc-\nturedmodeloutputs. Afterthat,wediscussbasicconceptsofalanguagemodelandusethis\n327 Working with Sequences\ndiscussion to motivate our first RNN models. Finally, we describe the method for calculat-\ning gradients when backpropagating through RNNs and explore some challenges that are\noftenencounteredwhentrainingsuchnetworks, motivatingthemodernRNNarchitectures\nthat will follow in Chapter 10 .\n9.1Workingwith Sequences\nUp until now, we have focused on models whose inputs consisted of a single feature vector\nx2R\ud835\udc51. The main change of perspective when developing models capable of processing\nsequences is that we now focus on inputs that consist of an ordered list of feature vec-\ntorsx1,...,x\ud835\udc47, where each feature vector x\ud835\udc61is indexed by a time step \ud835\udc612Z\u00b8lying in\nR\ud835\udc51.\nSome datasets consist of a single massive sequence. Consider, for example, the extremely\nlong streams of sensor readings that might be available to climate scientists. In such cases,\nwe might create training datasets by randomly sampling subsequences of some predeter-\nmined length. More often, our data arrives as a collection of sequences.", "mimetype": "text/plain", "start_char_idx": 782180, "end_char_idx": 786367, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b3c0c935-51bf-46d3-9c70-fae814ab7935": {"__data__": {"id_": "b3c0c935-51bf-46d3-9c70-fae814ab7935", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "df9e68bd-2ecf-49a5-81db-e6c7260409c2", "node_type": "1", "metadata": {}, "hash": "b23fada5f33e5acc9eb91b5f2e4cc7c14583722ed662dc2039d7a475e1dca9f1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8a1180e1-2815-4bb4-bea9-7ddfe04ca59a", "node_type": "1", "metadata": {}, "hash": "c221889823a63384c597bedabe82598a3f3b7e4883e04c05c1a4f5036afcfdef", "class_name": "RelatedNodeInfo"}}, "text": "9.1Workingwith Sequences\nUp until now, we have focused on models whose inputs consisted of a single feature vector\nx2R\ud835\udc51. The main change of perspective when developing models capable of processing\nsequences is that we now focus on inputs that consist of an ordered list of feature vec-\ntorsx1,...,x\ud835\udc47, where each feature vector x\ud835\udc61is indexed by a time step \ud835\udc612Z\u00b8lying in\nR\ud835\udc51.\nSome datasets consist of a single massive sequence. Consider, for example, the extremely\nlong streams of sensor readings that might be available to climate scientists. In such cases,\nwe might create training datasets by randomly sampling subsequences of some predeter-\nmined length. More often, our data arrives as a collection of sequences. Consider the\nfollowingexamples: (i)acollectionofdocuments, eachrepresentedasitsownsequenceof\nwords,andeachhavingitsownlength \ud835\udc47\ud835\udc56;(ii)sequencerepresentationofpatientstaysinthe\nhospital, where each stay consists of a number of events and the sequence length depends\nroughly on the length of the stay.\nPreviously, when dealing with individual inputs, we assumed that they were sampled inde-\npendently from the same underlying distribution \ud835\udc43\u00b9\ud835\udc4b\u00ba. While we still assume that entire\nsequences (e.g., entire documents or patient trajectories) are sampled independently, we\ncannot assume that the data arriving at each time step are independent of each other. For\nexample, the words that likely to appear later in a document depend heavily on words oc-\ncurring earlier in the document. The medicine a patient is likely to receive on the 10th day\nof a hospital visit depends heavily on what transpired in the previous nine days.\nThis should come as no surprise. If we did not believe that the elements in a sequence\nwere related, we would not have bothered to model them as a sequence in the first place.\nConsidertheusefulnessoftheauto-fillfeaturesthatarepopularonsearchtoolsandmodern\nemail clients. They are useful precisely because it is often possible to predict (imperfectly,\nbut better than random guessing) what the likely continuations of a sequence might be,\ngiven some initial prefix. For most sequence models, we do not require independence, or\neven stationarity, of our sequences. Instead, we require only that the sequences themselves\nare sampled from some fixed underlying distribution over entire sequences.\nThis flexible approach allows for such phenomena as (i) documents looking significantly\ndifferentatthebeginningthanattheend;or(ii)patientstatusevolvingeithertowardsrecov-\neryortowardsdeathoverthecourseofahospitalstay;or(iii)customertasteevolvinginpre-\ndictable ways over the course of continued interaction with a recommender system.\n328 Recurrent Neural Networks\nWesometimeswishtopredictafixedtarget \ud835\udc66givensequentiallystructuredinput(e.g.,sen-\ntimentclassificationbasedonamoviereview). Atothertimes,wewishtopredictasequen-\ntially structured target ( \ud835\udc661,...,\ud835\udc66\ud835\udc47) given a fixed input (e.g., image captioning). Still other\ntimes, our goal is to predict sequentially structured targets based on sequentially structured\ninputs (e.g., machine translation or video captioning). Such sequence-to-sequence tasks\ntake two forms: (i) aligned: where the input at each time step aligns with a correspond-\ning target (e.g., part of speech tagging); (ii) unaligned : where the input and target do not\nnecessarily exhibit a step-for-step correspondence (e.g., machine translation).\nBeforeweworryabouthandlingtargetsofanykind,wecantacklethemoststraightforward\nproblem: unsupervised density modeling (also called sequence modeling ). Here, given a\ncollection of sequences, our goal is to estimate the probability mass function that tells us\nhow likely we are to see any given sequence, i.e., \ud835\udc5d\u00b9x1,...,x\ud835\udc47\u00ba.\n%matplotlib inline\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n9.1.1AutoregressiveModels\nBefore introducing specialized neural networks designed to handle sequentially structured\ndata, let\u2019s take a look at some actual sequence data and build up some basic intuitions\nand statistical tools. In particular, we will focus on stock price data from the FTSE 100\nindex (Fig. 9.1.1 ). At each time step\ud835\udc612Z\u00b8, we observe the price, \ud835\udc65\ud835\udc61, of the index at that\ntime.\ntFig.", "mimetype": "text/plain", "start_char_idx": 785654, "end_char_idx": 789844, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8a1180e1-2815-4bb4-bea9-7ddfe04ca59a": {"__data__": {"id_": "8a1180e1-2815-4bb4-bea9-7ddfe04ca59a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b3c0c935-51bf-46d3-9c70-fae814ab7935", "node_type": "1", "metadata": {}, "hash": "f989df0b83db938208e99972d3be25db8900356bd2fd9412608a3bfbce054a43", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fad39a75-456c-43f7-853f-40c8e02e00e1", "node_type": "1", "metadata": {}, "hash": "aada3dec8b49d8f530bdc6fb4d6a317685dc90e6e56d1aa632bf17be1af008e5", "class_name": "RelatedNodeInfo"}}, "text": "Here, given a\ncollection of sequences, our goal is to estimate the probability mass function that tells us\nhow likely we are to see any given sequence, i.e., \ud835\udc5d\u00b9x1,...,x\ud835\udc47\u00ba.\n%matplotlib inline\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n9.1.1AutoregressiveModels\nBefore introducing specialized neural networks designed to handle sequentially structured\ndata, let\u2019s take a look at some actual sequence data and build up some basic intuitions\nand statistical tools. In particular, we will focus on stock price data from the FTSE 100\nindex (Fig. 9.1.1 ). At each time step\ud835\udc612Z\u00b8, we observe the price, \ud835\udc65\ud835\udc61, of the index at that\ntime.\ntFig. 9.1.1 FTSE 100 index over about 30 years.\nNow suppose that a trader would like to make short-term trades, strategically getting into\nor out of the index, depending on whether they believe that it will rise or decline in the\nsubsequent time step. Absent any other features (news, financial reporting data, etc.), the\n329 Working with Sequences\nonly available signal for predicting the subsequent value is the history of prices to date.\nThe trader is thus interested in knowing the probability distribution\n\ud835\udc43\u00b9\ud835\udc65\ud835\udc61j\ud835\udc65\ud835\udc61\u00001,...,\ud835\udc65 1\u00ba (9.1.1)\noverpricesthattheindexmighttakeinthesubsequenttimestep. Whileestimatingtheentire\ndistribution over a continuously valued random variable can be difficult, the trader would\nbe happy to focus on a few key statistics of the distribution, particularly the expected value\nand the variance. One simple strategy for estimating the conditional expectation\nE\u00bb\u00b9\ud835\udc65\ud835\udc61j\ud835\udc65\ud835\udc61\u00001,...,\ud835\udc65 1\u00ba\u00bc, (9.1.2)\nwould be to apply a linear regression model (recall Section 3.1 ). Such models that regress\nthe value of a signal on the previous values of that same signal are naturally called au-\ntoregressive models . There is just one major problem: the number of inputs, \ud835\udc65\ud835\udc61\u00001,...,\ud835\udc65 1\nvaries, depending on \ud835\udc61. In other words, the number of inputs increases with the amount of\ndata that we encounter. Thus if we want to treat our historical data as a training set, we\nare left with the problem that each example has a different number of features. Much of\nwhatfollowsinthischapterwillrevolvearoundtechniquesforovercomingthesechallenges\nwhen engaging in such autoregressive modeling problems where the object of interest is\n\ud835\udc43\u00b9\ud835\udc65\ud835\udc61j\ud835\udc65\ud835\udc61\u00001,...,\ud835\udc65 1\u00baor some statistic(s) of this distribution.\nAfewstrategiesrecurfrequently. Firstofall,wemightbelievethatalthoughlongsequences\n\ud835\udc65\ud835\udc61\u00001,...,\ud835\udc65 1are available, it may not be necessary to look back so far in the history when\npredicting the near future. In this case we might content ourselves to condition on some\nwindow of length \ud835\udf0fand only use \ud835\udc65\ud835\udc61\u00001,...,\ud835\udc65\ud835\udc61\u0000\ud835\udf0fobservations. The immediate benefit is\nthat now the number of arguments is always the same, at least for \ud835\udc61 > \ud835\udf0f. This allows us to\ntrainanylinearmodelordeepnetworkthatrequiresfixed-lengthvectorsasinputs. Second,\nwe might develop models that maintain some summary \u210e\ud835\udc61of the past observations (see\nFig. 9.1.2 ) and at the same time update \u210e\ud835\udc61in addition to the prediction \u02c6\ud835\udc65\ud835\udc61. This leads to\nmodels that estimate not only \ud835\udc65\ud835\udc61with \u02c6\ud835\udc65\ud835\udc61=\ud835\udc43\u00b9\ud835\udc65\ud835\udc61j\u210e\ud835\udc61\u00babut also updates of the form \u210e\ud835\udc61=\n\ud835\udc54\u00b9\u210e\ud835\udc61\u00001,\ud835\udc65\ud835\udc61\u00001\u00ba. Since\u210e\ud835\udc61isneverobserved,thesemodelsarealsocalled latentautoregressive\nmodels.\ntFig. 9.1.2 A latent autoregressive model.\nTo construct training data from historical data, one typically creates examples by sampling\nwindows randomly. In general, we do not expect time to stand still.", "mimetype": "text/plain", "start_char_idx": 789195, "end_char_idx": 792591, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fad39a75-456c-43f7-853f-40c8e02e00e1": {"__data__": {"id_": "fad39a75-456c-43f7-853f-40c8e02e00e1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8a1180e1-2815-4bb4-bea9-7ddfe04ca59a", "node_type": "1", "metadata": {}, "hash": "c221889823a63384c597bedabe82598a3f3b7e4883e04c05c1a4f5036afcfdef", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "92d388c1-f890-4a92-b556-a1e32286b117", "node_type": "1", "metadata": {}, "hash": "e3a1a65c16a3fe29349867cca7340bf7fade5d080ccd1f147780b3520dffa4b0", "class_name": "RelatedNodeInfo"}}, "text": "9.1.2 ) and at the same time update \u210e\ud835\udc61in addition to the prediction \u02c6\ud835\udc65\ud835\udc61. This leads to\nmodels that estimate not only \ud835\udc65\ud835\udc61with \u02c6\ud835\udc65\ud835\udc61=\ud835\udc43\u00b9\ud835\udc65\ud835\udc61j\u210e\ud835\udc61\u00babut also updates of the form \u210e\ud835\udc61=\n\ud835\udc54\u00b9\u210e\ud835\udc61\u00001,\ud835\udc65\ud835\udc61\u00001\u00ba. Since\u210e\ud835\udc61isneverobserved,thesemodelsarealsocalled latentautoregressive\nmodels.\ntFig. 9.1.2 A latent autoregressive model.\nTo construct training data from historical data, one typically creates examples by sampling\nwindows randomly. In general, we do not expect time to stand still. However, we often\nassume that while the specific values of \ud835\udc65\ud835\udc61might change, the dynamics according to which\neach subsequent observation is generated given the previous observations do not. Statisti-\ncians call dynamics that do not change stationary .\n330 Recurrent Neural Networks\n9.1.2SequenceModels\nSometimes,especiallywhenworkingwithlanguage,wewishtoestimatethejointprobabil-\nity of an entire sequence. This is a common task when working with sequences composed\nof discrete tokens, such as words. Generally, these estimated functions are called sequence\nmodelsand for natural language data, they are called language models . The field of se-\nquence modeling has been driven so much by natural language processing, that we often\ndescribe sequence models as \u201clanguage models\u201d, even when dealing with non-language\ndata. Language models prove useful for all sorts of reasons. Sometimes we want to evalu-\nate the likelihood of sentences. For example, we might wish to compare the naturalness of\ntwocandidateoutputsgeneratedbyamachinetranslationsystemorbyaspeechrecognition\nsystem. But language modeling gives us not only the capacity to evaluate likelihood, but\ntheabilityto samplesequences, andeventooptimizeforthemostlikelysequences.\nWhile language modeling might not, at first glance, look like an autoregressive problem,\nwe can reduce language modeling to autoregressive prediction by decomposing the joint\ndensity of a sequence \ud835\udc5d\u00b9\ud835\udc651,...,\ud835\udc65\ud835\udc47\u00bainto the product of conditional densities in a left-to-\nright fashion by applying the chain rule of probability:\n\ud835\udc43\u00b9\ud835\udc651,...,\ud835\udc65\ud835\udc47\u00ba=\ud835\udc43\u00b9\ud835\udc651\u00ba\ud835\udc47\u00d6\n\ud835\udc61=2\ud835\udc43\u00b9\ud835\udc65\ud835\udc61j\ud835\udc65\ud835\udc61\u00001,...,\ud835\udc65 1\u00ba. (9.1.3)\nNote that if we are working with discrete signals such as words, then the autoregressive\nmodel must be a probabilistic classifier, outputting a full probability distribution over the\nvocabulary for whatever word will come next, given the leftwards context.\nMarkovModels\nNow suppose that we wish to employ the strategy mentioned above, where we condition\nonlyonthe\ud835\udf0fprevioustimesteps,i.e., \ud835\udc65\ud835\udc61\u00001,...,\ud835\udc65\ud835\udc61\u0000\ud835\udf0f,ratherthantheentiresequencehistory\n\ud835\udc65\ud835\udc61\u00001,...,\ud835\udc65 1. Wheneverwecanthrowawaythehistorybeyondtheprevious \ud835\udf0fstepswithout\nanylossinpredictivepower,wesaythatthesequencesatisfiesa Markovcondition ,i.e.,that\nthe future is conditionally independent of the past, given the recent history . When\ud835\udf0f=1,\nwe say that the data is characterized by a first-order Markov model , and when\ud835\udf0f=\ud835\udc58, we\nsay that the data is characterized by a \ud835\udc58th-order Markov model. For when the first-order\nMarkovconditionholds( \ud835\udf0f=1)thefactorizationofourjointprobabilitybecomesaproduct\nof probabilities of each word given the previous word:\n\ud835\udc43\u00b9\ud835\udc651,...,\ud835\udc65\ud835\udc47\u00ba=\ud835\udc43\u00b9\ud835\udc651\u00ba\ud835\udc47\u00d6\n\ud835\udc61=2\ud835\udc43\u00b9\ud835\udc65\ud835\udc61j\ud835\udc65\ud835\udc61\u00001\u00ba. (9.1.4)\nWeoftenfinditusefultoworkwithmodelsthatproceedasthoughaMarkovconditionwere\nsatisfied,evenwhenweknowthatthisisonly approximately true. Withrealtextdocuments\nwe continue to gain information as we include more and more leftwards context. But these\ngains diminish rapidly.", "mimetype": "text/plain", "start_char_idx": 792129, "end_char_idx": 795507, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "92d388c1-f890-4a92-b556-a1e32286b117": {"__data__": {"id_": "92d388c1-f890-4a92-b556-a1e32286b117", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fad39a75-456c-43f7-853f-40c8e02e00e1", "node_type": "1", "metadata": {}, "hash": "aada3dec8b49d8f530bdc6fb4d6a317685dc90e6e56d1aa632bf17be1af008e5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ce4398f7-c886-4b34-8e57-5905f99a7ea7", "node_type": "1", "metadata": {}, "hash": "a744e2f87fc501122dc0f8c21f6a947c799a567fc4ca2d93566c99984b0143a3", "class_name": "RelatedNodeInfo"}}, "text": "For when the first-order\nMarkovconditionholds( \ud835\udf0f=1)thefactorizationofourjointprobabilitybecomesaproduct\nof probabilities of each word given the previous word:\n\ud835\udc43\u00b9\ud835\udc651,...,\ud835\udc65\ud835\udc47\u00ba=\ud835\udc43\u00b9\ud835\udc651\u00ba\ud835\udc47\u00d6\n\ud835\udc61=2\ud835\udc43\u00b9\ud835\udc65\ud835\udc61j\ud835\udc65\ud835\udc61\u00001\u00ba. (9.1.4)\nWeoftenfinditusefultoworkwithmodelsthatproceedasthoughaMarkovconditionwere\nsatisfied,evenwhenweknowthatthisisonly approximately true. Withrealtextdocuments\nwe continue to gain information as we include more and more leftwards context. But these\ngains diminish rapidly. Thus, sometimes we compromise, obviating computational and\nstatistical difficulties by training models whose validity depends on a \ud835\udc58th-order Markov\ncondition. Even today\u2019s massive RNN- and Transformer-based language models seldom\nincorporate more than thousands of words of context.\n331 Working with Sequences\nWith discrete data, a true Markov model simplycounts the number of times that each word\nhas occurred in each context, producing the relative frequency estimate of \ud835\udc43\u00b9\ud835\udc65\ud835\udc61j\ud835\udc65\ud835\udc61\u00001\u00ba.\nWhenever the data assumes only discrete values (as in language), the most likely sequence\nof words can be computed efficiently using dynamic programming.\nThe Orderof Decoding\nYoumaybewonderingwhywerepresentedthefactorizationofatextsequence \ud835\udc43\u00b9\ud835\udc651,...,\ud835\udc65\ud835\udc47\u00ba\nas a left-to-right chain of conditional probabilities. Why not right-to-left or some other,\nseeminglyrandomorder? Inprinciple,thereisnothingwrongwithunfolding \ud835\udc43\u00b9\ud835\udc651,...,\ud835\udc65\ud835\udc47\u00ba\nin reverse order. The result is a valid factorization:\n\ud835\udc43\u00b9\ud835\udc651,...,\ud835\udc65\ud835\udc47\u00ba=\ud835\udc43\u00b9\ud835\udc65\ud835\udc47\u00ba1\u00d6\n\ud835\udc61=\ud835\udc47\u00001\ud835\udc43\u00b9\ud835\udc65\ud835\udc61j\ud835\udc65\ud835\udc61\u00b81,...,\ud835\udc65\ud835\udc47\u00ba. (9.1.5)\nHowever, there are many reasons why factorizing text in the same direction in which we\nreadit(left-to-rightformostlanguages,butright-to-leftforArabicandHebrew)ispreferred\nfor the task of language modeling. First, this is just a more natural direction for us to think\nabout. After all we all read text every day, and this process is guided by our ability to\nanticipate which words and phrases are likely to come next. Just think of how many times\nyouhavecompletedsomeoneelse\u2019ssentence. Thus,evenifwehadnootherreasontoprefer\nsuch in-order decodings, they would be useful if only because we have better intuitions for\nwhat should be likely when predicting in this order.\nSecond, by factorizing in order, we can assign probabilities to arbitrarily long sequences\nusingthesamelanguagemodel. Toconvertaprobabilityoversteps 1through\ud835\udc61intoonethat\nextendstoword \ud835\udc61\u00b81wesimplymultiplybytheconditionalprobabilityoftheadditionalto-\nkengiventhepreviousones: \ud835\udc43\u00b9\ud835\udc65\ud835\udc61\u00b81,...,\ud835\udc65 1\u00ba=\ud835\udc43\u00b9\ud835\udc65\ud835\udc61,...,\ud835\udc65 1\u00ba\u0001\ud835\udc43\u00b9\ud835\udc65\ud835\udc61\u00b81j\ud835\udc65\ud835\udc61,...,\ud835\udc65 1\u00ba.\nThird, we have stronger predictive models for predicting adjacent words than words at ar-\nbitrary other locations. While all orders of factorization are valid, they do not necessarily\nallrepresentequallyeasypredictivemodelingproblems. Thisistruenotonlyforlanguage,\nbut for other kinds of data as well, e.g., when the data is causally structured. For example,\nwe believe that future events cannot influence the past. Hence, if we change \ud835\udc65\ud835\udc61, we may be\nable to influence what happens for \ud835\udc65\ud835\udc61\u00b81going forward but not the converse. That is, if we\nchange\ud835\udc65\ud835\udc61, the distribution over past events will not change.", "mimetype": "text/plain", "start_char_idx": 795036, "end_char_idx": 798118, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ce4398f7-c886-4b34-8e57-5905f99a7ea7": {"__data__": {"id_": "ce4398f7-c886-4b34-8e57-5905f99a7ea7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "92d388c1-f890-4a92-b556-a1e32286b117", "node_type": "1", "metadata": {}, "hash": "e3a1a65c16a3fe29349867cca7340bf7fade5d080ccd1f147780b3520dffa4b0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cf754a1e-5838-470a-a19c-2c106150bb63", "node_type": "1", "metadata": {}, "hash": "b86d0237dfd758eeae76a7a671c67cd263b67db3ffb17c50812d402bfcb192a7", "class_name": "RelatedNodeInfo"}}, "text": "Third, we have stronger predictive models for predicting adjacent words than words at ar-\nbitrary other locations. While all orders of factorization are valid, they do not necessarily\nallrepresentequallyeasypredictivemodelingproblems. Thisistruenotonlyforlanguage,\nbut for other kinds of data as well, e.g., when the data is causally structured. For example,\nwe believe that future events cannot influence the past. Hence, if we change \ud835\udc65\ud835\udc61, we may be\nable to influence what happens for \ud835\udc65\ud835\udc61\u00b81going forward but not the converse. That is, if we\nchange\ud835\udc65\ud835\udc61, the distribution over past events will not change. In some contexts, this makes\nit easier to predict \ud835\udc43\u00b9\ud835\udc65\ud835\udc61\u00b81j\ud835\udc65\ud835\udc61\u00bathan to predict \ud835\udc43\u00b9\ud835\udc65\ud835\udc61j\ud835\udc65\ud835\udc61\u00b81\u00ba. For instance, in some cases,\nwe can find\ud835\udc65\ud835\udc61\u00b81=\ud835\udc53\u00b9\ud835\udc65\ud835\udc61\u00ba\u00b8\ud835\udf16for some additive noise \ud835\udf16, whereas the converse is not true\n(Hoyeret al., 2009). This is great news, since it is typically the forward direction that we\nare interested in estimating. The book by Peters et al.(2017) contains more on this topic.\nWe barely scratch the surface of it.\n9.1.3Training\nBefore we focus our attention on text data, let\u2019s first try this out with some continuous-\nvalued synthetic data.\nHere, our 1000 synthetic data will follow the trigonometric sinfunction, applied to 0.01\n332 Recurrent Neural Networks\ntimes the time step. To make the problem a little more interesting, we corrupt each sample\nwith additive noise. From this sequence we extract training examples, each consisting of\nfeatures and a label.\nclass Data (d2l .DataModule):\ndef __init__ (self , batch_size =16, T=1000 , num_train =600, tau =4):\nself .save_hyperparameters()\nself .time =torch .arange( 1, T +1, dtype =torch .float32)\nself .x=torch .sin( 0.01 *self .time) +torch .randn(T) *0.2\ndata =Data()\nd2l.plot(data .time, data .x,'time ','x', xlim =[1,1000 ], figsize =(6,3))\nTo begin, we try a model that acts as if the data satisfied a \ud835\udf0fth-order Markov condition,\nand thus predicts \ud835\udc65\ud835\udc61using only the past \ud835\udf0fobservations. Thus for each time step we have an\nexamplewithlabel \ud835\udc66=\ud835\udc65\ud835\udc61andfeatures x\ud835\udc61=\u00bb\ud835\udc65\ud835\udc61\u0000\ud835\udf0f,...,\ud835\udc65\ud835\udc61\u00001\u00bc. Theastutereadermighthave\nnoticedthatthisresultsin 1000\u0000\ud835\udf0fexamples,sincewelacksufficienthistoryfor \ud835\udc661,...,\ud835\udc66\ud835\udf0f.\nWhile we could pad the first \ud835\udf0fsequences with zeros, to keep things simple, we drop them\nfor now. The resulting dataset contains \ud835\udc47\u0000\ud835\udf0fexamples, where each input to the model has\nsequence length \ud835\udf0f. We create a data iterator on the first 600 examples, covering a period of\nthe sin function.\n@d2l .add_to_class(Data)\ndef get_dataloader (self , train):\nfeatures =[self .x[i : self .T-self .tau+i]for iinrange (self .tau)]\nself .features =torch .stack(features, 1)\nself .labels =self .x[self .tau:] .reshape(( -1,1))\ni=slice (0,self .num_train) iftrain else slice (self .num_train, None )\nreturn self .get_tensorloader([ self .features, self .labels], train, i)\nIn this example our model will be a standard linear regression.\nmodel =d2l.LinearRegression(lr =0.01 )\ntrainer =d2l.Trainer(max_epochs =5)\ntrainer .fit(model, data)\n333 Working with Sequences\n9.1.4Prediction\nToevaluateourmodel,wefirstcheckhowwellitperformsatone-step-aheadprediction.", "mimetype": "text/plain", "start_char_idx": 797518, "end_char_idx": 800604, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cf754a1e-5838-470a-a19c-2c106150bb63": {"__data__": {"id_": "cf754a1e-5838-470a-a19c-2c106150bb63", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ce4398f7-c886-4b34-8e57-5905f99a7ea7", "node_type": "1", "metadata": {}, "hash": "a744e2f87fc501122dc0f8c21f6a947c799a567fc4ca2d93566c99984b0143a3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0cb2f343-92c1-47c4-89ce-c3fc954a3d28", "node_type": "1", "metadata": {}, "hash": "50288321eb03d865c2ebbb822a4b7db1ce934b9bf14ab821874e34ea8cd7155d", "class_name": "RelatedNodeInfo"}}, "text": "@d2l .add_to_class(Data)\ndef get_dataloader (self , train):\nfeatures =[self .x[i : self .T-self .tau+i]for iinrange (self .tau)]\nself .features =torch .stack(features, 1)\nself .labels =self .x[self .tau:] .reshape(( -1,1))\ni=slice (0,self .num_train) iftrain else slice (self .num_train, None )\nreturn self .get_tensorloader([ self .features, self .labels], train, i)\nIn this example our model will be a standard linear regression.\nmodel =d2l.LinearRegression(lr =0.01 )\ntrainer =d2l.Trainer(max_epochs =5)\ntrainer .fit(model, data)\n333 Working with Sequences\n9.1.4Prediction\nToevaluateourmodel,wefirstcheckhowwellitperformsatone-step-aheadprediction.\nonestep_preds =model(data .features) .detach() .numpy()\nd2l.plot(data .time[data .tau:], [data .labels, onestep_preds], 'time ','x',\nlegend =['labels ','1-step preds '], figsize =(6,3))\nThese predictions look good, even near the end at \ud835\udc61=1000.\nBut what if we only observed sequence data up until time step 604 ( n_train + tau ) and\nwished to make predictions several stepsinto the future? Unfortunately, we cannot directly\ncompute the one-step-ahead prediction for time step 609, because we do not know the cor-\nrespondinginputs,havingseenonlyupto \ud835\udc65604. Wecanaddressthisproblembypluggingin\nourearlierpredictionsasinputstoourmodelformakingsubsequentpredictions,projecting\nforward, one step at a time, until reaching the desired time step:\n\u02c6\ud835\udc65605=\ud835\udc53\u00b9\ud835\udc65601,\ud835\udc65602,\ud835\udc65603,\ud835\udc65604\u00ba,\n\u02c6\ud835\udc65606=\ud835\udc53\u00b9\ud835\udc65602,\ud835\udc65603,\ud835\udc65604,\u02c6\ud835\udc65605\u00ba,\n\u02c6\ud835\udc65607=\ud835\udc53\u00b9\ud835\udc65603,\ud835\udc65604,\u02c6\ud835\udc65605,\u02c6\ud835\udc65606\u00ba,\n\u02c6\ud835\udc65608=\ud835\udc53\u00b9\ud835\udc65604,\u02c6\ud835\udc65605,\u02c6\ud835\udc65606,\u02c6\ud835\udc65607\u00ba,\n\u02c6\ud835\udc65609=\ud835\udc53\u00b9\u02c6\ud835\udc65605,\u02c6\ud835\udc65606,\u02c6\ud835\udc65607,\u02c6\ud835\udc65608\u00ba,\n...(9.1.6)\nGenerally, for an observed sequence \ud835\udc651,...,\ud835\udc65\ud835\udc61, its predicted output \u02c6\ud835\udc65\ud835\udc61\u00b8\ud835\udc58at time step\ud835\udc61\u00b8\ud835\udc58\n334 Recurrent Neural Networks\nis called the \ud835\udc58-step-ahead prediction . Since we have observed up to \ud835\udc65604, its\ud835\udc58-step-ahead\nprediction is \u02c6\ud835\udc65604\u00b8\ud835\udc58. In other words, we will have to keep on using our own predictions to\nmake multistep-ahead predictions. Let\u2019s see how well this goes.\nmultistep_preds =torch .zeros(data .T)\nmultistep_preds[:] =data .x\nfor iinrange (data .num_train +data .tau, data .T):\nmultistep_preds[i] =model(\nmultistep_preds[i -data .tau:i] .reshape(( 1,-1)))\nmultistep_preds =multistep_preds .detach() .numpy()\nd2l.plot([data .time[data .tau:], data .time[data .num_train +data .tau:]],\n[onestep_preds, multistep_preds[data .num_train +data .tau:]], 'time ',\n'x', legend =['1-step preds ','multistep preds '], figsize =(6,3))\nUnfortunately, in this case we fail spectacularly. The predictions decay to a constant pretty\nquickly after a few steps. Why did the algorithm perform so much worse when predicting\nfurther into the future? Ultimately, this is down to the fact that errors build up. Let\u2019s say\nthat after step 1 we have some error \ud835\udf161=\u00af\ud835\udf16. Now the inputfor step 2 is perturbed by \ud835\udf161,\nhence we suffer some error in the order of \ud835\udf162=\u00af\ud835\udf16\u00b8\ud835\udc50\ud835\udf161for some constant \ud835\udc50, and so on. The\npredictions can diverge rapidly from the true observations. You may already be familiar\nwith this common phenomenon.", "mimetype": "text/plain", "start_char_idx": 799953, "end_char_idx": 802911, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0cb2f343-92c1-47c4-89ce-c3fc954a3d28": {"__data__": {"id_": "0cb2f343-92c1-47c4-89ce-c3fc954a3d28", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cf754a1e-5838-470a-a19c-2c106150bb63", "node_type": "1", "metadata": {}, "hash": "b86d0237dfd758eeae76a7a671c67cd263b67db3ffb17c50812d402bfcb192a7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fe4d0878-a2b9-4704-9fcb-ac7c0be822f3", "node_type": "1", "metadata": {}, "hash": "b261333985c04bc4d8a49433986d1be225cf6783b066bb0f7579194efa635b54", "class_name": "RelatedNodeInfo"}}, "text": "The predictions decay to a constant pretty\nquickly after a few steps. Why did the algorithm perform so much worse when predicting\nfurther into the future? Ultimately, this is down to the fact that errors build up. Let\u2019s say\nthat after step 1 we have some error \ud835\udf161=\u00af\ud835\udf16. Now the inputfor step 2 is perturbed by \ud835\udf161,\nhence we suffer some error in the order of \ud835\udf162=\u00af\ud835\udf16\u00b8\ud835\udc50\ud835\udf161for some constant \ud835\udc50, and so on. The\npredictions can diverge rapidly from the true observations. You may already be familiar\nwith this common phenomenon. For instance, weather forecasts for the next 24 hours tend\nto be pretty accurate but beyond that, accuracy declines rapidly. We will discuss methods\nfor improving this throughout this chapter and beyond.\nLet\u2019s take a closer look at the difficulties in \ud835\udc58-step-ahead predictions by computing predic-\ntions on the entire sequence for \ud835\udc58=1,4,16,64.\ndef k_step_pred (k):\nfeatures =[]\nfor iinrange (data .tau):\nfeatures .append(data .x[i : i +data .T-data .tau-k+1])\n# The (i+tau)-th element stores the (i+1)-step-ahead predictions\nfor iinrange (k):\npreds =model(torch .stack(features[i : i +data .tau], 1))\nfeatures .append(preds .reshape( -1))\nreturn features[data .tau:]\n335 Working with Sequences\nsteps =(1,4,16,64)\npreds =k_step_pred(steps[ -1])\nd2l.plot(data .time[data .tau+steps[ -1]-1:],\n[preds[k -1].detach() .numpy() for kinsteps], 'time ','x',\nlegend =[f'{k}-step preds 'for kinsteps], figsize =(6,3))\nThisclearlyillustrateshowthequalityofthepredictionchangesaswetrytopredictfurther\ninto the future. While the 4-step-ahead predictions still look good, anything beyond that is\nalmost useless.\n9.1.5Summary\nThere is quite a difference in difficulty between interpolation and extrapolation. Conse-\nquently,ifyouhaveasequence,alwaysrespectthetemporalorderofthedatawhentraining,\ni.e.,nevertrainonfuturedata. Giventhiskindofdata,sequencemodelsrequirespecialized\nstatistical tools for estimation. Two popular choices are autoregressive models and latent-\nvariable autoregressive models. For causal models (e.g., time going forward), estimating\nthe forward direction is typically a lot easier than the reverse direction. For an observed\nsequenceuptotimestep \ud835\udc61, itspredictedoutputattimestep \ud835\udc61\u00b8\ud835\udc58isthe\ud835\udc58-step-aheadpredic-\ntion. As we predict further in time by increasing \ud835\udc58, the errors accumulate and the quality\nof the prediction degrades, often dramatically.\n9.1.6Exercises\n1.Improve the model in the experiment of this section.\n1.Incorporate more than the past four observations? How many do you really need?\n2.How many past observations would you need if there was no noise? Hint: you can\nwrite sinandcosas a differential equation.\n3.Can you incorporate older observations while keeping the total number of features\nconstant? Does this improve accuracy? Why?\n4.Changetheneuralnetworkarchitectureandevaluatetheperformance. Youmaytrain\nthe new model with more epochs. What do you observe?\n336 Recurrent Neural Networks\n136\n1372.An investor wants to find a good security to buy. They look at past returns to decide\nwhich one is likely to do well. What could possibly go wrong with this strategy?\n3.Does causality also apply to text? To which extent?\n4.Give an example for when a latent autoregressive model might be needed to capture the\ndynamic of the data.\nDiscussions136.\n9.2ConvertingRawTextinto SequenceData\nThroughoutthisbook,wewilloftenworkwithtextdatarepresentedassequencesofwords,\ncharacters, or word pieces. To get going, we will need some basic tools for converting raw\ntext into sequences of the appropriate form. Typical preprocessing pipelines execute the\nfollowing steps:\n1.Load text as strings into memory.\n2.Split the strings into tokens (e.g., words or characters).\n3.Build a vocabulary dictionary to associate each vocabulary element with a numerical\nindex.\n4.Convert the text into sequences of numerical indices.", "mimetype": "text/plain", "start_char_idx": 802395, "end_char_idx": 806238, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fe4d0878-a2b9-4704-9fcb-ac7c0be822f3": {"__data__": {"id_": "fe4d0878-a2b9-4704-9fcb-ac7c0be822f3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0cb2f343-92c1-47c4-89ce-c3fc954a3d28", "node_type": "1", "metadata": {}, "hash": "50288321eb03d865c2ebbb822a4b7db1ce934b9bf14ab821874e34ea8cd7155d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f1bf788f-6dd6-4694-b0bb-76bd0e083baa", "node_type": "1", "metadata": {}, "hash": "56ba094ae5a8056f99a42ca5229d849612656546ac386a05ec12f681fa1cca1e", "class_name": "RelatedNodeInfo"}}, "text": "They look at past returns to decide\nwhich one is likely to do well. What could possibly go wrong with this strategy?\n3.Does causality also apply to text? To which extent?\n4.Give an example for when a latent autoregressive model might be needed to capture the\ndynamic of the data.\nDiscussions136.\n9.2ConvertingRawTextinto SequenceData\nThroughoutthisbook,wewilloftenworkwithtextdatarepresentedassequencesofwords,\ncharacters, or word pieces. To get going, we will need some basic tools for converting raw\ntext into sequences of the appropriate form. Typical preprocessing pipelines execute the\nfollowing steps:\n1.Load text as strings into memory.\n2.Split the strings into tokens (e.g., words or characters).\n3.Build a vocabulary dictionary to associate each vocabulary element with a numerical\nindex.\n4.Convert the text into sequences of numerical indices.\nimport collections\nimport random\nimport re\nimport torch\nfrom d2l import torch asd2l\n9.2.1Readingthe Dataset\nHere, we will work with H. G. Wells\u2019 The Time Machine137, a book containing just over\n30,000 words. While real applications will typically involve significantly larger datasets,\nthis is sufficient to demonstrate the preprocessing pipeline. The following _download\nmethod reads the raw text into a string.\nclass TimeMachine (d2l .DataModule): #@save\n\"\"\"The Time Machine dataset.\"\"\"\ndef _download (self ):\nfname =d2l.download(d2l .DATA_URL +'timemachine.txt ',self .root,\n'090b5e7e70c295757f55df93cb0a180b9691891a ')\nwith open (fname) asf:\nreturn f.read()\n(continues on next page)\n337 Converting Raw Text into Sequence Data\n(continued from previous page)\ndata =TimeMachine()\nraw_text =data ._download()\nraw_text[: 60]\n'The Time Machine, by H. G. Wells [1898]nnnnnInnnThe Time Tra'\nForsimplicity,weignorepunctuationandcapitalizationwhenpreprocessingtherawtext.\n@d2l .add_to_class(TimeMachine) #@save\ndef _preprocess (self , text):\nreturn re.sub( '[^A-Za-z]+ ','', text) .lower()\ntext =data ._preprocess(raw_text)\ntext[: 60]\n'the time machine by h g wells i the time traveller for so it '\n9.2.2Tokenization\nTokensare the atomic (indivisible) units of text. Each time step corresponds to 1 token,\nbut what precisely constitutes a token is a design choice. For example, we could represent\nthe sentence \u201cBaby needs a new pair of shoes\u201d as a sequence of 7 words, where the set of\nall words comprise a large vocabulary (typically tens or hundreds of thousands of words).\nOr we would represent the same sentence as a much longer sequence of 30 characters,\nusingamuchsmallervocabulary(thereareonly256distinctASCIIcharacters). Below,we\ntokenize our preprocessed text into a sequence of characters.\n@d2l .add_to_class(TimeMachine) #@save\ndef _tokenize (self , text):\nreturn list (text)\ntokens =data ._tokenize(text)\n','.join(tokens[: 30])\n't,h,e, ,t,i,m,e, ,m,a,c,h,i,n,e, ,b,y, ,h, ,g, ,w,e,l,l,s, '\n9.2.3Vocabulary\nThese tokens are still strings. However, the inputs to our models must ultimately consist of\nnumericalinputs. Next,weintroduceaclassforconstructing vocabularies ,i.e.,objectsthat\nassociateeachdistincttokenvaluewithauniqueindex. First,wedeterminethesetofunique\ntokensinourtraining corpus. Wethenassignanumericalindextoeachuniquetoken. Rare\nvocabularyelementsareoftendroppedforconvenience. Wheneverweencounteratokenat\ntrainingor testtime that had notbeen previouslyseen or wasdropped fromthe vocabulary,\nwerepresentitbyaspecial\u201c<unk>\u201dtoken,signifyingthatthisisan unknown value.\n338 Recurrent Neural Networks\nclass Vocab :#@save\n\"\"\"Vocabulary for text.\"\"\"", "mimetype": "text/plain", "start_char_idx": 805385, "end_char_idx": 808903, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f1bf788f-6dd6-4694-b0bb-76bd0e083baa": {"__data__": {"id_": "f1bf788f-6dd6-4694-b0bb-76bd0e083baa", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fe4d0878-a2b9-4704-9fcb-ac7c0be822f3", "node_type": "1", "metadata": {}, "hash": "b261333985c04bc4d8a49433986d1be225cf6783b066bb0f7579194efa635b54", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d4dd3629-17d8-4979-b27a-2b785e9d9e00", "node_type": "1", "metadata": {}, "hash": "958f7b558fe7a0807f28125d80dcbf6c6e1c14c9a49d880416724136c6b46bf7", "class_name": "RelatedNodeInfo"}}, "text": "However, the inputs to our models must ultimately consist of\nnumericalinputs. Next,weintroduceaclassforconstructing vocabularies ,i.e.,objectsthat\nassociateeachdistincttokenvaluewithauniqueindex. First,wedeterminethesetofunique\ntokensinourtraining corpus. Wethenassignanumericalindextoeachuniquetoken. Rare\nvocabularyelementsareoftendroppedforconvenience. Wheneverweencounteratokenat\ntrainingor testtime that had notbeen previouslyseen or wasdropped fromthe vocabulary,\nwerepresentitbyaspecial\u201c<unk>\u201dtoken,signifyingthatthisisan unknown value.\n338 Recurrent Neural Networks\nclass Vocab :#@save\n\"\"\"Vocabulary for text.\"\"\"\ndef __init__ (self , tokens =[], min_freq =0, reserved_tokens =[]):\n# Flatten a 2D list if needed\niftokens and isinstance (tokens[ 0],list ):\ntokens =[token for line intokens for token inline]\n# Count token frequencies\ncounter =collections .Counter(tokens)\nself .token_freqs =sorted (counter .items(), key =lambda x: x[ 1],\nreverse =True )\n# The list of unique tokens\nself .idx_to_token =list (sorted (set(['<unk> ']+reserved_tokens +[\ntoken for token, freq inself .token_freqs iffreq >=min_freq])))\nself .token_to_idx ={token: idx\nfor idx, token inenumerate (self .idx_to_token)}\ndef __len__ (self ):\nreturn len(self .idx_to_token)\ndef __getitem__ (self , tokens):\nifnot isinstance (tokens, ( list ,tuple )):\nreturn self .token_to_idx .get(tokens, self .unk)\nreturn [self .__getitem__ (token) for token intokens]\ndef to_tokens (self , indices):\nifhasattr (indices, '__len__ ')and len(indices) >1:\nreturn [self .idx_to_token[ int(index)] for index inindices]\nreturn self .idx_to_token[indices]\n@property\ndef unk(self ): # Index for the unknown token\nreturn self .token_to_idx[ '<unk> ']\nWe now construct a vocabulary for our dataset, converting the sequence of strings into a\nlist of numerical indices. Note that we have not lost any information and can easily convert\nour dataset back to its original (string) representation.\nvocab =Vocab(tokens)\nindices =vocab[tokens[: 10]]\nprint ('indices: ', indices)\nprint ('words: ', vocab .to_tokens(indices))\nindices: [ 21,9,6,0,21,10,14,6,0,14]\nwords: [ 't','h','e','','t','i','m','e','','m']\n9.2.4PuttingIt All Together\nUsing the above classes and methods, we package everything into the following build\nmethodofthe TimeMachine class,whichreturns corpus,alistoftokenindices,and vocab,\nthe vocabulary of The Time Machine corpus. The modifications we did here are: (i) we\ntokenizetextintocharacters,notwords,tosimplifythetraininginlatersections;(ii) corpus\n339 Converting Raw Text into Sequence Data\nis a single list, not a list of token lists, since each text line in The Time Machine dataset is\nnot necessarily a sentence or paragraph.\n@d2l .add_to_class(TimeMachine) #@save\ndef build (self , raw_text, vocab =None ):\ntokens =self ._tokenize( self ._preprocess(raw_text))\nifvocab isNone : vocab =Vocab(tokens)\ncorpus =[vocab[token] for token intokens]\nreturn corpus, vocab\ncorpus, vocab =data .build(raw_text)\nlen(corpus), len(vocab)\n(173428 ,28)\n9.2.5Exploratory LanguageStatistics\nUsingtherealcorpusandthe Vocabclassdefinedoverwords,wecaninspectbasicstatistics\nconcerning word use in our corpus. Below, we construct a vocabulary from words used in\nTheTimeMachine and print the ten most frequently occurring of them.\nwords =text .split()\nvocab =Vocab(words)\nvocab .token_freqs[: 10]\n[('the',2261 ),\n('i',1267 ),\n('and',1245 ),\n('of',1155 ),\n('a',816),\n('to',695),\n('was',552),\n('in',541),\n('that ',443),\n('my',440)]\nNote that the ten most frequent words are not all that descriptive. You might even imagine\nthat we might see a very similar list if we had chosen any book at random.", "mimetype": "text/plain", "start_char_idx": 808283, "end_char_idx": 811930, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d4dd3629-17d8-4979-b27a-2b785e9d9e00": {"__data__": {"id_": "d4dd3629-17d8-4979-b27a-2b785e9d9e00", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f1bf788f-6dd6-4694-b0bb-76bd0e083baa", "node_type": "1", "metadata": {}, "hash": "56ba094ae5a8056f99a42ca5229d849612656546ac386a05ec12f681fa1cca1e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0306ffb8-89c6-4daf-b391-ef44c918266a", "node_type": "1", "metadata": {}, "hash": "792554ea1b825854772f89653ea24bfed19c2e3303c827656f10b12ddea610eb", "class_name": "RelatedNodeInfo"}}, "text": "Below, we construct a vocabulary from words used in\nTheTimeMachine and print the ten most frequently occurring of them.\nwords =text .split()\nvocab =Vocab(words)\nvocab .token_freqs[: 10]\n[('the',2261 ),\n('i',1267 ),\n('and',1245 ),\n('of',1155 ),\n('a',816),\n('to',695),\n('was',552),\n('in',541),\n('that ',443),\n('my',440)]\nNote that the ten most frequent words are not all that descriptive. You might even imagine\nthat we might see a very similar list if we had chosen any book at random. Articles like\n\u201cthe\u201d and \u201ca\u201d, pronouns like \u201ci\u201d and \u201cmy\u201d, and prepositions like \u201cof\u201d, \u201cto\u201d, and \u201cin\u201d occur\noften because they serve common syntactic roles. Such words that are common but not\nparticularly descriptive are often called stop words and, in previous generations of text\nclassifiers based on so-called bag-of-words representations, they were most often filtered\nout. However, they carry meaning and it is not necessary to filter them out when working\nwith modern RNN- and Transformer-based neural models. If you look further down the\nlist, you will notice that word frequency decays quickly. The 10thmost frequent word is\nless than 1\u009d5as common as the most popular. Word frequency tends to follow a power law\ndistribution(specificallytheZipfian)aswegodowntheranks. Togetabetteridea, weplot\nthe figure of the word frequency.\n340 Recurrent Neural Networks\nfreqs =[freq for token, freq invocab .token_freqs]\nd2l.plot(freqs, xlabel ='token: x ', ylabel ='frequency: n(x) ',\nxscale ='log', yscale ='log')\nAfterdealingwiththefirstfewwordsasexceptions,alltheremainingwordsroughlyfollow\na straight line on a log\u2013log plot. This phenomenon is captured by Zipf\u2019s law , which states\nthat the frequency \ud835\udc5b\ud835\udc56of the\ud835\udc56thmost frequent word is:\n\ud835\udc5b\ud835\udc56/1\n\ud835\udc56\ud835\udefc, (9.2.1)\nwhich is equivalent to\nlog\ud835\udc5b\ud835\udc56=\u0000\ud835\udefclog\ud835\udc56\u00b8\ud835\udc50, (9.2.2)\nwhere\ud835\udefcis the exponent that characterizes the distribution and \ud835\udc50is a constant. This should\nalready give us pause for thought if we want to model words by counting statistics. After\nall, we will significantly overestimate the frequency of the tail, also known as the infre-\nquent words. But what about the other word combinations, such as two consecutive words\n(bigrams), three consecutive words (trigrams), and beyond? Let\u2019s see whether the bigram\nfrequency behaves in the same manner as the single word (unigram) frequency.\nbigram_tokens =['--'.join(pair) for pair inzip(words[: -1], words[ 1:])]\nbigram_vocab =Vocab(bigram_tokens)\nbigram_vocab .token_freqs[: 10]\n[('of--the ',309),\n('in--the ',169),\n('i--had ',130),\n('i--was ',112),\n('and--the ',109),\n('the--time ',102),\n('it--was ',99),\n('to--the ',85),\n('as--i ',78),\n('of--a ',73)]\nOne thing is notable here. Out of the ten most frequent word pairs, nine are composed of\nbothstopwordsandonlyoneisrelevanttotheactualbook\u2014\u201cthetime\u201d. Furthermore, let\u2019s\nsee whether the trigram frequency behaves in the same manner.\n341 Converting Raw Text into Sequence Data\ntrigram_tokens =['--'.join(triple) for triple inzip(\nwords[: -2], words[ 1:-1], words[ 2:])]\ntrigram_vocab =Vocab(trigram_tokens)\ntrigram_vocab .token_freqs[: 10]\n[('the--time--traveller ',59),\n('the--time--machine ',30),\n('the--medical--man ',24),\n('it--seemed--to ',16),\n('it--was--a ',15),\n('here--and--there ',15),\n('seemed--to--me ',14),\n('i--did--not ',14),\n('i--saw--the ',13),\n('i--began--to ',13)]\nNow, let\u2019s visualize the token frequency among these three models: unigrams, bigrams,\nand trigrams.", "mimetype": "text/plain", "start_char_idx": 811446, "end_char_idx": 814845, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0306ffb8-89c6-4daf-b391-ef44c918266a": {"__data__": {"id_": "0306ffb8-89c6-4daf-b391-ef44c918266a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d4dd3629-17d8-4979-b27a-2b785e9d9e00", "node_type": "1", "metadata": {}, "hash": "958f7b558fe7a0807f28125d80dcbf6c6e1c14c9a49d880416724136c6b46bf7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "60dd11e1-4437-485a-a5f2-edce7893ad77", "node_type": "1", "metadata": {}, "hash": "1a0e701d0f5358effb9c113c95fb8ca117e13b4bc00bc80127eda640a0aa3483", "class_name": "RelatedNodeInfo"}}, "text": "341 Converting Raw Text into Sequence Data\ntrigram_tokens =['--'.join(triple) for triple inzip(\nwords[: -2], words[ 1:-1], words[ 2:])]\ntrigram_vocab =Vocab(trigram_tokens)\ntrigram_vocab .token_freqs[: 10]\n[('the--time--traveller ',59),\n('the--time--machine ',30),\n('the--medical--man ',24),\n('it--seemed--to ',16),\n('it--was--a ',15),\n('here--and--there ',15),\n('seemed--to--me ',14),\n('i--did--not ',14),\n('i--saw--the ',13),\n('i--began--to ',13)]\nNow, let\u2019s visualize the token frequency among these three models: unigrams, bigrams,\nand trigrams.\nbigram_freqs =[freq for token, freq inbigram_vocab .token_freqs]\ntrigram_freqs =[freq for token, freq intrigram_vocab .token_freqs]\nd2l.plot([freqs, bigram_freqs, trigram_freqs], xlabel ='token: x ',\nylabel ='frequency: n(x) ', xscale ='log', yscale ='log',\nlegend =['unigram ','bigram ','trigram '])\nThis figure is quite exciting. First, beyond unigram words, sequences of words also appear\nto be following Zipf\u2019s law, albeit with a smaller exponent \ud835\udefcin(9.2.1 ), depending on the\nsequence length. Second, the number of distinct \ud835\udc5b-grams is not that large. This gives us\nhope that there is quite a lot of structure in language. Third, many \ud835\udc5b-grams occur very\nrarely. This makes certain methods unsuitable for language modeling and motivates the\nuse of deep learning models. We will discuss this in the next section.\n9.2.6Summary\nText is among the most common forms of sequence data encountered in deep learning.\nCommon choices for what constitutes a token are characters, words, and word pieces. To\npreprocess text, we usually (i) split text into tokens; (ii) build a vocabulary to map token\nstrings to numerical indices; and (iii) convert text data into token indices for models to\n342 Recurrent Neural Networks\n138manipulate. In practice, the frequency of words tends to follow Zipf\u2019s law. This is true not\njust for individual words (unigrams), but also for \ud835\udc5b-grams.\n9.2.7Exercises\n1.In the experiment of this section, tokenize text into words and vary the min_freq argu-\nment value of the Vocabinstance. Qualitatively characterize how changes in min_freq\nimpact the size of the resulting vocabulary.\n2.EstimatetheexponentofZipfiandistributionforunigrams,bigrams,andtrigramsinthis\ncorpus.\n3.Find some other sources of data (download a standard machine learning dataset, pick\nanother public domain book, scrape a website, etc). For each, tokenize the data at both\nthe word and character levels. How do the vocabulary sizes compare with The Time\nMachine corpusatequivalentvaluesof min_freq . EstimatetheexponentoftheZipfian\ndistribution corresponding to the unigram and bigram distributions for these corpora.\nHow do they compare with the values that you observed for TheTimeMachine corpus?\nDiscussions138.\n9.3LanguageModels\nInSection 9.2 , we saw how to map text sequences into tokens, where these tokens can be\nviewed as a sequence of discrete observations such as words or characters. Assume that\nthe tokens in a text sequence of length \ud835\udc47are in turn\ud835\udc651,\ud835\udc652,...,\ud835\udc65\ud835\udc47. The goal of language\nmodelsis to estimate the joint probability of the whole sequence:\n\ud835\udc43\u00b9\ud835\udc651,\ud835\udc652,...,\ud835\udc65\ud835\udc47\u00ba, (9.3.1)\nwhere statistical tools in Section 9.1 can be applied.\nLanguage models are incredibly useful. For instance, an ideal language model should\ngenerate natural text on its own, simply by drawing one token at a time \ud835\udc65\ud835\udc61\u0018\ud835\udc43\u00b9\ud835\udc65\ud835\udc61j\n\ud835\udc65\ud835\udc61\u00001,...,\ud835\udc65 1\u00ba. Quite unlike the monkey using a typewriter, all text emerging from such\na model would pass as natural language, e.g., English text. Furthermore, it would be suffi-\ncientforgeneratingameaningfuldialog,simplybyconditioningthetextonpreviousdialog\nfragments.", "mimetype": "text/plain", "start_char_idx": 814296, "end_char_idx": 817912, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "60dd11e1-4437-485a-a5f2-edce7893ad77": {"__data__": {"id_": "60dd11e1-4437-485a-a5f2-edce7893ad77", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0306ffb8-89c6-4daf-b391-ef44c918266a", "node_type": "1", "metadata": {}, "hash": "792554ea1b825854772f89653ea24bfed19c2e3303c827656f10b12ddea610eb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "735a507b-9a5a-4b49-80fa-083c601d9138", "node_type": "1", "metadata": {}, "hash": "19fc0ef7153c3d84813689334b45063473c687e332fb2c589c028b34c593c475", "class_name": "RelatedNodeInfo"}}, "text": "The goal of language\nmodelsis to estimate the joint probability of the whole sequence:\n\ud835\udc43\u00b9\ud835\udc651,\ud835\udc652,...,\ud835\udc65\ud835\udc47\u00ba, (9.3.1)\nwhere statistical tools in Section 9.1 can be applied.\nLanguage models are incredibly useful. For instance, an ideal language model should\ngenerate natural text on its own, simply by drawing one token at a time \ud835\udc65\ud835\udc61\u0018\ud835\udc43\u00b9\ud835\udc65\ud835\udc61j\n\ud835\udc65\ud835\udc61\u00001,...,\ud835\udc65 1\u00ba. Quite unlike the monkey using a typewriter, all text emerging from such\na model would pass as natural language, e.g., English text. Furthermore, it would be suffi-\ncientforgeneratingameaningfuldialog,simplybyconditioningthetextonpreviousdialog\nfragments. Clearly we are still very far from designing such a system, since it would need\ntounderstand the text rather than just generate grammatically sensible content.\nNonetheless, language models are of great service even in their limited form. For instance,\nthephrases\u201ctorecognizespeech\u201dand\u201ctowreckanicebeach\u201dsoundverysimilar. Thiscan\ncause ambiguity in speech recognition, which is easily resolved through a language model\nthat rejects the second translation as outlandish. Likewise, in a document summarization\nalgorithm it is worthwhile knowing that \u201cdog bites man\u201d is much more frequent than \u201cman\n343 Language Models\n139bitesdog\u201d,orthat\u201cIwanttoeatgrandma\u201disaratherdisturbingstatement,whereas\u201cIwant\nto eat, grandma\u201d is much more benign.\nimport torch\nfrom d2l import torch asd2l\n9.3.1Learning LanguageModels\nThe obvious question is how we should model a document, or even a sequence of tokens.\nSupposethatwetokenizetextdataatthewordlevel. Let\u2019sstartbyapplyingbasicprobability\nrules:\n\ud835\udc43\u00b9\ud835\udc651,\ud835\udc652,...,\ud835\udc65\ud835\udc47\u00ba=\ud835\udc47\u00d6\n\ud835\udc61=1\ud835\udc43\u00b9\ud835\udc65\ud835\udc61j\ud835\udc651,...,\ud835\udc65\ud835\udc61\u00001\u00ba. (9.3.2)\nFor example, the probability of a text sequence containing four words would be given\nas:\n\ud835\udc43\u00b9deep,learning,is,fun\u00ba\n=\ud835\udc43\u00b9deep\u00ba\ud835\udc43\u00b9learningjdeep\u00ba\ud835\udc43\u00b9isjdeep,learning\u00ba\ud835\udc43\u00b9funjdeep,learning,is\u00ba.(9.3.3)\nMarkovModels and \ud835\udc5b-grams\nAmong those sequence model analyses in Section 9.1 , let\u2019s apply Markov models to lan-\nguage modeling. A distribution over sequences satisfies the Markov property of first order\nif\ud835\udc43\u00b9\ud835\udc65\ud835\udc61\u00b81j\ud835\udc65\ud835\udc61,...,\ud835\udc65 1\u00ba=\ud835\udc43\u00b9\ud835\udc65\ud835\udc61\u00b81j\ud835\udc65\ud835\udc61\u00ba. Higher orders correspond to longer dependencies.\nThisleadstoanumberofapproximationsthatwecouldapplytomodelasequence:\n\ud835\udc43\u00b9\ud835\udc651,\ud835\udc652,\ud835\udc653,\ud835\udc654\u00ba=\ud835\udc43\u00b9\ud835\udc651\u00ba\ud835\udc43\u00b9\ud835\udc652\u00ba\ud835\udc43\u00b9\ud835\udc653\u00ba\ud835\udc43\u00b9\ud835\udc654\u00ba,\n\ud835\udc43\u00b9\ud835\udc651,\ud835\udc652,\ud835\udc653,\ud835\udc654\u00ba=\ud835\udc43\u00b9\ud835\udc651\u00ba\ud835\udc43\u00b9\ud835\udc652j\ud835\udc651\u00ba\ud835\udc43\u00b9\ud835\udc653j\ud835\udc652\u00ba\ud835\udc43\u00b9\ud835\udc654j\ud835\udc653\u00ba,\n\ud835\udc43\u00b9\ud835\udc651,\ud835\udc652,\ud835\udc653,\ud835\udc654\u00ba=\ud835\udc43\u00b9\ud835\udc651\u00ba\ud835\udc43\u00b9\ud835\udc652j\ud835\udc651\u00ba\ud835\udc43\u00b9\ud835\udc653j\ud835\udc651,\ud835\udc652\u00ba\ud835\udc43\u00b9\ud835\udc654j\ud835\udc652,\ud835\udc653\u00ba.(9.3.4)\nThe probability formulae that involve one, two, and three variables are typically referred\nto asunigram ,bigram, andtrigrammodels, respectively. In order to compute the language\nmodel, we need to calculate the probability of words and the conditional probability of\na word given the previous few words. Note that such probabilities are language model\nparameters.", "mimetype": "text/plain", "start_char_idx": 817311, "end_char_idx": 819986, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "735a507b-9a5a-4b49-80fa-083c601d9138": {"__data__": {"id_": "735a507b-9a5a-4b49-80fa-083c601d9138", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "60dd11e1-4437-485a-a5f2-edce7893ad77", "node_type": "1", "metadata": {}, "hash": "1a0e701d0f5358effb9c113c95fb8ca117e13b4bc00bc80127eda640a0aa3483", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7a118f90-381c-46c5-8091-7726c0a36476", "node_type": "1", "metadata": {}, "hash": "2b6aa256224474ca42b79b8cb446a931d0f763506121847231366e3dfddae550", "class_name": "RelatedNodeInfo"}}, "text": "(9.3.4)\nThe probability formulae that involve one, two, and three variables are typically referred\nto asunigram ,bigram, andtrigrammodels, respectively. In order to compute the language\nmodel, we need to calculate the probability of words and the conditional probability of\na word given the previous few words. Note that such probabilities are language model\nparameters.\nWordFrequency\nHere,weassumethatthetrainingdatasetisalargetextcorpus,suchasallWikipediaentries,\nProject Gutenberg139, and all text posted on the web. The probability of words can be\ncalculated from the relative word frequency of a given word in the training dataset. For\nexample, theestimate \u02c6\ud835\udc43\u00b9deep\u00bacanbecalculatedastheprobabilityofanysentencestarting\nwith the word \u201cdeep\u201d. A slightly less accurate approach would be to count all occurrences\n344 Recurrent Neural Networks\nof the word \u201cdeep\u201d and divide it by the total number of words in the corpus. This works\nfairlywell,particularlyforfrequentwords. Movingon,wecouldattempttoestimate\n\u02c6\ud835\udc43\u00b9learningjdeep\u00ba=\ud835\udc5b\u00b9deep, learning\u00ba\n\ud835\udc5b\u00b9deep\u00ba, (9.3.5)\nwhere\ud835\udc5b\u00b9\ud835\udc65\u00baand\ud835\udc5b\u00b9\ud835\udc65,\ud835\udc650\u00baare the number of occurrences of singletons and consecutive word\npairs, respectively. Unfortunately, estimating the probability of a word pair is somewhat\nmoredifficult,sincetheoccurrencesof\u201cdeeplearning\u201darealotlessfrequent. Inparticular,\nfor some unusual word combinations it may be tricky to find enough occurrences to get\naccurate estimates. As suggested by the empirical results in Section 9.2.5 , things take a\nturn for the worse for three-word combinations and beyond. There will be many plausible\nthree-wordcombinationsthatwelikelywillnotseeinourdataset. Unlessweprovidesome\nsolutiontoassignsuchwordcombinationsanonzerocount,wewillnotbeabletousethem\nin a language model. If the dataset is small or if the words are very rare, we might not find\neven a single one of them.\nLaplaceSmoothing\nA common strategy is to perform some form of Laplacesmoothing . The solution is to add\nasmallconstanttoallcounts. Denoteby \ud835\udc5bthetotalnumberofwordsinthetrainingsetand\n\ud835\udc5athe number of unique words. This solution helps with singletons, e.g., via\n\u02c6\ud835\udc43\u00b9\ud835\udc65\u00ba=\ud835\udc5b\u00b9\ud835\udc65\u00ba\u00b8\ud835\udf161\u009d\ud835\udc5a\n\ud835\udc5b\u00b8\ud835\udf161,\n\u02c6\ud835\udc43\u00b9\ud835\udc650j\ud835\udc65\u00ba=\ud835\udc5b\u00b9\ud835\udc65,\ud835\udc650\u00ba\u00b8\ud835\udf162\u02c6\ud835\udc43\u00b9\ud835\udc650\u00ba\n\ud835\udc5b\u00b9\ud835\udc65\u00ba\u00b8\ud835\udf162,\n\u02c6\ud835\udc43\u00b9\ud835\udc6500j\ud835\udc65,\ud835\udc650\u00ba=\ud835\udc5b\u00b9\ud835\udc65,\ud835\udc650,\ud835\udc6500\u00ba\u00b8\ud835\udf163\u02c6\ud835\udc43\u00b9\ud835\udc6500\u00ba\n\ud835\udc5b\u00b9\ud835\udc65,\ud835\udc650\u00ba\u00b8\ud835\udf163.(9.3.6)\nHere\ud835\udf161,\ud835\udf162,and\ud835\udf163arehyperparameters. Take \ud835\udf161asanexample: when \ud835\udf161=0,nosmoothing\nis applied; when \ud835\udf161approaches positive infinity, \u02c6\ud835\udc43\u00b9\ud835\udc65\u00baapproaches the uniform probability\n1\u009d\ud835\udc5a. The above is a rather primitive variant of what other techniques can accomplish\n(Woodetal., 2011).\nUnfortunately, modelslikethisgetunwieldyratherquicklyforthefollowingreasons. First,\nas discussed in Section 9.2.5 , many\ud835\udc5b-grams occur very rarely, making Laplace smoothing\nrather unsuitable for language modeling. Second, we need to store all counts. Third, this\nentirely ignores the meaning of the words. For instance, \u201ccat\u201d and \u201cfeline\u201d should occur in\nrelated contexts. It is quite difficult to adjust such models to additional contexts, whereas,\ndeep learning based language models are well suited to take this into account. Last, long\nword sequences are almost certain to be novel, hence a model that simply counts the fre-\nquencyofpreviouslyseenwordsequencesisboundtoperformpoorlythere.", "mimetype": "text/plain", "start_char_idx": 819616, "end_char_idx": 822802, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7a118f90-381c-46c5-8091-7726c0a36476": {"__data__": {"id_": "7a118f90-381c-46c5-8091-7726c0a36476", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "735a507b-9a5a-4b49-80fa-083c601d9138", "node_type": "1", "metadata": {}, "hash": "19fc0ef7153c3d84813689334b45063473c687e332fb2c589c028b34c593c475", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9bbce4d6-9059-4ac1-a38f-f256bb7688f7", "node_type": "1", "metadata": {}, "hash": "0a9236a1b0cd46cf9347666316f07f12bc8fcbffaf4daf2b050017c1fc1cdf58", "class_name": "RelatedNodeInfo"}}, "text": "The above is a rather primitive variant of what other techniques can accomplish\n(Woodetal., 2011).\nUnfortunately, modelslikethisgetunwieldyratherquicklyforthefollowingreasons. First,\nas discussed in Section 9.2.5 , many\ud835\udc5b-grams occur very rarely, making Laplace smoothing\nrather unsuitable for language modeling. Second, we need to store all counts. Third, this\nentirely ignores the meaning of the words. For instance, \u201ccat\u201d and \u201cfeline\u201d should occur in\nrelated contexts. It is quite difficult to adjust such models to additional contexts, whereas,\ndeep learning based language models are well suited to take this into account. Last, long\nword sequences are almost certain to be novel, hence a model that simply counts the fre-\nquencyofpreviouslyseenwordsequencesisboundtoperformpoorlythere. Therefore,we\nfocus on using neural networks for language modeling in the rest of the chapter.\n9.3.2Perplexity\n345 Language Models\nNext, let\u2019s discuss about how to measure the quality of the language model, which we\nwill then use to evaluate our models in the subsequent sections. One way is to check how\nsurprising the text is. A good language model is able to predict, with high accuracy, the\ntokens that come next. Consider the following continuations of the phrase \u201cIt is raining\u201d,\nas proposed by different language models:\n1.\u201cIt is raining outside\u201d\n2.\u201cIt is raining banana tree\u201d\n3.\u201cIt is raining piouw;kcj pwepoiut\u201d\nIn terms of quality, Example 1 is clearly the best. The words are sensible and logically co-\nherent. Whileitmightnotquiteaccuratelyreflectwhichwordfollowssemantically(\u201cinSan\nFrancisco\u201d and \u201cin winter\u201d would have been perfectly reasonable extensions), the model is\nabletocapturewhichkindofwordfollows. Example2isconsiderablyworsebyproducing\na nonsensical extension. Nonetheless, at least the model has learned how to spell words\nand some degree of correlation between words. Last, Example 3 indicates a poorly trained\nmodel that does not fit data properly.\nWe might measure the quality of the model by computing the likelihood of the sequence.\nUnfortunatelythisisanumberthatishardtounderstandanddifficulttocompare. Afterall,\nshorter sequencesare muchmore likelyto occur than the longerones, hence evaluatingthe\nmodel on Tolstoy\u2019s magnum opus War and Peace will inevitably produce a much smaller\nlikelihood than, say, on Saint-Exupery\u2019s novella The Little Prince . What is missing is the\nequivalent of an average.\nInformation theory comes handy here. We defined entropy, surprisal, and cross-entropy\nwhen we introduced the softmax regression ( Section 4.1.3 ). If we want to compress text,\nwecanaskaboutpredictingthenexttokengiventhecurrentsetoftokens. Abetterlanguage\nmodelshouldallowustopredictthenexttokenmoreaccurately. Thus,itshouldallowusto\nspend fewer bits in compressing the sequence. So we can measure it by the cross-entropy\nloss averaged over all the \ud835\udc5btokens of a sequence:\n1\n\ud835\udc5b\ud835\udc5b\u00d5\n\ud835\udc61=1\u0000log\ud835\udc43\u00b9\ud835\udc65\ud835\udc61j\ud835\udc65\ud835\udc61\u00001,...,\ud835\udc65 1\u00ba, (9.3.7)\nwhere\ud835\udc43isgivenbyalanguagemodeland \ud835\udc65\ud835\udc61istheactualtokenobservedattimestep \ud835\udc61from\nthe sequence. This makes the performance on documents of different lengths comparable.\nFor historical reasons, scientists in natural language processing prefer to use a quantity\ncalledperplexity . In a nutshell, it is the exponential of (9.3.7 ):\nexp \n\u00001\n\ud835\udc5b\ud835\udc5b\u00d5\n\ud835\udc61=1log\ud835\udc43\u00b9\ud835\udc65\ud835\udc61j\ud835\udc65\ud835\udc61\u00001,...,\ud835\udc65 1\u00ba!\n. (9.3.8)\nPerplexitycanbebestunderstoodasthereciprocalofthegeometricmeanofthenumberof\nreal choices that we have when deciding which token to pick next. Let\u2019s look at a number\nof cases:\n346 Recurrent Neural Networks\n\u000fIn the best case scenario, the model always perfectly estimates the probability of the\ntarget token as 1. In this case the perplexity of the model is 1.\n\u000fIn the worst case scenario, the model always predicts the probability of the target token\nas 0. In this situation, the perplexity is positive infinity.", "mimetype": "text/plain", "start_char_idx": 822012, "end_char_idx": 825829, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9bbce4d6-9059-4ac1-a38f-f256bb7688f7": {"__data__": {"id_": "9bbce4d6-9059-4ac1-a38f-f256bb7688f7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7a118f90-381c-46c5-8091-7726c0a36476", "node_type": "1", "metadata": {}, "hash": "2b6aa256224474ca42b79b8cb446a931d0f763506121847231366e3dfddae550", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5c600742-599f-4c38-ae5d-4d8e35e7172b", "node_type": "1", "metadata": {}, "hash": "7549b700e006d08859440f619a0de898b0c128d2efc8467e2b299b9391cb593a", "class_name": "RelatedNodeInfo"}}, "text": "In a nutshell, it is the exponential of (9.3.7 ):\nexp \n\u00001\n\ud835\udc5b\ud835\udc5b\u00d5\n\ud835\udc61=1log\ud835\udc43\u00b9\ud835\udc65\ud835\udc61j\ud835\udc65\ud835\udc61\u00001,...,\ud835\udc65 1\u00ba!\n. (9.3.8)\nPerplexitycanbebestunderstoodasthereciprocalofthegeometricmeanofthenumberof\nreal choices that we have when deciding which token to pick next. Let\u2019s look at a number\nof cases:\n346 Recurrent Neural Networks\n\u000fIn the best case scenario, the model always perfectly estimates the probability of the\ntarget token as 1. In this case the perplexity of the model is 1.\n\u000fIn the worst case scenario, the model always predicts the probability of the target token\nas 0. In this situation, the perplexity is positive infinity.\n\u000fAtthe baseline, the model predicts a uniform distribution overall the availabletokensof\nthe vocabulary. In this case, the perplexity equals the number of unique tokens of the\nvocabulary. In fact, if we were to store the sequence without any compression, this\nwouldbe thebestwecould doforencodingit. Hence, this providesa nontrivialupper\nbound that any useful model must beat.\n9.3.3PartitioningSequences\nWe will design language models using neural networks and use perplexity to evaluate how\ngood the model is at predicting the next token given the current set of tokens in text se-\nquences. Before introducing the model, let\u2019s assume that it processes a minibatch of se-\nquences with predefined length at a time. Now the question is how to read minibatches of\ninput sequences and target sequences at random.\nSuppose that the dataset takes the form of a sequence of \ud835\udc47token indices in corpus. We\nwill partition it into subsequences, where each subsequence has \ud835\udc5btokens (time steps). To\niterateover(almost)allthetokensoftheentiredatasetforeachepochandobtainallpossible\nlength-\ud835\udc5bsubsequences, we can introduce randomness. More concretely, at the beginning\nof each epoch, discard the first \ud835\udc51tokens, where \ud835\udc512\u00bb0,\ud835\udc5b\u00bais uniformly sampled at random.\nTherestofthesequenceisthenpartitionedinto \ud835\udc5a=b\u00b9\ud835\udc47\u0000\ud835\udc51\u00ba\u009d\ud835\udc5bcsubsequences. Denoteby\nx\ud835\udc61=\u00bb\ud835\udc65\ud835\udc61,...,\ud835\udc65\ud835\udc61\u00b8\ud835\udc5b\u00001\u00bcthe length-\ud835\udc5bsubsequence starting from token \ud835\udc65\ud835\udc61at time step\ud835\udc61. The\nresulting\ud835\udc5apartitioned subsequences are x\ud835\udc51,x\ud835\udc51\u00b8\ud835\udc5b,...,x\ud835\udc51\u00b8\ud835\udc5b\u00b9\ud835\udc5a\u00001\u00ba.Each subsequence will\nbe used as an input sequence into the language model.\nFor language modeling, the goal is to predict the next token based on the tokens we have\nseen so far; hence the targets (labels) are the original sequence, shifted by one token. The\ntarget sequence for any input sequence x\ud835\udc61isx\ud835\udc61\u00b81with length\ud835\udc5b.\ntFig. 9.3.1 Obtaining \ufb01ve pairs of input sequences and target sequences from partitioned length-5\nsubsequences.\nFig.9.3.1 showsanexampleofobtainingfivepairsofinputsequencesandtargetsequences\nwith\ud835\udc5b=5and\ud835\udc51=2.\n@d2l .add_to_class(d2l .TimeMachine) #@save\ndef __init__ (self , batch_size, num_steps, num_train =10000 , num_val =5000 ):\nsuper (d2l .TimeMachine, self ).__init__ ()\nself .save_hyperparameters()\ncorpus, self .vocab =self .build( self ._download())\n(continues on next page)\n347 Language Models\n(continued from previous page)\narray =torch .tensor([corpus[i:i +num_steps +1]\nfor iinrange (len(corpus) -num_steps)])\nself .X,self .Y=array[:,: -1], array[:, 1:]\nTo train language models, we will randomly sample pairs of input sequences and target\nsequences in minibatches. The followingdata loader randomlygeneratesa minibatchfrom\nthe dataset each time. The argument batch_size specifies the number of subsequence\nexamples in each minibatch and num_steps is the subsequence length in tokens.", "mimetype": "text/plain", "start_char_idx": 825220, "end_char_idx": 828601, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5c600742-599f-4c38-ae5d-4d8e35e7172b": {"__data__": {"id_": "5c600742-599f-4c38-ae5d-4d8e35e7172b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9bbce4d6-9059-4ac1-a38f-f256bb7688f7", "node_type": "1", "metadata": {}, "hash": "0a9236a1b0cd46cf9347666316f07f12bc8fcbffaf4daf2b050017c1fc1cdf58", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cc2c15db-3c3f-48a3-acda-58f8a61f09b3", "node_type": "1", "metadata": {}, "hash": "aa359c60180e5be363d5574edacc4403265e170da021244e0e4cb6267c6f4501", "class_name": "RelatedNodeInfo"}}, "text": "The followingdata loader randomlygeneratesa minibatchfrom\nthe dataset each time. The argument batch_size specifies the number of subsequence\nexamples in each minibatch and num_steps is the subsequence length in tokens.\n@d2l .add_to_class(d2l .TimeMachine) #@save\ndef get_dataloader (self , train):\nidx =slice (0,self .num_train) iftrain else slice (\nself .num_train, self .num_train +self .num_val)\nreturn self .get_tensorloader([ self .X,self .Y], train, idx)\nAs we can see in the following, a minibatch of target sequences can be obtained by shifting\nthe input sequences by one token.\ndata =d2l.TimeMachine(batch_size =2, num_steps =10)\nfor X, Y indata .train_dataloader():\nprint ('X:', X, '\\nY:', Y)\nbreak\nDownloading ../data /timemachine .txt from http ://d2l-data .s3-accelerate .\n\u21a9!amazonaws .com/timemachine .txt...\nX: tensor([[ 10,4,2,21,10,16,15,0,20,2],\n[21,9,6,19,0,24,2,26,0,16]])\nY: tensor([[ 4,2,21,10,16,15,0,20,2,10],\n[9,6,19,0,24,2,26,0,16,9]])\n9.3.4Summaryand Discussion\nLanguage models estimate the joint probability of a text sequence. For long sequences,\n\ud835\udc5b-grams provide a convenient model by truncating the dependence. However, there is a lot\nofstructurebutnotenoughfrequencytodealefficientlywithinfrequentwordcombinations\nvia Laplace smoothing. Thus, we will focus on neural language modeling in subsequent\nsections. To train language models, we can randomly sample pairs of input sequences\nand target sequences in minibatches. After training, we will use perplexity to measure the\nlanguage model quality.\nLanguage models can be scaled up with increased data size, model size, and amount in\ntraining compute. Large language models can perform desired tasks by predicting output\ntextgiveninputtextinstructions. Aswewilldiscusslater(e.g., Section11.9 ),atthepresent\nmoment large language models form the basis of state-of-the-art systems across diverse\ntasks.\n348 Recurrent Neural Networks\n1409.3.5Exercises\n1.Suppose there are 100,000 words in the training dataset. How much word frequency\nand multi-word adjacent frequency does a four-gram need to store?\n2.How would you model a dialogue?\n3.What other methods can you think of for reading long sequence data?\n4.Consider our method for discarding a uniformly random number of the first few tokens\nat the beginning of each epoch.\n1.Doesitreallyleadtoaperfectlyuniformdistributionoverthesequencesonthedocu-\nment?\n2.What would you have to do to make things even more uniform?\n5.If we want a sequence example to be a complete sentence, what kind of problem does\nthis introduce in minibatch sampling? How can we fix it?\nDiscussions140.\n9.4RecurrentNeuralNetworks\nInSection 9.3 we described Markov models and \ud835\udc5b-grams for language modeling, where\nthe conditional probability of token \ud835\udc65\ud835\udc61at time step \ud835\udc61only depends on the \ud835\udc5b\u00001previous\ntokens. If we want to incorporate the possible effect of tokens earlier than time step \ud835\udc61\u0000\n\u00b9\ud835\udc5b\u00001\u00baon\ud835\udc65\ud835\udc61, weneedtoincrease \ud835\udc5b. However, thenumberofmodelparameterswouldalso\nincrease exponentially with it, as we need to store jVj\ud835\udc5bnumbers for a vocabulary set V.\nHence,ratherthanmodeling \ud835\udc43\u00b9\ud835\udc65\ud835\udc61j\ud835\udc65\ud835\udc61\u00001,...,\ud835\udc65\ud835\udc61\u0000\ud835\udc5b\u00b81\u00baitispreferabletousealatentvariable\nmodel,\n\ud835\udc43\u00b9\ud835\udc65\ud835\udc61j\ud835\udc65\ud835\udc61\u00001,...,\ud835\udc65 1\u00ba\u0019\ud835\udc43\u00b9\ud835\udc65\ud835\udc61j\u210e\ud835\udc61\u00001\u00ba, (9.4.1)\nwhere\u210e\ud835\udc61\u00001is ahidden state that stores the sequence information up to time step \ud835\udc61\u00001.", "mimetype": "text/plain", "start_char_idx": 828383, "end_char_idx": 831644, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cc2c15db-3c3f-48a3-acda-58f8a61f09b3": {"__data__": {"id_": "cc2c15db-3c3f-48a3-acda-58f8a61f09b3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5c600742-599f-4c38-ae5d-4d8e35e7172b", "node_type": "1", "metadata": {}, "hash": "7549b700e006d08859440f619a0de898b0c128d2efc8467e2b299b9391cb593a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "10e50c27-ec8f-4f96-a235-873d5dc6890e", "node_type": "1", "metadata": {}, "hash": "6f9b2220f7df9421b7ade95cc67a59f17a9dbe5a86c81a79310f7b6f9e90a1e7", "class_name": "RelatedNodeInfo"}}, "text": "In\ngeneral, the hidden state at any time step \ud835\udc61could be computed based on both the current\ninput\ud835\udc65\ud835\udc61and the previous hidden state \u210e\ud835\udc61\u00001:\n\u210e\ud835\udc61=\ud835\udc53\u00b9\ud835\udc65\ud835\udc61,\u210e\ud835\udc61\u00001\u00ba. (9.4.2)\nForasufficientlypowerfulfunction \ud835\udc53in(9.4.2 ),thelatentvariablemodelisnotanapprox-\nimation. Afterall, \u210e\ud835\udc61maysimplystoreallthedataithasobservedsofar. However, itcould\npotentially make both computation and storage expensive.\nRecallthatwehavediscussedhiddenlayerswithhiddenunitsin Chapter5 . Itisnoteworthy\nthat hidden layers and hidden states refer to two very different concepts. Hidden layers are,\nas explained, layers that are hidden from view on the path from input to output. Hidden\n349 Recurrent Neural Networks\nstates are technically speaking inputsto whatever we do at a given step, and they can only\nbe computed by looking at data at previous time steps.\nRecurrent neural networks (RNNs) are neural networks with hidden states. Before intro-\nducing the RNN model, we first revisit the MLP model introduced in Section 5.1 .\nimport torch\nfrom d2l import torch asd2l\n9.4.1NeuralNetworkswithout Hidden States\nLet\u2019s take a look at an MLP with a single hidden layer. Let the hidden layer\u2019s activation\nfunction be\ud835\udf19. Given a minibatch of examples X2R\ud835\udc5b\u0002\ud835\udc51with batch size \ud835\udc5band\ud835\udc51inputs,\nthe hidden layer output H2R\ud835\udc5b\u0002\u210eis calculated as\nH=\ud835\udf19\u00b9XWxh\u00b8bh\u00ba. (9.4.3)\nIn(9.4.3 ), we have the weight parameter Wxh2R\ud835\udc51\u0002\u210e, the bias parameter bh2R1\u0002\u210e, and\nthe number of hidden units \u210e, for the hidden layer. So armed, we apply broadcasting (see\nSection 2.1.4 ) during the summation. Next, the hidden layer output His used as input of\nthe output layer, which is given by\nO=HWhq\u00b8bq, (9.4.4)\nwhere O2R\ud835\udc5b\u0002\ud835\udc5eis the output variable, Whq2R\u210e\u0002\ud835\udc5eis the weight parameter, and bq2\nR1\u0002\ud835\udc5eis the bias parameter of the output layer. If it is a classification problem, we can use\nsoftmax\u00b9O\u00bato compute the probability distribution of the output categories.\nThis is entirely analogous to the regression problem we solved previously in Section 9.1 ,\nhence we omit details. Suffice it to say that we can pick feature-label pairs at random and\nlearn the parameters of our network via automatic differentiation and stochastic gradient\ndescent.\n9.4.2RecurrentNeuralNetworkswith Hidden States\nMatters are entirely different when we have hidden states. Let\u2019s look at the structure in\nsome more detail.\nAssume that we have a minibatch of inputs X\ud835\udc612R\ud835\udc5b\u0002\ud835\udc51at time step\ud835\udc61. In other words, for\na minibatch of \ud835\udc5bsequence examples, each row of X\ud835\udc61corresponds to one example at time\nstep\ud835\udc61from the sequence. Next, denote by H\ud835\udc612R\ud835\udc5b\u0002\u210ethe hidden layer output of time step\n\ud835\udc61. UnlikewithMLP,herewesavethehiddenlayeroutput H\ud835\udc61\u00001fromtheprevioustimestep\nandintroduceanewweightparameter Whh2R\u210e\u0002\u210etodescribehowtousethehiddenlayer\noutput of the previous time step in the current time step. Specifically, the calculation of the\nhidden layer output of the current time step is determined by the input of the current time\nstep together with the hidden layer output of the previous time step:\nH\ud835\udc61=\ud835\udf19\u00b9X\ud835\udc61Wxh\u00b8H\ud835\udc61\u00001Whh\u00b8bh\u00ba. (9.4.5)\n350 Recurrent Neural Networks\nComparedwith (9.4.3 ),(9.4.5 )addsonemoreterm H\ud835\udc61\u00001Whhandthusinstantiates (9.4.2 ).", "mimetype": "text/plain", "start_char_idx": 831645, "end_char_idx": 834752, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "10e50c27-ec8f-4f96-a235-873d5dc6890e": {"__data__": {"id_": "10e50c27-ec8f-4f96-a235-873d5dc6890e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cc2c15db-3c3f-48a3-acda-58f8a61f09b3", "node_type": "1", "metadata": {}, "hash": "aa359c60180e5be363d5574edacc4403265e170da021244e0e4cb6267c6f4501", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6b54c715-51ff-4f60-baa0-c5499d80e177", "node_type": "1", "metadata": {}, "hash": "1cb72403bee5dc7c676a37b56ae599b086e7c6243773b59c164056a8305a544e", "class_name": "RelatedNodeInfo"}}, "text": "Specifically, the calculation of the\nhidden layer output of the current time step is determined by the input of the current time\nstep together with the hidden layer output of the previous time step:\nH\ud835\udc61=\ud835\udf19\u00b9X\ud835\udc61Wxh\u00b8H\ud835\udc61\u00001Whh\u00b8bh\u00ba. (9.4.5)\n350 Recurrent Neural Networks\nComparedwith (9.4.3 ),(9.4.5 )addsonemoreterm H\ud835\udc61\u00001Whhandthusinstantiates (9.4.2 ).\nFrom the relationship between hidden layer outputs H\ud835\udc61andH\ud835\udc61\u00001of adjacent time steps,\nwe know that these variables captured and retained the sequence\u2019s historical information\nup to their current time step, just like the state or memory of the neural network\u2019s current\ntime step. Therefore, such a hidden layer output is called a hidden state . Since the hidden\nstate uses the same definition of the previous time step in the current time step, the compu-\ntation of (9.4.5 )isrecurrent . Hence, as we said, neural networks with hidden states based\non recurrent computation are named recurrent neural networks . Layers that perform the\ncomputation of (9.4.5 )in RNNs are called recurrentlayers .\nThere are many different ways for constructing RNNs. Those with a hidden state defined\nby(9.4.5 )are very common. For time step \ud835\udc61, the output of the output layer is similar to the\ncomputation in the MLP:\nO\ud835\udc61=H\ud835\udc61Whq\u00b8bq. (9.4.6)\nParameters of the RNN include the weights Wxh2R\ud835\udc51\u0002\u210e,Whh2R\u210e\u0002\u210e, and the bias bh2\nR1\u0002\u210eof the hidden layer, together with the weights Whq2R\u210e\u0002\ud835\udc5eand the bias bq2R1\u0002\ud835\udc5e\nof the output layer. It is worth mentioning that even at different time steps, RNNs always\nuse these model parameters. Therefore, the parametrization cost of an RNN does not grow\nas the number of time steps increases.\nFig. 9.4.1 illustrates the computational logic of an RNN at three adjacent time steps. At\nany time step \ud835\udc61, the computation of the hidden state can be treated as: (i) concatenating the\ninputX\ud835\udc61at the current time step \ud835\udc61and the hidden state H\ud835\udc61\u00001at the previous time step \ud835\udc61\u00001;\n(ii)feedingtheconcatenationresultintoafullyconnectedlayerwiththeactivationfunction\n\ud835\udf19. Theoutputofsuchafullyconnectedlayeristhehiddenstate H\ud835\udc61ofthecurrenttimestep\n\ud835\udc61. In this case, the model parameters are the concatenation of WxhandWhh, and a bias\nofbh, all from (9.4.5 ). The hidden state of the current time step \ud835\udc61,H\ud835\udc61, will participate in\ncomputing the hidden state H\ud835\udc61\u00b81of the next time step \ud835\udc61\u00b81. What is more, H\ud835\udc61will also be\nfed into the fully connected output layer to compute the output O\ud835\udc61of the current time step\n\ud835\udc61.\ntFig. 9.4.1 An RNN with a hidden state.\nWejustmentionedthatthecalculationof X\ud835\udc61Wxh\u00b8H\ud835\udc61\u00001Whhforthehiddenstateisequiv-\nalent to matrix multiplication of the concatenation of X\ud835\udc61andH\ud835\udc61\u00001and the concatenation\nofWxhandWhh. Though this can be proven mathematically, in the following we just use\n351 Recurrent Neural Networks\na simple code snippet as a demonstration. To begin with, we define matrices X,W_xh,H,\nandW_hh, whose shapes are (3, 1), (1, 4), (3, 4), and (4, 4), respectively. Multiplying Xby\nW_xh, and HbyW_hh, and then adding these two products, we obtain a matrix of shape (3,\n4).", "mimetype": "text/plain", "start_char_idx": 834409, "end_char_idx": 837422, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6b54c715-51ff-4f60-baa0-c5499d80e177": {"__data__": {"id_": "6b54c715-51ff-4f60-baa0-c5499d80e177", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "10e50c27-ec8f-4f96-a235-873d5dc6890e", "node_type": "1", "metadata": {}, "hash": "6f9b2220f7df9421b7ade95cc67a59f17a9dbe5a86c81a79310f7b6f9e90a1e7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5dbccf7b-5ce5-4308-ad0f-bf57b02f8664", "node_type": "1", "metadata": {}, "hash": "6445f9fb1492cca2df61dadbf719976309f0ed99acd6121376b34dbded2106fa", "class_name": "RelatedNodeInfo"}}, "text": "9.4.1 An RNN with a hidden state.\nWejustmentionedthatthecalculationof X\ud835\udc61Wxh\u00b8H\ud835\udc61\u00001Whhforthehiddenstateisequiv-\nalent to matrix multiplication of the concatenation of X\ud835\udc61andH\ud835\udc61\u00001and the concatenation\nofWxhandWhh. Though this can be proven mathematically, in the following we just use\n351 Recurrent Neural Networks\na simple code snippet as a demonstration. To begin with, we define matrices X,W_xh,H,\nandW_hh, whose shapes are (3, 1), (1, 4), (3, 4), and (4, 4), respectively. Multiplying Xby\nW_xh, and HbyW_hh, and then adding these two products, we obtain a matrix of shape (3,\n4).\nX, W_xh =torch .randn( 3,1), torch .randn( 1,4)\nH, W_hh =torch .randn( 3,4), torch .randn( 4,4)\ntorch .matmul(X, W_xh) +torch .matmul(H, W_hh)\ntensor([[ 1.2526 ,0.0580 ,-3.3460 ,-0.2519 ],\n[-1.3064 ,1.4132 ,-0.1435 ,0.3482 ],\n[3.1495 ,0.8172 ,1.5167 ,-0.9038 ]])\nNow we concatenate the matrices XandHalong columns (axis 1), and the matrices W_xh\nandW_hhalong rows (axis 0). These two concatenations result in matrices of shape (3, 5)\nand of shape (5, 4), respectively. Multiplying these two concatenated matrices, we obtain\nthe same output matrix of shape (3, 4) as above.\ntorch .matmul(torch .cat((X, H), 1), torch .cat((W_xh, W_hh), 0))\ntensor([[ 1.2526 ,0.0580 ,-3.3460 ,-0.2519 ],\n[-1.3064 ,1.4132 ,-0.1435 ,0.3482 ],\n[3.1495 ,0.8172 ,1.5167 ,-0.9038 ]])\n9.4.3RNN-Based Character-LevelLanguageModels\nRecallthatforlanguagemodelingin Section9.3 , weaimtopredictthenexttokenbasedon\nthe current and past tokens; thus we shift the original sequence by one token as the targets\n(labels). Bengio etal.(2003)firstproposedtouseaneuralnetworkforlanguagemodeling.\nIn the following we illustrate how RNNs can be used to build a language model. Let the\nminibatch size be one, and the sequence of the text be \u201cmachine\u201d. To simplify training\nin subsequent sections, we tokenize text into characters rather than words and consider a\ncharacter-level language model .Fig. 9.4.2 demonstrates how to predict the next charac-\nter based on the current and previous characters via an RNN for character-level language\nmodeling.\nDuringthetrainingprocess,werunasoftmaxoperationontheoutputfromtheoutputlayer\nfor each time step, and then use the cross-entropy loss to compute the error between the\nmodeloutputandthetarget. Becauseoftherecurrentcomputationofthehiddenstateinthe\nhidden layer, the output, O3, of time step 3 in Fig. 9.4.2 is determined by the text sequence\n\u201cm\u201d, \u201ca\u201d, and \u201cc\u201d. Since the next character of the sequence in the training data is \u201ch\u201d, the\nlossoftimestep3willdependontheprobabilitydistributionofthenextcharactergenerated\nbased on the feature sequence \u201cm\u201d, \u201ca\u201d, \u201cc\u201d and the target \u201ch\u201d of this time step.\nIn practice, each token is represented by a \ud835\udc51-dimensional vector, and we use a batch size\n352 Recurrent Neural Networks\ntFig. 9.4.2 A character-level language model based on the RNN. The input and target sequences are\n\u201cmachin\u201d and \u201cachine\u201d, respectively.\n141\ud835\udc5b> 1. Therefore, the input X\ud835\udc61at time step\ud835\udc61will be an\ud835\udc5b\u0002\ud835\udc51matrix, which is identical to\nwhat we discussed in Section 9.4.2 .\nIn the following sections, we will implement RNNs for character-level language mod-\nels.", "mimetype": "text/plain", "start_char_idx": 836845, "end_char_idx": 839994, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5dbccf7b-5ce5-4308-ad0f-bf57b02f8664": {"__data__": {"id_": "5dbccf7b-5ce5-4308-ad0f-bf57b02f8664", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6b54c715-51ff-4f60-baa0-c5499d80e177", "node_type": "1", "metadata": {}, "hash": "1cb72403bee5dc7c676a37b56ae599b086e7c6243773b59c164056a8305a544e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "60d8a5ea-871d-425c-ba22-8f6335886d9d", "node_type": "1", "metadata": {}, "hash": "20b23ab4f15172ad4f777c0be1a1af55a7a47c217419e119b898c3700d7fb8f8", "class_name": "RelatedNodeInfo"}}, "text": "Since the next character of the sequence in the training data is \u201ch\u201d, the\nlossoftimestep3willdependontheprobabilitydistributionofthenextcharactergenerated\nbased on the feature sequence \u201cm\u201d, \u201ca\u201d, \u201cc\u201d and the target \u201ch\u201d of this time step.\nIn practice, each token is represented by a \ud835\udc51-dimensional vector, and we use a batch size\n352 Recurrent Neural Networks\ntFig. 9.4.2 A character-level language model based on the RNN. The input and target sequences are\n\u201cmachin\u201d and \u201cachine\u201d, respectively.\n141\ud835\udc5b> 1. Therefore, the input X\ud835\udc61at time step\ud835\udc61will be an\ud835\udc5b\u0002\ud835\udc51matrix, which is identical to\nwhat we discussed in Section 9.4.2 .\nIn the following sections, we will implement RNNs for character-level language mod-\nels.\n9.4.4Summary\nA neural network that uses recurrent computation for hidden states is called a recurrent\nneural network (RNN). The hidden state of an RNN can capture historical information of\nthe sequence up to the current time step. With recurrent computation, the number of RNN\nmodelparametersdoesnotgrowasthenumberoftimestepsincreases. Asforapplications,\nan RNN can be used to create character-level language models.\n9.4.5Exercises\n1.If we use an RNN to predict the next character in a text sequence, what is the required\ndimension for any output?\n2.Why can RNNs express the conditional probability of a token at some time step based\non all the previous tokens in the text sequence?\n3.What happens to the gradient if you backpropagate through a long sequence?\n4.What are some of the problems associated with the language model described in this\nsection?\nDiscussions141.\n9.5RecurrentNeuralNetworkImplementation\nfromScratch\nWe are now ready to implement an RNN from scratch. In particular, we will train this\nRNN to function as a character-level language model (see Section 9.4 ) and train it on a\n353 Recurrent Neural Network Implementation from Scratch\ncorpus consisting of the entire text of H. G. Wells\u2019 The Time Machine , following the data\nprocessing steps outlined in Section 9.2 . We start by loading the dataset.\n%matplotlib inline\nimport math\nimport torch\nfrom torch import nn\nfrom torch .nnimport functional asF\nfrom d2l import torch asd2l\n9.5.1RNNModel\nWe begin by defining a class to implement the RNN model ( Section 9.4.2 ). Note that the\nnumber of hidden units num_hiddens is a tunable hyperparameter.\nclass RNNScratch (d2l .Module): #@save\n\"\"\"The RNN model implemented from scratch.\"\"\"\ndef __init__ (self , num_inputs, num_hiddens, sigma =0.01 ):\nsuper ().__init__ ()\nself .save_hyperparameters()\nself .W_xh =nn.Parameter(\ntorch .randn(num_inputs, num_hiddens) *sigma)\nself .W_hh =nn.Parameter(\ntorch .randn(num_hiddens, num_hiddens) *sigma)\nself .b_h =nn.Parameter(torch .zeros(num_hiddens))\nTheforward methodbelowdefineshowtocomputetheoutputandhiddenstateatanytime\nstep, given the current input and the state of the model at the previous time step. Note that\nthe RNN model loops through the outermost dimension of inputs, updating the hidden\nstate one time step at a time. The model here uses a tanhactivation function ( Section\n5.1.2).\n@d2l .add_to_class(RNNScratch) #@save\ndef forward (self , inputs, state =None ):\nifstate isNone :\n# Initial state with shape: (batch_size, num_hiddens)\nstate =torch .zeros((inputs .shape[ 1],self .num_hiddens),\ndevice =inputs .device)\nelse :\nstate, =state\noutputs =[]\nfor Xininputs: # Shape of inputs: (num_steps, batch_size, num_inputs)\nstate =torch .tanh(torch .matmul(X, self .W_xh) +\ntorch .matmul(state, self .W_hh) +self .b_h)\noutputs .append(state)\nreturn outputs, state\nWe can feed a minibatch of input sequences into an RNN model as follows.", "mimetype": "text/plain", "start_char_idx": 839289, "end_char_idx": 842899, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "60d8a5ea-871d-425c-ba22-8f6335886d9d": {"__data__": {"id_": "60d8a5ea-871d-425c-ba22-8f6335886d9d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5dbccf7b-5ce5-4308-ad0f-bf57b02f8664", "node_type": "1", "metadata": {}, "hash": "6445f9fb1492cca2df61dadbf719976309f0ed99acd6121376b34dbded2106fa", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "13f2ba21-ea4d-4828-9b4c-8c21829ac607", "node_type": "1", "metadata": {}, "hash": "07e67de7d7178717a90a7ddad8ff4f6083ee442da224a8dc133c8ebc512d7e5a", "class_name": "RelatedNodeInfo"}}, "text": "The model here uses a tanhactivation function ( Section\n5.1.2).\n@d2l .add_to_class(RNNScratch) #@save\ndef forward (self , inputs, state =None ):\nifstate isNone :\n# Initial state with shape: (batch_size, num_hiddens)\nstate =torch .zeros((inputs .shape[ 1],self .num_hiddens),\ndevice =inputs .device)\nelse :\nstate, =state\noutputs =[]\nfor Xininputs: # Shape of inputs: (num_steps, batch_size, num_inputs)\nstate =torch .tanh(torch .matmul(X, self .W_xh) +\ntorch .matmul(state, self .W_hh) +self .b_h)\noutputs .append(state)\nreturn outputs, state\nWe can feed a minibatch of input sequences into an RNN model as follows.\nbatch_size, num_inputs, num_hiddens, num_steps =2,16,32,100\n(continues on next page)\n354 Recurrent Neural Networks\n(continued from previous page)\nrnn =RNNScratch(num_inputs, num_hiddens)\nX=torch .ones((num_steps, batch_size, num_inputs))\noutputs, state =rnn(X)\nLet\u2019s check whether the RNN model produces results of the correct shapes to ensure that\nthe dimensionality of the hidden state remains unchanged.\ndef check_len (a, n): #@save\n\"\"\"Check the length of a list.\"\"\"\nassert len(a) ==n,f'list \\'s length {len(a)}!= expected length {n}'\ndef check_shape (a, shape): #@save\n\"\"\"Check the shape of a tensor.\"\"\"\nassert a.shape ==shape, \\\nf'tensor \\'s shape {a.shape }!= expected shape {shape }'\ncheck_len(outputs, num_steps)\ncheck_shape(outputs[ 0], (batch_size, num_hiddens))\ncheck_shape(state, (batch_size, num_hiddens))\n9.5.2RNN-BasedLanguageModel\nThe following RNNLMScratch class defines an RNN-based language model, where wepass\nin our RNN via the rnnargument of the __init__ method. When training language mod-\nels, the inputs and outputs are from the same vocabulary. Hence, they have the same di-\nmension, which is equal to the vocabulary size. Note that we use perplexity to evaluate the\nmodel. As discussed in Section 9.3.2 , this ensures that sequences of different length are\ncomparable.\nclass RNNLMScratch (d2l .Classifier): #@save\n\"\"\"The RNN-based language model implemented from scratch.\"\"\"\ndef __init__ (self , rnn, vocab_size, lr =0.01 ):\nsuper ().__init__ ()\nself .save_hyperparameters()\nself .init_params()\ndef init_params (self ):\nself .W_hq =nn.Parameter(\ntorch .randn(\nself .rnn.num_hiddens, self .vocab_size) *self .rnn.sigma)\nself .b_q =nn.Parameter(torch .zeros( self .vocab_size))\ndef training_step (self , batch):\nl=self .loss( self (*batch[: -1]), batch[ -1])\nself .plot( 'ppl', torch .exp(l), train =True )\nreturn l\ndef validation_step (self , batch):\nl=self .loss( self (*batch[: -1]), batch[ -1])\nself .plot( 'ppl', torch .exp(l), train =False )\n355 Recurrent Neural Network Implementation from Scratch\nOne-HotEncoding\nRecall that each token is represented by a numerical index indicating the position in the\nvocabularyofthecorrespondingword/character/wordpiece. Youmightbetemptedtobuild\na neural network with a single input node (at each time step), where the index could be fed\nin as a scalar value. This works when we are dealing with numerical inputs like price or\ntemperature, where any two values sufficiently close together should be treated similarly.\nBut this does not quite make sense. The 45thand46thwords in our vocabulary happen to\nbe \u201ctheir\u201d and \u201csaid\u201d, whose meanings are not remotely similar.\nWhen dealing with such categorical data, the most common strategy is to represent each\nitem by a one-hot encoding (recall from Section 4.1.1 ). A one-hot encoding is a vector\nwhose length is given by the size of the vocabulary \ud835\udc41, where all entries are set to 0, except\nfor the entry corresponding to our token, which is set to 1. For example, if the vocabulary\nhad five elements, then the one-hot vectors corresponding to indices 0 and 2 would be the\nfollowing.", "mimetype": "text/plain", "start_char_idx": 842285, "end_char_idx": 845997, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "13f2ba21-ea4d-4828-9b4c-8c21829ac607": {"__data__": {"id_": "13f2ba21-ea4d-4828-9b4c-8c21829ac607", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "60d8a5ea-871d-425c-ba22-8f6335886d9d", "node_type": "1", "metadata": {}, "hash": "20b23ab4f15172ad4f777c0be1a1af55a7a47c217419e119b898c3700d7fb8f8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "55a581d2-aa2e-4879-82ef-31a2734ef44b", "node_type": "1", "metadata": {}, "hash": "1fbf705e68c6b3bed3c694d6cb338ac40b1c3030cc89e541320982200d335ca7", "class_name": "RelatedNodeInfo"}}, "text": "This works when we are dealing with numerical inputs like price or\ntemperature, where any two values sufficiently close together should be treated similarly.\nBut this does not quite make sense. The 45thand46thwords in our vocabulary happen to\nbe \u201ctheir\u201d and \u201csaid\u201d, whose meanings are not remotely similar.\nWhen dealing with such categorical data, the most common strategy is to represent each\nitem by a one-hot encoding (recall from Section 4.1.1 ). A one-hot encoding is a vector\nwhose length is given by the size of the vocabulary \ud835\udc41, where all entries are set to 0, except\nfor the entry corresponding to our token, which is set to 1. For example, if the vocabulary\nhad five elements, then the one-hot vectors corresponding to indices 0 and 2 would be the\nfollowing.\nF.one_hot(torch .tensor([ 0,2]), 5)\ntensor([[ 1,0,0,0,0],\n[0,0,1,0,0]])\nThe minibatches that we sample at each iteration will take the shape (batch size, number\nof time steps). Once representing each input as a one-hot vector, we can think of each\nminibatch as a three-dimensional tensor, where the length along the third axis is given by\nthe vocabulary size ( len(vocab) ). We often transpose the input so that we will obtain an\noutput of shape (number of time steps, batch size, vocabulary size). This will allow us to\nloop more conveniently through the outermost dimension for updating hidden states of a\nminibatch, time step by time step (e.g., in the above forward method).\n@d2l .add_to_class(RNNLMScratch) #@save\ndef one_hot (self , X):\n# Output shape: (num_steps, batch_size, vocab_size)\nreturn F.one_hot(X .T,self .vocab_size) .type(torch .float32)\nTransformingRNN Outputs\nThe language model uses a fully connected output layer to transform RNN outputs into\ntoken predictions at each time step.\n@d2l .add_to_class(RNNLMScratch) #@save\ndef output_layer (self , rnn_outputs):\noutputs =[torch .matmul(H, self .W_hq) +self .b_q for Hinrnn_outputs]\nreturn torch .stack(outputs, 1)\n@d2l .add_to_class(RNNLMScratch) #@save\n(continues on next page)\n356 Recurrent Neural Networks\n(continued from previous page)\ndef forward (self , X, state =None ):\nembs =self .one_hot(X)\nrnn_outputs, _ =self .rnn(embs, state)\nreturn self .output_layer(rnn_outputs)\nLet\u2019scheckwhethertheforwardcomputationproducesoutputswiththecorrectshape.\nmodel =RNNLMScratch(rnn, num_inputs)\noutputs =model(torch .ones((batch_size, num_steps), dtype =torch .int64))\ncheck_shape(outputs, (batch_size, num_steps, num_inputs))\n9.5.3Gradient Clipping\nWhileyouarealreadyusedtothinkingofneuralnetworksas\u201cdeep\u201dinthesensethatmany\nlayers separate the input and output even within a single time step, the length of the se-\nquence introduces a new notion of depth. In addition to the passing through the network\nin the input-to-output direction, inputs at the first time step must pass through a chain of \ud835\udc47\nlayers along the time steps in order to influence the output of the model at the final time\nstep. Taking the backwards view, in each iteration, we backpropagate gradients through\ntime, resulting in a chain of matrix-products of length O\u00b9\ud835\udc47\u00ba. As mentioned in Section 5.4 ,\nthis can result in numerical instability, causing the gradients either to explode or vanish,\ndepending on the properties of the weight matrices.\nDealing with vanishing and exploding gradients is a fundamental problem when designing\nRNNs and has inspired some of the biggest advances in modern neural network architec-\ntures. Inthenextchapter,wewilltalkaboutspecializedarchitecturesthatweredesignedin\nhopes of mitigating the vanishing gradient problem. However, even modern RNNs often\nsufferfromexplodinggradients. Oneinelegantbutubiquitoussolutionistosimplyclipthe\ngradients forcing the resulting \u201cclipped\u201d gradients to take smaller values.\nGenerally speaking, when optimizing some objective by gradient descent, we iteratively\nupdatetheparameterofinterest,sayavector x,butpushingitinthedirectionofthenegative\ngradient g(instochasticgradientdescent,wecalculatethisgradientonarandomlysampled\nminibatch).", "mimetype": "text/plain", "start_char_idx": 845229, "end_char_idx": 849235, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "55a581d2-aa2e-4879-82ef-31a2734ef44b": {"__data__": {"id_": "55a581d2-aa2e-4879-82ef-31a2734ef44b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "13f2ba21-ea4d-4828-9b4c-8c21829ac607", "node_type": "1", "metadata": {}, "hash": "07e67de7d7178717a90a7ddad8ff4f6083ee442da224a8dc133c8ebc512d7e5a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "da26f561-4f90-438d-889f-18e100ce7cdc", "node_type": "1", "metadata": {}, "hash": "03061eb5c738053c1c228cc8aa336273057bfed0c5c078b7d192a8b273aeae64", "class_name": "RelatedNodeInfo"}}, "text": "Dealing with vanishing and exploding gradients is a fundamental problem when designing\nRNNs and has inspired some of the biggest advances in modern neural network architec-\ntures. Inthenextchapter,wewilltalkaboutspecializedarchitecturesthatweredesignedin\nhopes of mitigating the vanishing gradient problem. However, even modern RNNs often\nsufferfromexplodinggradients. Oneinelegantbutubiquitoussolutionistosimplyclipthe\ngradients forcing the resulting \u201cclipped\u201d gradients to take smaller values.\nGenerally speaking, when optimizing some objective by gradient descent, we iteratively\nupdatetheparameterofinterest,sayavector x,butpushingitinthedirectionofthenegative\ngradient g(instochasticgradientdescent,wecalculatethisgradientonarandomlysampled\nminibatch). Forexample,withlearningrate \ud835\udf02> 0,eachupdatetakestheform x x\u0000\ud835\udf02g.\nLet\u2019s further assume that the objective function \ud835\udc53is sufficiently smooth. Formally, we say\nthat the objective is Lipschitz continuous with constant \ud835\udc3f, meaning that for any xandy,\nwe have\nj\ud835\udc53\u00b9x\u00ba\u0000\ud835\udc53\u00b9y\u00baj\u0014\ud835\udc3fkx\u0000yk. (9.5.1)\nAs you can see, when we update the parameter vector by subtracting \ud835\udf02g, the change in\nthe value of the objective depends on the learning rate, the norm of the gradient and \ud835\udc3fas\nfollows:\nj\ud835\udc53\u00b9x\u00ba\u0000\ud835\udc53\u00b9x\u0000\ud835\udf02g\u00baj\u0014\ud835\udc3f\ud835\udf02kgk. (9.5.2)\nIn other words, the objective cannot change by more than \ud835\udc3f\ud835\udf02kgk. Having a small value for\n357 Recurrent Neural Network Implementation from Scratch\nthis upper bound might be viewed as good or bad. On the downside, we are limiting the\nspeed at which we can reduce the value of the objective. On the bright side, this limits by\njust how much we can go wrong in any one gradient step.\nWhen we say that gradients explode, we mean that kgkbecomes excessively large. In this\nworst case, we might do so much damage in a single gradient step that we could undo all\nof the progress made over the course of thousands of training iterations. When gradients\ncan be so large, neural network training often diverges, failing to reduce the value of the\nobjective. At other times, training eventually converges but is unstable owing to massive\nspikes in the loss.\nOne way to limit the size of \ud835\udc3f\ud835\udf02kgkis to shrink the learning rate \ud835\udf02to tiny values. This\nhas the advantage that we do not bias the updates. But what if we only rarelyget large\ngradients? This drastic move slows down our progress at all steps, just to deal with the rare\nexploding gradient events. A popular alternative is to adopt a gradient clipping heuristic\nprojecting the gradients gonto a ball of some given radius \ud835\udf03as follows:\ng min\u0012\n1,\ud835\udf03\nkgk\u0013\ng. (9.5.3)\nThisensuresthatthegradientnormneverexceeds \ud835\udf03andthattheupdatedgradientisentirely\naligned with the original direction of g. It also has the desirable side-effect of limiting the\ninfluence any given minibatch (and within it any given sample) can exert on the parameter\nvector. This bestows a certain degree of robustness to the model. To be clear, it is a hack.\nGradient clipping means that we are not always following the true gradient and it is hard to\nreason analytically about the possible side effects. However, it is a very useful hack, and is\nwidely adopted in RNN implementations in most deep learning frameworks.\nBelow we define a method to clip gradients, which is invoked by the fit_epoch method\nof the d2l.Trainer class (see Section 3.4 ). Note that when computing the gradient norm,\nwe are concatenating all model parameters, treating them as a single giant parameter vec-\ntor.", "mimetype": "text/plain", "start_char_idx": 848478, "end_char_idx": 851920, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "da26f561-4f90-438d-889f-18e100ce7cdc": {"__data__": {"id_": "da26f561-4f90-438d-889f-18e100ce7cdc", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "55a581d2-aa2e-4879-82ef-31a2734ef44b", "node_type": "1", "metadata": {}, "hash": "1fbf705e68c6b3bed3c694d6cb338ac40b1c3030cc89e541320982200d335ca7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "946da3ae-095a-4376-aa05-d80f5eeab86a", "node_type": "1", "metadata": {}, "hash": "2e86cd36171f9802c38d92905dff17a5e63ad117955ea1e1354563f474b763cc", "class_name": "RelatedNodeInfo"}}, "text": "This bestows a certain degree of robustness to the model. To be clear, it is a hack.\nGradient clipping means that we are not always following the true gradient and it is hard to\nreason analytically about the possible side effects. However, it is a very useful hack, and is\nwidely adopted in RNN implementations in most deep learning frameworks.\nBelow we define a method to clip gradients, which is invoked by the fit_epoch method\nof the d2l.Trainer class (see Section 3.4 ). Note that when computing the gradient norm,\nwe are concatenating all model parameters, treating them as a single giant parameter vec-\ntor.\n@d2l .add_to_class(d2l .Trainer) #@save\ndef clip_gradients (self , grad_clip_val, model):\nparams =[pfor pinmodel .parameters() ifp.requires_grad]\nnorm =torch .sqrt( sum(torch .sum((p .grad **2))for pinparams))\nifnorm >grad_clip_val:\nfor param inparams:\nparam .grad[:] *=grad_clip_val /norm\n9.5.4Training\nUsingTheTimeMachine dataset( data),wetrainacharacter-levellanguagemodel( model)\nbased on the RNN ( rnn) implemented from scratch. Note that we first calculate the gra-\ndients, then clip them, and finally update the model parameters using the clipped gradi-\nents.\n358 Recurrent Neural Networks\ndata =d2l.TimeMachine(batch_size =1024 , num_steps =32)\nrnn =RNNScratch(num_inputs =len(data .vocab), num_hiddens =32)\nmodel =RNNLMScratch(rnn, vocab_size =len(data .vocab), lr =1)\ntrainer =d2l.Trainer(max_epochs =100, gradient_clip_val =1, num_gpus =1)\ntrainer .fit(model, data)\n9.5.5Decoding\nOnce a language model has been learned, we can use it not only to predict the next token\nbut to continue predicting each subsequent one, treating the previously predicted token as\nthoughitwerethenextintheinput. Sometimeswewilljustwanttogeneratetextasthough\nwewerestartingatthebeginningofadocument. However,itisoftenusefultoconditionthe\nlanguagemodelonauser-suppliedprefix. Forexample,ifweweredevelopinganautocom-\nplete feature for a search engine or to assist users in writing emails, we would want to feed\nin what they had written so far (the prefix), and then generate a likely continuation.\nThe following predict method generates a continuation, one character at a time, after\ningesting a user-provided prefix. When looping through the characters in prefix, we\nkeep passing the hidden state to the next time step but do not generate any output. This is\ncalled the warm-up period. After ingesting the prefix, we are now ready to begin emitting\nthe subsequent characters, each of which will be fed back into the model as the input at the\nnext time step.\n@d2l .add_to_class(RNNLMScratch) #@save\ndef predict (self , prefix, num_preds, vocab, device =None ):\nstate, outputs =None , [vocab[prefix[ 0]]]\nfor iinrange (len(prefix) +num_preds -1):\nX=torch .tensor([[outputs[ -1]]], device =device)\nembs =self .one_hot(X)\nrnn_outputs, state =self .rnn(embs, state)\nifi<len(prefix) -1:# Warm-up period\noutputs .append(vocab[prefix[i +1]])\nelse :# Predict num_preds steps\nY=self .output_layer(rnn_outputs)\noutputs .append( int(Y.argmax(axis =2).reshape( 1)))\nreturn ''.join([vocab .idx_to_token[i] for iinoutputs])\nInthefollowing,wespecifytheprefixandhaveitgenerate20additionalcharacters.\n359 Recurrent Neural Network Implementation from Scratch\nmodel .predict( 'it has ',20, data .vocab, d2l .try_gpu())\n'it has in the the the the '\nWhileimplementingtheaboveRNNmodelfromscratchisinstructive,itisnotconvenient.\nInthenextsection,wewillseehowtoleveragedeeplearningframeworkstowhipupRNNs\nusingstandardarchitectures, andtoreapperformancegainsbyrelyingonhighlyoptimized\nlibrary functions.\n9.5.6Summary\nWecantrainRNN-basedlanguagemodelstogeneratetextfollowingtheuser-providedtext\nprefix. A simple RNN language model consists of input encoding, RNN modeling, and\noutput generation.", "mimetype": "text/plain", "start_char_idx": 851307, "end_char_idx": 855077, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "946da3ae-095a-4376-aa05-d80f5eeab86a": {"__data__": {"id_": "946da3ae-095a-4376-aa05-d80f5eeab86a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "da26f561-4f90-438d-889f-18e100ce7cdc", "node_type": "1", "metadata": {}, "hash": "03061eb5c738053c1c228cc8aa336273057bfed0c5c078b7d192a8b273aeae64", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e46db9a1-daf2-427b-84e3-4e700078319f", "node_type": "1", "metadata": {}, "hash": "4feb093ec47fbeeb702aa8384dfeaab777c3bbb2798f440370f541eedc4029ba", "class_name": "RelatedNodeInfo"}}, "text": "359 Recurrent Neural Network Implementation from Scratch\nmodel .predict( 'it has ',20, data .vocab, d2l .try_gpu())\n'it has in the the the the '\nWhileimplementingtheaboveRNNmodelfromscratchisinstructive,itisnotconvenient.\nInthenextsection,wewillseehowtoleveragedeeplearningframeworkstowhipupRNNs\nusingstandardarchitectures, andtoreapperformancegainsbyrelyingonhighlyoptimized\nlibrary functions.\n9.5.6Summary\nWecantrainRNN-basedlanguagemodelstogeneratetextfollowingtheuser-providedtext\nprefix. A simple RNN language model consists of input encoding, RNN modeling, and\noutput generation. During training, gradient clipping can mitigate the problem of explod-\ning gradients but does not address the problem of vanishing gradients. In the experiment,\nweimplementedasimpleRNNlanguagemodelandtraineditwithgradientclippingonse-\nquences of text, tokenized at the character level. By conditioning on a prefix, we can use a\nlanguagemodeltogeneratelikelycontinuations,whichprovesusefulinmanyapplications,\ne.g., autocomplete features.\n9.5.7Exercises\n1.Doestheimplementedlanguagemodelpredictthenexttokenbasedonallthepasttokens\nup to the very first token in TheTimeMachine ?\n2.Which hyperparameter controls the length of history used for prediction?\n3.Show that one-hot encoding is equivalent to picking a different embedding for each\nobject.\n4.Adjust the hyperparameters (e.g., number of epochs, number of hidden units, number\nof time steps in a minibatch, and learning rate) to improve the perplexity. How low can\nyou go while sticking with this simple architecture?\n5.Replace one-hot encoding with learnable embeddings. Does this lead to better perfor-\nmance?\n6.Conductanexperimenttodeterminehowwellthislanguagemodeltrainedon TheTime\nMachine works on other books by H. G. Wells, e.g., The Warof theWorlds .\n7.Conduct another experiment to evaluate the perplexity of this model on books written\nby other authors.\n8.Modify the prediction method so as to use sampling rather than picking the most likely\nnext character.\n\u000fWhat happens?\n360 Recurrent Neural Networks\n142\u000fBiasthemodeltowardsmorelikelyoutputs,e.g.,bysamplingfrom \ud835\udc5e\u00b9\ud835\udc65\ud835\udc61j\ud835\udc65\ud835\udc61\u00001,...,\ud835\udc65 1\u00ba/\n\ud835\udc43\u00b9\ud835\udc65\ud835\udc61j\ud835\udc65\ud835\udc61\u00001,...,\ud835\udc65 1\u00ba\ud835\udefcfor\ud835\udefc> 1.\n9.Run the code in this section without clipping the gradient. What happens?\n10.Replace the activation function used in this section with ReLU and repeat the experi-\nments in this section. Do we still need gradient clipping? Why?\nDiscussions142.\n9.6ConciseImplementation of RecurrentNeural\nNetworks\nLike most of our from-scratch implementations, Section 9.5 was designed to provide in-\nsight into how each component works. But when you are using RNNs every day or writing\nproduction code, you will want to rely more on libraries that cut down on both implemen-\ntationtime(bysupplyinglibrarycodeforcommonmodelsandfunctions)andcomputation\ntime (by optimizing the heck out of these library implementations). This section will show\nyou how to implement the same language model more efficiently using the high-level API\nprovided by your deep learning framework. We begin, as before, by loading The Time\nMachine dataset.\nimport torch\nfrom torch import nn\nfrom torch .nnimport functional asF\nfrom d2l import torch asd2l\n9.6.1Definingthe Model\nWe define the following class using the RNN implemented by high-level APIs.\nclass RNN(d2l .Module): #@save\n\"\"\"The RNN model implemented with high-level APIs.\"\"\"\ndef __init__ (self , num_inputs, num_hiddens):\nsuper ().__init__ ()\nself .save_hyperparameters()\nself .rnn =nn.RNN(num_inputs, num_hiddens)\ndef forward (self , inputs, H =None ):\nreturn self .rnn(inputs, H)\nInheriting from the RNNLMScratch class inSection 9.5 , the following RNNLMclass defines\na complete RNN-based language model. Note that we need to create a separate fully con-\nnected output layer.\n361 Concise Implementation of Recurrent Neural Networks\nclass RNNLM (d2l .RNNLMScratch): #@save\n\"\"\"The RNN-based language model implemented with high-level APIs.\"\"\"", "mimetype": "text/plain", "start_char_idx": 854492, "end_char_idx": 858415, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e46db9a1-daf2-427b-84e3-4e700078319f": {"__data__": {"id_": "e46db9a1-daf2-427b-84e3-4e700078319f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "946da3ae-095a-4376-aa05-d80f5eeab86a", "node_type": "1", "metadata": {}, "hash": "2e86cd36171f9802c38d92905dff17a5e63ad117955ea1e1354563f474b763cc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "571ac82d-4426-4296-905f-a07eb3ed9d62", "node_type": "1", "metadata": {}, "hash": "64784ff27e961518244eb2f426a3a77e1659121001f138dd3eb1d2826ee368b4", "class_name": "RelatedNodeInfo"}}, "text": "class RNN(d2l .Module): #@save\n\"\"\"The RNN model implemented with high-level APIs.\"\"\"\ndef __init__ (self , num_inputs, num_hiddens):\nsuper ().__init__ ()\nself .save_hyperparameters()\nself .rnn =nn.RNN(num_inputs, num_hiddens)\ndef forward (self , inputs, H =None ):\nreturn self .rnn(inputs, H)\nInheriting from the RNNLMScratch class inSection 9.5 , the following RNNLMclass defines\na complete RNN-based language model. Note that we need to create a separate fully con-\nnected output layer.\n361 Concise Implementation of Recurrent Neural Networks\nclass RNNLM (d2l .RNNLMScratch): #@save\n\"\"\"The RNN-based language model implemented with high-level APIs.\"\"\"\ndef init_params (self ):\nself .linear =nn.LazyLinear( self .vocab_size)\ndef output_layer (self , hiddens):\nreturn self .linear(hiddens) .swapaxes( 0,1)\n9.6.2Trainingand Predicting\nBefore training the model, let\u2019s make a prediction with a model initialized with random\nweights. Given that we have not trained the network, it will generate nonsensical predic-\ntions.\ndata =d2l.TimeMachine(batch_size =1024 , num_steps =32)\nrnn =RNN(num_inputs =len(data .vocab), num_hiddens =32)\nmodel =RNNLM(rnn, vocab_size =len(data .vocab), lr =1)\nmodel .predict( 'it has ',20, data .vocab)\n'it hasoadd dd dd dd dd dd '\nNext, we train our model, leveraging the high-level API.\ntrainer =d2l.Trainer(max_epochs =100, gradient_clip_val =1, num_gpus =1)\ntrainer .fit(model, data)\nComparedwith Section9.5 , thismodelachievescomparableperplexity, butrunsfasterdue\nto the optimized implementations. As before, we can generate predicted tokens following\nthe specified prefix string.\nmodel .predict( 'it has ',20, data .vocab, d2l .try_gpu())\n'it has and the trave the t '\n9.6.3Summary\n362 Recurrent Neural Networks\n143High-level APIs in deep learning frameworks provide implementations of standard RNNs.\nTheselibrarieshelpyoutoavoidwastingtimereimplementingstandardmodels. Moreover,\nframework implementations are often highly optimized, leading to significant (computa-\ntional) performance gains when compared with implementations from scratch.\n9.6.4Exercises\n1.Can you make the RNN model overfit using the high-level APIs?\n2.Implement the autoregressive model of Section 9.1 using an RNN.\nDiscussions143.\n9.7BackpropagationThroughTime\nIfyoucompletedtheexercisesin Section9.5 , youwouldhaveseenthatgradientclippingis\nvitalforpreventingtheoccasionalmassivegradientsfromdestabilizingtraining. Wehinted\nthat the exploding gradients stem from backpropagating across long sequences. Before in-\ntroducing a slew of modern RNN architectures, let\u2019s take a closer look at how backprop-\nagationworks in sequence models in mathematical detail. Hopefully, this discussion will\nbring some precision to the notion of vanishing andexploding gradients. If you recall our\ndiscussion of forward and backward propagation through computational graphs when we\nintroduced MLPs in Section 5.3 , then forward propagation in RNNs should be relatively\nstraightforward. Applying backpropagation in RNNs is called backpropagation through\ntime(Werbos, 1990 ). This procedure requires us to expand (or unroll) the computational\ngraph of an RNN one time step at a time. The unrolled RNN is essentially a feedforward\nneural network with the special property that the same parameters are repeated throughout\nthe unrolled network, appearing at each time step. Then, just as in any feedforward neural\nnetwork, we can apply the chain rule, backpropagating gradients through the unrolled net.\nThe gradient with respect to each parameter must be summed across all places that the pa-\nrameteroccursintheunrollednet. Handlingsuchweighttyingshouldbefamiliarfromour\nchapters on convolutional neural networks.\nComplications arise because sequences can be rather long. It is not unusual to work with\ntext sequences consisting of over a thousand tokens. Note that this poses problems both\nfrom a computational (too much memory) and optimization (numerical instability) stand-\npoint.", "mimetype": "text/plain", "start_char_idx": 857763, "end_char_idx": 861729, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "571ac82d-4426-4296-905f-a07eb3ed9d62": {"__data__": {"id_": "571ac82d-4426-4296-905f-a07eb3ed9d62", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e46db9a1-daf2-427b-84e3-4e700078319f", "node_type": "1", "metadata": {}, "hash": "4feb093ec47fbeeb702aa8384dfeaab777c3bbb2798f440370f541eedc4029ba", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "311a4f84-216d-410f-90ba-5b70baeb799e", "node_type": "1", "metadata": {}, "hash": "4e7f82454c640cb0de88843b7dcf5bf0ab27c718aa35b0e2d39de48b66d38ee8", "class_name": "RelatedNodeInfo"}}, "text": "This procedure requires us to expand (or unroll) the computational\ngraph of an RNN one time step at a time. The unrolled RNN is essentially a feedforward\nneural network with the special property that the same parameters are repeated throughout\nthe unrolled network, appearing at each time step. Then, just as in any feedforward neural\nnetwork, we can apply the chain rule, backpropagating gradients through the unrolled net.\nThe gradient with respect to each parameter must be summed across all places that the pa-\nrameteroccursintheunrollednet. Handlingsuchweighttyingshouldbefamiliarfromour\nchapters on convolutional neural networks.\nComplications arise because sequences can be rather long. It is not unusual to work with\ntext sequences consisting of over a thousand tokens. Note that this poses problems both\nfrom a computational (too much memory) and optimization (numerical instability) stand-\npoint. Input from the first step passes through over 1000 matrix products before arriving\nat the output, and another 1000 matrix products are required to compute the gradient. We\nnow analyze what can go wrong and how to address it in practice.\n9.7.1Analysisof Gradients in RNNs\nWe start with a simplified model of how an RNN works. This model ignores details about\nthespecificsofthehiddenstateandhowitisupdated. Themathematicalnotationheredoes\n363 Backpropagation Through Time\nnotexplicitlydistinguishscalars, vectors, andmatrices. Wearejusttryingtodevelopsome\nintuition. In this simplified model, we denote \u210e\ud835\udc61as the hidden state, \ud835\udc65\ud835\udc61as input, and \ud835\udc5c\ud835\udc61as\noutput at time step \ud835\udc61. Recall our discussions in Section 9.4.2 that the input and the hidden\nstatecanbeconcatenatedbeforebeingmultipliedbyoneweightvariableinthehiddenlayer.\nThus, we use \ud835\udc64hand\ud835\udc64oto indicate the weights of the hidden layer and the output layer,\nrespectively. As a result, the hidden states and outputs at each time step are\n\u210e\ud835\udc61=\ud835\udc53\u00b9\ud835\udc65\ud835\udc61,\u210e\ud835\udc61\u00001,\ud835\udc64h\u00ba,\n\ud835\udc5c\ud835\udc61=\ud835\udc54\u00b9\u210e\ud835\udc61,\ud835\udc64o\u00ba,(9.7.1)\nwhere\ud835\udc53and\ud835\udc54are transformations of the hidden layer and the output layer, respectively.\nHence, we have a chain of values f...,\u00b9\ud835\udc65\ud835\udc61\u00001,\u210e\ud835\udc61\u00001,\ud835\udc5c\ud835\udc61\u00001\u00ba,\u00b9\ud835\udc65\ud835\udc61,\u210e\ud835\udc61,\ud835\udc5c\ud835\udc61\u00ba,...gthat depend on\neach other via recurrent computation. The forward propagation is fairly straightforward.\nAll we need is to loop through the \u00b9\ud835\udc65\ud835\udc61,\u210e\ud835\udc61,\ud835\udc5c\ud835\udc61\u00batriples one time step at a time. The discrep-\nancy between output \ud835\udc5c\ud835\udc61and the desired target \ud835\udc66\ud835\udc61is then evaluated by an objective function\nacross all the \ud835\udc47time steps as\n\ud835\udc3f\u00b9\ud835\udc651,...,\ud835\udc65\ud835\udc47,\ud835\udc661,...,\ud835\udc66\ud835\udc47,\ud835\udc64h,\ud835\udc64o\u00ba=1\n\ud835\udc47\ud835\udc47\u00d5\n\ud835\udc61=1\ud835\udc59\u00b9\ud835\udc66\ud835\udc61,\ud835\udc5c\ud835\udc61\u00ba. (9.7.2)\nFor backpropagation, matters are a bit trickier, especially when we compute the gradients\nwith regard to the parameters \ud835\udc64hof the objective function \ud835\udc3f. To be specific, by the chain\nrule,\n\ud835\udf15\ud835\udc3f\n\ud835\udf15\ud835\udc64h=1\n\ud835\udc47\ud835\udc47\u00d5\n\ud835\udc61=1\ud835\udf15\ud835\udc59\u00b9\ud835\udc66\ud835\udc61,\ud835\udc5c\ud835\udc61\u00ba\n\ud835\udf15\ud835\udc64h\n=1\n\ud835\udc47\ud835\udc47\u00d5\n\ud835\udc61=1\ud835\udf15\ud835\udc59\u00b9\ud835\udc66\ud835\udc61,\ud835\udc5c\ud835\udc61\u00ba\n\ud835\udf15\ud835\udc5c\ud835\udc61\ud835\udf15\ud835\udc54\u00b9\u210e\ud835\udc61,\ud835\udc64o\u00ba\n\ud835\udf15\u210e\ud835\udc61\ud835\udf15\u210e\ud835\udc61\n\ud835\udf15\ud835\udc64h.(9.7.3)\nThe first and the second factors of the product in (9.7.3 )are easy to compute.", "mimetype": "text/plain", "start_char_idx": 860823, "end_char_idx": 863625, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "311a4f84-216d-410f-90ba-5b70baeb799e": {"__data__": {"id_": "311a4f84-216d-410f-90ba-5b70baeb799e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "571ac82d-4426-4296-905f-a07eb3ed9d62", "node_type": "1", "metadata": {}, "hash": "64784ff27e961518244eb2f426a3a77e1659121001f138dd3eb1d2826ee368b4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b80d32b0-f760-439b-a708-4a8cbd492117", "node_type": "1", "metadata": {}, "hash": "bcf74eff78bf0928f87c6d56454b7bd91b5f2f5c1bb5cfc94dcdd3d9db4c0279", "class_name": "RelatedNodeInfo"}}, "text": "(9.7.3)\nThe first and the second factors of the product in (9.7.3 )are easy to compute. The third\nfactor\ud835\udf15\u210e\ud835\udc61\u009d\ud835\udf15\ud835\udc64his where things get tricky, since we need to recurrently compute the effect\nof the parameter \ud835\udc64hon\u210e\ud835\udc61. According to the recurrent computation in (9.7.1 ),\u210e\ud835\udc61depends\non both\u210e\ud835\udc61\u00001and\ud835\udc64h, where computation of \u210e\ud835\udc61\u00001also depends on \ud835\udc64h. Thus, evaluating the\ntotal derivate of \u210e\ud835\udc61with respect to \ud835\udc64husing the chain rule yields\n\ud835\udf15\u210e\ud835\udc61\n\ud835\udf15\ud835\udc64h=\ud835\udf15\ud835\udc53\u00b9\ud835\udc65\ud835\udc61,\u210e\ud835\udc61\u00001,\ud835\udc64h\u00ba\n\ud835\udf15\ud835\udc64h\u00b8\ud835\udf15\ud835\udc53\u00b9\ud835\udc65\ud835\udc61,\u210e\ud835\udc61\u00001,\ud835\udc64h\u00ba\n\ud835\udf15\u210e\ud835\udc61\u00001\ud835\udf15\u210e\ud835\udc61\u00001\n\ud835\udf15\ud835\udc64h. (9.7.4)\nTo derive the above gradient, assume that we have three sequences f\ud835\udc4e\ud835\udc61g,f\ud835\udc4f\ud835\udc61g,f\ud835\udc50\ud835\udc61gsatisfy-\ning\ud835\udc4e0=0and\ud835\udc4e\ud835\udc61=\ud835\udc4f\ud835\udc61\u00b8\ud835\udc50\ud835\udc61\ud835\udc4e\ud835\udc61\u00001for\ud835\udc61=1,2,.... Then for\ud835\udc61\u00151, it is easy to show\n\ud835\udc4e\ud835\udc61=\ud835\udc4f\ud835\udc61\u00b8\ud835\udc61\u00001\u00d5\n\ud835\udc56=1\u00a9\u00ad\n\u00ab\ud835\udc61\u00d6\n\ud835\udc57=\ud835\udc56\u00b81\ud835\udc50\ud835\udc57\u00aa\u00ae\n\u00ac\ud835\udc4f\ud835\udc56. (9.7.5)\n364 Recurrent Neural Networks\nBy substituting \ud835\udc4e\ud835\udc61,\ud835\udc4f\ud835\udc61, and\ud835\udc50\ud835\udc61according to\n\ud835\udc4e\ud835\udc61=\ud835\udf15\u210e\ud835\udc61\n\ud835\udf15\ud835\udc64h,\n\ud835\udc4f\ud835\udc61=\ud835\udf15\ud835\udc53\u00b9\ud835\udc65\ud835\udc61,\u210e\ud835\udc61\u00001,\ud835\udc64h\u00ba\n\ud835\udf15\ud835\udc64h,\n\ud835\udc50\ud835\udc61=\ud835\udf15\ud835\udc53\u00b9\ud835\udc65\ud835\udc61,\u210e\ud835\udc61\u00001,\ud835\udc64h\u00ba\n\ud835\udf15\u210e\ud835\udc61\u00001,(9.7.6)\nthe gradient computation in (9.7.4 )satisfies\ud835\udc4e\ud835\udc61=\ud835\udc4f\ud835\udc61\u00b8\ud835\udc50\ud835\udc61\ud835\udc4e\ud835\udc61\u00001. Thus, per (9.7.5 ), we can\nremove the recurrent computation in (9.7.4 )with\n\ud835\udf15\u210e\ud835\udc61\n\ud835\udf15\ud835\udc64h=\ud835\udf15\ud835\udc53\u00b9\ud835\udc65\ud835\udc61,\u210e\ud835\udc61\u00001,\ud835\udc64h\u00ba\n\ud835\udf15\ud835\udc64h\u00b8\ud835\udc61\u00001\u00d5\n\ud835\udc56=1\u00a9\u00ad\n\u00ab\ud835\udc61\u00d6\n\ud835\udc57=\ud835\udc56\u00b81\ud835\udf15\ud835\udc53\u00b9\ud835\udc65\ud835\udc57,\u210e\ud835\udc57\u00001,\ud835\udc64h\u00ba\n\ud835\udf15\u210e\ud835\udc57\u00001\u00aa\u00ae\n\u00ac\ud835\udf15\ud835\udc53\u00b9\ud835\udc65\ud835\udc56,\u210e\ud835\udc56\u00001,\ud835\udc64h\u00ba\n\ud835\udf15\ud835\udc64h.(9.7.7)\nWhile we can use the chain rule to compute \ud835\udf15\u210e\ud835\udc61\u009d\ud835\udf15\ud835\udc64hrecursively, this chain can get very\nlong whenever \ud835\udc61is large. Let\u2019s discuss a number of strategies for dealing with this prob-\nlem.\nFull Computation\nOne idea might be to compute the full sum in (9.7.7 ). However, this is very slow and\ngradients can blow up, since subtle changes in the initial conditions can potentially affect\ntheoutcomealot. Thatis,wecouldseethingssimilartothebutterflyeffect,whereminimal\nchanges in the initial conditions lead to disproportionate changes in the outcome. This is\ngenerally undesirable. After all, we are looking for robust estimators that generalize well.\nHence this strategy is almost never used in practice.", "mimetype": "text/plain", "start_char_idx": 863538, "end_char_idx": 865294, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b80d32b0-f760-439b-a708-4a8cbd492117": {"__data__": {"id_": "b80d32b0-f760-439b-a708-4a8cbd492117", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "311a4f84-216d-410f-90ba-5b70baeb799e", "node_type": "1", "metadata": {}, "hash": "4e7f82454c640cb0de88843b7dcf5bf0ab27c718aa35b0e2d39de48b66d38ee8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "97e535ca-abe4-45ee-8c50-37537064d747", "node_type": "1", "metadata": {}, "hash": "ff6bc2fcd0d04830b040f4372d3783bd03d8d54bcf7b1ea30c24fa9d1f4cc19b", "class_name": "RelatedNodeInfo"}}, "text": "(9.7.7)\nWhile we can use the chain rule to compute \ud835\udf15\u210e\ud835\udc61\u009d\ud835\udf15\ud835\udc64hrecursively, this chain can get very\nlong whenever \ud835\udc61is large. Let\u2019s discuss a number of strategies for dealing with this prob-\nlem.\nFull Computation\nOne idea might be to compute the full sum in (9.7.7 ). However, this is very slow and\ngradients can blow up, since subtle changes in the initial conditions can potentially affect\ntheoutcomealot. Thatis,wecouldseethingssimilartothebutterflyeffect,whereminimal\nchanges in the initial conditions lead to disproportionate changes in the outcome. This is\ngenerally undesirable. After all, we are looking for robust estimators that generalize well.\nHence this strategy is almost never used in practice.\nTruncatingTime Steps\nAlternatively, we can truncate the sum in (9.7.7 )after\ud835\udf0fsteps. This is what we have been\ndiscussingsofar. Thisleadstoan approximation ofthetruegradient,simplybyterminating\nthe sum at\ud835\udf15\u210e\ud835\udc61\u0000\ud835\udf0f\u009d\ud835\udf15\ud835\udc64h. In practice this works quite well. It is what is commonly referred\nto as truncated backpropgation through time ( Jaeger, 2002 ). One of the consequences of\nthis is that the model focuses primarily on short-term influence rather than long-term con-\nsequences. Thisisactually desirable ,sinceitbiasestheestimatetowardssimplerandmore\nstable models.\nRandomizedTruncation\nLast, we can replace \ud835\udf15\u210e\ud835\udc61\u009d\ud835\udf15\ud835\udc64hby a random variable which is correct in expectation but\ntruncates the sequence. This is achieved by using a sequence of \ud835\udf09\ud835\udc61with predefined 0\u0014\n\ud835\udf0b\ud835\udc61\u00141, where\ud835\udc43\u00b9\ud835\udf09\ud835\udc61=0\u00ba=1\u0000\ud835\udf0b\ud835\udc61and\ud835\udc43\u00b9\ud835\udf09\ud835\udc61=\ud835\udf0b\u00001\n\ud835\udc61\u00ba=\ud835\udf0b\ud835\udc61, thus\ud835\udc38\u00bb\ud835\udf09\ud835\udc61\u00bc=1. We use this to\nreplace the gradient \ud835\udf15\u210e\ud835\udc61\u009d\ud835\udf15\ud835\udc64hin(9.7.4 )with\n\ud835\udc67\ud835\udc61=\ud835\udf15\ud835\udc53\u00b9\ud835\udc65\ud835\udc61,\u210e\ud835\udc61\u00001,\ud835\udc64h\u00ba\n\ud835\udf15\ud835\udc64h\u00b8\ud835\udf09\ud835\udc61\ud835\udf15\ud835\udc53\u00b9\ud835\udc65\ud835\udc61,\u210e\ud835\udc61\u00001,\ud835\udc64h\u00ba\n\ud835\udf15\u210e\ud835\udc61\u00001\ud835\udf15\u210e\ud835\udc61\u00001\n\ud835\udf15\ud835\udc64h. (9.7.8)\n365 Backpropagation Through Time\nIt follows from the definition of \ud835\udf09\ud835\udc61that\ud835\udc38\u00bb\ud835\udc67\ud835\udc61\u00bc=\ud835\udf15\u210e\ud835\udc61\u009d\ud835\udf15\ud835\udc64h. Whenever\ud835\udf09\ud835\udc61=0the recurrent\ncomputation terminates at that time step \ud835\udc61. This leads to a weighted sum of sequences of\nvarying lengths, where long sequences are rare but appropriately overweighted. This idea\nwas proposed by Tallec and Ollivier ( 2017).\nComparingStrategies\ntFig. 9.7.1 Comparing strategies for computing gradients in RNNs. From top to bottom: randomized\ntruncation, regular truncation, and full computation.\nFig.9.7.1 illustratesthethreestrategieswhenanalyzingthefirstfewcharactersof TheTime\nMachine using backpropagation through time for RNNs:\n\u000fThefirstrowistherandomizedtruncationthatpartitionsthetextintosegmentsofvarying\nlengths.\n\u000fThe second row is the regular truncation that breaks the text into subsequences of the\nsame length. This is what we have been doing in RNN experiments.\n\u000fThe third row is the full backpropagation through time that leads to a computationally\ninfeasible expression.\nUnfortunately, while appealing in theory, randomized truncation does not work much bet-\nter than regular truncation, most likely due to a number of factors. First, the effect of an\nobservation after a number of backpropagation steps into the past is quite sufficient to cap-\nture dependencies in practice. Second, the increased variance counteracts the fact that the\ngradient is more accurate with more steps.", "mimetype": "text/plain", "start_char_idx": 864591, "end_char_idx": 867629, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "97e535ca-abe4-45ee-8c50-37537064d747": {"__data__": {"id_": "97e535ca-abe4-45ee-8c50-37537064d747", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b80d32b0-f760-439b-a708-4a8cbd492117", "node_type": "1", "metadata": {}, "hash": "bcf74eff78bf0928f87c6d56454b7bd91b5f2f5c1bb5cfc94dcdd3d9db4c0279", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7c23e5b6-6f9d-4e53-a34e-845dfefa4ebf", "node_type": "1", "metadata": {}, "hash": "063c34dd51f672cb3d6f8a36390ca0a36a2858f11f1fbcea7edfbc6a87466bf2", "class_name": "RelatedNodeInfo"}}, "text": "\u000fThe second row is the regular truncation that breaks the text into subsequences of the\nsame length. This is what we have been doing in RNN experiments.\n\u000fThe third row is the full backpropagation through time that leads to a computationally\ninfeasible expression.\nUnfortunately, while appealing in theory, randomized truncation does not work much bet-\nter than regular truncation, most likely due to a number of factors. First, the effect of an\nobservation after a number of backpropagation steps into the past is quite sufficient to cap-\nture dependencies in practice. Second, the increased variance counteracts the fact that the\ngradient is more accurate with more steps. Third, we actually wantmodels that have only\nashortrangeofinteractions. Hence, regularlytruncatedbackpropagationthroughtimehas\na slight regularizing effect that can be desirable.\n9.7.2BackpropagationThroughTimein Detail\nAfterdiscussingthegeneralprinciple,let\u2019sdiscussbackpropagationthroughtimeindetail.\nIncontrasttotheanalysisin Section9.7.1 ,inthefollowingwewillshowhowtocomputethe\ngradients of the objective function with respect to all the decomposed model parameters.\nTo keep things simple, we consider an RNN without bias parameters, whose activation\nfunction in the hidden layer uses the identity mapping ( \ud835\udf19\u00b9\ud835\udc65\u00ba=\ud835\udc65). For time step \ud835\udc61, let\nthe single example input and the target be x\ud835\udc612R\ud835\udc51and\ud835\udc66\ud835\udc61, respectively. The hidden state\nh\ud835\udc612R\u210eand the output o\ud835\udc612R\ud835\udc5eare computed as\nh\ud835\udc61=Whxx\ud835\udc61\u00b8Whhh\ud835\udc61\u00001,\no\ud835\udc61=Wqhh\ud835\udc61,(9.7.9)\n366 Recurrent Neural Networks\nwhere Whx2R\u210e\u0002\ud835\udc51,Whh2R\u210e\u0002\u210e, andWqh2R\ud835\udc5e\u0002\u210eare the weight parameters. Denote\nby\ud835\udc59\u00b9o\ud835\udc61,\ud835\udc66\ud835\udc61\u00bathe loss at time step \ud835\udc61. Our objective function, the loss over \ud835\udc47time steps from\nthe beginning of the sequence is thus\n\ud835\udc3f=1\n\ud835\udc47\ud835\udc47\u00d5\n\ud835\udc61=1\ud835\udc59\u00b9o\ud835\udc61,\ud835\udc66\ud835\udc61\u00ba. (9.7.10)\nIn order to visualize the dependencies among model variables and parameters during com-\nputation of the RNN, we can draw a computational graph for the model, as shown in Fig.\n9.7.2. For example, the computation of the hidden states of time step 3, h3, depends on\nthe model parameters WhxandWhh, the hidden state of the previous time step h2, and the\ninput of the current time step x3.\ntFig. 9.7.2 Computational graph showing dependencies for an RNN model with three time steps.\nBoxes represent variables (not shaded) or parameters (shaded) and circles represent\noperators.\nAs just mentioned, the model parameters in Fig. 9.7.2 areWhx,Whh, andWqh. Gen-\nerally, training this model requires gradient computation with respect to these parameters\n\ud835\udf15\ud835\udc3f\u009d\ud835\udf15Whx,\ud835\udf15\ud835\udc3f\u009d\ud835\udf15Whh,and\ud835\udf15\ud835\udc3f\u009d\ud835\udf15Wqh. Accordingtothedependenciesin Fig.9.7.2 ,wecan\ntraverse in the opposite direction of the arrows to calculate and store the gradients in turn.\nTo flexibly express the multiplication of matrices, vectors, and scalars of different shapes\nin the chain rule, we continue to use the prod operator as described in Section 5.3 .\nFirst of all, differentiating the objective function with respect to the model output at any\ntime step\ud835\udc61is fairly straightforward:\n\ud835\udf15\ud835\udc3f\n\ud835\udf15o\ud835\udc61=\ud835\udf15\ud835\udc59\u00b9o\ud835\udc61,\ud835\udc66\ud835\udc61\u00ba\n\ud835\udc47\u0001\ud835\udf15o\ud835\udc612R\ud835\udc5e. (9.7.11)\nNow we can calculate the gradient of the objective with respect to the parameter Wqhin\nthe output layer: \ud835\udf15\ud835\udc3f\u009d\ud835\udf15Wqh2R\ud835\udc5e\u0002\u210e. Based on Fig. 9.7.2 , the objective \ud835\udc3fdepends on Wqh\nviao1,...,o\ud835\udc47.", "mimetype": "text/plain", "start_char_idx": 866956, "end_char_idx": 870134, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7c23e5b6-6f9d-4e53-a34e-845dfefa4ebf": {"__data__": {"id_": "7c23e5b6-6f9d-4e53-a34e-845dfefa4ebf", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "97e535ca-abe4-45ee-8c50-37537064d747", "node_type": "1", "metadata": {}, "hash": "ff6bc2fcd0d04830b040f4372d3783bd03d8d54bcf7b1ea30c24fa9d1f4cc19b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "55b3bece-979b-473a-bb1c-8e98d34e75d1", "node_type": "1", "metadata": {}, "hash": "bc402af6d35ca26110ea636d54f4c9d1c0afc3b3f276e9cb33d7018d8d9495a8", "class_name": "RelatedNodeInfo"}}, "text": "First of all, differentiating the objective function with respect to the model output at any\ntime step\ud835\udc61is fairly straightforward:\n\ud835\udf15\ud835\udc3f\n\ud835\udf15o\ud835\udc61=\ud835\udf15\ud835\udc59\u00b9o\ud835\udc61,\ud835\udc66\ud835\udc61\u00ba\n\ud835\udc47\u0001\ud835\udf15o\ud835\udc612R\ud835\udc5e. (9.7.11)\nNow we can calculate the gradient of the objective with respect to the parameter Wqhin\nthe output layer: \ud835\udf15\ud835\udc3f\u009d\ud835\udf15Wqh2R\ud835\udc5e\u0002\u210e. Based on Fig. 9.7.2 , the objective \ud835\udc3fdepends on Wqh\nviao1,...,o\ud835\udc47. Using the chain rule yields\n\ud835\udf15\ud835\udc3f\n\ud835\udf15Wqh=\ud835\udc47\u00d5\n\ud835\udc61=1prod\u0012\ud835\udf15\ud835\udc3f\n\ud835\udf15o\ud835\udc61,\ud835\udf15o\ud835\udc61\n\ud835\udf15Wqh\u0013\n=\ud835\udc47\u00d5\n\ud835\udc61=1\ud835\udf15\ud835\udc3f\n\ud835\udf15o\ud835\udc61h>\n\ud835\udc61, (9.7.12)\nwhere\ud835\udf15\ud835\udc3f\u009d\ud835\udf15o\ud835\udc61is given by (9.7.11 ).\nNext, as shown in Fig. 9.7.2 , at the final time step \ud835\udc47, the objective function \ud835\udc3fdepends on\nthe hidden state h\ud835\udc47only via o\ud835\udc47. Therefore, we can easily find the gradient \ud835\udf15\ud835\udc3f\u009d\ud835\udf15h\ud835\udc472R\u210e\n367 Backpropagation Through Time\nusing the chain rule:\n\ud835\udf15\ud835\udc3f\n\ud835\udf15h\ud835\udc47=prod\u0012\ud835\udf15\ud835\udc3f\n\ud835\udf15o\ud835\udc47,\ud835\udf15o\ud835\udc47\n\ud835\udf15h\ud835\udc47\u0013\n=W>\nqh\ud835\udf15\ud835\udc3f\n\ud835\udf15o\ud835\udc47. (9.7.13)\nIt gets trickier for any time step \ud835\udc61 < \ud835\udc47, where the objective function \ud835\udc3fdepends on h\ud835\udc61via\nh\ud835\udc61\u00b81ando\ud835\udc61. According to the chain rule, the gradient of the hidden state \ud835\udf15\ud835\udc3f\u009d\ud835\udf15h\ud835\udc612R\u210eat\nany time step \ud835\udc61 <\ud835\udc47can be recurrently computed as:\n\ud835\udf15\ud835\udc3f\n\ud835\udf15h\ud835\udc61=prod\u0012\ud835\udf15\ud835\udc3f\n\ud835\udf15h\ud835\udc61\u00b81,\ud835\udf15h\ud835\udc61\u00b81\n\ud835\udf15h\ud835\udc61\u0013\n\u00b8prod\u0012\ud835\udf15\ud835\udc3f\n\ud835\udf15o\ud835\udc61,\ud835\udf15o\ud835\udc61\n\ud835\udf15h\ud835\udc61\u0013\n=W>\nhh\ud835\udf15\ud835\udc3f\n\ud835\udf15h\ud835\udc61\u00b81\u00b8W>\nqh\ud835\udf15\ud835\udc3f\n\ud835\udf15o\ud835\udc61.(9.7.14)\nForanalysis,expandingtherecurrentcomputationforanytimestep 1\u0014\ud835\udc61\u0014\ud835\udc47gives\n\ud835\udf15\ud835\udc3f\n\ud835\udf15h\ud835\udc61=\ud835\udc47\u00d5\n\ud835\udc56=\ud835\udc61\u0000W>\nhh\u0001\ud835\udc47\u0000\ud835\udc56W>\nqh\ud835\udf15\ud835\udc3f\n\ud835\udf15o\ud835\udc47\u00b8\ud835\udc61\u0000\ud835\udc56. (9.7.15)\nWe can see from (9.7.15 )that this simple linear example already exhibits some key prob-\nlems of long sequence models: it involves potentially very large powers of W>\nhh. In it,\neigenvalues smaller than 1 vanish and eigenvalues larger than 1 diverge. This is numer-\nically unstable, which manifests itself in the form of vanishing and exploding gradients.\nOnewaytoaddressthisistotruncatethetimestepsatacomputationallyconvenientsizeas\ndiscussedin Section9.7.1 . Inpractice,thistruncationcanalsobeeffectedbydetachingthe\ngradient after a given number of time steps. Later on, we will see how more sophisticated\nsequence models such as long short-term memory can alleviate this further.\nFinally,Fig. 9.7.2 shows that the objective function \ud835\udc3fdepends on model parameters Whx\nandWhhin the hidden layer via hidden states h1,...,h\ud835\udc47.", "mimetype": "text/plain", "start_char_idx": 869784, "end_char_idx": 871800, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "55b3bece-979b-473a-bb1c-8e98d34e75d1": {"__data__": {"id_": "55b3bece-979b-473a-bb1c-8e98d34e75d1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7c23e5b6-6f9d-4e53-a34e-845dfefa4ebf", "node_type": "1", "metadata": {}, "hash": "063c34dd51f672cb3d6f8a36390ca0a36a2858f11f1fbcea7edfbc6a87466bf2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b7545fc3-3e76-48f1-84b3-64aa28f53585", "node_type": "1", "metadata": {}, "hash": "09f69980d34f7c2b7385c912bcdbc344027a92982193049a06483910850d2aa6", "class_name": "RelatedNodeInfo"}}, "text": "In it,\neigenvalues smaller than 1 vanish and eigenvalues larger than 1 diverge. This is numer-\nically unstable, which manifests itself in the form of vanishing and exploding gradients.\nOnewaytoaddressthisistotruncatethetimestepsatacomputationallyconvenientsizeas\ndiscussedin Section9.7.1 . Inpractice,thistruncationcanalsobeeffectedbydetachingthe\ngradient after a given number of time steps. Later on, we will see how more sophisticated\nsequence models such as long short-term memory can alleviate this further.\nFinally,Fig. 9.7.2 shows that the objective function \ud835\udc3fdepends on model parameters Whx\nandWhhin the hidden layer via hidden states h1,...,h\ud835\udc47. To compute gradients with\nrespect to such parameters \ud835\udf15\ud835\udc3f\u009d\ud835\udf15Whx2R\u210e\u0002\ud835\udc51and\ud835\udf15\ud835\udc3f\u009d\ud835\udf15Whh2R\u210e\u0002\u210e, we apply the chain\nrule giving\n\ud835\udf15\ud835\udc3f\n\ud835\udf15Whx=\ud835\udc47\u00d5\n\ud835\udc61=1prod\u0012\ud835\udf15\ud835\udc3f\n\ud835\udf15h\ud835\udc61,\ud835\udf15h\ud835\udc61\n\ud835\udf15Whx\u0013\n=\ud835\udc47\u00d5\n\ud835\udc61=1\ud835\udf15\ud835\udc3f\n\ud835\udf15h\ud835\udc61x>\n\ud835\udc61,\n\ud835\udf15\ud835\udc3f\n\ud835\udf15Whh=\ud835\udc47\u00d5\n\ud835\udc61=1prod\u0012\ud835\udf15\ud835\udc3f\n\ud835\udf15h\ud835\udc61,\ud835\udf15h\ud835\udc61\n\ud835\udf15Whh\u0013\n=\ud835\udc47\u00d5\n\ud835\udc61=1\ud835\udf15\ud835\udc3f\n\ud835\udf15h\ud835\udc61h>\n\ud835\udc61\u00001,(9.7.16)\nwhere\ud835\udf15\ud835\udc3f\u009d\ud835\udf15h\ud835\udc61which is recurrently computed by (9.7.13 )and(9.7.14 )is the key quantity\nthat affects the numerical stability.\nSince backpropagation through time is the application of backpropagation in RNNs, as we\nhave explained in Section 5.3 , training RNNs alternates forward propagation with back-\npropagation through time. Moreover, backpropagation through time computes and stores\nthe above gradients in turn. Specifically, stored intermediate values are reused to avoid du-\nplicate calculations, such as storing \ud835\udf15\ud835\udc3f\u009d\ud835\udf15h\ud835\udc61to be used in computation of both \ud835\udf15\ud835\udc3f\u009d\ud835\udf15Whx\nand\ud835\udf15\ud835\udc3f\u009d\ud835\udf15Whh.\n9.7.3Summary\n368 Recurrent Neural Networks\n144Backpropagation through time is merely an application of backpropagation to sequence\nmodels with a hidden state. Truncation, such as regular or randomized, is needed for com-\nputational convenience and numerical stability. High powers of matrices can lead to diver-\ngent or vanishing eigenvalues. This manifests itself in the form of exploding or vanishing\ngradients. For efficient computation, intermediate values are cached during backpropaga-\ntion through time.\n9.7.4Exercises\n1.Assume that we have a symmetric matrix M2R\ud835\udc5b\u0002\ud835\udc5bwith eigenvalues \ud835\udf06\ud835\udc56whose cor-\nresponding eigenvectors are v\ud835\udc56(\ud835\udc56=1,...,\ud835\udc5b). Without loss of generality, assume that\nthey are ordered in the order j\ud835\udf06\ud835\udc56j\u0015j\ud835\udf06\ud835\udc56\u00b81j.\n1.Show that M\ud835\udc58has eigenvalues \ud835\udf06\ud835\udc58\n\ud835\udc56.\n2.Provethatforarandomvector x2R\ud835\udc5b,withhighprobability M\ud835\udc58xwillbeverymuch\naligned with the eigenvector v1ofM. Formalize this statement.\n3.What does the above result mean for gradients in RNNs?\n2.Besides gradient clipping, can you think of any other methods to cope with gradient\nexplosion in recurrent neural networks?\nDiscussions144.\n10 Modern Recurrent Neural Networks\nThe previous chapter introduced the key ideas behind recurrent neural networks (RNNs).\nHowever, just as with convolutional neural networks, there has been a tremendous amount\nof innovation in RNN architectures, culminating in several complex designs that have\nproven successful in practice. In particular, the most popular designs feature mechanisms\nfor mitigating the notorious numerical instability faced by RNNs, as typified by vanishing\nand exploding gradients.", "mimetype": "text/plain", "start_char_idx": 871148, "end_char_idx": 874208, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b7545fc3-3e76-48f1-84b3-64aa28f53585": {"__data__": {"id_": "b7545fc3-3e76-48f1-84b3-64aa28f53585", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "55b3bece-979b-473a-bb1c-8e98d34e75d1", "node_type": "1", "metadata": {}, "hash": "bc402af6d35ca26110ea636d54f4c9d1c0afc3b3f276e9cb33d7018d8d9495a8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "128677bd-f083-4b1f-b67f-8ccd7cb6b47f", "node_type": "1", "metadata": {}, "hash": "a359d2db6b85da93889aff5b5c955a7d67d25942afb00f9f1905f502d50a0450", "class_name": "RelatedNodeInfo"}}, "text": "2.Provethatforarandomvector x2R\ud835\udc5b,withhighprobability M\ud835\udc58xwillbeverymuch\naligned with the eigenvector v1ofM. Formalize this statement.\n3.What does the above result mean for gradients in RNNs?\n2.Besides gradient clipping, can you think of any other methods to cope with gradient\nexplosion in recurrent neural networks?\nDiscussions144.\n10 Modern Recurrent Neural Networks\nThe previous chapter introduced the key ideas behind recurrent neural networks (RNNs).\nHowever, just as with convolutional neural networks, there has been a tremendous amount\nof innovation in RNN architectures, culminating in several complex designs that have\nproven successful in practice. In particular, the most popular designs feature mechanisms\nfor mitigating the notorious numerical instability faced by RNNs, as typified by vanishing\nand exploding gradients. Recall that in Chapter 9 we dealt with exploding gradients by ap-\nplying a blunt gradient clipping heuristic. Despite the efficacy of this hack, it leaves open\nthe problem of vanishing gradients.\nInthischapter,weintroducethekeyideasbehindthemostsuccessfulRNNarchitecturesfor\nsequences, which stem from two papers. The first, Long Short-Term Memory (Hochreiter\nand Schmidhuber, 1997 ), introduces the memory cell , a unit of computation that replaces\ntraditional nodes in the hidden layer of a network. With these memory cells, networks\nare able to overcome difficulties with training encountered by earlier recurrent networks.\nIntuitively, the memory cell avoids the vanishing gradient problem by keeping values in\neach memory cell\u2019s internal state cascading along a recurrent edge with weight 1 across\nmanysuccessivetimesteps. Asetofmultiplicativegateshelpthenetworktodeterminenot\nonly the inputs to allow into the memory state, but when the content of the memory state\nshould influence the model\u2019s output.\nThe second paper, Bidirectional Recurrent Neural Networks (Schuster and Paliwal, 1997 ),\nintroducesanarchitectureinwhichinformationfromboththefuture(subsequenttimesteps)\nand the past (preceding time steps) are used to determine the output at any point in the se-\nquence. This is in contrast to previous networks, in which only past input can affect the\noutput. Bidirectional RNNs have become a mainstay for sequence labeling tasks in natu-\nral language processing, among a myriad of other tasks. Fortunately, the two innovations\narenotmutuallyexclusive,andhavebeensuccessfullycombinedforphonemeclassification\n(GravesandSchmidhuber,2005 )andhandwritingrecognition( Gravesetal.,2008).\nThefirstsectionsinthischapterwillexplaintheLSTMarchitecture,alighter-weightversion\ncalled the gated recurrent unit (GRU), the key ideas behind bidirectional RNNs and a brief\nexplanation of how RNN layers are stacked together to form deep RNNs. Subsequently,\nwe will explore the application of RNNs in sequence-to-sequence tasks, introducing ma-\nchine translation along with key ideas such as encoder\u2013decoder architectures and beam\nsearch.\n369\n370 Modern Recurrent Neural Networks\n10.1Long Short-TermMemory (LSTM)\nShortlyafterthefirstElman-styleRNNsweretrainedusingbackpropagation( Elman,1990 ),\nthe problems of learning long-term dependencies (owing to vanishing and exploding gra-\ndients) became salient, with Bengio and Hochreiter discussing the problem ( Bengioetal.,\n1994,Hochreiter et al., 2001). Hochreiter had articulated this problem as early as 1991 in\nhisMaster\u2019sthesis,althoughtheresultswerenotwidelyknownbecausethethesiswaswrit-\nteninGerman. Whilegradientclippinghelpswithexplodinggradients,handlingvanishing\ngradientsappearstorequireamoreelaboratesolution. Oneofthefirstandmostsuccessful\ntechniquesforaddressingvanishinggradientscameintheformofthelongshort-termmem-\nory (LSTM) model due to Hochreiter and Schmidhuber ( 1997). LSTMs resemble standard\nrecurrent neural networks but here each ordinary recurrent node is replaced by a memory\ncell. Each memory cell contains an internal state , i.e., a node with a self-connected re-\ncurrent edge of fixed weight 1, ensuring that the gradient can pass across many time steps\nwithout vanishing or exploding.\nThe term \u201clong short-term memory\u201d comes from the following intuition. Simple recurrent\nneuralnetworkshave long-termmemory intheformofweights. Theweightschangeslowly\nduring training, encoding general knowledge about the data.", "mimetype": "text/plain", "start_char_idx": 873375, "end_char_idx": 877689, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "128677bd-f083-4b1f-b67f-8ccd7cb6b47f": {"__data__": {"id_": "128677bd-f083-4b1f-b67f-8ccd7cb6b47f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b7545fc3-3e76-48f1-84b3-64aa28f53585", "node_type": "1", "metadata": {}, "hash": "09f69980d34f7c2b7385c912bcdbc344027a92982193049a06483910850d2aa6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d0c39b82-8fc8-4067-96bd-c346e07c792d", "node_type": "1", "metadata": {}, "hash": "be1318f073953b6e019196dfff1aa43c397d9fd0496608ceebdac4fb73a6c4a6", "class_name": "RelatedNodeInfo"}}, "text": "Oneofthefirstandmostsuccessful\ntechniquesforaddressingvanishinggradientscameintheformofthelongshort-termmem-\nory (LSTM) model due to Hochreiter and Schmidhuber ( 1997). LSTMs resemble standard\nrecurrent neural networks but here each ordinary recurrent node is replaced by a memory\ncell. Each memory cell contains an internal state , i.e., a node with a self-connected re-\ncurrent edge of fixed weight 1, ensuring that the gradient can pass across many time steps\nwithout vanishing or exploding.\nThe term \u201clong short-term memory\u201d comes from the following intuition. Simple recurrent\nneuralnetworkshave long-termmemory intheformofweights. Theweightschangeslowly\nduring training, encoding general knowledge about the data. They also have short-term\nmemory in the form of ephemeral activations, which pass from each node to successive\nnodes. The LSTM model introduces an intermediate type of storage via the memory cell.\nA memory cell is a composite unit, built from simpler nodes in a specific connectivity\npattern, with the novel inclusion of multiplicative nodes.\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n10.1.1Gated Memory Cell\nEach memory cell is equipped with an internal state and a number of multiplicative gates\nthat determine whether (i) a given input should impact the internal state (the input gate ),\n(ii) the internal state should be flushed to 0(theforgetgate ), and (iii) the internal state of a\ngiven neuron should be allowed to impact the cell\u2019s output (the outputgate).\nGatedHidden State\nThe key distinction between vanilla RNNs and LSTMs is that the latter support gating of\nthe hidden state. This means that we have dedicated mechanisms for when a hidden state\nshould be updated and also for when it should be reset. These mechanisms are learned and\ntheyaddresstheconcernslistedabove. Forinstance,ifthefirsttokenisofgreatimportance\nwe will learn not to update the hidden state after the first observation. Likewise, we will\nlearn to skip irrelevant temporary observations. Last, we will learn to reset the latent state\nwhenever needed. We discuss this in detail below.\n371 Long Short-Term Memory (LSTM)\nInputGate, ForgetGate, and Output Gate\nThe data feeding into the LSTM gates are the input at the current time step and the hidden\nstate of the previous time step, as illustrated in Fig. 10.1.1 . Three fully connected layers\nwithsigmoidactivationfunctionscomputethevaluesoftheinput, forget, andoutputgates.\nAs a result of the sigmoid activation, all values of the three gates are in the range of \u00b90,1\u00ba.\nAdditionally, we require an input node , typically computed with a tanhactivation func-\ntion. Intuitively, the input gate determines how much of the input node\u2019s value should be\naddedtothecurrentmemorycellinternalstate. The forgetgate determineswhethertokeep\nthe current value of the memory or flush it. And the output gate determines whether the\nmemory cell should influence the output at the current time step.\ntFig. 10.1.1 Computing the input gate, the forget gate, and the output gate in an LSTM model.\nMathematically, suppose that there are \u210ehidden units, the batch size is \ud835\udc5b, and the number\nof inputs is\ud835\udc51. Thus, the input is X\ud835\udc612R\ud835\udc5b\u0002\ud835\udc51and the hidden state of the previous time step\nisH\ud835\udc61\u000012R\ud835\udc5b\u0002\u210e. Correspondingly, the gates at time step \ud835\udc61are defined as follows: the input\ngate is I\ud835\udc612R\ud835\udc5b\u0002\u210e, the forget gate is F\ud835\udc612R\ud835\udc5b\u0002\u210e, and the output gate is O\ud835\udc612R\ud835\udc5b\u0002\u210e. They\nare calculated as follows:\nI\ud835\udc61=\ud835\udf0e\u00b9X\ud835\udc61Wxi\u00b8H\ud835\udc61\u00001Whi\u00b8bi\u00ba,\nF\ud835\udc61=\ud835\udf0e\u00b9X\ud835\udc61Wxf\u00b8H\ud835\udc61\u00001Whf\u00b8bf\u00ba,\nO\ud835\udc61=\ud835\udf0e\u00b9X\ud835\udc61Wxo\u00b8H\ud835\udc61\u00001Who\u00b8bo\u00ba,(10.1.1)\nwhere Wxi,Wxf,Wxo2R\ud835\udc51\u0002\u210eandWhi,Whf,Who2R\u210e\u0002\u210eare weight parameters and\nbi,bf,bo2R1\u0002\u210eare bias parameters.", "mimetype": "text/plain", "start_char_idx": 876970, "end_char_idx": 880575, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d0c39b82-8fc8-4067-96bd-c346e07c792d": {"__data__": {"id_": "d0c39b82-8fc8-4067-96bd-c346e07c792d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "128677bd-f083-4b1f-b67f-8ccd7cb6b47f", "node_type": "1", "metadata": {}, "hash": "a359d2db6b85da93889aff5b5c955a7d67d25942afb00f9f1905f502d50a0450", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e680a6ac-ac0c-4d92-8183-62fd3ebb181a", "node_type": "1", "metadata": {}, "hash": "3c2ca6385c1c77901702988280060e52978cdcc1781318d756160291510cb73e", "class_name": "RelatedNodeInfo"}}, "text": "They\nare calculated as follows:\nI\ud835\udc61=\ud835\udf0e\u00b9X\ud835\udc61Wxi\u00b8H\ud835\udc61\u00001Whi\u00b8bi\u00ba,\nF\ud835\udc61=\ud835\udf0e\u00b9X\ud835\udc61Wxf\u00b8H\ud835\udc61\u00001Whf\u00b8bf\u00ba,\nO\ud835\udc61=\ud835\udf0e\u00b9X\ud835\udc61Wxo\u00b8H\ud835\udc61\u00001Who\u00b8bo\u00ba,(10.1.1)\nwhere Wxi,Wxf,Wxo2R\ud835\udc51\u0002\u210eandWhi,Whf,Who2R\u210e\u0002\u210eare weight parameters and\nbi,bf,bo2R1\u0002\u210eare bias parameters. Note that broadcasting (see Section 2.1.4 ) is trig-\ngered during the summation. We use sigmoid functions (as introduced in Section 5.1 ) to\nmap the input values to the interval \u00b90,1\u00ba.\nInputNode\nNextwedesignthememorycell. Sincewehavenotspecifiedtheactionofthevariousgates\nyet, we first introduce the input node \u02dcC\ud835\udc612R\ud835\udc5b\u0002\u210e. Its computation is similar to that of the\nthree gates described above, but uses a tanhfunction with a value range for \u00b9\u00001,1\u00baas the\nactivation function. This leads to the following equation at time step \ud835\udc61:\n\u02dcC\ud835\udc61=tanh\u00b9X\ud835\udc61Wxc\u00b8H\ud835\udc61\u00001Whc\u00b8bc\u00ba, (10.1.2)\n372 Modern Recurrent Neural Networks\nwhere Wxc2R\ud835\udc51\u0002\u210eandWhc2R\u210e\u0002\u210eare weight parameters and bc2R1\u0002\u210eis a bias\nparameter.\nA quick illustration of the input node is shown in Fig. 10.1.2 .\ntFig. 10.1.2 Computing the input node in an LSTM model.\nMemory Cell Internal State\nIn LSTMs, the input gate I\ud835\udc61governs how much we take new data into account via \u02dcC\ud835\udc61and\ntheforgetgate F\ud835\udc61addresseshowmuchoftheoldcellinternalstate C\ud835\udc61\u000012R\ud835\udc5b\u0002\u210eweretain.\nUsing the Hadamard (elementwise) product operator \fwe arrive at the following update\nequation:\nC\ud835\udc61=F\ud835\udc61\fC\ud835\udc61\u00001\u00b8I\ud835\udc61\f\u02dcC\ud835\udc61. (10.1.3)\nIf the forget gate is always 1 and the input gate is always 0, the memory cell internal state\nC\ud835\udc61\u00001will remain constant forever, passing unchanged to each subsequent time step. How-\never, input gates and forget gates give the model the flexibility of being able to learn when\nto keep this value unchanged and when to perturb it in response to subsequent inputs. In\npractice, this design alleviates the vanishing gradient problem, resulting in models that are\nmuch easier to train, especially when facing datasets with long sequence lengths.\nWe thus arrive at the flow diagram in Fig. 10.1.3 .\nHidden State\nLast,weneedtodefinehowtocomputetheoutputofthememorycell, i.e., thehiddenstate\nH\ud835\udc612R\ud835\udc5b\u0002\u210e, as seen by other layers. This is where the output gate comes into play. In\nLSTMs, we first apply tanhto the memory cell internal state and then apply another point-\nwise multiplication, this time with the output gate. This ensures that the values of H\ud835\udc61are\nalways in the interval \u00b9\u00001,1\u00ba:\nH\ud835\udc61=O\ud835\udc61\ftanh\u00b9C\ud835\udc61\u00ba. (10.1.4)\nWhenever the output gate is close to 1, we allow the memory cell internal state to impact\nthesubsequentlayersuninhibited, whereasforoutputgatevaluescloseto0, wepreventthe\n373 Long Short-Term Memory (LSTM)\ntFig. 10.1.3 Computing the memory cell internal state in an LSTM model.\ncurrent memory from impacting other layers of the network at the current time step. Note\nthat a memory cell can accrue information across many time steps without impacting the\nrest of the network (as long as the output gate takes values close to 0), and then suddenly\nimpact the network at a subsequent time step as soon as the output gate flips from values\ncloseto0tovaluescloseto1. Fig.10.1.4 hasagraphicalillustrationofthedataflow.\ntFig.", "mimetype": "text/plain", "start_char_idx": 880363, "end_char_idx": 883409, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e680a6ac-ac0c-4d92-8183-62fd3ebb181a": {"__data__": {"id_": "e680a6ac-ac0c-4d92-8183-62fd3ebb181a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d0c39b82-8fc8-4067-96bd-c346e07c792d", "node_type": "1", "metadata": {}, "hash": "be1318f073953b6e019196dfff1aa43c397d9fd0496608ceebdac4fb73a6c4a6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e4628853-0607-4cc2-a7b6-d8d06d02edcb", "node_type": "1", "metadata": {}, "hash": "634e0356b13dd0af8406fdf35dc60850feaea4909516ab88a9e344eaee53e669", "class_name": "RelatedNodeInfo"}}, "text": "(10.1.4)\nWhenever the output gate is close to 1, we allow the memory cell internal state to impact\nthesubsequentlayersuninhibited, whereasforoutputgatevaluescloseto0, wepreventthe\n373 Long Short-Term Memory (LSTM)\ntFig. 10.1.3 Computing the memory cell internal state in an LSTM model.\ncurrent memory from impacting other layers of the network at the current time step. Note\nthat a memory cell can accrue information across many time steps without impacting the\nrest of the network (as long as the output gate takes values close to 0), and then suddenly\nimpact the network at a subsequent time step as soon as the output gate flips from values\ncloseto0tovaluescloseto1. Fig.10.1.4 hasagraphicalillustrationofthedataflow.\ntFig. 10.1.4 Computing the hidden state in an LSTM model.\n10.1.2Implementation fromScratch\nNow let\u2019s implement an LSTM from scratch. As same as the experiments in Section 9.5 ,\nwe first load The TimeMachine dataset.\nInitializingModel Parameters\nNext, we need to define and initialize the model parameters. As previously, the hyperpa-\nrameter num_hiddens dictates the number of hidden units. We initialize weights following\na Gaussian distribution with 0.01 standard deviation, and we set the biases to 0.\nclass LSTMScratch (d2l .Module):\ndef __init__ (self , num_inputs, num_hiddens, sigma =0.01 ):\n(continues on next page)\n374 Modern Recurrent Neural Networks\n(continued from previous page)\nsuper ().__init__ ()\nself .save_hyperparameters()\ninit_weight =lambda *shape: nn .Parameter(torch .randn( *shape) *sigma)\ntriple =lambda : (init_weight(num_inputs, num_hiddens),\ninit_weight(num_hiddens, num_hiddens),\nnn.Parameter(torch .zeros(num_hiddens)))\nself .W_xi, self .W_hi, self .b_i =triple() # Input gate\nself .W_xf, self .W_hf, self .b_f =triple() # Forget gate\nself .W_xo, self .W_ho, self .b_o =triple() # Output gate\nself .W_xc, self .W_hc, self .b_c =triple() # Input node\nTheactualmodelisdefinedasdescribedabove,consistingofthreegatesandaninputnode.\nNote that only the hidden state is passed to the output layer.\n@d2l .add_to_class(LSTMScratch)\ndef forward (self , inputs, H_C =None ):\nifH_C isNone :\n# Initial state with shape: (batch_size, num_hiddens)\nH=torch .zeros((inputs .shape[ 1],self .num_hiddens),\ndevice =inputs .device)\nC=torch .zeros((inputs .shape[ 1],self .num_hiddens),\ndevice =inputs .device)\nelse :\nH, C =H_C\noutputs =[]\nfor Xininputs:\nI=torch .sigmoid(torch .matmul(X, self .W_xi) +\ntorch .matmul(H, self .W_hi) +self .b_i)\nF=torch .sigmoid(torch .matmul(X, self .W_xf) +\ntorch .matmul(H, self .W_hf) +self .b_f)\nO=torch .sigmoid(torch .matmul(X, self .W_xo) +\ntorch .matmul(H, self .W_ho) +self .b_o)\nC_tilde =torch .tanh(torch .matmul(X, self .W_xc) +\ntorch .matmul(H, self .W_hc) +self .b_c)\nC=F*C+I*C_tilde\nH=O*torch .tanh(C)\noutputs .append(H)\nreturn outputs, (H, C)\nTrainingand Prediction\nLet\u2019strainanLSTMmodelbyinstantiatingthe RNNLMScratch classfrom Section9.5 .\ndata =d2l.TimeMachine(batch_size =1024 , num_steps =32)\nlstm =LSTMScratch(num_inputs =len(data .vocab), num_hiddens =32)\nmodel =d2l.RNNLMScratch(lstm, vocab_size =len(data .vocab), lr =4)\ntrainer =d2l.Trainer(max_epochs =50, gradient_clip_val =1, num_gpus =1)\ntrainer .fit(model, data)\n10.1.3ConciseImplementation\n375 Long Short-Term Memory (LSTM)\nUsing high-level APIs, we can directly instantiate an LSTM model. This encapsulates\nall the configuration details that we made explicit above.", "mimetype": "text/plain", "start_char_idx": 882683, "end_char_idx": 886093, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e4628853-0607-4cc2-a7b6-d8d06d02edcb": {"__data__": {"id_": "e4628853-0607-4cc2-a7b6-d8d06d02edcb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e680a6ac-ac0c-4d92-8183-62fd3ebb181a", "node_type": "1", "metadata": {}, "hash": "3c2ca6385c1c77901702988280060e52978cdcc1781318d756160291510cb73e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "97a4a886-b503-4105-9bde-4b58459e7f3c", "node_type": "1", "metadata": {}, "hash": "0e4aefc79b1fc1280d0bd8fec3cae377185497c018daad4c17129b57fd45b1b2", "class_name": "RelatedNodeInfo"}}, "text": "data =d2l.TimeMachine(batch_size =1024 , num_steps =32)\nlstm =LSTMScratch(num_inputs =len(data .vocab), num_hiddens =32)\nmodel =d2l.RNNLMScratch(lstm, vocab_size =len(data .vocab), lr =4)\ntrainer =d2l.Trainer(max_epochs =50, gradient_clip_val =1, num_gpus =1)\ntrainer .fit(model, data)\n10.1.3ConciseImplementation\n375 Long Short-Term Memory (LSTM)\nUsing high-level APIs, we can directly instantiate an LSTM model. This encapsulates\nall the configuration details that we made explicit above. The code is significantly faster\nas it uses compiled operators rather than Python for many details that we spelled out be-\nfore.\nclass LSTM (d2l .RNN):\ndef __init__ (self , num_inputs, num_hiddens):\nd2l.Module .__init__ (self )\nself .save_hyperparameters()\nself .rnn =nn.LSTM(num_inputs, num_hiddens)\ndef forward (self , inputs, H_C =None ):\nreturn self .rnn(inputs, H_C)\nlstm =LSTM(num_inputs =len(data .vocab), num_hiddens =32)\nmodel =d2l.RNNLM(lstm, vocab_size =len(data .vocab), lr =4)\ntrainer .fit(model, data)\nmodel .predict( 'it has ',20, data .vocab, d2l .try_gpu())\n'it has a the time travelly '\nLSTMs are the prototypical latent variable autoregressive model with nontrivial state con-\ntrol. Many variants thereof have been proposed over the years, e.g., multiple layers, resid-\nual connections, different types of regularization. However, training LSTMs and other\n376 Modern Recurrent Neural Networks\n145sequence models (such as GRUs) is quite costly because of the long range dependency of\nthe sequence. Later we will encounter alternative models such as Transformers that can be\nused in some cases.\n10.1.4Summary\nWhileLSTMswerepublishedin1997,theyrosetogreatprominencewithsomevictoriesin\nprediction competitions in the mid-2000s, and became the dominant models for sequence\nlearning from 2011 until the rise of Transformer models, starting in 2017. Even Tran-\nformers owe some of their key ideas to architecture design innovations introduced by the\nLSTM.\nLSTMshavethreetypesofgates: inputgates,forgetgates,andoutputgatesthatcontrolthe\nflow of information. The hidden layer output of LSTM includes the hidden state and the\nmemory cell internal state. Only the hidden state is passed into the output layer while the\nmemory cell internal state remains entirely internal. LSTMs can alleviate vanishing and\nexploding gradients.\n10.1.5Exercises\n1.Adjustthehyperparametersandanalyzetheirinfluenceonrunningtime,perplexity,and\nthe output sequence.\n2.How would you need to change the model to generate proper words rather than just\nsequences of characters?\n3.Compare the computational cost for GRUs, LSTMs, and regular RNNs for a given hid-\nden dimension. Pay special attention to the training and inference cost.\n4.Since the candidate memory cell ensures that the value range is between \u00001and1by\nusing the tanhfunction, why does the hidden state need to use the tanhfunction again\nto ensure that the output value range is between \u00001and1?\n5.Implement an LSTM model for time series prediction rather than character sequence\nprediction.\nDiscussions145.\n10.2GatedRecurrentUnits(GRU)\nAs RNNs and particularly the LSTM architecture ( Section 10.1 ) rapidly gained popularity\nduring the 2010s, a number of researchers began to experiment with simplified architec-\ntures in hopes of retaining the key idea of incorporating an internal state and multiplicative\ngating mechanisms but with the aim of speeding up computation. The gated recurrent unit\n377 Gated Recurrent Units (GRU)\n(GRU) (Choet al., 2014) offered a streamlined version of the LSTM memory cell that of-\nten achieves comparable performance but with the advantage of being faster to compute\n(Chungetal., 2014).\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n10.2.1ResetGate and UpdateGate\nHere, the LSTM\u2019s three gates are replaced by two: the reset gate and theupdate gate . As\nwith LSTMs, these gates are given sigmoid activations, forcing their values to lie in the\ninterval\u00b90,1\u00ba.", "mimetype": "text/plain", "start_char_idx": 885603, "end_char_idx": 889549, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "97a4a886-b503-4105-9bde-4b58459e7f3c": {"__data__": {"id_": "97a4a886-b503-4105-9bde-4b58459e7f3c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e4628853-0607-4cc2-a7b6-d8d06d02edcb", "node_type": "1", "metadata": {}, "hash": "634e0356b13dd0af8406fdf35dc60850feaea4909516ab88a9e344eaee53e669", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "018d7dec-ee8f-41ab-8daf-bf002e87ff10", "node_type": "1", "metadata": {}, "hash": "2df7e78a41eb6aff8618d611c268bce2f3e856365c27a8a2f499a44ce39ff530", "class_name": "RelatedNodeInfo"}}, "text": "The gated recurrent unit\n377 Gated Recurrent Units (GRU)\n(GRU) (Choet al., 2014) offered a streamlined version of the LSTM memory cell that of-\nten achieves comparable performance but with the advantage of being faster to compute\n(Chungetal., 2014).\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n10.2.1ResetGate and UpdateGate\nHere, the LSTM\u2019s three gates are replaced by two: the reset gate and theupdate gate . As\nwith LSTMs, these gates are given sigmoid activations, forcing their values to lie in the\ninterval\u00b90,1\u00ba. Intuitively, the reset gate controls how much of the previous state we might\nstill want to remember. Likewise, an update gate would allow us to control how much of\nthenewstateisjustacopyoftheoldone. Fig.10.2.1 illustratestheinputsforboththereset\nand update gates in a GRU, given the input of the current time step and the hidden state\nof the previous time step. The outputs of the gates are given by two fully connected layers\nwith a sigmoid activation function.\ntFig. 10.2.1 Computing the reset gate and the update gate in a GRU model.\nMathematically, for a given time step \ud835\udc61, suppose that the input is a minibatch X\ud835\udc612R\ud835\udc5b\u0002\ud835\udc51\n(number of examples =\ud835\udc5b; number of inputs =\ud835\udc51) and the hidden state of the previous time\nstep is H\ud835\udc61\u000012R\ud835\udc5b\u0002\u210e(number of hidden units =\u210e). Then the reset gate R\ud835\udc612R\ud835\udc5b\u0002\u210eand\nupdate gate Z\ud835\udc612R\ud835\udc5b\u0002\u210eare computed as follows:\nR\ud835\udc61=\ud835\udf0e\u00b9X\ud835\udc61Wxr\u00b8H\ud835\udc61\u00001Whr\u00b8br\u00ba,\nZ\ud835\udc61=\ud835\udf0e\u00b9X\ud835\udc61Wxz\u00b8H\ud835\udc61\u00001Whz\u00b8bz\u00ba,(10.2.1)\nwhereWxr,Wxz2R\ud835\udc51\u0002\u210eandWhr,Whz2R\u210e\u0002\u210eareweightparametersand br,bz2R1\u0002\u210e\nare bias parameters.\n10.2.2Candidate Hidden State\n378 Modern Recurrent Neural Networks\nNext,weintegratetheresetgate R\ud835\udc61withtheregularupdatingmechanismin (9.4.5 ),leading\nto the following candidatehidden state \u02dcH\ud835\udc612R\ud835\udc5b\u0002\u210eat time step\ud835\udc61:\n\u02dcH\ud835\udc61=tanh\u00b9X\ud835\udc61Wxh\u00b8\u00b9R\ud835\udc61\fH\ud835\udc61\u00001\u00baWhh\u00b8bh\u00ba, (10.2.2)\nwhereWxh2R\ud835\udc51\u0002\u210eandWhh2R\u210e\u0002\u210eareweightparameters, bh2R1\u0002\u210eisthebias,andthe\nsymbol\fis the Hadamard (elementwise) product operator. Here we use a tanh activation\nfunction.\nThe result is a candidate , since we still need to incorporate the action of the update gate.\nComparing with (9.4.5 ), the influence of the previous states can now be reduced with the\nelementwise multiplication of R\ud835\udc61andH\ud835\udc61\u00001in(10.2.2 ). Whenever the entries in the reset\ngateR\ud835\udc61are close to 1, we recover a vanilla RNN such as that in (9.4.5 ). For all entries of\nthe reset gate R\ud835\udc61that are close to 0, the candidate hidden state is the result of an MLP with\nX\ud835\udc61as input. Any pre-existing hidden state is thus resetto defaults.\nFig. 10.2.2 illustrates the computational flow after applying the reset gate.\ntFig. 10.2.2 Computing the candidate hidden state in a GRU model.\n10.2.3HiddenState\nFinally, we need to incorporate the effect of the update gate Z\ud835\udc61. This determines the extent\nto which the new hidden state H\ud835\udc612R\ud835\udc5b\u0002\u210ematches the old state H\ud835\udc61\u00001compared with how\nmuch it resembles the new candidate state \u02dcH\ud835\udc61. The update gate Z\ud835\udc61can be used for this\npurpose, simply by taking elementwise convex combinations of H\ud835\udc61\u00001and \u02dcH\ud835\udc61.", "mimetype": "text/plain", "start_char_idx": 889013, "end_char_idx": 891960, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "018d7dec-ee8f-41ab-8daf-bf002e87ff10": {"__data__": {"id_": "018d7dec-ee8f-41ab-8daf-bf002e87ff10", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "97a4a886-b503-4105-9bde-4b58459e7f3c", "node_type": "1", "metadata": {}, "hash": "0e4aefc79b1fc1280d0bd8fec3cae377185497c018daad4c17129b57fd45b1b2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9448b4c0-7343-4771-b7e4-22c02c6f0782", "node_type": "1", "metadata": {}, "hash": "34313f126f077fef8a66940cd1c2e0797c177fbd80079e84b7456b17cf4eaada", "class_name": "RelatedNodeInfo"}}, "text": "Any pre-existing hidden state is thus resetto defaults.\nFig. 10.2.2 illustrates the computational flow after applying the reset gate.\ntFig. 10.2.2 Computing the candidate hidden state in a GRU model.\n10.2.3HiddenState\nFinally, we need to incorporate the effect of the update gate Z\ud835\udc61. This determines the extent\nto which the new hidden state H\ud835\udc612R\ud835\udc5b\u0002\u210ematches the old state H\ud835\udc61\u00001compared with how\nmuch it resembles the new candidate state \u02dcH\ud835\udc61. The update gate Z\ud835\udc61can be used for this\npurpose, simply by taking elementwise convex combinations of H\ud835\udc61\u00001and \u02dcH\ud835\udc61. This leads\nto the final update equation for the GRU:\nH\ud835\udc61=Z\ud835\udc61\fH\ud835\udc61\u00001\u00b8\u00b91\u0000Z\ud835\udc61\u00ba\f \u02dcH\ud835\udc61. (10.2.3)\nWhenever the update gate Z\ud835\udc61is close to 1, we simply retain the old state. In this case\nthe information from X\ud835\udc61is ignored, effectively skipping time step \ud835\udc61in the dependency\nchain. By contrast, whenever Z\ud835\udc61is close to 0, the new latent state H\ud835\udc61approaches the\ncandidate latent state \u02dcH\ud835\udc61.Fig. 10.2.3 shows the computational flow after the update gate is\nin action.\nIn summary, GRUs have the following two distinguishing features:\n379 Gated Recurrent Units (GRU)\ntFig. 10.2.3 Computing the hidden state in a GRU model.\n\u000fReset gates help capture short-term dependencies in sequences.\n\u000fUpdate gates help capture long-term dependencies in sequences.\n10.2.4Implementation fromScratch\nTo gain a better understanding of the GRU model, let\u2019s implement it from scratch.\nInitializingModel Parameters\nThe first step is to initialize the model parameters. We draw the weights from a Gaussian\ndistribution with standard deviation to be sigmaand set the bias to 0. The hyperparameter\nnum_hiddens defines the number of hidden units. We instantiate all weights and biases\nrelating to the update gate, the reset gate, and the candidate hidden state.\nclass GRUScratch (d2l .Module):\ndef __init__ (self , num_inputs, num_hiddens, sigma =0.01 ):\nsuper ().__init__ ()\nself .save_hyperparameters()\ninit_weight =lambda *shape: nn .Parameter(torch .randn( *shape) *sigma)\ntriple =lambda : (init_weight(num_inputs, num_hiddens),\ninit_weight(num_hiddens, num_hiddens),\nnn.Parameter(torch .zeros(num_hiddens)))\nself .W_xz, self .W_hz, self .b_z =triple() # Update gate\nself .W_xr, self .W_hr, self .b_r =triple() # Reset gate\nself .W_xh, self .W_hh, self .b_h =triple() # Candidate hidden state\nDefiningthe Model\nNow we are ready to define the GRU forward computation. Its structure is the same as that\nof the basic RNN cell, except that the update equations are more complex.\n@d2l .add_to_class(GRUScratch)\ndef forward (self , inputs, H =None ):\n(continues on next page)\n380 Modern Recurrent Neural Networks\n(continued from previous page)\nifHisNone :\n# Initial state with shape: (batch_size, num_hiddens)\nH=torch .zeros((inputs .shape[ 1],self .num_hiddens),\ndevice =inputs .device)\noutputs =[]\nfor Xininputs:\nZ=torch .sigmoid(torch .matmul(X, self .W_xz) +\ntorch .matmul(H, self .W_hz) +self .b_z)\nR=torch .sigmoid(torch .matmul(X, self .W_xr) +\ntorch .matmul(H, self .W_hr) +self .b_r)\nH_tilde =torch .tanh(torch .matmul(X, self .W_xh) +\ntorch .matmul(R *H,self .W_hh) +self .b_h)\nH=Z*H+(1-Z)*H_tilde\noutputs .append(H)\nreturn outputs, H\nTraining\nTrainingalanguagemodelon TheTimeMachine datasetworksinexactlythesamemanner\nas inSection 9.5 .", "mimetype": "text/plain", "start_char_idx": 891409, "end_char_idx": 894658, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9448b4c0-7343-4771-b7e4-22c02c6f0782": {"__data__": {"id_": "9448b4c0-7343-4771-b7e4-22c02c6f0782", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "018d7dec-ee8f-41ab-8daf-bf002e87ff10", "node_type": "1", "metadata": {}, "hash": "2df7e78a41eb6aff8618d611c268bce2f3e856365c27a8a2f499a44ce39ff530", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e446ffeb-8f34-4495-8c3d-5c79f5d764aa", "node_type": "1", "metadata": {}, "hash": "2a22cd08e11e19879169106a3896b25ac2eceac78fbac3f233c02d1ea5abd0ee", "class_name": "RelatedNodeInfo"}}, "text": "data =d2l.TimeMachine(batch_size =1024 , num_steps =32)\ngru =GRUScratch(num_inputs =len(data .vocab), num_hiddens =32)\nmodel =d2l.RNNLMScratch(gru, vocab_size =len(data .vocab), lr =4)\ntrainer =d2l.Trainer(max_epochs =50, gradient_clip_val =1, num_gpus =1)\ntrainer .fit(model, data)\n10.2.5ConciseImplementation\nIn high-level APIs, we can directly instantiate a GRU model. This encapsulates all the\nconfiguration detail that we made explicit above.\nclass GRU(d2l .RNN):\ndef __init__ (self , num_inputs, num_hiddens):\nd2l.Module .__init__ (self )\nself .save_hyperparameters()\nself .rnn =nn.GRU(num_inputs, num_hiddens)\n381 Gated Recurrent Units (GRU)\n146ThecodeissignificantlyfasterintrainingasitusescompiledoperatorsratherthanPython.\ngru =GRU(num_inputs =len(data .vocab), num_hiddens =32)\nmodel =d2l.RNNLM(gru, vocab_size =len(data .vocab), lr =4)\ntrainer .fit(model, data)\nAfter training, we print out the perplexity on the training set and the predicted sequence\nfollowing the provided prefix.\nmodel .predict( 'it has ',20, data .vocab, d2l .try_gpu())\n'it has so it and the time '\n10.2.6Summary\nCompared with LSTMs, GRUs achieve similar performance but tend to be lighter com-\nputationally. Generally, compared with simple RNNs, gated RNNS, just like LSTMs and\nGRUs,canbettercapturedependenciesforsequenceswithlargetimestepdistances. GRUs\ncontainbasicRNNsastheirextremecasewhenevertheresetgateisswitchedon. Theycan\nalso skip subsequences by turning on the update gate.\n10.2.7Exercises\n1.Assume that we only want to use the input at time step \ud835\udc610to predict the output at time\nstep\ud835\udc61 >\ud835\udc610. What are the best values for the reset and update gates for each time step?\n2.Adjustthehyperparametersandanalyzetheirinfluenceonrunningtime,perplexity,and\nthe output sequence.\n3.Compare runtime, perplexity, and the output strings for rnn.RNN andrnn.GRU imple-\nmentations with each other.\n4.Whathappensifyouimplementonlyparts ofaGRU,e.g., withonlyareset gateoronly\nan update gate?\nDiscussions146.\n382 Modern Recurrent Neural Networks\n10.3Deep RecurrentNeuralNetworks\nUpuntilnow,wehavefocusedondefiningnetworksconsistingofasequenceinput,asingle\nhidden RNN layer, and an output layer. Despite having just one hidden layer between the\ninputatanytimestepandthecorrespondingoutput,thereisasenseinwhichthesenetworks\nare deep. Inputs from the first time step can influence the outputs at the final time step\n\ud835\udc47(often 100s or 1000s of steps later). These inputs pass through \ud835\udc47applications of the\nrecurrent layer before reaching the final output. However, we often also wish to retain the\nability to express complex relationships between the inputs at a given time step and the\noutputs at that same time step. Thus we often construct RNNs that are deep not only in the\ntimedirectionbutalsointheinput-to-outputdirection. Thisispreciselythenotionofdepth\nthat we have already encountered in our development of MLPs and deep CNNs.\nThe standard method for building this sort of deep RNN is strikingly simple: we stack\nthe RNNs on top of each other. Given a sequence of length \ud835\udc47, the first RNN produces a\nsequence of outputs, also of length \ud835\udc47. These, in turn, constitute the inputs to the next RNN\nlayer. Inthisshortsection,weillustratethisdesignpatternandpresentasimpleexamplefor\nhowtocodeupsuchstackedRNNs. Below,in Fig.10.3.1 ,weillustrateadeepRNNwith \ud835\udc3f\nhidden layers. Each hidden state operates on a sequential input and produces a sequential\noutput. Moreover, any RNN cell (white box in Fig. 10.3.1 ) at each time step depends on\nboth the same layer\u2019s value at the previous time step and the previous layer\u2019s value at the\nsame time step.\ntFig.", "mimetype": "text/plain", "start_char_idx": 894659, "end_char_idx": 898278, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e446ffeb-8f34-4495-8c3d-5c79f5d764aa": {"__data__": {"id_": "e446ffeb-8f34-4495-8c3d-5c79f5d764aa", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9448b4c0-7343-4771-b7e4-22c02c6f0782", "node_type": "1", "metadata": {}, "hash": "34313f126f077fef8a66940cd1c2e0797c177fbd80079e84b7456b17cf4eaada", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ae06a1bc-738c-4ffa-998c-dd8b71e85f96", "node_type": "1", "metadata": {}, "hash": "568dee9760ff96b1d51fba39d71d328b0bf1ba9fdafbcc974ac8a2aa21a77e26", "class_name": "RelatedNodeInfo"}}, "text": "Given a sequence of length \ud835\udc47, the first RNN produces a\nsequence of outputs, also of length \ud835\udc47. These, in turn, constitute the inputs to the next RNN\nlayer. Inthisshortsection,weillustratethisdesignpatternandpresentasimpleexamplefor\nhowtocodeupsuchstackedRNNs. Below,in Fig.10.3.1 ,weillustrateadeepRNNwith \ud835\udc3f\nhidden layers. Each hidden state operates on a sequential input and produces a sequential\noutput. Moreover, any RNN cell (white box in Fig. 10.3.1 ) at each time step depends on\nboth the same layer\u2019s value at the previous time step and the previous layer\u2019s value at the\nsame time step.\ntFig. 10.3.1 Architecture of a deep RNN.\nFormally, suppose that we have a minibatch input X\ud835\udc612R\ud835\udc5b\u0002\ud835\udc51(number of examples =\ud835\udc5b;\nnumber of inputs in each example =\ud835\udc51) at time step \ud835\udc61. At the same time step, let the hidden\nstate of the\ud835\udc59thhidden layer ( \ud835\udc59=1,...,\ud835\udc3f) beH\u00b9\ud835\udc59\u00ba\n\ud835\udc612R\ud835\udc5b\u0002\u210e(number of hidden units =\u210e)\nand the output layer variable be O\ud835\udc612R\ud835\udc5b\u0002\ud835\udc5e(number of outputs: \ud835\udc5e). Setting H\u00b90\u00ba\n\ud835\udc61=X\ud835\udc61,\nthe hidden state of the \ud835\udc59thhidden layer that uses the activation function \ud835\udf19\ud835\udc59is calculated as\nfollows:\nH\u00b9\ud835\udc59\u00ba\n\ud835\udc61=\ud835\udf19\ud835\udc59\u00b9H\u00b9\ud835\udc59\u00001\u00ba\n\ud835\udc61W\u00b9\ud835\udc59\u00ba\nxh\u00b8H\u00b9\ud835\udc59\u00ba\n\ud835\udc61\u00001W\u00b9\ud835\udc59\u00ba\nhh\u00b8b\u00b9\ud835\udc59\u00ba\nh\u00ba, (10.3.1)\n383 Deep Recurrent Neural Networks\nwheretheweights W\u00b9\ud835\udc59\u00ba\nxh2R\u210e\u0002\u210eandW\u00b9\ud835\udc59\u00ba\nhh2R\u210e\u0002\u210e, togetherwiththebias b\u00b9\ud835\udc59\u00ba\nh2R1\u0002\u210e, are\nthe model parameters of the \ud835\udc59thhidden layer.\nAt the end, the calculation of the output layer is only based on the hidden state of the final\n\ud835\udc3fthhidden layer:\nO\ud835\udc61=H\u00b9\ud835\udc3f\u00ba\n\ud835\udc61Whq\u00b8bq, (10.3.2)\nwhere the weight Whq2R\u210e\u0002\ud835\udc5eand the bias bq2R1\u0002\ud835\udc5eare the model parameters of the\noutput layer.\nJustaswithMLPs, thenumberofhiddenlayers \ud835\udc3fandthenumberofhiddenunits \u210earehy-\nperparametersthatwecantune. CommonRNNlayerwidths( \u210e)areintherange\u00b964,2056\u00ba,\nand common depths ( \ud835\udc3f) are in the range\u00b91,8\u00ba. In addition, we can easily get a deep-gated\nRNN by replacing the hidden state computation in (10.3.1 )with that from an LSTM or a\nGRU.\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n10.3.1Implementation fromScratch\nTo implement a multilayer RNN from scratch, we can treat each layer as an RNNScratch\ninstance with its own learnable parameters.\nclass StackedRNNScratch (d2l .Module):\ndef __init__ (self , num_inputs, num_hiddens, num_layers, sigma =0.01 ):\nsuper ().__init__ ()\nself .save_hyperparameters()\nself .rnns =nn.Sequential( *[d2l .RNNScratch(\nnum_inputs ifi==0else num_hiddens, num_hiddens, sigma)\nfor iinrange (num_layers)])\nThemultilayerforwardcomputationsimplyperformsforwardcomputationlayerbylayer.\n@d2l .add_to_class(StackedRNNScratch)\ndef forward (self , inputs, Hs =None ):\noutputs =inputs\nifHsisNone : Hs =[None ]*self .num_layers\nfor iinrange (self .num_layers):\noutputs, Hs[i] =self .rnns[i](outputs, Hs[i])\noutputs =torch .stack(outputs, 0)\nreturn outputs, Hs\nAs an example, we train a deep GRU model on The Time Machine dataset (same as in\nSection 9.5 ).", "mimetype": "text/plain", "start_char_idx": 897680, "end_char_idx": 900490, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ae06a1bc-738c-4ffa-998c-dd8b71e85f96": {"__data__": {"id_": "ae06a1bc-738c-4ffa-998c-dd8b71e85f96", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e446ffeb-8f34-4495-8c3d-5c79f5d764aa", "node_type": "1", "metadata": {}, "hash": "2a22cd08e11e19879169106a3896b25ac2eceac78fbac3f233c02d1ea5abd0ee", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3e1dd7e7-6f88-4aa5-8cc8-8d25543ff446", "node_type": "1", "metadata": {}, "hash": "d4d419fb5774d2776a3e6ec816726367f6a91d430cf2581b0b71bd347c27c364", "class_name": "RelatedNodeInfo"}}, "text": "@d2l .add_to_class(StackedRNNScratch)\ndef forward (self , inputs, Hs =None ):\noutputs =inputs\nifHsisNone : Hs =[None ]*self .num_layers\nfor iinrange (self .num_layers):\noutputs, Hs[i] =self .rnns[i](outputs, Hs[i])\noutputs =torch .stack(outputs, 0)\nreturn outputs, Hs\nAs an example, we train a deep GRU model on The Time Machine dataset (same as in\nSection 9.5 ). To keep things simple we set the number of layers to 2.\n384 Modern Recurrent Neural Networks\ndata =d2l.TimeMachine(batch_size =1024 , num_steps =32)\nrnn_block =StackedRNNScratch(num_inputs =len(data .vocab),\nnum_hiddens =32, num_layers =2)\nmodel =d2l.RNNLMScratch(rnn_block, vocab_size =len(data .vocab), lr =2)\ntrainer =d2l.Trainer(max_epochs =100, gradient_clip_val =1, num_gpus =1)\ntrainer .fit(model, data)\n10.3.2ConciseImplementation\nFortunatelymanyof thelogisticaldetails requiredtoimplement multiplelayersofanRNN\nare readily available in high-level APIs. Our concise implementation will use such built-\nin functionalities. The code generalizes the one we used previously in Section 10.2 , let-\nting us specify the number of layers explicitly rather than picking the default of only one\nlayer.\nclass GRU(d2l .RNN): #@save\n\"\"\"The multilayer GRU model.\"\"\"\ndef __init__ (self , num_inputs, num_hiddens, num_layers, dropout =0):\nd2l.Module .__init__ (self )\nself .save_hyperparameters()\nself .rnn =nn.GRU(num_inputs, num_hiddens, num_layers,\ndropout =dropout)\nThe architectural decisions such as choosing hyperparameters are very similar to those of\nSection 10.2 . We pick the same number of inputs and outputs as we have distinct tokens,\ni.e.,vocab_size . Thenumberofhiddenunitsisstill32. Theonlydifferenceisthatwenow\nselect a nontrivial number of hidden layers by specifying the value of num_layers .\ngru =GRU(num_inputs =len(data .vocab), num_hiddens =32, num_layers =2)\nmodel =d2l.RNNLM(gru, vocab_size =len(data .vocab), lr =2)\ntrainer .fit(model, data)\nmodel .predict( 'it has ',20, data .vocab, d2l .try_gpu())\n'it has for and the time th '\n385 Bidirectional Recurrent Neural Networks\n14710.3.3Summary\nIn deep RNNs, the hidden state information is passed to the next time step of the current\nlayer and the current time step of the next layer. There exist many different flavors of\ndeep RNNs, such as LSTMs, GRUs, or vanilla RNNs. Conveniently, these models are\nall available as parts of the high-level APIs of deep learning frameworks. Initialization of\nmodels requires care. Overall, deep RNNs require considerable amount of work (such as\nlearning rate and clipping) to ensure proper convergence.\n10.3.4Exercises\n1.Replace the GRU by an LSTM and compare the accuracy and training speed.\n2.Increase the training data to include multiple books. How low can you go on the per-\nplexity scale?\n3.Would you want to combine sources of different authors when modeling text? Why is\nthis a good idea? What could go wrong?\nDiscussions147.\n10.4BidirectionalRecurrentNeuralNetworks\nSofar,ourworkingexampleofasequencelearningtaskhasbeenlanguagemodeling,where\nwe aim to predict the next token given all previous tokens in a sequence. In this scenario,\nwewishonlytoconditionupontheleftwardcontext,andthustheunidirectionalchainingof\nastandardRNNseemsappropriate. However,therearemanyothersequencelearningtasks\ncontexts where it is perfectly fine to condition the prediction at every time step on both the\nleftward and the rightward context. Consider, for example, part of speech detection. Why\nshouldn\u2019t we take the context in both directions into account when assessing the part of\nspeech associated with a given word?\nAnother common task\u2014often useful as a pretraining exercise prior to fine-tuning a model\non an actual task of interest\u2014is to mask out random tokens in a text document and then\n386 Modern Recurrent Neural Networks\nto train a sequence model to predict the values of the missing tokens.", "mimetype": "text/plain", "start_char_idx": 900127, "end_char_idx": 903986, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3e1dd7e7-6f88-4aa5-8cc8-8d25543ff446": {"__data__": {"id_": "3e1dd7e7-6f88-4aa5-8cc8-8d25543ff446", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ae06a1bc-738c-4ffa-998c-dd8b71e85f96", "node_type": "1", "metadata": {}, "hash": "568dee9760ff96b1d51fba39d71d328b0bf1ba9fdafbcc974ac8a2aa21a77e26", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1dd3ecb4-96a5-428f-8ae9-30a3b56acadc", "node_type": "1", "metadata": {}, "hash": "732973bb8df868027fb186645bdab3f9431ba3a2211592048141bfefbcdca492", "class_name": "RelatedNodeInfo"}}, "text": "In this scenario,\nwewishonlytoconditionupontheleftwardcontext,andthustheunidirectionalchainingof\nastandardRNNseemsappropriate. However,therearemanyothersequencelearningtasks\ncontexts where it is perfectly fine to condition the prediction at every time step on both the\nleftward and the rightward context. Consider, for example, part of speech detection. Why\nshouldn\u2019t we take the context in both directions into account when assessing the part of\nspeech associated with a given word?\nAnother common task\u2014often useful as a pretraining exercise prior to fine-tuning a model\non an actual task of interest\u2014is to mask out random tokens in a text document and then\n386 Modern Recurrent Neural Networks\nto train a sequence model to predict the values of the missing tokens. Note that depend-\ning on what comes after the blank, the likely value of the missing token changes dramati-\ncally:\n\u000fI am ___.\n\u000fI am ___hungry.\n\u000fI am ___hungry, and I can eat half a pig.\nIn the first sentence \u201chappy\u201d seems to be a likely candidate. The words \u201cnot\u201d and \u201cvery\u201d\nseem plausible in the second sentence, but \u201cnot\u201d seems incompatible with the third sen-\ntences.\nFortunately, a simple technique transforms any unidirectional RNN into a bidirectional\nRNN (Schuster and Paliwal, 1997 ). We simply implement two unidirectional RNN layers\nchained together in opposite directions and acting on the same input ( Fig. 10.4.1 ). For\nthe first RNN layer, the first input is x1and the last input is x\ud835\udc47, but for the second RNN\nlayer,thefirstinputis x\ud835\udc47andthelastinputis x1. Toproducetheoutputofthisbidirectional\nRNNlayer,wesimplyconcatenatetogetherthecorrespondingoutputsofthetwounderlying\nunidirectional RNN layers.\ntFig. 10.4.1 Architecture of a bidirectional RNN.\nFormally for any time step \ud835\udc61, we consider a minibatch input X\ud835\udc612R\ud835\udc5b\u0002\ud835\udc51(number of exam-\nples=\ud835\udc5b;numberofinputsineachexample =\ud835\udc51)andletthehiddenlayeractivationfunction\nbe\ud835\udf19. Inthebidirectionalarchitecture, theforwardandbackwardhiddenstatesforthistime\nstep are\u0000 !H\ud835\udc612R\ud835\udc5b\u0002\u210eand \u0000H\ud835\udc612R\ud835\udc5b\u0002\u210e, respectively, where \u210eis the number of hidden units.\nThe forward and backward hidden state updates are as follows:\n\u0000 !H\ud835\udc61=\ud835\udf19\u00b9X\ud835\udc61W\u00b9\ud835\udc53\u00ba\nxh\u00b8\u0000 !H\ud835\udc61\u00001W\u00b9\ud835\udc53\u00ba\nhh\u00b8b\u00b9\ud835\udc53\u00ba\nh\u00ba,\n \u0000H\ud835\udc61=\ud835\udf19\u00b9X\ud835\udc61W\u00b9\ud835\udc4f\u00ba\nxh\u00b8 \u0000H\ud835\udc61\u00b81W\u00b9\ud835\udc4f\u00ba\nhh\u00b8b\u00b9\ud835\udc4f\u00ba\nh\u00ba,(10.4.1)\nwhere the weights W\u00b9\ud835\udc53\u00ba\nxh2R\ud835\udc51\u0002\u210e,W\u00b9\ud835\udc53\u00ba\nhh2R\u210e\u0002\u210e,W\u00b9\ud835\udc4f\u00ba\nxh2R\ud835\udc51\u0002\u210e,andW\u00b9\ud835\udc4f\u00ba\nhh2R\u210e\u0002\u210e, and\nthe biases b\u00b9\ud835\udc53\u00ba\nh2R1\u0002\u210eandb\u00b9\ud835\udc4f\u00ba\nh2R1\u0002\u210eare all the model parameters.\nNext, we concatenate the forward and backward hidden states\u0000 !H\ud835\udc61and \u0000H\ud835\udc61to obtain the\nhiddenstate H\ud835\udc612R\ud835\udc5b\u00022\u210eforfeedingintotheoutputlayer. IndeepbidirectionalRNNswith\nmultiplehiddenlayers,suchinformationispassedonas inputtothenextbidirectionallayer.\n387 Bidirectional Recurrent Neural Networks\nLast, the output layer computes the output O\ud835\udc612R\ud835\udc5b\u0002\ud835\udc5e(number of outputs =\ud835\udc5e):\nO\ud835\udc61=H\ud835\udc61Whq\u00b8bq. (10.4.2)\nHere, the weight matrix Whq2R2\u210e\u0002\ud835\udc5eand the bias bq2R1\u0002\ud835\udc5eare the model parameters\nof the output layer. While technically, the two directions can have different numbers of\nhidden units, this design choice is seldom made in practice. We now demonstrate a simple\nimplementation of a bidirectional RNN.", "mimetype": "text/plain", "start_char_idx": 903220, "end_char_idx": 906253, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1dd3ecb4-96a5-428f-8ae9-30a3b56acadc": {"__data__": {"id_": "1dd3ecb4-96a5-428f-8ae9-30a3b56acadc", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3e1dd7e7-6f88-4aa5-8cc8-8d25543ff446", "node_type": "1", "metadata": {}, "hash": "d4d419fb5774d2776a3e6ec816726367f6a91d430cf2581b0b71bd347c27c364", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "24fe6c16-fac4-47ba-8236-4ff611ae0481", "node_type": "1", "metadata": {}, "hash": "63a2c5ff0a2e923a59c882720342831258fc015a98147cfe61b0fa2f33063080", "class_name": "RelatedNodeInfo"}}, "text": "IndeepbidirectionalRNNswith\nmultiplehiddenlayers,suchinformationispassedonas inputtothenextbidirectionallayer.\n387 Bidirectional Recurrent Neural Networks\nLast, the output layer computes the output O\ud835\udc612R\ud835\udc5b\u0002\ud835\udc5e(number of outputs =\ud835\udc5e):\nO\ud835\udc61=H\ud835\udc61Whq\u00b8bq. (10.4.2)\nHere, the weight matrix Whq2R2\u210e\u0002\ud835\udc5eand the bias bq2R1\u0002\ud835\udc5eare the model parameters\nof the output layer. While technically, the two directions can have different numbers of\nhidden units, this design choice is seldom made in practice. We now demonstrate a simple\nimplementation of a bidirectional RNN.\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n10.4.1Implementation fromScratch\nToimplementabidirectionalRNNfromscratch,wecanincludetwounidirectional RNNScratch\ninstances with separate learnable parameters.\nclass BiRNNScratch (d2l .Module):\ndef __init__ (self , num_inputs, num_hiddens, sigma =0.01 ):\nsuper ().__init__ ()\nself .save_hyperparameters()\nself .f_rnn =d2l.RNNScratch(num_inputs, num_hiddens, sigma)\nself .b_rnn =d2l.RNNScratch(num_inputs, num_hiddens, sigma)\nself .num_hiddens *=2# The output dimension will be doubled\nStates of forward and backward RNNs are updated separately, while outputs of these two\nRNNs are concatenated.\n@d2l .add_to_class(BiRNNScratch)\ndef forward (self , inputs, Hs =None ):\nf_H, b_H =HsifHsisnot None else (None ,None )\nf_outputs, f_H =self .f_rnn(inputs, f_H)\nb_outputs, b_H =self .b_rnn( reversed (inputs), b_H)\noutputs =[torch .cat((f, b), -1)for f, b inzip(\nf_outputs, reversed (b_outputs))]\nreturn outputs, (f_H, b_H)\n10.4.2ConciseImplementation\nUsingthehigh-levelAPIs,wecanimplementbidirectionalRNNsmoreconcisely. Herewe\ntake a GRU model as an example.\nclass BiGRU (d2l .RNN):\ndef __init__ (self , num_inputs, num_hiddens):\nd2l.Module .__init__ (self )\nself .save_hyperparameters()\nself .rnn =nn.GRU(num_inputs, num_hiddens, bidirectional =True )\nself .num_hiddens *=2\n388 Modern Recurrent Neural Networks\n14810.4.3Summary\nIn bidirectional RNNs, the hidden state for each time step is simultaneously determined\nby the data prior to and after the current time step. Bidirectional RNNs are mostly use-\nful for sequence encoding and the estimation of observations given bidirectional context.\nBidirectional RNNs are very costly to train due to long gradient chains.\n10.4.4Exercises\n1.If the different directions use a different number of hidden units, how will the shape of\nH\ud835\udc61change?\n2.Design a bidirectional RNN with multiple hidden layers.\n3.Polysemy is common in natural languages. For example, the word \u201cbank\u201d has different\nmeanings in contexts \u201ci went to the bank to deposit cash\u201d and \u201ci went to the bank to sit\ndown\u201d. How can we design a neural network model such that given a context sequence\nand a word, a vector representation of the word in the correct context will be returned?\nWhat type of neural architectures is preferred for handling polysemy?\nDiscussions148.\n10.5MachineTranslationand the Dataset\nAmong the major breakthroughs that prompted widespread interest in modern RNNs was\na major advance in the applied field of statistical machine translation . Here, the model is\npresented with a sentence in one language and must predict the corresponding sentence in\nanother. Note that here the sentences may be of different lengths, and that corresponding\nwords in the two sentences may not occur in the same order, owing to differences in the\ntwo language\u2019s grammatical structure.\nMany problems have this flavor of mapping between two such \u201cunaligned\u201d sequences.\nExamples include mapping from dialog prompts to replies or from questions to answers.\nBroadly, such problems are called sequence-to-sequence (seq2seq) problems and they are\nour focus for both the remainder of this chapter and much of Chapter 11 .\nIn this section, we introduce the machine translation problem and an example dataset that\nwe will use in the subsequent examples.", "mimetype": "text/plain", "start_char_idx": 905708, "end_char_idx": 909565, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "24fe6c16-fac4-47ba-8236-4ff611ae0481": {"__data__": {"id_": "24fe6c16-fac4-47ba-8236-4ff611ae0481", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1dd3ecb4-96a5-428f-8ae9-30a3b56acadc", "node_type": "1", "metadata": {}, "hash": "732973bb8df868027fb186645bdab3f9431ba3a2211592048141bfefbcdca492", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7a81335a-d499-4696-a820-7044d8daadc1", "node_type": "1", "metadata": {}, "hash": "2a7dfbf20438a32d7ca23b342e7c37869475141321f4a6ba3c1196427c9ba224", "class_name": "RelatedNodeInfo"}}, "text": "Discussions148.\n10.5MachineTranslationand the Dataset\nAmong the major breakthroughs that prompted widespread interest in modern RNNs was\na major advance in the applied field of statistical machine translation . Here, the model is\npresented with a sentence in one language and must predict the corresponding sentence in\nanother. Note that here the sentences may be of different lengths, and that corresponding\nwords in the two sentences may not occur in the same order, owing to differences in the\ntwo language\u2019s grammatical structure.\nMany problems have this flavor of mapping between two such \u201cunaligned\u201d sequences.\nExamples include mapping from dialog prompts to replies or from questions to answers.\nBroadly, such problems are called sequence-to-sequence (seq2seq) problems and they are\nour focus for both the remainder of this chapter and much of Chapter 11 .\nIn this section, we introduce the machine translation problem and an example dataset that\nwe will use in the subsequent examples. For decades, statistical formulations of translation\nbetween languages had been popular ( Brownetal., 1990,Brownetal., 1988), even before\nresearchers got neural network approaches working (methods were often lumped together\nunder the term neuralmachinetranslation ).\nFirst we will need some new code to process our data. Unlike the language modeling that\nwesawin Section9.3 ,hereeachexampleconsistsoftwoseparatetextsequences,oneinthe\nsource language and another (the translation) in the target language. The following code\nsnippets will show how to load the preprocessed data into minibatches for training.\n389 Machine Translation and the Dataset\n149import os\nimport torch\nfrom d2l import torch asd2l\n10.5.1Downloadingand Preprocessingthe Dataset\nTo begin, we download an English\u2013French dataset that consists of bilingual sentence pairs\nfrom the Tatoeba Project149. Each line in the dataset is a tab-delimited pair consisting\nof an English text sequence (the source) and the translated French text sequence (the tar-\nget). Note that each text sequence can be just one sentence, or a paragraph of multiple\nsentences.\nclass MTFraEng (d2l .DataModule): #@save\n\"\"\"The English-French dataset.\"\"\"\ndef _download (self ):\nd2l.extract(d2l .download(\nd2l.DATA_URL +'fra-eng.zip ',self .root,\n'94646ad1522d915e7b0f9296181140edcf86a4f5 '))\nwith open (self .root +'/fra-eng/fra.txt ', encoding ='utf-8 ')asf:\nreturn f.read()\ndata =MTFraEng()\nraw_text =data ._download()\nprint (raw_text[: 75])\nDownloading ../data/fra-eng.zip from http://d2l-data.s3-accelerate.amazonaws.\n\u21a9!com/fra-eng.zip...\nGo. Va !\nHi. Salut !\nRun! Cours !\nRun! Courez !\nWho? Qui ?\nWow! \u00c7a alors !\nAfterdownloadingthedataset,weproceedwithseveralpreprocessingstepsfortherawtext\ndata. For instance, we replace non-breaking space with space, convert uppercase letters to\nlowercase ones, and insert space between words and punctuation marks.\n@d2l .add_to_class(MTFraEng) #@save\ndef _preprocess (self , text):\n# Replace non-breaking space with space\ntext =text .replace( '\\u202f ','').replace( '\\xa0 ','')\n# Insert space between words and punctuation marks\nno_space =lambda char, prev_char: char in',.!? 'and prev_char !=''\nout =[''+char ifi>0and no_space(char, text[i -1])else char\nfor i, char inenumerate (text .lower())]\nreturn ''.join(out)\n390 Modern Recurrent Neural Networks\ntext =data ._preprocess(raw_text)\nprint (text[: 80])\ngo . va !\nhi . salut !\nrun ! cours !\nrun ! courez !\nwho ? qui ?\nwow ! \u00e7a alors !\n10.5.2Tokenization\nUnlike the character-level tokenization in Section 9.3 , for machine translation we prefer\nword-level tokenization here (today\u2019s state-of-the-art models use more complex tokeniza-\ntion techniques). The following _tokenize method tokenizes the first max_examples text\nsequence pairs, where each token is either a word or a punctuation mark. We append the\nspecial \u201c<eos>\u201d token to the end of every sequence to indicate the end of the sequence.\nWhen a model is predicting by generating a sequence token after token, the generation of\nthe\u201c<eos>\u201dtokencansuggestthattheoutputsequenceiscomplete.", "mimetype": "text/plain", "start_char_idx": 908572, "end_char_idx": 912639, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7a81335a-d499-4696-a820-7044d8daadc1": {"__data__": {"id_": "7a81335a-d499-4696-a820-7044d8daadc1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "24fe6c16-fac4-47ba-8236-4ff611ae0481", "node_type": "1", "metadata": {}, "hash": "63a2c5ff0a2e923a59c882720342831258fc015a98147cfe61b0fa2f33063080", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8fa5f463-3d75-4b45-999a-fc7c91a750ca", "node_type": "1", "metadata": {}, "hash": "ec64e1982ef18190cc76aff5e3ae3cb394bedc1b3999def717f6276d20327fff", "class_name": "RelatedNodeInfo"}}, "text": "va !\nhi . salut !\nrun ! cours !\nrun ! courez !\nwho ? qui ?\nwow ! \u00e7a alors !\n10.5.2Tokenization\nUnlike the character-level tokenization in Section 9.3 , for machine translation we prefer\nword-level tokenization here (today\u2019s state-of-the-art models use more complex tokeniza-\ntion techniques). The following _tokenize method tokenizes the first max_examples text\nsequence pairs, where each token is either a word or a punctuation mark. We append the\nspecial \u201c<eos>\u201d token to the end of every sequence to indicate the end of the sequence.\nWhen a model is predicting by generating a sequence token after token, the generation of\nthe\u201c<eos>\u201dtokencansuggestthattheoutputsequenceiscomplete. Intheend,themethod\nbelow returns two lists of token lists: srcandtgt. Specifically, src[i]is a list of tokens\nfrom the\ud835\udc56thtext sequence in the source language (English here) and tgt[i]is that in the\ntarget language (French here).\n@d2l .add_to_class(MTFraEng) #@save\ndef _tokenize (self , text, max_examples =None ):\nsrc, tgt =[], []\nfor i, line inenumerate (text .split( '\\n')):\nifmax_examples and i>max_examples: break\nparts =line .split( '\\t')\niflen(parts) ==2:\n# Skip empty tokens\nsrc.append([t for tinf'{parts[ 0]}<eos> '.split( '')ift])\ntgt.append([t for tinf'{parts[ 1]}<eos> '.split( '')ift])\nreturn src, tgt\nsrc, tgt =data ._tokenize(text)\nsrc[: 6], tgt[: 6]\n([['go','.','<eos> '],\n['hi','.','<eos> '],\n['run','!','<eos> '],\n['run','!','<eos> '],\n['who','?','<eos> '],\n['wow','!','<eos> ']],\n[['va','!','<eos> '],\n['salut ','!','<eos> '],\n['cours ','!','<eos> '],\n['courez ','!','<eos> '],\n(continues on next page)\n391 Machine Translation and the Dataset\n(continued from previous page)\n['qui','?','<eos> '],\n['\u00e7a','alors ','!','<eos> ']])\nLet\u2019s plot the histogram of the number of tokens per text sequence. In this simple English\u2013\nFrench dataset, most of the text sequences have fewer than 20 tokens.\n#@save\ndef show_list_len_pair_hist (legend, xlabel, ylabel, xlist, ylist):\n\"\"\"Plot the histogram for list length pairs.\"\"\"\nd2l.set_figsize()\n_, _, patches =d2l.plt.hist(\n[[len(l) for linxlist], [ len(l) for linylist]])\nd2l.plt.xlabel(xlabel)\nd2l.plt.ylabel(ylabel)\nfor patch inpatches[ 1].patches:\npatch .set_hatch( '/')\nd2l.plt.legend(legend)\nshow_list_len_pair_hist([ 'source ','target '],'# tokens per sequence ',\n'count ', src, tgt);\n10.5.3LoadingSequencesof FixedLength\nRecallthat in languagemodeling eachexamplesequence, either a segment of one sentence\nor a span over multiple sentences, had a fixed length. This was specified by the num_steps\n(number of time steps or tokens) argument from Section 9.3 . In machine translation, each\nexample is a pair of source and target text sequences, where the two text sequences may\nhave different lengths.\nForcomputationalefficiency,wecanstillprocessaminibatchoftextsequencesatonetime\nbytruncation andpadding. Supposethateverysequenceinthesameminibatchshouldhave\nthe same length num_steps . If a text sequence has fewer than num_steps tokens, we will\nkeep appending the special \u201c<pad>\u201d token to its end until its length reaches num_steps .\nOtherwise, wewilltruncatethetextsequencebyonlytakingitsfirst num_steps tokensand\ndiscarding the remaining. In this way, every text sequence will have the same length to be\nloaded in minibatches of the same shape. Furthermore, we also record length of the source\n392 Modern Recurrent Neural Networks\nsequence excluding padding tokens. This information will be needed by some models that\nwe will cover later.\nSince the machine translation dataset consists of pairs of languages, we can build two vo-\ncabulariesforboththesourcelanguageandthetargetlanguageseparately.", "mimetype": "text/plain", "start_char_idx": 911956, "end_char_idx": 915598, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8fa5f463-3d75-4b45-999a-fc7c91a750ca": {"__data__": {"id_": "8fa5f463-3d75-4b45-999a-fc7c91a750ca", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7a81335a-d499-4696-a820-7044d8daadc1", "node_type": "1", "metadata": {}, "hash": "2a7dfbf20438a32d7ca23b342e7c37869475141321f4a6ba3c1196427c9ba224", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "522bacc8-4e94-4665-9b88-5e902bc8bc16", "node_type": "1", "metadata": {}, "hash": "6f8325f6adb169c576341ea04894dac70256a763d1e5a7daac75d9f20cb5b5a4", "class_name": "RelatedNodeInfo"}}, "text": "Supposethateverysequenceinthesameminibatchshouldhave\nthe same length num_steps . If a text sequence has fewer than num_steps tokens, we will\nkeep appending the special \u201c<pad>\u201d token to its end until its length reaches num_steps .\nOtherwise, wewilltruncatethetextsequencebyonlytakingitsfirst num_steps tokensand\ndiscarding the remaining. In this way, every text sequence will have the same length to be\nloaded in minibatches of the same shape. Furthermore, we also record length of the source\n392 Modern Recurrent Neural Networks\nsequence excluding padding tokens. This information will be needed by some models that\nwe will cover later.\nSince the machine translation dataset consists of pairs of languages, we can build two vo-\ncabulariesforboththesourcelanguageandthetargetlanguageseparately. Withword-level\ntokenization, the vocabulary size will be significantly larger than that using character-level\ntokenization. To alleviate this, here we treat infrequent tokens that appear less than twice\nas the same unknown (\u201c<unk>\u201d) token. As we will explain later ( Fig. 10.7.1 ), when train-\ning with target sequences, the decoder output (label tokens) can be the same decoder input\n(targettokens),shiftedbyonetoken; andthespecialbeginning-of-sequence\u201c<bos>\u201dtoken\nwill be used as the first input token for predicting the target sequence ( Fig. 10.7.3 ).\n@d2l .add_to_class(MTFraEng) #@save\ndef __init__ (self , batch_size, num_steps =9, num_train =512, num_val =128):\nsuper (MTFraEng, self ).__init__ ()\nself .save_hyperparameters()\nself .arrays, self .src_vocab, self .tgt_vocab =self ._build_arrays(\nself ._download())\n@d2l .add_to_class(MTFraEng) #@save\ndef _build_arrays (self , raw_text, src_vocab =None , tgt_vocab =None ):\ndef _build_array (sentences, vocab, is_tgt =False ):\npad_or_trim =lambda seq, t: (\nseq[:t] iflen(seq) >telse seq +['<pad> ']*(t-len(seq)))\nsentences =[pad_or_trim(s, self .num_steps) for sinsentences]\nifis_tgt:\nsentences =[['<bos> ']+sfor sinsentences]\nifvocab isNone :\nvocab =d2l.Vocab(sentences, min_freq =2)\narray =torch .tensor([vocab[s] for sinsentences])\nvalid_len =(array !=vocab[ '<pad> ']).type(torch .int32) .sum( 1)\nreturn array, vocab, valid_len\nsrc, tgt =self ._tokenize( self ._preprocess(raw_text),\nself .num_train +self .num_val)\nsrc_array, src_vocab, src_valid_len =_build_array(src, src_vocab)\ntgt_array, tgt_vocab, _ =_build_array(tgt, tgt_vocab, True )\nreturn ((src_array, tgt_array[:,: -1], src_valid_len, tgt_array[:, 1:]),\nsrc_vocab, tgt_vocab)\n10.5.4Readingthe Dataset\nFinally, we define the get_dataloader method to return the data iterator.\n@d2l .add_to_class(MTFraEng) #@save\ndef get_dataloader (self , train):\nidx =slice (0,self .num_train) iftrain else slice (self .num_train, None )\nreturn self .get_tensorloader( self .arrays, train, idx)\nLet\u2019s read the first minibatch from the English\u2013French dataset.", "mimetype": "text/plain", "start_char_idx": 914805, "end_char_idx": 917664, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "522bacc8-4e94-4665-9b88-5e902bc8bc16": {"__data__": {"id_": "522bacc8-4e94-4665-9b88-5e902bc8bc16", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8fa5f463-3d75-4b45-999a-fc7c91a750ca", "node_type": "1", "metadata": {}, "hash": "ec64e1982ef18190cc76aff5e3ae3cb394bedc1b3999def717f6276d20327fff", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3110c164-5f55-4d67-9508-e1c9a984a3f7", "node_type": "1", "metadata": {}, "hash": "59f494e05b4fe2497c8805f1f0630e8f915228f65550986d26d166017b38dbe2", "class_name": "RelatedNodeInfo"}}, "text": "@d2l .add_to_class(MTFraEng) #@save\ndef get_dataloader (self , train):\nidx =slice (0,self .num_train) iftrain else slice (self .num_train, None )\nreturn self .get_tensorloader( self .arrays, train, idx)\nLet\u2019s read the first minibatch from the English\u2013French dataset.\n393 Machine Translation and the Dataset\ndata =MTFraEng(batch_size =3)\nsrc, tgt, src_valid_len, label =next (iter (data .train_dataloader()))\nprint ('source: ', src .type(torch .int32))\nprint ('decoder input: ', tgt .type(torch .int32))\nprint ('source len excluding pad: ', src_valid_len .type(torch .int32))\nprint ('label: ', label .type(torch .int32))\nsource: tensor([[ 117,182, 0, 3, 4, 4, 4, 4, 4],\n[62,72, 2, 3, 4, 4, 4, 4, 4],\n[57,124, 0, 3, 4, 4, 4, 4, 4]], dtype =torch .int32)\ndecoder input : tensor([[ 3,37,100,58,160, 0, 4, 5, 5],\n[3, 6, 2, 4, 5, 5, 5, 5, 5],\n[3,180, 0, 4, 5, 5, 5, 5, 5]], dtype =torch .int32)\nsource len excluding pad: tensor([ 4,4,4], dtype =torch .int32)\nlabel: tensor([[ 37,100,58,160, 0, 4, 5, 5, 5],\n[6, 2, 4, 5, 5, 5, 5, 5, 5],\n[180, 0, 4, 5, 5, 5, 5, 5, 5]], dtype =torch .int32)\nWe show a pair of source and target sequences processed by the above _build_arrays\nmethod (in the string format).\n@d2l .add_to_class(MTFraEng) #@save\ndef build (self , src_sentences, tgt_sentences):\nraw_text ='\\n'.join([src +'\\t'+tgt for src, tgt inzip(\nsrc_sentences, tgt_sentences)])\narrays, _, _ =self ._build_arrays(\nraw_text, self .src_vocab, self .tgt_vocab)\nreturn arrays\nsrc, tgt, _, _ =data .build([ 'hi . '], [ 'salut . '])\nprint ('source: ', data .src_vocab .to_tokens(src[ 0].type(torch .int32)))\nprint ('target: ', data .tgt_vocab .to_tokens(tgt[ 0].type(torch .int32)))\nsource: [ 'hi','.','<eos> ','<pad> ','<pad> ','<pad> ','<pad> ','<pad> ','\n\u21a9!<pad> ']\ntarget: [ '<bos> ','salut ','.','<eos> ','<pad> ','<pad> ','<pad> ','<pad> ','\n\u21a9!<pad> ']\n10.5.5Summary\nInnaturallanguageprocessing, machinetranslation referstothetaskofautomaticallymap-\npingfromasequencerepresentingastringoftextina sourcelanguagetoastringrepresent-\ning a plausible translation in a targetlanguage. Using word-level tokenization, the vocab-\nulary size will be significantly larger than that using character-level tokenization, but the\nsequence lengths will be much shorter. To mitigate the large vocabulary size, we can treat\ninfrequent tokens as some \u201cunknown\u201d token. We can truncate and pad text sequences so\nthat all of them will have the same length to be loaded in minibatches. Modern implemen-\n394 Modern Recurrent Neural Networks\n150tationsoftenbucketsequenceswithsimilarlengthstoavoidwastingexcessivecomputation\non padding.\n10.5.6Exercises\n1.Try different values of the max_examples argument in the _tokenize method. How\ndoes this affect the vocabulary sizes of the source language and the target language?\n2.Text in some languages such as Chinese and Japanese does not have word boundary\nindicators(e.g.,space). Isword-leveltokenizationstillagoodideaforsuchcases? Why\nor why not?\nDiscussions150.\n10.6TheEncoder\u0000Decoder Architecture\nIn general sequence-to-sequence problems like machine translation ( Section 10.5 ), inputs\nand outputs are of varying lengths that are unaligned.", "mimetype": "text/plain", "start_char_idx": 917398, "end_char_idx": 920554, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3110c164-5f55-4d67-9508-e1c9a984a3f7": {"__data__": {"id_": "3110c164-5f55-4d67-9508-e1c9a984a3f7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "522bacc8-4e94-4665-9b88-5e902bc8bc16", "node_type": "1", "metadata": {}, "hash": "6f8325f6adb169c576341ea04894dac70256a763d1e5a7daac75d9f20cb5b5a4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d8209767-669f-4131-9d83-bfc337549707", "node_type": "1", "metadata": {}, "hash": "52a267f0e9bc58b4dbe7b1bb6241acb6c9a3b86070d036c5f6c1306b7a1df16d", "class_name": "RelatedNodeInfo"}}, "text": "We can truncate and pad text sequences so\nthat all of them will have the same length to be loaded in minibatches. Modern implemen-\n394 Modern Recurrent Neural Networks\n150tationsoftenbucketsequenceswithsimilarlengthstoavoidwastingexcessivecomputation\non padding.\n10.5.6Exercises\n1.Try different values of the max_examples argument in the _tokenize method. How\ndoes this affect the vocabulary sizes of the source language and the target language?\n2.Text in some languages such as Chinese and Japanese does not have word boundary\nindicators(e.g.,space). Isword-leveltokenizationstillagoodideaforsuchcases? Why\nor why not?\nDiscussions150.\n10.6TheEncoder\u0000Decoder Architecture\nIn general sequence-to-sequence problems like machine translation ( Section 10.5 ), inputs\nand outputs are of varying lengths that are unaligned. The standard approach to handling\nthis sort of data is to design an encoder\u2013decoder architecture ( Fig. 10.6.1 ) consisting of\ntwo major components: an encoder that takes a variable-length sequence as input, and a\ndecoder that acts as a conditional language model, taking in the encoded input and the\nleftwards context of the target sequence and predicting the subsequent token in the target\nsequence.\ntFig. 10.6.1 The encoder\u2013decoder architecture.\nLet\u2019s take machine translation from English to French as an example. Given an input\nsequence in English: \u201cThey\u201d, \u201care\u201d, \u201cwatching\u201d, \u201c.\u201d, this encoder\u2013decoder architecture\nfirst encodes the variable-length input into a state, then decodes the state to generate the\ntranslated sequence, token by token, as output: \u201cIls\u201d, \u201cregardent\u201d, \u201c.\u201d. Since the encoder\u2013\ndecoder architecture forms the basis of different sequence-to-sequence models in subse-\nquent sections, this section will convert this architecture into an interface that will be im-\nplemented later.\nfrom torch import nn\nfrom d2l import torch asd2l\n10.6.1Encoder\nIntheencoderinterface,wejustspecifythattheencodertakesvariable-lengthsequencesas\ninput X. The implementation will be provided by any model that inherits this base Encoder\nclass.\n395 The Encoder\u0000Decoder Architecture\nclass Encoder (nn.Module): #@save\n\"\"\"The base encoder interface for the encoder--decoder architecture.\"\"\"\ndef __init__ (self ):\nsuper ().__init__ ()\n# Later there can be additional arguments (e.g., length excluding padding)\ndef forward (self , X, *args):\nraise NotImplementedError\n10.6.2Decoder\nInthefollowingdecoderinterface,weaddanadditional init_state methodtoconvertthe\nencoder output ( enc_all_outputs ) into the encoded state. Note that this step may require\nextra inputs, such as the valid length of the input, which was explained in Section 10.5 .\nTo generate a variable-length sequence token by token, every time the decoder may map\nan input (e.g., the generated token at the previous time step) and the encoded state into an\noutput token at the current time step.\nclass Decoder (nn.Module): #@save\n\"\"\"The base decoder interface for the encoder--decoder architecture.\"\"\"\ndef __init__ (self ):\nsuper ().__init__ ()\n# Later there can be additional arguments (e.g., length excluding padding)\ndef init_state (self , enc_all_outputs, *args):\nraise NotImplementedError\ndef forward (self , X, state):\nraise NotImplementedError\n10.6.3Puttingthe Encoder and Decoder Together\nIn the forward propagation, the output of the encoder is used to produce the encoded state,\nand this state will be further used by the decoder as one of its input.\nclass EncoderDecoder (d2l .Classifier): #@save\n\"\"\"The base class for the encoder--decoder architecture.\"\"\"\ndef __init__ (self , encoder, decoder):\nsuper ().__init__ ()\nself .encoder =encoder\nself .decoder =decoder\ndef forward (self , enc_X, dec_X, *args):\nenc_all_outputs =self .encoder(enc_X, *args)\ndec_state =self .decoder .init_state(enc_all_outputs, *args)\n# Return decoder output only\nreturn self .decoder(dec_X, dec_state)[ 0]\nInthenextsection,wewillseehowtoapplyRNNstodesignsequence-to-sequencemodels\nbased on this encoder\u2013decoder architecture.\n396 Modern Recurrent Neural Networks\n15110.6.4Summary\nEncoder-decoder architectures can handle inputs and outputs that both consist of variable-\nlengthsequencesandthusaresuitableforsequence-to-sequenceproblemssuchasmachine\ntranslation. The encoder takes a variable-length sequence as input and transforms it into a\nstatewitha fixedshape.", "mimetype": "text/plain", "start_char_idx": 919737, "end_char_idx": 924067, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d8209767-669f-4131-9d83-bfc337549707": {"__data__": {"id_": "d8209767-669f-4131-9d83-bfc337549707", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3110c164-5f55-4d67-9508-e1c9a984a3f7", "node_type": "1", "metadata": {}, "hash": "59f494e05b4fe2497c8805f1f0630e8f915228f65550986d26d166017b38dbe2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e403de8b-cc6c-4e47-a438-30328ae64779", "node_type": "1", "metadata": {}, "hash": "fdc7eb9f1a34c67028a3b79942ada3a648eb65bbf092a60435c8e443744e0f0c", "class_name": "RelatedNodeInfo"}}, "text": "def __init__ (self , encoder, decoder):\nsuper ().__init__ ()\nself .encoder =encoder\nself .decoder =decoder\ndef forward (self , enc_X, dec_X, *args):\nenc_all_outputs =self .encoder(enc_X, *args)\ndec_state =self .decoder .init_state(enc_all_outputs, *args)\n# Return decoder output only\nreturn self .decoder(dec_X, dec_state)[ 0]\nInthenextsection,wewillseehowtoapplyRNNstodesignsequence-to-sequencemodels\nbased on this encoder\u2013decoder architecture.\n396 Modern Recurrent Neural Networks\n15110.6.4Summary\nEncoder-decoder architectures can handle inputs and outputs that both consist of variable-\nlengthsequencesandthusaresuitableforsequence-to-sequenceproblemssuchasmachine\ntranslation. The encoder takes a variable-length sequence as input and transforms it into a\nstatewitha fixedshape. Thedecoder mapsthe encodedstateofa fixedshapeto avariable-\nlength sequence.\n10.6.5Exercises\n1.Suppose that we use neural networks to implement the encoder\u2013decoder architecture.\nDo the encoder and the decoder have to be the same type of neural network?\n2.Besides machine translation, can you think of another application where the encoder\u2013\ndecoder architecture can be applied?\nDiscussions151.\n10.7Sequence-to-SequenceLearning forMachine\nTranslation\nIn so-called sequence-to-sequence problems such as machine translation (as discussed in\nSection10.5 ),whereinputsandoutputseachconsistofvariable-lengthunalignedsequences,\nwe generally rely on encoder\u2013decoder architectures ( Section 10.6 ). In this section, we will\ndemonstrate the application of an encoder\u2013decoder architecture, where both the encoder\nand decoder are implemented as RNNs, to the task of machine translation ( Choet al.,\n2014,Sutskever etal., 2014).\nHere, the encoder RNN will take a variable-length sequence as input and transform it into\na fixed-shape hidden state. Later, in Chapter 11 , we will introduce attention mechanisms,\nwhich allow us to access encoded inputs without having to compress the entire input into a\nsingle fixed-length representation.\nThen to generate the output sequence, one token at a time, the decoder model, consisting\nof a separate RNN, will predict each successive target token given both the input sequence\nand the preceding tokens in the output. During training, the decoder will typically be con-\nditioned upon the preceding tokens in the official \u201cground truth\u201d label. However, at test\ntime, we will want to condition each output of the decoder on the tokens already predicted.\nNote that if we ignore the encoder, the decoder in a sequence-to-sequence architecture be-\nhaves just like a normal language model. Fig. 10.7.1 illustrates how to use two RNNs for\nsequence-to-sequence learning in machine translation.\nInFig. 10.7.1 , the special \u201c<eos>\u201d token marks the end of the sequence. Our model can\nstop making predictions once this token is generated. At the initial time step of the RNN\ndecoder, there are two special design decisions to be aware of: First, we begin every input\n397 Sequence-to-Sequence Learning for Machine Translation\ntFig. 10.7.1 Sequence-to-sequence learning with an RNN encoder and an RNN decoder.\nwithaspecialbeginning-of-sequence\u201c<bos>\u201dtoken. Second,wemayfeedthefinalhidden\nstate of the encoder into the decoder at every single decoding time step ( Choet al., 2014).\nIn some other designs, such as that of Sutskever et al.(2014), the final hidden state of the\nRNN encoder is used to initiate the hidden state of the decoder only at the first decoding\nstep.\nimport collections\nimport math\nimport torch\nfrom torch import nn\nfrom torch .nnimport functional asF\nfrom d2l import torch asd2l\n10.7.1TeacherForcing\nWhile running the encoder on the input sequence is relatively straightforward, handling\nthe input and output of the decoder requires more care. The most common approach is\nsometimes called teacher forcing . Here, the original target sequence (token labels) is fed\ninto the decoder as input. More concretely, the special beginning-of-sequence token and\nthe original target sequence, excluding the final token, are concatenated as input to the\ndecoder,whilethedecoderoutput(labelsfortraining)istheoriginaltargetsequence,shifted\nby one token: \u201c<bos>\u201d, \u201cIls\u201d, \u201cregardent\u201d, \u201c.\u201d !\u201cIls\u201d, \u201cregardent\u201d, \u201c.\u201d, \u201c<eos>\u201d ( Fig.\n10.7.1).", "mimetype": "text/plain", "start_char_idx": 923284, "end_char_idx": 927521, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e403de8b-cc6c-4e47-a438-30328ae64779": {"__data__": {"id_": "e403de8b-cc6c-4e47-a438-30328ae64779", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d8209767-669f-4131-9d83-bfc337549707", "node_type": "1", "metadata": {}, "hash": "52a267f0e9bc58b4dbe7b1bb6241acb6c9a3b86070d036c5f6c1306b7a1df16d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6444dcea-c708-4530-9d2d-232fcbc50633", "node_type": "1", "metadata": {}, "hash": "828a22b74c4e8ed0389a04fe6c3841f95708b8e8d0aa12556355c25f72aa40eb", "class_name": "RelatedNodeInfo"}}, "text": "import collections\nimport math\nimport torch\nfrom torch import nn\nfrom torch .nnimport functional asF\nfrom d2l import torch asd2l\n10.7.1TeacherForcing\nWhile running the encoder on the input sequence is relatively straightforward, handling\nthe input and output of the decoder requires more care. The most common approach is\nsometimes called teacher forcing . Here, the original target sequence (token labels) is fed\ninto the decoder as input. More concretely, the special beginning-of-sequence token and\nthe original target sequence, excluding the final token, are concatenated as input to the\ndecoder,whilethedecoderoutput(labelsfortraining)istheoriginaltargetsequence,shifted\nby one token: \u201c<bos>\u201d, \u201cIls\u201d, \u201cregardent\u201d, \u201c.\u201d !\u201cIls\u201d, \u201cregardent\u201d, \u201c.\u201d, \u201c<eos>\u201d ( Fig.\n10.7.1).\nOur implementation in Section 10.5.3 prepared training data for teacher forcing, where\nshifting tokens for self-supervised learning is similar to the training of language models in\nSection 9.3 . An alternative approach is to feed the predicted token from the previous time\nstep as the current input to the decoder.\nIn the following, we explain the design depicted in Fig. 10.7.1 in greater detail. We will\ntrain this model for machine translation on the English\u2013French dataset as introduced in\nSection 10.5 .\n10.7.2Encoder\nRecall that the encoder transforms an input sequence of variable length into a fixed-shape\ncontextvariable c(seeFig. 10.7.1 ).\nConsiderasinglesequenceexample(batchsize1). Supposetheinputsequenceis \ud835\udc651,...,\ud835\udc65\ud835\udc47,\nsuch that\ud835\udc65\ud835\udc61is the\ud835\udc61thtoken. At time step \ud835\udc61, the RNN transforms the input feature vector x\ud835\udc61\n398 Modern Recurrent Neural Networks\nfor\ud835\udc65\ud835\udc61andthehiddenstate h\ud835\udc61\u00001fromtheprevioustimestepintothecurrenthiddenstate h\ud835\udc61.\nWecanuseafunction \ud835\udc53toexpressthetransformationoftheRNN\u2019srecurrentlayer:\nh\ud835\udc61=\ud835\udc53\u00b9x\ud835\udc61,h\ud835\udc61\u00001\u00ba. (10.7.1)\nIn general, the encoder transforms the hidden states at all time steps into a context variable\nthrough a customized function \ud835\udc5e:\nc=\ud835\udc5e\u00b9h1,...,h\ud835\udc47\u00ba. (10.7.2)\nFor example, in Fig. 10.7.1 , the context variable is just the hidden state h\ud835\udc47correspond-\ning to the encoder RNN\u2019s representation after processing the final token of the input se-\nquence.\nInthisexample,wehaveusedaunidirectionalRNNtodesigntheencoder,wherethehidden\nstate only depends on the input subsequence at and before the time step of the hidden state.\nWe can also construct encoders using bidirectional RNNs. In this case, a hidden state\ndependsonthesubsequencebeforeandafterthetimestep(includingtheinputatthecurrent\ntime step), which encodes the information of the entire sequence.\nNow let\u2019s implement the RNN encoder. Note that we use an embedding layer to obtain\nthe feature vector for each token in the input sequence. The weight of an embedding\nlayer is a matrix, where the number of rows corresponds to the size of the input vocab-\nulary ( vocab_size ) and number of columns corresponds to the feature vector\u2019s dimension\n(embed_size ). Foranyinputtokenindex \ud835\udc56,theembeddinglayerfetchesthe \ud835\udc56throw(starting\nfrom 0) of the weight matrix to return its feature vector. Here we implement the encoder\nwith a multilayer GRU.\ndef init_seq2seq (module): #@save\n\"\"\"Initialize weights for sequence-to-sequence learning.\"\"\"\niftype (module) ==nn.Linear:\nnn.init .xavier_uniform_(module .weight)\niftype (module) ==nn.GRU:\nfor param inmodule ._flat_weights_names:\nif\"weight \"inparam:\nnn.init .xavier_uniform_(module ._parameters[param])\nclass Seq2SeqEncoder (d2l .Encoder): #@save\n\"\"\"The RNN encoder for sequence-to-sequence learning.\"\"\"", "mimetype": "text/plain", "start_char_idx": 926749, "end_char_idx": 930239, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6444dcea-c708-4530-9d2d-232fcbc50633": {"__data__": {"id_": "6444dcea-c708-4530-9d2d-232fcbc50633", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e403de8b-cc6c-4e47-a438-30328ae64779", "node_type": "1", "metadata": {}, "hash": "fdc7eb9f1a34c67028a3b79942ada3a648eb65bbf092a60435c8e443744e0f0c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6f950f92-47ff-4ddb-930e-21dc669b5a03", "node_type": "1", "metadata": {}, "hash": "229f910d108fbdf67a416114ee864b9379f444d4c2c46b5229e74bd8ffcec018", "class_name": "RelatedNodeInfo"}}, "text": "Foranyinputtokenindex \ud835\udc56,theembeddinglayerfetchesthe \ud835\udc56throw(starting\nfrom 0) of the weight matrix to return its feature vector. Here we implement the encoder\nwith a multilayer GRU.\ndef init_seq2seq (module): #@save\n\"\"\"Initialize weights for sequence-to-sequence learning.\"\"\"\niftype (module) ==nn.Linear:\nnn.init .xavier_uniform_(module .weight)\niftype (module) ==nn.GRU:\nfor param inmodule ._flat_weights_names:\nif\"weight \"inparam:\nnn.init .xavier_uniform_(module ._parameters[param])\nclass Seq2SeqEncoder (d2l .Encoder): #@save\n\"\"\"The RNN encoder for sequence-to-sequence learning.\"\"\"\ndef __init__ (self , vocab_size, embed_size, num_hiddens, num_layers,\ndropout =0):\nsuper ().__init__ ()\nself .embedding =nn.Embedding(vocab_size, embed_size)\nself .rnn =d2l.GRU(embed_size, num_hiddens, num_layers, dropout)\nself .apply(init_seq2seq)\ndef forward (self , X, *args):\n# X shape: (batch_size, num_steps)\nembs =self .embedding(X .t().type(torch .int64))\n# embs shape: (num_steps, batch_size, embed_size)\noutputs, state =self .rnn(embs)\n(continues on next page)\n399 Sequence-to-Sequence Learning for Machine Translation\n(continued from previous page)\n# outputs shape: (num_steps, batch_size, num_hiddens)\n# state shape: (num_layers, batch_size, num_hiddens)\nreturn outputs, state\nLet\u2019s use a concrete example to illustrate the above encoder implementation. Below, we\ninstantiateatwo-layerGRUencoderwhosenumberofhiddenunitsis16. Givenaminibatch\nof sequence inputs X(batch size =4; number of time steps =9), the hidden states of the\nfinal layer at all the time steps ( enc_outputs returned by the encoder\u2019s recurrent layers)\nare a tensor of shape (number of time steps, batch size, number of hidden units).\nvocab_size, embed_size, num_hiddens, num_layers =10,8,16,2\nbatch_size, num_steps =4,9\nencoder =Seq2SeqEncoder(vocab_size, embed_size, num_hiddens, num_layers)\nX=torch .zeros((batch_size, num_steps))\nenc_outputs, enc_state =encoder(X)\nd2l.check_shape(enc_outputs, (num_steps, batch_size, num_hiddens))\nSince we are using a GRU here, the shape of the multilayer hidden states at the final time\nstep is (number of hidden layers, batch size, number of hidden units).\nd2l.check_shape(enc_state, (num_layers, batch_size, num_hiddens))\n10.7.3Decoder\nGivenatargetoutputsequence \ud835\udc661,\ud835\udc662,...,\ud835\udc66\ud835\udc470foreachtimestep \ud835\udc610(weuse\ud835\udc610todifferentiate\nfrom the input sequence time steps), the decoder assigns a predicted probability to each\npossible token occurring at step \ud835\udc66\ud835\udc610\u00b81conditioned upon the previous tokens in the target\n\ud835\udc661,...,\ud835\udc66\ud835\udc610and the context variable c, i.e.,\ud835\udc43\u00b9\ud835\udc66\ud835\udc610\u00b81j\ud835\udc661,...,\ud835\udc66\ud835\udc610,c\u00ba.\nTo predict the subsequent token \ud835\udc610\u00b81in the target sequence, the RNN decoder takes the\nprevious step\u2019s target token \ud835\udc66\ud835\udc610, the hidden RNN state from the previous time step s\ud835\udc610\u00001,\nand the context variable cas its input, and transforms them into the hidden state s\ud835\udc610at the\ncurrent time step. We can use a function \ud835\udc54to express the transformation of the decoder\u2019s\nhidden layer:\ns\ud835\udc610=\ud835\udc54\u00b9\ud835\udc66\ud835\udc610\u00001,c,s\ud835\udc610\u00001\u00ba. (10.7.3)\nAfter obtaining the hidden state of the decoder, we can use an output layer and the softmax\noperation to compute the predictive distribution \ud835\udc5d\u00b9\ud835\udc66\ud835\udc610\u00b81j\ud835\udc661,...,\ud835\udc66\ud835\udc610,c\u00baover the subse-\nquent output token \ud835\udc610\u00b81.\nFollowing Fig. 10.7.1 , when implementing the decoder as follows, we directly use the hid-\nden state at the final time step of the encoder to initialize the hidden state of the decoder.", "mimetype": "text/plain", "start_char_idx": 929655, "end_char_idx": 933013, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6f950f92-47ff-4ddb-930e-21dc669b5a03": {"__data__": {"id_": "6f950f92-47ff-4ddb-930e-21dc669b5a03", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6444dcea-c708-4530-9d2d-232fcbc50633", "node_type": "1", "metadata": {}, "hash": "828a22b74c4e8ed0389a04fe6c3841f95708b8e8d0aa12556355c25f72aa40eb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c2ce7c52-7cf7-4119-8f64-032187212523", "node_type": "1", "metadata": {}, "hash": "c730967efa644419bcdea5fa5bdf423b4d65134d04a207cb193b36cd9ef5341d", "class_name": "RelatedNodeInfo"}}, "text": "We can use a function \ud835\udc54to express the transformation of the decoder\u2019s\nhidden layer:\ns\ud835\udc610=\ud835\udc54\u00b9\ud835\udc66\ud835\udc610\u00001,c,s\ud835\udc610\u00001\u00ba. (10.7.3)\nAfter obtaining the hidden state of the decoder, we can use an output layer and the softmax\noperation to compute the predictive distribution \ud835\udc5d\u00b9\ud835\udc66\ud835\udc610\u00b81j\ud835\udc661,...,\ud835\udc66\ud835\udc610,c\u00baover the subse-\nquent output token \ud835\udc610\u00b81.\nFollowing Fig. 10.7.1 , when implementing the decoder as follows, we directly use the hid-\nden state at the final time step of the encoder to initialize the hidden state of the decoder.\nThis requires that the RNN encoder and the RNN decoder have the same number of lay-\ners and hidden units. To further incorporate the encoded input sequence information, the\ncontext variable is concatenated with the decoder input at all the time steps. To predict the\n400 Modern Recurrent Neural Networks\nprobability distribution of the output token, we use a fully connected layer to transform the\nhidden state at the final layer of the RNN decoder.\nclass Seq2SeqDecoder (d2l .Decoder):\n\"\"\"The RNN decoder for sequence to sequence learning.\"\"\"\ndef __init__ (self , vocab_size, embed_size, num_hiddens, num_layers,\ndropout =0):\nsuper ().__init__ ()\nself .embedding =nn.Embedding(vocab_size, embed_size)\nself .rnn =d2l.GRU(embed_size +num_hiddens, num_hiddens,\nnum_layers, dropout)\nself .dense =nn.LazyLinear(vocab_size)\nself .apply(init_seq2seq)\ndef init_state (self , enc_all_outputs, *args):\nreturn enc_all_outputs\ndef forward (self , X, state):\n# X shape: (batch_size, num_steps)\n# embs shape: (num_steps, batch_size, embed_size)\nembs =self .embedding(X .t().type(torch .int32))\nenc_output, hidden_state =state\n# context shape: (batch_size, num_hiddens)\ncontext =enc_output[ -1]\n# Broadcast context to (num_steps, batch_size, num_hiddens)\ncontext =context .repeat(embs .shape[ 0],1,1)\n# Concat at the feature dimension\nembs_and_context =torch .cat((embs, context), -1)\noutputs, hidden_state =self .rnn(embs_and_context, hidden_state)\noutputs =self .dense(outputs) .swapaxes( 0,1)\n# outputs shape: (batch_size, num_steps, vocab_size)\n# hidden_state shape: (num_layers, batch_size, num_hiddens)\nreturn outputs, [enc_output, hidden_state]\nTo illustrate the implemented decoder, below we instantiate it with the same hyperparam-\neters from the aforementioned encoder. As we can see, the output shape of the decoder\nbecomes (batch size, number of time steps, vocabulary size), where the final dimension of\nthe tensor stores the predicted token distribution.\ndecoder =Seq2SeqDecoder(vocab_size, embed_size, num_hiddens, num_layers)\nstate =decoder .init_state(encoder(X))\ndec_outputs, state =decoder(X, state)\nd2l.check_shape(dec_outputs, (batch_size, num_steps, vocab_size))\nd2l.check_shape(state[ 1], (num_layers, batch_size, num_hiddens))\nThelayersintheaboveRNNencoder\u2013decodermodelaresummarizedin Fig.10.7.2 .\n10.7.4Encoder\u2013DecoderforSequence-to-SequenceLearning\nPutting it all together in code yields the following:\n401 Sequence-to-Sequence Learning for Machine Translation\ntFig. 10.7.2 Layers in an RNN encoder\u2013decoder model.\nclass Seq2Seq (d2l .EncoderDecoder): #@save\n\"\"\"The RNN encoder--decoder for sequence to sequence learning.\"\"\"\ndef __init__ (self , encoder, decoder, tgt_pad, lr):\nsuper ().__init__ (encoder, decoder)\nself .save_hyperparameters()\ndef validation_step (self , batch):\nY_hat =self (*batch[: -1])\nself .plot( 'loss ',self .loss(Y_hat, batch[ -1]), train =False )\ndef configure_optimizers (self ):\n# Adam optimizer is used here\nreturn torch .optim .Adam( self .parameters(), lr =self .lr)\n10.7.5LossFunction with Masking\nAt each time step, the decoder predicts a probability distribution for the output tokens.\nAs with language modeling, we can apply softmax to obtain the distribution and calculate\nthe cross-entropy loss for optimization.", "mimetype": "text/plain", "start_char_idx": 932510, "end_char_idx": 936274, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c2ce7c52-7cf7-4119-8f64-032187212523": {"__data__": {"id_": "c2ce7c52-7cf7-4119-8f64-032187212523", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6f950f92-47ff-4ddb-930e-21dc669b5a03", "node_type": "1", "metadata": {}, "hash": "229f910d108fbdf67a416114ee864b9379f444d4c2c46b5229e74bd8ffcec018", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "88de74a9-caa7-41a6-acb9-b0f14e0ed7d7", "node_type": "1", "metadata": {}, "hash": "68f4e711bd103ed413724aa51b6a4faf53a0b2e790e3a61f983a68e096846184", "class_name": "RelatedNodeInfo"}}, "text": "10.7.2 Layers in an RNN encoder\u2013decoder model.\nclass Seq2Seq (d2l .EncoderDecoder): #@save\n\"\"\"The RNN encoder--decoder for sequence to sequence learning.\"\"\"\ndef __init__ (self , encoder, decoder, tgt_pad, lr):\nsuper ().__init__ (encoder, decoder)\nself .save_hyperparameters()\ndef validation_step (self , batch):\nY_hat =self (*batch[: -1])\nself .plot( 'loss ',self .loss(Y_hat, batch[ -1]), train =False )\ndef configure_optimizers (self ):\n# Adam optimizer is used here\nreturn torch .optim .Adam( self .parameters(), lr =self .lr)\n10.7.5LossFunction with Masking\nAt each time step, the decoder predicts a probability distribution for the output tokens.\nAs with language modeling, we can apply softmax to obtain the distribution and calculate\nthe cross-entropy loss for optimization. Recall from Section 10.5 that the special padding\ntokens are appended to the end of sequences and so sequences of varying lengths can be\nefficientlyloadedinminibatchesofthesameshape. However,predictionofpaddingtokens\nshould be excluded from loss calculations. To this end, we can mask irrelevant entries\nwith zero values so that multiplication of any irrelevant prediction with zero equates to\nzero.\n@d2l .add_to_class(Seq2Seq)\ndef loss (self , Y_hat, Y):\nl=super (Seq2Seq, self ).loss(Y_hat, Y, averaged =False )\nmask =(Y.reshape( -1)!=self .tgt_pad) .type(torch .float32)\nreturn (l*mask) .sum() /mask .sum()\n10.7.6Training\nNow we can create and train an RNN encoder\u2013decoder model for sequence-to-sequence\nlearning on the machine translation dataset.\ndata =d2l.MTFraEng(batch_size =128)\nembed_size, num_hiddens, num_layers, dropout =256,256,2,0.2\n(continues on next page)\n402 Modern Recurrent Neural Networks\n(continued from previous page)\nencoder =Seq2SeqEncoder(\nlen(data .src_vocab), embed_size, num_hiddens, num_layers, dropout)\ndecoder =Seq2SeqDecoder(\nlen(data .tgt_vocab), embed_size, num_hiddens, num_layers, dropout)\nmodel =Seq2Seq(encoder, decoder, tgt_pad =data .tgt_vocab[ '<pad> '],\nlr=0.005 )\ntrainer =d2l.Trainer(max_epochs =30, gradient_clip_val =1, num_gpus =1)\ntrainer .fit(model, data)\n10.7.7Prediction\nTopredicttheoutputsequenceateachstep,thepredictedtokenfromtheprevioustimestep\nis fed into the decoder as an input. One simple strategy is to sample whichever token that\nhas been assigned by the decoder the highest probability when predicting at each step. As\nintraining,attheinitialtimestepthebeginning-of-sequence(\u201c<bos>\u201d)tokenisfedintothe\ndecoder. This prediction process is illustrated in Fig. 10.7.3 . When the end-of-sequence\n(\u201c<eos>\u201d) token is predicted, the prediction of the output sequence is complete.\ntFig. 10.7.3 Predicting the output sequence token by token using an RNN encoder\u2013decoder.\nIn the next section, we will introduce more sophisticated strategies based on beam search\n(Section 10.8 ).\n@d2l .add_to_class(d2l .EncoderDecoder) #@save\ndef predict_step (self , batch, device, num_steps,\nsave_attention_weights =False ):\nbatch =[a.to(device) for ainbatch]\nsrc, tgt, src_valid_len, _ =batch\nenc_all_outputs =self .encoder(src, src_valid_len)\ndec_state =self .decoder .init_state(enc_all_outputs, src_valid_len)\n(continues on next page)\n403 Sequence-to-Sequence Learning for Machine Translation\n(continued from previous page)\noutputs, attention_weights =[tgt[:, ( 0)].unsqueeze( 1), ], []\nfor _inrange (num_steps):\nY, dec_state =self .decoder(outputs[ -1], dec_state)\noutputs .append(Y .argmax( 2))\n# Save attention weights (to be covered later)\nifsave_attention_weights:\nattention_weights .append( self .decoder .attention_weights)\nreturn torch .cat(outputs[ 1:], 1), attention_weights\n10.7.8Evaluationof PredictedSequences\nWecanevaluateapredictedsequencebycomparingitwiththetargetsequence(theground\ntruth). Butwhatpreciselyistheappropriatemeasureforcomparingsimilaritybetweentwo\nsequences?", "mimetype": "text/plain", "start_char_idx": 935493, "end_char_idx": 939305, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "88de74a9-caa7-41a6-acb9-b0f14e0ed7d7": {"__data__": {"id_": "88de74a9-caa7-41a6-acb9-b0f14e0ed7d7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c2ce7c52-7cf7-4119-8f64-032187212523", "node_type": "1", "metadata": {}, "hash": "c730967efa644419bcdea5fa5bdf423b4d65134d04a207cb193b36cd9ef5341d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bf0ec803-bff8-4fdd-a4ca-3538cafc356f", "node_type": "1", "metadata": {}, "hash": "35883b9ed1a42f1e57086fec46f94c47b7c00f9d0059c968d55c968d33ef066a", "class_name": "RelatedNodeInfo"}}, "text": "Butwhatpreciselyistheappropriatemeasureforcomparingsimilaritybetweentwo\nsequences?\nBilingual Evaluation Understudy (BLEU), though originally proposed for evaluating ma-\nchinetranslationresults( Papinenietal., 2002), hasbeenextensivelyusedinmeasuringthe\nqualityofoutputsequencesfordifferentapplications. Inprinciple,forany \ud835\udc5b-gram(Section\n9.3.1)inthepredictedsequence,BLEUevaluateswhetherthis \ud835\udc5b-gramappearsinthetarget\nsequence.\nDenote by\ud835\udc5d\ud835\udc5bthe precision of an \ud835\udc5b-gram, defined as the ratio of the number of matched\n\ud835\udc5b-grams in the predicted and target sequences to the number of \ud835\udc5b-grams in the predicted\nsequence. To explain, given a target sequence \ud835\udc34,\ud835\udc35,\ud835\udc36,\ud835\udc37,\ud835\udc38,\ud835\udc39, and a predicted sequence\n\ud835\udc34,\ud835\udc35,\ud835\udc35,\ud835\udc36,\ud835\udc37, we have\ud835\udc5d1=4\u009d5,\ud835\udc5d2=3\u009d4,\ud835\udc5d3=1\u009d3, and\ud835\udc5d4=0. Now let len label\nand len predbe the numbers of tokens in the target sequence and the predicted sequence,\nrespectively. Then, BLEU is defined as\nexp\u0012\nmin\u0012\n0,1\u0000lenlabel\nlenpred\u0013\u0013\ud835\udc58\u00d6\n\ud835\udc5b=1\ud835\udc5d1\u009d2\ud835\udc5b\n\ud835\udc5b, (10.7.4)\nwhere\ud835\udc58is the longest \ud835\udc5b-gram for matching.\nBased on the definition of BLEU in (10.7.4 ), whenever the predicted sequence is the same\nas the target sequence, BLEU is 1. Moreover, since matching longer \ud835\udc5b-grams is more diffi-\ncult,BLEUassignsagreaterweightwhenalonger \ud835\udc5b-gramhashighprecision. Specifically,\nwhen\ud835\udc5d\ud835\udc5bis fixed,\ud835\udc5d1\u009d2\ud835\udc5b\n\ud835\udc5bincreases as \ud835\udc5bgrows (the original paper uses \ud835\udc5d1\u009d\ud835\udc5b\n\ud835\udc5b). Furthermore,\nsince predicting shorter sequences tends to yield a higher \ud835\udc5d\ud835\udc5bvalue, the coefficient before\nthe multiplication term in (10.7.4 )penalizes shorter predicted sequences. For example,\nwhen\ud835\udc58=2, given the target sequence \ud835\udc34,\ud835\udc35,\ud835\udc36,\ud835\udc37,\ud835\udc38,\ud835\udc39and the predicted sequence \ud835\udc34,\ud835\udc35,\nalthough\ud835\udc5d1=\ud835\udc5d2=1, the penalty factor exp\u00b91\u00006\u009d2\u00ba\u00190.14lowers the BLEU.\nWe implement the BLEU measure as follows.\ndef bleu (pred_seq, label_seq, k): #@save\n\"\"\"Compute the BLEU.\"\"\"\npred_tokens, label_tokens =pred_seq .split( ''), label_seq .split( '')\n(continues on next page)\n404 Modern Recurrent Neural Networks\n(continued from previous page)\nlen_pred, len_label =len(pred_tokens), len(label_tokens)\nscore =math .exp( min(0,1-len_label /len_pred))\nfor ninrange (1,min(k, len_pred) +1):\nnum_matches, label_subs =0, collections .defaultdict( int)\nfor iinrange (len_label -n+1):\nlabel_subs[ ''.join(label_tokens[i: i +n])] +=1\nfor iinrange (len_pred -n+1):\niflabel_subs[ ''.join(pred_tokens[i: i +n])] >0:\nnum_matches +=1\nlabel_subs[ ''.join(pred_tokens[i: i +n])] -=1\nscore *=math .pow(num_matches /(len_pred -n+1), math .pow( 0.5, n))\nreturn score\nIn the end, we use the trained RNN encoder\u2013decoder to translate a few English sentences\ninto French and compute the BLEU of the results.\nengs =['go . ','i lost . ','he\\'s calm . ','i\\'m home . ']\nfras =['va ! ','j\\'ai perdu . ','il est calme . ','je suis chez moi . ']", "mimetype": "text/plain", "start_char_idx": 939223, "end_char_idx": 941916, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bf0ec803-bff8-4fdd-a4ca-3538cafc356f": {"__data__": {"id_": "bf0ec803-bff8-4fdd-a4ca-3538cafc356f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "88de74a9-caa7-41a6-acb9-b0f14e0ed7d7", "node_type": "1", "metadata": {}, "hash": "68f4e711bd103ed413724aa51b6a4faf53a0b2e790e3a61f983a68e096846184", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "686b03ab-70bb-429b-8d44-d424fefb7c67", "node_type": "1", "metadata": {}, "hash": "f2d7e8a340dd4e583185160149e5ea1c138130915eddd2015a730321ecb00f2a", "class_name": "RelatedNodeInfo"}}, "text": "engs =['go . ','i lost . ','he\\'s calm . ','i\\'m home . ']\nfras =['va ! ','j\\'ai perdu . ','il est calme . ','je suis chez moi . ']\npreds, _ =model .predict_step(\ndata .build(engs, fras), d2l .try_gpu(), data .num_steps)\nfor en, fr, p inzip(engs, fras, preds):\ntranslation =[]\nfor token indata .tgt_vocab .to_tokens(p):\niftoken =='<eos> ':\nbreak\ntranslation .append(token)\nprint (f'{en}=>{translation }, bleu, '\nf'{bleu( \"\".join(translation), fr, k=2):.3f}')\ngo.=>['va','!'], bleu, 1.000\ni lost .=>[\"j'ai\",'perdu ','.'], bleu, 1.000\nhe's calm . => [ 'elle ','court ','.'], bleu,0.000\ni'm home . => [ 'je','suis ','chez ','moi','.'], bleu,1.000\n10.7.9Summary\nFollowing the design of the encoder\u2013decoder architecture, we can use two RNNs to design\na model for sequence-to-sequence learning. In encoder\u2013decoder training, the teacher forc-\ning approach feeds original output sequences (in contrast to predictions) into the decoder.\nWhen implementing the encoder and the decoder, we can use multilayer RNNs. We can\nusemaskstofilteroutirrelevantcomputations, suchaswhencalculatingtheloss. Foreval-\nuating output sequences, BLEU is a popular measure that matches \ud835\udc5b-grams between the\npredicted sequence and the target sequence.\n10.7.10Exercises\n1.Can you adjust the hyperparameters to improve the translation results?\n2.Rerun the experiment without using masks in the loss calculation. What results do you\nobserve? Why?\n405 Beam Search\n1523.If the encoder and the decoder differ in the number of layers or the number of hidden\nunits, how can we initialize the hidden state of the decoder?\n4.In training, replace teacher forcing with feeding the prediction at the previous time step\ninto the decoder. How does this influence the performance?\n5.Rerun the experiment by replacing GRU with LSTM.\n6.Are there any other ways to design the output layer of the decoder?\nDiscussions152.\n10.8Beam Search\nInSection 10.7 , we introduced the encoder\u2013decoder architecture, and the standard tech-\nniques for training them end-to-end. However, when it came to test-time prediction, we\nmentioned only the greedystrategy, where we select at each time step the token given the\nhighest predicted probability of coming next, until, at some time step, we find that we have\npredicted the special end-of-sequence \u201c<eos>\u201d token. In this section, we will begin by for-\nmalizing this greedysearch strategy and identifying some problems that practitioners tend\ntoruninto. Subsequently,wecomparethisstrategywithtwoalternatives: exhaustivesearch\n(illustrative but not practical) and beamsearch (the standard method in practice).\nLet\u2019s begin by setting up our mathematical notation, borrowing conventions from Section\n10.7. At any time step \ud835\udc610, the decoder outputs predictions representing the probability of\neach token in the vocabulary coming next in the sequence (the likely value of \ud835\udc66\ud835\udc610\u00b81), con-\nditioned on the previous tokens \ud835\udc661,...,\ud835\udc66\ud835\udc610and the context variable c, produced by the\nencoder to represent the input sequence. To quantify computational cost, denote by Ythe\noutput vocabulary (including the special end-of-sequence token \u201c<eos>\u201d). Let\u2019s also spec-\nify the maximum number of tokens of an output sequence as \ud835\udc470. Our goal is to search for\nan ideal output from all O\u00b9jYj\ud835\udc470\u00bapossible output sequences. Note that this slightly over-\nestimates the number of distinct outputs because there are no subsequent tokens once the\n\u201c<eos>\u201d token occurs. However, for our purposes, this number roughly captures the size\nof the search space.\n10.8.1GreedySearch\nConsider the simple greedy search strategy from Section 10.7 . Here, at any time step \ud835\udc610,\nwe simply select the token with the highest conditional probability from Y, i.e.,\n\ud835\udc66\ud835\udc610=argmax\n\ud835\udc662Y\ud835\udc43\u00b9\ud835\udc66j\ud835\udc661,...,\ud835\udc66\ud835\udc610\u00001,c\u00ba.", "mimetype": "text/plain", "start_char_idx": 941785, "end_char_idx": 945510, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "686b03ab-70bb-429b-8d44-d424fefb7c67": {"__data__": {"id_": "686b03ab-70bb-429b-8d44-d424fefb7c67", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bf0ec803-bff8-4fdd-a4ca-3538cafc356f", "node_type": "1", "metadata": {}, "hash": "35883b9ed1a42f1e57086fec46f94c47b7c00f9d0059c968d55c968d33ef066a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "22496963-c3cb-4862-9f0b-1fe966848a5d", "node_type": "1", "metadata": {}, "hash": "cc1faa7fcb5390089a4b610048daf37ab22e0d1eafb1d6384cf936d2c775ba0d", "class_name": "RelatedNodeInfo"}}, "text": "Let\u2019s also spec-\nify the maximum number of tokens of an output sequence as \ud835\udc470. Our goal is to search for\nan ideal output from all O\u00b9jYj\ud835\udc470\u00bapossible output sequences. Note that this slightly over-\nestimates the number of distinct outputs because there are no subsequent tokens once the\n\u201c<eos>\u201d token occurs. However, for our purposes, this number roughly captures the size\nof the search space.\n10.8.1GreedySearch\nConsider the simple greedy search strategy from Section 10.7 . Here, at any time step \ud835\udc610,\nwe simply select the token with the highest conditional probability from Y, i.e.,\n\ud835\udc66\ud835\udc610=argmax\n\ud835\udc662Y\ud835\udc43\u00b9\ud835\udc66j\ud835\udc661,...,\ud835\udc66\ud835\udc610\u00001,c\u00ba.(10.8.1)\nOnceourmodeloutputs\u201c<eos>\u201d(orwereachthemaximumlength \ud835\udc470)theoutputsequence\nis completed.\n406 Modern Recurrent Neural Networks\nThisstrategymightlookreasonable,andinfactitisnotsobad! Consideringhowcomputa-\ntionallyundemandingitis,you\u2019dbehardpressedtogetmorebangforyourbuck. However,\nifweputasideefficiencyforaminute,itmightseemmorereasonabletosearchforthe most\nlikelysequence , not the sequence of (greedily selected) mostlikelytokens . It turns out that\nthesetwoobjectscanbequitedifferent. Themostlikelysequenceistheonethatmaximizes\nthe expression\u00ce\ud835\udc470\n\ud835\udc610=1\ud835\udc43\u00b9\ud835\udc66\ud835\udc610j\ud835\udc661,...,\ud835\udc66\ud835\udc610\u00001,c\u00ba. In our machine translation example, if the\ndecoder truly recovered the probabilities of the underlying generative process, then this\nwould give us the most likely translation. Unfortunately, there is no guarantee that greedy\nsearch will give us this sequence.\nLet\u2019s illustrate it with an example. Suppose that there are four tokens \u201cA\u201d, \u201cB\u201d, \u201cC\u201d, and\n\u201c<eos>\u201dintheoutputdictionary. In Fig.10.8.1 ,thefournumbersundereachtimesteprep-\nresent the conditional probabilities of generating \u201cA\u201d, \u201cB\u201d, \u201cC\u201d, and \u201c<eos>\u201d respectively,\nat that time step.\ntFig. 10.8.1 At each time step, greedy search selects the token with the highest conditional probability.\nAt each time step, greedy search selects the token with the highest conditional probability.\nTherefore, the output sequence \u201cA\u201d, \u201cB\u201d, \u201cC\u201d, and \u201c<eos>\u201d will be predicted ( Fig. 10.8.1 ).\nTheconditionalprobabilityofthisoutputsequenceis 0.5\u00020.4\u00020.4\u00020.6=0.048.\nNext, let\u2019s look at another example in Fig. 10.8.2 . Unlike in Fig. 10.8.1 , at time step 2 we\nselect the token \u201cC\u201d, which has the secondhighest conditional probability.\ntFig. 10.8.2 The four numbers under each time step represent the conditional probabilities of\ngenerating \u201cA\u201d, \u201cB\u201d, \u201cC\u201d, and \u201c<eos>\u201d at that time step. At time step 2, the token \u201cC\u201d,\nwhich has the second highest conditional probability, is selected.\nSince the output subsequences at time steps 1 and 2, on which time step 3 is based, have\nchanged from \u201cA\u201d and \u201cB\u201d in Fig. 10.8.1 to \u201cA\u201d and \u201cC\u201d in Fig. 10.8.2 , the conditional\nprobability of each token at time step 3 has also changed in Fig. 10.8.2 . Suppose that\nwe choose the token \u201cB\u201d at time step 3. Now time step 4 is conditional on the output\nsubsequence at the first three time steps \u201cA\u201d, \u201cC\u201d, and \u201cB\u201d, which has changed from \u201cA\u201d,\n\u201cB\u201d,and\u201cC\u201din Fig.10.8.1 . Therefore,theconditionalprobabilityofgeneratingeachtoken\nat time step 4 in Fig. 10.8.2 is also different from that in Fig. 10.8.1 . As a result, the\nconditional probability of the output sequence \u201cA\u201d, \u201cC\u201d, \u201cB\u201d, and \u201c<eos>\u201d in Fig. 10.8.2\nis0.5\u00020.3\u00020.6\u00020.6=0.054, which is greater than that of greedy search in Fig.", "mimetype": "text/plain", "start_char_idx": 944893, "end_char_idx": 948199, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "22496963-c3cb-4862-9f0b-1fe966848a5d": {"__data__": {"id_": "22496963-c3cb-4862-9f0b-1fe966848a5d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "686b03ab-70bb-429b-8d44-d424fefb7c67", "node_type": "1", "metadata": {}, "hash": "f2d7e8a340dd4e583185160149e5ea1c138130915eddd2015a730321ecb00f2a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cb51740e-e8a1-4c57-a871-aee89c774c85", "node_type": "1", "metadata": {}, "hash": "f033417e92d469666b7c84ac57375e10f86bf54e73dca8963a57a9788c339e3d", "class_name": "RelatedNodeInfo"}}, "text": "10.8.2 . Suppose that\nwe choose the token \u201cB\u201d at time step 3. Now time step 4 is conditional on the output\nsubsequence at the first three time steps \u201cA\u201d, \u201cC\u201d, and \u201cB\u201d, which has changed from \u201cA\u201d,\n\u201cB\u201d,and\u201cC\u201din Fig.10.8.1 . Therefore,theconditionalprobabilityofgeneratingeachtoken\nat time step 4 in Fig. 10.8.2 is also different from that in Fig. 10.8.1 . As a result, the\nconditional probability of the output sequence \u201cA\u201d, \u201cC\u201d, \u201cB\u201d, and \u201c<eos>\u201d in Fig. 10.8.2\nis0.5\u00020.3\u00020.6\u00020.6=0.054, which is greater than that of greedy search in Fig. 10.8.1 .\n407 Beam Search\nIn this example, the output sequence \u201cA\u201d, \u201cB\u201d, \u201cC\u201d, and \u201c<eos>\u201d obtained by the greedy\nsearch is not optimal.\n10.8.2ExhaustiveSearch\nIf the goal is to obtain the most likely sequence, we may consider using exhaustivesearch :\nenumerate all the possible output sequences with their conditional probabilities, and then\noutput the one that scores the highest predicted probability.\nWhile this would certainly give us what we desire, it would come at a prohibitive com-\nputational cost ofO\u00b9jYj\ud835\udc470\u00ba, exponential in the sequence length and with an enormous\nbase given by the vocabulary size. For example, when jYj=10000and\ud835\udc470=10, both\nsmall numbers when compared with ones in real applications, we will need to evaluate\n1000010=1040sequences, which is already beyond the capabilities of any foreseeable\ncomputers. Ontheotherhand,thecomputationalcostofgreedysearchis O\u00b9jYj\ud835\udc470\u00ba: mirac-\nulously cheap but far from optimal. For example, when jYj=10000and\ud835\udc470=10, we only\nneed to evaluate 10000\u000210=105sequences.\n10.8.3Beam Search\nYou could view sequence decoding strategies as lying on a spectrum, with beam search\nstriking a compromise between the efficiency of greedy search and the optimality of ex-\nhaustive search. The most straightforward version of beam search is characterized by a\nsingle hyperparameter, the beam size ,\ud835\udc58. Let\u2019s explain this terminology. At time step 1,\nwe select the \ud835\udc58tokens with the highest predicted probabilities. Each of them will be the\nfirst token of \ud835\udc58candidate output sequences, respectively. At each subsequent time step,\nbased on the \ud835\udc58candidate output sequences at the previous time step, we continue to select\n\ud835\udc58candidate output sequences with the highest predicted probabilities from \ud835\udc58jYjpossible\nchoices.\ntFig. 10.8.3 The process of beam search (beam size =2; maximum length of an output sequence =3).\nThe candidate output sequences are A,C,AB,CE,ABD , and CED .\nFig. 10.8.3 demonstrates the process of beam search with an example. Suppose that the\noutput vocabulary contains only five elements: Y=f\ud835\udc34,\ud835\udc35,\ud835\udc36,\ud835\udc37,\ud835\udc38g, where one of them is\n408 Modern Recurrent Neural Networks\n153\u201c<eos>\u201d. Letthebeamsizebetwoandthemaximumlengthofanoutputsequencebethree.\nAt time step 1, suppose that the tokens with the highest conditional probabilities \ud835\udc43\u00b9\ud835\udc661jc\u00ba\nare\ud835\udc34and\ud835\udc36. At time step 2, for all \ud835\udc6622Y,we compute\n\ud835\udc43\u00b9\ud835\udc34,\ud835\udc66 2jc\u00ba=\ud835\udc43\u00b9\ud835\udc34jc\u00ba\ud835\udc43\u00b9\ud835\udc662j\ud835\udc34,c\u00ba,\n\ud835\udc43\u00b9\ud835\udc36,\ud835\udc66 2jc\u00ba=\ud835\udc43\u00b9\ud835\udc36jc\u00ba\ud835\udc43\u00b9\ud835\udc662j\ud835\udc36,c\u00ba,(10.8.2)\nand pick the largest two among these ten values, say \ud835\udc43\u00b9\ud835\udc34,\ud835\udc35jc\u00baand\ud835\udc43\u00b9\ud835\udc36,\ud835\udc38jc\u00ba.", "mimetype": "text/plain", "start_char_idx": 947663, "end_char_idx": 950669, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cb51740e-e8a1-4c57-a871-aee89c774c85": {"__data__": {"id_": "cb51740e-e8a1-4c57-a871-aee89c774c85", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "22496963-c3cb-4862-9f0b-1fe966848a5d", "node_type": "1", "metadata": {}, "hash": "cc1faa7fcb5390089a4b610048daf37ab22e0d1eafb1d6384cf936d2c775ba0d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "aca14484-b9db-427d-ba59-9993f6cce0f3", "node_type": "1", "metadata": {}, "hash": "54cd53783c3589549ed64768cd704de6e05a5f0630c644b00269091d360cf7bd", "class_name": "RelatedNodeInfo"}}, "text": "Letthebeamsizebetwoandthemaximumlengthofanoutputsequencebethree.\nAt time step 1, suppose that the tokens with the highest conditional probabilities \ud835\udc43\u00b9\ud835\udc661jc\u00ba\nare\ud835\udc34and\ud835\udc36. At time step 2, for all \ud835\udc6622Y,we compute\n\ud835\udc43\u00b9\ud835\udc34,\ud835\udc66 2jc\u00ba=\ud835\udc43\u00b9\ud835\udc34jc\u00ba\ud835\udc43\u00b9\ud835\udc662j\ud835\udc34,c\u00ba,\n\ud835\udc43\u00b9\ud835\udc36,\ud835\udc66 2jc\u00ba=\ud835\udc43\u00b9\ud835\udc36jc\u00ba\ud835\udc43\u00b9\ud835\udc662j\ud835\udc36,c\u00ba,(10.8.2)\nand pick the largest two among these ten values, say \ud835\udc43\u00b9\ud835\udc34,\ud835\udc35jc\u00baand\ud835\udc43\u00b9\ud835\udc36,\ud835\udc38jc\u00ba. Then at\ntime step 3, for all \ud835\udc6632Y, we compute\n\ud835\udc43\u00b9\ud835\udc34,\ud835\udc35,\ud835\udc66 3jc\u00ba=\ud835\udc43\u00b9\ud835\udc34,\ud835\udc35jc\u00ba\ud835\udc43\u00b9\ud835\udc663j\ud835\udc34,\ud835\udc35,c\u00ba,\n\ud835\udc43\u00b9\ud835\udc36,\ud835\udc38,\ud835\udc66 3jc\u00ba=\ud835\udc43\u00b9\ud835\udc36,\ud835\udc38jc\u00ba\ud835\udc43\u00b9\ud835\udc663j\ud835\udc36,\ud835\udc38,c\u00ba,(10.8.3)\nand pick the largest two among these ten values, say \ud835\udc43\u00b9\ud835\udc34,\ud835\udc35,\ud835\udc37jc\u00baand\ud835\udc43\u00b9\ud835\udc36,\ud835\udc38,\ud835\udc37jc\u00ba.\nAs a result, we get six candidates output sequences: (i) \ud835\udc34; (ii)\ud835\udc36; (iii)\ud835\udc34,\ud835\udc35; (iv)\ud835\udc36,\ud835\udc38; (v)\n\ud835\udc34,\ud835\udc35,\ud835\udc37; and (vi)\ud835\udc36,\ud835\udc38,\ud835\udc37.\nIn the end, we obtain the set of final candidate output sequences based on these six se-\nquences (e.g., discard portions including and after \u201c<eos>\u201d). Then we choose the output\nsequence which maximizes the following score:\n1\n\ud835\udc3f\ud835\udefclog\ud835\udc43\u00b9\ud835\udc661,...,\ud835\udc66\ud835\udc3fjc\u00ba=1\n\ud835\udc3f\ud835\udefc\ud835\udc3f\u00d5\n\ud835\udc610=1log\ud835\udc43\u00b9\ud835\udc66\ud835\udc610j\ud835\udc661,...,\ud835\udc66\ud835\udc610\u00001,c\u00ba; (10.8.4)\nhere\ud835\udc3fis the length of the final candidate sequence and \ud835\udefcis usually set to 0.75. Since a\nlonger sequence has more logarithmic terms in the summation of (10.8.4 ), the term\ud835\udc3f\ud835\udefcin\nthe denominator penalizes long sequences.\nThe computational cost of beam search is O\u00b9\ud835\udc58jYj\ud835\udc470\u00ba. This result is in between that of\ngreedy search and that of exhaustive search. Greedy search can be treated as a special case\nof beam search arising when the beam size is set to 1.\n10.8.4Summary\nSequence searching strategies include greedy search, exhaustive search, and beam search.\nBeam search provides a trade-off between accuracy and computational cost via the flexible\nchoice of the beam size.\n10.8.5Exercises\n1.Can we treat exhaustive search as a special type of beam search? Why or why not?\n2.Apply beam search in the machine translation problem in Section 10.7 . How does the\nbeam size affect the translation results and the prediction speed?\n3.Weusedlanguagemodelingforgeneratingtextfollowinguser-providedprefixesin Sec-\ntion 9.5. Which kind of search strategy does it use? Can you improve it?\nDiscussions153.\n11 Attention Mechanisms and Transformers\nThe earliest years of the deep learning boom were driven primarily by results produced us-\ning the multilayer perceptron, convolutional network, and recurrent network architectures.\nRemarkably, the model architectures that underpinned many of deep learning\u2019s break-\nthroughsinthe2010shadchangedremarkablylittlerelativetotheirantecedentsdespitethe\nlapse of nearly 30 years. While plenty of new methodological innovations made their way\ninto most practitioner\u2019s toolkits\u2014ReLU activations, residual layers, batch normalization,\ndropout, and adaptive learning rate schedules come to mind\u2014the core underlying archi-\ntectures were clearly recognizable as scaled-up implementations of classic ideas.", "mimetype": "text/plain", "start_char_idx": 950326, "end_char_idx": 953094, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "aca14484-b9db-427d-ba59-9993f6cce0f3": {"__data__": {"id_": "aca14484-b9db-427d-ba59-9993f6cce0f3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cb51740e-e8a1-4c57-a871-aee89c774c85", "node_type": "1", "metadata": {}, "hash": "f033417e92d469666b7c84ac57375e10f86bf54e73dca8963a57a9788c339e3d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2a3fb042-e61e-4cfb-b057-88c550d50988", "node_type": "1", "metadata": {}, "hash": "3917f6fb819b937d6b76672db3c815b96c3eb5ae36f72ed29c11811bb05f4752", "class_name": "RelatedNodeInfo"}}, "text": "3.Weusedlanguagemodelingforgeneratingtextfollowinguser-providedprefixesin Sec-\ntion 9.5. Which kind of search strategy does it use? Can you improve it?\nDiscussions153.\n11 Attention Mechanisms and Transformers\nThe earliest years of the deep learning boom were driven primarily by results produced us-\ning the multilayer perceptron, convolutional network, and recurrent network architectures.\nRemarkably, the model architectures that underpinned many of deep learning\u2019s break-\nthroughsinthe2010shadchangedremarkablylittlerelativetotheirantecedentsdespitethe\nlapse of nearly 30 years. While plenty of new methodological innovations made their way\ninto most practitioner\u2019s toolkits\u2014ReLU activations, residual layers, batch normalization,\ndropout, and adaptive learning rate schedules come to mind\u2014the core underlying archi-\ntectures were clearly recognizable as scaled-up implementations of classic ideas. Despite\nthousandsofpapersproposingalternativeideas,modelsresemblingclassicalconvolutional\nneural networks ( Chapter 7 ) retained state-of-the-art status in computer vision and models\nresemblingSeppHochreiter\u2019soriginaldesignfortheLSTMrecurrentneuralnetwork( Sec-\ntion 10.1 ), dominated most applications in natural language processing. Arguably, to that\npoint, the rapid emergence of deep learning appeared to be primarily attributable to shifts\nin the available computational resources (thanks to innovations in parallel computing with\nGPUs) and the availability of massive data resources (thanks to cheap storage and Internet\nservices). While these factors may indeed remain the primary drivers behind this technol-\nogy\u2019s increasing power we are also witnessing, at long last, a sea change in the landscape\nof dominant architectures.\nAt the present moment, the dominant models for nearly all natural language processing\ntasks are based on the Transformer architecture. Given any new task in natural language\nprocessing, the default first-pass approach is to grab a large Transformer-based pretrained\nmodel, (e.g., BERT ( Devlinet al., 2018), ELECTRA ( Clarket al., 2020), RoBERTa ( Liu\net al., 2019), or Longformer ( Beltagyet al., 2020)) adapting the output layers as neces-\nsary, and fine-tuning the model on the available data for the downstream task. If you have\nbeen paying attention to the last few years of breathless news coverage centered on Ope-\nnAI\u2019s large language models, then you have been tracking a conversation centered on the\nGPT-2 and GPT-3 Transformer-based models ( Brownet al., 2020,Radfordet al., 2019).\nMeanwhile,thevisionTransformerhasemergedasadefaultmodelfordiversevisiontasks,\nincludingimagerecognition, objectdetection, semanticsegmentation, andsuperresolution\n(Dosovitskiy et al., 2021,Liuet al., 2021). Transformers also showed up as competitive\nmethods for speech recognition ( Gulatiet al., 2020), reinforcement learning ( Chenet al.,\n2021), and graph neural networks ( Dwivedi and Bresson, 2020 ).\nThe core idea behind the Transformer model is the attention mechanism , an innovation\nthat was originally envisioned as an enhancement for encoder\u2013decoder RNNs applied to\n409\n410 Attention Mechanisms and Transformers\nsequence-to-sequence applications, such as machine translations ( Bahdanau et al., 2014).\nYou might recall that in the first sequence-to-sequence models for machine translation\n(Sutskever etal., 2014), theentireinputwascompressedbytheencoderintoasinglefixed-\nlength vector to be fed into the decoder. The intuition behind attention is that rather than\ncompressing the input, it might be better for the decoder to revisit the input sequence at\nevery step. Moreover, rather than always seeing the same representation of the input, one\nmight imagine that the decoder should selectively focus on particular parts of the input se-\nquence at particular decoding steps. Bahdanau\u2019s attention mechanism provided a simple\nmeansbywhichthedecodercoulddynamically attendtodifferentpartsoftheinputateach\ndecoding step. The high-level idea is that the encoder could produce a representation of\nlength equal to the original input sequence. Then, at decoding time, the decoder can (via\nsome control mechanism) receive as input a context vector consisting of a weighted sum\nof the representations on the input at each time step. Intuitively, the weights determine the\nextent to which each step\u2019s context \u201cfocuses\u201d on each input token, and the key is to make\nthis process for assigning the weights differentiable so that it can be learned along with all\nof the other neural network parameters.", "mimetype": "text/plain", "start_char_idx": 952193, "end_char_idx": 956719, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2a3fb042-e61e-4cfb-b057-88c550d50988": {"__data__": {"id_": "2a3fb042-e61e-4cfb-b057-88c550d50988", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "aca14484-b9db-427d-ba59-9993f6cce0f3", "node_type": "1", "metadata": {}, "hash": "54cd53783c3589549ed64768cd704de6e05a5f0630c644b00269091d360cf7bd", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "da56cccc-2bea-4768-8250-b36246416785", "node_type": "1", "metadata": {}, "hash": "1920519ae843209f4e9268546db59dbdc7eb80a8c2d72ac90768ba875c3dd051", "class_name": "RelatedNodeInfo"}}, "text": "Moreover, rather than always seeing the same representation of the input, one\nmight imagine that the decoder should selectively focus on particular parts of the input se-\nquence at particular decoding steps. Bahdanau\u2019s attention mechanism provided a simple\nmeansbywhichthedecodercoulddynamically attendtodifferentpartsoftheinputateach\ndecoding step. The high-level idea is that the encoder could produce a representation of\nlength equal to the original input sequence. Then, at decoding time, the decoder can (via\nsome control mechanism) receive as input a context vector consisting of a weighted sum\nof the representations on the input at each time step. Intuitively, the weights determine the\nextent to which each step\u2019s context \u201cfocuses\u201d on each input token, and the key is to make\nthis process for assigning the weights differentiable so that it can be learned along with all\nof the other neural network parameters.\nInitially, the idea was a remarkably successful enhancement to the recurrent neural net-\nworks that already dominated machine translation applications. The models performed\nbetterthantheoriginalencoder\u2013decodersequence-to-sequencearchitectures. Furthermore,\nresearchers noted that some nice qualitative insights sometimes emerged from inspecting\nthe pattern of attention weights. In translation tasks, attention models often assigned high\nattention weights to cross-lingual synonyms when generating the corresponding words in\nthe target language. For example, when translating the sentence \u201cmy feet hurt\u201d to \u201cj\u2019ai mal\nau pieds\u201d, the neural network might assign high attention weights to the representation of\n\u201cfeet\u201d when generating the corresponding French word \u201cpieds\u201d. These insights spurred\nclaims that attention models confer \u201cinterpretability\u201d although what precisely the atten-\ntion weights mean\u2014i.e., how, if at all, they should be interpreted remains a hazy research\ntopic.\nHowever, attention mechanisms soon emerged as more significant concerns, beyond their\nusefulnessasanenhancementforencoder\u2013decoderrecurrentneuralnetworksandtheirpu-\ntative usefulness for picking out salient inputs. Vaswani et al.(2017) proposed the Trans-\nformer architecture for machine translation, dispensing with recurrent connections alto-\ngether, and instead relying on cleverly arranged attention mechanisms to capture all rela-\ntionshipsamonginputandoutputtokens. Thearchitectureperformedremarkablywell,and\nby 2018 the Transformer began showing up in the majority of state-of-the-art natural lan-\nguageprocessingsystems. Moreover,atthesametime,thedominantpracticeinnaturallan-\nguage processing became to pretrain large-scale models on enormous generic background\ncorpora to optimize some self-supervised pretraining objective, and then to fine-tune these\nmodelsusingtheavailabledownstreamdata. ThegapbetweenTransformersandtraditional\narchitectures grew especially wide when applied in this pretraining paradigm, and thus the\nascendance of Transformers coincided with the ascendence of such large-scale pretrained\nmodels, now sometimes called foundationmodels (Bommasani etal., 2021).\nIn this chapter, we introduce attention models, starting with the most basic intuitions and\n411 Queries, Keys, and Values\nthe simplest instantiations of the idea. We then work our way up to the Transformer archi-\ntecture,thevisionTransformer,andthelandscapeofmodernTransformer-basedpretrained\nmodels.\n11.1Queries, Keys,and Values\nSo far all the networks we have reviewed crucially relied on the input being of a well-\ndefined size. For instance, the images in ImageNet are of size 224\u0002224pixels and CNNs\nare specifically tuned to this size. Even in natural language processing the input size for\nRNNs is well defined and fixed. Variable size is addressed by sequentially processing one\ntoken at a time, or by specially designed convolution kernels ( Kalchbrenner et al., 2014).\nThis approach can lead to significant problems when the input is truly of varying size with\nvaryinginformationcontent,suchasin Section10.7 inthetransformationoftext( Sutskever\net al., 2014). In particular, for long sequences it becomes quite difficult to keep track of\neverything that has already been generated or even viewed by the network. Even explicit\ntrackingheuristicssuchasproposedbyYang etal.(2016)onlyofferlimitedbenefit.\nComparethistodatabases. Intheirsimplestformtheyarecollectionsofkeys( \ud835\udc58)andvalues\n(\ud835\udc63).", "mimetype": "text/plain", "start_char_idx": 955800, "end_char_idx": 960187, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "da56cccc-2bea-4768-8250-b36246416785": {"__data__": {"id_": "da56cccc-2bea-4768-8250-b36246416785", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2a3fb042-e61e-4cfb-b057-88c550d50988", "node_type": "1", "metadata": {}, "hash": "3917f6fb819b937d6b76672db3c815b96c3eb5ae36f72ed29c11811bb05f4752", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e280d9a0-0a5a-41c6-a5ca-eb2e8972f2db", "node_type": "1", "metadata": {}, "hash": "69e4dc35e052d1d85f2059253fba19ff204e30c7063cecdb50e18d5950cc2cb7", "class_name": "RelatedNodeInfo"}}, "text": "Even in natural language processing the input size for\nRNNs is well defined and fixed. Variable size is addressed by sequentially processing one\ntoken at a time, or by specially designed convolution kernels ( Kalchbrenner et al., 2014).\nThis approach can lead to significant problems when the input is truly of varying size with\nvaryinginformationcontent,suchasin Section10.7 inthetransformationoftext( Sutskever\net al., 2014). In particular, for long sequences it becomes quite difficult to keep track of\neverything that has already been generated or even viewed by the network. Even explicit\ntrackingheuristicssuchasproposedbyYang etal.(2016)onlyofferlimitedbenefit.\nComparethistodatabases. Intheirsimplestformtheyarecollectionsofkeys( \ud835\udc58)andvalues\n(\ud835\udc63). For instance, our database Dmight consist of tuples {(\u201cZhang\u201d, \u201cAston\u201d), (\u201cLipton\u201d,\n\u201cZachary\u201d), (\u201cLi\u201d, \u201cMu\u201d), (\u201cSmola\u201d, \u201cAlex\u201d), (\u201cHu\u201d, \u201cRachel\u201d), (\u201cWerness\u201d, \u201cBrent\u201d)}\nwith the last name being the key and the first name being the value. We can operate on\nD, for instance with the exact query ( \ud835\udc5e) for \u201cLi\u201d which would return the value \u201cMu\u201d. If\n(\u201cLi\u201d, \u201cMu\u201d) was not a record in D, there would be no valid answer. If we also allowed for\napproximate matches, we would retrieve (\u201cLipton\u201d, \u201cZachary\u201d) instead. This quite simple\nand trivial example nonetheless teaches us a number of useful things:\n\u000fWe can design queries \ud835\udc5ethat operate on ( \ud835\udc58,\ud835\udc63) pairs in such a manner as to be valid\nregardless of the database size.\n\u000fThe same query can receive different answers, according to the contents of the database.\n\u000fThe\u201ccode\u201dbeingexecutedforoperatingonalargestatespace(thedatabase)canbequite\nsimple (e.g., exact match, approximate match, top- \ud835\udc58).\n\u000fThere is no need to compress or simplify the database to make the operations effective.\nClearly we would not have introduced a simple database here if it wasn\u2019t for the purpose of\nexplainingdeeplearning. Indeed,thisleadstooneofthemostexcitingconceptsintroduced\nin deep learning in the past decade: the attention mechanism (Bahdanau et al., 2014). We\nwill cover the specifics of its application to machine translation later. For now, simply\nconsider the following: denote by Ddef=f\u00b9k1,v1\u00ba,...\u00b9k\ud835\udc5a,v\ud835\udc5a\u00baga database of \ud835\udc5atuples of\nkeysandvalues. Moreover, denote by qaquery. Then we can define the attention overD\n412 Attention Mechanisms and Transformers\nas\nAttention\u00b9q,D\u00badef=\ud835\udc5a\u00d5\n\ud835\udc56=1\ud835\udefc\u00b9q,k\ud835\udc56\u00bav\ud835\udc56, (11.1.1)\nwhere\ud835\udefc\u00b9q,k\ud835\udc56\u00ba 2R(\ud835\udc56=1,...,\ud835\udc5a) are scalar attention weights. The operation itself is\ntypically referred to as attentionpooling . The name attention derives from the fact that the\noperation pays particular attention to the terms for which the weight \ud835\udefcis significant (i.e.,\nlarge). As such, the attention over Dgenerates a linear combination of values contained in\nthe database. In fact, this contains the above example as a special case where all but one\nweight is zero. We have a number of special cases:\n\u000fTheweights \ud835\udefc\u00b9q,k\ud835\udc56\u00baarenonnegative. Inthiscasetheoutputoftheattentionmechanism\nis contained in the convex cone spanned by the values v\ud835\udc56.\n\u000fTheweights \ud835\udefc\u00b9q,k\ud835\udc56\u00baformaconvexcombination,i.e.,\u00cd\n\ud835\udc56\ud835\udefc\u00b9q,k\ud835\udc56\u00ba=1and\ud835\udefc\u00b9q,k\ud835\udc56\u00ba\u00150\nfor all\ud835\udc56. This is the most common setting in deep learning.\n\u000fExactlyoneoftheweights \ud835\udefc\u00b9q,k\ud835\udc56\u00bais1,whileallothersare 0. Thisisakintoatraditional\ndatabase query.\n\u000fAll weights are equal, i.e., \ud835\udefc\u00b9q,k\ud835\udc56\u00ba=1\n\ud835\udc5afor all\ud835\udc56. This amounts to averaging across the\nentire database, also called average pooling in deep learning.", "mimetype": "text/plain", "start_char_idx": 959433, "end_char_idx": 962835, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e280d9a0-0a5a-41c6-a5ca-eb2e8972f2db": {"__data__": {"id_": "e280d9a0-0a5a-41c6-a5ca-eb2e8972f2db", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "da56cccc-2bea-4768-8250-b36246416785", "node_type": "1", "metadata": {}, "hash": "1920519ae843209f4e9268546db59dbdc7eb80a8c2d72ac90768ba875c3dd051", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "01c47f2a-a1f1-4616-83c6-ec0fb4db2179", "node_type": "1", "metadata": {}, "hash": "471a6f9c8897b141e935844f71ec36626384b0fec2e65f0294d60b349b2c17c0", "class_name": "RelatedNodeInfo"}}, "text": "Inthiscasetheoutputoftheattentionmechanism\nis contained in the convex cone spanned by the values v\ud835\udc56.\n\u000fTheweights \ud835\udefc\u00b9q,k\ud835\udc56\u00baformaconvexcombination,i.e.,\u00cd\n\ud835\udc56\ud835\udefc\u00b9q,k\ud835\udc56\u00ba=1and\ud835\udefc\u00b9q,k\ud835\udc56\u00ba\u00150\nfor all\ud835\udc56. This is the most common setting in deep learning.\n\u000fExactlyoneoftheweights \ud835\udefc\u00b9q,k\ud835\udc56\u00bais1,whileallothersare 0. Thisisakintoatraditional\ndatabase query.\n\u000fAll weights are equal, i.e., \ud835\udefc\u00b9q,k\ud835\udc56\u00ba=1\n\ud835\udc5afor all\ud835\udc56. This amounts to averaging across the\nentire database, also called average pooling in deep learning.\nAcommonstrategyforensuringthattheweightssumupto 1istonormalizethemvia\n\ud835\udefc\u00b9q,k\ud835\udc56\u00ba=\ud835\udefc\u00b9q,k\ud835\udc56\u00ba\u00cd\n\ud835\udc57\ud835\udefc\u00b9q,k\ud835\udc57\u00ba. (11.1.2)\nIn particular, to ensure that the weights are also nonnegative, one can resort to exponenti-\nation. This means that we can now pick anyfunction\ud835\udc4e\u00b9q,k\u00baand then apply the softmax\noperation used for multinomial models to it via\n\ud835\udefc\u00b9q,k\ud835\udc56\u00ba=exp\u00b9\ud835\udc4e\u00b9q,k\ud835\udc56\u00ba\u00ba\u00cd\n\ud835\udc57exp\u00b9\ud835\udc4e\u00b9q,k\ud835\udc57\u00ba\u00ba. (11.1.3)\nThis operation is readily available in all deep learning frameworks. It is differentiable and\nits gradient never vanishes, all of which are desirable properties in a model. Note though,\nthe attention mechanism introduced above is not the only option. For instance, we can\ndesignanon-differentiableattentionmodelthatcanbetrainedusingreinforcementlearning\nmethods( Mnihetal., 2014). Asonewouldexpect, trainingsuchamodelisquitecomplex.\nConsequentlythebulkofmodernattentionresearchfollowstheframeworkoutlinedin Fig.\n11.1.1. We thus focus our exposition on this family of differentiable mechanisms.\nWhatisquiteremarkableisthattheactual\u201ccode\u201dforexecutingonthesetofkeysandvalues,\nnamely the query, can be quite concise, even though the space to operate on is significant.\nThisisadesirablepropertyforanetworklayerasitdoesnotrequiretoomanyparametersto\nlearn. Just as convenient is the fact that attention can operate on arbitrarily large databases\nwithout the need to change the way the attention pooling operation is performed.\n413 Queries, Keys, and Values\ntFig. 11.1.1 The attention mechanism computes a linear combination over values vivia attention\npooling, where weights are derived according to the compatibility between a query qand\nkeyski.\nimport torch\nfrom d2l import torch asd2l\n11.1.1Visualization\nOne of the benefits of the attention mechanism is that it can be quite intuitive, particularly\nwhen the weights are nonnegative and sum to 1. In this case we might interpret large\nweights as a way for the model to select components of relevance. While this is a good\nintuition, it is important to remember that it is just that, an intuition . Regardless, we may\nwant to visualize its effect on the given set of keys when applying a variety of different\nqueries. This function will come in handy later.\nWethusdefinethe show_heatmaps function. Notethatitdoesnottakeamatrix(ofattention\nweights) as its input but rather a tensor with four axes, allowing for an array of different\nqueries and weights. Consequently the input matrices has the shape (number of rows\nfor display, number of columns for display, number of queries, number of keys). This\nwill come in handy later on when we want to visualize the workings that are to design\nTransformers.\n#@save\ndef show_heatmaps (matrices, xlabel, ylabel, titles =None , figsize =(2.5,2.5),\ncmap ='Reds '):\n\"\"\"Show heatmaps of matrices.\"\"\"", "mimetype": "text/plain", "start_char_idx": 962355, "end_char_idx": 965592, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "01c47f2a-a1f1-4616-83c6-ec0fb4db2179": {"__data__": {"id_": "01c47f2a-a1f1-4616-83c6-ec0fb4db2179", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e280d9a0-0a5a-41c6-a5ca-eb2e8972f2db", "node_type": "1", "metadata": {}, "hash": "69e4dc35e052d1d85f2059253fba19ff204e30c7063cecdb50e18d5950cc2cb7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9c36a244-cc03-41e5-8673-1b2ba7311e92", "node_type": "1", "metadata": {}, "hash": "b43bddc730aeb136e35ca6c4e629c77d5797081ce1e9f8bb6cce12c0858e1111", "class_name": "RelatedNodeInfo"}}, "text": "Regardless, we may\nwant to visualize its effect on the given set of keys when applying a variety of different\nqueries. This function will come in handy later.\nWethusdefinethe show_heatmaps function. Notethatitdoesnottakeamatrix(ofattention\nweights) as its input but rather a tensor with four axes, allowing for an array of different\nqueries and weights. Consequently the input matrices has the shape (number of rows\nfor display, number of columns for display, number of queries, number of keys). This\nwill come in handy later on when we want to visualize the workings that are to design\nTransformers.\n#@save\ndef show_heatmaps (matrices, xlabel, ylabel, titles =None , figsize =(2.5,2.5),\ncmap ='Reds '):\n\"\"\"Show heatmaps of matrices.\"\"\"\nd2l.use_svg_display()\nnum_rows, num_cols, _, _ =matrices .shape\nfig, axes =d2l.plt.subplots(num_rows, num_cols, figsize =figsize,\nsharex =True , sharey =True , squeeze =False )\nfor i, (row_axes, row_matrices) inenumerate (zip(axes, matrices)):\nfor j, (ax, matrix) inenumerate (zip(row_axes, row_matrices)):\npcm =ax.imshow(matrix .detach() .numpy(), cmap =cmap)\nifi==num_rows -1:\nax.set_xlabel(xlabel)\nifj==0:\nax.set_ylabel(ylabel)\niftitles:\n(continues on next page)\n414 Attention Mechanisms and Transformers\n(continued from previous page)\nax.set_title(titles[j])\nfig.colorbar(pcm, ax =axes, shrink =0.6);\nAs a quick sanity check let\u2019s visualize the identity matrix, representing a case where the\nattention weight is 1only when the query and the key are the same.\nattention_weights =torch .eye( 10).reshape(( 1,1,10,10))\nshow_heatmaps(attention_weights, xlabel ='Keys ', ylabel ='Queries ')\n11.1.2Summary\nThe attention mechanism allows us to aggregate data from many (key, value) pairs. So\nfar our discussion was quite abstract, simply describing a way to pool data. We have not\nexplained yet where those mysterious queries, keys, and values might arise from. Some\nintuition might help here: for instance, in a regression setting, the query might correspond\nto the location where the regression should be carried out. The keys are the locations\nwhere past data was observed and the values are the (regression) values themselves. This\nis the so-called Nadaraya\u2013Watson estimator ( Nadaraya, 1964 ,Watson, 1964 ) that we will\nbe studying in the next section.\nBy design, the attention mechanism provides a differentiable means of control by which a\nneural network can select elements from a set and to construct an associated weighted sum\nover representations.\n11.1.3Exercises\n1.Suppose that you wanted to reimplement approximate (key, query) matches as used in\nclassical databases, which attention function would you pick?\n2.Suppose that the attention function is given by \ud835\udc4e\u00b9q,k\ud835\udc56\u00ba=q>k\ud835\udc56and that k\ud835\udc56=v\ud835\udc56for\n\ud835\udc56=1,...,\ud835\udc5a. Denote by \ud835\udc5d\u00b9k\ud835\udc56;q\u00bathe probability distribution over keys when using the\nsoftmax normalization in (11.1.3 ). Prove thatrqAttention\u00b9q,D\u00ba=Cov\ud835\udc5d\u00b9k\ud835\udc56;q\u00ba\u00bbk\ud835\udc56\u00bc.\n3.Design a differentiable search engine using the attention mechanism.\n4.ReviewthedesignoftheSqueezeandExcitationNetworks( Huetal.,2018)andinterpret\nthem through the lens of the attention mechanism.\n415 Attention Pooling by Similarity\n154\n155Discussions154.\n11.2Attention PoolingbySimilarity\nNow that we have introduced the primary components of the attention mechanism, let\u2019s\nuse them in a rather classical setting, namely regression and classification via kernel den-\nsity estimation ( Nadaraya, 1964 ,Watson, 1964 ). This detour simply provides additional\nbackground: it is entirely optional and can be skipped if needed.", "mimetype": "text/plain", "start_char_idx": 964856, "end_char_idx": 968377, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9c36a244-cc03-41e5-8673-1b2ba7311e92": {"__data__": {"id_": "9c36a244-cc03-41e5-8673-1b2ba7311e92", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "01c47f2a-a1f1-4616-83c6-ec0fb4db2179", "node_type": "1", "metadata": {}, "hash": "471a6f9c8897b141e935844f71ec36626384b0fec2e65f0294d60b349b2c17c0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "35105674-9e76-4f82-833f-80ecdddd75f7", "node_type": "1", "metadata": {}, "hash": "dfd0e601a3b29736761fbd0d338273182b878c74f61de03c87a38ee8be30ca82", "class_name": "RelatedNodeInfo"}}, "text": "Prove thatrqAttention\u00b9q,D\u00ba=Cov\ud835\udc5d\u00b9k\ud835\udc56;q\u00ba\u00bbk\ud835\udc56\u00bc.\n3.Design a differentiable search engine using the attention mechanism.\n4.ReviewthedesignoftheSqueezeandExcitationNetworks( Huetal.,2018)andinterpret\nthem through the lens of the attention mechanism.\n415 Attention Pooling by Similarity\n154\n155Discussions154.\n11.2Attention PoolingbySimilarity\nNow that we have introduced the primary components of the attention mechanism, let\u2019s\nuse them in a rather classical setting, namely regression and classification via kernel den-\nsity estimation ( Nadaraya, 1964 ,Watson, 1964 ). This detour simply provides additional\nbackground: it is entirely optional and can be skipped if needed. At their core, Nadaraya\u2013\nWatsonestimatorsrelyonsomesimilaritykernel \ud835\udefc\u00b9q,k\u00barelatingqueries qtokeys k. Some\ncommon kernels are\n\ud835\udefc\u00b9q,k\u00ba=exp\u0012\n\u00001\n2kq\u0000kk2\u0013\nGaussian;\n\ud835\udefc\u00b9q,k\u00ba=1ifkq\u0000kk\u00141 Boxcar;\n\ud835\udefc\u00b9q,k\u00ba=max\u00b90,1\u0000kq\u0000kk\u00baEpanechikov.(11.2.1)\nThere are many more choices that we could pick. See a Wikipedia article155for a more\nextensivereviewandhowthechoiceofkernelsisrelatedtokerneldensityestimation,some-\ntimes also called Parzen Windows (Parzen, 1957 ). All of the kernels are heuristic and can\nbe tuned. For instance, we can adjust the width, not only on a global basis but even on a\nper-coordinate basis. Regardless, all of them lead to the following equation for regression\nand classification alike:\n\ud835\udc53\u00b9q\u00ba=\u00d5\n\ud835\udc56v\ud835\udc56\ud835\udefc\u00b9q,k\ud835\udc56\u00ba\u00cd\n\ud835\udc57\ud835\udefc\u00b9q,k\ud835\udc57\u00ba. (11.2.2)\nInthecaseofa(scalar)regressionwithobservations \u00b9x\ud835\udc56,\ud835\udc66\ud835\udc56\u00baforfeaturesandlabelsrespec-\ntively, v\ud835\udc56=\ud835\udc66\ud835\udc56are scalars, k\ud835\udc56=x\ud835\udc56are vectors, and the query qdenotes the new location\nwhere\ud835\udc53should be evaluated. In the case of (multiclass) classification, we use one-hot-\nencoding of \ud835\udc66\ud835\udc56to obtain v\ud835\udc56. One of the convenient properties of this estimator is that it re-\nquiresnotraining. Evenmoreso, ifwesuitablynarrowthekernelwithincreasingamounts\nof data, the approach is consistent ( Mack and Silverman, 1982 ), i.e., it will converge to\nsome statistically optimal solution. Let\u2019s start by inspecting some kernels.\nimport numpy asnp\nimport torch\nfrom torch import nn\nfrom torch .nnimport functional asF\nfrom d2l import torch asd2l\nd2l.use_svg_display()\n11.2.1Kernelsand Data\nAll the kernels \ud835\udefc\u00b9k,q\u00badefined in this section are translation and rotation invariant ; that\nis, if we shift and rotate kandqin the same manner, the value of \ud835\udefcremains unchanged.\n416 Attention Mechanisms and Transformers\nFor simplicity we thus pick scalar arguments \ud835\udc58,\ud835\udc5e2Rand pick the key \ud835\udc58=0as the origin.\nThis yields:\n# Define some kernels\ndef gaussian (x):\nreturn torch .exp( -x**2/2)\ndef boxcar (x):\nreturn torch .abs(x) <1.0\ndef constant (x):\nreturn 1.0 +0*x\ndef epanechikov (x):\nreturn torch .max( 1-torch .abs(x), torch .zeros_like(x))\nfig, axes =d2l.plt.subplots( 1,4, sharey =True , figsize =(12,3))\nkernels =(gaussian, boxcar, constant, epanechikov)\nnames =('Gaussian ','Boxcar ','Constant ','Epanechikov ')\nx=torch .arange( -2.5,2.5,0.1)\nfor kernel, name, ax inzip(kernels, names, axes):\nax.plot(x .detach() .numpy(), kernel(x) .detach() .numpy())\nax.set_xlabel(name)\nd2l.plt.show()\nDifferent kernels correspond to different notions of range and smoothness.", "mimetype": "text/plain", "start_char_idx": 967710, "end_char_idx": 970827, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "35105674-9e76-4f82-833f-80ecdddd75f7": {"__data__": {"id_": "35105674-9e76-4f82-833f-80ecdddd75f7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9c36a244-cc03-41e5-8673-1b2ba7311e92", "node_type": "1", "metadata": {}, "hash": "b43bddc730aeb136e35ca6c4e629c77d5797081ce1e9f8bb6cce12c0858e1111", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "67c5803b-8cba-421c-8449-d0838698e7ae", "node_type": "1", "metadata": {}, "hash": "eb8b993d229fc2ee116c67fa70bdbb2101b14bee83c10ee15c57cbf46cc7a709", "class_name": "RelatedNodeInfo"}}, "text": "For instance,\nthe boxcar kernel only attends to observations within a distance of 1(or some otherwise\ndefined hyperparameter) and does so indiscriminately.\nTo see Nadaraya\u2013Watson estimation in action, let\u2019s define some training data. In the fol-\nlowing we use the dependency\n\ud835\udc66\ud835\udc56=2 sin\u00b9\ud835\udc65\ud835\udc56\u00ba\u00b8\ud835\udc65\ud835\udc56\u00b8\ud835\udf16, (11.2.3)\nwhere\ud835\udf16is drawn from a normal distribution with zero mean and unit variance. We draw\n40 training examples.\n417 Attention Pooling by Similarity\ndef f(x):\nreturn 2*torch .sin(x) +x\nn=40\nx_train, _ =torch .sort(torch .rand(n) *5)\ny_train =f(x_train) +torch .randn(n)\nx_val =torch .arange( 0,5,0.1)\ny_val =f(x_val)\n11.2.2AttentionPoolingvia Nadaraya\u2013WatsonRegression\nNow that we have data and kernels, all we need is a function that computes the kernel\nregression estimates. Note that we also want to obtain the relative kernel weights in order\ntoperformsomeminordiagnostics. Hencewefirstcomputethekernelbetweenalltraining\nfeatures(covariates) x_train andallvalidationfeatures x_val. Thisyieldsamatrix,which\nwe subsequently normalize. When multiplied with the training labels y_train we obtain\nthe estimates.\nRecall attention pooling in (11.1.1 ). Let each validation feature be a query, and each\ntraining feature\u2013label pair be a key\u2013value pair. As a result, the normalized relative ker-\nnel weights ( attention_w below) are the attentionweights .\ndef nadaraya_watson (x_train, y_train, x_val, kernel):\ndists =x_train .reshape(( -1,1))-x_val .reshape(( 1,-1))\n# Each column/row corresponds to each query/key\nk=kernel(dists) .type(torch .float32)\n# Normalization over keys for each query\nattention_w =k/k.sum( 0)\ny_hat =y_train @attention_w\nreturn y_hat, attention_w\nLet\u2019s have a look at the kind of estimates that the different kernels produce.\ndef plot (x_train, y_train, x_val, y_val, kernels, names, attention =False ):\nfig, axes =d2l.plt.subplots( 1,4, sharey =True , figsize =(12,3))\nfor kernel, name, ax inzip(kernels, names, axes):\ny_hat, attention_w =nadaraya_watson(x_train, y_train, x_val, kernel)\nifattention:\npcm =ax.imshow(attention_w .detach() .numpy(), cmap ='Reds ')\nelse :\nax.plot(x_val, y_hat)\nax.plot(x_val, y_val, 'm--')\nax.plot(x_train, y_train, 'o', alpha =0.5);\nax.set_xlabel(name)\nifnot attention:\nax.legend([ 'y_hat ','y'])\nifattention:\nfig.colorbar(pcm, ax =axes, shrink =0.7)\n418 Attention Mechanisms and Transformers\nplot(x_train, y_train, x_val, y_val, kernels, names)\nThe first thing that stands out is that all three nontrivial kernels (Gaussian, Boxcar, and\nEpanechikov) produce fairly workable estimates that are not too far from the true function.\nOnly the constant kernel that leads to the trivial estimate \ud835\udc53\u00b9\ud835\udc65\u00ba=1\n\ud835\udc5b\u00cd\n\ud835\udc56\ud835\udc66\ud835\udc56produces a rather\nunrealistic result. Let\u2019s inspect the attention weighting a bit more closely:\nplot(x_train, y_train, x_val, y_val, kernels, names, attention =True )\nThe visualization clearly shows why the estimates for Gaussian, Boxcar, and Epanechikov\nare very similar: after all, they are derived from very similar attention weights, despite the\ndifferent functional form of the kernel. This raises the question as to whether this is always\nthe case.\n11.2.3AdaptingAttentionPooling\nWe could replace the Gaussian kernel with one of a different width. That is, we could use\n\ud835\udefc\u00b9q,k\u00ba=exp\u0010\n\u00001\n2\ud835\udf0e2kq\u0000kk2\u0011\nwhere\ud835\udf0e2determines the width of the kernel. Let\u2019s see\nwhether this affects the outcomes.", "mimetype": "text/plain", "start_char_idx": 970828, "end_char_idx": 974170, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "67c5803b-8cba-421c-8449-d0838698e7ae": {"__data__": {"id_": "67c5803b-8cba-421c-8449-d0838698e7ae", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "35105674-9e76-4f82-833f-80ecdddd75f7", "node_type": "1", "metadata": {}, "hash": "dfd0e601a3b29736761fbd0d338273182b878c74f61de03c87a38ee8be30ca82", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cd79b74d-d00f-4c27-b11a-7b3847109b4a", "node_type": "1", "metadata": {}, "hash": "1ac5969c925d2e86e0eb6e8476ed78602c415bb8ed729ede565885316dabc28d", "class_name": "RelatedNodeInfo"}}, "text": "Let\u2019s inspect the attention weighting a bit more closely:\nplot(x_train, y_train, x_val, y_val, kernels, names, attention =True )\nThe visualization clearly shows why the estimates for Gaussian, Boxcar, and Epanechikov\nare very similar: after all, they are derived from very similar attention weights, despite the\ndifferent functional form of the kernel. This raises the question as to whether this is always\nthe case.\n11.2.3AdaptingAttentionPooling\nWe could replace the Gaussian kernel with one of a different width. That is, we could use\n\ud835\udefc\u00b9q,k\u00ba=exp\u0010\n\u00001\n2\ud835\udf0e2kq\u0000kk2\u0011\nwhere\ud835\udf0e2determines the width of the kernel. Let\u2019s see\nwhether this affects the outcomes.\nsigmas =(0.1,0.2,0.5,1)\nnames =['Sigma '+str(sigma) for sigma insigmas]\ndef gaussian_with_width (sigma):\nreturn (lambda x: torch .exp( -x**2/(2*sigma **2)))\nkernels =[gaussian_with_width(sigma) for sigma insigmas]\nplot(x_train, y_train, x_val, y_val, kernels, names)\n419 Attention Pooling by Similarity\nClearly, the narrower the kernel, the less smooth the estimate. At the same time, it adapts\nbetter to the local variations. Let\u2019s look at the corresponding attention weights.\nplot(x_train, y_train, x_val, y_val, kernels, names, attention =True )\nAs we would expect, the narrower the kernel, the narrower the range of large attention\nweights. It is also clear that picking the same width might not be ideal. In fact, Silverman\n(1986) proposed a heuristic that depends on the local density. Many more such \u201ctricks\u201d\nhave been proposed. For instance, Norelli et al.(2022) used a similar nearest-neighbor\ninterpolation technique for designing cross-modal image and text representations.\nTheastutereadermightwonderwhyweareprovidingthisdeepdiveforamethodthatisover\nhalfacenturyold. First,itisoneoftheearliestprecursorsofmodernattentionmechanisms.\nSecond,itisgreatforvisualization. Third,andjustasimportantly,itdemonstratesthelimits\nof hand-crafted attention mechanisms. A much better strategy is to learnthe mechanism,\nby learning the representations for queries and keys. This is what we will embark on in the\nfollowing sections.\n11.2.4Summary\nNadaraya\u2013Watson kernel regression is an early precursor of the current attention mecha-\nnisms. It can be used directly with little to no training or tuning, either for classification or\nregression. The attention weight is assigned according to the similarity (or distance) be-\ntweenqueryandkey,andaccordingtohowmanysimilarobservationsareavailable.\n11.2.5Exercises\n420 Attention Mechanisms and Transformers\n1561.Parzen windows density estimates are given by \u02c6\ud835\udc5d\u00b9x\u00ba=1\n\ud835\udc5b\u00cd\n\ud835\udc56\ud835\udc58\u00b9x,x\ud835\udc56\u00ba. Prove that for\nbinary classification the function \u02c6\ud835\udc5d\u00b9x,\ud835\udc66=1\u00ba\u0000 \u02c6\ud835\udc5d\u00b9x,\ud835\udc66=\u00001\u00ba, as obtained by Parzen\nwindows is equivalent to Nadaraya\u2013Watson classification.\n2.ImplementstochasticgradientdescenttolearnagoodvalueforkernelwidthsinNadaraya\u2013\nWatson regression.\n1.Whathappensifyoujustusetheaboveestimatestominimize \u00b9\ud835\udc53\u00b9xi\u00ba\u0000\ud835\udc66\ud835\udc56\u00ba2directly?\nHint:\ud835\udc66\ud835\udc56is part of the terms used to compute \ud835\udc53.\n2.Remove\u00b9x\ud835\udc56,\ud835\udc66\ud835\udc56\u00bafrom the estimate for \ud835\udc53\u00b9x\ud835\udc56\u00baand optimize over the kernel widths.\nDo you still observe overfitting?\n3.Assume that all xlie on the unit sphere, i.e., all satisfy kxk=1. Can you simplify the\nkx\u0000x\ud835\udc56k2termintheexponential? Hint: wewilllaterseethatthisisverycloselyrelated\nto dot product attention.\n4.RecallthatMackandSilverman( 1982)provedthatNadaraya\u2013Watsonestimationiscon-\nsistent. Howquicklyshouldyoureducethescalefortheattentionmechanismasyouget\nmore data? Provide some intuition for your answer. Does it depend on the dimension-\nality of the data? How?\nDiscussions156.", "mimetype": "text/plain", "start_char_idx": 973519, "end_char_idx": 977043, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cd79b74d-d00f-4c27-b11a-7b3847109b4a": {"__data__": {"id_": "cd79b74d-d00f-4c27-b11a-7b3847109b4a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "67c5803b-8cba-421c-8449-d0838698e7ae", "node_type": "1", "metadata": {}, "hash": "eb8b993d229fc2ee116c67fa70bdbb2101b14bee83c10ee15c57cbf46cc7a709", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "dcb5fb76-14d0-476b-97c5-d4708a8dad4a", "node_type": "1", "metadata": {}, "hash": "a2c4106480870912bcc03575238f982325bf47d15ab1d674d0ac6d27cebe6e1f", "class_name": "RelatedNodeInfo"}}, "text": "2.Remove\u00b9x\ud835\udc56,\ud835\udc66\ud835\udc56\u00bafrom the estimate for \ud835\udc53\u00b9x\ud835\udc56\u00baand optimize over the kernel widths.\nDo you still observe overfitting?\n3.Assume that all xlie on the unit sphere, i.e., all satisfy kxk=1. Can you simplify the\nkx\u0000x\ud835\udc56k2termintheexponential? Hint: wewilllaterseethatthisisverycloselyrelated\nto dot product attention.\n4.RecallthatMackandSilverman( 1982)provedthatNadaraya\u2013Watsonestimationiscon-\nsistent. Howquicklyshouldyoureducethescalefortheattentionmechanismasyouget\nmore data? Provide some intuition for your answer. Does it depend on the dimension-\nality of the data? How?\nDiscussions156.\n11.3AttentionScoring Functions\nInSection11.2 ,weusedanumberofdifferentdistance-basedkernels,includingaGaussian\nkernel to model interactions between queries and keys. As it turns out, distance functions\nare slightly more expensive to compute than dot products. As such, with the softmax op-\neration to ensure nonnegative attention weights, much of the work has gone into attention\nscoringfunctions \ud835\udc4ein(11.1.3 )andFig. 11.3.1 that are simpler to compute.\ntFig. 11.3.1 Computing the output of attention pooling as a weighted average of values, where weights\nare computed with the attention scoring function aand the softmax operation.\n421 Attention Scoring Functions\nimport math\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n11.3.1DotProductAttention\nLet\u2019s review the attention function (without exponentiation) from the Gaussian kernel for\na moment:\n\ud835\udc4e\u00b9q,k\ud835\udc56\u00ba=\u00001\n2kq\u0000k\ud835\udc56k2=q>k\ud835\udc56\u00001\n2kk\ud835\udc56k2\u00001\n2kqk2. (11.3.1)\nFirst, note that the final term depends on qonly. As such it is identical for all \u00b9q,k\ud835\udc56\u00ba\npairs. Normalizing the attention weights to 1, as is done in (11.1.3 ), ensures that this term\ndisappears entirely. Second, note that both batch and layer normalization (to be discussed\nlater) lead to activations that have well-bounded, and often constant, norms kk\ud835\udc56k. This is\nthe case, for instance, whenever the keys k\ud835\udc56were generated by a layer norm. As such, we\ncan drop it from the definition of \ud835\udc4ewithout any major change in the outcome.\nLast, we need to keep the order of magnitude of the arguments in the exponential function\nunder control. Assume that all the elements of the query q2R\ud835\udc51and the key k\ud835\udc562R\ud835\udc51\nare independent and identically drawn random variables with zero mean and unit variance.\nThe dot product between both vectors has zero mean and a variance of \ud835\udc51. To ensure that\nthevarianceofthedotproductstillremains 1regardlessofvectorlength, weusethe scaled\ndot product attention scoring function. That is, we rescale the dot product by 1\u009dp\n\ud835\udc51. We\nthus arrive at the first commonly used attention function that is used, e.g., in Transformers\n(Vaswanietal., 2017):\n\ud835\udc4e\u00b9q,k\ud835\udc56\u00ba=q>k\ud835\udc56\u009dp\n\ud835\udc51. (11.3.2)\nNote that attention weights \ud835\udefcstill need normalizing. We can simplify this further via\n(11.1.3 )by using the softmax operation:\n\ud835\udefc\u00b9q,k\ud835\udc56\u00ba=softmax\u00b9\ud835\udc4e\u00b9q,k\ud835\udc56\u00ba\u00ba=exp\u00b9q>k\ud835\udc56\u009dp\n\ud835\udc51\u00ba\n\u00cd\n\ud835\udc57=1exp\u00b9q>k\ud835\udc57\u009dp\n\ud835\udc51\u00ba. (11.3.3)\nAs it turns out, all popular attention mechanisms use the softmax, hence we will limit\nourselves to that in the remainder of this chapter.\n11.3.2ConvenienceFunctions\nWeneedafewfunctionstomaketheattentionmechanismefficienttodeploy. Thisincludes\ntoolsfordealingwithstringsofvariablelengths(commonfornaturallanguageprocessing)\nand tools for efficient evaluation on minibatches (batch matrix multiplication).\nMaskedSoftmax Operation\nOne of the most popular applications of the attention mechanism is to sequence models.", "mimetype": "text/plain", "start_char_idx": 976462, "end_char_idx": 979860, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dcb5fb76-14d0-476b-97c5-d4708a8dad4a": {"__data__": {"id_": "dcb5fb76-14d0-476b-97c5-d4708a8dad4a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cd79b74d-d00f-4c27-b11a-7b3847109b4a", "node_type": "1", "metadata": {}, "hash": "1ac5969c925d2e86e0eb6e8476ed78602c415bb8ed729ede565885316dabc28d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ed1c198a-a7ca-43e0-862c-a4c7e752fa89", "node_type": "1", "metadata": {}, "hash": "3765fcf4312aae1b22ee48f8a9e4fb5ba2aa25d09b42c6dccf8c715d1bb61e58", "class_name": "RelatedNodeInfo"}}, "text": "(11.3.3)\nAs it turns out, all popular attention mechanisms use the softmax, hence we will limit\nourselves to that in the remainder of this chapter.\n11.3.2ConvenienceFunctions\nWeneedafewfunctionstomaketheattentionmechanismefficienttodeploy. Thisincludes\ntoolsfordealingwithstringsofvariablelengths(commonfornaturallanguageprocessing)\nand tools for efficient evaluation on minibatches (batch matrix multiplication).\nMaskedSoftmax Operation\nOne of the most popular applications of the attention mechanism is to sequence models.\nHence we need to be able to deal with sequences of different lengths. In some cases, such\n422 Attention Mechanisms and Transformers\nsequences may end up in the same minibatch, necessitating padding with dummy tokens\nfor shorter sequences (see Section 10.5 for an example). These special tokens do not carry\nmeaning. For instance, assume that we have the following three sentences:\nDive into Deep Learning\nLearn to code <blank >\nHello world <blank ><blank >\nSincewedonotwantblanksinourattentionmodelwesimplyneedtolimit\u00cd\ud835\udc5b\n\ud835\udc56=1\ud835\udefc\u00b9q,k\ud835\udc56\u00bav\ud835\udc56\nto\u00cd\ud835\udc59\n\ud835\udc56=1\ud835\udefc\u00b9q,k\ud835\udc56\u00bav\ud835\udc56forhoweverlong, \ud835\udc59\u0014\ud835\udc5b,theactualsentenceis. Sinceitissuchacommon\nproblem, it has a name: the maskedsoftmax operation .\nLet\u2019simplementit. Actually,theimplementationcheatseversoslightlybysettingthevalues\nofv\ud835\udc56, for\ud835\udc56 >\ud835\udc59, to zero. Moreover, it sets the attention weights to a large negative number,\nsuchas\u0000106,inordertomaketheircontributiontogradientsandvaluesvanishinpractice.\nThis is done since linear algebra kernels and operators are heavily optimized for GPUs and\nit is faster to be slightly wasteful in computation rather than to have code with conditional\n(if then else) statements.\ndef masked_softmax (X, valid_lens): #@save\n\"\"\"Perform softmax operation by masking elements on the last axis.\"\"\"\n# X: 3D tensor, valid_lens: 1D or 2D tensor\ndef _sequence_mask (X, valid_len, value =0):\nmaxlen =X.size( 1)\nmask =torch .arange((maxlen), dtype =torch .float32,\ndevice =X.device)[ None , :] <valid_len[:, None ]\nX[~mask] =value\nreturn X\nifvalid_lens isNone :\nreturn nn.functional .softmax(X, dim =-1)\nelse :\nshape =X.shape\nifvalid_lens .dim() ==1:\nvalid_lens =torch .repeat_interleave(valid_lens, shape[ 1])\nelse :\nvalid_lens =valid_lens .reshape( -1)\n# On the last axis, replace masked elements with a very large negative\n# value, whose exponentiation outputs 0\nX=_sequence_mask(X .reshape( -1, shape[ -1]), valid_lens, value =-1e6)\nreturn nn.functional .softmax(X .reshape(shape), dim =-1)\nTo illustrate how this function works, consider a minibatch of two examples of size 2\u00024,\nwhere their valid lengths are 2and3, respectively. As a result of the masked softmax oper-\nation,valuesbeyondthevalidlengthsforeachpairofvectorsareallmaskedaszero.\nmasked_softmax(torch .rand( 2,2,4), torch .tensor([ 2,3]))\ntensor([[[ 0.4448 ,0.5552 ,0.0000 ,0.0000 ],\n[0.4032 ,0.5968 ,0.0000 ,0.0000 ]],\n(continues on next page)\n423 Attention Scoring Functions\n(continued from previous page)\n[[0.2795 ,0.2805 ,0.4400 ,0.0000 ],\n[0.2798 ,0.3092 ,0.4110 ,0.0000 ]]])\nIf we need more fine-grained control to specify the valid length for each of the two vec-\ntors of every example, we simply use a two-dimensional tensor of valid lengths.", "mimetype": "text/plain", "start_char_idx": 979336, "end_char_idx": 982520, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ed1c198a-a7ca-43e0-862c-a4c7e752fa89": {"__data__": {"id_": "ed1c198a-a7ca-43e0-862c-a4c7e752fa89", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "dcb5fb76-14d0-476b-97c5-d4708a8dad4a", "node_type": "1", "metadata": {}, "hash": "a2c4106480870912bcc03575238f982325bf47d15ab1d674d0ac6d27cebe6e1f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "59eb2e06-f1e1-4ac3-b80f-cf52bceda9a6", "node_type": "1", "metadata": {}, "hash": "43407a45384fa26ce3adbb78e7510ab9dc1fd289dca8384a7cec7954af0fcefc", "class_name": "RelatedNodeInfo"}}, "text": "As a result of the masked softmax oper-\nation,valuesbeyondthevalidlengthsforeachpairofvectorsareallmaskedaszero.\nmasked_softmax(torch .rand( 2,2,4), torch .tensor([ 2,3]))\ntensor([[[ 0.4448 ,0.5552 ,0.0000 ,0.0000 ],\n[0.4032 ,0.5968 ,0.0000 ,0.0000 ]],\n(continues on next page)\n423 Attention Scoring Functions\n(continued from previous page)\n[[0.2795 ,0.2805 ,0.4400 ,0.0000 ],\n[0.2798 ,0.3092 ,0.4110 ,0.0000 ]]])\nIf we need more fine-grained control to specify the valid length for each of the two vec-\ntors of every example, we simply use a two-dimensional tensor of valid lengths. This\nyields:\nmasked_softmax(torch .rand( 2,2,4), torch .tensor([[ 1,3], [ 2,4]]))\ntensor([[[ 1.0000 ,0.0000 ,0.0000 ,0.0000 ],\n[0.4109 ,0.2794 ,0.3097 ,0.0000 ]],\n[[0.3960 ,0.6040 ,0.0000 ,0.0000 ],\n[0.2557 ,0.1833 ,0.2420 ,0.3190 ]]])\nBatchMatrix Multiplication\nAnother commonly used operation is to multiply batches of matrices by one another. This\ncomes in handy when we have minibatches of queries, keys, and values. More specifically,\nassume that\nQ=\u00bbQ1,Q2,...,Q\ud835\udc5b\u00bc2R\ud835\udc5b\u0002\ud835\udc4e\u0002\ud835\udc4f,\nK=\u00bbK1,K2,...,K\ud835\udc5b\u00bc2R\ud835\udc5b\u0002\ud835\udc4f\u0002\ud835\udc50.(11.3.4)\nThen the batch matrix multiplication (BMM) computes the elementwise product\nBMM\u00b9Q,K\u00ba=\u00bbQ1K1,Q2K2,...,Q\ud835\udc5bK\ud835\udc5b\u00bc2R\ud835\udc5b\u0002\ud835\udc4e\u0002\ud835\udc50. (11.3.5)\nLet\u2019s see this in action in a deep learning framework.\nQ=torch .ones(( 2,3,4))\nK=torch .ones(( 2,4,6))\nd2l.check_shape(torch .bmm(Q, K), ( 2,3,6))\n11.3.3Scaled DotProductAttention\nLet\u2019s return to the dot product attention introduced in (11.3.2 ). In general, it requires that\nboth the query and the key have the same vector length, say \ud835\udc51, even though this can be\naddressed easily by replacing q>kwithq>Mkwhere Mis a matrix suitably chosen for\ntranslating between both spaces. For now assume that the dimensions match.\nIn practice, we often think of minibatches for efficiency, such as computing attention for\n\ud835\udc5bqueries and\ud835\udc5akey-value pairs, where queries and keys are of length \ud835\udc51and values are of\nlength\ud835\udc63. The scaled dot product attention of queries Q2R\ud835\udc5b\u0002\ud835\udc51, keysK2R\ud835\udc5a\u0002\ud835\udc51, and\n424 Attention Mechanisms and Transformers\nvalues V2R\ud835\udc5a\u0002\ud835\udc63thus can be written as\nsoftmax\u0012QK>\np\n\ud835\udc51\u0013\nV2R\ud835\udc5b\u0002\ud835\udc63. (11.3.6)\nNotethatwhenapplyingthistoaminibatch, weneedthebatchmatrixmultiplicationintro-\nduced in (11.3.5 ). In the following implementation of the scaled dot product attention, we\nuse dropout for model regularization.\nclass DotProductAttention (nn.Module): #@save\n\"\"\"Scaled dot product attention.\"\"\"\ndef __init__ (self , dropout):\nsuper ().__init__ ()\nself .dropout =nn.Dropout(dropout)\n# Shape of queries: (batch_size, no. of queries, d)\n# Shape of keys: (batch_size, no. of key-value pairs, d)\n# Shape of values: (batch_size, no. of key-value pairs, value dimension)\n# Shape of valid_lens: (batch_size,) or (batch_size, no.", "mimetype": "text/plain", "start_char_idx": 981937, "end_char_idx": 984654, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "59eb2e06-f1e1-4ac3-b80f-cf52bceda9a6": {"__data__": {"id_": "59eb2e06-f1e1-4ac3-b80f-cf52bceda9a6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ed1c198a-a7ca-43e0-862c-a4c7e752fa89", "node_type": "1", "metadata": {}, "hash": "3765fcf4312aae1b22ee48f8a9e4fb5ba2aa25d09b42c6dccf8c715d1bb61e58", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2cb340ec-7a0a-489c-8839-ac278053d120", "node_type": "1", "metadata": {}, "hash": "a43aa29bb40110736bf6aaf60f484ea3afad192b92248e5df44d885be3d3ee81", "class_name": "RelatedNodeInfo"}}, "text": "(11.3.6)\nNotethatwhenapplyingthistoaminibatch, weneedthebatchmatrixmultiplicationintro-\nduced in (11.3.5 ). In the following implementation of the scaled dot product attention, we\nuse dropout for model regularization.\nclass DotProductAttention (nn.Module): #@save\n\"\"\"Scaled dot product attention.\"\"\"\ndef __init__ (self , dropout):\nsuper ().__init__ ()\nself .dropout =nn.Dropout(dropout)\n# Shape of queries: (batch_size, no. of queries, d)\n# Shape of keys: (batch_size, no. of key-value pairs, d)\n# Shape of values: (batch_size, no. of key-value pairs, value dimension)\n# Shape of valid_lens: (batch_size,) or (batch_size, no. of queries)\ndef forward (self , queries, keys, values, valid_lens =None ):\nd=queries .shape[ -1]\n# Swap the last two dimensions of keys with keys.transpose(1, 2)\nscores =torch .bmm(queries, keys .transpose( 1,2))/math .sqrt(d)\nself .attention_weights =masked_softmax(scores, valid_lens)\nreturn torch .bmm( self .dropout( self .attention_weights), values)\nTo illustrate how the DotProductAttention class works, we use the same keys, values,\nand valid lengths from the earlier toy example for additive attention. For the purpose of\nour example we assume that we have a minibatch size of 2, a total of 10keys and values,\nand that the dimensionality of the values is 4. Lastly, we assume that the valid length per\nobservationis 2and6respectively. Giventhat,weexpecttheoutputtobea 2\u00021\u00024tensor,\ni.e., one row per example of the minibatch.\nqueries =torch .normal( 0,1, (2,1,2))\nkeys =torch .normal( 0,1, (2,10,2))\nvalues =torch .normal( 0,1, (2,10,4))\nvalid_lens =torch .tensor([ 2,6])\nattention =DotProductAttention(dropout =0.5)\nattention .eval()\nd2l.check_shape(attention(queries, keys, values, valid_lens), ( 2,1,4))\nLet\u2019s check whether the attention weights actually vanish for anything beyond the second\nand sixth column respectively (because of setting the valid length to 2and6).\nd2l.show_heatmaps(attention .attention_weights .reshape(( 1,1,2,10)),\nxlabel ='Keys ', ylabel ='Queries ')\n11.3.4AdditiveAttention\nWhenqueries qandkeys karevectorsofdifferentdimension,wecaneitheruseamatrixto\naddress the mismatch via q>Mk, or we can use additive attention as the scoring function.\n425 Attention Scoring Functions\nAnother benefit is that, as its name indicates, the attention is additive. This can lead to\nsome minor computational savings. Given a query q2R\ud835\udc5eand a key k2R\ud835\udc58, theadditive\nattention scoring function ( Bahdanau etal., 2014) is given by\n\ud835\udc4e\u00b9q,k\u00ba=w>\n\ud835\udc63tanh\u00b9W\ud835\udc5eq\u00b8W\ud835\udc58k\u00ba2R, (11.3.7)\nwhere W\ud835\udc5e2R\u210e\u0002\ud835\udc5e,W\ud835\udc582R\u210e\u0002\ud835\udc58, andw\ud835\udc632R\u210eare the learnable parameters. This term\nis then fed into a softmax to ensure both nonnegativity and normalization. An equivalent\ninterpretation of (11.3.7 )is that the query and key are concatenated and fed into an MLP\nwith a single hidden layer. Using tanhas the activation function and disabling bias terms,\nwe implement additive attention as follows:\nclass AdditiveAttention (nn.Module): #@save\n\"\"\"Additive attention.\"\"\"\ndef __init__ (self , num_hiddens, dropout, **kwargs):\nsuper (AdditiveAttention, self ).__init__ (**kwargs)\nself .W_k =nn.LazyLinear(num_hiddens, bias =False )\nself .W_q =nn.LazyLinear(num_hiddens, bias =False )\nself .w_v =nn.LazyLinear( 1, bias =False )\nself .dropout =nn.Dropout(dropout)\ndef forward (self , queries, keys, values, valid_lens):\nqueries, keys =self .W_q(queries), self .W_k(keys)\n# After dimension expansion, shape of queries: (batch_size, no. of\n# queries, 1, num_hiddens) and shape of keys: (batch_size, 1, no.", "mimetype": "text/plain", "start_char_idx": 984029, "end_char_idx": 987520, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2cb340ec-7a0a-489c-8839-ac278053d120": {"__data__": {"id_": "2cb340ec-7a0a-489c-8839-ac278053d120", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "59eb2e06-f1e1-4ac3-b80f-cf52bceda9a6", "node_type": "1", "metadata": {}, "hash": "43407a45384fa26ce3adbb78e7510ab9dc1fd289dca8384a7cec7954af0fcefc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a5a81eca-ac97-458c-b358-d783f1c3312d", "node_type": "1", "metadata": {}, "hash": "48bec7a938bfecfb3d9771518eb82daf9ee0ff842b95df2c4e45954c3cb868be", "class_name": "RelatedNodeInfo"}}, "text": "def __init__ (self , num_hiddens, dropout, **kwargs):\nsuper (AdditiveAttention, self ).__init__ (**kwargs)\nself .W_k =nn.LazyLinear(num_hiddens, bias =False )\nself .W_q =nn.LazyLinear(num_hiddens, bias =False )\nself .w_v =nn.LazyLinear( 1, bias =False )\nself .dropout =nn.Dropout(dropout)\ndef forward (self , queries, keys, values, valid_lens):\nqueries, keys =self .W_q(queries), self .W_k(keys)\n# After dimension expansion, shape of queries: (batch_size, no. of\n# queries, 1, num_hiddens) and shape of keys: (batch_size, 1, no. of\n# key-value pairs, num_hiddens). Sum them up with broadcasting\nfeatures =queries .unsqueeze( 2)+keys .unsqueeze( 1)\nfeatures =torch .tanh(features)\n# There is only one output of self.w_v, so we remove the last\n# one-dimensional entry from the shape. Shape of scores: (batch_size,\n# no. of queries, no. of key-value pairs)\nscores =self .w_v(features) .squeeze( -1)\nself .attention_weights =masked_softmax(scores, valid_lens)\n# Shape of values: (batch_size, no. of key-value pairs, value\n# dimension)\nreturn torch .bmm( self .dropout( self .attention_weights), values)\nLet\u2019s see how AdditiveAttention works. In our toy example we pick queries, keys and\nvaluesofsize\u00b92,1,20\u00ba,\u00b92,10,2\u00baand\u00b92,10,4\u00ba,respectively. Thisisidenticaltoourchoice\nforDotProductAttention , except that now the queries are 20-dimensional. Likewise, we\npick\u00b92,6\u00baas the valid lengths for the sequences in the minibatch.\nqueries =torch .normal( 0,1, (2,1,20))\n(continues on next page)\n426 Attention Mechanisms and Transformers\n157\n158(continued from previous page)\nattention =AdditiveAttention(num_hiddens =8, dropout =0.1)\nattention .eval()\nd2l.check_shape(attention(queries, keys, values, valid_lens), ( 2,1,4))\nWhen reviewing the attention function we see a behavior that is qualitatively quite similar\nto that of DotProductAttention . That is, onlyterms within the chosenvalid length \u00b92,6\u00ba\nare nonzero.\nd2l.show_heatmaps(attention .attention_weights .reshape(( 1,1,2,10)),\nxlabel ='Keys ', ylabel ='Queries ')\n11.3.5Summary\nInthissectionweintroducedthetwokeyattentionscoringfunctions: dotproductandaddi-\ntive attention. They are effective tools for aggregating across sequences of variable length.\nInparticular,thedotproductattentionisthemainstayofmodernTransformerarchitectures.\nWhen queries and keys are vectors of different lengths, we can use the additive attention\nscoring function instead. Optimizing these layers is one of the key areas of advance in re-\ncent years. For instance, NVIDIA\u2019s Transformer Library157and Megatron ( Shoeybietal.,\n2019) crucially rely on efficient variants of the attention mechanism. We will dive into this\nin quite a bit more detail as we review Transformers in later sections.\n11.3.6Exercises\n1.Implementdistance-basedattentionbymodifyingthe DotProductAttention code. Note\nthat you only need the squared norms of the keys kk\ud835\udc56k2for an efficient implementation.\n2.Modify the dot product attention to allow for queries and keys of different dimension-\nalities by employing a matrix to adjust dimensions.\n3.How does the computational cost scale with the dimensionality of the keys, queries,\nvalues, and their number? What about the memory bandwidth requirements?\nDiscussions158.\n427 The Bahdanau Attention Mechanism\n11.4TheBahdanau AttentionMechanism\nWhenweencounteredmachinetranslationin Section10.7 ,wedesignedanencoder\u2013decoder\narchitectureforsequence-to-sequencelearningbasedontwoRNNs( Sutskever etal.,2014).\nSpecifically, the RNN encoder transforms a variable-length sequence into a fixed-shape\ncontext variable. Then, the RNN decoder generates the output (target) sequence token by\ntoken based on the generated tokens and the context variable.\nRecallFig. 10.7.2 which we repeat ( Fig. 11.4.1 ) with some additional detail.", "mimetype": "text/plain", "start_char_idx": 986992, "end_char_idx": 990752, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a5a81eca-ac97-458c-b358-d783f1c3312d": {"__data__": {"id_": "a5a81eca-ac97-458c-b358-d783f1c3312d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2cb340ec-7a0a-489c-8839-ac278053d120", "node_type": "1", "metadata": {}, "hash": "a43aa29bb40110736bf6aaf60f484ea3afad192b92248e5df44d885be3d3ee81", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "19ca01b1-6f58-4728-87b5-6943dfa7c727", "node_type": "1", "metadata": {}, "hash": "d799827ef6d5c4be74995fbef2157cc9d0f36a963475a4f460a630c0f08cfd8b", "class_name": "RelatedNodeInfo"}}, "text": "3.How does the computational cost scale with the dimensionality of the keys, queries,\nvalues, and their number? What about the memory bandwidth requirements?\nDiscussions158.\n427 The Bahdanau Attention Mechanism\n11.4TheBahdanau AttentionMechanism\nWhenweencounteredmachinetranslationin Section10.7 ,wedesignedanencoder\u2013decoder\narchitectureforsequence-to-sequencelearningbasedontwoRNNs( Sutskever etal.,2014).\nSpecifically, the RNN encoder transforms a variable-length sequence into a fixed-shape\ncontext variable. Then, the RNN decoder generates the output (target) sequence token by\ntoken based on the generated tokens and the context variable.\nRecallFig. 10.7.2 which we repeat ( Fig. 11.4.1 ) with some additional detail. Convention-\nally, in an RNN all relevant information about a source sequence is translated into some\ninternalfixed-dimensional state representation by the encoder. It is this very state that is\nused by the decoder as the complete and exclusive source of information for generating the\ntranslated sequence. In other words, the sequence-to-sequence mechanism treats the inter-\nmediate state as a sufficient statistic of whatever string might have served as input.\ntFig. 11.4.1 Sequence-to-sequence model. The state, as generated by the encoder, is the only piece of\ninformation shared between the encoder and the decoder.\nWhilethisisquitereasonableforshortsequences,itisclearthatitisinfeasibleforlongones,\nsuchasabookchapterorevenjustaverylongsentence. Afterall,beforetoolongtherewill\nsimplynotbeenough\u201cspace\u201dintheintermediaterepresentationtostoreallthatisimportant\nin the source sequence. Consequently the decoder will fail to translate long and complex\nsentences. One of the first to encounter this was Graves ( 2013) who tried to design an\nRNNtogeneratehandwrittentext. Sincethesourcetexthasarbitrarylengththeydesigneda\ndifferentiableattentionmodeltoaligntextcharacterswiththemuchlongerpentrace,where\nthe alignment moves only in one direction. This, in turn, draws on decoding algorithms in\nspeech recognition, e.g., hidden Markov models ( Rabiner and Juang, 1993 ).\nInspired by the idea of learning to align, Bahdanau et al.(2014) proposed a differentiable\nattention model withoutthe unidirectional alignment limitation. When predicting a token,\nifnotalltheinputtokensarerelevant,themodelaligns(orattends)onlytopartsoftheinput\nsequencethataredeemedrelevanttothecurrentprediction. Thisisthenusedtoupdatethe\ncurrentstatebeforegeneratingthenexttoken. Whilequiteinnocuousinitsdescription,this\nBahdanau attention mechanism has arguably turned into one of the most influential ideas\nof the past decade in deep learning, giving rise to Transformers ( Vaswanietal., 2017) and\nmany related new architectures.\n428 Attention Mechanisms and Transformers\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n11.4.1Model\nWe follow the notation introduced by the sequence-to-sequence architecture of Section\n10.7, in particular (10.7.3 ). The key idea is that instead of keeping the state, i.e., the con-\ntext variable csummarizing the source sentence, as fixed, we dynamically update it, as a\nfunction of both the original text (encoder hidden states h\ud835\udc61) and the text that was already\ngenerated (decoder hidden states s\ud835\udc610\u00001). This yields c\ud835\udc610, which is updated after any decod-\ning time step \ud835\udc610. Suppose that the input sequence is of length \ud835\udc47. In this case the context\nvariable is the output of attention pooling:\nc\ud835\udc610=\ud835\udc47\u00d5\n\ud835\udc61=1\ud835\udefc\u00b9s\ud835\udc610\u00001,h\ud835\udc61\u00bah\ud835\udc61. (11.4.1)\nWe used s\ud835\udc610\u00001as the query, and h\ud835\udc61as both the key and the value. Note that c\ud835\udc610is then\nused to generate the state s\ud835\udc610and to generate a new token: see (10.7.3 ). In particular, the\nattention weight \ud835\udefcis computed as in (11.3.3 )using the additive attention scoring function\ndefinedby (11.3.7 ). ThisRNNencoder\u2013decoderarchitectureusingattentionisdepictedin\nFig. 11.4.2 .", "mimetype": "text/plain", "start_char_idx": 990030, "end_char_idx": 993861, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "19ca01b1-6f58-4728-87b5-6943dfa7c727": {"__data__": {"id_": "19ca01b1-6f58-4728-87b5-6943dfa7c727", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a5a81eca-ac97-458c-b358-d783f1c3312d", "node_type": "1", "metadata": {}, "hash": "48bec7a938bfecfb3d9771518eb82daf9ee0ff842b95df2c4e45954c3cb868be", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c701bc5b-185c-4ba3-9888-fd83cc4ba487", "node_type": "1", "metadata": {}, "hash": "b8541c823437564673f049892f6bc3f5ddf3105bdc2f9898cc96f0c4610fd654", "class_name": "RelatedNodeInfo"}}, "text": "Suppose that the input sequence is of length \ud835\udc47. In this case the context\nvariable is the output of attention pooling:\nc\ud835\udc610=\ud835\udc47\u00d5\n\ud835\udc61=1\ud835\udefc\u00b9s\ud835\udc610\u00001,h\ud835\udc61\u00bah\ud835\udc61. (11.4.1)\nWe used s\ud835\udc610\u00001as the query, and h\ud835\udc61as both the key and the value. Note that c\ud835\udc610is then\nused to generate the state s\ud835\udc610and to generate a new token: see (10.7.3 ). In particular, the\nattention weight \ud835\udefcis computed as in (11.3.3 )using the additive attention scoring function\ndefinedby (11.3.7 ). ThisRNNencoder\u2013decoderarchitectureusingattentionisdepictedin\nFig. 11.4.2 . Note that later this model was modified so as to include the already generated\ntokensinthedecoderasfurthercontext(i.e., theattentionsumdoesnotstopat \ud835\udc47butrather\nit proceeds up to \ud835\udc610\u00001). For instance, see Chan et al.(2015) for a description of this\nstrategy, as applied to speech recognition.\ntFig. 11.4.2 Layers in an RNN encoder\u2013decoder model with the Bahdanau attention mechanism.\n11.4.2Defining the Decoder with Attention\nTo implement the RNN encoder\u2013decoder with attention, we only need to redefine the de-\ncoder (omitting the generated symbols from the attention function simplifies the design).\nLet\u2019s begin with the base interface for decoders with attention by defining the quite unsur-\nprisingly named AttentionDecoder class.\n429 The Bahdanau Attention Mechanism\nclass AttentionDecoder (d2l .Decoder): #@save\n\"\"\"The base attention-based decoder interface.\"\"\"\ndef __init__ (self ):\nsuper ().__init__ ()\n@property\ndef attention_weights (self ):\nraise NotImplementedError\nWe need to implement the RNN decoder in the Seq2SeqAttentionDecoder class. The\nstate of the decoder is initialized with (i) the hidden states of the last layer of the encoder\nat all time steps, used as keys and values for attention; (ii) the hidden state of the encoder\nat all layers at the final time step, which serves to initialize the hidden state of the decoder;\nand (iii) the valid length of the encoder, to exclude the padding tokens in attention pooling.\nAt each decoding time step, the hidden state of the final layer of the decoder, obtained at\nthe previous time step, is used as the query of the attention mechanism. Both the output of\nthe attention mechanism and the input embedding are concatenated to serve as the input of\nthe RNN decoder.\nclass Seq2SeqAttentionDecoder (AttentionDecoder):\ndef __init__ (self , vocab_size, embed_size, num_hiddens, num_layers,\ndropout =0):\nsuper ().__init__ ()\nself .attention =d2l.AdditiveAttention(num_hiddens, dropout)\nself .embedding =nn.Embedding(vocab_size, embed_size)\nself .rnn =nn.GRU(\nembed_size +num_hiddens, num_hiddens, num_layers,\ndropout =dropout)\nself .dense =nn.LazyLinear(vocab_size)\nself .apply(d2l .init_seq2seq)\ndef init_state (self , enc_outputs, enc_valid_lens):\n# Shape of outputs: (num_steps, batch_size, num_hiddens).\n# Shape of hidden_state: (num_layers, batch_size, num_hiddens)\noutputs, hidden_state =enc_outputs\nreturn (outputs .permute( 1,0,2), hidden_state, enc_valid_lens)\ndef forward (self , X, state):\n# Shape of enc_outputs: (batch_size, num_steps, num_hiddens).", "mimetype": "text/plain", "start_char_idx": 993345, "end_char_idx": 996383, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c701bc5b-185c-4ba3-9888-fd83cc4ba487": {"__data__": {"id_": "c701bc5b-185c-4ba3-9888-fd83cc4ba487", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "19ca01b1-6f58-4728-87b5-6943dfa7c727", "node_type": "1", "metadata": {}, "hash": "d799827ef6d5c4be74995fbef2157cc9d0f36a963475a4f460a630c0f08cfd8b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "130c92ef-e69f-4377-b704-424018681566", "node_type": "1", "metadata": {}, "hash": "2a80c6b4b623c09f98881fbe88849d1883462a93007def307e06a47e9c99bcd5", "class_name": "RelatedNodeInfo"}}, "text": "# Shape of hidden_state: (num_layers, batch_size, num_hiddens)\noutputs, hidden_state =enc_outputs\nreturn (outputs .permute( 1,0,2), hidden_state, enc_valid_lens)\ndef forward (self , X, state):\n# Shape of enc_outputs: (batch_size, num_steps, num_hiddens).\n# Shape of hidden_state: (num_layers, batch_size, num_hiddens)\nenc_outputs, hidden_state, enc_valid_lens =state\n# Shape of the output X: (num_steps, batch_size, embed_size)\nX=self .embedding(X) .permute( 1,0,2)\noutputs, self ._attention_weights =[], []\nfor xinX:\n# Shape of query: (batch_size, 1, num_hiddens)\nquery =torch .unsqueeze(hidden_state[ -1], dim =1)\n# Shape of context: (batch_size, 1, num_hiddens)\ncontext =self .attention(\nquery, enc_outputs, enc_outputs, enc_valid_lens)\n# Concatenate on the feature dimension\nx=torch .cat((context, torch .unsqueeze(x, dim =1)), dim =-1)\n(continues on next page)\n430 Attention Mechanisms and Transformers\n(continued from previous page)\n# Reshape x as (1, batch_size, embed_size + num_hiddens)\nout, hidden_state =self .rnn(x .permute( 1,0,2), hidden_state)\noutputs .append(out)\nself ._attention_weights .append( self .attention .attention_weights)\n# After fully connected layer transformation, shape of outputs:\n# (num_steps, batch_size, vocab_size)\noutputs =self .dense(torch .cat(outputs, dim =0))\nreturn outputs .permute( 1,0,2), [enc_outputs, hidden_state,\nenc_valid_lens]\n@property\ndef attention_weights (self ):\nreturn self ._attention_weights\nIn the following, we test the implemented decoder with attention using a minibatch of four\nsequences, each of which are seven time steps long.\nvocab_size, embed_size, num_hiddens, num_layers =10,8,16,2\nbatch_size, num_steps =4,7\nencoder =d2l.Seq2SeqEncoder(vocab_size, embed_size, num_hiddens, num_layers)\ndecoder =Seq2SeqAttentionDecoder(vocab_size, embed_size, num_hiddens,\nnum_layers)\nX=torch .zeros((batch_size, num_steps), dtype =torch .long)\nstate =decoder .init_state(encoder(X), None )\noutput, state =decoder(X, state)\nd2l.check_shape(output, (batch_size, num_steps, vocab_size))\nd2l.check_shape(state[ 0], (batch_size, num_steps, num_hiddens))\nd2l.check_shape(state[ 1][0], (batch_size, num_hiddens))\n11.4.3Training\nNow that we specified the new decoder we can proceed analogously to Section 10.7.6 :\nspecify the hyperparameters, instantiate a regular encoder and a decoder with attention,\nand train this model for machine translation.\ndata =d2l.MTFraEng(batch_size =128)\nembed_size, num_hiddens, num_layers, dropout =256,256,2,0.2\nencoder =d2l.Seq2SeqEncoder(\nlen(data .src_vocab), embed_size, num_hiddens, num_layers, dropout)\ndecoder =Seq2SeqAttentionDecoder(\nlen(data .tgt_vocab), embed_size, num_hiddens, num_layers, dropout)\nmodel =d2l.Seq2Seq(encoder, decoder, tgt_pad =data .tgt_vocab[ '<pad> '],\nlr=0.005 )\ntrainer =d2l.Trainer(max_epochs =30, gradient_clip_val =1, num_gpus =1)\ntrainer .fit(model, data)\nAfter the model is trained, we use it to translate a few English sentences into French and\ncompute their BLEU scores.\n431 The Bahdanau Attention Mechanism\nengs =['go . ','i lost . ','he\\'s calm . ','i\\'m home . ']\nfras =['va ! ','j\\'ai perdu . ','il est calme . ','je suis chez moi . ']", "mimetype": "text/plain", "start_char_idx": 996129, "end_char_idx": 999290, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "130c92ef-e69f-4377-b704-424018681566": {"__data__": {"id_": "130c92ef-e69f-4377-b704-424018681566", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c701bc5b-185c-4ba3-9888-fd83cc4ba487", "node_type": "1", "metadata": {}, "hash": "b8541c823437564673f049892f6bc3f5ddf3105bdc2f9898cc96f0c4610fd654", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4e2cecbd-0358-46d8-8b2f-bf9219036913", "node_type": "1", "metadata": {}, "hash": "4e7c7920642a3d16ca30dd9ae23006e1ba46b29dc7db5ed8e51fbe0594402ecf", "class_name": "RelatedNodeInfo"}}, "text": "431 The Bahdanau Attention Mechanism\nengs =['go . ','i lost . ','he\\'s calm . ','i\\'m home . ']\nfras =['va ! ','j\\'ai perdu . ','il est calme . ','je suis chez moi . ']\npreds, _ =model .predict_step(\ndata .build(engs, fras), d2l .try_gpu(), data .num_steps)\nfor en, fr, p inzip(engs, fras, preds):\ntranslation =[]\nfor token indata .tgt_vocab .to_tokens(p):\niftoken =='<eos> ':\nbreak\ntranslation .append(token)\nprint (f'{en}=>{translation }, bleu, '\nf'{d2l.bleu( \"\".join(translation), fr, k=2):.3f}')\ngo.=>['va','!'], bleu, 1.000\ni lost .=>[\"j'ai\",'perdu ','.'], bleu, 1.000\nhe's calm . => [ 'il','court ','.'], bleu,0.000\ni'm home . => [ 'je','suis ','chez ','moi','.'], bleu,1.000\nLet\u2019svisualizetheattentionweightswhentranslatingthelastEnglishsentence. Weseethat\neach query assigns non-uniform weights over key\u2013value pairs. It shows that at each decod-\ning step, different parts of the input sequences are selectively aggregated in the attention\npooling.\n_, dec_attention_weights =model .predict_step(\ndata .build([engs[ -1]], [fras[ -1]]), d2l .try_gpu(), data .num_steps, True )\nattention_weights =torch .cat(\n[step[ 0][0][0]for step indec_attention_weights], 0)\nattention_weights =attention_weights .reshape(( 1,1,-1, data .num_steps))\n# Plus one to include the end-of-sequence token\nd2l.show_heatmaps(\nattention_weights[:, :, :, : len(engs[ -1].split()) +1].cpu(),\nxlabel ='Key positions ', ylabel ='Query positions ')\n11.4.4Summary\nWhenpredictingatoken,ifnotalltheinputtokensarerelevant,theRNNencoder\u2013decoder\nwith the Bahdanau attention mechanism selectively aggregates different parts of the input\n432 Attention Mechanisms and Transformers\n159sequence. This is achieved by treating the state (context variable) as an output of additive\nattention pooling. In the RNN encoder\u2013decoder, the Bahdanau attention mechanism treats\nthe decoder hidden state at the previous time step as the query, and the encoder hidden\nstates at all the time steps as both the keys and values.\n11.4.5Exercises\n1.Replace GRU with LSTM in the experiment.\n2.Modifytheexperimenttoreplacetheadditiveattentionscoringfunctionwiththescaled\ndot-product. How does it influence the training efficiency?\nDiscussions159.\n11.5Multi-HeadAttention\nIn practice, given the same set of queries, keys, and values we may want our model to\ncombine knowledge from different behaviors of the same attention mechanism, such as\ncapturingdependenciesofvariousranges(e.g., shorter-rangevs.longer-range)withinase-\nquence. Thus,itmaybebeneficialtoallowourattentionmechanismtojointlyusedifferent\nrepresentation subspaces of queries, keys, and values.\nTo this end, instead of performing a single attention pooling, queries, keys, and values can\nbe transformed with \u210eindependently learned linear projections. Then these \u210eprojected\nqueries, keys, and values are fed into attention pooling in parallel. In the end, \u210eattention-\npoolingoutputsareconcatenatedandtransformedwithanotherlearnedlinearprojectionto\nproduce the final output. This design is called multi-head attention , where each of the \u210e\nattention pooling outputs is a head(Vaswaniet al., 2017). Using fully connected layers to\nperformlearnablelineartransformations, Fig.11.5.1 describesmulti-headattention.\nimport math\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n433 Multi-Head Attention\ntFig. 11.5.1 Multi-head attention, where multiple heads are concatenated then linearly transformed.\n11.5.1Model\nBefore providing the implementation of multi-head attention, let\u2019s formalize this model\nmathematically.", "mimetype": "text/plain", "start_char_idx": 999122, "end_char_idx": 1002651, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4e2cecbd-0358-46d8-8b2f-bf9219036913": {"__data__": {"id_": "4e2cecbd-0358-46d8-8b2f-bf9219036913", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "130c92ef-e69f-4377-b704-424018681566", "node_type": "1", "metadata": {}, "hash": "2a80c6b4b623c09f98881fbe88849d1883462a93007def307e06a47e9c99bcd5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "82af1557-e069-49ae-bb1c-39435e9f00d5", "node_type": "1", "metadata": {}, "hash": "93686b4488e638b909ce4f5f1ee73de54fa7e677867ac801026d4c276bdbc693", "class_name": "RelatedNodeInfo"}}, "text": "Then these \u210eprojected\nqueries, keys, and values are fed into attention pooling in parallel. In the end, \u210eattention-\npoolingoutputsareconcatenatedandtransformedwithanotherlearnedlinearprojectionto\nproduce the final output. This design is called multi-head attention , where each of the \u210e\nattention pooling outputs is a head(Vaswaniet al., 2017). Using fully connected layers to\nperformlearnablelineartransformations, Fig.11.5.1 describesmulti-headattention.\nimport math\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n433 Multi-Head Attention\ntFig. 11.5.1 Multi-head attention, where multiple heads are concatenated then linearly transformed.\n11.5.1Model\nBefore providing the implementation of multi-head attention, let\u2019s formalize this model\nmathematically. Given a query q2R\ud835\udc51\ud835\udc5e, a key k2R\ud835\udc51\ud835\udc58, and a value v2R\ud835\udc51\ud835\udc63, each\nattention head h\ud835\udc56(\ud835\udc56=1,...,\u210e) is computed as\nh\ud835\udc56=\ud835\udc53\u00b9W\u00b9\ud835\udc5e\u00ba\n\ud835\udc56q,W\u00b9\ud835\udc58\u00ba\n\ud835\udc56k,W\u00b9\ud835\udc63\u00ba\n\ud835\udc56v\u00ba2R\ud835\udc5d\ud835\udc63, (11.5.1)\nwhere W\u00b9\ud835\udc5e\u00ba\n\ud835\udc562R\ud835\udc5d\ud835\udc5e\u0002\ud835\udc51\ud835\udc5e,W\u00b9\ud835\udc58\u00ba\n\ud835\udc562R\ud835\udc5d\ud835\udc58\u0002\ud835\udc51\ud835\udc58, andW\u00b9\ud835\udc63\u00ba\n\ud835\udc562R\ud835\udc5d\ud835\udc63\u0002\ud835\udc51\ud835\udc63are learnable parameters\nand\ud835\udc53is attention pooling, such as additive attention and scaled dot product attention in\nSection11.3 . Themulti-headattentionoutputisanotherlineartransformationvialearnable\nparameters W\ud835\udc5c2R\ud835\udc5d\ud835\udc5c\u0002\u210e\ud835\udc5d\ud835\udc63of the concatenation of \u210eheads:\nW\ud835\udc5c2666664h1\n...\nh\u210e37777752R\ud835\udc5d\ud835\udc5c. (11.5.2)\nBased on this design, each head may attend to different parts of the input. More sophisti-\ncated functions than the simple weighted average can be expressed.\n11.5.2Implementation\nIn our implementation, we choose the scaled dot product attention for each head of the\nmulti-head attention. To avoid significant growth of computational cost and parametriza-\ntion cost, we set \ud835\udc5d\ud835\udc5e=\ud835\udc5d\ud835\udc58=\ud835\udc5d\ud835\udc63=\ud835\udc5d\ud835\udc5c\u009d\u210e. Note that\u210eheads can be computed in parallel\nif we set the number of outputs of linear transformations for the query, key, and value to\n\ud835\udc5d\ud835\udc5e\u210e=\ud835\udc5d\ud835\udc58\u210e=\ud835\udc5d\ud835\udc63\u210e=\ud835\udc5d\ud835\udc5c. Inthefollowingimplementation, \ud835\udc5d\ud835\udc5cisspecifiedviatheargument\nnum_hiddens .\nclass MultiHeadAttention (d2l .Module): #@save\n\"\"\"Multi-head attention.\"\"\"\ndef __init__ (self , num_hiddens, num_heads, dropout, bias =False ,**kwargs):\nsuper ().__init__ ()\nself .num_heads =num_heads\nself .attention =d2l.DotProductAttention(dropout)\nself .W_q =nn.LazyLinear(num_hiddens, bias =bias)\nself .W_k =nn.LazyLinear(num_hiddens, bias =bias)\nself .W_v =nn.LazyLinear(num_hiddens, bias =bias)\n(continues on next page)\n434 Attention Mechanisms and Transformers\n(continued from previous page)\nself .W_o =nn.LazyLinear(num_hiddens, bias =bias)\ndef forward (self , queries, keys, values, valid_lens):\n# Shape of queries, keys, or values:\n# (batch_size, no. of queries or key-value pairs, num_hiddens)\n# Shape of valid_lens: (batch_size,) or (batch_size, no. of queries)\n# After transposing, shape of output queries, keys, or values:\n# (batch_size * num_heads, no.", "mimetype": "text/plain", "start_char_idx": 1001880, "end_char_idx": 1004618, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "82af1557-e069-49ae-bb1c-39435e9f00d5": {"__data__": {"id_": "82af1557-e069-49ae-bb1c-39435e9f00d5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4e2cecbd-0358-46d8-8b2f-bf9219036913", "node_type": "1", "metadata": {}, "hash": "4e7c7920642a3d16ca30dd9ae23006e1ba46b29dc7db5ed8e51fbe0594402ecf", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2fa30afc-b0e1-4854-8dfd-77d05249d86f", "node_type": "1", "metadata": {}, "hash": "6d44740ac7ae6707a5a58a07755f1274eb3a3aab4e21555468e856fd0134016a", "class_name": "RelatedNodeInfo"}}, "text": "of queries or key-value pairs, num_hiddens)\n# Shape of valid_lens: (batch_size,) or (batch_size, no. of queries)\n# After transposing, shape of output queries, keys, or values:\n# (batch_size * num_heads, no. of queries or key-value pairs,\n# num_hiddens / num_heads)\nqueries =self .transpose_qkv( self .W_q(queries))\nkeys =self .transpose_qkv( self .W_k(keys))\nvalues =self .transpose_qkv( self .W_v(values))\nifvalid_lens isnot None :\n# On axis 0, copy the first item (scalar or vector) for num_heads\n# times, then copy the next item, and so on\nvalid_lens =torch .repeat_interleave(\nvalid_lens, repeats =self .num_heads, dim =0)\n# Shape of output: (batch_size * num_heads, no. of queries,\n# num_hiddens / num_heads)\noutput =self .attention(queries, keys, values, valid_lens)\n# Shape of output_concat: (batch_size, no. of queries, num_hiddens)\noutput_concat =self .transpose_output(output)\nreturn self .W_o(output_concat)\nToallowforparallelcomputationofmultipleheads, theabove MultiHeadAttention class\nuses two transposition methods as defined below. Specifically, the transpose_output\nmethod reverses the operation of the transpose_qkv method.\n@d2l .add_to_class(MultiHeadAttention) #@save\ndef transpose_qkv (self , X):\n\"\"\"Transposition for parallel computation of multiple attention heads.\"\"\"\n# Shape of input X: (batch_size, no. of queries or key-value pairs,\n# num_hiddens). Shape of output X: (batch_size, no. of queries or\n# key-value pairs, num_heads, num_hiddens / num_heads)\nX=X.reshape(X .shape[ 0], X .shape[ 1],self .num_heads, -1)\n# Shape of output X: (batch_size, num_heads, no. of queries or key-value\n# pairs, num_hiddens / num_heads)\nX=X.permute( 0,2,1,3)\n# Shape of output: (batch_size * num_heads, no. of queries or key-value\n# pairs, num_hiddens / num_heads)\nreturn X.reshape( -1, X.shape[ 2], X .shape[ 3])\n@d2l .add_to_class(MultiHeadAttention) #@save\ndef transpose_output (self , X):\n\"\"\"Reverse the operation of transpose_qkv.\"\"\"\nX=X.reshape( -1,self .num_heads, X .shape[ 1], X .shape[ 2])\nX=X.permute( 0,2,1,3)\nreturn X.reshape(X .shape[ 0], X .shape[ 1],-1)\nLet\u2019s test our implemented MultiHeadAttention class using a toy example where keys\n435 Self-Attention and Positional Encoding\n160and values are the same. As a result, the shape of the multi-head attention output is\n(batch_size ,num_queries ,num_hiddens ).\nnum_hiddens, num_heads =100,5\nattention =MultiHeadAttention(num_hiddens, num_heads, 0.5)\nbatch_size, num_queries, num_kvpairs =2,4,6\nvalid_lens =torch .tensor([ 3,2])\nX=torch .ones((batch_size, num_queries, num_hiddens))\nY=torch .ones((batch_size, num_kvpairs, num_hiddens))\nd2l.check_shape(attention(X, Y, Y, valid_lens),\n(batch_size, num_queries, num_hiddens))\n11.5.3Summary\nMulti-headattentioncombinesknowledgeofthesameattentionpoolingviadifferentrepre-\nsentation subspaces of queries, keys, and values. To compute multiple heads of multi-head\nattention in parallel, proper tensor manipulation is needed.\n11.5.4Exercises\n1.Visualize attention weights of multiple heads in this experiment.\n2.Suppose that we have a trained model based on multi-head attention and we want to\nprune less important attention heads to increase the prediction speed. How can we de-\nsign experiments to measure the importance of an attention head?\nDiscussions160.\n11.6Self-Attentionand PositionalEncoding\nIn deep learning, we often use CNNs or RNNs to encode sequences. Now with attention\nmechanisms in mind, imagine feeding a sequence of tokens into an attention mechanism\nsuchthatateverystep,eachtokenhasitsownquery,keys,andvalues.", "mimetype": "text/plain", "start_char_idx": 1004412, "end_char_idx": 1007961, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2fa30afc-b0e1-4854-8dfd-77d05249d86f": {"__data__": {"id_": "2fa30afc-b0e1-4854-8dfd-77d05249d86f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "82af1557-e069-49ae-bb1c-39435e9f00d5", "node_type": "1", "metadata": {}, "hash": "93686b4488e638b909ce4f5f1ee73de54fa7e677867ac801026d4c276bdbc693", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a30de74e-e646-4077-bf63-53cb6290d3d5", "node_type": "1", "metadata": {}, "hash": "998343da3ff876dc4dfdd8aea4f5da5d0e6cf42f384a02381907abb33615fbdb", "class_name": "RelatedNodeInfo"}}, "text": "To compute multiple heads of multi-head\nattention in parallel, proper tensor manipulation is needed.\n11.5.4Exercises\n1.Visualize attention weights of multiple heads in this experiment.\n2.Suppose that we have a trained model based on multi-head attention and we want to\nprune less important attention heads to increase the prediction speed. How can we de-\nsign experiments to measure the importance of an attention head?\nDiscussions160.\n11.6Self-Attentionand PositionalEncoding\nIn deep learning, we often use CNNs or RNNs to encode sequences. Now with attention\nmechanisms in mind, imagine feeding a sequence of tokens into an attention mechanism\nsuchthatateverystep,eachtokenhasitsownquery,keys,andvalues. Here,whencomput-\ningthevalueofatoken\u2019srepresentationatthenextlayer,thetokencanattend(viaitsquery\nvector) to any other\u2019s token (matching based on their key vectors). Using the full set of\nquery-key compatibility scores, we can compute, for each token, a representation by build-\ning the appropriate weighted sum over the other tokens. Because every token is attending\nto each other token (unlike the case where decoder steps attend to encoder steps), such\narchitectures are typically described as self-attention models ( Linet al., 2017,Vaswaniet\nal., 2017), and elsewhere described as intra-attention model (Chenget al., 2016,Parikh\net al., 2016,Pauluset al., 2017). In this section, we will discuss sequence encoding using\nself-attention, including using additional information for the sequence order.\n436 Attention Mechanisms and Transformers\nimport math\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n11.6.1Self-Attention\nGiven a sequence of input tokens x1,...,x\ud835\udc5bwhere any x\ud835\udc562R\ud835\udc51(1\u0014\ud835\udc56\u0014\ud835\udc5b), its self-\nattention outputs a sequence of the same length y1,...,y\ud835\udc5b, where\ny\ud835\udc56=\ud835\udc53\u00b9x\ud835\udc56,\u00b9x1,x1\u00ba,...,\u00b9x\ud835\udc5b,x\ud835\udc5b\u00ba\u00ba2R\ud835\udc51(11.6.1)\naccording to the definition of attention pooling in (11.1.1 ). Using multi-head attention,\nthe following code snippet computes the self-attention of a tensor with shape (batch size,\nnumber of time steps or sequence length in tokens, \ud835\udc51). The output tensor has the same\nshape.\nnum_hiddens, num_heads =100,5\nattention =d2l.MultiHeadAttention(num_hiddens, num_heads, 0.5)\nbatch_size, num_queries, valid_lens =2,4, torch .tensor([ 3,2])\nX=torch .ones((batch_size, num_queries, num_hiddens))\nd2l.check_shape(attention(X, X, X, valid_lens),\n(batch_size, num_queries, num_hiddens))\n11.6.2ComparingCNNs, RNNs, and Self-Attention\nLet\u2019s compare architectures for mapping a sequence of \ud835\udc5btokens to another one of equal\nlength, where each input or output token is represented by a \ud835\udc51-dimensional vector. Specif-\nically, we will consider CNNs, RNNs, and self-attention. We will compare their computa-\ntional complexity, sequential operations, and maximum path lengths. Note that sequential\noperations prevent parallel computation, while a shorter path between any combination of\nsequence positions makes it easier to learn long-range dependencies within the sequence\n(Hochreiter etal., 2001).\nLet\u2019s regard any text sequence as a \u201cone-dimensional image\u201d. Similarly, one-dimensional\nCNNscanprocesslocalfeaturessuchas \ud835\udc5b-gramsintext. Givenasequenceoflength \ud835\udc5b,con-\nsider a convolutional layer whose kernel size is \ud835\udc58, and whose numbers of input and output\nchannels are both \ud835\udc51. The computational complexity of the convolutional layer is O\u00b9\ud835\udc58\ud835\udc5b\ud835\udc512\u00ba.\nAsFig. 11.6.1 shows, CNNs are hierarchical, so there are O\u00b91\u00basequential operations and\nthe maximum path length is O\u00b9\ud835\udc5b\u009d\ud835\udc58\u00ba. For example, x1andx5are within the receptive field\nof a two-layer CNN with kernel size 3 in Fig. 11.6.1 .\nWhenupdatingthehiddenstateofRNNs,multiplicationofthe \ud835\udc51\u0002\ud835\udc51weightmatrixandthe\n\ud835\udc51-dimensional hidden state has a computational complexity of O\u00b9\ud835\udc512\u00ba.", "mimetype": "text/plain", "start_char_idx": 1007256, "end_char_idx": 1010976, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a30de74e-e646-4077-bf63-53cb6290d3d5": {"__data__": {"id_": "a30de74e-e646-4077-bf63-53cb6290d3d5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2fa30afc-b0e1-4854-8dfd-77d05249d86f", "node_type": "1", "metadata": {}, "hash": "6d44740ac7ae6707a5a58a07755f1274eb3a3aab4e21555468e856fd0134016a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "55083392-a9aa-4796-a0a8-1891632c1ed9", "node_type": "1", "metadata": {}, "hash": "354821a817886fb33f125a74cd0695ff190a123e48b13a22b4935eb093b5377c", "class_name": "RelatedNodeInfo"}}, "text": "Givenasequenceoflength \ud835\udc5b,con-\nsider a convolutional layer whose kernel size is \ud835\udc58, and whose numbers of input and output\nchannels are both \ud835\udc51. The computational complexity of the convolutional layer is O\u00b9\ud835\udc58\ud835\udc5b\ud835\udc512\u00ba.\nAsFig. 11.6.1 shows, CNNs are hierarchical, so there are O\u00b91\u00basequential operations and\nthe maximum path length is O\u00b9\ud835\udc5b\u009d\ud835\udc58\u00ba. For example, x1andx5are within the receptive field\nof a two-layer CNN with kernel size 3 in Fig. 11.6.1 .\nWhenupdatingthehiddenstateofRNNs,multiplicationofthe \ud835\udc51\u0002\ud835\udc51weightmatrixandthe\n\ud835\udc51-dimensional hidden state has a computational complexity of O\u00b9\ud835\udc512\u00ba. Since the sequence\nlength is\ud835\udc5b, the computational complexity of the recurrent layer is O\u00b9\ud835\udc5b\ud835\udc512\u00ba. According\ntoFig. 11.6.1 , there areO\u00b9\ud835\udc5b\u00basequential operations that cannot be parallelized and the\nmaximum path length is also O\u00b9\ud835\udc5b\u00ba.\n437 Self-Attention and Positional Encoding\ntFig. 11.6.1 Comparing CNN (padding tokens are omitted), RNN, and self-attention architectures.\nIn self-attention, the queries, keys, and values are all \ud835\udc5b\u0002\ud835\udc51matrices. Consider the scaled\ndotproductattentionin (11.3.6 ),wherean\ud835\udc5b\u0002\ud835\udc51matrixismultipliedbya \ud835\udc51\u0002\ud835\udc5bmatrix,then\ntheoutput\ud835\udc5b\u0002\ud835\udc5bmatrixismultipliedbyan \ud835\udc5b\u0002\ud835\udc51matrix. Asaresult, theself-attentionhasa\nO\u00b9\ud835\udc5b2\ud835\udc51\u00bacomputational complexity. As we can see from Fig. 11.6.1 , each token is directly\nconnectedtoanyothertokenviaself-attention. Therefore,computationcanbeparallelwith\nO\u00b91\u00basequential operations and the maximum path length is also O\u00b91\u00ba.\nAll in all, both CNNs and self-attention enjoy parallel computation and self-attention has\nthe shortest maximum path length. However, the quadratic computational complexity with\nrespect to the sequence length makes self-attention prohibitively slow for very long se-\nquences.\n11.6.3Positional Encoding\nUnlike RNNs, which recurrently process tokens of a sequence one-by-one, self-attention\nditches sequential operations in favor of parallel computation. Note that self-attention by\nitself does not preserve the order of the sequence. What do we do if it really matters that\nthe model knows in which order the input sequence arrived?\nThedominantapproachforpreservinginformationabouttheorderoftokensistorepresent\nthis to the model as an additional input associated with each token. These inputs are called\npositional encodings , and they can either be learned or fixed a priori. We now describe a\nsimple scheme for fixed positional encodings based on sine and cosine functions ( Vaswani\netal., 2017).\nSuppose that the input representation X2R\ud835\udc5b\u0002\ud835\udc51contains the \ud835\udc51-dimensional embeddings\nfor\ud835\udc5btokens of a sequence. The positional encoding outputs X\u00b8Pusing a positional\nembedding matrix P2R\ud835\udc5b\u0002\ud835\udc51of the same shape, whose element on the \ud835\udc56throw and the\n438 Attention Mechanisms and Transformers\n\u00b92\ud835\udc57\u00bathor the\u00b92\ud835\udc57\u00b81\u00bathcolumn is\n\ud835\udc5d\ud835\udc56,2\ud835\udc57=sin\u0012\ud835\udc56\n100002\ud835\udc57\u009d\ud835\udc51\u0013\n,\n\ud835\udc5d\ud835\udc56,2\ud835\udc57\u00b81=cos\u0012\ud835\udc56\n100002\ud835\udc57\u009d\ud835\udc51\u0013\n.(11.6.2)\nAtfirstglance,thistrigonometricfunctiondesignlooksweird. Beforewegiveexplanations\nof this design, let\u2019s first implement it in the following PositionalEncoding class.\nclass PositionalEncoding (nn.Module): #@save\n\"\"\"Positional encoding.\"\"\"", "mimetype": "text/plain", "start_char_idx": 1010397, "end_char_idx": 1013434, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "55083392-a9aa-4796-a0a8-1891632c1ed9": {"__data__": {"id_": "55083392-a9aa-4796-a0a8-1891632c1ed9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a30de74e-e646-4077-bf63-53cb6290d3d5", "node_type": "1", "metadata": {}, "hash": "998343da3ff876dc4dfdd8aea4f5da5d0e6cf42f384a02381907abb33615fbdb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "eaaf5dc4-4dd6-4777-b169-68bff69bf2d1", "node_type": "1", "metadata": {}, "hash": "a4d096bfcb65f98bc1487f2b662a9b0a4806bf4c3c4269df7c75196518e74374", "class_name": "RelatedNodeInfo"}}, "text": "The positional encoding outputs X\u00b8Pusing a positional\nembedding matrix P2R\ud835\udc5b\u0002\ud835\udc51of the same shape, whose element on the \ud835\udc56throw and the\n438 Attention Mechanisms and Transformers\n\u00b92\ud835\udc57\u00bathor the\u00b92\ud835\udc57\u00b81\u00bathcolumn is\n\ud835\udc5d\ud835\udc56,2\ud835\udc57=sin\u0012\ud835\udc56\n100002\ud835\udc57\u009d\ud835\udc51\u0013\n,\n\ud835\udc5d\ud835\udc56,2\ud835\udc57\u00b81=cos\u0012\ud835\udc56\n100002\ud835\udc57\u009d\ud835\udc51\u0013\n.(11.6.2)\nAtfirstglance,thistrigonometricfunctiondesignlooksweird. Beforewegiveexplanations\nof this design, let\u2019s first implement it in the following PositionalEncoding class.\nclass PositionalEncoding (nn.Module): #@save\n\"\"\"Positional encoding.\"\"\"\ndef __init__ (self , num_hiddens, dropout, max_len =1000 ):\nsuper ().__init__ ()\nself .dropout =nn.Dropout(dropout)\n# Create a long enough P\nself .P=torch .zeros(( 1, max_len, num_hiddens))\nX=torch .arange(max_len, dtype =torch .float32) .reshape(\n-1,1)/torch .pow( 10000 , torch .arange(\n0, num_hiddens, 2, dtype =torch .float32) /num_hiddens)\nself .P[:, :, 0::2]=torch .sin(X)\nself .P[:, :, 1::2]=torch .cos(X)\ndef forward (self , X):\nX=X+self .P[:, :X .shape[ 1], :] .to(X .device)\nreturn self .dropout(X)\nIn the positional embedding matrix P, rows correspond to positions within a sequence and\ncolumns represent different positional encoding dimensions. In the example below, we\ncan see that the 6thand the 7thcolumns of the positional embedding matrix have a higher\nfrequencythanthe 8thandthe 9thcolumns. Theoffsetbetweenthe 6thandthe 7th(samefor\nthe8thand the 9th) columns is due to the alternation of sine and cosine functions.\nencoding_dim, num_steps =32,60\npos_encoding =PositionalEncoding(encoding_dim, 0)\nX=pos_encoding(torch .zeros(( 1, num_steps, encoding_dim)))\nP=pos_encoding .P[:, :X .shape[ 1], :]\nd2l.plot(torch .arange(num_steps), P[ 0, :, 6:10].T, xlabel ='Row (position) ',\nfigsize =(6,2.5), legend =[\"Col %d\"%dfor dintorch .arange( 6,10)])\n\n439 Self-Attention and Positional Encoding\nAbsolutePositionalInformation\nTo see how the monotonically decreased frequency along the encoding dimension relates\nto absolute positional information, let\u2019s print out the binary representations of 0,1,..., 7.\nAs we can see, the lowest bit, the second-lowest bit, and the third-lowest bit alternate on\nevery number, every two numbers, and every four numbers, respectively.\nfor iinrange (8):\nprint (f'{i}in binary is {i:>03b }')\n0inbinary is000\n1inbinary is001\n2inbinary is010\n3inbinary is011\n4inbinary is100\n5inbinary is101\n6inbinary is110\n7inbinary is111\nIn binary representations, a higher bit has a lower frequency than a lower bit. Similarly,\nas demonstrated in the heat map below, the positional encoding decreases frequencies\nalongtheencodingdimensionbyusingtrigonometricfunctions. Sincetheoutputsarefloat\nnumbers, such continuous representations are more space-efficient than binary representa-\ntions.\nP=P[0, :, :] .unsqueeze( 0).unsqueeze( 0)\nd2l.show_heatmaps(P, xlabel ='Column (encoding dimension) ',\nylabel ='Row (position) ', figsize =(3.5,4), cmap ='Blues ')\nRelativePositionalInformation\nBesides capturing absolute positional information, the above positional encoding also al-\nlows a model to easily learn to attend by relative positions. This is because for any fixed\n440 Attention Mechanisms and Transformers\n161position offset \ud835\udeff, the positional encoding at position \ud835\udc56\u00b8\ud835\udeffcan be represented by a linear\nprojection of that at position \ud835\udc56.\nThis projection can be explained mathematically.", "mimetype": "text/plain", "start_char_idx": 1012933, "end_char_idx": 1016242, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "eaaf5dc4-4dd6-4777-b169-68bff69bf2d1": {"__data__": {"id_": "eaaf5dc4-4dd6-4777-b169-68bff69bf2d1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "55083392-a9aa-4796-a0a8-1891632c1ed9", "node_type": "1", "metadata": {}, "hash": "354821a817886fb33f125a74cd0695ff190a123e48b13a22b4935eb093b5377c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "338753a6-aa61-4edd-84ef-a88828170e6e", "node_type": "1", "metadata": {}, "hash": "92cd5a1d7da6e58ec869a352bf0986fe1cd642b33ce40025d5ccefa25051faef", "class_name": "RelatedNodeInfo"}}, "text": "Similarly,\nas demonstrated in the heat map below, the positional encoding decreases frequencies\nalongtheencodingdimensionbyusingtrigonometricfunctions. Sincetheoutputsarefloat\nnumbers, such continuous representations are more space-efficient than binary representa-\ntions.\nP=P[0, :, :] .unsqueeze( 0).unsqueeze( 0)\nd2l.show_heatmaps(P, xlabel ='Column (encoding dimension) ',\nylabel ='Row (position) ', figsize =(3.5,4), cmap ='Blues ')\nRelativePositionalInformation\nBesides capturing absolute positional information, the above positional encoding also al-\nlows a model to easily learn to attend by relative positions. This is because for any fixed\n440 Attention Mechanisms and Transformers\n161position offset \ud835\udeff, the positional encoding at position \ud835\udc56\u00b8\ud835\udeffcan be represented by a linear\nprojection of that at position \ud835\udc56.\nThis projection can be explained mathematically. Denoting \ud835\udf14\ud835\udc57=1\u009d100002\ud835\udc57\u009d\ud835\udc51, any pair\nof\u00b9\ud835\udc5d\ud835\udc56,2\ud835\udc57,\ud835\udc5d\ud835\udc56,2\ud835\udc57\u00b81\u00bain(11.6.2 )can be linearly projected to \u00b9\ud835\udc5d\ud835\udc56\u00b8\ud835\udeff,2\ud835\udc57,\ud835\udc5d\ud835\udc56\u00b8\ud835\udeff,2\ud835\udc57\u00b81\u00bafor any fixed\noffset\ud835\udeff:\n\u0014cos\u00b9\ud835\udeff\ud835\udf14\ud835\udc57\u00ba sin\u00b9\ud835\udeff\ud835\udf14\ud835\udc57\u00ba\n\u0000sin\u00b9\ud835\udeff\ud835\udf14\ud835\udc57\u00bacos\u00b9\ud835\udeff\ud835\udf14\ud835\udc57\u00ba\u0015 \u0014\ud835\udc5d\ud835\udc56,2\ud835\udc57\n\ud835\udc5d\ud835\udc56,2\ud835\udc57\u00b81\u0015\n=\u0014cos\u00b9\ud835\udeff\ud835\udf14\ud835\udc57\u00basin\u00b9\ud835\udc56\ud835\udf14\ud835\udc57\u00ba\u00b8sin\u00b9\ud835\udeff\ud835\udf14\ud835\udc57\u00bacos\u00b9\ud835\udc56\ud835\udf14\ud835\udc57\u00ba\n\u0000sin\u00b9\ud835\udeff\ud835\udf14\ud835\udc57\u00basin\u00b9\ud835\udc56\ud835\udf14\ud835\udc57\u00ba\u00b8cos\u00b9\ud835\udeff\ud835\udf14\ud835\udc57\u00bacos\u00b9\ud835\udc56\ud835\udf14\ud835\udc57\u00ba\u0015\n=\u0014sin\u0000\u00b9\ud835\udc56\u00b8\ud835\udeff\u00ba\ud835\udf14\ud835\udc57\u0001\ncos\u0000\u00b9\ud835\udc56\u00b8\ud835\udeff\u00ba\ud835\udf14\ud835\udc57\u0001\u0015\n=\u0014\ud835\udc5d\ud835\udc56\u00b8\ud835\udeff,2\ud835\udc57\n\ud835\udc5d\ud835\udc56\u00b8\ud835\udeff,2\ud835\udc57\u00b81\u0015\n,\n(11.6.3)\nwhere the 2\u00022projection matrix does not depend on any position index \ud835\udc56.\n11.6.4Summary\nIn self-attention, the queries, keys, and values all come from the same place. Both CNNs\nand self-attention enjoy parallel computation and self-attention has the shortest maximum\npathlength. However,thequadraticcomputationalcomplexitywithrespecttothesequence\nlengthmakesself-attentionprohibitivelyslowforverylongsequences. Tousethesequence\norder information, we can inject absolute or relative positional information by adding po-\nsitional encoding to the input representations.\n11.6.5Exercises\n1.Suppose that we design a deep architecture to represent a sequence by stacking self-\nattention layers with positional encoding. What could the possible issues be?\n2.Can you design a learnable positional encoding method?\n3.Canweassigndifferentlearnedembeddingsaccordingtodifferentoffsetsbetweenqueries\nand keys that are compared in self-attention? Hint: you may refer to relative position\nembeddings ( Huangetal., 2018,Shawetal., 2018).\nDiscussions161.\n11.7The TransformerArchitecture\nWe have compared CNNs, RNNs, and self-attention in Section 11.6.2 . Notably, self-\nattention enjoys both parallel computation and the shortest maximum path length. There-\nfore, it is appealing to design deep architectures by using self-attention. Unlike earlier\nself-attention models that still rely on RNNs for input representations ( Chenget al., 2016,\n441 The Transformer Architecture\nLinet al., 2017,Pauluset al., 2017), the Transformer model is solely based on attention\nmechanisms without any convolutional or recurrent layer ( Vaswaniet al., 2017).", "mimetype": "text/plain", "start_char_idx": 1015377, "end_char_idx": 1018185, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "338753a6-aa61-4edd-84ef-a88828170e6e": {"__data__": {"id_": "338753a6-aa61-4edd-84ef-a88828170e6e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "eaaf5dc4-4dd6-4777-b169-68bff69bf2d1", "node_type": "1", "metadata": {}, "hash": "a4d096bfcb65f98bc1487f2b662a9b0a4806bf4c3c4269df7c75196518e74374", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f7a824d0-2277-4083-b89e-795153a4c489", "node_type": "1", "metadata": {}, "hash": "a91595c1bdf29a1174662386812d7a88102f2330bf5305c59ac5717c4b92b379", "class_name": "RelatedNodeInfo"}}, "text": "Hint: you may refer to relative position\nembeddings ( Huangetal., 2018,Shawetal., 2018).\nDiscussions161.\n11.7The TransformerArchitecture\nWe have compared CNNs, RNNs, and self-attention in Section 11.6.2 . Notably, self-\nattention enjoys both parallel computation and the shortest maximum path length. There-\nfore, it is appealing to design deep architectures by using self-attention. Unlike earlier\nself-attention models that still rely on RNNs for input representations ( Chenget al., 2016,\n441 The Transformer Architecture\nLinet al., 2017,Pauluset al., 2017), the Transformer model is solely based on attention\nmechanisms without any convolutional or recurrent layer ( Vaswaniet al., 2017). Though\noriginallyproposedforsequence-to-sequencelearningontextdata,Transformershavebeen\npervasiveinawiderangeofmoderndeeplearningapplications, suchasinareastodowith\nlanguage, vision, speech, and reinforcement learning.\nimport math\nimport pandas aspd\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n11.7.1Model\nAs an instance of the encoder\u2013decoder architecture, the overall architecture of the Trans-\nformer is presented in Fig. 11.7.1 . As we can see, the Transformer is composed of an en-\ncoder and a decoder. In contrast to Bahdanau attention for sequence-to-sequence learning\ninFig. 11.4.2 , the input (source) and output (target) sequence embeddings are added with\npositional encoding before being fed into the encoder and the decoder that stack modules\nbased on self-attention.\nNowweprovideanoverviewoftheTransformerarchitecturein Fig.11.7.1 . Atahighlevel,\nthe Transformer encoder is a stack of multiple identical layers, where each layer has two\nsublayers (either is denoted as sublayer). The first is a multi-head self-attention pooling\nand the second is a positionwise feed-forward network. Specifically, in the encoder self-\nattention, queries, keys, and values are all from the outputs of the previous encoder layer.\nInspired by the ResNet design of Section 8.6 , a residual connection is employed around\nboth sublayers. In the Transformer, for any input x2R\ud835\udc51at any position of the sequence,\nwe require that sublayer \u00b9x\u00ba2R\ud835\udc51so that the residual connection x\u00b8sublayer\u00b9x\u00ba2R\ud835\udc51is\nfeasible. This addition from the residual connection is immediately followed by layer nor-\nmalization ( Baetal., 2016). As a result, the Transformer encoder outputs a \ud835\udc51-dimensional\nvector representation for each position of the input sequence.\nThe Transformer decoder is also a stack of multiple identical layers with residual connec-\ntions and layer normalizations. As well as the two sublayers described in the encoder, the\ndecoder inserts a third sublayer, known as the encoder\u2013decoder attention, between these\ntwo. In the encoder\u2013decoder attention, queries are from the outputs of the decoder\u2019s self-\nattention sublayer, and the keys and values are from the Transformer encoder outputs. In\nthedecoderself-attention, queries, keys, andvaluesareallfromtheoutputsoftheprevious\ndecoder layer. However, each position in the decoder is allowed only to attend to all posi-\ntions in the decoder up to that position. This maskedattention preserves the autoregressive\nproperty, ensuring that the prediction only depends on those output tokens that have been\ngenerated.\nWehavealreadydescribedandimplementedmulti-headattentionbasedonscaleddotprod-\nucts inSection 11.5 and positional encoding in Section 11.6.3 . In the following, we will\nimplement the rest of the Transformer model.\n442 Attention Mechanisms and Transformers\ntFig. 11.7.1 The Transformer architecture.\n11.7.2PositionwiseFeed-ForwardNetworks\nThe positionwise feed-forward network transforms the representation at all the sequence\npositions using the same MLP. This is why we call it positionwise . In the implementation\nbelow,theinput Xwithshape(batchsize,numberoftimestepsorsequencelengthintokens,\nnumber of hidden units or feature dimension) will be transformed by a two-layer MLP into\nan output tensor of shape (batch size, number of time steps, ffn_num_outputs ).\nclass PositionWiseFFN (nn.Module): #@save\n\"\"\"The positionwise feed-forward network.\"\"\"", "mimetype": "text/plain", "start_char_idx": 1017493, "end_char_idx": 1021597, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f7a824d0-2277-4083-b89e-795153a4c489": {"__data__": {"id_": "f7a824d0-2277-4083-b89e-795153a4c489", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "338753a6-aa61-4edd-84ef-a88828170e6e", "node_type": "1", "metadata": {}, "hash": "92cd5a1d7da6e58ec869a352bf0986fe1cd642b33ce40025d5ccefa25051faef", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "360d7fc7-f58d-4cb8-874d-e87e393dea73", "node_type": "1", "metadata": {}, "hash": "a4b5655930bac830838f0150dcb25d2328d76f0aeb8f924c090f8d5954200f72", "class_name": "RelatedNodeInfo"}}, "text": "Wehavealreadydescribedandimplementedmulti-headattentionbasedonscaleddotprod-\nucts inSection 11.5 and positional encoding in Section 11.6.3 . In the following, we will\nimplement the rest of the Transformer model.\n442 Attention Mechanisms and Transformers\ntFig. 11.7.1 The Transformer architecture.\n11.7.2PositionwiseFeed-ForwardNetworks\nThe positionwise feed-forward network transforms the representation at all the sequence\npositions using the same MLP. This is why we call it positionwise . In the implementation\nbelow,theinput Xwithshape(batchsize,numberoftimestepsorsequencelengthintokens,\nnumber of hidden units or feature dimension) will be transformed by a two-layer MLP into\nan output tensor of shape (batch size, number of time steps, ffn_num_outputs ).\nclass PositionWiseFFN (nn.Module): #@save\n\"\"\"The positionwise feed-forward network.\"\"\"\ndef __init__ (self , ffn_num_hiddens, ffn_num_outputs):\nsuper ().__init__ ()\nself .dense1 =nn.LazyLinear(ffn_num_hiddens)\nself .relu =nn.ReLU()\nself .dense2 =nn.LazyLinear(ffn_num_outputs)\ndef forward (self , X):\nreturn self .dense2( self .relu( self .dense1(X)))\nThefollowingexampleshowsthattheinnermostdimensionofatensorchangestothenum-\n443 The Transformer Architecture\nber of outputs in the positionwise feed-forward network. Since the same MLP transforms\natallthepositions,whentheinputsatallthesepositionsarethesame,theiroutputsarealso\nidentical.\nffn =PositionWiseFFN( 4,8)\nffn.eval()\nffn(torch .ones(( 2,3,4)))[ 0]\ntensor([[ 0.6300 ,0.7739 ,0.0278 ,0.2508 ,-0.0519 ,0.4881 ,-0.4105 ,0.\n\u21a9!5163 ],\n[0.6300 ,0.7739 ,0.0278 ,0.2508 ,-0.0519 ,0.4881 ,-0.4105 ,0.\n\u21a9!5163 ],\n[0.6300 ,0.7739 ,0.0278 ,0.2508 ,-0.0519 ,0.4881 ,-0.4105 ,0.\n\u21a9!5163 ]],\ngrad_fn =<SelectBackward0 >)\n11.7.3Residual Connection and LayerNormalization\nNow let\u2019s focus on the \u201cadd & norm\u201d component in Fig. 11.7.1 . As we described at the\nbeginning of this section, this is a residual connection immediately followed by layer nor-\nmalization. Both are key to effective deep architectures.\nInSection 8.5 , we explained how batch normalization recenters and rescales across the\nexampleswithinaminibatch. Asdiscussedin Section8.5.2 ,layernormalizationisthesame\nasbatchnormalizationexceptthattheformernormalizesacrossthefeaturedimension,thus\nenjoyingbenefitsofscaleindependenceandbatchsizeindependence. Despiteitspervasive\napplications in computer vision, batch normalization is usually empirically less effective\nthan layer normalization in natural language processing tasks, where the inputs are often\nvariable-length sequences.\nThe following code snippet compares the normalization across different dimensions by\nlayer normalization and batch normalization.\nln=nn.LayerNorm( 2)\nbn=nn.LazyBatchNorm1d()\nX=torch .tensor([[ 1,2], [ 2,3]], dtype =torch .float32)\n# Compute mean and variance from X in the training mode\nprint ('layer norm: ', ln(X), '\\nbatch norm: ', bn(X))\nlayer norm: tensor([[ -1.0000 ,1.0000 ],\n[-1.0000 ,1.0000 ]], grad_fn =<NativeLayerNormBackward0 >)\nbatch norm: tensor([[ -1.0000 ,-1.0000 ],\n[1.0000 ,1.0000 ]], grad_fn =<NativeBatchNormBackward0 >)\nNow we can implement the AddNorm class using a residual connection followed by layer\nnormalization. Dropout is also applied for regularization.\n444 Attention Mechanisms and Transformers\nclass AddNorm (nn.Module): #@save\n\"\"\"The residual connection followed by layer normalization.\"\"\"", "mimetype": "text/plain", "start_char_idx": 1020749, "end_char_idx": 1024120, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "360d7fc7-f58d-4cb8-874d-e87e393dea73": {"__data__": {"id_": "360d7fc7-f58d-4cb8-874d-e87e393dea73", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f7a824d0-2277-4083-b89e-795153a4c489", "node_type": "1", "metadata": {}, "hash": "a91595c1bdf29a1174662386812d7a88102f2330bf5305c59ac5717c4b92b379", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "90f09988-290a-473d-a99b-1037d2b67520", "node_type": "1", "metadata": {}, "hash": "3bb91b5728e8d5e8a645208da59ada21b09b026b9124cddd90dab9fdb15246e4", "class_name": "RelatedNodeInfo"}}, "text": "Dropout is also applied for regularization.\n444 Attention Mechanisms and Transformers\nclass AddNorm (nn.Module): #@save\n\"\"\"The residual connection followed by layer normalization.\"\"\"\ndef __init__ (self , norm_shape, dropout):\nsuper ().__init__ ()\nself .dropout =nn.Dropout(dropout)\nself .ln=nn.LayerNorm(norm_shape)\ndef forward (self , X, Y):\nreturn self .ln(self .dropout(Y) +X)\nTheresidualconnectionrequiresthatthetwoinputsareofthesameshapesothattheoutput\ntensor also has the same shape after the addition operation.\nadd_norm =AddNorm( 4,0.5)\nshape =(2,3,4)\nd2l.check_shape(add_norm(torch .ones(shape), torch .ones(shape)), shape)\n11.7.4Encoder\nWith all the essential components to assemble the Transformer encoder, let\u2019s start by im-\nplementing a single layer within the encoder. The following TransformerEncoderBlock\nclass contains two sublayers: multi-head self-attention and positionwise feed-forward net-\nworks, where a residual connection followed by layer normalization is employed around\nboth sublayers.\nclass TransformerEncoderBlock (nn.Module): #@save\n\"\"\"The Transformer encoder block.\"\"\"\ndef __init__ (self , num_hiddens, ffn_num_hiddens, num_heads, dropout,\nuse_bias =False ):\nsuper ().__init__ ()\nself .attention =d2l.MultiHeadAttention(num_hiddens, num_heads,\ndropout, use_bias)\nself .addnorm1 =AddNorm(num_hiddens, dropout)\nself .ffn =PositionWiseFFN(ffn_num_hiddens, num_hiddens)\nself .addnorm2 =AddNorm(num_hiddens, dropout)\ndef forward (self , X, valid_lens):\nY=self .addnorm1(X, self .attention(X, X, X, valid_lens))\nreturn self .addnorm2(Y, self .ffn(Y))\nAs we can see, no layer in the Transformer encoder changes the shape of its input.\nX=torch .ones(( 2,100,24))\nvalid_lens =torch .tensor([ 3,2])\nencoder_blk =TransformerEncoderBlock( 24,48,8,0.5)\nencoder_blk .eval()\nd2l.check_shape(encoder_blk(X, valid_lens), X .shape)\nIn the following Transformer encoder implementation, we stack num_blks instances of the\nabove TransformerEncoderBlock classes. Since we use the fixed positional encoding\n445 The Transformer Architecture\nwhose values are always between \u00001and1, we multiply values of the learnable input em-\nbeddings by the square root of the embedding dimension to rescale before summing up the\ninput embedding and the positional encoding.\nclass TransformerEncoder (d2l .Encoder): #@save\n\"\"\"The Transformer encoder.\"\"\"\ndef __init__ (self , vocab_size, num_hiddens, ffn_num_hiddens,\nnum_heads, num_blks, dropout, use_bias =False ):\nsuper ().__init__ ()\nself .num_hiddens =num_hiddens\nself .embedding =nn.Embedding(vocab_size, num_hiddens)\nself .pos_encoding =d2l.PositionalEncoding(num_hiddens, dropout)\nself .blks =nn.Sequential()\nfor iinrange (num_blks):\nself .blks .add_module( \"block \"+str(i), TransformerEncoderBlock(\nnum_hiddens, ffn_num_hiddens, num_heads, dropout, use_bias))\ndef forward (self , X, valid_lens):\n# Since positional encoding values are between -1 and 1, the embedding\n# values are multiplied by the square root of the embedding dimension\n# to rescale before they are summed up\nX=self .pos_encoding( self .embedding(X) *math .sqrt( self .num_hiddens))\nself .attention_weights =[None ]*len(self .blks)\nfor i, blk inenumerate (self .blks):\nX=blk(X, valid_lens)\nself .attention_weights[\ni]=blk.attention .attention .attention_weights\nreturn X\nBelowwespecifyhyperparameterstocreateatwo-layerTransformerencoder. Theshapeof\ntheTransformerencoderoutputis(batchsize,numberoftimesteps, num_hiddens ).\nencoder =TransformerEncoder( 200,24,48,8,2,0.5)\nd2l.check_shape(encoder(torch .ones(( 2,100), dtype =torch .long), valid_lens),\n(2,100,24))\n11.7.5Decoder\nAs shown in Fig. 11.7.1 , the Transformer decoder is composed of multiple identical lay-\ners. Each layer is implemented in the following TransformerDecoderBlock class, which\ncontains three sublayers: decoder self-attention, encoder\u2013decoder attention, and position-\nwise feed-forward networks.", "mimetype": "text/plain", "start_char_idx": 1023938, "end_char_idx": 1027825, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "90f09988-290a-473d-a99b-1037d2b67520": {"__data__": {"id_": "90f09988-290a-473d-a99b-1037d2b67520", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "360d7fc7-f58d-4cb8-874d-e87e393dea73", "node_type": "1", "metadata": {}, "hash": "a4b5655930bac830838f0150dcb25d2328d76f0aeb8f924c090f8d5954200f72", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "22714739-1ef0-4798-810e-82f79b3feca7", "node_type": "1", "metadata": {}, "hash": "853b8b834fe1cf93a3385b36862488569169febfabaddbc1dcf0d5732de5672a", "class_name": "RelatedNodeInfo"}}, "text": "Theshapeof\ntheTransformerencoderoutputis(batchsize,numberoftimesteps, num_hiddens ).\nencoder =TransformerEncoder( 200,24,48,8,2,0.5)\nd2l.check_shape(encoder(torch .ones(( 2,100), dtype =torch .long), valid_lens),\n(2,100,24))\n11.7.5Decoder\nAs shown in Fig. 11.7.1 , the Transformer decoder is composed of multiple identical lay-\ners. Each layer is implemented in the following TransformerDecoderBlock class, which\ncontains three sublayers: decoder self-attention, encoder\u2013decoder attention, and position-\nwise feed-forward networks. These sublayers employ a residual connection around them\nfollowed by layer normalization.\nAs we described earlier in this section, in the masked multi-head decoder self-attention\n(the first sublayer), queries, keys, and values all come from the outputs of the previous\ndecoder layer. When training sequence-to-sequence models, tokens at all the positions\n(time steps) of the output sequence are known. However, during prediction the output\nsequence is generated token by token; thus, at any decoder time step only the generated\ntokenscanbeusedinthedecoderself-attention. Topreserveautoregressioninthedecoder,\n446 Attention Mechanisms and Transformers\nits masked self-attention specifies dec_valid_lens so that any query only attends to all\npositions in the decoder up to the query position.\nclass TransformerDecoderBlock (nn.Module):\n# The i-th block in the Transformer decoder\ndef __init__ (self , num_hiddens, ffn_num_hiddens, num_heads, dropout, i):\nsuper ().__init__ ()\nself .i=i\nself .attention1 =d2l.MultiHeadAttention(num_hiddens, num_heads,\ndropout)\nself .addnorm1 =AddNorm(num_hiddens, dropout)\nself .attention2 =d2l.MultiHeadAttention(num_hiddens, num_heads,\ndropout)\nself .addnorm2 =AddNorm(num_hiddens, dropout)\nself .ffn =PositionWiseFFN(ffn_num_hiddens, num_hiddens)\nself .addnorm3 =AddNorm(num_hiddens, dropout)\ndef forward (self , X, state):\nenc_outputs, enc_valid_lens =state[ 0], state[ 1]\n# During training, all the tokens of any output sequence are processed\n# at the same time, so state[2][self.i] is None as initialized. When\n# decoding any output sequence token by token during prediction,\n# state[2][self.i] contains representations of the decoded output at\n# the i-th block up to the current time step\nifstate[ 2][self .i]isNone :\nkey_values =X\nelse :\nkey_values =torch .cat((state[ 2][self .i], X), dim =1)\nstate[ 2][self .i]=key_values\nifself .training:\nbatch_size, num_steps, _ =X.shape\n# Shape of dec_valid_lens: (batch_size, num_steps), where every\n# row is [1, 2, ..., num_steps]\ndec_valid_lens =torch .arange(\n1, num_steps +1, device =X.device) .repeat(batch_size, 1)\nelse :\ndec_valid_lens =None\n# Self-attention\nX2=self .attention1(X, key_values, key_values, dec_valid_lens)\nY=self .addnorm1(X, X2)\n# Encoder-decoder attention. Shape of enc_outputs:\n# (batch_size, num_steps, num_hiddens)\nY2=self .attention2(Y, enc_outputs, enc_outputs, enc_valid_lens)\nZ=self .addnorm2(Y, Y2)\nreturn self .addnorm3(Z, self .ffn(Z)), state\nTo facilitate scaled dot product operations in the encoder\u2013decoder attention and addition\noperationsintheresidualconnections,thefeaturedimension( num_hiddens )ofthedecoder\nis the same as that of the encoder.\ndecoder_blk =TransformerDecoderBlock( 24,48,8,0.5,0)\nX=torch .ones(( 2,100,24))\nstate =[encoder_blk(X, valid_lens), valid_lens, [ None ]]\nd2l.check_shape(decoder_blk(X, state)[ 0], X .shape)\n447 The Transformer Architecture\nNow we construct the entire Transformer decoder composed of num_blks instances of\nTransformerDecoderBlock . In the end, a fully connected layer computes the prediction\nfor all the vocab_size possible output tokens. Both of the decoder self-attention weights\nand the encoder\u2013decoder attention weights are stored for later visualization.", "mimetype": "text/plain", "start_char_idx": 1027294, "end_char_idx": 1031050, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "22714739-1ef0-4798-810e-82f79b3feca7": {"__data__": {"id_": "22714739-1ef0-4798-810e-82f79b3feca7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "90f09988-290a-473d-a99b-1037d2b67520", "node_type": "1", "metadata": {}, "hash": "3bb91b5728e8d5e8a645208da59ada21b09b026b9124cddd90dab9fdb15246e4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1ddc0ff5-2186-4b87-88a0-52849aa73e92", "node_type": "1", "metadata": {}, "hash": "c216b6d3c3e87a162fdee7d9b054214d4bf8df370c6b07bb2518e203acb1c6d7", "class_name": "RelatedNodeInfo"}}, "text": "decoder_blk =TransformerDecoderBlock( 24,48,8,0.5,0)\nX=torch .ones(( 2,100,24))\nstate =[encoder_blk(X, valid_lens), valid_lens, [ None ]]\nd2l.check_shape(decoder_blk(X, state)[ 0], X .shape)\n447 The Transformer Architecture\nNow we construct the entire Transformer decoder composed of num_blks instances of\nTransformerDecoderBlock . In the end, a fully connected layer computes the prediction\nfor all the vocab_size possible output tokens. Both of the decoder self-attention weights\nand the encoder\u2013decoder attention weights are stored for later visualization.\nclass TransformerDecoder (d2l .AttentionDecoder):\ndef __init__ (self , vocab_size, num_hiddens, ffn_num_hiddens, num_heads,\nnum_blks, dropout):\nsuper ().__init__ ()\nself .num_hiddens =num_hiddens\nself .num_blks =num_blks\nself .embedding =nn.Embedding(vocab_size, num_hiddens)\nself .pos_encoding =d2l.PositionalEncoding(num_hiddens, dropout)\nself .blks =nn.Sequential()\nfor iinrange (num_blks):\nself .blks .add_module( \"block \"+str(i), TransformerDecoderBlock(\nnum_hiddens, ffn_num_hiddens, num_heads, dropout, i))\nself .dense =nn.LazyLinear(vocab_size)\ndef init_state (self , enc_outputs, enc_valid_lens):\nreturn [enc_outputs, enc_valid_lens, [ None ]*self .num_blks]\ndef forward (self , X, state):\nX=self .pos_encoding( self .embedding(X) *math .sqrt( self .num_hiddens))\nself ._attention_weights =[[None ]*len(self .blks) for _inrange (2)]\nfor i, blk inenumerate (self .blks):\nX, state =blk(X, state)\n# Decoder self-attention weights\nself ._attention_weights[ 0][\ni]=blk.attention1 .attention .attention_weights\n# Encoder-decoder attention weights\nself ._attention_weights[ 1][\ni]=blk.attention2 .attention .attention_weights\nreturn self .dense(X), state\n@property\ndef attention_weights (self ):\nreturn self ._attention_weights\n11.7.6Training\nLet\u2019s instantiate an encoder\u2013decoder model by following the Transformer architecture.\nHere we specify that both the Transformer encoder and the Transformer decoder have two\nlayers using 4-head attention. As in Section 10.7.6 , we train the Transformer model for\nsequence-to-sequence learning on the English\u2013French machine translation dataset.\ndata =d2l.MTFraEng(batch_size =128)\nnum_hiddens, num_blks, dropout =256,2,0.2\nffn_num_hiddens, num_heads =64,4\nencoder =TransformerEncoder(\nlen(data .src_vocab), num_hiddens, ffn_num_hiddens, num_heads,\nnum_blks, dropout)\ndecoder =TransformerDecoder(\n(continues on next page)\n448 Attention Mechanisms and Transformers\n(continued from previous page)\nlen(data .tgt_vocab), num_hiddens, ffn_num_hiddens, num_heads,\nnum_blks, dropout)\nmodel =d2l.Seq2Seq(encoder, decoder, tgt_pad =data .tgt_vocab[ '<pad> '],\nlr=0.001 )\ntrainer =d2l.Trainer(max_epochs =30, gradient_clip_val =1, num_gpus =1)\ntrainer .fit(model, data)\nAfter training, we use the Transformer model to translate a few English sentences into\nFrench and compute their BLEU scores.\nengs =['go . ','i lost . ','he\\'s calm . ','i\\'m home . ']\nfras =['va ! ','j\\'ai perdu . ','il est calme . ','je suis chez moi . ']\npreds, _ =model .predict_step(\ndata .build(engs, fras), d2l .try_gpu(), data .num_steps)\nfor en, fr, p inzip(engs, fras, preds):\ntranslation =[]\nfor token indata .tgt_vocab .to_tokens(p):\niftoken =='<eos> ':\nbreak\ntranslation .append(token)\nprint (f'{en}=>{translation }, bleu, '\nf'{d2l.bleu( \"\".join(translation), fr, k=2):.3f}')\ngo.=>['va','!'], bleu, 1.000\ni lost .=>['je','perdu ','.'], bleu, 0.687\nhe's calm . => [ 'il','est','mouill\u00e9 ','.'], bleu,0.658\ni'm home .", "mimetype": "text/plain", "start_char_idx": 1030491, "end_char_idx": 1033979, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1ddc0ff5-2186-4b87-88a0-52849aa73e92": {"__data__": {"id_": "1ddc0ff5-2186-4b87-88a0-52849aa73e92", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "22714739-1ef0-4798-810e-82f79b3feca7", "node_type": "1", "metadata": {}, "hash": "853b8b834fe1cf93a3385b36862488569169febfabaddbc1dcf0d5732de5672a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7ade0e6f-0c37-4145-85b1-0789a13f21f7", "node_type": "1", "metadata": {}, "hash": "8fefb7a3979d0383c609782da03e1367d2ea7d99b5667395be2835e2869fd709", "class_name": "RelatedNodeInfo"}}, "text": "','il est calme . ','je suis chez moi . ']\npreds, _ =model .predict_step(\ndata .build(engs, fras), d2l .try_gpu(), data .num_steps)\nfor en, fr, p inzip(engs, fras, preds):\ntranslation =[]\nfor token indata .tgt_vocab .to_tokens(p):\niftoken =='<eos> ':\nbreak\ntranslation .append(token)\nprint (f'{en}=>{translation }, bleu, '\nf'{d2l.bleu( \"\".join(translation), fr, k=2):.3f}')\ngo.=>['va','!'], bleu, 1.000\ni lost .=>['je','perdu ','.'], bleu, 0.687\nhe's calm . => [ 'il','est','mouill\u00e9 ','.'], bleu,0.658\ni'm home . => [ 'je','suis ','chez ','moi','.'], bleu,1.000\nLet\u2019s visualize the Transformer attention weights when translating the final English sen-\ntence into French. The shape of the encoder self-attention weights is (number of encoder\nlayers, numberofattentionheads, num_steps ornumberofqueries, num_steps ornumber\nof key-value pairs).\n_, dec_attention_weights =model .predict_step(\ndata .build([engs[ -1]], [fras[ -1]]), d2l .try_gpu(), data .num_steps, True )\nenc_attention_weights =torch .cat(model .encoder .attention_weights, 0)\nshape =(num_blks, num_heads, -1, data .num_steps)\nenc_attention_weights =enc_attention_weights .reshape(shape)\n(continues on next page)\n449 The Transformer Architecture\n(continued from previous page)\nd2l.check_shape(enc_attention_weights,\n(num_blks, num_heads, data .num_steps, data .num_steps))\nIn the encoder self-attention, both queries and keys come from the same input sequence.\nSince padding tokens do not carry meaning, with specified valid length of the input se-\nquence no query attends to positions of padding tokens. In the following, two layers of\nmulti-head attention weights are presented row by row. Each head independently attends\nbased on a separate representation subspace of queries, keys, and values.\nd2l.show_heatmaps(\nenc_attention_weights .cpu(), xlabel ='Key positions ',\nylabel ='Query positions ', titles =['Head %d'%ifor iinrange (1,5)],\nfigsize =(7,3.5))\nTo visualize the decoder self-attention weights and the encoder\u2013decoder attention weights,\nwe need more data manipulations. For example, we fill the masked attention weights\nwith zero. Note that the decoder self-attention weights and the encoder\u2013decoder atten-\ntion weights both have the same queries: the beginning-of-sequence token followed by the\noutput tokens and possibly end-of-sequence tokens.\ndec_attention_weights_2d =[head[ 0].tolist()\nfor step indec_attention_weights\nfor attn instep for blk inattn for head inblk]\ndec_attention_weights_filled =torch .tensor(\npd.DataFrame(dec_attention_weights_2d) .fillna( 0.0).values)\nshape =(-1,2, num_blks, num_heads, data .num_steps)\ndec_attention_weights =dec_attention_weights_filled .reshape(shape)\ndec_self_attention_weights, dec_inter_attention_weights =\\\ndec_attention_weights .permute( 1,2,3,0,4)\nd2l.check_shape(dec_self_attention_weights,\n(num_blks, num_heads, data .num_steps, data .num_steps))\nd2l.check_shape(dec_inter_attention_weights,\n(num_blks, num_heads, data .num_steps, data .num_steps))\n450 Attention Mechanisms and Transformers\nBecause of the autoregressive property of the decoder self-attention, no query attends to\nkey\u2013value pairs after the query position.\nd2l.show_heatmaps(\ndec_self_attention_weights[:, :, :, :],\nxlabel ='Key positions ', ylabel ='Query positions ',\ntitles =['Head %d'%ifor iinrange (1,5)], figsize =(7,3.5))\nSimilar to the case in the encoder self-attention, via the specified valid length of the input\nsequence,noqueryfromtheoutputsequenceattendstothosepaddingtokensfromtheinput\nsequence.\nd2l.show_heatmaps(\ndec_inter_attention_weights, xlabel ='Key positions ',\nylabel ='Query positions ', titles =['Head %d'%ifor iinrange (1,5)],\nfigsize =(7,3.5))\nAlthough the Transformer architecture was originally proposed for sequence-to-sequence\nlearning, aswewilldiscoverlaterinthebook, eithertheTransformerencoderortheTrans-\nformer decoder is often individually used for different deep learning tasks.", "mimetype": "text/plain", "start_char_idx": 1033467, "end_char_idx": 1037380, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7ade0e6f-0c37-4145-85b1-0789a13f21f7": {"__data__": {"id_": "7ade0e6f-0c37-4145-85b1-0789a13f21f7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1ddc0ff5-2186-4b87-88a0-52849aa73e92", "node_type": "1", "metadata": {}, "hash": "c216b6d3c3e87a162fdee7d9b054214d4bf8df370c6b07bb2518e203acb1c6d7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4a410f7e-fd45-47e7-a87b-5fc9bff48df6", "node_type": "1", "metadata": {}, "hash": "76b2938c019f22b1537d2aa04b032f47cb75ee4be9949eec18e9bd27222cb0c2", "class_name": "RelatedNodeInfo"}}, "text": "d2l.show_heatmaps(\ndec_self_attention_weights[:, :, :, :],\nxlabel ='Key positions ', ylabel ='Query positions ',\ntitles =['Head %d'%ifor iinrange (1,5)], figsize =(7,3.5))\nSimilar to the case in the encoder self-attention, via the specified valid length of the input\nsequence,noqueryfromtheoutputsequenceattendstothosepaddingtokensfromtheinput\nsequence.\nd2l.show_heatmaps(\ndec_inter_attention_weights, xlabel ='Key positions ',\nylabel ='Query positions ', titles =['Head %d'%ifor iinrange (1,5)],\nfigsize =(7,3.5))\nAlthough the Transformer architecture was originally proposed for sequence-to-sequence\nlearning, aswewilldiscoverlaterinthebook, eithertheTransformerencoderortheTrans-\nformer decoder is often individually used for different deep learning tasks.\n11.7.7Summary\n451 Transformers for Vision\n162The Transformer is an instance of the encoder\u2013decoder architecture, though either the en-\ncoder or the decoder can be used individually in practice. In the Transformer architec-\nture, multi-head self-attention is used for representing the input sequence and the output\nsequence, though the decoder has to preserve the autoregressive property via a masked\nversion. Both the residual connections and the layer normalization in the Transformer are\nimportant for training a very deep model. The positionwise feed-forward network in the\nTransformer model transforms the representation at all the sequence positions using the\nsame MLP.\n11.7.8Exercises\n1.Train a deeper Transformer in the experiments. How does it affect the training speed\nand the translation performance?\n2.Is it a good idea to replace scaled dot product attention with additive attention in the\nTransformer? Why?\n3.Forlanguagemodeling,shouldweusetheTransformerencoder,decoder,orboth? How\nwould you design this method?\n4.What challenges can Transformers face if input sequences are very long? Why?\n5.How would you improve the computational and memory efficiency of Transformers?\nHint: you may refer to the survey paper by Tay etal.(2020).\nDiscussions162.\n11.8TransformersforVision\nThe Transformer architecture was initially proposed for sequence-to-sequence learning,\nwith a focus on machine translation. Subsequently, Transformers emerged as the model\nof choice in various natural language processing tasks ( Brownet al., 2020,Devlinet al.,\n2018,Radfordetal.,2018,Radfordetal.,2019,Raffeletal.,2020). However,inthefieldof\ncomputer vision the dominant architecture has remained the CNN ( Chapter 8 ). Naturally,\nresearchers started to wonder if it might be possible to do better by adapting Transformer\nmodelstoimagedata. Thisquestionsparkedimmenseinterestinthecomputervisioncom-\nmunity. Recently, Ramachandran et al.(2019) proposed a scheme for replacing convolu-\ntion with self-attention. However, its use of specialized patterns in attention makes it hard\nto scale up models on hardware accelerators. Then, Cordonnier et al.(2020) theoretically\nproved that self-attention can learn to behave similarly to convolution. Empirically, 2\u00022\npatches were taken from images as inputs, but the small patch size makes the model only\napplicable to image data with low resolutions.\nWithout specific constraints on patch size, visionTransformers (ViTs) extract patches from\nimages and feed them into a Transformer encoder to obtain a global representation, which\n452 Attention Mechanisms and Transformers\nwillfinallybetransformedforclassification( Dosovitskiy etal.,2021). Notably,Transform-\ners show better scalability than CNNs: and when training larger models on larger datasets,\nvision Transformers outperform ResNets by a significant margin. Similar to the landscape\nof network architecture design in natural language processing, Transformers have also be-\ncome a game-changer in computer vision.\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n11.8.1Model\nFig.11.8.1 depictsthemodelarchitectureofvisionTransformers. Thisarchitectureconsists\nof a stem that patchifies images, a body based on the multilayer Transformer encoder, and\na head that transforms the global representation into the output label.\ntFig. 11.8.1 The vision Transformer architecture. In this example, an image is split into nine patches.\nA special \u201c<cls>\u201d token and the nine \ufb02attened image patches are transformed via patch\nembedding and nTransformer encoder blocks into ten representations, respectively. The\n\u201c<cls>\u201d representation is further transformed into the output label.\nConsider an input image with height \u210e, width\ud835\udc64, and\ud835\udc50channels.", "mimetype": "text/plain", "start_char_idx": 1036621, "end_char_idx": 1041105, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4a410f7e-fd45-47e7-a87b-5fc9bff48df6": {"__data__": {"id_": "4a410f7e-fd45-47e7-a87b-5fc9bff48df6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7ade0e6f-0c37-4145-85b1-0789a13f21f7", "node_type": "1", "metadata": {}, "hash": "8fefb7a3979d0383c609782da03e1367d2ea7d99b5667395be2835e2869fd709", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c63a68a3-d998-4ee7-af61-6bcb5e53ab74", "node_type": "1", "metadata": {}, "hash": "e4a3757f802f5a3cfeb60b298c4e125e36195eb5a78525c265d1313037a0ca0b", "class_name": "RelatedNodeInfo"}}, "text": "import torch\nfrom torch import nn\nfrom d2l import torch asd2l\n11.8.1Model\nFig.11.8.1 depictsthemodelarchitectureofvisionTransformers. Thisarchitectureconsists\nof a stem that patchifies images, a body based on the multilayer Transformer encoder, and\na head that transforms the global representation into the output label.\ntFig. 11.8.1 The vision Transformer architecture. In this example, an image is split into nine patches.\nA special \u201c<cls>\u201d token and the nine \ufb02attened image patches are transformed via patch\nembedding and nTransformer encoder blocks into ten representations, respectively. The\n\u201c<cls>\u201d representation is further transformed into the output label.\nConsider an input image with height \u210e, width\ud835\udc64, and\ud835\udc50channels. Specifying the patch\nheight and width both as \ud835\udc5d, the image is split into a sequence of \ud835\udc5a=\u210e\ud835\udc64\u009d\ud835\udc5d2patches,\nwhere each patch is flattened to a vector of length \ud835\udc50\ud835\udc5d2. In this way, image patches can be\n453 Transformers for Vision\ntreated similarly to tokens in text sequences by Transformer encoders. A special \u201c<cls>\u201d\n(class) token and the \ud835\udc5aflattened image patches are linearly projected into a sequence of\n\ud835\udc5a\u00b81vectors, summed with learnable positional embeddings. The multilayer Transformer\nencoder transforms \ud835\udc5a\u00b81input vectors into the same number of output vector representa-\ntionsofthesamelength. ItworksexactlythesamewayastheoriginalTransformerencoder\ninFig. 11.7.1 , only differing in the position of normalization. Since the \u201c<cls>\u201d token at-\ntends to all the image patches via self-attention (see Fig. 11.6.1 ), its representation from\nthe Transformer encoder output will be further transformed into the output label.\n11.8.2PatchEmbedding\nTo implement a vision Transformer, let\u2019s start with patch embedding in Fig. 11.8.1 . Split-\nting an image into patches and linearly projecting these flattened patches can be simplified\nas a single convolution operation, where both the kernel size and the stride size are set to\nthe patch size.\nclass PatchEmbedding (nn.Module):\ndef __init__ (self , img_size =96, patch_size =16, num_hiddens =512):\nsuper ().__init__ ()\ndef _make_tuple (x):\nifnot isinstance (x, ( list ,tuple )):\nreturn (x, x)\nreturn x\nimg_size, patch_size =_make_tuple(img_size), _make_tuple(patch_size)\nself .num_patches =(img_size[ 0]//patch_size[ 0])*(\nimg_size[ 1]//patch_size[ 1])\nself .conv =nn.LazyConv2d(num_hiddens, kernel_size =patch_size,\nstride =patch_size)\ndef forward (self , X):\n# Output shape: (batch size, no. of patches, no. of channels)\nreturn self .conv(X) .flatten( 2).transpose( 1,2)\nIn the following example, taking images with height and width of img_size as inputs, the\npatchembeddingoutputs (img_size//patch_size)**2 patchesthatarelinearlyprojected\nto vectors of length num_hiddens .\nimg_size, patch_size, num_hiddens, batch_size =96,16,512,4\npatch_emb =PatchEmbedding(img_size, patch_size, num_hiddens)\nX=torch .zeros(batch_size, 3, img_size, img_size)\nd2l.check_shape(patch_emb(X),\n(batch_size, (img_size //patch_size) **2, num_hiddens))\n11.8.3VisionTransformerEncoder\nTheMLPofthevisionTransformerencoderisslightlydifferentfromthepositionwiseFFN\noftheoriginalTransformerencoder(see Section11.7.2 ). First,heretheactivationfunction\nusestheGaussianerrorlinearunit(GELU),whichcanbeconsideredasasmootherversion\nof the ReLU ( Hendrycks and Gimpel, 2016 ). Second, dropout is applied to the output of\neach fully connected layer in the MLP for regularization.", "mimetype": "text/plain", "start_char_idx": 1040379, "end_char_idx": 1043791, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c63a68a3-d998-4ee7-af61-6bcb5e53ab74": {"__data__": {"id_": "c63a68a3-d998-4ee7-af61-6bcb5e53ab74", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4a410f7e-fd45-47e7-a87b-5fc9bff48df6", "node_type": "1", "metadata": {}, "hash": "76b2938c019f22b1537d2aa04b032f47cb75ee4be9949eec18e9bd27222cb0c2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4f5f404e-c195-478d-95eb-07d3e13673e1", "node_type": "1", "metadata": {}, "hash": "51baa176e3977b377cf8e99f95110964a8f5ca8e79be86e61a27427182076572", "class_name": "RelatedNodeInfo"}}, "text": "img_size, patch_size, num_hiddens, batch_size =96,16,512,4\npatch_emb =PatchEmbedding(img_size, patch_size, num_hiddens)\nX=torch .zeros(batch_size, 3, img_size, img_size)\nd2l.check_shape(patch_emb(X),\n(batch_size, (img_size //patch_size) **2, num_hiddens))\n11.8.3VisionTransformerEncoder\nTheMLPofthevisionTransformerencoderisslightlydifferentfromthepositionwiseFFN\noftheoriginalTransformerencoder(see Section11.7.2 ). First,heretheactivationfunction\nusestheGaussianerrorlinearunit(GELU),whichcanbeconsideredasasmootherversion\nof the ReLU ( Hendrycks and Gimpel, 2016 ). Second, dropout is applied to the output of\neach fully connected layer in the MLP for regularization.\n454 Attention Mechanisms and Transformers\nclass ViTMLP (nn.Module):\ndef __init__ (self , mlp_num_hiddens, mlp_num_outputs, dropout =0.5):\nsuper ().__init__ ()\nself .dense1 =nn.LazyLinear(mlp_num_hiddens)\nself .gelu =nn.GELU()\nself .dropout1 =nn.Dropout(dropout)\nself .dense2 =nn.LazyLinear(mlp_num_outputs)\nself .dropout2 =nn.Dropout(dropout)\ndef forward (self , x):\nreturn self .dropout2( self .dense2( self .dropout1( self .gelu(\nself .dense1(x)))))\nThe vision Transformer encoder block implementation just follows the pre-normalization\ndesign in Fig. 11.8.1 , where normalization is applied right beforemulti-head attention or\nthe MLP. In contrast to post-normalization (\u201cadd & norm\u201d in Fig. 11.7.1 ), where normal-\nizationisplacedright afterresidualconnections, pre-normalizationleadstomoreeffective\nor efficient training for Transformers ( Baevski and Auli, 2018 ,Wangetal., 2019,Xionget\nal., 2020).\nclass ViTBlock (nn.Module):\ndef __init__ (self , num_hiddens, norm_shape, mlp_num_hiddens,\nnum_heads, dropout, use_bias =False ):\nsuper ().__init__ ()\nself .ln1 =nn.LayerNorm(norm_shape)\nself .attention =d2l.MultiHeadAttention(num_hiddens, num_heads,\ndropout, use_bias)\nself .ln2 =nn.LayerNorm(norm_shape)\nself .mlp =ViTMLP(mlp_num_hiddens, num_hiddens, dropout)\ndef forward (self , X, valid_lens =None ):\nX=X+self .attention( *([self .ln1(X)] *3), valid_lens)\nreturn X+self .mlp( self .ln2(X))\nJustasin Section11.7.4 ,novisionTransformerencoderblockchangesitsinputshape.\nX=torch .ones(( 2,100,24))\nencoder_blk =ViTBlock( 24,24,48,8,0.5)\nencoder_blk .eval()\nd2l.check_shape(encoder_blk(X), X .shape)\n11.8.4PuttingIt All Together\nThe forward pass of vision Transformers below is straightforward. First, input images are\nfedintoan PatchEmbedding instance,whoseoutputisconcatenatedwiththe\u201c<cls>\u201dtoken\nembedding. Theyaresummedwithlearnablepositionalembeddingsbeforedropout. Then\nthe output is fed into the Transformer encoder that stacks num_blks instances of the ViT-\nBlockclass. Finally, the representation of the \u201c<cls>\u201d token is projected by the network\nhead.\n455 Transformers for Vision\nclass ViT(d2l .Classifier):\n\"\"\"Vision Transformer.\"\"\"", "mimetype": "text/plain", "start_char_idx": 1043121, "end_char_idx": 1045938, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4f5f404e-c195-478d-95eb-07d3e13673e1": {"__data__": {"id_": "4f5f404e-c195-478d-95eb-07d3e13673e1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c63a68a3-d998-4ee7-af61-6bcb5e53ab74", "node_type": "1", "metadata": {}, "hash": "e4a3757f802f5a3cfeb60b298c4e125e36195eb5a78525c265d1313037a0ca0b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "95d231b3-b165-48d9-b311-4e17bbff18e5", "node_type": "1", "metadata": {}, "hash": "f8c2934f03c3a4d884c4ab5ef376eb127397da0d2bc33f2876d91ca7608d3691", "class_name": "RelatedNodeInfo"}}, "text": "X=torch .ones(( 2,100,24))\nencoder_blk =ViTBlock( 24,24,48,8,0.5)\nencoder_blk .eval()\nd2l.check_shape(encoder_blk(X), X .shape)\n11.8.4PuttingIt All Together\nThe forward pass of vision Transformers below is straightforward. First, input images are\nfedintoan PatchEmbedding instance,whoseoutputisconcatenatedwiththe\u201c<cls>\u201dtoken\nembedding. Theyaresummedwithlearnablepositionalembeddingsbeforedropout. Then\nthe output is fed into the Transformer encoder that stacks num_blks instances of the ViT-\nBlockclass. Finally, the representation of the \u201c<cls>\u201d token is projected by the network\nhead.\n455 Transformers for Vision\nclass ViT(d2l .Classifier):\n\"\"\"Vision Transformer.\"\"\"\ndef __init__ (self , img_size, patch_size, num_hiddens, mlp_num_hiddens,\nnum_heads, num_blks, emb_dropout, blk_dropout, lr =0.1,\nuse_bias =False , num_classes =10):\nsuper ().__init__ ()\nself .save_hyperparameters()\nself .patch_embedding =PatchEmbedding(\nimg_size, patch_size, num_hiddens)\nself .cls_token =nn.Parameter(torch .zeros( 1,1, num_hiddens))\nnum_steps =self .patch_embedding .num_patches +1# Add the cls token\n# Positional embeddings are learnable\nself .pos_embedding =nn.Parameter(\ntorch .randn( 1, num_steps, num_hiddens))\nself .dropout =nn.Dropout(emb_dropout)\nself .blks =nn.Sequential()\nfor iinrange (num_blks):\nself .blks .add_module( f\"{i}\", ViTBlock(\nnum_hiddens, num_hiddens, mlp_num_hiddens,\nnum_heads, blk_dropout, use_bias))\nself .head =nn.Sequential(nn .LayerNorm(num_hiddens),\nnn.Linear(num_hiddens, num_classes))\ndef forward (self , X):\nX=self .patch_embedding(X)\nX=torch .cat(( self .cls_token .expand(X .shape[ 0],-1,-1), X), 1)\nX=self .dropout(X +self .pos_embedding)\nfor blk inself .blks:\nX=blk(X)\nreturn self .head(X[:, 0])\n11.8.5Training\nTraining a vision Transformer on the Fashion-MNIST dataset is just like how CNNs were\ntrained in Chapter 8 .\nimg_size, patch_size =96,16\nnum_hiddens, mlp_num_hiddens, num_heads, num_blks =512,2048 ,8,2\nemb_dropout, blk_dropout, lr =0.1,0.1,0.1\nmodel =ViT(img_size, patch_size, num_hiddens, mlp_num_hiddens, num_heads,\nnum_blks, emb_dropout, blk_dropout, lr)\ntrainer =d2l.Trainer(max_epochs =10, num_gpus =1)\ndata =d2l.FashionMNIST(batch_size =128, resize =(img_size, img_size))\ntrainer .fit(model, data)\n11.8.6Summary and Discussion\nYoumayhavenoticed thatforsmall datasetslikeFashion-MNIST,ourimplementedvision\nTransformer does not outperform the ResNet in Section 8.6 . Similar observations can be\nmadeevenontheImageNetdataset(1.2millionimages). ThisisbecauseTransformers lack\nthose useful principles in convolution, such as translation invariance and locality ( Section\n7.1). However, the picture changes when training larger models on larger datasets (e.g.,\n456 Attention Mechanisms and Transformers\n163300 million images), where vision Transformers outperform ResNets by a large margin\nin image classification, demonstrating intrinsic superiority of Transformers in scalability\n(Dosovitskiy et al., 2021). The introduction of vision Transformers has changed the land-\nscapeofnetworkdesignformodelingimagedata. Theyweresoonshowntobeeffectiveon\nthe ImageNet dataset with data-efficient training strategies of DeiT ( Touvronet al., 2021).\nHowever, the quadratic complexity of self-attention ( Section 11.6 ) makes the Transformer\narchitecture less suitable for higher-resolution images. Towards a general-purpose back-\nbone network in computer vision, Swin Transformers addressed the quadratic computa-\ntional complexity with respect to image size ( Section 11.6.2 ) and reinstated convolution-\nlike priors, extending the applicability of Transformers to a range of computer vision tasks\nbeyond image classification with state-of-the-art results ( Liuetal., 2021).", "mimetype": "text/plain", "start_char_idx": 1045269, "end_char_idx": 1048973, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "95d231b3-b165-48d9-b311-4e17bbff18e5": {"__data__": {"id_": "95d231b3-b165-48d9-b311-4e17bbff18e5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4f5f404e-c195-478d-95eb-07d3e13673e1", "node_type": "1", "metadata": {}, "hash": "51baa176e3977b377cf8e99f95110964a8f5ca8e79be86e61a27427182076572", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4fcb5bd0-6daa-4a71-8845-4b4fea16070c", "node_type": "1", "metadata": {}, "hash": "78586efba8a79ed0e245ddbd75afcde024a2413a9a25fa9369f4725d3a532d24", "class_name": "RelatedNodeInfo"}}, "text": "The introduction of vision Transformers has changed the land-\nscapeofnetworkdesignformodelingimagedata. Theyweresoonshowntobeeffectiveon\nthe ImageNet dataset with data-efficient training strategies of DeiT ( Touvronet al., 2021).\nHowever, the quadratic complexity of self-attention ( Section 11.6 ) makes the Transformer\narchitecture less suitable for higher-resolution images. Towards a general-purpose back-\nbone network in computer vision, Swin Transformers addressed the quadratic computa-\ntional complexity with respect to image size ( Section 11.6.2 ) and reinstated convolution-\nlike priors, extending the applicability of Transformers to a range of computer vision tasks\nbeyond image classification with state-of-the-art results ( Liuetal., 2021).\n11.8.7Exercises\n1.How does the value of img_size affect training time?\n2.Instead of projecting the \u201c<cls>\u201d token representation to the output, how would you\nprojecttheaveragedpatchrepresentations? Implementthischangeandseehowitaffects\nthe accuracy.\n3.Can you modify hyperparameters to improve the accuracy of the vision Transformer?\nDiscussions163.\n11.9Large-ScalePretrainingwith Transformers\nSo far in our image classification and machine translation experiments, models have been\ntrained on datasets with input\u2013output examples fromscratch to perform specific tasks. For\nexample, a Transformer was trained with English\u2013French pairs ( Section 11.7 ) so that this\nmodel can translate input English text into French. As a result, each model becomes a\nspecific expert that is sensitive to even a slight shift in data distribution ( Section 4.7 ). For\nbetter generalized models, or even more competent generalists that can perform multiple\ntasks with or without adaptation, pretraining models on large data has been increasingly\ncommon.\n457 Large-Scale Pretraining with Transformers\nGiven larger data for pretraining, the Transformer architecture performs better with an in-\ncreasedmodelsizeandtrainingcompute,demonstratingsuperior scalingbehavior. Specif-\nically, performance of Transformer-based language models scales as a power law with the\namount of model parameters, training tokens, and training compute ( Kaplanet al., 2020).\nThe scalability of Transformers is also evidenced by the significantly boosted performance\nfrom larger vision Transformers trained on larger data (discussed in Section 11.8 ). More\nrecent success stories include Gato, a generalist model that can play Atari, caption im-\nages, chat, and act as a robot ( Reedet al., 2022). Gato is a single Transformer that scales\nwell when pretrained on diverse modalities, including text, images, joint torques, and but-\nton presses. Notably, all such multimodal data is serialized into a flat sequence of tokens,\nwhich can be processed akin to text tokens ( Section 11.7 ) or image patches ( Section 11.8 )\nby Transformers.\nPrior to the compelling success of pretraining Transformers for multimodal data, Trans-\nformerswereextensivelypretrainedwithawealthoftext. Originallyproposedformachine\ntranslation,theTransformerarchitecturein Fig.11.7.1 consistsofanencoderforrepresent-\ninginputsequencesandadecoderforgeneratingtargetsequences. Primarily,Transformers\ncan be used in three different modes: encoder-only ,encoder\u2013decoder , anddecoder-only .\nTo conclude this chapter, we will review these three modes and explain the scalability in\npretraining Transformers.\n11.9.1Encoder-Only\nWhenonlytheTransformerencoderisused,asequenceofinputtokensisconvertedintothe\nsame number of representations that can be further projected into output (e.g., classifica-\ntion). ATransformerencoderconsistsofself-attentionlayers,whereallinputtokensattend\nto each other. For example, vision Transformers depicted in Fig. 11.8.1 are encoder-only,\nconverting a sequence of input image patches into the representation of a special \u201c<cls>\u201d\ntoken. Since this representation depends on all input tokens, it is further projected into\nclassification labels. This design was inspired by an earlier encoder-only Transformer pre-\ntrainedontext: BERT(BidirectionalEncoderRepresentationsfromTransformers)( Devlin\netal., 2018).\nPretrainingBERT\nBERT is pretrained on text sequences using masked language modeling : input text with\nrandomly masked tokens is fed into a Transformer encoder to predict the masked tokens.\nAs illustrated in Fig. 11.9.1 , an original text sequence \u201cI\u201d, \u201clove\u201d, \u201cthis\u201d, \u201cred\u201d, \u201ccar\u201d is\nprepended with the \u201c<cls>\u201d token, and the \u201c<mask>\u201d token randomly replaces \u201clove\u201d;\nthen the cross-entropy loss between the masked token \u201clove\u201d and its prediction is to be\nminimized during pretraining.", "mimetype": "text/plain", "start_char_idx": 1048218, "end_char_idx": 1052814, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4fcb5bd0-6daa-4a71-8845-4b4fea16070c": {"__data__": {"id_": "4fcb5bd0-6daa-4a71-8845-4b4fea16070c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "95d231b3-b165-48d9-b311-4e17bbff18e5", "node_type": "1", "metadata": {}, "hash": "f8c2934f03c3a4d884c4ab5ef376eb127397da0d2bc33f2876d91ca7608d3691", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1df95d59-b2ee-4a6b-9444-44c468f6b198", "node_type": "1", "metadata": {}, "hash": "c975aad82525761b1be0211ca14c721f98a661143fee57193bb80babd985e6b6", "class_name": "RelatedNodeInfo"}}, "text": "Since this representation depends on all input tokens, it is further projected into\nclassification labels. This design was inspired by an earlier encoder-only Transformer pre-\ntrainedontext: BERT(BidirectionalEncoderRepresentationsfromTransformers)( Devlin\netal., 2018).\nPretrainingBERT\nBERT is pretrained on text sequences using masked language modeling : input text with\nrandomly masked tokens is fed into a Transformer encoder to predict the masked tokens.\nAs illustrated in Fig. 11.9.1 , an original text sequence \u201cI\u201d, \u201clove\u201d, \u201cthis\u201d, \u201cred\u201d, \u201ccar\u201d is\nprepended with the \u201c<cls>\u201d token, and the \u201c<mask>\u201d token randomly replaces \u201clove\u201d;\nthen the cross-entropy loss between the masked token \u201clove\u201d and its prediction is to be\nminimized during pretraining. Note that there is no constraint in the attention pattern of\nTransformer encoders (right of Fig. 11.9.1 ) so all tokens can attend to each other. Thus,\nprediction of \u201clove\u201d depends on input tokens before and after it in the sequence. This is\nwhyBERTis a \u201cbidirectional encoder\u201d. Withoutneed formanual labeling, large-scaletext\ndata from books and Wikipedia can be used for pretraining BERT.\n458 Attention Mechanisms and Transformers\ntFig. 11.9.1 Left: Pretraining BERT with masked language modeling. Prediction of the masked \u201clove\u201d\ntoken depends on all input tokens before and after \u201clove\u201d. Right: Attention pattern in the\nTransformer encoder. Each token along the vertical axis attends to all input tokens along\nthe horizontal axis.\nFine-TuningBERT\nThepretrainedBERTcanbe fine-tuned todownstreamencodingtasksinvolvingsingletext\nor text pairs. During fine-tuning, additional layers can be added to BERT with randomized\nparameters: these parameters and those pretrained BERT parameters will be updated to fit\ntraining data of downstream tasks.\ntFig. 11.9.2 Fine-tuning BERT for sentiment analysis.\nFig.11.9.2 illustratesfine-tuningofBERTforsentimentanalysis. TheTransformerencoder\nis a pretrained BERT, which takes a text sequence as input and feeds the \u201c<cls>\u201d represen-\ntation(globalrepresentationoftheinput)intoanadditionalfullyconnectedlayertopredict\nthe sentiment. During fine-tuning, the cross-entropy loss between the prediction and the\nlabel on sentiment analysis data is minimized via gradient-based algorithms, where the\nadditional layer is trained from scratch while pretrained parameters of BERT are updated.\nBERT does more than sentiment analysis. The general language representations learned\nby the 350-million-parameter BERT from 250 billion training tokens advanced the state of\ntheartfornaturallanguagetaskssuchassingletextclassification, textpairclassificationor\nregression, text tagging, and question answering.\nYoumaynotethatthesedownstreamtasksincludetextpairunderstanding. BERTpretrain-\ning has another loss for predicting whether one sentence immediately follows the other.\nHowever, this loss was later found to be less useful when pretraining RoBERTa, a BERT\nvariant of the same size, on 2000 billion tokens ( Liuet al., 2019). Other derivatives of\n459 Large-Scale Pretraining with Transformers\nBERT improved model architectures or pretraining objectives, such as ALBERT (enforc-\ningparametersharing)( Lanetal.,2019),SpanBERT(representingandpredictingspansof\ntext) (Joshiet al., 2020), DistilBERT (lightweight via knowledge distillation) ( Sanhet al.,\n2019),andELECTRA(replacedtokendetection)( Clarketal.,2020). Moreover,BERTin-\nspiredTransformerpretrainingincomputervision,suchaswithvisionTransformers( Doso-\nvitskiyetal.,2021),SwinTransformers( Liuetal.,2021),andMAE(maskedautoencoders)\n(Heetal., 2022).\n11.9.2Encoder\u2013Decoder\nSince a Transformer encoder converts a sequence of input tokens into the same number\nof output representations, the encoder-only mode cannot generate a sequence of arbitrary\nlengthasinmachinetranslation. Asoriginallyproposedformachinetranslation,theTrans-\nformer architecture can be outfitted with a decoder that autoregressively predicts the tar-\nget sequence of arbitrary length, token by token, conditional on both encoder output and\ndecoder output: (i) for conditioning on encoder output, encoder\u2013decoder cross-attention\n(multi-head attention of decoder in Fig.", "mimetype": "text/plain", "start_char_idx": 1052059, "end_char_idx": 1056231, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1df95d59-b2ee-4a6b-9444-44c468f6b198": {"__data__": {"id_": "1df95d59-b2ee-4a6b-9444-44c468f6b198", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4fcb5bd0-6daa-4a71-8845-4b4fea16070c", "node_type": "1", "metadata": {}, "hash": "78586efba8a79ed0e245ddbd75afcde024a2413a9a25fa9369f4725d3a532d24", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7d6393e3-faa8-40de-8bce-bd7fb99a8342", "node_type": "1", "metadata": {}, "hash": "cc0bd30090204fccbb40f9415ba46c27b3a75b41eb14dc3506de3426a8836653", "class_name": "RelatedNodeInfo"}}, "text": "Moreover,BERTin-\nspiredTransformerpretrainingincomputervision,suchaswithvisionTransformers( Doso-\nvitskiyetal.,2021),SwinTransformers( Liuetal.,2021),andMAE(maskedautoencoders)\n(Heetal., 2022).\n11.9.2Encoder\u2013Decoder\nSince a Transformer encoder converts a sequence of input tokens into the same number\nof output representations, the encoder-only mode cannot generate a sequence of arbitrary\nlengthasinmachinetranslation. Asoriginallyproposedformachinetranslation,theTrans-\nformer architecture can be outfitted with a decoder that autoregressively predicts the tar-\nget sequence of arbitrary length, token by token, conditional on both encoder output and\ndecoder output: (i) for conditioning on encoder output, encoder\u2013decoder cross-attention\n(multi-head attention of decoder in Fig. 11.7.1 ) allows target tokens to attend to allinput\ntokens; (ii) conditioning on decoder output is achieved by a so-called causalattention (this\nname is common in the literature but is misleading as it has little connection to the proper\nstudy of causality) pattern (masked multi-head attention of decoder in Fig. 11.7.1 ), where\nany target token can only attend to pastandpresenttokens in the target sequence.\nTopretrainencoder\u2013decoderTransformersbeyondhuman-labeledmachinetranslationdata,\nBART (Lewiset al., 2019) and T5 ( Raffelet al., 2020) are two concurrently proposed\nencoder\u2013decoder Transformers pretrained on large-scale text corpora. Both attempt to re-\nconstruct original text in their pretraining objectives, while the former emphasizes noising\ninput(e.g.,masking,deletion,permutation,androtation)andthelatterhighlightsmultitask\nunification with comprehensive ablation studies.\nPretrainingT5\nAs an example of the pretrained Transformer encoder\u2013decoder, T5 (Text-to-Text Transfer\nTransformer) unifies many tasks as the same text-to-text problem: for any task, the input\nof the encoder is a task description (e.g., \u201cSummarize\u201d, \u201c:\u201d) followed by task input (e.g.,\na sequence of tokens from an article), and the decoder predicts the task output (e.g., a\nsequenceoftokenssummarizingtheinputarticle). Toperformastext-to-text, T5istrained\nto generate some target text conditional on input text.\nTo obtain input and output from any original text, T5 is pretrained to predict consecu-\ntive spans. Specifically, tokens from text are randomly replaced by special tokens where\neach consecutive span is replaced by the same special token. Consider the example in Fig.\n11.9.3, where the original text is \u201cI\u201d, \u201clove\u201d, \u201cthis\u201d, \u201cred\u201d, \u201ccar\u201d. Tokens \u201clove\u201d, \u201cred\u201d,\n\u201ccar\u201d are randomly replaced by special tokens. Since \u201cred\u201d and \u201ccar\u201d are a consecutive\nspan, they are replaced by the same special token. As a result, the input sequence is \u201cI\u201d,\n\u201c<X>\u201d, \u201cthis\u201d, \u201c<Y>\u201d, and the target sequence is \u201c<X>\u201d, \u201clove\u201d, \u201c<Y>\u201d, \u201cred\u201d, \u201ccar\u201d,\n\u201c<Z>\u201d, where \u201c<Z>\u201d is another special token marking the end. As shown in Fig. 11.9.3 ,\n460 Attention Mechanisms and Transformers\ntFig. 11.9.3 Left: Pretraining T5 by predicting consecutive spans. The original sentence is \u201cI\u201d, \u201clove\u201d,\n\u201cthis\u201d, \u201cred\u201d, \u201ccar\u201d, where \u201clove\u201d is replaced by a special \u201c<X>\u201d token, and consecutive\n\u201cred\u201d, \u201ccar\u201d are replaced by a special \u201c<Y>\u201d token. The target sequence ends with a\nspecial \u201c<Z>\u201d token. Right: Attention pattern in the Transformer encoder\u2013decoder. In the\nencoder self-attention (lower square), all input tokens attend to each other; In the\nencoder\u2013decoder cross-attention (upper rectangle), each target token attends to all input\ntokens; In the decoder self-attention (upper triangle), each target token attends to present\nand past target tokens only (causal).\nthe decoder has a causal attention pattern to prevent itself from attending to future tokens\nduring sequence prediction.\nIn T5, predicting consecutive span is also referred to as reconstructing corrupted text.\nWith this objective, T5 is pretrained with 1000 billion tokens from the C4 (Colossal Clean\nCrawled Corpus) data, which consists of clean English text from the web ( Raffelet al.,\n2020).", "mimetype": "text/plain", "start_char_idx": 1055450, "end_char_idx": 1059451, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7d6393e3-faa8-40de-8bce-bd7fb99a8342": {"__data__": {"id_": "7d6393e3-faa8-40de-8bce-bd7fb99a8342", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1df95d59-b2ee-4a6b-9444-44c468f6b198", "node_type": "1", "metadata": {}, "hash": "c975aad82525761b1be0211ca14c721f98a661143fee57193bb80babd985e6b6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7d14db31-94bb-4152-bdb3-616e816587fa", "node_type": "1", "metadata": {}, "hash": "d6eec0f2b374851ba8dae432324c410e311c51880806259f6ec4fd6c3b392b15", "class_name": "RelatedNodeInfo"}}, "text": "The target sequence ends with a\nspecial \u201c<Z>\u201d token. Right: Attention pattern in the Transformer encoder\u2013decoder. In the\nencoder self-attention (lower square), all input tokens attend to each other; In the\nencoder\u2013decoder cross-attention (upper rectangle), each target token attends to all input\ntokens; In the decoder self-attention (upper triangle), each target token attends to present\nand past target tokens only (causal).\nthe decoder has a causal attention pattern to prevent itself from attending to future tokens\nduring sequence prediction.\nIn T5, predicting consecutive span is also referred to as reconstructing corrupted text.\nWith this objective, T5 is pretrained with 1000 billion tokens from the C4 (Colossal Clean\nCrawled Corpus) data, which consists of clean English text from the web ( Raffelet al.,\n2020).\nFine-TuningT5\nSimilartoBERT,T5needstobefine-tuned(updatingT5parameters)ontask-specifictrain-\ning data to perform this task. Major differences from BERT fine-tuning include: (i) T5\ninput includes task descriptions; (ii) T5 can generate sequences with arbitrary length with\nits Transformer decoder; (iii) No additional layers are required.\nFig. 11.9.4 explains fine-tuning T5 using text summarization as an example. In this down-\nstream task, the task description tokens \u201cSummarize\u201d, \u201c:\u201d followed by the article tokens\nare input to the encoder.\nAfterfine-tuning,the11-billion-parameterT5(T5-11B)achievedstate-of-the-artresultson\nmultiple encoding (e.g., classification) and generation (e.g., summarization) benchmarks.\nSince released, T5 has been extensively used in later research. For example, switch Trans-\nformersaredesignedbasedonT5toactivateasubsetoftheparametersforbettercomputa-\ntional efficiency ( Fedusetal., 2022). In a text-to-image model called Imagen, text is input\nto a frozen T5 encoder (T5-XXL) with 4.6 billion parameters ( Sahariaet al., 2022). The\n461 Large-Scale Pretraining with Transformers\ntFig. 11.9.4 Fine-tuning T5 for text summarization. Both the task description and article tokens are\nfed into the Transformer encoder for predicting the summary.\nphotorealistic text-to-image examples in Fig. 11.9.5 suggest that the T5 encoder alone may\neffectively represent text even without fine-tuning.\ntFig. 11.9.5 Text-to-image examples by the Imagen model, whose text encoder is from T5 (\ufb01gures\ntaken from Saharia et al. ( 2022 )).\n11.9.3Decoder-Only\nWehavereviewedencoder-onlyandencoder\u2013decoderTransformers. Alternatively,decoder-\nonly Transformers remove the entire encoder and the decoder sublayer with the encoder\u2013\ndecoder cross-attention from the original encoder\u2013decoder architecture depicted in Fig.\n11.7.1. Nowadays, decoder-only Transformers have been the defacto architecture in large-\nscalelanguagemodeling( Section9.3 ),whichleveragestheworld\u2019sabundantunlabeledtext\ncorpora via self-supervised learning.\nGPT and GPT-2\nUsinglanguagemodelingasthetrainingobjective,theGPT(generativepre-training)model\nchooses a Transformer decoder as its backbone ( Radfordetal., 2018).\nFollowing the autoregressive language model training as described in Section 9.3.3 ,Fig.\n11.9.6illustratesGPTpretrainingwithaTransformerencoder,wherethetargetsequenceis\nthe input sequence shifted by one token. Note that the attention pattern in the Transformer\n462 Attention Mechanisms and Transformers\ntFig. 11.9.6 Left: Pretraining GPT with language modeling. The target sequence is the input sequence\nshifted by one token. Both \u201c<bos>\u201d and \u201c<eos>\u201d are special tokens marking the\nbeginning and end of sequences, respectively. Right: Attention pattern in the Transformer\ndecoder. Each token along the vertical axis attends to only its past tokens along the\nhorizontal axis (causal).\ndecoder enforces that each token can only attend to its past tokens (future tokens cannot be\nattended to because they have not yet been chosen).\nGPT has 100 million parameters and needs to be fine-tuned for individual downstream\ntasks. A much larger Transformer-decoder language model, GPT-2, was introduced one\nyear later ( Radfordetal., 2019).", "mimetype": "text/plain", "start_char_idx": 1058629, "end_char_idx": 1062678, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7d14db31-94bb-4152-bdb3-616e816587fa": {"__data__": {"id_": "7d14db31-94bb-4152-bdb3-616e816587fa", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7d6393e3-faa8-40de-8bce-bd7fb99a8342", "node_type": "1", "metadata": {}, "hash": "cc0bd30090204fccbb40f9415ba46c27b3a75b41eb14dc3506de3426a8836653", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "11accb39-cd89-4687-8fb4-ea5bb91de766", "node_type": "1", "metadata": {}, "hash": "61ceeafa4b3917fe495e2599016f503fbecaa9037bc6bb555e6b2e11332340c3", "class_name": "RelatedNodeInfo"}}, "text": "Note that the attention pattern in the Transformer\n462 Attention Mechanisms and Transformers\ntFig. 11.9.6 Left: Pretraining GPT with language modeling. The target sequence is the input sequence\nshifted by one token. Both \u201c<bos>\u201d and \u201c<eos>\u201d are special tokens marking the\nbeginning and end of sequences, respectively. Right: Attention pattern in the Transformer\ndecoder. Each token along the vertical axis attends to only its past tokens along the\nhorizontal axis (causal).\ndecoder enforces that each token can only attend to its past tokens (future tokens cannot be\nattended to because they have not yet been chosen).\nGPT has 100 million parameters and needs to be fine-tuned for individual downstream\ntasks. A much larger Transformer-decoder language model, GPT-2, was introduced one\nyear later ( Radfordetal., 2019). Compared with the original Transformer decoder in GPT,\npre-normalization (discussed in Section 11.8.3 ) and improved initialization and weight-\nscalingwereadoptedinGPT-2. Pretrainedon40GBoftext,the1.5-billion-parameterGPT-\n2 obtained the state-of-the-art results on language modeling benchmarks and promising\nresults on multiple other tasks withoutupdating theparametersor architecture .\nGPT-3and Beyond\nGPT-2demonstratedpotentialofusingthesamelanguagemodelformultipletaskswithout\nupdatingthemodel. Thisismorecomputationallyefficientthanfine-tuning,whichrequires\nmodel updates via gradient computation.\nBefore explaining the more computationally efficient use of language models without pa-\nrameter update, recall Section 9.5 that a language model can be trained to generate a text\nsequenceconditionalonsomeprefixtextsequence. Thus,apretrainedlanguagemodelmay\ngenerate the task output as a sequence without parameter update , conditional on an input\nsequencewiththetaskdescription,task-specificinput\u2013outputexamples,andaprompt(task\ninput). This learning paradigm is called in-context learning (Brownet al., 2020), which\ncan be further categorized into zero-shot ,one-shot , andfew-shot , when there is no, one,\nand a few task-specific input\u2013output examples ( Fig. 11.9.7 ).\nThese three settings were tested in GPT-3 ( Brownetal., 2020), whose largest version uses\ndata and model size about two orders of magnitude larger than those in GPT-2. GPT-3\nusesthesameTransformerdecoderarchitectureasitsdirectpredecessorGPT-2exceptthat\nattention patterns (at the right in Fig. 11.9.6 ) are sparser at alternating layers. Pretrained\n463 Large-Scale Pretraining with Transformers\ntFig. 11.9.7 Zero-shot, one-shot, few-shot in-context learning with language models (Transformer\ndecoders). No parameter update is needed.\ntFig. 11.9.8 Aggregate performance of GPT-3 for all 42 accuracy-denominated benchmarks (caption\nadapted and \ufb01gure taken from Brown et al. ( 2020 )).\nwith 300 billion tokens, GPT-3 performs better with larger model size, where few-shot\nperformance increases most rapidly ( Fig. 11.9.8 ).\nThe subsequent GPT-4 model did not fully disclose technical details in its report ( OpenAI,\n2023). By contrast with its predecessors, GPT-4 is a large-scale, multimodal model that\ncan take both text and images as input and generate text output.\n11.9.4Scalability\nFig. 11.9.8 empirically demonstrates scalability of Transformers in the GPT-3 language\nmodel. For language modeling, more comprehensive empirical studies on the scalability\n464 Attention Mechanisms and Transformers\nof Transformers have led researchers to see promise in training larger Transformers with\nmore data and compute ( Kaplanetal., 2020).\ntFig. 11.9.9 Transformer language model performance improves smoothly as we increase the model\nsize, dataset size, and amount of compute used for training. For optimal performance all\nthree factors must be scaled up in tandem. Empirical performance has a power-law\nrelationship with each individual factor when not bottlenecked by the other two (caption\nadapted and \ufb01gure taken from Kaplan et al. ( 2020 )).\nAs shown in Fig. 11.9.9 ,power-law scaling can be observed in the performance with re-\nspect to the model size (number of parameters, excluding embedding layers), dataset size\n(numberoftrainingtokens), andamountoftrainingcompute(PetaFLOP/s-days, excluding\nembedding layers). In general, increasing all these three factors in tandem leads to better\nperformance.", "mimetype": "text/plain", "start_char_idx": 1061859, "end_char_idx": 1066152, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "11accb39-cd89-4687-8fb4-ea5bb91de766": {"__data__": {"id_": "11accb39-cd89-4687-8fb4-ea5bb91de766", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7d14db31-94bb-4152-bdb3-616e816587fa", "node_type": "1", "metadata": {}, "hash": "d6eec0f2b374851ba8dae432324c410e311c51880806259f6ec4fd6c3b392b15", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "905b7137-aaa7-4c69-8f04-376caa0ba25f", "node_type": "1", "metadata": {}, "hash": "ce0463d796a61ad02eda4428d659320d34f18871026d428ed3db942e7199e4d1", "class_name": "RelatedNodeInfo"}}, "text": "tFig. 11.9.9 Transformer language model performance improves smoothly as we increase the model\nsize, dataset size, and amount of compute used for training. For optimal performance all\nthree factors must be scaled up in tandem. Empirical performance has a power-law\nrelationship with each individual factor when not bottlenecked by the other two (caption\nadapted and \ufb01gure taken from Kaplan et al. ( 2020 )).\nAs shown in Fig. 11.9.9 ,power-law scaling can be observed in the performance with re-\nspect to the model size (number of parameters, excluding embedding layers), dataset size\n(numberoftrainingtokens), andamountoftrainingcompute(PetaFLOP/s-days, excluding\nembedding layers). In general, increasing all these three factors in tandem leads to better\nperformance. However, howto increase them in tandem still remains a matter of debate\n(Hoffmann etal., 2022).\ntFig. 11.9.10 Transformer language model training runs (\ufb01gure taken from Kaplan et al. ( 2020 )).\nAs well as increased performance, large models also enjoy better sample efficiency than\nsmall models. Fig. 11.9.10 shows that large models need fewer training samples (tokens\nprocessed) to perform at the same level achieved by small models, and performance is\nscaled smoothly with compute.\nThe empirical scaling behaviors in Kaplan et al.(2020) have been tested in subsequent\nlarge Transformer models. For example, GPT-3 supported this hypothesis with two more\norders of magnitude in Fig. 11.9.11 .\n465 Large-Scale Pretraining with Transformers\ntFig. 11.9.11 GPT-3 performance (cross-entropy validation loss) follows a power-law trend with the\namount of compute used for training. The power-law behavior observed in Kaplan et al.\n(2020 ) continues for an additional two orders of magnitude with only small deviations\nfrom the predicted curve. Embedding parameters are excluded from compute and\nparameter counts (caption adapted and \ufb01gure taken from Brown et al. ( 2020 )).\n11.9.5LargeLanguageModels\nThe scalability of Transformers in the GPT series has inspired subsequent large language\nmodels. The GPT-2 Transformer decoder was used for training the 530-billion-parameter\nMegatron-Turing NLG ( Smithet al., 2022) with 270 billion training tokens. Following\ntheGPT-2design, the280-billion-parameterGopher( Raeetal., 2021)pretrainedwith300\nbillion tokens, performed competitively across diverse tasks. Inheriting the same architec-\nture and using the same compute budget of Gopher, Chinchilla ( Hoffmann et al., 2022)\nis a substantially smaller (70 billion parameters) model that trains for much longer (1.4\ntrillion training tokens), outperforming Gopher on many tasks and with more emphasis on\nthe number of tokens than on the number of parameters. To continue the scaling line of\nlanguage modeling, PaLM (Pathway Language Model) ( Chowdhery et al., 2022), a 540-\nbillion-parameter Transformer decoder with modified designs pretrained on 780 billion to-\nkens,outperformedaveragehumanperformanceontheBIG-Benchbenchmark( Srivastava\netal.,2022). Itslaterversion,PaLM2( Aniletal.,2023),scaleddataandmodelroughly1:1\nand improved multilingual and reasoning capabilities. Other large language models, such\nas Minerva ( Lewkowycz et al., 2022) that further trains a generalist (PaLM) and Galac-\ntica (Tayloret al., 2022) that is not trained on a general corpus, have shown promising\nquantitative and scientific reasoning capabilities.\nOpen-sourced releases, such as OPT (Open Pretrained Transformers) ( Zhangetal., 2022),\nBLOOM ( Scaoet al., 2022), and FALCON ( Penedoet al., 2023), democratized research\nand use of large language models. Focusing on computational efficiency at inference time,\nthe open-sourced Llama 1 ( Touvronet al., 2023a) outperformed much larger models by\ntraining on more tokens than had been typically used. The updated Llama 2 ( Touvronet\nal.,2023b)furtherincreasedthepretrainingcorpusby40%,leadingtoproductmodelsthat\nmay match the performance of competitive close-sourced models.\n466 Attention Mechanisms and Transformers\n164Weietal.(2022) discussed emergent abilities of large language models that are present in\nlarger models, but not in smaller models.", "mimetype": "text/plain", "start_char_idx": 1065384, "end_char_idx": 1069523, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "905b7137-aaa7-4c69-8f04-376caa0ba25f": {"__data__": {"id_": "905b7137-aaa7-4c69-8f04-376caa0ba25f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "11accb39-cd89-4687-8fb4-ea5bb91de766", "node_type": "1", "metadata": {}, "hash": "61ceeafa4b3917fe495e2599016f503fbecaa9037bc6bb555e6b2e11332340c3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "096fba12-75c4-4820-ad30-f526f27a4b9b", "node_type": "1", "metadata": {}, "hash": "a55716595595a0798f6183ad13893bfe1979e26afe6d8bf5eb549884e598a70d", "class_name": "RelatedNodeInfo"}}, "text": "Open-sourced releases, such as OPT (Open Pretrained Transformers) ( Zhangetal., 2022),\nBLOOM ( Scaoet al., 2022), and FALCON ( Penedoet al., 2023), democratized research\nand use of large language models. Focusing on computational efficiency at inference time,\nthe open-sourced Llama 1 ( Touvronet al., 2023a) outperformed much larger models by\ntraining on more tokens than had been typically used. The updated Llama 2 ( Touvronet\nal.,2023b)furtherincreasedthepretrainingcorpusby40%,leadingtoproductmodelsthat\nmay match the performance of competitive close-sourced models.\n466 Attention Mechanisms and Transformers\n164Weietal.(2022) discussed emergent abilities of large language models that are present in\nlarger models, but not in smaller models. However, simply increasing model size does not\ninherently make models follow human instructions better. Sanh et al.(2021), Weiet al.\n(2021) have found that fine-tuning large language models on a range of datasets described\nviainstructions canimprovezero-shotperformanceonheld-outtasks. Using reinforcement\nlearningfromhumanfeedback , Ouyang etal.(2022) fine-tuned GPT-3 to follow a diverse\nsetofinstructions. FollowingtheresultantInstructGPTwhichalignslanguagemodelswith\nhuman intent via fine-tuning ( Ouyanget al., 2022),ChatGPT164can generate human-like\nresponses (e.g., code debugging and creative writing) based on conversations with humans\nandcanperformmanynaturallanguageprocessingtaskszero-shot( Qinetal.,2023). Baiet\nal.(2022)replacedhumaninputs(e.g.,human-labeleddata)withmodeloutputstopartially\nautomate the instruction tuning process, which is also known as reinforcement learning\nfromAI feedback .\nLargelanguagemodelsofferanexcitingprospectofformulatingtextinputtoinducemodels\nto perform desired tasks via in-context learning, which is also known as prompting . No-\ntably,chain-of-thought prompting (Weiet al., 2022), an in-context learning method with\nfew-shot \u201cquestion, intermediate reasoning steps, answer\u201d demonstrations, elicits the com-\nplex reasoning capabilities of large language models in order to solve mathematical, com-\nmonsense, and symbolic reasoning tasks. Sampling multiple reasoning paths ( Wangetal.,\n2023), diversifying few-shot demonstrations ( Zhanget al., 2023), and reducing complex\nproblems to sub-problems ( Zhouet al., 2023) can all improve the reasoning accuracy. In\nfact, with simple prompts like \u201cLet\u2019s think step by step\u201d just before each answer, large lan-\nguagemodelscanevenperform zero-shot chain-of-thoughtreasoningwithdecentaccuracy\n(Kojimaet al., 2022). Even for multimodal inputs consisting of both text and images, lan-\nguage models can perform multimodal chain-of-thought reasoning with higher accuracy\nthan using text input only ( Zhangetal., 2023).\n11.9.6Summary and Discussion\nTransformers have been pretrained as encoder-only (e.g., BERT), encoder\u2013decoder (e.g.,\nT5), and decoder-only (e.g., GPT series). Pretrained models may be adapted to perform\ndifferent tasks with model update (e.g., fine-tuning) or not (e.g., few-shot). Scalability of\nTransformers suggests that better performance benefits from larger models, more training\ndata, and more training compute. Since Transformers were first designed and pretrained\nfor text data, this section leans slightly towards natural language processing. Nonetheless,\nthose models discussed above can be often found in more recent models across multiple\nmodalities. For example, (i) Chinchilla ( Hoffmann et al., 2022) was further extended to\nFlamingo ( Alayracetal., 2022), a visual language model for few-shot learning; (ii) GPT-2\n(Radfordet al., 2019) and the vision Transformer encode text and images in CLIP (Con-\ntrastive Language-Image Pre-training) ( Radfordet al., 2021), whose image and text em-\nbeddings were later adopted in the DALL-E 2 text-to-image system ( Rameshetal., 2022).", "mimetype": "text/plain", "start_char_idx": 1068776, "end_char_idx": 1072617, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "096fba12-75c4-4820-ad30-f526f27a4b9b": {"__data__": {"id_": "096fba12-75c4-4820-ad30-f526f27a4b9b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "905b7137-aaa7-4c69-8f04-376caa0ba25f", "node_type": "1", "metadata": {}, "hash": "ce0463d796a61ad02eda4428d659320d34f18871026d428ed3db942e7199e4d1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "75461e90-a1fe-4582-ae21-55b040fb884c", "node_type": "1", "metadata": {}, "hash": "894109ca6adf45342ecee5db998c97f96fc9b2f06b85b3800dbb4d33e965a86f", "class_name": "RelatedNodeInfo"}}, "text": "Scalability of\nTransformers suggests that better performance benefits from larger models, more training\ndata, and more training compute. Since Transformers were first designed and pretrained\nfor text data, this section leans slightly towards natural language processing. Nonetheless,\nthose models discussed above can be often found in more recent models across multiple\nmodalities. For example, (i) Chinchilla ( Hoffmann et al., 2022) was further extended to\nFlamingo ( Alayracetal., 2022), a visual language model for few-shot learning; (ii) GPT-2\n(Radfordet al., 2019) and the vision Transformer encode text and images in CLIP (Con-\ntrastive Language-Image Pre-training) ( Radfordet al., 2021), whose image and text em-\nbeddings were later adopted in the DALL-E 2 text-to-image system ( Rameshetal., 2022).\nAlthough there have been no systematic studies on Transformer scalability in multimodal\npretrainingyet,anall-Transformertext-to-imagemodelcalledParti( Yuetal.,2022)shows\npotential of scalability across modalities: a larger Parti is more capable of high-fidelity\nimage generation and content-rich text understanding ( Fig. 11.9.12 ).\n467 Large-Scale Pretraining with Transformers\ntFig. 11.9.12 Image examples generated from the same text by the Parti model of increasing sizes\n(350M, 750M, 3B, 20B) (examples taken from Yu et al. ( 2022 )).\n16511.9.7Exercises\n1.Is it possible to fine-tune T5 using a minibatch consisting of different tasks? Why or\nwhy not? How about for GPT-2?\n2.Given a powerful language model, what applications can you think of?\n3.Say that you are asked to fine-tune a language model to perform text classification by\nadding additional layers. Where will you add them? Why?\n4.Consider sequence-to-sequence problems (e.g., machine translation) where the input\nsequence is always available throughout the target sequence prediction. What could be\nlimitations of modeling with decoder-only Transformers? Why?\nDiscussions165.\n12 Optimization Algorithms\nIfyoureadthebookinsequenceuptothispointyoualreadyusedanumberofoptimization\nalgorithms to train deep learning models. They were the tools that allowed us to continue\nupdating model parameters and to minimize the value of the loss function, as evaluated on\nthe training set. Indeed, anyone content with treating optimization as a black box device\nto minimize objective functions in a simple setting might well content oneself with the\nknowledge that there exists an array of incantations of such a procedure (with names such\nas \u201cSGD\u201d and \u201cAdam\u201d).\nTo do well, however, some deeper knowledge is required. Optimization algorithms are\nimportant for deep learning. On the one hand, training a complex deep learning model can\ntake hours, days, or even weeks. The performance of the optimization algorithm directly\naffects the model\u2019s training efficiency. On the other hand, understanding the principles\nof different optimization algorithms and the role of their hyperparameters will enable us to\ntunethehyperparametersinatargetedmannertoimprovetheperformanceofdeeplearning\nmodels.\nIn this chapter, we explore common deep learning optimization algorithms in depth. Al-\nmost all optimization problems arising in deep learning are nonconvex . Nonetheless, the\ndesignandanalysisofalgorithmsinthecontextof convexproblemshaveproventobevery\ninstructive. It is for that reason that this chapter includes a primer on convex optimization\nand the proof fora very simple stochastic gradient descent algorithm on a convexobjective\nfunction.\n12.1Optimizationand Deep Learning\nIn this section, we will discuss the relationship between optimization and deep learning as\nwellasthechallengesofusingoptimizationindeeplearning. Foradeeplearningproblem,\nwe will usually define a loss function first. Once we have the loss function, we can use an\noptimization algorithm in attempt to minimize the loss. In optimization, a loss function is\noftenreferredtoasthe objectivefunction oftheoptimizationproblem. Bytraditionandcon-\nvention most optimization algorithms are concerned with minimization . If we ever need to\nmaximize an objective there is a simple solution: just flip the sign on the objective.\n468\n469 Optimization and Deep Learning\n12.1.1Goal of Optimization\nAlthough optimization provides a way to minimize the loss function for deep learning,\nin essence, the goals of optimization and deep learning are fundamentally different.", "mimetype": "text/plain", "start_char_idx": 1071809, "end_char_idx": 1076193, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "75461e90-a1fe-4582-ae21-55b040fb884c": {"__data__": {"id_": "75461e90-a1fe-4582-ae21-55b040fb884c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "096fba12-75c4-4820-ad30-f526f27a4b9b", "node_type": "1", "metadata": {}, "hash": "a55716595595a0798f6183ad13893bfe1979e26afe6d8bf5eb549884e598a70d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "46ef9c6c-7aa1-43cc-a57b-1da066a2d134", "node_type": "1", "metadata": {}, "hash": "813af3e0f1395a90d95f6b658517cdc97f58652648a6ba359079b9209b24eb04", "class_name": "RelatedNodeInfo"}}, "text": "12.1Optimizationand Deep Learning\nIn this section, we will discuss the relationship between optimization and deep learning as\nwellasthechallengesofusingoptimizationindeeplearning. Foradeeplearningproblem,\nwe will usually define a loss function first. Once we have the loss function, we can use an\noptimization algorithm in attempt to minimize the loss. In optimization, a loss function is\noftenreferredtoasthe objectivefunction oftheoptimizationproblem. Bytraditionandcon-\nvention most optimization algorithms are concerned with minimization . If we ever need to\nmaximize an objective there is a simple solution: just flip the sign on the objective.\n468\n469 Optimization and Deep Learning\n12.1.1Goal of Optimization\nAlthough optimization provides a way to minimize the loss function for deep learning,\nin essence, the goals of optimization and deep learning are fundamentally different. The\nformerisprimarilyconcernedwithminimizinganobjectivewhereasthelatterisconcerned\nwithfindingasuitablemodel,givenafiniteamountofdata. In Section3.6 ,wediscussedthe\ndifferencebetweenthesetwogoalsindetail. Forinstance,trainingerrorandgeneralization\nerrorgenerallydiffer: sincetheobjectivefunctionoftheoptimizationalgorithmisusuallya\nlossfunctionbasedonthetrainingdataset,thegoalofoptimizationistoreducethetraining\nerror. However,thegoalofdeeplearning(ormorebroadly,statisticalinference)istoreduce\nthe generalization error. To accomplish the latter we need to pay attention to overfitting in\naddition to using the optimization algorithm to reduce the training error.\n%matplotlib inline\nimport numpy asnp\nimport torch\nfrom mpl_toolkits import mplot3d\nfrom d2l import torch asd2l\nTo illustrate the aforementioned different goals, let\u2019s consider the empirical risk and the\nrisk. As described in Section 4.7.3 , the empirical risk is an average loss on the training\ndatasetwhiletheriskistheexpectedlossontheentirepopulationofdata. Belowwedefine\ntwo functions: the risk function fand the empirical risk function g. Suppose that we have\nonly a finite amount of training data. As a result, here gis less smooth than f.\ndef f(x):\nreturn x*torch .cos(np .pi*x)\ndef g(x):\nreturn f(x) +0.2 *torch .cos( 5*np.pi*x)\nThe graph below illustrates that the minimum of the empirical risk on a training dataset\nmay be at a different location from the minimum of the risk (generalization error).\ndef annotate (text, xy, xytext): #@save\nd2l.plt.gca() .annotate(text, xy =xy, xytext =xytext,\narrowprops =dict (arrowstyle ='->'))\nx=torch .arange( 0.5,1.5,0.01 )\nd2l.set_figsize(( 4.5,2.5))\nd2l.plot(x, [f(x), g(x)], 'x','risk ')\nannotate( 'min of \\nempirical risk ', (1.0,-1.2), ( 0.5,-1.1))\nannotate( 'min of risk ', (1.1,-1.05 ), ( 0.95 ,-0.5))\n12.1.2OptimizationChallengesin Deep Learning\nIn this chapter, we are going to focus specifically on the performance of optimization algo-\nrithms in minimizing the objective function, rather than a model\u2019s generalization error. In\nSection 3.1 we distinguished between analytical solutions and numerical solutions in opti-\n470 Optimization Algorithms\nmization problems. In deep learning, most objective functions are complicated and do not\nhave analytical solutions. Instead, we must use numerical optimization algorithms. The\noptimization algorithms in this chapter all fall into this category.\nThere are many challenges in deep learning optimization. Some of the most vexing ones\narelocalminima, saddlepoints, andvanishinggradients. Let\u2019shavealookatthem.\nLocalMinima\nFor any objective function \ud835\udc53\u00b9\ud835\udc65\u00ba, if the value of \ud835\udc53\u00b9\ud835\udc65\u00baat\ud835\udc65is smaller than the values of \ud835\udc53\u00b9\ud835\udc65\u00ba\nat any other points in the vicinity of \ud835\udc65, then\ud835\udc53\u00b9\ud835\udc65\u00bacould be a local minimum. If the value\nof\ud835\udc53\u00b9\ud835\udc65\u00baat\ud835\udc65is the minimum of the objective function over the entire domain, then \ud835\udc53\u00b9\ud835\udc65\u00bais\nthe global minimum.", "mimetype": "text/plain", "start_char_idx": 1075307, "end_char_idx": 1079068, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "46ef9c6c-7aa1-43cc-a57b-1da066a2d134": {"__data__": {"id_": "46ef9c6c-7aa1-43cc-a57b-1da066a2d134", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "75461e90-a1fe-4582-ae21-55b040fb884c", "node_type": "1", "metadata": {}, "hash": "894109ca6adf45342ecee5db998c97f96fc9b2f06b85b3800dbb4d33e965a86f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9dda4634-0594-4a53-8b39-a78fcb827ffc", "node_type": "1", "metadata": {}, "hash": "d33fb71ff1a86782b92e1a4c34115aaa5f17219de4d8a6dfc711e1840e039b57", "class_name": "RelatedNodeInfo"}}, "text": "Instead, we must use numerical optimization algorithms. The\noptimization algorithms in this chapter all fall into this category.\nThere are many challenges in deep learning optimization. Some of the most vexing ones\narelocalminima, saddlepoints, andvanishinggradients. Let\u2019shavealookatthem.\nLocalMinima\nFor any objective function \ud835\udc53\u00b9\ud835\udc65\u00ba, if the value of \ud835\udc53\u00b9\ud835\udc65\u00baat\ud835\udc65is smaller than the values of \ud835\udc53\u00b9\ud835\udc65\u00ba\nat any other points in the vicinity of \ud835\udc65, then\ud835\udc53\u00b9\ud835\udc65\u00bacould be a local minimum. If the value\nof\ud835\udc53\u00b9\ud835\udc65\u00baat\ud835\udc65is the minimum of the objective function over the entire domain, then \ud835\udc53\u00b9\ud835\udc65\u00bais\nthe global minimum.\nFor example, given the function\n\ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc65\u0001cos\u00b9\ud835\udf0b\ud835\udc65\u00bafor\u00001.0\u0014\ud835\udc65\u00142.0, (12.1.1)\nwe can approximate the local minimum and global minimum of this function.\nx=torch .arange( -1.0,2.0,0.01 )\nd2l.plot(x, [f(x), ], 'x','f(x) ')\nannotate( 'local minimum ', (-0.3,-0.25 ), ( -0.77 ,-1.0))\nannotate( 'global minimum ', (1.1,-0.95 ), ( 0.6,0.8))\nThe objective function of deep learning models usually has many local optima. When the\nnumerical solution of an optimization problem is near the local optimum, the numerical\n471 Optimization and Deep Learning\nsolution obtained by the final iteration may only minimize the objective function locally,\nrather than globally, as the gradient of the objective function\u2019s solutions approaches or\nbecomes zero. Only some degree of noise might knock the parameter out of the local\nminimum. In fact, this is one of the beneficial properties of minibatch stochastic gradient\ndescent where the natural variation of gradients over minibatches is able to dislodge the\nparameters from local minima.\nSaddle Points\nBesides local minima, saddle points are another reason for gradients to vanish. A saddle\npointis any location where all gradients of a function vanish but which is neither a global\nnor a local minimum. Consider the function \ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc653. Its first and second derivative van-\nishfor\ud835\udc65=0. Optimizationmightstallatthispoint,eventhoughitisnotaminimum.\nx=torch .arange( -2.0,2.0,0.01 )\nd2l.plot(x, [x **3],'x','f(x) ')\nannotate( 'saddle point ', (0,-0.2), ( -0.52 ,-5.0))\nSaddle points in higher dimensions are even more insidious, as the example below shows.\nConsiderthefunction \ud835\udc53\u00b9\ud835\udc65,\ud835\udc66\u00ba=\ud835\udc652\u0000\ud835\udc662. Ithasitssaddlepointat \u00b90,0\u00ba. Thisisamaximum\nwith respect to \ud835\udc66and a minimum with respect to \ud835\udc65. Moreover, it lookslike a saddle, which\nis where this mathematical property got its name.\nx, y =torch .meshgrid(\ntorch .linspace( -1.0,1.0,101), torch .linspace( -1.0,1.0,101))\nz=x**2-y**2\nax=d2l.plt.figure() .add_subplot( 111, projection ='3d')\nax.plot_wireframe(x, y, z, **{'rstride ':10,'cstride ':10})\nax.plot([ 0], [ 0], [ 0],'rx')\nticks =[-1,0,1]\nd2l.plt.xticks(ticks)\nd2l.plt.yticks(ticks)\nax.set_zticks(ticks)\nd2l.plt.xlabel( 'x')\nd2l.plt.ylabel( 'y');\nWe assume that the input of a function is a \ud835\udc58-dimensional vector and its output is a scalar,\n472 Optimization Algorithms\nso its Hessian matrix will have \ud835\udc58eigenvalues. The solution of the function could be a local\nminimum, a local maximum, or a saddle point at a position where the function gradient is\nzero:\n\u000fWhen the eigenvalues of the function\u2019s Hessian matrix at the zero-gradient position are\nall positive, we have a local minimum for the function.\n\u000fWhen the eigenvalues of the function\u2019s Hessian matrix at the zero-gradient position are\nall negative, we have a local maximum for the function.", "mimetype": "text/plain", "start_char_idx": 1078481, "end_char_idx": 1081828, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9dda4634-0594-4a53-8b39-a78fcb827ffc": {"__data__": {"id_": "9dda4634-0594-4a53-8b39-a78fcb827ffc", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "46ef9c6c-7aa1-43cc-a57b-1da066a2d134", "node_type": "1", "metadata": {}, "hash": "813af3e0f1395a90d95f6b658517cdc97f58652648a6ba359079b9209b24eb04", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c5fbe5b1-d5da-4769-850b-3babab7c10db", "node_type": "1", "metadata": {}, "hash": "dea71ae9bf6cbbc164dea8d265495be58193bf8e8738b15cc1d44d8351868b3b", "class_name": "RelatedNodeInfo"}}, "text": "The solution of the function could be a local\nminimum, a local maximum, or a saddle point at a position where the function gradient is\nzero:\n\u000fWhen the eigenvalues of the function\u2019s Hessian matrix at the zero-gradient position are\nall positive, we have a local minimum for the function.\n\u000fWhen the eigenvalues of the function\u2019s Hessian matrix at the zero-gradient position are\nall negative, we have a local maximum for the function.\n\u000fWhen the eigenvalues of the function\u2019s Hessian matrix at the zero-gradient position are\nnegative and positive, we have a saddle point for the function.\nForhigh-dimensionalproblemsthelikelihoodthatatleast someoftheeigenvaluesareneg-\nativeisquitehigh. Thismakessaddlepointsmorelikelythanlocalminima. Wewilldiscuss\nsome exceptions to this situation in the next section when introducing convexity. In short,\nconvex functions are those where the eigenvalues of the Hessian are never negative. Sadly,\nthough,mostdeeplearningproblemsdonotfallintothiscategory. Nonethelessitisagreat\ntool to study optimization algorithms.\nVanishingGradients\nProbably the most insidious problem to encounter is the vanishing gradient. Recall our\ncommonly-used activation functions and their derivatives in Section 5.1.2 . For instance,\nassumethatwewanttominimizethefunction \ud835\udc53\u00b9\ud835\udc65\u00ba=tanh\u00b9\ud835\udc65\u00baandwehappentogetstarted\nat\ud835\udc65=4. As we can see, the gradient of \ud835\udc53is close to nil. More specifically, \ud835\udc530\u00b9\ud835\udc65\u00ba=\n1\u0000tanh2\u00b9\ud835\udc65\u00baand thus\ud835\udc530\u00b94\u00ba=0.0013. Consequently, optimization will get stuck for a\nlong time before we make progress. This turns out to be one of the reasons that training\ndeep learning models was quite tricky prior to the introduction of the ReLU activation\nfunction.\nx=torch .arange( -2.0,5.0,0.01 )\nd2l.plot(x, [torch .tanh(x)], 'x','f(x) ')\nannotate( 'vanishing gradient ', (4,1), ( 2,0.0))\nAs we saw, optimization for deep learning is full of challenges. Fortunately there exists a\nrobust range of algorithms that perform well and that are easy to use even for beginners.\n473 Optimization and Deep Learning\n166Furthermore, it is not really necessary to find thebest solution. Local optima or even ap-\nproximate solutions thereof are still very useful.\n12.1.3Summary\n\u000fMinimizing the training error does notguarantee that we find the best set of parameters\nto minimize the generalization error.\n\u000fThe optimization problems may have many local minima.\n\u000fTheproblemmayhaveevenmoresaddlepoints,asgenerallytheproblemsarenotconvex.\n\u000fVanishing gradients can cause optimization to stall. Often a reparametrization of the\nproblem helps. Good initialization of the parameters can be beneficial, too.\n12.1.4Exercises\n1.Consider a simple MLP with a single hidden layer of, say, \ud835\udc51dimensions in the hid-\nden layer and a single output. Show that for any local minimum there are at least \ud835\udc51!\nequivalent solutions that behave identically.\n2.Assume that we have a symmetric random matrix Mwhere the entries \ud835\udc40\ud835\udc56\ud835\udc57=\ud835\udc40\ud835\udc57\ud835\udc56are\neach drawn from some probability distribution \ud835\udc5d\ud835\udc56\ud835\udc57. Furthermore assume that \ud835\udc5d\ud835\udc56\ud835\udc57\u00b9\ud835\udc65\u00ba=\n\ud835\udc5d\ud835\udc56\ud835\udc57\u00b9\u0000\ud835\udc65\u00ba, i.e., that the distribution is symmetric (see e.g., Wigner ( 1958) for details).\n1.Provethatthedistributionovereigenvaluesisalsosymmetric. Thatis,foranyeigen-\nvector vthe probability that the associated eigenvalue \ud835\udf06satisfies\ud835\udc43\u00b9\ud835\udf06> 0\u00ba=\ud835\udc43\u00b9\ud835\udf06<\n0\u00ba.\n2.Why does the above notimply\ud835\udc43\u00b9\ud835\udf06> 0\u00ba=0.5?\n3.What other challenges involved in deep learning optimization can you think of?\n4.Assume that you want to balance a (real) ball on a (real) saddle.\n1.Why is this hard?\n2.Can you exploit this effect also for optimization algorithms?\nDiscussions166.\n474 Optimization Algorithms\n12.2Convexity\nConvexity plays a vital role in the design of optimization algorithms.", "mimetype": "text/plain", "start_char_idx": 1081398, "end_char_idx": 1085030, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c5fbe5b1-d5da-4769-850b-3babab7c10db": {"__data__": {"id_": "c5fbe5b1-d5da-4769-850b-3babab7c10db", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9dda4634-0594-4a53-8b39-a78fcb827ffc", "node_type": "1", "metadata": {}, "hash": "d33fb71ff1a86782b92e1a4c34115aaa5f17219de4d8a6dfc711e1840e039b57", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2fc3bf49-5958-44aa-99f8-8acd981c2ac4", "node_type": "1", "metadata": {}, "hash": "a5dd83d7aa2b7d8e8c23271683a4c05c66ab7de7bcbfdfa29ab41f4aef1f3b87", "class_name": "RelatedNodeInfo"}}, "text": "1.Provethatthedistributionovereigenvaluesisalsosymmetric. Thatis,foranyeigen-\nvector vthe probability that the associated eigenvalue \ud835\udf06satisfies\ud835\udc43\u00b9\ud835\udf06> 0\u00ba=\ud835\udc43\u00b9\ud835\udf06<\n0\u00ba.\n2.Why does the above notimply\ud835\udc43\u00b9\ud835\udf06> 0\u00ba=0.5?\n3.What other challenges involved in deep learning optimization can you think of?\n4.Assume that you want to balance a (real) ball on a (real) saddle.\n1.Why is this hard?\n2.Can you exploit this effect also for optimization algorithms?\nDiscussions166.\n474 Optimization Algorithms\n12.2Convexity\nConvexity plays a vital role in the design of optimization algorithms. This is largely due\nto the fact that it is much easier to analyze and test algorithms in such a context. In other\nwords, if the algorithm performs poorly even in the convex setting, typically we should not\nhopetoseegreatresultsotherwise. Furthermore,eventhoughtheoptimizationproblemsin\ndeep learning are generally nonconvex, they often exhibit some properties of convex ones\nnear local minima. This can lead to exciting new optimization variants such as ( Izmailov\netal., 2018).\n%matplotlib inline\nimport numpy asnp\nimport torch\nfrom mpl_toolkits import mplot3d\nfrom d2l import torch asd2l\n12.2.1Definitions\nBefore convex analysis, we need to define convex sets andconvex functions . They lead to\nmathematical tools that are commonly applied to machine learning.\nConvexSets\nSets are the basis of convexity. Simply put, a set Xin a vector space is convexif for any\n\ud835\udc4e,\ud835\udc4f2Xthe line segment connecting \ud835\udc4eand\ud835\udc4fis also inX. In mathematical terms this\nmeans that for all \ud835\udf062\u00bb0,1\u00bcwe have\n\ud835\udf06\ud835\udc4e\u00b8\u00b91\u0000\ud835\udf06\u00ba\ud835\udc4f2Xwhenever\ud835\udc4e,\ud835\udc4f2X. (12.2.1)\nThissoundsabitabstract. Consider Fig.12.2.1 . Thefirstsetisnotconvexsincethereexist\nlinesegmentsthatarenotcontainedinit. Theothertwosetssuffernosuchproblem.\ntFig. 12.2.1 The \ufb01rst set is nonconvex and the other two are convex.\nDefinitionsontheirownarenotparticularlyusefulunlessyoucandosomethingwiththem.\nIn this case we can look at intersections as shown in Fig. 12.2.2 . Assume thatXandYare\nconvex sets. ThenX\\Yis also convex. To see this, consider any \ud835\udc4e,\ud835\udc4f2X\\Y . SinceX\nandYare convex, the line segments connecting \ud835\udc4eand\ud835\udc4fare contained in both XandY.\nGiven that, they also need to be contained in X\\Y, thus proving our theorem.\n475 Convexity\ntFig. 12.2.2 The intersection between two convex sets is convex.\nWecanstrengthenthisresultwithlittleeffort: givenconvexsets X\ud835\udc56, theirintersection\\\ud835\udc56X\ud835\udc56\nis convex. To see that the converse is not true, consider two disjoint sets X\\Y =;. Now\npick\ud835\udc4e2Xand\ud835\udc4f2Y. Thelinesegmentin Fig.12.2.3 connecting\ud835\udc4eand\ud835\udc4fneedstocontain\nsome part that is neither in Xnor inY, since we assumed that X\\Y =;. Hence the line\nsegment is not inX[Yeither, thus proving that in general unions of convex sets need not\nbe convex.\ntFig. 12.2.3 The union of two convex sets need not be convex.\nTypically the problems in deep learning are defined on convex sets. For instance, R\ud835\udc51, the\nsetof\ud835\udc51-dimensionalvectorsofrealnumbers,isaconvexset(afterall,thelinebetweenany\ntwo points in R\ud835\udc51remains in R\ud835\udc51). In some cases we work with variables of bounded length,\nsuch as balls of radius \ud835\udc5fas defined byfxjx2R\ud835\udc51andkxk\u0014\ud835\udc5fg.\nConvexFunctions\nNow that we have convex sets we can introduce convexfunctions \ud835\udc53. Given a convex set X,\na function\ud835\udc53:X!", "mimetype": "text/plain", "start_char_idx": 1084467, "end_char_idx": 1087669, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2fc3bf49-5958-44aa-99f8-8acd981c2ac4": {"__data__": {"id_": "2fc3bf49-5958-44aa-99f8-8acd981c2ac4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c5fbe5b1-d5da-4769-850b-3babab7c10db", "node_type": "1", "metadata": {}, "hash": "dea71ae9bf6cbbc164dea8d265495be58193bf8e8738b15cc1d44d8351868b3b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8942b9bc-724f-49b0-8138-13d142f3feb8", "node_type": "1", "metadata": {}, "hash": "aba4c83f628eb7dd2be9189199b67882a57322334400787fba05929d3994b21b", "class_name": "RelatedNodeInfo"}}, "text": "Hence the line\nsegment is not inX[Yeither, thus proving that in general unions of convex sets need not\nbe convex.\ntFig. 12.2.3 The union of two convex sets need not be convex.\nTypically the problems in deep learning are defined on convex sets. For instance, R\ud835\udc51, the\nsetof\ud835\udc51-dimensionalvectorsofrealnumbers,isaconvexset(afterall,thelinebetweenany\ntwo points in R\ud835\udc51remains in R\ud835\udc51). In some cases we work with variables of bounded length,\nsuch as balls of radius \ud835\udc5fas defined byfxjx2R\ud835\udc51andkxk\u0014\ud835\udc5fg.\nConvexFunctions\nNow that we have convex sets we can introduce convexfunctions \ud835\udc53. Given a convex set X,\na function\ud835\udc53:X! Risconvexif for all\ud835\udc65,\ud835\udc6502Xand for all\ud835\udf062\u00bb0,1\u00bcwe have\n\ud835\udf06\ud835\udc53\u00b9\ud835\udc65\u00ba\u00b8\u00b9 1\u0000\ud835\udf06\u00ba\ud835\udc53\u00b9\ud835\udc650\u00ba\u0015\ud835\udc53\u00b9\ud835\udf06\ud835\udc65\u00b8\u00b91\u0000\ud835\udf06\u00ba\ud835\udc650\u00ba. (12.2.2)\nTo illustrate this let\u2019s plot a few functions and check which ones satisfy the requirement.\nBelow we define a few functions, both convex and nonconvex.\nf=lambda x:0.5 *x**2# Convex\ng=lambda x: torch .cos(np .pi*x) # Nonconvex\nh=lambda x: torch .exp( 0.5 *x) # Convex\nx, segment =torch .arange( -2,2,0.01 ), torch .tensor([ -1.5,1])\nd2l.use_svg_display()\n_, axes =d2l.plt.subplots( 1,3, figsize =(9,3))\nfor ax, func inzip(axes, [f, g, h]):\nd2l.plot([x, segment], [func(x), func(segment)], axes =ax)\n476 Optimization Algorithms\nAs expected, the cosine function is nonconvex , whereas the parabola and the exponential\nfunctionare. Notethattherequirementthat Xisaconvexsetisnecessaryforthecondition\ntomakesense. Otherwisetheoutcomeof \ud835\udc53\u00b9\ud835\udf06\ud835\udc65\u00b8\u00b91\u0000\ud835\udf06\u00ba\ud835\udc650\u00bamightnotbewelldefined.\nJensen\u2019sInequality\nGivenaconvexfunction \ud835\udc53,oneofthemostusefulmathematicaltoolsis Jensen\u2019sinequality .\nIt amounts to a generalization of the definition of convexity:\n\u00d5\n\ud835\udc56\ud835\udefc\ud835\udc56\ud835\udc53\u00b9\ud835\udc65\ud835\udc56\u00ba\u0015\ud835\udc53 \u00d5\n\ud835\udc56\ud835\udefc\ud835\udc56\ud835\udc65\ud835\udc56!\nand\ud835\udc38\ud835\udc4b\u00bb\ud835\udc53\u00b9\ud835\udc4b\u00ba\u00bc\u0015\ud835\udc53\u00b9\ud835\udc38\ud835\udc4b\u00bb\ud835\udc4b\u00bc\u00ba, (12.2.3)\nwhere\ud835\udefc\ud835\udc56are nonnegative real numbers such that\u00cd\n\ud835\udc56\ud835\udefc\ud835\udc56=1and\ud835\udc4bis a random variable. In\nother words, the expectation of a convex function is no less than the convex function of an\nexpectation, where the latter is usually a simpler expression. To prove the first inequality\nwe repeatedly apply the definition of convexity to one term in the sum at a time.\nOne of the common applications of Jensen\u2019s inequality is to bound a more complicated\nexpression by a simpler one. For example, its application can be with regard to the log-\nlikelihood of partially observed random variables. That is, we use\n\ud835\udc38\ud835\udc4c\u0018\ud835\udc43\u00b9\ud835\udc4c\u00ba\u00bb\u0000log\ud835\udc43\u00b9\ud835\udc4bj\ud835\udc4c\u00ba\u00bc\u0015\u0000 log\ud835\udc43\u00b9\ud835\udc4b\u00ba, (12.2.4)\nsince\u00af\n\ud835\udc43\u00b9\ud835\udc4c\u00ba\ud835\udc43\u00b9\ud835\udc4bj\ud835\udc4c\u00ba\ud835\udc51\ud835\udc4c=\ud835\udc43\u00b9\ud835\udc4b\u00ba. This can be used in variational methods. Here \ud835\udc4c\nis typically the unobserved random variable, \ud835\udc43\u00b9\ud835\udc4c\u00bais the best guess of how it might be\ndistributed, and \ud835\udc43\u00b9\ud835\udc4b\u00bais the distribution with \ud835\udc4cintegrated out. For instance, in clustering\n\ud835\udc4cmight be the cluster labels and \ud835\udc43\u00b9\ud835\udc4bj\ud835\udc4c\u00bais the generative model when applying cluster\nlabels.", "mimetype": "text/plain", "start_char_idx": 1087063, "end_char_idx": 1089718, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8942b9bc-724f-49b0-8138-13d142f3feb8": {"__data__": {"id_": "8942b9bc-724f-49b0-8138-13d142f3feb8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2fc3bf49-5958-44aa-99f8-8acd981c2ac4", "node_type": "1", "metadata": {}, "hash": "a5dd83d7aa2b7d8e8c23271683a4c05c66ab7de7bcbfdfa29ab41f4aef1f3b87", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "08de803a-98e6-4b38-9022-07c1dbd118aa", "node_type": "1", "metadata": {}, "hash": "86149722e4febd883ac12df6fe52fb0bdb74c7be7244c0abadb42f18f1c4916a", "class_name": "RelatedNodeInfo"}}, "text": "That is, we use\n\ud835\udc38\ud835\udc4c\u0018\ud835\udc43\u00b9\ud835\udc4c\u00ba\u00bb\u0000log\ud835\udc43\u00b9\ud835\udc4bj\ud835\udc4c\u00ba\u00bc\u0015\u0000 log\ud835\udc43\u00b9\ud835\udc4b\u00ba, (12.2.4)\nsince\u00af\n\ud835\udc43\u00b9\ud835\udc4c\u00ba\ud835\udc43\u00b9\ud835\udc4bj\ud835\udc4c\u00ba\ud835\udc51\ud835\udc4c=\ud835\udc43\u00b9\ud835\udc4b\u00ba. This can be used in variational methods. Here \ud835\udc4c\nis typically the unobserved random variable, \ud835\udc43\u00b9\ud835\udc4c\u00bais the best guess of how it might be\ndistributed, and \ud835\udc43\u00b9\ud835\udc4b\u00bais the distribution with \ud835\udc4cintegrated out. For instance, in clustering\n\ud835\udc4cmight be the cluster labels and \ud835\udc43\u00b9\ud835\udc4bj\ud835\udc4c\u00bais the generative model when applying cluster\nlabels.\n12.2.2Properties\nConvex functions have many useful properties. We describe a few commonly-used ones\nbelow.\n477 Convexity\nLocalMinima AreGlobal Minima\nFirst and foremost, the local minima of convex functions are also the global minima. We\ncan prove it by contradiction as follows.\nConsider a convex function \ud835\udc53defined on a convex set X. Suppose that \ud835\udc65\u00032Xis a local\nminimum: thereexistsasmallpositivevalue \ud835\udc5dsothatfor\ud835\udc652Xthatsatisfies 0<j\ud835\udc65\u0000\ud835\udc65\u0003j\u0014\n\ud835\udc5dwe have\ud835\udc53\u00b9\ud835\udc65\u0003\u00ba< \ud835\udc53\u00b9\ud835\udc65\u00ba.\nAssume that the local minimum \ud835\udc65\u0003is not the global minimum of \ud835\udc53: there exists \ud835\udc6502X\nfor which\ud835\udc53\u00b9\ud835\udc650\u00ba< \ud835\udc53\u00b9\ud835\udc65\u0003\u00ba. There also exists \ud835\udf062 \u00bb0,1\u00basuch as\ud835\udf06=1\u0000\ud835\udc5d\nj\ud835\udc65\u0003\u0000\ud835\udc650jso that\n0<j\ud835\udf06\ud835\udc65\u0003\u00b8\u00b91\u0000\ud835\udf06\u00ba\ud835\udc650\u0000\ud835\udc65\u0003j\u0014\ud835\udc5d.\nHowever, according to the definition of convex functions, we have\n\ud835\udc53\u00b9\ud835\udf06\ud835\udc65\u0003\u00b8\u00b91\u0000\ud835\udf06\u00ba\ud835\udc650\u00ba\u0014\ud835\udf06\ud835\udc53\u00b9\ud835\udc65\u0003\u00ba\u00b8\u00b9 1\u0000\ud835\udf06\u00ba\ud835\udc53\u00b9\ud835\udc650\u00ba\n<\ud835\udf06\ud835\udc53\u00b9\ud835\udc65\u0003\u00ba\u00b8\u00b9 1\u0000\ud835\udf06\u00ba\ud835\udc53\u00b9\ud835\udc65\u0003\u00ba\n=\ud835\udc53\u00b9\ud835\udc65\u0003\u00ba,(12.2.5)\nwhich contradicts with our statement that \ud835\udc65\u0003is a local minimum. Therefore, there does\nnot exist\ud835\udc6502 Xfor which\ud835\udc53\u00b9\ud835\udc650\u00ba< \ud835\udc53\u00b9\ud835\udc65\u0003\u00ba. The local minimum \ud835\udc65\u0003is also the global\nminimum.\nFor instance, the convex function \ud835\udc53\u00b9\ud835\udc65\u00ba=\u00b9\ud835\udc65\u00001\u00ba2has a local minimum at \ud835\udc65=1, which is\nalso the global minimum.\nf=lambda x: (x -1)**2\nd2l.set_figsize()\nd2l.plot([x, segment], [f(x), f(segment)], 'x','f(x) ')\nThe fact that the local minima for convex functions are also the global minima is very\nconvenient. It means that if we minimize functions we cannot \u201cget stuck\u201d. Note, though,\nthat this does not mean that there cannot be more than one global minimum or that there\nmightevenexistone. Forinstance,thefunction \ud835\udc53\u00b9\ud835\udc65\u00ba=max\u00b9j\ud835\udc65j\u00001,0\u00baattainsitsminimum\nvalue over the interval \u00bb\u00001,1\u00bc. Conversely, the function \ud835\udc53\u00b9\ud835\udc65\u00ba=exp\u00b9\ud835\udc65\u00badoes not attain a\nminimum value on R: for\ud835\udc65!\u00001it asymptotes to 0, but there is no \ud835\udc65for which\ud835\udc53\u00b9\ud835\udc65\u00ba=\n0.\n478 Optimization Algorithms\nBelowSetsof ConvexFunctions AreConvex\nWe can conveniently define convex sets via below sets of convex functions. Concretely,\ngiven a convex function \ud835\udc53defined on a convex set X, any below set\nS\ud835\udc4fdef=f\ud835\udc65j\ud835\udc652Xand\ud835\udc53\u00b9\ud835\udc65\u00ba\u0014\ud835\udc4fg (12.2.6)\nis convex.\nLet\u2019sprovethisquickly.", "mimetype": "text/plain", "start_char_idx": 1089319, "end_char_idx": 1091664, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "08de803a-98e6-4b38-9022-07c1dbd118aa": {"__data__": {"id_": "08de803a-98e6-4b38-9022-07c1dbd118aa", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8942b9bc-724f-49b0-8138-13d142f3feb8", "node_type": "1", "metadata": {}, "hash": "aba4c83f628eb7dd2be9189199b67882a57322334400787fba05929d3994b21b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "585a4373-4cc9-41e3-8d33-9641cecf44f8", "node_type": "1", "metadata": {}, "hash": "d2607c75fbb4349202509cb88ed5d3dc9841307b00618230c56fe6d7dbaaa77b", "class_name": "RelatedNodeInfo"}}, "text": "Conversely, the function \ud835\udc53\u00b9\ud835\udc65\u00ba=exp\u00b9\ud835\udc65\u00badoes not attain a\nminimum value on R: for\ud835\udc65!\u00001it asymptotes to 0, but there is no \ud835\udc65for which\ud835\udc53\u00b9\ud835\udc65\u00ba=\n0.\n478 Optimization Algorithms\nBelowSetsof ConvexFunctions AreConvex\nWe can conveniently define convex sets via below sets of convex functions. Concretely,\ngiven a convex function \ud835\udc53defined on a convex set X, any below set\nS\ud835\udc4fdef=f\ud835\udc65j\ud835\udc652Xand\ud835\udc53\u00b9\ud835\udc65\u00ba\u0014\ud835\udc4fg (12.2.6)\nis convex.\nLet\u2019sprovethisquickly. Recallthatforany \ud835\udc65,\ud835\udc6502S\ud835\udc4fweneedtoshowthat \ud835\udf06\ud835\udc65\u00b8\u00b91\u0000\ud835\udf06\u00ba\ud835\udc6502\nS\ud835\udc4fas long as\ud835\udf062\u00bb0,1\u00bc. Since\ud835\udc53\u00b9\ud835\udc65\u00ba\u0014\ud835\udc4fand\ud835\udc53\u00b9\ud835\udc650\u00ba\u0014\ud835\udc4f, by the definition of convexity we\nhave\n\ud835\udc53\u00b9\ud835\udf06\ud835\udc65\u00b8\u00b91\u0000\ud835\udf06\u00ba\ud835\udc650\u00ba\u0014\ud835\udf06\ud835\udc53\u00b9\ud835\udc65\u00ba\u00b8\u00b9 1\u0000\ud835\udf06\u00ba\ud835\udc53\u00b9\ud835\udc650\u00ba\u0014\ud835\udc4f. (12.2.7)\nConvexityand Second Derivatives\nWhenever the second derivative of a function \ud835\udc53:R\ud835\udc5b!Rexists it is very easy to check\nwhether\ud835\udc53is convex. All we need to do is check whether the Hessian of \ud835\udc53is positive\nsemidefinite:r2\ud835\udc53\u00170, i.e., denoting the Hessian matrix r2\ud835\udc53byH,x>Hx\u00150for all\nx2R\ud835\udc5b. Forinstance, thefunction \ud835\udc53\u00b9x\u00ba=1\n2kxk2isconvexsincer2\ud835\udc53=1, i.e., itsHessian\nis an identity matrix.\nFormally, atwice-differentiableone-dimensionalfunction \ud835\udc53:R!Risconvexifandonly\nif its second derivative \ud835\udc5300\u00150. For any twice-differentiable multidimensional function\n\ud835\udc53:R\ud835\udc5b!R, it is convex if and only if its Hessian r2\ud835\udc53\u00170.\nFirst,weneedtoprovetheone-dimensionalcase. Toseethatconvexityof \ud835\udc53implies\ud835\udc5300\u00150\nwe use the fact that\n1\n2\ud835\udc53\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\u00b81\n2\ud835\udc53\u00b9\ud835\udc65\u0000\ud835\udf16\u00ba\u0015\ud835\udc53\u0010\ud835\udc65\u00b8\ud835\udf16\n2\u00b8\ud835\udc65\u0000\ud835\udf16\n2\u0011\n=\ud835\udc53\u00b9\ud835\udc65\u00ba. (12.2.8)\nSincethesecondderivativeisgivenbythelimitoverfinitedifferencesitfollowsthat\n\ud835\udc5300\u00b9\ud835\udc65\u00ba=lim\n\ud835\udf16!0\ud835\udc53\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\u00b8\ud835\udc53\u00b9\ud835\udc65\u0000\ud835\udf16\u00ba\u00002\ud835\udc53\u00b9\ud835\udc65\u00ba\n\ud835\udf162\u00150. (12.2.9)\nTo see that\ud835\udc5300\u00150implies that \ud835\udc53is convex we use the fact that \ud835\udc5300\u00150implies that \ud835\udc530\nis a monotonically nondecreasing function. Let \ud835\udc4e < \ud835\udc65 < \ud835\udc4f be three points in R, where\n\ud835\udc65=\u00b91\u0000\ud835\udf06\u00ba\ud835\udc4e\u00b8\ud835\udf06\ud835\udc4fand\ud835\udf062 \u00b90,1\u00ba. According to the mean value theorem, there exist\n\ud835\udefc2\u00bb\ud835\udc4e,\ud835\udc65\u00bcand\ud835\udefd2\u00bb\ud835\udc65,\ud835\udc4f\u00bcsuch that\n\ud835\udc530\u00b9\ud835\udefc\u00ba=\ud835\udc53\u00b9\ud835\udc65\u00ba\u0000\ud835\udc53\u00b9\ud835\udc4e\u00ba\n\ud835\udc65\u0000\ud835\udc4eand\ud835\udc530\u00b9\ud835\udefd\u00ba=\ud835\udc53\u00b9\ud835\udc4f\u00ba\u0000\ud835\udc53\u00b9\ud835\udc65\u00ba\n\ud835\udc4f\u0000\ud835\udc65.", "mimetype": "text/plain", "start_char_idx": 1091244, "end_char_idx": 1093024, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "585a4373-4cc9-41e3-8d33-9641cecf44f8": {"__data__": {"id_": "585a4373-4cc9-41e3-8d33-9641cecf44f8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "08de803a-98e6-4b38-9022-07c1dbd118aa", "node_type": "1", "metadata": {}, "hash": "86149722e4febd883ac12df6fe52fb0bdb74c7be7244c0abadb42f18f1c4916a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e1e3c140-a670-4810-b39f-6dd236233009", "node_type": "1", "metadata": {}, "hash": "53c2c450869c639030fcfb7f12978f39ce8547f04005a3a9f7c4f35b592d786c", "class_name": "RelatedNodeInfo"}}, "text": "Let \ud835\udc4e < \ud835\udc65 < \ud835\udc4f be three points in R, where\n\ud835\udc65=\u00b91\u0000\ud835\udf06\u00ba\ud835\udc4e\u00b8\ud835\udf06\ud835\udc4fand\ud835\udf062 \u00b90,1\u00ba. According to the mean value theorem, there exist\n\ud835\udefc2\u00bb\ud835\udc4e,\ud835\udc65\u00bcand\ud835\udefd2\u00bb\ud835\udc65,\ud835\udc4f\u00bcsuch that\n\ud835\udc530\u00b9\ud835\udefc\u00ba=\ud835\udc53\u00b9\ud835\udc65\u00ba\u0000\ud835\udc53\u00b9\ud835\udc4e\u00ba\n\ud835\udc65\u0000\ud835\udc4eand\ud835\udc530\u00b9\ud835\udefd\u00ba=\ud835\udc53\u00b9\ud835\udc4f\u00ba\u0000\ud835\udc53\u00b9\ud835\udc65\u00ba\n\ud835\udc4f\u0000\ud835\udc65. (12.2.10)\nBy monotonicity \ud835\udc530\u00b9\ud835\udefd\u00ba\u0015\ud835\udc530\u00b9\ud835\udefc\u00ba, hence\n\ud835\udc65\u0000\ud835\udc4e\n\ud835\udc4f\u0000\ud835\udc4e\ud835\udc53\u00b9\ud835\udc4f\u00ba\u00b8\ud835\udc4f\u0000\ud835\udc65\n\ud835\udc4f\u0000\ud835\udc4e\ud835\udc53\u00b9\ud835\udc4e\u00ba\u0015\ud835\udc53\u00b9\ud835\udc65\u00ba. (12.2.11)\nSince\ud835\udc65=\u00b91\u0000\ud835\udf06\u00ba\ud835\udc4e\u00b8\ud835\udf06\ud835\udc4f, we have\n\ud835\udf06\ud835\udc53\u00b9\ud835\udc4f\u00ba\u00b8\u00b9 1\u0000\ud835\udf06\u00ba\ud835\udc53\u00b9\ud835\udc4e\u00ba\u0015\ud835\udc53\u00b9\u00b91\u0000\ud835\udf06\u00ba\ud835\udc4e\u00b8\ud835\udf06\ud835\udc4f\u00ba, (12.2.12)\n479 Convexity\nthus proving convexity.\nSecond,weneedalemmabeforeprovingthemultidimensionalcase: \ud835\udc53:R\ud835\udc5b!Risconvex\nif and only if for all x,y2R\ud835\udc5b\n\ud835\udc54\u00b9\ud835\udc67\u00badef=\ud835\udc53\u00b9\ud835\udc67x\u00b8\u00b91\u0000\ud835\udc67\u00bay\u00bawhere\ud835\udc672\u00bb0,1\u00bc (12.2.13)\nis convex.\nToprovethatconvexityof \ud835\udc53impliesthat\ud835\udc54isconvex,wecanshowthatforall \ud835\udc4e,\ud835\udc4f,\ud835\udf062\u00bb0,1\u00bc\n(thus 0\u0014\ud835\udf06\ud835\udc4e\u00b8\u00b91\u0000\ud835\udf06\u00ba\ud835\udc4f\u00141)\n\ud835\udc54\u00b9\ud835\udf06\ud835\udc4e\u00b8\u00b91\u0000\ud835\udf06\u00ba\ud835\udc4f\u00ba\n=\ud835\udc53\u00b9\u00b9\ud835\udf06\ud835\udc4e\u00b8\u00b91\u0000\ud835\udf06\u00ba\ud835\udc4f\u00bax\u00b8\u00b91\u0000\ud835\udf06\ud835\udc4e\u0000\u00b91\u0000\ud835\udf06\u00ba\ud835\udc4f\u00bay\u00ba\n=\ud835\udc53\u00b9\ud835\udf06\u00b9\ud835\udc4ex\u00b8\u00b91\u0000\ud835\udc4e\u00bay\u00ba\u00b8\u00b91\u0000\ud835\udf06\u00ba\u00b9\ud835\udc4fx\u00b8\u00b91\u0000\ud835\udc4f\u00bay\u00ba\u00ba\n\u0014\ud835\udf06\ud835\udc53\u00b9\ud835\udc4ex\u00b8\u00b91\u0000\ud835\udc4e\u00bay\u00ba\u00b8\u00b91\u0000\ud835\udf06\u00ba\ud835\udc53\u00b9\ud835\udc4fx\u00b8\u00b91\u0000\ud835\udc4f\u00bay\u00ba\n=\ud835\udf06\ud835\udc54\u00b9\ud835\udc4e\u00ba\u00b8\u00b9 1\u0000\ud835\udf06\u00ba\ud835\udc54\u00b9\ud835\udc4f\u00ba.(12.2.14)\nTo prove the converse, we can show that for all \ud835\udf062\u00bb0,1\u00bc\n\ud835\udc53\u00b9\ud835\udf06x\u00b8\u00b91\u0000\ud835\udf06\u00bay\u00ba\n=\ud835\udc54\u00b9\ud835\udf06\u00011\u00b8\u00b91\u0000\ud835\udf06\u00ba\u00010\u00ba\n\u0014\ud835\udf06\ud835\udc54\u00b91\u00ba\u00b8\u00b9 1\u0000\ud835\udf06\u00ba\ud835\udc54\u00b90\u00ba\n=\ud835\udf06\ud835\udc53\u00b9x\u00ba\u00b8\u00b9 1\u0000\ud835\udf06\u00ba\ud835\udc53\u00b9y\u00ba.(12.2.15)\nFinally,usingthelemmaaboveandtheresultoftheone-dimensionalcase,themultidimen-\nsional case can be proven as follows. A multidimensional function \ud835\udc53:R\ud835\udc5b!Ris convex\nif and only if for all x,y2R\ud835\udc5b\ud835\udc54\u00b9\ud835\udc67\u00badef=\ud835\udc53\u00b9\ud835\udc67x\u00b8\u00b91\u0000\ud835\udc67\u00bay\u00ba, where\ud835\udc672\u00bb0,1\u00bc, is convex.", "mimetype": "text/plain", "start_char_idx": 1092840, "end_char_idx": 1093975, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e1e3c140-a670-4810-b39f-6dd236233009": {"__data__": {"id_": "e1e3c140-a670-4810-b39f-6dd236233009", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "585a4373-4cc9-41e3-8d33-9641cecf44f8", "node_type": "1", "metadata": {}, "hash": "d2607c75fbb4349202509cb88ed5d3dc9841307b00618230c56fe6d7dbaaa77b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7ad45b4c-3408-4485-9150-a7a7d1b185ee", "node_type": "1", "metadata": {}, "hash": "fada5b0e23e7c544f8eef150efb8e5b0ecdb6a1f27124fab4a1145b2ef7dc29a", "class_name": "RelatedNodeInfo"}}, "text": "(12.2.15)\nFinally,usingthelemmaaboveandtheresultoftheone-dimensionalcase,themultidimen-\nsional case can be proven as follows. A multidimensional function \ud835\udc53:R\ud835\udc5b!Ris convex\nif and only if for all x,y2R\ud835\udc5b\ud835\udc54\u00b9\ud835\udc67\u00badef=\ud835\udc53\u00b9\ud835\udc67x\u00b8\u00b91\u0000\ud835\udc67\u00bay\u00ba, where\ud835\udc672\u00bb0,1\u00bc, is convex. Ac-\ncording to the one-dimensional case, this holds if and only if \ud835\udc5400=\u00b9x\u0000y\u00ba>H\u00b9x\u0000y\u00ba\u00150\n(Hdef=r2\ud835\udc53) for all x,y2R\ud835\udc5b, which is equivalent to H\u00170per the definition of positive\nsemidefinite matrices.\n12.2.3Constraints\nOneofthenicepropertiesofconvexoptimizationisthatitallowsustohandleconstraintsef-\nficiently. Thatis,itallowsustosolve constrainedoptimization problemsoftheform:\nminimize\nx\ud835\udc53\u00b9x\u00ba\nsubject to\ud835\udc50\ud835\udc56\u00b9x\u00ba\u00140for all\ud835\udc562f1,...,\ud835\udc5bg,(12.2.16)\nwhere\ud835\udc53istheobjectiveandthefunctions \ud835\udc50\ud835\udc56areconstraintfunctions. Toseewhatthisdoes\nconsider the case where \ud835\udc501\u00b9x\u00ba=kxk2\u00001. In this case the parameters xare constrained to\nthe unit ball. If a second constraint is \ud835\udc502\u00b9x\u00ba=v>x\u00b8\ud835\udc4f, then this corresponds to all xlying\non a half-space. Satisfying both constraints simultaneously amounts to selecting a slice of\na ball.\n480 Optimization Algorithms\nLagrangian\nIn general, solving a constrained optimization problem is difficult. One way of addressing\nit stems from physics with a rather simple intuition. Imagine a ball inside a box. The ball\nwill roll to the place that is lowest and the forces of gravity will be balanced out with the\nforcesthatthesidesoftheboxcanimposeontheball. Inshort,thegradientoftheobjective\nfunction(i.e.,gravity)willbeoffsetbythegradientoftheconstraintfunction(theballneed\nto remain inside the box by virtue of the walls \u201cpushing back\u201d). Note that some constraints\nmay not be active: the walls that are not touched by the ball will not be able to exert any\nforce on the ball.\nSkipping over the derivation of the Lagrangian \ud835\udc3f, the above reasoning can be expressed\nvia the following saddle point optimization problem:\n\ud835\udc3f\u00b9x,\ud835\udefc1,...,\ud835\udefc\ud835\udc5b\u00ba=\ud835\udc53\u00b9x\u00ba\u00b8\ud835\udc5b\u00d5\n\ud835\udc56=1\ud835\udefc\ud835\udc56\ud835\udc50\ud835\udc56\u00b9x\u00bawhere\ud835\udefc\ud835\udc56\u00150. (12.2.17)\nHere the variables \ud835\udefc\ud835\udc56(\ud835\udc56=1,...,\ud835\udc5b) are the so-called Lagrange multipliers that ensure that\nconstraintsareproperlyenforced. Theyarechosenjustlargeenoughtoensurethat \ud835\udc50\ud835\udc56\u00b9x\u00ba\u0014\n0for all\ud835\udc56. For instance, for any xwhere\ud835\udc50\ud835\udc56\u00b9x\u00ba<0naturally, we\u2019d end up picking \ud835\udefc\ud835\udc56=0.\nMoreover, thisisasaddlepointoptimizationproblemwhereonewantsto maximize\ud835\udc3fwith\nrespect to all \ud835\udefc\ud835\udc56and simultaneously minimize it with respect to x. There is a rich body of\nliterature explaining how to arrive at the function \ud835\udc3f\u00b9x,\ud835\udefc1,...,\ud835\udefc\ud835\udc5b\u00ba. For our purposes it is\nsufficient to know that the saddle point of \ud835\udc3fis where the original constrained optimization\nproblem is solved optimally.\nPenalties\nOne way of satisfying constrained optimization problems at least approximately is to adapt\ntheLagrangian \ud835\udc3f. Ratherthansatisfying \ud835\udc50\ud835\udc56\u00b9x\u00ba\u00140wesimplyadd \ud835\udefc\ud835\udc56\ud835\udc50\ud835\udc56\u00b9x\u00batotheobjective\nfunction\ud835\udc53\u00b9\ud835\udc65\u00ba. This ensures that the constraints will not be violated too badly.\nIn fact, we have been using this trick all along. Consider weight decay in Section 3.7 . In it\nweadd\ud835\udf06\n2kwk2totheobjectivefunctiontoensurethat wdoesnotgrowtoolarge.", "mimetype": "text/plain", "start_char_idx": 1093730, "end_char_idx": 1096695, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7ad45b4c-3408-4485-9150-a7a7d1b185ee": {"__data__": {"id_": "7ad45b4c-3408-4485-9150-a7a7d1b185ee", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e1e3c140-a670-4810-b39f-6dd236233009", "node_type": "1", "metadata": {}, "hash": "53c2c450869c639030fcfb7f12978f39ce8547f04005a3a9f7c4f35b592d786c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e33dd020-53f9-41b0-be9d-ab6b01dcc728", "node_type": "1", "metadata": {}, "hash": "10947093352a8ccaebe051466c1790bd1ba68b9bdfb4988b6a07136d3b02190a", "class_name": "RelatedNodeInfo"}}, "text": "For our purposes it is\nsufficient to know that the saddle point of \ud835\udc3fis where the original constrained optimization\nproblem is solved optimally.\nPenalties\nOne way of satisfying constrained optimization problems at least approximately is to adapt\ntheLagrangian \ud835\udc3f. Ratherthansatisfying \ud835\udc50\ud835\udc56\u00b9x\u00ba\u00140wesimplyadd \ud835\udefc\ud835\udc56\ud835\udc50\ud835\udc56\u00b9x\u00batotheobjective\nfunction\ud835\udc53\u00b9\ud835\udc65\u00ba. This ensures that the constraints will not be violated too badly.\nIn fact, we have been using this trick all along. Consider weight decay in Section 3.7 . In it\nweadd\ud835\udf06\n2kwk2totheobjectivefunctiontoensurethat wdoesnotgrowtoolarge. Fromthe\nconstrained optimization point of view we can see that this will ensure that kwk2\u0000\ud835\udc5f2\u00140\nfor some radius \ud835\udc5f. Adjusting the value of \ud835\udf06allows us to vary the size of w.\nIn general, adding penalties is a good way of ensuring approximate constraint satisfaction.\nIn practice this turns out to be much more robust than exact satisfaction. Furthermore, for\nnonconvex problems many of the properties that make the exact approach so appealing in\nthe convex case (e.g., optimality) no longer hold.\nProjections\nAn alternative strategy for satisfying constraints is projections. Again, we encountered\nthem before, e.g., when dealing with gradient clipping in Section 9.5 . There we ensured\n481 Convexity\nthat a gradient has length bounded by \ud835\udf03via\ng g\u0001min\u00b91,\ud835\udf03\u009dkgk\u00ba. (12.2.18)\nThisturnsout tobe a projection ofgontotheball ofradius \ud835\udf03. More generally, aprojection\non a convex setXis defined as\nProjX\u00b9x\u00ba=argmin\nx02Xkx\u0000x0k, (12.2.19)\nwhich is the closest point in Xtox.\ntFig. 12.2.4 Convex Projections.\nThe mathematical definition of projections may sound a bit abstract. Fig. 12.2.4 explains it\nsomewhatmoreclearly. Initwehavetwoconvexsets,acircleandadiamond. Pointsinside\nboth sets (yellow) remain unchanged during projections. Points outside both sets (black)\nare projected to the points inside the sets (red) that are closet to the original points (black).\nWhile for\u21132balls this leaves the direction unchanged, this need not be the case in general,\nas can be seen in the case of the diamond.\nOne of the uses for convex projections is to compute sparse weight vectors. In this case we\nproject weight vectors onto an \u21131ball, which is a generalized version of the diamond case\ninFig. 12.2.4 .\n12.2.4Summary\nIn the context of deep learning the main purpose of convex functions is to motivate opti-\nmization algorithms and help us understand them in detail. In the following we will see\nhow gradient descent and stochastic gradient descent can be derived accordingly.\n\u000fIntersections of convex sets are convex. Unions are not.\n\u000fTheexpectationofaconvexfunctionisnolessthantheconvexfunctionofanexpectation\n(Jensen\u2019s inequality).\n\u000fA twice-differentiable function is convex if and only if its Hessian (a matrix of second\nderivatives) is positive semidefinite.\n\u000fConvex constraints can be added via the Lagrangian. In practice we may simply add\nthem with a penalty to the objective function.\n\u000fProjections map to points in the convex set closest to the original points.\n482 Optimization Algorithms\n16712.2.5Exercises\n1.Assume that we want to verify convexity of a set by drawing all lines between points\nwithin the set and checking whether the lines are contained.\n1.Prove that it is sufficient to check only the points on the boundary.\n2.Prove that it is sufficient to check only the vertices of the set.\n2.Denote byB\ud835\udc5d\u00bb\ud835\udc5f\u00bcdef=fxjx2R\ud835\udc51andkxk\ud835\udc5d\u0014\ud835\udc5fgthe ball of radius \ud835\udc5fusing the\ud835\udc5d-norm.\nProve thatB\ud835\udc5d\u00bb\ud835\udc5f\u00bcis convex for all \ud835\udc5d\u00151.\n3.Givenconvexfunctions \ud835\udc53and\ud835\udc54,showthat max\u00b9\ud835\udc53,\ud835\udc54\u00baisconvex,too. Provethat min\u00b9\ud835\udc53,\ud835\udc54\u00ba\nis not convex.\n4.Prove that the normalization of the softmax function is convex.", "mimetype": "text/plain", "start_char_idx": 1096128, "end_char_idx": 1099752, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e33dd020-53f9-41b0-be9d-ab6b01dcc728": {"__data__": {"id_": "e33dd020-53f9-41b0-be9d-ab6b01dcc728", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7ad45b4c-3408-4485-9150-a7a7d1b185ee", "node_type": "1", "metadata": {}, "hash": "fada5b0e23e7c544f8eef150efb8e5b0ecdb6a1f27124fab4a1145b2ef7dc29a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "470e2ce7-18db-42e0-a851-42971fc120a6", "node_type": "1", "metadata": {}, "hash": "d08a4a972d69eff7f3d5ee1b034b96040e1a483fa16cc9a94f25a7b46b71f80d", "class_name": "RelatedNodeInfo"}}, "text": "1.Prove that it is sufficient to check only the points on the boundary.\n2.Prove that it is sufficient to check only the vertices of the set.\n2.Denote byB\ud835\udc5d\u00bb\ud835\udc5f\u00bcdef=fxjx2R\ud835\udc51andkxk\ud835\udc5d\u0014\ud835\udc5fgthe ball of radius \ud835\udc5fusing the\ud835\udc5d-norm.\nProve thatB\ud835\udc5d\u00bb\ud835\udc5f\u00bcis convex for all \ud835\udc5d\u00151.\n3.Givenconvexfunctions \ud835\udc53and\ud835\udc54,showthat max\u00b9\ud835\udc53,\ud835\udc54\u00baisconvex,too. Provethat min\u00b9\ud835\udc53,\ud835\udc54\u00ba\nis not convex.\n4.Prove that the normalization of the softmax function is convex. More specifically prove\nthe convexity of \ud835\udc53\u00b9\ud835\udc65\u00ba=log\u00cd\n\ud835\udc56exp\u00b9\ud835\udc65\ud835\udc56\u00ba.\n5.Prove that linear subspaces, i.e., X=fxjWx=bg, are convex sets.\n6.Provethatinthecaseoflinearsubspaceswith b=0theprojectionProjXcanbewritten\nasMxfor some matrix M.\n7.Show that for twice-differentiable convex functions \ud835\udc53we can write \ud835\udc53\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba=\ud835\udc53\u00b9\ud835\udc65\u00ba\u00b8\n\ud835\udf16\ud835\udc530\u00b9\ud835\udc65\u00ba\u00b81\n2\ud835\udf162\ud835\udc5300\u00b9\ud835\udc65\u00b8\ud835\udf09\u00bafor some\ud835\udf092\u00bb0,\ud835\udf16\u00bc.\n8.Given a convex set Xand two vectors xandy, prove that projections never increase\ndistances, i.e.,kx\u0000yk\u0015kProjX\u00b9x\u00ba\u0000ProjX\u00b9y\u00bak.\nDiscussions167.\n12.3GradientDescent\nIn this section we are going to introduce the basic concepts underlying gradient descent .\nAlthough it is rarely used directly in deep learning, an understanding of gradient descent is\nkeytounderstandingstochasticgradientdescentalgorithms. Forinstance,theoptimization\nproblem might diverge due to an overly large learning rate. This phenomenon can already\nbe seen in gradient descent. Likewise, preconditioning is a common technique in gradient\ndescent and carries over to more advanced algorithms. Let\u2019s start with a simple special\ncase.\n12.3.1One-DimensionalGradient Descent\nGradient descent in one dimension is an excellent example to explain why the gradient\ndescent algorithm may reduce the value of the objective function. Consider some con-\ntinuously differentiable real-valued function \ud835\udc53:R!R. Using a Taylor expansion we\n483 Gradient Descent\nobtain\n\ud835\udc53\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba=\ud835\udc53\u00b9\ud835\udc65\u00ba\u00b8\ud835\udf16\ud835\udc530\u00b9\ud835\udc65\u00ba\u00b8O\u00b9\ud835\udf162\u00ba. (12.3.1)\nThat is, in first-order approximation \ud835\udc53\u00b9\ud835\udc65\u00b8\ud835\udf16\u00bais given by the function value \ud835\udc53\u00b9\ud835\udc65\u00baand the\nfirst derivative \ud835\udc530\u00b9\ud835\udc65\u00baat\ud835\udc65. It is not unreasonable to assume that for small \ud835\udf16moving in the\ndirection of the negative gradient will decrease \ud835\udc53. To keep things simple we pick a fixed\nstep size\ud835\udf02> 0and choose\ud835\udf16=\u0000\ud835\udf02\ud835\udc530\u00b9\ud835\udc65\u00ba. Plugging this into the Taylor expansion above we\nget\n\ud835\udc53\u00b9\ud835\udc65\u0000\ud835\udf02\ud835\udc530\u00b9\ud835\udc65\u00ba\u00ba=\ud835\udc53\u00b9\ud835\udc65\u00ba\u0000\ud835\udf02\ud835\udc5302\u00b9\ud835\udc65\u00ba\u00b8O\u00b9\ud835\udf022\ud835\udc5302\u00b9\ud835\udc65\u00ba\u00ba. (12.3.2)\nIfthederivative \ud835\udc530\u00b9\ud835\udc65\u00ba\u22600doesnotvanishwemakeprogresssince \ud835\udf02\ud835\udc5302\u00b9\ud835\udc65\u00ba>0. Moreover,\nwe can always choose \ud835\udf02small enough for the higher-order terms to become irrelevant.\nHence we arrive at\n\ud835\udc53\u00b9\ud835\udc65\u0000\ud835\udf02\ud835\udc530\u00b9\ud835\udc65\u00ba\u00ba\u2a85\ud835\udc53\u00b9\ud835\udc65\u00ba. (12.3.3)\nThis means that, if we use\n\ud835\udc65 \ud835\udc65\u0000\ud835\udf02\ud835\udc530\u00b9\ud835\udc65\u00ba (12.3.4)\ntoiterate\ud835\udc65,thevalueoffunction \ud835\udc53\u00b9\ud835\udc65\u00bamightdecline.", "mimetype": "text/plain", "start_char_idx": 1099340, "end_char_idx": 1101853, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "470e2ce7-18db-42e0-a851-42971fc120a6": {"__data__": {"id_": "470e2ce7-18db-42e0-a851-42971fc120a6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e33dd020-53f9-41b0-be9d-ab6b01dcc728", "node_type": "1", "metadata": {}, "hash": "10947093352a8ccaebe051466c1790bd1ba68b9bdfb4988b6a07136d3b02190a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a8205fb5-3aec-4806-a0bd-e73ae8068fe0", "node_type": "1", "metadata": {}, "hash": "dd4be2ec33aad1bd7096d72d319c65fffd8d6e19fdda21e8fec138051534602c", "class_name": "RelatedNodeInfo"}}, "text": "(12.3.2)\nIfthederivative \ud835\udc530\u00b9\ud835\udc65\u00ba\u22600doesnotvanishwemakeprogresssince \ud835\udf02\ud835\udc5302\u00b9\ud835\udc65\u00ba>0. Moreover,\nwe can always choose \ud835\udf02small enough for the higher-order terms to become irrelevant.\nHence we arrive at\n\ud835\udc53\u00b9\ud835\udc65\u0000\ud835\udf02\ud835\udc530\u00b9\ud835\udc65\u00ba\u00ba\u2a85\ud835\udc53\u00b9\ud835\udc65\u00ba. (12.3.3)\nThis means that, if we use\n\ud835\udc65 \ud835\udc65\u0000\ud835\udf02\ud835\udc530\u00b9\ud835\udc65\u00ba (12.3.4)\ntoiterate\ud835\udc65,thevalueoffunction \ud835\udc53\u00b9\ud835\udc65\u00bamightdecline. Therefore,ingradientdescentwefirst\nchoose an initial value \ud835\udc65and a constant \ud835\udf02 > 0and then use them to continuously iterate \ud835\udc65\nuntilthestopconditionisreached,forexample,whenthemagnitudeofthegradient j\ud835\udc530\u00b9\ud835\udc65\u00baj\nis small enough or the number of iterations has reached a certain value.\nFor simplicity we choose the objective function \ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc652to illustrate how to implement\ngradient descent. Although we know that \ud835\udc65=0is the solution to minimize \ud835\udc53\u00b9\ud835\udc65\u00ba, we still\nuse this simple function to observe how \ud835\udc65changes.\n%matplotlib inline\nimport numpy asnp\nimport torch\nfrom d2l import torch asd2l\ndef f(x): # Objective function\nreturn x**2\ndef f_grad (x): # Gradient (derivative) of the objective function\nreturn 2*x\nNext, we use \ud835\udc65=10as the initial value and assume \ud835\udf02=0.2. Using gradient descent to\niterate\ud835\udc65for 10 times we can see that, eventually, the value of \ud835\udc65approaches the optimal\nsolution.\ndef gd(eta, f_grad):\nx=10.0\nresults =[x]\n(continues on next page)\n484 Optimization Algorithms\n(continued from previous page)\nfor iinrange (10):\nx-=eta *f_grad(x)\nresults .append( float (x))\nprint (f'epoch 10, x: {x:f}')\nreturn results\nresults =gd(0.2, f_grad)\nepoch 10, x: 0.060466\nThe progress of optimizing over \ud835\udc65can be plotted as follows.\ndef show_trace (results, f):\nn=max(abs(min(results)), abs(max(results)))\nf_line =torch .arange( -n, n, 0.01 )\nd2l.set_figsize()\nd2l.plot([f_line, results], [[f(x) for xinf_line], [\nf(x) for xinresults]], 'x','f(x) ', fmts =['-','-o'])\nshow_trace(results, f)\nLearning Rate\nThelearningrate \ud835\udf02canbesetbythealgorithmdesigner. Ifweusealearningratethatistoo\nsmall, it will cause \ud835\udc65to update very slowly, requiring more iterations to get a better solu-\ntion. To show what happens in such a case, consider the progress in the same optimization\nproblem for \ud835\udf02=0.05. As we can see, even after 10 steps we are still very far from the\noptimal solution.\nshow_trace(gd( 0.05 , f_grad), f)\nepoch 10, x: 3.486784\nConversely, if we use an excessively high learning rate, j\ud835\udf02\ud835\udc530\u00b9\ud835\udc65\u00bajmight be too large for\nthe first-order Taylor expansion formula. That is, the term O\u00b9\ud835\udf022\ud835\udc5302\u00b9\ud835\udc65\u00ba\u00bain(12.3.2 )might\n485 Gradient Descent\nbecome significant. In this case, we cannot guarantee that the iteration of \ud835\udc65will be able to\nlowerthevalueof \ud835\udc53\u00b9\ud835\udc65\u00ba. Forexample,whenwesetthelearningrateto \ud835\udf02=1.1,\ud835\udc65overshoots\nthe optimal solution \ud835\udc65=0and gradually diverges.\nshow_trace(gd( 1.1, f_grad), f)\nepoch 10, x: 61.917364\nLocalMinima\nTo illustrate what happens for nonconvex functions consider the case of \ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc65\u0001cos\u00b9\ud835\udc50\ud835\udc65\u00ba\nfor some constant \ud835\udc50. This function has infinitely many local minima.", "mimetype": "text/plain", "start_char_idx": 1101543, "end_char_idx": 1104404, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a8205fb5-3aec-4806-a0bd-e73ae8068fe0": {"__data__": {"id_": "a8205fb5-3aec-4806-a0bd-e73ae8068fe0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "470e2ce7-18db-42e0-a851-42971fc120a6", "node_type": "1", "metadata": {}, "hash": "d08a4a972d69eff7f3d5ee1b034b96040e1a483fa16cc9a94f25a7b46b71f80d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "98ccc000-2938-4df0-a1a1-5f494889d456", "node_type": "1", "metadata": {}, "hash": "4b741dc26c313d630c93892d393aab0ace2f19edfb8f3b85034e41f78817964c", "class_name": "RelatedNodeInfo"}}, "text": "That is, the term O\u00b9\ud835\udf022\ud835\udc5302\u00b9\ud835\udc65\u00ba\u00bain(12.3.2 )might\n485 Gradient Descent\nbecome significant. In this case, we cannot guarantee that the iteration of \ud835\udc65will be able to\nlowerthevalueof \ud835\udc53\u00b9\ud835\udc65\u00ba. Forexample,whenwesetthelearningrateto \ud835\udf02=1.1,\ud835\udc65overshoots\nthe optimal solution \ud835\udc65=0and gradually diverges.\nshow_trace(gd( 1.1, f_grad), f)\nepoch 10, x: 61.917364\nLocalMinima\nTo illustrate what happens for nonconvex functions consider the case of \ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc65\u0001cos\u00b9\ud835\udc50\ud835\udc65\u00ba\nfor some constant \ud835\udc50. This function has infinitely many local minima. Depending on our\nchoice of the learning rate and depending on how well conditioned the problem is, we may\nend up with one of many solutions. The example below illustrates how an (unrealistically)\nhigh learning rate will lead to a poor local minimum.\nc=torch .tensor( 0.15 *np.pi)\ndef f(x): # Objective function\nreturn x*torch .cos(c *x)\ndef f_grad (x): # Gradient of the objective function\nreturn torch .cos(c *x)-c*x*torch .sin(c *x)\nshow_trace(gd( 2, f_grad), f)\n486 Optimization Algorithms\nepoch 10, x: -1.528166\n12.3.2MultivariateGradient Descent\nNowthatwehaveabetterintuitionoftheunivariatecase, let\u2019sconsiderthesituationwhere\nx=\u00bb\ud835\udc651,\ud835\udc652,...,\ud835\udc65\ud835\udc51\u00bc>. That is, the objective function \ud835\udc53:R\ud835\udc51!Rmaps vectors into\nscalars. Correspondingly its gradient is multivariate, too. It is a vector consisting of \ud835\udc51\npartial derivatives:\nr\ud835\udc53\u00b9x\u00ba=\u0014\ud835\udf15\ud835\udc53\u00b9x\u00ba\n\ud835\udf15\ud835\udc651,\ud835\udf15\ud835\udc53\u00b9x\u00ba\n\ud835\udf15\ud835\udc652,...,\ud835\udf15\ud835\udc53\u00b9x\u00ba\n\ud835\udf15\ud835\udc65\ud835\udc51\u0015>\n. (12.3.5)\nEach partial derivative element \ud835\udf15\ud835\udc53\u00b9x\u00ba\u009d\ud835\udf15\ud835\udc65\ud835\udc56in the gradient indicates the rate of change of\n\ud835\udc53atxwith respect to the input \ud835\udc65\ud835\udc56. As before in the univariate case we can use the cor-\nresponding Taylor approximation for multivariate functions to get some idea of what we\nshould do. In particular, we have that\n\ud835\udc53\u00b9x\u00b8\ud835\udf50\u00ba=\ud835\udc53\u00b9x\u00ba\u00b8\ud835\udf50>r\ud835\udc53\u00b9x\u00ba\u00b8O\u00b9k \ud835\udf50k2\u00ba. (12.3.6)\nInotherwords,uptosecond-ordertermsin \ud835\udf50thedirectionofsteepestdescentisgivenbythe\nnegative gradient\u0000r\ud835\udc53\u00b9x\u00ba. Choosing a suitable learning rate \ud835\udf02> 0yields the prototypical\ngradient descent algorithm:\nx x\u0000\ud835\udf02r\ud835\udc53\u00b9x\u00ba. (12.3.7)\nTo see how the algorithm behaves in practice let\u2019s construct an objective function \ud835\udc53\u00b9x\u00ba=\n\ud835\udc652\n1\u00b82\ud835\udc652\n2with a two-dimensional vector x=\u00bb\ud835\udc651,\ud835\udc652\u00bc>as input and a scalar as output. The\ngradient is given by r\ud835\udc53\u00b9x\u00ba=\u00bb2\ud835\udc651,4\ud835\udc652\u00bc>. We will observe the trajectory of xby gradient\ndescent from the initial position \u00bb\u00005,\u00002\u00bc.\nTobeginwith,weneedtwomorehelperfunctions. Thefirstusesanupdatefunctionandap-\npliesit20timestotheinitialvalue. Thesecondhelpervisualizesthetrajectoryof x.\ndef train_2d (trainer, steps =20, f_grad =None ): #@save\n\"\"\"Optimize a 2D objective function with a customized trainer.\"\"\"", "mimetype": "text/plain", "start_char_idx": 1103896, "end_char_idx": 1106416, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "98ccc000-2938-4df0-a1a1-5f494889d456": {"__data__": {"id_": "98ccc000-2938-4df0-a1a1-5f494889d456", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a8205fb5-3aec-4806-a0bd-e73ae8068fe0", "node_type": "1", "metadata": {}, "hash": "dd4be2ec33aad1bd7096d72d319c65fffd8d6e19fdda21e8fec138051534602c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "34765d87-3450-479c-85a2-b889b6002968", "node_type": "1", "metadata": {}, "hash": "4c42b3f7417e84c96e8201c40a0b39bfade99805907ec20d3989fc8d57cebe78", "class_name": "RelatedNodeInfo"}}, "text": "The\ngradient is given by r\ud835\udc53\u00b9x\u00ba=\u00bb2\ud835\udc651,4\ud835\udc652\u00bc>. We will observe the trajectory of xby gradient\ndescent from the initial position \u00bb\u00005,\u00002\u00bc.\nTobeginwith,weneedtwomorehelperfunctions. Thefirstusesanupdatefunctionandap-\npliesit20timestotheinitialvalue. Thesecondhelpervisualizesthetrajectoryof x.\ndef train_2d (trainer, steps =20, f_grad =None ): #@save\n\"\"\"Optimize a 2D objective function with a customized trainer.\"\"\"\n# `s1` and `s2` are internal state variables that will be used in Momentum,\n\u21a9!adagrad, RMSProp\n(continues on next page)\n487 Gradient Descent\n(continued from previous page)\nx1, x2, s1, s2 =-5,-2,0,0\nresults =[(x1, x2)]\nfor iinrange (steps):\niff_grad:\nx1, x2, s1, s2 =trainer(x1, x2, s1, s2, f_grad)\nelse :\nx1, x2, s1, s2 =trainer(x1, x2, s1, s2)\nresults .append((x1, x2))\nprint (f'epoch {i+1}, x1: {float (x1) :f}, x2: {float (x2) :f}')\nreturn results\ndef show_trace_2d (f, results): #@save\n\"\"\"Show the trace of 2D variables during optimization.\"\"\"\nd2l.set_figsize()\nd2l.plt.plot( *zip(*results), '-o', color ='#ff7f0e ')\nx1, x2 =torch .meshgrid(torch .arange( -5.5,1.0,0.1),\ntorch .arange( -3.0,1.0,0.1), indexing ='ij')\nd2l.plt.contour(x1, x2, f(x1, x2), colors ='#1f77b4 ')\nd2l.plt.xlabel( 'x1')\nd2l.plt.ylabel( 'x2')\nNext, we observe the trajectory of the optimization variable xfor learning rate \ud835\udf02=0.1.\nWe can see that after 20 steps the value of xapproaches its minimum at \u00bb0,0\u00bc. Progress is\nfairly well-behaved albeit rather slow.\ndef f_2d (x1, x2): # Objective function\nreturn x1**2+2*x2**2\ndef f_2d_grad (x1, x2): # Gradient of the objective function\nreturn (2*x1, 4*x2)\ndef gd_2d (x1, x2, s1, s2, f_grad):\ng1, g2 =f_grad(x1, x2)\nreturn (x1 -eta *g1, x2 -eta *g2, 0,0)\neta =0.1\nshow_trace_2d(f_2d, train_2d(gd_2d, f_grad =f_2d_grad))\nepoch 20, x1: -0.057646 , x2: -0.000073\n\n488 Optimization Algorithms\n12.3.3AdaptiveMethods\nAs we could see in Section 12.3.1 , getting the learning rate \ud835\udf02\u201cjust right\u201d is tricky. If we\npick it too small, we make little progress. If we pick it too large, the solution oscillates and\nin the worst case it might even diverge. What if we could determine \ud835\udf02automatically or get\nridofhavingtoselectalearningrateatall? Second-ordermethodsthatlooknotonlyatthe\nvalue and gradient of the objective function but also at its curvature can help in this case.\nWhile these methods cannot be applied to deep learning directly due to the computational\ncost, they provide useful intuition into how to design advanced optimization algorithms\nthat mimic many of the desirable properties of the algorithms outlined below.\nNewton\u2019sMethod\nReviewingtheTaylorexpansionofsomefunction \ud835\udc53:R\ud835\udc51!Rthereisnoneedtostopafter\nthe first term. In fact, we can write it as\n\ud835\udc53\u00b9x\u00b8\ud835\udf50\u00ba=\ud835\udc53\u00b9x\u00ba\u00b8\ud835\udf50>r\ud835\udc53\u00b9x\u00ba\u00b81\n2\ud835\udf50>r2\ud835\udc53\u00b9x\u00ba\ud835\udf50\u00b8O\u00b9k \ud835\udf50k3\u00ba.", "mimetype": "text/plain", "start_char_idx": 1106007, "end_char_idx": 1108732, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "34765d87-3450-479c-85a2-b889b6002968": {"__data__": {"id_": "34765d87-3450-479c-85a2-b889b6002968", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "98ccc000-2938-4df0-a1a1-5f494889d456", "node_type": "1", "metadata": {}, "hash": "4b741dc26c313d630c93892d393aab0ace2f19edfb8f3b85034e41f78817964c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2bbb3ca2-5d94-4a20-9322-96f471a966cf", "node_type": "1", "metadata": {}, "hash": "dcc13aa6d84f54eda28549ae68101be59e2cb2b5553cff20beef89aab64590c2", "class_name": "RelatedNodeInfo"}}, "text": "Second-ordermethodsthatlooknotonlyatthe\nvalue and gradient of the objective function but also at its curvature can help in this case.\nWhile these methods cannot be applied to deep learning directly due to the computational\ncost, they provide useful intuition into how to design advanced optimization algorithms\nthat mimic many of the desirable properties of the algorithms outlined below.\nNewton\u2019sMethod\nReviewingtheTaylorexpansionofsomefunction \ud835\udc53:R\ud835\udc51!Rthereisnoneedtostopafter\nthe first term. In fact, we can write it as\n\ud835\udc53\u00b9x\u00b8\ud835\udf50\u00ba=\ud835\udc53\u00b9x\u00ba\u00b8\ud835\udf50>r\ud835\udc53\u00b9x\u00ba\u00b81\n2\ud835\udf50>r2\ud835\udc53\u00b9x\u00ba\ud835\udf50\u00b8O\u00b9k \ud835\udf50k3\u00ba. (12.3.8)\nTo avoid cumbersome notation we define Hdef=r2\ud835\udc53\u00b9x\u00bato be the Hessian of \ud835\udc53, which is\na\ud835\udc51\u0002\ud835\udc51matrix. For small \ud835\udc51and simple problems His easy to compute. For deep neural\nnetworks, ontheotherhand, Hmaybeprohibitivelylarge,duetothecostofstoring O\u00b9\ud835\udc512\u00ba\nentries. Furthermore it may be too expensive to compute via backpropagation. For now\nlet\u2019s ignore such considerations and look at what algorithm we would get.\nAfter all, the minimum of \ud835\udc53satisfiesr\ud835\udc53=0. Following calculus rules in Section 2.4.3 , by\ntaking derivatives of (12.3.8 )with regard to \ud835\udf50and ignoring higher-order terms we arrive\nat\nr\ud835\udc53\u00b9x\u00ba\u00b8H\ud835\udf50=0and hence \ud835\udf50=\u0000H\u00001r\ud835\udc53\u00b9x\u00ba. (12.3.9)\nThat is, we need to invert the Hessian Has part of the optimization problem.\nAs a simple example, for \ud835\udc53\u00b9\ud835\udc65\u00ba=1\n2\ud835\udc652we haver\ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc65andH=1. Hence for any \ud835\udc65\nwe obtain\ud835\udf16=\u0000\ud835\udc65. In other words, a singlestep is sufficient to converge perfectly without\nthe need for any adjustment! Alas, we got a bit lucky here: the Taylor expansion was exact\nsince\ud835\udc53\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba=1\n2\ud835\udc652\u00b8\ud835\udf16\ud835\udc65\u00b81\n2\ud835\udf162.\nLet\u2019s see what happens in other problems. Given a convex hyperbolic cosine function\n\ud835\udc53\u00b9\ud835\udc65\u00ba=cosh\u00b9\ud835\udc50\ud835\udc65\u00bafor some constant \ud835\udc50, we can see that the global minimum at \ud835\udc65=0is\nreached after a few iterations.\nc=torch .tensor( 0.5)\ndef f(x): # Objective function\nreturn torch .cosh(c *x)\ndef f_grad (x): # Gradient of the objective function\nreturn c*torch .sinh(c *x)\n(continues on next page)\n489 Gradient Descent\n(continued from previous page)\ndef f_hess (x): # Hessian of the objective function\nreturn c**2*torch .cosh(c *x)\ndef newton (eta =1):\nx=10.0\nresults =[x]\nfor iinrange (10):\nx-=eta *f_grad(x) /f_hess(x)\nresults .append( float (x))\nprint ('epoch 10, x: ', x)\nreturn results\nshow_trace(newton(), f)\nepoch 10, x: tensor( 0.)\nNow let\u2019s consider a nonconvex function, such as \ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc65cos\u00b9\ud835\udc50\ud835\udc65\u00bafor some constant \ud835\udc50.\nAfterall,notethatinNewton\u2019smethodweendupdividingbytheHessian. Thismeansthat\nif the second derivative is negative we may walk into the direction of increasing the value\nof\ud835\udc53. That is a fatal flaw of the algorithm. Let\u2019s see what happens in practice.", "mimetype": "text/plain", "start_char_idx": 1108169, "end_char_idx": 1110772, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2bbb3ca2-5d94-4a20-9322-96f471a966cf": {"__data__": {"id_": "2bbb3ca2-5d94-4a20-9322-96f471a966cf", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "34765d87-3450-479c-85a2-b889b6002968", "node_type": "1", "metadata": {}, "hash": "4c42b3f7417e84c96e8201c40a0b39bfade99805907ec20d3989fc8d57cebe78", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "acf05399-5715-46b2-91f2-8a73866e10ef", "node_type": "1", "metadata": {}, "hash": "4e896818a2e9f4fe9c0e4aa9c1881b45efda070ca8b81d9952330ade7e70b88a", "class_name": "RelatedNodeInfo"}}, "text": "Now let\u2019s consider a nonconvex function, such as \ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc65cos\u00b9\ud835\udc50\ud835\udc65\u00bafor some constant \ud835\udc50.\nAfterall,notethatinNewton\u2019smethodweendupdividingbytheHessian. Thismeansthat\nif the second derivative is negative we may walk into the direction of increasing the value\nof\ud835\udc53. That is a fatal flaw of the algorithm. Let\u2019s see what happens in practice.\nc=torch .tensor( 0.15 *np.pi)\ndef f(x): # Objective function\nreturn x*torch .cos(c *x)\ndef f_grad (x): # Gradient of the objective function\nreturn torch .cos(c *x)-c*x*torch .sin(c *x)\ndef f_hess (x): # Hessian of the objective function\nreturn -2*c*torch .sin(c *x)-x*c**2*torch .cos(c *x)\nshow_trace(newton(), f)\nepoch 10, x: tensor( 26.8341 )\nThis went spectacularly wrong. How can we fix it? One way would be to \u201cfix\u201d the Hessian\nby taking its absolute value instead. Another strategy is to bring back the learning rate.\n490 Optimization Algorithms\nThis seems to defeat the purpose, but not quite. Having second-order information allows\nus to be cautious whenever the curvature is large and to take longer steps whenever the\nobjective function is flatter. Let\u2019s see how this works with a slightly smaller learning rate,\nsay\ud835\udf02=0.5. As we can see, we have quite an efficient algorithm.\nshow_trace(newton( 0.5), f)\nepoch 10, x: tensor( 7.2699 )\nConvergenceAnalysis\nWeonlyanalyzetheconvergencerateofNewton\u2019smethodforsomeconvexandthreetimes\ndifferentiable objective function \ud835\udc53, where the second derivative is nonzero, i.e., \ud835\udc5300>0.\nThe multivariate proof is a straightforward extension of the one-dimensional argument be-\nlow and omitted since it does not help us much in terms of intuition.\nDenoteby\ud835\udc65\u00b9\ud835\udc58\u00bathevalueof\ud835\udc65atthe\ud835\udc58thiterationandlet \ud835\udc52\u00b9\ud835\udc58\u00badef=\ud835\udc65\u00b9\ud835\udc58\u00ba\u0000\ud835\udc65\u0003bethedistancefrom\noptimality at the \ud835\udc58thiteration. By Taylor expansion we have that the condition \ud835\udc530\u00b9\ud835\udc65\u0003\u00ba=0\ncan be written as\n0=\ud835\udc530\u00b9\ud835\udc65\u00b9\ud835\udc58\u00ba\u0000\ud835\udc52\u00b9\ud835\udc58\u00ba\u00ba=\ud835\udc530\u00b9\ud835\udc65\u00b9\ud835\udc58\u00ba\u00ba\u0000\ud835\udc52\u00b9\ud835\udc58\u00ba\ud835\udc5300\u00b9\ud835\udc65\u00b9\ud835\udc58\u00ba\u00ba\u00b81\n2\u00b9\ud835\udc52\u00b9\ud835\udc58\u00ba\u00ba2\ud835\udc53000\u00b9\ud835\udf09\u00b9\ud835\udc58\u00ba\u00ba, (12.3.10)\nwhichholdsforsome \ud835\udf09\u00b9\ud835\udc58\u00ba2\u00bb\ud835\udc65\u00b9\ud835\udc58\u00ba\u0000\ud835\udc52\u00b9\ud835\udc58\u00ba,\ud835\udc65\u00b9\ud835\udc58\u00ba\u00bc. Dividingtheaboveexpansionby \ud835\udc5300\u00b9\ud835\udc65\u00b9\ud835\udc58\u00ba\u00ba\n491 Gradient Descent\nyields\n\ud835\udc52\u00b9\ud835\udc58\u00ba\u0000\ud835\udc530\u00b9\ud835\udc65\u00b9\ud835\udc58\u00ba\u00ba\n\ud835\udc5300\u00b9\ud835\udc65\u00b9\ud835\udc58\u00ba\u00ba=1\n2\u00b9\ud835\udc52\u00b9\ud835\udc58\u00ba\u00ba2\ud835\udc53000\u00b9\ud835\udf09\u00b9\ud835\udc58\u00ba\u00ba\n\ud835\udc5300\u00b9\ud835\udc65\u00b9\ud835\udc58\u00ba\u00ba. (12.3.11)\nRecall that we have the update \ud835\udc65\u00b9\ud835\udc58\u00b81\u00ba=\ud835\udc65\u00b9\ud835\udc58\u00ba\u0000\ud835\udc530\u00b9\ud835\udc65\u00b9\ud835\udc58\u00ba\u00ba\u009d\ud835\udc5300\u00b9\ud835\udc65\u00b9\ud835\udc58\u00ba\u00ba. Plugging in this update\nequation and taking the absolute value of both sides, we have\n\f\f\f\ud835\udc52\u00b9\ud835\udc58\u00b81\u00ba\f\f\f=1\n2\u00b9\ud835\udc52\u00b9\ud835\udc58\u00ba\u00ba2\f\f\ud835\udc53000\u00b9\ud835\udf09\u00b9\ud835\udc58\u00ba\u00ba\f\f\n\ud835\udc5300\u00b9\ud835\udc65\u00b9\ud835\udc58\u00ba\u00ba.", "mimetype": "text/plain", "start_char_idx": 1110442, "end_char_idx": 1112688, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "acf05399-5715-46b2-91f2-8a73866e10ef": {"__data__": {"id_": "acf05399-5715-46b2-91f2-8a73866e10ef", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2bbb3ca2-5d94-4a20-9322-96f471a966cf", "node_type": "1", "metadata": {}, "hash": "dcc13aa6d84f54eda28549ae68101be59e2cb2b5553cff20beef89aab64590c2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9e60ac1e-2bd1-4861-9bde-7b805dd113eb", "node_type": "1", "metadata": {}, "hash": "fa5a808d2b184c54e28bc2b533f83fe64a02c0316d312b1584159d5372530ef4", "class_name": "RelatedNodeInfo"}}, "text": "(12.3.11)\nRecall that we have the update \ud835\udc65\u00b9\ud835\udc58\u00b81\u00ba=\ud835\udc65\u00b9\ud835\udc58\u00ba\u0000\ud835\udc530\u00b9\ud835\udc65\u00b9\ud835\udc58\u00ba\u00ba\u009d\ud835\udc5300\u00b9\ud835\udc65\u00b9\ud835\udc58\u00ba\u00ba. Plugging in this update\nequation and taking the absolute value of both sides, we have\n\f\f\f\ud835\udc52\u00b9\ud835\udc58\u00b81\u00ba\f\f\f=1\n2\u00b9\ud835\udc52\u00b9\ud835\udc58\u00ba\u00ba2\f\f\ud835\udc53000\u00b9\ud835\udf09\u00b9\ud835\udc58\u00ba\u00ba\f\f\n\ud835\udc5300\u00b9\ud835\udc65\u00b9\ud835\udc58\u00ba\u00ba. (12.3.12)\nConsequently, whenever we are in a region of bounded\f\f\ud835\udc53000\u00b9\ud835\udf09\u00b9\ud835\udc58\u00ba\u00ba\f\f\u009d\u00b92\ud835\udc5300\u00b9\ud835\udc65\u00b9\ud835\udc58\u00ba\u00ba\u00ba\u0014\ud835\udc50, we\nhave a quadratically decreasing error\n\f\f\f\ud835\udc52\u00b9\ud835\udc58\u00b81\u00ba\f\f\f\u0014\ud835\udc50\u00b9\ud835\udc52\u00b9\ud835\udc58\u00ba\u00ba2. (12.3.13)\nAsanaside,optimizationresearcherscallthis linearconvergence,whereasaconditionsuch\nas\f\f\ud835\udc52\u00b9\ud835\udc58\u00b81\u00ba\f\f\u0014\ud835\udefc\f\f\ud835\udc52\u00b9\ud835\udc58\u00ba\f\fwouldbecalleda constant rateofconvergence. Notethatthisanalysis\ncomes with a number of caveats. First, we do not really have muchof a guarantee when we\nwill reach the region of rapid convergence. Instead, we only know that once we reach it,\nconvergence will be very quick. Second, this analysis requires that \ud835\udc53is well-behaved up to\nhigher-order derivatives. It comes down to ensuring that \ud835\udc53does not have any \u201csurprising\u201d\nproperties in terms of how it might change its values.\nPreconditioning\nQuite unsurprisingly computing and storing the full Hessian is very expensive. It is thus\ndesirable to find alternatives. One way to improve matters is preconditioning . It avoids\ncomputing the Hessian in its entirety but only computes the diagonal entries. This leads to\nupdate algorithms of the form\nx x\u0000\ud835\udf02diag\u00b9H\u00ba\u00001r\ud835\udc53\u00b9x\u00ba. (12.3.14)\nWhile this is not quite as good as the full Newton\u2019s method, it is still much better than not\nusing it. To see why this might be a good idea consider a situation where one variable\ndenotes height in millimeters and the other one denotes height in kilometers. Assuming\nthatforboththenaturalscaleisinmeters,wehaveaterriblemismatchinparametrizations.\nFortunately, using preconditioning removes this. Effectively preconditioning with gradient\ndescentamountstoselectingadifferentlearningrateforeachvariable(coordinateofvector\nx). Aswewillseelater,preconditioningdrivessomeoftheinnovationinstochasticgradient\ndescent optimization algorithms.\nGradientDescent with Line Search\nOne of the key problems in gradient descent is that we might overshoot the goal or make\ninsufficient progress. A simple fix for the problem is to use line search in conjunction with\ngradient descent. That is, we use the direction given by r\ud835\udc53\u00b9x\u00baand then perform binary\nsearch as to which learning rate \ud835\udf02minimizes\ud835\udc53\u00b9x\u0000\ud835\udf02r\ud835\udc53\u00b9x\u00ba\u00ba.\n492 Optimization Algorithms\n168This algorithm converges rapidly (for an analysis and proof see e.g., Boyd and Vanden-\nberghe ( 2004)). However, for the purpose of deep learning this is not quite so feasible,\nsince each step of the line search would require us to evaluate the objective function on the\nentire dataset. This is way too costly to accomplish.\n12.3.4Summary\n\u000fLearningratesmatter. Toolargeandwediverge,toosmallandwedonotmakeprogress.\n\u000fGradient descent can get stuck in local minima.\n\u000fIn high dimensions adjusting the learning rate is complicated.\n\u000fPreconditioning can help with scale adjustment.\n\u000fNewton\u2019s method is a lot faster once it has started working properly in convex problems.\n\u000fBeware of using Newton\u2019s method without any adjustments for nonconvex problems.\n12.3.5Exercises\n1.Experiment with different learning rates and objective functions for gradient descent.\n2.Implement line search to minimize a convex function in the interval \u00bb\ud835\udc4e,\ud835\udc4f\u00bc.", "mimetype": "text/plain", "start_char_idx": 1112481, "end_char_idx": 1115737, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9e60ac1e-2bd1-4861-9bde-7b805dd113eb": {"__data__": {"id_": "9e60ac1e-2bd1-4861-9bde-7b805dd113eb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "acf05399-5715-46b2-91f2-8a73866e10ef", "node_type": "1", "metadata": {}, "hash": "4e896818a2e9f4fe9c0e4aa9c1881b45efda070ca8b81d9952330ade7e70b88a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2c374338-aff8-4340-9989-461cd3772603", "node_type": "1", "metadata": {}, "hash": "bfdb3a7c0f18f32ae8cf4f83d78f25c4bd4b2321eca703b693df2c168fb170a2", "class_name": "RelatedNodeInfo"}}, "text": "However, for the purpose of deep learning this is not quite so feasible,\nsince each step of the line search would require us to evaluate the objective function on the\nentire dataset. This is way too costly to accomplish.\n12.3.4Summary\n\u000fLearningratesmatter. Toolargeandwediverge,toosmallandwedonotmakeprogress.\n\u000fGradient descent can get stuck in local minima.\n\u000fIn high dimensions adjusting the learning rate is complicated.\n\u000fPreconditioning can help with scale adjustment.\n\u000fNewton\u2019s method is a lot faster once it has started working properly in convex problems.\n\u000fBeware of using Newton\u2019s method without any adjustments for nonconvex problems.\n12.3.5Exercises\n1.Experiment with different learning rates and objective functions for gradient descent.\n2.Implement line search to minimize a convex function in the interval \u00bb\ud835\udc4e,\ud835\udc4f\u00bc.\n1.Do you need derivatives for binary search, i.e., to decide whether to pick \u00bb\ud835\udc4e,\u00b9\ud835\udc4e\u00b8\n\ud835\udc4f\u00ba\u009d2\u00bcor\u00bb\u00b9\ud835\udc4e\u00b8\ud835\udc4f\u00ba\u009d2,\ud835\udc4f\u00bc.\n2.How rapid is the rate of convergence for the algorithm?\n3.Implement the algorithm and apply it to minimizing log\u00b9exp\u00b9\ud835\udc65\u00ba\u00b8exp\u00b9\u00002\ud835\udc65\u00003\u00ba\u00ba.\n3.Design an objective function defined on R2where gradient descent is exceedingly slow.\nHint: scale different coordinates differently.\n4.Implement the lightweight version of Newton\u2019s method using preconditioning:\n1.Use diagonal Hessian as preconditioner.\n2.Use the absolute values of that rather than the actual (possibly signed) values.\n3.Apply this to the problem above.\n5.Apply the algorithm above to a number of objective functions (convex or not). What\nhappens if you rotate coordinates by 45degrees?\nDiscussions168.\n493 Stochastic Gradient Descent\n12.4StochasticGradient Descent\nInearlierchapterswekeptusingstochasticgradientdescentinourtrainingprocedure,how-\never, withoutexplainingwhyitworks. Toshedsomelightonit, wejustdescribedthebasic\nprinciplesofgradientdescentin Section12.3 . Inthissection,wegoontodiscuss stochastic\ngradientdescent in greater detail.\n%matplotlib inline\nimport math\nimport torch\nfrom d2l import torch asd2l\n12.4.1StochasticGradient Updates\nIn deep learning, the objective function is usually the average of the loss functions for each\nexample in the training dataset. Given a training dataset of \ud835\udc5bexamples, we assume that\n\ud835\udc53\ud835\udc56\u00b9x\u00bais the loss function with respect to the training example of index \ud835\udc56, where xis the\nparameter vector. Then we arrive at the objective function\n\ud835\udc53\u00b9x\u00ba=1\n\ud835\udc5b\ud835\udc5b\u00d5\n\ud835\udc56=1\ud835\udc53\ud835\udc56\u00b9x\u00ba. (12.4.1)\nThe gradient of the objective function at xis computed as\nr\ud835\udc53\u00b9x\u00ba=1\n\ud835\udc5b\ud835\udc5b\u00d5\n\ud835\udc56=1r\ud835\udc53\ud835\udc56\u00b9x\u00ba. (12.4.2)\nIf gradient descent is used, the computational cost for each independent variable iteration\nisO\u00b9\ud835\udc5b\u00ba, which grows linearly with \ud835\udc5b. Therefore, when the training dataset is larger, the\ncost of gradient descent for each iteration will be higher.\nStochastic gradient descent (SGD) reduces computational cost at each iteration. At each\niteration of stochastic gradient descent, we uniformly sample an index \ud835\udc562f1,...,\ud835\udc5bgfor\ndata examples at random, and compute the gradient r\ud835\udc53\ud835\udc56\u00b9x\u00bato update x:\nx x\u0000\ud835\udf02r\ud835\udc53\ud835\udc56\u00b9x\u00ba, (12.4.3)\nwhere\ud835\udf02isthelearningrate. Wecanseethatthecomputationalcostforeachiterationdrops\nfromO\u00b9\ud835\udc5b\u00baof the gradient descent to the constant O\u00b91\u00ba. Moreover, we want to empha-\nsize that the stochastic gradient r\ud835\udc53\ud835\udc56\u00b9x\u00bais an unbiased estimate of the full gradient r\ud835\udc53\u00b9x\u00ba\nbecause\nE\ud835\udc56r\ud835\udc53\ud835\udc56\u00b9x\u00ba=1\n\ud835\udc5b\ud835\udc5b\u00d5\n\ud835\udc56=1r\ud835\udc53\ud835\udc56\u00b9x\u00ba=r\ud835\udc53\u00b9x\u00ba. (12.4.4)\nThismeansthat,onaverage,thestochasticgradientisagoodestimateofthegradient.", "mimetype": "text/plain", "start_char_idx": 1114913, "end_char_idx": 1118279, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2c374338-aff8-4340-9989-461cd3772603": {"__data__": {"id_": "2c374338-aff8-4340-9989-461cd3772603", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9e60ac1e-2bd1-4861-9bde-7b805dd113eb", "node_type": "1", "metadata": {}, "hash": "fa5a808d2b184c54e28bc2b533f83fe64a02c0316d312b1584159d5372530ef4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "afd7222d-103e-4394-b970-a3c18b4a5605", "node_type": "1", "metadata": {}, "hash": "dc1c0f5172d8176ea142b542013d693e509f117c932b54b9e624cbd921bd9836", "class_name": "RelatedNodeInfo"}}, "text": "Wecanseethatthecomputationalcostforeachiterationdrops\nfromO\u00b9\ud835\udc5b\u00baof the gradient descent to the constant O\u00b91\u00ba. Moreover, we want to empha-\nsize that the stochastic gradient r\ud835\udc53\ud835\udc56\u00b9x\u00bais an unbiased estimate of the full gradient r\ud835\udc53\u00b9x\u00ba\nbecause\nE\ud835\udc56r\ud835\udc53\ud835\udc56\u00b9x\u00ba=1\n\ud835\udc5b\ud835\udc5b\u00d5\n\ud835\udc56=1r\ud835\udc53\ud835\udc56\u00b9x\u00ba=r\ud835\udc53\u00b9x\u00ba. (12.4.4)\nThismeansthat,onaverage,thestochasticgradientisagoodestimateofthegradient.\nNow, we will compare it with gradient descent by adding random noise with a mean of 0\nand a variance of 1 to the gradient to simulate a stochastic gradient descent.\n494 Optimization Algorithms\ndef f(x1, x2): # Objective function\nreturn x1**2+2*x2**2\ndef f_grad (x1, x2): # Gradient of the objective function\nreturn 2*x1, 4*x2\ndef sgd(x1, x2, s1, s2, f_grad):\ng1, g2 =f_grad(x1, x2)\n# Simulate noisy gradient\ng1+=torch .normal( 0.0,1, (1,)).item()\ng2+=torch .normal( 0.0,1, (1,)).item()\neta_t =eta *lr()\nreturn (x1 -eta_t *g1, x2 -eta_t *g2, 0,0)\ndef constant_lr ():\nreturn 1\neta =0.1\nlr=constant_lr # Constant learning rate\nd2l.show_trace_2d(f, d2l .train_2d(sgd, steps =50, f_grad =f_grad))\nepoch 50, x1: 0.225517 , x2: -0.076646\nAs we can see, the trajectory of the variables in the stochastic gradient descent is much\nmore noisy than the one we observed in gradient descent in Section 12.3 . This is due to\nthe stochastic nature of the gradient. That is, even when we arrive near the minimum,\nwe are still subject to the uncertainty injected by the instantaneous gradient via \ud835\udf02r\ud835\udc53\ud835\udc56\u00b9x\u00ba.\nEven after 50 steps the quality is still not so good. Even worse, it will not improve after\nadditional steps (we encourage you to experiment with a larger number of steps to confirm\nthis). This leaves us with the only alternative: change the learning rate \ud835\udf02. However, if we\npick this too small, we will not make any meaningful progress initially. On the other hand,\nif we pick it too large, we will not get a good solution, as seen above. The only way to\nresolve these conflicting goals is to reduce the learning rate dynamically as optimization\nprogresses.\nThis is also the reason for adding a learning rate function lrinto the sgdstep function. In\n495 Stochastic Gradient Descent\nthe example above any functionality for learning rate scheduling lies dormant as we set the\nassociated lrfunction to be constant.\n12.4.2DynamicLearning Rate\nReplacing\ud835\udf02with a time-dependent learning rate \ud835\udf02\u00b9\ud835\udc61\u00baadds to the complexity of controlling\nconvergence of an optimization algorithm. In particular, we need to figure out how rapidly\n\ud835\udf02should decay. If it is too quick, we will stop optimizing prematurely. If we decrease\nit too slowly, we waste too much time on optimization. The following are a few basic\nstrategies that are used in adjusting \ud835\udf02over time (we will discuss more advanced strategies\nlater):\n\ud835\udf02\u00b9\ud835\udc61\u00ba=\ud835\udf02\ud835\udc56if\ud835\udc61\ud835\udc56\u0014\ud835\udc61\u0014\ud835\udc61\ud835\udc56\u00b81piecewise constant\n\ud835\udf02\u00b9\ud835\udc61\u00ba=\ud835\udf020\u0001\ud835\udc52\u0000\ud835\udf06\ud835\udc61exponential decay\n\ud835\udf02\u00b9\ud835\udc61\u00ba=\ud835\udf020\u0001\u00b9\ud835\udefd\ud835\udc61\u00b81\u00ba\u0000\ud835\udefcpolynomial decay(12.4.5)\nInthefirst piecewiseconstant scenariowedecreasethelearningrate,e.g.,wheneverprogress\nin optimization stalls. This is a common strategy for training deep networks. Alternatively\nwe could decrease it much more aggressively by an exponential decay . Unfortunately this\noften leads to premature stopping before the algorithm has converged. A popular choice is\npolynomial decay with\ud835\udefc=0.5.", "mimetype": "text/plain", "start_char_idx": 1117929, "end_char_idx": 1121148, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "afd7222d-103e-4394-b970-a3c18b4a5605": {"__data__": {"id_": "afd7222d-103e-4394-b970-a3c18b4a5605", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2c374338-aff8-4340-9989-461cd3772603", "node_type": "1", "metadata": {}, "hash": "bfdb3a7c0f18f32ae8cf4f83d78f25c4bd4b2321eca703b693df2c168fb170a2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1a055c74-cb31-4a2a-be35-478b80bc440a", "node_type": "1", "metadata": {}, "hash": "2956c98d41bdb519c5258206b124e3ef5567b46f8bd0697a52de5643a3f833db", "class_name": "RelatedNodeInfo"}}, "text": "This is a common strategy for training deep networks. Alternatively\nwe could decrease it much more aggressively by an exponential decay . Unfortunately this\noften leads to premature stopping before the algorithm has converged. A popular choice is\npolynomial decay with\ud835\udefc=0.5. In the case of convex optimization there are a number of\nproofs that show that this rate is well behaved.\nLet\u2019s see what the exponential decay looks like in practice.\ndef exponential_lr ():\n# Global variable that is defined outside this function and updated inside\nglobal t\nt+=1\nreturn math .exp( -0.1 *t)\nt=1\nlr=exponential_lr\nd2l.show_trace_2d(f, d2l .train_2d(sgd, steps =1000 , f_grad =f_grad))\nepoch 1000 , x1: -0.758829 , x2: -0.115584\nAs expected, the variance in the parameters is significantly reduced. However, this comes\n496 Optimization Algorithms\n169at the expense of failing to converge to the optimal solution x=\u00b90,0\u00ba. Even after 1000\niterationstepsarewearestillveryfarawayfromtheoptimalsolution. Indeed,thealgorithm\nfails to convergeat all. On the other hand, if weuse a polynomialdecaywhere the learning\nrate decays with the inverse square root of the number of steps, convergence gets better\nafter only 50 steps.\ndef polynomial_lr ():\n# Global variable that is defined outside this function and updated inside\nglobal t\nt+=1\nreturn (1+0.1 *t)**(-0.5)\nt=1\nlr=polynomial_lr\nd2l.show_trace_2d(f, d2l .train_2d(sgd, steps =50, f_grad =f_grad))\nepoch 50, x1: 0.144834 , x2: 0.041688\nThereexistmanymorechoicesforhowtosetthelearningrate. Forinstance, wecouldstart\nwith a small rate, then rapidly ramp up and then decrease it again, albeit more slowly. We\ncould even alternate between smaller and larger learning rates. There exists a large variety\nof such schedules. For now let\u2019s focus on learning rate schedules for which a comprehen-\nsive theoretical analysis is possible, i.e., on learning rates in a convex setting. For general\nnonconvexproblemsitis verydifficulttoobtain meaningfulconvergenceguarantees, since\ningeneralminimizing nonlinearnonconvexproblemsisNP hard. Forasurveyseee.g., the\nexcellent lecture notes169of Tibshirani 2015.\n12.4.3ConvergenceAnalysisforConvexObjectives\nThe following convergence analysis of stochastic gradient descent for convex objective\nfunctions is optional and primarily serves to convey more intuition about the problem. We\nlimit ourselves to one of the simplest proofs ( Nesterov and Vial, 2000 ). Significantly more\nadvanced proof techniques exist, e.g., whenever the objective function is particularly well\nbehaved.\nSuppose that the objective function \ud835\udc53\u00b9\ud835\udf43,x\u00bais convex in xfor all \ud835\udf43. More concretely, we\n497 Stochastic Gradient Descent\nconsider the stochastic gradient descent update:\nx\ud835\udc61\u00b81=x\ud835\udc61\u0000\ud835\udf02\ud835\udc61\ud835\udf15x\ud835\udc53\u00b9\ud835\udf43\ud835\udc61,x\u00ba, (12.4.6)\nwhere\ud835\udc53\u00b9\ud835\udf43\ud835\udc61,x\u00baistheobjectivefunctionwithrespecttothetrainingexample \ud835\udf43\ud835\udc61drawnfrom\nsome distribution at step \ud835\udc61andxis the model parameter. Denote by\n\ud835\udc45\u00b9x\u00ba=\ud835\udc38\ud835\udf43\u00bb\ud835\udc53\u00b9\ud835\udf43,x\u00ba\u00bc (12.4.7)\nthe expected risk and by \ud835\udc45\u0003its minimum with regard to x. Last let x\u0003be the minimizer\n(we assume that it exists within the domain where xis defined).", "mimetype": "text/plain", "start_char_idx": 1120874, "end_char_idx": 1123932, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1a055c74-cb31-4a2a-be35-478b80bc440a": {"__data__": {"id_": "1a055c74-cb31-4a2a-be35-478b80bc440a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "afd7222d-103e-4394-b970-a3c18b4a5605", "node_type": "1", "metadata": {}, "hash": "dc1c0f5172d8176ea142b542013d693e509f117c932b54b9e624cbd921bd9836", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "db66b242-0707-40a3-9ab8-20fb3b7a0503", "node_type": "1", "metadata": {}, "hash": "d81519791ab30968150c8569d0e8e643f9a2a9a17d4cdbf0a8f74b6718d20744", "class_name": "RelatedNodeInfo"}}, "text": "Denote by\n\ud835\udc45\u00b9x\u00ba=\ud835\udc38\ud835\udf43\u00bb\ud835\udc53\u00b9\ud835\udf43,x\u00ba\u00bc (12.4.7)\nthe expected risk and by \ud835\udc45\u0003its minimum with regard to x. Last let x\u0003be the minimizer\n(we assume that it exists within the domain where xis defined). In this case we can track\nthe distance between the current parameter x\ud835\udc61at time\ud835\udc61and the risk minimizer x\u0003and see\nwhether it improves over time:\nkx\ud835\udc61\u00b81\u0000x\u0003k2\n=kx\ud835\udc61\u0000\ud835\udf02\ud835\udc61\ud835\udf15x\ud835\udc53\u00b9\ud835\udf43\ud835\udc61,x\u00ba\u0000x\u0003k2\n=kx\ud835\udc61\u0000x\u0003k2\u00b8\ud835\udf022\n\ud835\udc61k\ud835\udf15x\ud835\udc53\u00b9\ud835\udf43\ud835\udc61,x\u00bak2\u00002\ud835\udf02\ud835\udc61\nx\ud835\udc61\u0000x\u0003,\ud835\udf15x\ud835\udc53\u00b9\ud835\udf43\ud835\udc61,x\u00ba\u000b\n.(12.4.8)\nWeassumethatthe \u21132normofstochasticgradient \ud835\udf15x\ud835\udc53\u00b9\ud835\udf43\ud835\udc61,x\u00baisboundedbysomeconstant\n\ud835\udc3f, hence we have that\n\ud835\udf022\n\ud835\udc61k\ud835\udf15x\ud835\udc53\u00b9\ud835\udf43\ud835\udc61,x\u00bak2\u0014\ud835\udf022\n\ud835\udc61\ud835\udc3f2. (12.4.9)\nWe are mostly interested in how the distance between x\ud835\udc61andx\u0003changesin expectation .\nIn fact, for any specific sequence of steps the distance might well increase, depending on\nwhichever \ud835\udf43\ud835\udc61weencounter. Henceweneedtoboundthedotproduct. Sinceforanyconvex\nfunction\ud835\udc53it holds that \ud835\udc53\u00b9y\u00ba\u0015\ud835\udc53\u00b9x\u00ba\u00b8h\ud835\udc530\u00b9x\u00ba,y\u0000xifor all xandy, by convexity we\nhave\n\ud835\udc53\u00b9\ud835\udf43\ud835\udc61,x\u0003\u00ba\u0015\ud835\udc53\u00b9\ud835\udf43\ud835\udc61,x\ud835\udc61\u00ba\u00b8\nx\u0003\u0000x\ud835\udc61,\ud835\udf15x\ud835\udc53\u00b9\ud835\udf43\ud835\udc61,x\ud835\udc61\u00ba\u000b\n. (12.4.10)\nPlugging both inequalities (12.4.9 )and(12.4.10 )into(12.4.8 )we obtain a bound on the\ndistance between parameters at time \ud835\udc61\u00b81as follows:\nkx\ud835\udc61\u0000x\u0003k2\u0000kx\ud835\udc61\u00b81\u0000x\u0003k2\u00152\ud835\udf02\ud835\udc61\u00b9\ud835\udc53\u00b9\ud835\udf43\ud835\udc61,x\ud835\udc61\u00ba\u0000\ud835\udc53\u00b9\ud835\udf43\ud835\udc61,x\u0003\u00ba\u00ba\u0000\ud835\udf022\n\ud835\udc61\ud835\udc3f2. (12.4.11)\nThis means that we make progress as long as the difference between current loss and the\noptimallossoutweighs \ud835\udf02\ud835\udc61\ud835\udc3f2\u009d2. Sincethisdifferenceisboundtoconvergetozeroitfollows\nthat the learning rate \ud835\udf02\ud835\udc61also needs to vanish.\nNext we take expectations over (12.4.11 ). This yields\n\ud835\udc38\u0002\nkx\ud835\udc61\u0000x\u0003k2\u0003\n\u0000\ud835\udc38\u0002\nkx\ud835\udc61\u00b81\u0000x\u0003k2\u0003\n\u00152\ud835\udf02\ud835\udc61\u00bb\ud835\udc38\u00bb\ud835\udc45\u00b9x\ud835\udc61\u00ba\u00bc\u0000\ud835\udc45\u0003\u00bc\u0000\ud835\udf022\n\ud835\udc61\ud835\udc3f2. (12.4.12)\nThe last step involves summing over the inequalities for \ud835\udc612 f1,...,\ud835\udc47g. Since the sum\ntelescopes and by dropping the lower term we obtain\nkx1\u0000x\u0003k2\u00152 \ud835\udc47\u00d5\n\ud835\udc61=1\ud835\udf02\ud835\udc61!\n\u00bb\ud835\udc38\u00bb\ud835\udc45\u00b9x\ud835\udc61\u00ba\u00bc\u0000\ud835\udc45\u0003\u00bc\u0000\ud835\udc3f2\ud835\udc47\u00d5\n\ud835\udc61=1\ud835\udf022\n\ud835\udc61. (12.4.13)\n498 Optimization Algorithms\nNote that we exploited that x1is given and thus the expectation can be dropped. Last\ndefine\n\u00afxdef=\u00cd\ud835\udc47\n\ud835\udc61=1\ud835\udf02\ud835\udc61x\ud835\udc61\u00cd\ud835\udc47\n\ud835\udc61=1\ud835\udf02\ud835\udc61.", "mimetype": "text/plain", "start_char_idx": 1123749, "end_char_idx": 1125555, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "db66b242-0707-40a3-9ab8-20fb3b7a0503": {"__data__": {"id_": "db66b242-0707-40a3-9ab8-20fb3b7a0503", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1a055c74-cb31-4a2a-be35-478b80bc440a", "node_type": "1", "metadata": {}, "hash": "2956c98d41bdb519c5258206b124e3ef5567b46f8bd0697a52de5643a3f833db", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5cc01fda-462a-4658-ab49-f0730ad71f27", "node_type": "1", "metadata": {}, "hash": "27a0f1a1a066b4234effe448a3239203ebbc5c20d783eb25e4b2ed10185e0bb7", "class_name": "RelatedNodeInfo"}}, "text": "(12.4.12)\nThe last step involves summing over the inequalities for \ud835\udc612 f1,...,\ud835\udc47g. Since the sum\ntelescopes and by dropping the lower term we obtain\nkx1\u0000x\u0003k2\u00152 \ud835\udc47\u00d5\n\ud835\udc61=1\ud835\udf02\ud835\udc61!\n\u00bb\ud835\udc38\u00bb\ud835\udc45\u00b9x\ud835\udc61\u00ba\u00bc\u0000\ud835\udc45\u0003\u00bc\u0000\ud835\udc3f2\ud835\udc47\u00d5\n\ud835\udc61=1\ud835\udf022\n\ud835\udc61. (12.4.13)\n498 Optimization Algorithms\nNote that we exploited that x1is given and thus the expectation can be dropped. Last\ndefine\n\u00afxdef=\u00cd\ud835\udc47\n\ud835\udc61=1\ud835\udf02\ud835\udc61x\ud835\udc61\u00cd\ud835\udc47\n\ud835\udc61=1\ud835\udf02\ud835\udc61. (12.4.14)\nSince\n\ud835\udc38 \u00cd\ud835\udc47\n\ud835\udc61=1\ud835\udf02\ud835\udc61\ud835\udc45\u00b9x\ud835\udc61\u00ba\n\u00cd\ud835\udc47\n\ud835\udc61=1\ud835\udf02\ud835\udc61!\n=\u00cd\ud835\udc47\n\ud835\udc61=1\ud835\udf02\ud835\udc61\ud835\udc38\u00bb\ud835\udc45\u00b9x\ud835\udc61\u00ba\u00bc\n\u00cd\ud835\udc47\n\ud835\udc61=1\ud835\udf02\ud835\udc61=\ud835\udc38\u00bb\ud835\udc45\u00b9x\ud835\udc61\u00ba\u00bc, (12.4.15)\nby Jensen\u2019s inequality (setting \ud835\udc56=\ud835\udc61,\ud835\udefc\ud835\udc56=\ud835\udf02\ud835\udc61\u009d\u00cd\ud835\udc47\n\ud835\udc61=1\ud835\udf02\ud835\udc61in(12.2.3 )) and convexity of \ud835\udc45it\nfollows that\ud835\udc38\u00bb\ud835\udc45\u00b9x\ud835\udc61\u00ba\u00bc\u0015\ud835\udc38\u00bb\ud835\udc45\u00b9\u00afx\u00ba\u00bc, thus\n\ud835\udc47\u00d5\n\ud835\udc61=1\ud835\udf02\ud835\udc61\ud835\udc38\u00bb\ud835\udc45\u00b9x\ud835\udc61\u00ba\u00bc\u0015\ud835\udc47\u00d5\n\ud835\udc61=1\ud835\udf02\ud835\udc61\ud835\udc38\u00bb\ud835\udc45\u00b9\u00afx\u00ba\u00bc. (12.4.16)\nPlugging this into the inequality (12.4.13 )yields the bound\n\u00bb\ud835\udc38\u00bb\u00afx\u00bc\u00bc\u0000\ud835\udc45\u0003\u0014\ud835\udc5f2\u00b8\ud835\udc3f2\u00cd\ud835\udc47\n\ud835\udc61=1\ud835\udf022\n\ud835\udc61\n2\u00cd\ud835\udc47\n\ud835\udc61=1\ud835\udf02\ud835\udc61, (12.4.17)\nwhere\ud835\udc5f2def=kx1\u0000x\u0003k2is a bound on the distance between the initial choice of parameters\nand the final outcome. In short, the speed of convergence depends on how the norm of\nstochastic gradient is bounded ( \ud835\udc3f) and how far away from optimality the initial parameter\nvalue is (\ud835\udc5f). Note that the bound is in terms of \u00afxrather than x\ud835\udc47. This is the case since \u00afxis\na smoothed version of the optimization path. Whenever \ud835\udc5f,\ud835\udc3f, and\ud835\udc47are known we can pick\nthe learning rate \ud835\udf02=\ud835\udc5f\u009d\u00b9\ud835\udc3fp\n\ud835\udc47\u00ba. This yields as upper bound \ud835\udc5f\ud835\udc3f\u009dp\n\ud835\udc47. That is, we converge\nwith rateO\u00b91\u009dp\n\ud835\udc47\u00bato the optimal solution.\n12.4.4StochasticGradients and Finite Samples\nSo far we have played a bit fast and loose when it comes to talking about stochastic gra-\ndient descent. We posited that we draw instances \ud835\udc65\ud835\udc56, typically with labels \ud835\udc66\ud835\udc56from some\ndistribution \ud835\udc5d\u00b9\ud835\udc65,\ud835\udc66\u00baand that we use this to update the model parameters in some man-\nner. In particular, for a finite sample size we simply argued that the discrete distribution\n\ud835\udc5d\u00b9\ud835\udc65,\ud835\udc66\u00ba=1\n\ud835\udc5b\u00cd\ud835\udc5b\n\ud835\udc56=1\ud835\udeff\ud835\udc65\ud835\udc56\u00b9\ud835\udc65\u00ba\ud835\udeff\ud835\udc66\ud835\udc56\u00b9\ud835\udc66\u00baforsomefunctions \ud835\udeff\ud835\udc65\ud835\udc56and\ud835\udeff\ud835\udc66\ud835\udc56allowsustoperformstochas-\ntic gradient descent over it.\nHowever, this is not really what we did.", "mimetype": "text/plain", "start_char_idx": 1125204, "end_char_idx": 1127039, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5cc01fda-462a-4658-ab49-f0730ad71f27": {"__data__": {"id_": "5cc01fda-462a-4658-ab49-f0730ad71f27", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "db66b242-0707-40a3-9ab8-20fb3b7a0503", "node_type": "1", "metadata": {}, "hash": "d81519791ab30968150c8569d0e8e643f9a2a9a17d4cdbf0a8f74b6718d20744", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3b4a8070-947a-435b-9ead-04d4dd6aab58", "node_type": "1", "metadata": {}, "hash": "b1b85f925ac389a236032935a358f9a5f93ee93419dca1bdf413133a72182b61", "class_name": "RelatedNodeInfo"}}, "text": "We posited that we draw instances \ud835\udc65\ud835\udc56, typically with labels \ud835\udc66\ud835\udc56from some\ndistribution \ud835\udc5d\u00b9\ud835\udc65,\ud835\udc66\u00baand that we use this to update the model parameters in some man-\nner. In particular, for a finite sample size we simply argued that the discrete distribution\n\ud835\udc5d\u00b9\ud835\udc65,\ud835\udc66\u00ba=1\n\ud835\udc5b\u00cd\ud835\udc5b\n\ud835\udc56=1\ud835\udeff\ud835\udc65\ud835\udc56\u00b9\ud835\udc65\u00ba\ud835\udeff\ud835\udc66\ud835\udc56\u00b9\ud835\udc66\u00baforsomefunctions \ud835\udeff\ud835\udc65\ud835\udc56and\ud835\udeff\ud835\udc66\ud835\udc56allowsustoperformstochas-\ntic gradient descent over it.\nHowever, this is not really what we did. In the toy examples in the current section we\nsimplyaddednoisetoanotherwisenon-stochasticgradient,i.e.,wepretendedtohavepairs\n\u00b9\ud835\udc65\ud835\udc56,\ud835\udc66\ud835\udc56\u00ba. It turns out that this is justified here (see the exercises for a detailed discussion).\nMore troubling is that in all previous discussions we clearly did not do this. Instead we\niteratedoverallinstances exactlyonce . Toseewhythisispreferableconsidertheconverse,\nnamelythatwearesampling \ud835\udc5bobservationsfromthediscretedistribution withreplacement .\nThe probability of choosing an element \ud835\udc56at random is 1\u009d\ud835\udc5b. Thus to choose it atleastonce\nis\n\ud835\udc43\u00b9choose\ud835\udc56\u00ba=1\u0000\ud835\udc43\u00b9omit\ud835\udc56\u00ba=1\u0000\u00b91\u00001\u009d\ud835\udc5b\u00ba\ud835\udc5b\u00191\u0000\ud835\udc52\u00001\u00190.63. (12.4.18)\n499 Stochastic Gradient Descent\n170Asimilarreasoningshowsthattheprobabilityofpickingsomesample(i.e., trainingexam-\nple)exactly once is given by\n\u0012\ud835\udc5b\n1\u00131\n\ud835\udc5b\u0012\n1\u00001\n\ud835\udc5b\u0013\ud835\udc5b\u00001\n=\ud835\udc5b\n\ud835\udc5b\u00001\u0012\n1\u00001\n\ud835\udc5b\u0013\ud835\udc5b\n\u0019\ud835\udc52\u00001\u00190.37. (12.4.19)\nSampling with replacement leads to an increased variance and decreased data efficiency\nrelative to sampling without replacement . Hence, in practice we perform the latter (and\nthis is the default choice throughout this book). Last note that repeated passes through the\ntraining dataset traverse it in a different random order.\n12.4.5Summary\n\u000fFor convex problems we can prove that for a wide choice of learning rates stochastic\ngradient descent will converge to the optimal solution.\n\u000fFor deep learning this is generally not the case. However, the analysis of convex prob-\nlems gives us useful insight into how to approach optimization, namely to reduce the\nlearning rate progressively, albeit not too quickly.\n\u000fProblems occur when the learning rate is too small or too large. In practice a suitable\nlearning rate is often found only after multiple experiments.\n\u000fWhen there are more examples in the training dataset, it costs more to compute each\niterationforgradientdescent,sostochasticgradientdescentispreferredinthesecases.\n\u000fOptimalityguaranteesforstochasticgradientdescentareingeneralnotavailableinnon-\nconvex cases since the number of local minima that require checking might well be\nexponential.\n12.4.6Exercises\n1.Experiment with different learning rate schedules for stochastic gradient descent and\nwith different numbers of iterations. In particular, plot the distance from the optimal\nsolution\u00b90,0\u00baas a function of the number of iterations.\n2.Prove that for the function \ud835\udc53\u00b9\ud835\udc651,\ud835\udc652\u00ba=\ud835\udc652\n1\u00b82\ud835\udc652\n2adding normal noise to the gradient is\nequivalent to minimizing a loss function \ud835\udc53\u00b9x,w\u00ba=\u00b9\ud835\udc651\u0000\ud835\udc641\u00ba2\u00b82\u00b9\ud835\udc652\u0000\ud835\udc642\u00ba2where x\nis drawn from a normal distribution.\n3.Compareconvergenceofstochasticgradientdescentwhenyousamplefrom f\u00b9\ud835\udc651,\ud835\udc661\u00ba,...,\u00b9\ud835\udc65\ud835\udc5b,\ud835\udc66\ud835\udc5b\u00bag\nwith replacement and when you sample without replacement.\n4.Howwouldyouchangethestochasticgradientdescentsolverifsomegradient(orrather\nsome coordinate associated with it) was consistently larger than all the other gradients?\n5.Assume that \ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc652\u00b91\u00b8sin\ud835\udc65\u00ba.", "mimetype": "text/plain", "start_char_idx": 1126640, "end_char_idx": 1129857, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3b4a8070-947a-435b-9ead-04d4dd6aab58": {"__data__": {"id_": "3b4a8070-947a-435b-9ead-04d4dd6aab58", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5cc01fda-462a-4658-ab49-f0730ad71f27", "node_type": "1", "metadata": {}, "hash": "27a0f1a1a066b4234effe448a3239203ebbc5c20d783eb25e4b2ed10185e0bb7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "21b7a125-5e6b-4d45-ae1f-2cd19d09209a", "node_type": "1", "metadata": {}, "hash": "5485561aa3a42195cbaf64b8cdcc76d98ad5163d77a583e376ff363075b4eaa8", "class_name": "RelatedNodeInfo"}}, "text": "3.Compareconvergenceofstochasticgradientdescentwhenyousamplefrom f\u00b9\ud835\udc651,\ud835\udc661\u00ba,...,\u00b9\ud835\udc65\ud835\udc5b,\ud835\udc66\ud835\udc5b\u00bag\nwith replacement and when you sample without replacement.\n4.Howwouldyouchangethestochasticgradientdescentsolverifsomegradient(orrather\nsome coordinate associated with it) was consistently larger than all the other gradients?\n5.Assume that \ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc652\u00b91\u00b8sin\ud835\udc65\u00ba. How many local minima does \ud835\udc53have? Can you\nchange\ud835\udc53in such a way that to minimize it one needs to evaluate all the local minima?\nDiscussions170.\n500 Optimization Algorithms\n17112.5MinibatchStochasticGradient Descent\nSo far we encountered two extremes in the approach to gradient-based learning: Section\n12.3usesthefulldatasettocomputegradientsandtoupdateparameters,onepassatatime.\nConversely Section 12.4 processes one training exampleat a time to make progress. Either\nofthemhasitsowndrawbacks. Gradientdescentisnotparticularly datae\ufb00icient whenever\ndataisverysimilar. Stochasticgradientdescentisnotparticularly computationallye\ufb00icient\nsince CPUs and GPUs cannot exploit the full power of vectorization. This suggests that\nthere might be something in between, and in fact, that is what we have been using so far in\nthe examples we discussed.\n12.5.1Vectorizationand Caches\nAt the heart of the decision to use minibatches is computational efficiency. This is most\neasily understood when considering parallelization to multiple GPUs and multiple servers.\nIn this case we need to send at least one image to each GPU. With 8 GPUs per server and\n16 servers we already arrive at a minibatch size no smaller than 128.\nThings are a bit more subtle when it comes to single GPUs or even CPUs. These devices\nhave multiple types of memory, often multiple types of computational units and different\nbandwidth constraints between them. For instance, a CPU has a small number of registers\nand then the L1, L2, and in some cases even L3 cache (which is shared among different\nprocessor cores). These caches are of increasing size and latency (and at the same time\nthey are of decreasing bandwidth). Suffice to say, the processor is capable of performing\nmany more operations than what the main memory interface is able to provide.\nFirst, a 2GHz CPU with 16 cores and AVX-512 vectorization can process up to 2\u0001109\u0001\n16\u000132=1012bytes per second. The capability of GPUs easily exceeds this number by a\nfactor of 100. On the other hand, a midrange server processor might not have much more\nthan 100 GB/s bandwidth, i.e., less than one tenth of what would be required to keep the\nprocessor fed. To make matters worse, not all memory access is created equal: memory\ninterfaces are typically 64 bit wide or wider (e.g., on GPUs up to 384 bit), hence reading a\nsingle byte incurs the cost of a much wider access.\nSecond, there is significant overhead for the first access whereas sequential access is rela-\ntivelycheap(thisisoftencalledaburstread). Therearemanymorethingstokeepinmind,\nsuch as caching when we have multiple sockets, chiplets, and other structures. See this\nWikipedia article171for a more in-depth discussion.\nThe way to alleviate these constraints is to use a hierarchy of CPU caches that are actu-\nally fast enough to supply the processor with data. This is thedriving force behind batch-\ning in deep learning. To keep matters simple, consider matrix-matrix multiplication, say\nA=BC. We have a number of options for calculating A. For instance, we could try the\nfollowing:\n501 Minibatch Stochastic Gradient Descent\n1.We could compute A\ud835\udc56\ud835\udc57=B\ud835\udc56,:C:,\ud835\udc57, i.e., we could compute it elementwise by means of\ndot products.\n2.We could compute A:,\ud835\udc57=BC :,\ud835\udc57, i.e., we could compute it one column at a time.\nLikewise we could compute Aone row A\ud835\udc56,:at a time.\n3.We could simply compute A=BC.\n4.We could break BandCinto smaller block matrices and compute Aone block at a\ntime.\nIf we follow the first option, we will need to copy one row and one column vector into the\nCPUeachtimewewanttocomputeanelement A\ud835\udc56\ud835\udc57.", "mimetype": "text/plain", "start_char_idx": 1129515, "end_char_idx": 1133436, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "21b7a125-5e6b-4d45-ae1f-2cd19d09209a": {"__data__": {"id_": "21b7a125-5e6b-4d45-ae1f-2cd19d09209a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3b4a8070-947a-435b-9ead-04d4dd6aab58", "node_type": "1", "metadata": {}, "hash": "b1b85f925ac389a236032935a358f9a5f93ee93419dca1bdf413133a72182b61", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "27a407f7-fb20-417e-8c24-85060c31d721", "node_type": "1", "metadata": {}, "hash": "88c22dba1d70c97c976685e24b454e3348b22619583463f3425c3427971cbe6f", "class_name": "RelatedNodeInfo"}}, "text": "We have a number of options for calculating A. For instance, we could try the\nfollowing:\n501 Minibatch Stochastic Gradient Descent\n1.We could compute A\ud835\udc56\ud835\udc57=B\ud835\udc56,:C:,\ud835\udc57, i.e., we could compute it elementwise by means of\ndot products.\n2.We could compute A:,\ud835\udc57=BC :,\ud835\udc57, i.e., we could compute it one column at a time.\nLikewise we could compute Aone row A\ud835\udc56,:at a time.\n3.We could simply compute A=BC.\n4.We could break BandCinto smaller block matrices and compute Aone block at a\ntime.\nIf we follow the first option, we will need to copy one row and one column vector into the\nCPUeachtimewewanttocomputeanelement A\ud835\udc56\ud835\udc57. Evenworse,duetothefactthatmatrix\nelements are aligned sequentially we are thus required to access many disjoint locations\nfor one of the two vectors as we read them from memory. The second option is much\nmore favorable. In it, we are able to keep the column vector C:,\ud835\udc57in the CPU cache while\nwe keep on traversing through B. This halves the memory bandwidth requirement with\ncorrespondingly faster access. Of course, option 3 is most desirable. Unfortunately, most\nmatricesmightnotentirelyfitintocache(thisiswhatwearediscussingafterall). However,\noption4offersapracticallyusefulalternative: wecanmoveblocksofthematrixintocache\nand multiply them locally. Optimized libraries take care of this for us. Let\u2019s have a look at\nhow efficient these operations are in practice.\nBeyondcomputationalefficiency,theoverheadintroducedbyPythonandbythedeeplearn-\ning framework itself is considerable. Recall that each time we execute a command the\nPython interpreter sends a command to the MXNet engine which needs to insert it into\nthe computational graph and deal with it during scheduling. Such overhead can be quite\ndetrimental. In short, it is highly advisable to use vectorization (and matrices) whenever\npossible.\n%matplotlib inline\nimport time\nimport numpy asnp\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\nA=torch .zeros( 256,256)\nB=torch .randn( 256,256)\nC=torch .randn( 256,256)\nSince we will benchmark the running time frequently in the rest of the book, let\u2019s define a\ntimer.\nclass Timer :#@save\n\"\"\"Record multiple running times.\"\"\"\ndef __init__ (self ):\nself .times =[]\nself .start()\n(continues on next page)\n502 Optimization Algorithms\n(continued from previous page)\ndef start (self ):\n\"\"\"Start the timer.\"\"\"\nself .tik =time .time()\ndef stop (self ):\n\"\"\"Stop the timer and record the time in a list.\"\"\"\nself .times .append(time .time() -self .tik)\nreturn self .times[ -1]\ndef avg(self ):\n\"\"\"Return the average time.\"\"\"\nreturn sum(self .times) /len(self .times)\ndef sum(self ):\n\"\"\"Return the sum of time.\"\"\"\nreturn sum(self .times)\ndef cumsum (self ):\n\"\"\"Return the accumulated time.\"\"\"\nreturn np.array( self .times) .cumsum() .tolist()\ntimer =Timer()\nElement-wiseassignmentsimplyiteratesoverallrowsandcolumnsof BandCrespectively\nto assign the value to A.\n# Compute A = BC one element at a time\ntimer .start()\nfor iinrange (256):\nfor jinrange (256):\nA[i, j] =torch .dot(B[i, :], C[:, j])\ntimer .stop()\n1.7845737934112549\nA faster strategy is to perform column-wise assignment.\n# Compute A = BC one column at a time\ntimer .start()\nfor jinrange (256):\nA[:, j] =torch .mv(B, C[:, j])\ntimer .stop()\n0.06541275978088379\nLast, the most effective manner is to perform the entire operation in one block. Note that\nmultiplyinganytwomatrices B2R\ud835\udc5a\u0002\ud835\udc5bandC2R\ud835\udc5b\u0002\ud835\udc5dtakesapproximately 2\ud835\udc5a\ud835\udc5b\ud835\udc5dfloating\npointoperations,whenscalarmultiplicationandadditionarecountedasseparateoperations\n503 Minibatch Stochastic Gradient Descent\n(fused in practice). Thus, multiplying two 256\u0002256matrices takes 0.03billion floating\npoint operations. Let\u2019s see what the respective speed of the operations is.", "mimetype": "text/plain", "start_char_idx": 1132831, "end_char_idx": 1136516, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "27a407f7-fb20-417e-8c24-85060c31d721": {"__data__": {"id_": "27a407f7-fb20-417e-8c24-85060c31d721", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "21b7a125-5e6b-4d45-ae1f-2cd19d09209a", "node_type": "1", "metadata": {}, "hash": "5485561aa3a42195cbaf64b8cdcc76d98ad5163d77a583e376ff363075b4eaa8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "238f6e68-b9ae-4bd3-8c78-85b3949f9122", "node_type": "1", "metadata": {}, "hash": "841def7d43a29cce0f7aafe491559eb2e31957dd136dbf114707cf51a4641a95", "class_name": "RelatedNodeInfo"}}, "text": "# Compute A = BC one column at a time\ntimer .start()\nfor jinrange (256):\nA[:, j] =torch .mv(B, C[:, j])\ntimer .stop()\n0.06541275978088379\nLast, the most effective manner is to perform the entire operation in one block. Note that\nmultiplyinganytwomatrices B2R\ud835\udc5a\u0002\ud835\udc5bandC2R\ud835\udc5b\u0002\ud835\udc5dtakesapproximately 2\ud835\udc5a\ud835\udc5b\ud835\udc5dfloating\npointoperations,whenscalarmultiplicationandadditionarecountedasseparateoperations\n503 Minibatch Stochastic Gradient Descent\n(fused in practice). Thus, multiplying two 256\u0002256matrices takes 0.03billion floating\npoint operations. Let\u2019s see what the respective speed of the operations is.\n# Compute A = BC in one go\ntimer .start()\nA=torch .mm(B, C)\ntimer .stop()\ngigaflops =[0.03 /ifor iintimer .times]\nprint (f'performance in Gigaflops: element {gigaflops[ 0]:.3f},'\nf'column {gigaflops[ 1]:.3f}, full {gigaflops[ 2]:.3f}')\nperformance inGigaflops: element 0.017 , column 0.459 , full 51.633\n12.5.2Minibatches\nIn the past we took it for granted that we would read minibatches of data rather than single\nobservations to update parameters. We now give a brief justification for it. Processing sin-\ngle observations requires us to perform many single matrix-vector (or even vector-vector)\nmultiplications, whichisquiteexpensiveandwhichincursasignificantoverheadonbehalf\noftheunderlyingdeeplearningframework. Thisappliesbothtoevaluatinganetworkwhen\nappliedtodata(oftenreferredtoasinference)andwhencomputinggradientstoupdatepa-\nrameters. That is, this applies whenever we perform w w\u0000\ud835\udf02\ud835\udc61g\ud835\udc61where\ng\ud835\udc61=\ud835\udf15w\ud835\udc53\u00b9x\ud835\udc61,w\u00ba (12.5.1)\nWecanincreasethe computational efficiencyofthisoperationbyapplyingittoaminibatch\nof observations at a time. That is, we replace the gradient g\ud835\udc61over a single observation by\none over a small batch\ng\ud835\udc61=\ud835\udf15w1\njB\ud835\udc61j\u00d5\n\ud835\udc562B\ud835\udc61\ud835\udc53\u00b9x\ud835\udc56,w\u00ba (12.5.2)\nLet\u2019sseewhatthisdoestothestatisticalpropertiesof g\ud835\udc61: sinceboth x\ud835\udc61andalsoallelements\noftheminibatchB\ud835\udc61aredrawnuniformlyatrandomfromthetrainingset,theexpectationof\nthe gradient remains unchanged. The variance, on the other hand, is reduced significantly.\nSince the minibatch gradient is composed of \ud835\udc4fdef=jB\ud835\udc61jindependent gradients which are\nbeingaveraged,itsstandarddeviationisreducedbyafactorof \ud835\udc4f\u00001\n2. This,byitself,isagood\nthing,sinceitmeansthattheupdatesaremorereliablyalignedwiththefullgradient.\nNaively this would indicate that choosing a large minibatch B\ud835\udc61would be universally desir-\nable. Alas,aftersomepoint,theadditionalreductioninstandarddeviationisminimalwhen\ncompared to the linear increase in computational cost. In practice we pick a minibatch that\nislargeenoughtooffergoodcomputationalefficiencywhilestillfittingintothememoryof\na GPU. To illustrate the savings let\u2019s have a look at some code. In it we perform the same\nmatrix-matrix multiplication, but this time broken up into \u201cminibatches\u201d of 64 columns at\na time.\n504 Optimization Algorithms\n172timer .start()\nfor jinrange (0,256,64):\nA[:, j:j +64]=torch .mm(B, C[:, j:j +64])\ntimer .stop()\nprint (f'performance in Gigaflops: block {0.03 /timer .times[ 3]:.3f}')\nperformance inGigaflops: block 37.640\nAs we can see, the computation on the minibatch is essentially as efficient as on the full\nmatrix. A word of caution is in order. In Section 8.5 we used a type of regularization that\nwas heavily dependent on the amount of variance in a minibatch.", "mimetype": "text/plain", "start_char_idx": 1135929, "end_char_idx": 1139180, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "238f6e68-b9ae-4bd3-8c78-85b3949f9122": {"__data__": {"id_": "238f6e68-b9ae-4bd3-8c78-85b3949f9122", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "27a407f7-fb20-417e-8c24-85060c31d721", "node_type": "1", "metadata": {}, "hash": "88c22dba1d70c97c976685e24b454e3348b22619583463f3425c3427971cbe6f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "749a0e77-ade1-443e-b149-fe68ec0b68d7", "node_type": "1", "metadata": {}, "hash": "aa3c27ce7466f8ade857e97cf0d7e389ef36ecf0d435e62c91b90292bb98e469", "class_name": "RelatedNodeInfo"}}, "text": "To illustrate the savings let\u2019s have a look at some code. In it we perform the same\nmatrix-matrix multiplication, but this time broken up into \u201cminibatches\u201d of 64 columns at\na time.\n504 Optimization Algorithms\n172timer .start()\nfor jinrange (0,256,64):\nA[:, j:j +64]=torch .mm(B, C[:, j:j +64])\ntimer .stop()\nprint (f'performance in Gigaflops: block {0.03 /timer .times[ 3]:.3f}')\nperformance inGigaflops: block 37.640\nAs we can see, the computation on the minibatch is essentially as efficient as on the full\nmatrix. A word of caution is in order. In Section 8.5 we used a type of regularization that\nwas heavily dependent on the amount of variance in a minibatch. As we increase the latter,\nthe variance decreases and with it the benefit of the noise-injection due to batch normal-\nization. See e.g., Ioffe ( 2017) for details on how to rescale and compute the appropriate\nterms.\n12.5.3Readingthe Dataset\nLet\u2019s have a look at how minibatches are efficiently generated from data. In the following\nwe use a dataset developed by NASA to test the wing noise from different aircraft172\nto compare these optimization algorithms. For convenience we only use the first 1,500\nexamples. Thedataiswhitenedforpreprocessing,i.e.,weremovethemeanandrescalethe\nvariance to 1per coordinate.\n#@save\nd2l.DATA_HUB[ 'airfoil ']=(d2l .DATA_URL +'airfoil_self_noise.dat ',\n'76e5be1548fd8222e5074cf0faae75edff8cf93f ')\n#@save\ndef get_data_ch11 (batch_size =10, n=1500 ):\ndata =np.genfromtxt(d2l .download( 'airfoil '),\ndtype =np.float32, delimiter ='\\t')\ndata =torch .from_numpy((data -data .mean(axis =0))/data .std(axis =0))\ndata_iter =d2l.load_array((data[:n, : -1], data[:n, -1]),\nbatch_size, is_train =True )\nreturn data_iter, data .shape[ 1]-1\n12.5.4Implementation fromScratch\nRecall the minibatch stochastic gradient descent implementation from Section 3.4 . In the\nfollowing we provide a slightly more general implementation. For convenience it has the\nsame call signature as the other optimization algorithms introduced later in this chapter.\nSpecifically, we add the status input states and place the hyperparameter in dictionary\nhyperparams . Inaddition, wewillaveragethelossofeachminibatchexampleinthetrain-\ning function, so the gradient in the optimization algorithm does not need to be divided by\nthe batch size.\n505 Minibatch Stochastic Gradient Descent\ndef sgd(params, states, hyperparams):\nfor pinparams:\np.data .sub_(hyperparams[ 'lr']*p.grad)\np.grad .data .zero_()\nNext,weimplementagenerictrainingfunctiontofacilitatetheuseoftheotheroptimization\nalgorithms introduced later in this chapter. It initializes a linear regression model and can\nbe used to train the model with minibatch stochastic gradient descent and other algorithms\nintroduced subsequently.", "mimetype": "text/plain", "start_char_idx": 1138515, "end_char_idx": 1141267, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "749a0e77-ade1-443e-b149-fe68ec0b68d7": {"__data__": {"id_": "749a0e77-ade1-443e-b149-fe68ec0b68d7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "238f6e68-b9ae-4bd3-8c78-85b3949f9122", "node_type": "1", "metadata": {}, "hash": "841def7d43a29cce0f7aafe491559eb2e31957dd136dbf114707cf51a4641a95", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cb254eb2-33eb-4522-8532-554e38dd156c", "node_type": "1", "metadata": {}, "hash": "e8ee639a5e4a485ca1b802690840190eff1b05026930309ecb5a562ace8ed543", "class_name": "RelatedNodeInfo"}}, "text": "For convenience it has the\nsame call signature as the other optimization algorithms introduced later in this chapter.\nSpecifically, we add the status input states and place the hyperparameter in dictionary\nhyperparams . Inaddition, wewillaveragethelossofeachminibatchexampleinthetrain-\ning function, so the gradient in the optimization algorithm does not need to be divided by\nthe batch size.\n505 Minibatch Stochastic Gradient Descent\ndef sgd(params, states, hyperparams):\nfor pinparams:\np.data .sub_(hyperparams[ 'lr']*p.grad)\np.grad .data .zero_()\nNext,weimplementagenerictrainingfunctiontofacilitatetheuseoftheotheroptimization\nalgorithms introduced later in this chapter. It initializes a linear regression model and can\nbe used to train the model with minibatch stochastic gradient descent and other algorithms\nintroduced subsequently.\n#@save\ndef train_ch11 (trainer_fn, states, hyperparams, data_iter,\nfeature_dim, num_epochs =2):\n# Initialization\nw=torch .normal(mean =0.0, std =0.01 , size =(feature_dim, 1),\nrequires_grad =True )\nb=torch .zeros(( 1), requires_grad =True )\nnet, loss =lambda X: d2l .linreg(X, w, b), d2l .squared_loss\n# Train\nanimator =d2l.Animator(xlabel ='epoch ', ylabel ='loss ',\nxlim =[0, num_epochs], ylim =[0.22 ,0.35 ])\nn, timer =0, d2l .Timer()\nfor _inrange (num_epochs):\nfor X, y indata_iter:\nl=loss(net(X), y) .mean()\nl.backward()\ntrainer_fn([w, b], states, hyperparams)\nn+=X.shape[ 0]\nifn%200 ==0:\ntimer .stop()\nanimator .add(n /X.shape[ 0]/len(data_iter),\n(d2l .evaluate_loss(net, data_iter, loss),))\ntimer .start()\nprint (f'loss: {animator .Y[0][-1]:.3f},{timer .sum() /num_epochs :.3f}sec/\n\u21a9!epoch ')\nreturn timer .cumsum(), animator .Y[0]\nLet\u2019s see how optimization proceeds for batch gradient descent. This can be achieved by\nsetting the minibatch size to 1500 (i.e., to the total number of examples). As a result the\nmodel parameters are updated only once per epoch. There is little progress. In fact, after 6\nsteps progress stalls.\ndef train_sgd (lr, batch_size, num_epochs =2):\ndata_iter, feature_dim =get_data_ch11(batch_size)\nreturn train_ch11(\nsgd, None , {'lr': lr}, data_iter, feature_dim, num_epochs)\ngd_res =train_sgd( 1,1500 ,10)\nloss: 0.247 ,0.020 sec/epoch\n506 Optimization Algorithms\nWhen the batch size equals 1, we use stochastic gradient descent for optimization. For\nsimplicityofimplementationwepickedaconstant(albeitsmall)learningrate. Instochastic\ngradient descent, the model parameters are updated whenever an example is processed. In\nourcasethisamountsto1500updatesperepoch. Aswecansee, thedeclineinthevalueof\ntheobjectivefunctionslowsdownafteroneepoch. Althoughboththeproceduresprocessed\n1500 examples within one epoch, stochastic gradient descent consumes more time than\ngradient descent in our experiment. This is because stochastic gradient descent updated\nthe parameters more frequently and since it is less efficient to process single observations\none at a time.\nsgd_res =train_sgd( 0.005 ,1)\nloss: 0.245 ,0.685 sec/epoch\nFinally, when the batch size equals 100, we use minibatch stochastic gradient descent for\noptimization. The time required per epoch is shorter than the time needed for stochastic\ngradient descent and the time for batch gradient descent.\nmini1_res =train_sgd( .4,100)\nloss: 0.246 ,0.025 sec/epoch\nReducing the batch size to 10, the time for each epoch increases because the workload for\neach batch is less efficient to execute.\n507 Minibatch Stochastic Gradient Descent\nmini2_res =train_sgd( .05,10)\nloss: 0.246 ,0.090 sec/epoch\nNow we can compare the time vs. loss for the previous four experiments.", "mimetype": "text/plain", "start_char_idx": 1140427, "end_char_idx": 1144018, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cb254eb2-33eb-4522-8532-554e38dd156c": {"__data__": {"id_": "cb254eb2-33eb-4522-8532-554e38dd156c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "749a0e77-ade1-443e-b149-fe68ec0b68d7", "node_type": "1", "metadata": {}, "hash": "aa3c27ce7466f8ade857e97cf0d7e389ef36ecf0d435e62c91b90292bb98e469", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "192ff4e3-6ece-4cb3-a6d7-ce2f40203bfb", "node_type": "1", "metadata": {}, "hash": "25896bc1193a690fa10090b6483992215eded9188aae5e860a4f7d5327adec79", "class_name": "RelatedNodeInfo"}}, "text": "sgd_res =train_sgd( 0.005 ,1)\nloss: 0.245 ,0.685 sec/epoch\nFinally, when the batch size equals 100, we use minibatch stochastic gradient descent for\noptimization. The time required per epoch is shorter than the time needed for stochastic\ngradient descent and the time for batch gradient descent.\nmini1_res =train_sgd( .4,100)\nloss: 0.246 ,0.025 sec/epoch\nReducing the batch size to 10, the time for each epoch increases because the workload for\neach batch is less efficient to execute.\n507 Minibatch Stochastic Gradient Descent\nmini2_res =train_sgd( .05,10)\nloss: 0.246 ,0.090 sec/epoch\nNow we can compare the time vs. loss for the previous four experiments. As can be seen,\nalthough stochastic gradient descent converges faster than GD in terms of number of ex-\namplesprocessed,itusesmoretimetoreachthesamelossthanGDbecausecomputingthe\ngradient example by example is not as efficient. Minibatch stochastic gradient descent is\nable to trade-off convergence speed and computation efficiency. A minibatch size of 10 is\nmore efficient than stochastic gradient descent; a minibatch size of 100 even outperforms\nGD in terms of runtime.\nd2l.set_figsize([ 6,3])\nd2l.plot( *list (map(list ,zip(gd_res, sgd_res, mini1_res, mini2_res))),\n'time (sec) ','loss ', xlim =[1e-2 ,10],\nlegend =['gd','sgd','batch size=100 ','batch size=10 '])\nd2l.plt.gca() .set_xscale( 'log')\n12.5.5ConciseImplementation\nInGluon,wecanusethe Trainer classtocalloptimizationalgorithms. Thisisusedtoim-\nplementagenerictrainingfunction. Wewillusethisthroughoutthecurrentchapter.\n508 Optimization Algorithms\n#@save\ndef train_concise_ch11 (trainer_fn, hyperparams, data_iter, num_epochs =4):\n# Initialization\nnet =nn.Sequential(nn .Linear( 5,1))\ndef init_weights (module):\niftype (module) ==nn.Linear:\ntorch .nn.init .normal_(module .weight, std =0.01 )\nnet.apply(init_weights)\noptimizer =trainer_fn(net .parameters(), **hyperparams)\nloss =nn.MSELoss(reduction ='none ')\nanimator =d2l.Animator(xlabel ='epoch ', ylabel ='loss ',\nxlim =[0, num_epochs], ylim =[0.22 ,0.35 ])\nn, timer =0, d2l .Timer()\nfor _inrange (num_epochs):\nfor X, y indata_iter:\noptimizer .zero_grad()\nout =net(X)\ny=y.reshape(out .shape)\nl=loss(out, y)\nl.mean() .backward()\noptimizer .step()\nn+=X.shape[ 0]\nifn%200 ==0:\ntimer .stop()\n# `MSELoss` computes squared error without the 1/2 factor\nanimator .add(n /X.shape[ 0]/len(data_iter),\n(d2l .evaluate_loss(net, data_iter, loss) /2,))\ntimer .start()\nprint (f'loss: {animator .Y[0][-1]:.3f},{timer .sum() /num_epochs :.3f}sec/\n\u21a9!epoch ')\nUsing Gluon to repeat the last experiment shows identical behavior.\ndata_iter, _ =get_data_ch11( 10)\ntrainer =torch .optim .SGD\ntrain_concise_ch11(trainer, { 'lr':0.01 }, data_iter)\n509 Minibatch Stochastic Gradient Descent\nloss: 0.243 ,0.096 sec/epoch\n12.5.6Summary\n\u000fVectorization makes code more efficient due to reduced overhead arising from the deep\nlearning framework and due to better memory locality and caching on CPUs and\nGPUs.\n\u000fThereisatrade-offbetweenstatisticalefficiencyarisingfromstochasticgradientdescent\nand computational efficiency arising from processing large batches of data at a time.\n\u000fMinibatch stochastic gradient descent offers the best of both worlds: computational and\nstatistical efficiency.\n\u000fInminibatchstochasticgradientdescentweprocessbatchesofdataobtainedbyarandom\npermutation of the training data (i.e., each observation is processed only once per\nepoch, albeit in random order).\n\u000fIt is advisable to decay the learning rates during training.\n\u000fIngeneral,minibatchstochasticgradientdescentisfasterthanstochasticgradientdescent\nand gradient descent for convergence to a smaller risk, when measured in terms of\nclock time.", "mimetype": "text/plain", "start_char_idx": 1143360, "end_char_idx": 1147027, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "192ff4e3-6ece-4cb3-a6d7-ce2f40203bfb": {"__data__": {"id_": "192ff4e3-6ece-4cb3-a6d7-ce2f40203bfb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cb254eb2-33eb-4522-8532-554e38dd156c", "node_type": "1", "metadata": {}, "hash": "e8ee639a5e4a485ca1b802690840190eff1b05026930309ecb5a562ace8ed543", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "53153f7c-e5ae-4e9a-98dc-471e679933e4", "node_type": "1", "metadata": {}, "hash": "90632e82e5356663762fc419e5cec6790dd772b6abfac35804644c62008efecf", "class_name": "RelatedNodeInfo"}}, "text": "\u000fThereisatrade-offbetweenstatisticalefficiencyarisingfromstochasticgradientdescent\nand computational efficiency arising from processing large batches of data at a time.\n\u000fMinibatch stochastic gradient descent offers the best of both worlds: computational and\nstatistical efficiency.\n\u000fInminibatchstochasticgradientdescentweprocessbatchesofdataobtainedbyarandom\npermutation of the training data (i.e., each observation is processed only once per\nepoch, albeit in random order).\n\u000fIt is advisable to decay the learning rates during training.\n\u000fIngeneral,minibatchstochasticgradientdescentisfasterthanstochasticgradientdescent\nand gradient descent for convergence to a smaller risk, when measured in terms of\nclock time.\n12.5.7Exercises\n1.Modify the batch size and learning rate and observe the rate of decline for the value of\nthe objective function and the time consumed in each epoch.\n2.Read the MXNet documentation and use the Trainer class set_learning_rate func-\ntion to reduce the learning rate of the minibatch stochastic gradient descent to 1/10 of\nits previous value after each epoch.\n3.Compareminibatchstochasticgradientdescentwithavariantthatactually sampleswith\nreplacement from the training set. What happens?\n4.An evil genie replicates your dataset without telling you (i.e., each observation occurs\ntwice and your dataset grows to twice its original size, but nobody told you). How does\n510 Optimization Algorithms\n173the behavior of stochastic gradient descent, minibatch stochastic gradient descent and\nthat of gradient descent change?\nDiscussions173.\n12.6Momentum\nInSection 12.4 we reviewed what happens when performing stochastic gradient descent,\ni.e., when performing optimization where only a noisy variant of the gradient is available.\nInparticular,wenoticedthatfornoisygradientsweneedtobeextracautiouswhenitcomes\ntochoosingthe learning rate inthe faceof noise. If wedecrease it too rapidly, convergence\nstalls. Ifwearetoolenient,wefailtoconvergetoagoodenoughsolutionsincenoisekeeps\non driving us away from optimality.\n12.6.1Basics\nIn this section, we will explore more effective optimization algorithms, especially for cer-\ntain types of optimization problems that are common in practice.\nLeaky Averages\nThe previous section saw us discussing minibatch SGD as a means for accelerating com-\nputation. It also had the nice side-effect that averaging gradients reduced the amount of\nvariance. The minibatch stochastic gradient descent can be calculated by:\ng\ud835\udc61,\ud835\udc61\u00001=\ud835\udf15w1\njB\ud835\udc61j\u00d5\n\ud835\udc562B\ud835\udc61\ud835\udc53\u00b9x\ud835\udc56,w\ud835\udc61\u00001\u00ba=1\njB\ud835\udc61j\u00d5\n\ud835\udc562B\ud835\udc61h\ud835\udc56,\ud835\udc61\u00001. (12.6.1)\nTo keep the notation simple, here we used h\ud835\udc56,\ud835\udc61\u00001=\ud835\udf15w\ud835\udc53\u00b9x\ud835\udc56,w\ud835\udc61\u00001\u00baas the stochastic gra-\ndient descent for sample \ud835\udc56using the weights updated at time \ud835\udc61\u00001. It would be nice if we\ncould benefit from the effect of variance reduction even beyond averaging gradients on a\nminibatch. One option to accomplish this task is to replace the gradient computation by a\n\u201cleaky average\u201d:\nv\ud835\udc61=\ud835\udefdv\ud835\udc61\u00001\u00b8g\ud835\udc61,\ud835\udc61\u00001 (12.6.2)\nforsome\ud835\udefd2\u00b90,1\u00ba. Thiseffectivelyreplacestheinstantaneousgradientbyonethatisbeen\naveraged over multiple pastgradients. vis calledvelocity. It accumulates past gradients\nsimilar to how a heavy ball rolling down the objective function landscape integrates over\npastforces. Toseewhatishappeninginmoredetaillet\u2019sexpand v\ud835\udc61recursivelyinto\nv\ud835\udc61=\ud835\udefd2v\ud835\udc61\u00002\u00b8\ud835\udefdg\ud835\udc61\u00001,\ud835\udc61\u00002\u00b8g\ud835\udc61,\ud835\udc61\u00001=...,=\ud835\udc61\u00001\u00d5\n\ud835\udf0f=0\ud835\udefd\ud835\udf0fg\ud835\udc61\u0000\ud835\udf0f,\ud835\udc61\u0000\ud835\udf0f\u00001. (12.6.3)\nLarge\ud835\udefdamounts to a long-range average, whereas small \ud835\udefdamounts to only a slight correc-\ntion relative to a gradient method.", "mimetype": "text/plain", "start_char_idx": 1146314, "end_char_idx": 1149756, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "53153f7c-e5ae-4e9a-98dc-471e679933e4": {"__data__": {"id_": "53153f7c-e5ae-4e9a-98dc-471e679933e4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "192ff4e3-6ece-4cb3-a6d7-ce2f40203bfb", "node_type": "1", "metadata": {}, "hash": "25896bc1193a690fa10090b6483992215eded9188aae5e860a4f7d5327adec79", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a8108559-f5f7-4b72-8cca-9ee4607b6b5a", "node_type": "1", "metadata": {}, "hash": "41fb61e336e8f8dc3f6bea63a4b7d2579c4840715a29b93231e15956e787ebf2", "class_name": "RelatedNodeInfo"}}, "text": "vis calledvelocity. It accumulates past gradients\nsimilar to how a heavy ball rolling down the objective function landscape integrates over\npastforces. Toseewhatishappeninginmoredetaillet\u2019sexpand v\ud835\udc61recursivelyinto\nv\ud835\udc61=\ud835\udefd2v\ud835\udc61\u00002\u00b8\ud835\udefdg\ud835\udc61\u00001,\ud835\udc61\u00002\u00b8g\ud835\udc61,\ud835\udc61\u00001=...,=\ud835\udc61\u00001\u00d5\n\ud835\udf0f=0\ud835\udefd\ud835\udf0fg\ud835\udc61\u0000\ud835\udf0f,\ud835\udc61\u0000\ud835\udf0f\u00001. (12.6.3)\nLarge\ud835\udefdamounts to a long-range average, whereas small \ud835\udefdamounts to only a slight correc-\ntion relative to a gradient method. The new gradient replacement no longer points into the\n511 Momentum\n174direction of steepest descent on a particular instance any longer but rather in the direction\nof a weighted average of past gradients. This allows us to realize most of the benefits of\naveraging over a batch without the cost of actually computing the gradients on it. We will\nrevisit this averaging procedure in more detail later.\nTheabovereasoningformedthebasisforwhatisnowknownas accelerated gradientmeth-\nods, such as gradients with momentum. They enjoy the additional benefit of being much\nmore effective in cases where the optimization problem is ill-conditioned (i.e., where there\nare some directions where progress is much slower than in others, resembling a narrow\ncanyon). Furthermore, they allow us to average over subsequent gradients to obtain more\nstable directions of descent. Indeed, the aspect of acceleration even for noise-free convex\nproblemsisoneofthekeyreasonswhymomentumworksandwhyitworkssowell.\nAsonewouldexpect,duetoitsefficacymomentumisawell-studiedsubjectinoptimization\nfor deep learning and beyond. See e.g., the beautiful expository article174by Goh ( 2017)\nfor an in-depth analysis and interactive animation. It was proposed by Polyak ( 1964). Nes-\nterov (2018) has a detailed theoretical discussion in the context of convex optimization.\nMomentum in deep learning has been known to be beneficial for a long time. See e.g., the\ndiscussion by Sutskever etal.(2013) for details.\nAn Ill-conditioned Problem\nTo get a better understanding of the geometric properties of the momentum method we\nrevisit gradient descent, albeit with a significantly less pleasant objective function. Recall\nthatinSection12.3 weused\ud835\udc53\u00b9x\u00ba=\ud835\udc652\n1\u00b82\ud835\udc652\n2,i.e.,amoderatelydistortedellipsoidobjective.\nWe distort this function further by stretching it out in the \ud835\udc651direction via\n\ud835\udc53\u00b9x\u00ba=0.1\ud835\udc652\n1\u00b82\ud835\udc652\n2. (12.6.4)\nAsbefore\ud835\udc53hasitsminimumat \u00b90,0\u00ba. Thisfunctionis veryflatinthedirectionof \ud835\udc651. Let\u2019s\nsee what happens when we perform gradient descent as before on this new function. We\npick a learning rate of 0.4.\n%matplotlib inline\nimport torch\nfrom d2l import torch asd2l\neta =0.4\ndef f_2d (x1, x2):\nreturn 0.1 *x1**2+2*x2**2\ndef gd_2d (x1, x2, s1, s2):\nreturn (x1 -eta *0.2 *x1, x2 -eta *4*x2, 0,0)\nd2l.show_trace_2d(f_2d, d2l .train_2d(gd_2d))\nepoch 20, x1: -0.943467 , x2: -0.000073\nBy construction, the gradient in the \ud835\udc652direction is muchhigher and changes much more\n512 Optimization Algorithms\nrapidly than in the horizontal \ud835\udc651direction. Thus we are stuck between two undesirable\nchoices: if we pick a small learning rate we ensure that the solution does not diverge in\nthe\ud835\udc652direction but we are saddled with slow convergence in the \ud835\udc651direction. Conversely,\nwith a large learning rate we progress rapidly in the \ud835\udc651direction but diverge in \ud835\udc652. The\nexample below illustrates what happens even after a slight increase in learning rate from\n0.4to0.6.", "mimetype": "text/plain", "start_char_idx": 1149357, "end_char_idx": 1152666, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a8108559-f5f7-4b72-8cca-9ee4607b6b5a": {"__data__": {"id_": "a8108559-f5f7-4b72-8cca-9ee4607b6b5a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "53153f7c-e5ae-4e9a-98dc-471e679933e4", "node_type": "1", "metadata": {}, "hash": "90632e82e5356663762fc419e5cec6790dd772b6abfac35804644c62008efecf", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9abd33f9-e15a-40b1-88d6-11bae333f56a", "node_type": "1", "metadata": {}, "hash": "f5b8f4757501cb47cf7a74b82250a4cb06447bfaa38b9516ca990dd62ddc4a18", "class_name": "RelatedNodeInfo"}}, "text": "Thus we are stuck between two undesirable\nchoices: if we pick a small learning rate we ensure that the solution does not diverge in\nthe\ud835\udc652direction but we are saddled with slow convergence in the \ud835\udc651direction. Conversely,\nwith a large learning rate we progress rapidly in the \ud835\udc651direction but diverge in \ud835\udc652. The\nexample below illustrates what happens even after a slight increase in learning rate from\n0.4to0.6. Convergenceinthe \ud835\udc651directionimprovesbuttheoverallsolutionqualityismuch\nworse.\neta =0.6\nd2l.show_trace_2d(f_2d, d2l .train_2d(gd_2d))\nepoch 20, x1: -0.387814 , x2: -1673.365109\nThe Momentum Method\nThe momentum method allows us to solve the gradient descent problem described above.\nLooking at the optimization trace above we might intuit that averaging gradients over the\npast would work well. After all, in the \ud835\udc651direction this will aggregate well-aligned gradi-\nents, thus increasing the distance we cover with every step. Conversely, in the \ud835\udc652direction\nwhere gradients oscillate, an aggregate gradient will reduce step size due to oscillations\nthat cancel each other out. Using v\ud835\udc61instead of the gradient g\ud835\udc61yields the following update\nequations:\nv\ud835\udc61 \ud835\udefdv\ud835\udc61\u00001\u00b8g\ud835\udc61,\ud835\udc61\u00001,\nx\ud835\udc61 x\ud835\udc61\u00001\u0000\ud835\udf02\ud835\udc61v\ud835\udc61.(12.6.5)\n513 Momentum\nNote that for \ud835\udefd=0we recover regular gradient descent. Before delving deeper into the\nmathematical properties let\u2019s have a quick look at how the algorithm behaves in prac-\ntice.\ndef momentum_2d (x1, x2, v1, v2):\nv1=beta *v1+0.2 *x1\nv2=beta *v2+4*x2\nreturn x1-eta *v1, x2 -eta *v2, v1, v2\neta, beta =0.6,0.5\nd2l.show_trace_2d(f_2d, d2l .train_2d(momentum_2d))\nepoch 20, x1: 0.007188 , x2: 0.002553\nAs we can see, even with the same learning rate that we used before, momentum still con-\nverges well. Let\u2019s see what happens when we decrease the momentum parameter. Halving\nit to\ud835\udefd=0.25leads to a trajectory that barely converges at all. Nonetheless, it is a lot better\nthan without momentum (when the solution diverges).\neta, beta =0.6,0.25\nd2l.show_trace_2d(f_2d, d2l .train_2d(momentum_2d))\nepoch 20, x1: -0.126340 , x2: -0.186632\nNote that we can combine momentum with stochastic gradient descent and in particular,\nminibatch stochastic gradient descent. The only change is that in that case we replace the\n514 Optimization Algorithms\ngradients g\ud835\udc61,\ud835\udc61\u00001withg\ud835\udc61. Last, for convenience we initialize v0=0at time\ud835\udc61=0. Let\u2019s\nlook at what leaky averaging actually does to the updates.\nEffectiveSampleWeight\nRecall that v\ud835\udc61=\u00cd\ud835\udc61\u00001\n\ud835\udf0f=0\ud835\udefd\ud835\udf0fg\ud835\udc61\u0000\ud835\udf0f,\ud835\udc61\u0000\ud835\udf0f\u00001. In the limit the terms add up to\u00cd1\n\ud835\udf0f=0\ud835\udefd\ud835\udf0f=1\n1\u0000\ud835\udefd. In\nother words, rather than taking a step of size \ud835\udf02in gradient descent or stochastic gradient\ndescent we take a step of size\ud835\udf02\n1\u0000\ud835\udefdwhile at the same time, dealing with a potentially much\nbetterbehaveddescentdirection. Thesearetwobenefitsinone. Toillustratehowweighting\nbehaves for different choices of \ud835\udefdconsider the diagram below.", "mimetype": "text/plain", "start_char_idx": 1152258, "end_char_idx": 1155076, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9abd33f9-e15a-40b1-88d6-11bae333f56a": {"__data__": {"id_": "9abd33f9-e15a-40b1-88d6-11bae333f56a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a8108559-f5f7-4b72-8cca-9ee4607b6b5a", "node_type": "1", "metadata": {}, "hash": "41fb61e336e8f8dc3f6bea63a4b7d2579c4840715a29b93231e15956e787ebf2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e533d7a1-eac8-4b65-a0a5-a6c8fe76fc53", "node_type": "1", "metadata": {}, "hash": "f5ecfac5f610c19350aefd02af5668ac97afece4295040040c9f5618825424f3", "class_name": "RelatedNodeInfo"}}, "text": "Let\u2019s\nlook at what leaky averaging actually does to the updates.\nEffectiveSampleWeight\nRecall that v\ud835\udc61=\u00cd\ud835\udc61\u00001\n\ud835\udf0f=0\ud835\udefd\ud835\udf0fg\ud835\udc61\u0000\ud835\udf0f,\ud835\udc61\u0000\ud835\udf0f\u00001. In the limit the terms add up to\u00cd1\n\ud835\udf0f=0\ud835\udefd\ud835\udf0f=1\n1\u0000\ud835\udefd. In\nother words, rather than taking a step of size \ud835\udf02in gradient descent or stochastic gradient\ndescent we take a step of size\ud835\udf02\n1\u0000\ud835\udefdwhile at the same time, dealing with a potentially much\nbetterbehaveddescentdirection. Thesearetwobenefitsinone. Toillustratehowweighting\nbehaves for different choices of \ud835\udefdconsider the diagram below.\nd2l.set_figsize()\nbetas =[0.95 ,0.9,0.6,0]\nfor beta inbetas:\nx=torch .arange( 40).detach() .numpy()\nd2l.plt.plot(x, beta **x, label =f'beta = {beta :.2f}')\nd2l.plt.xlabel( 'time ')\nd2l.plt.legend();\n12.6.2Practical Experiments\nLet\u2019s see how momentum works in practice, i.e., when used within the context of a proper\noptimizer. For this we need a somewhat more scalable implementation.\nImplementation fromScratch\nCompared with (minibatch) stochastic gradient descent the momentum method needs to\nmaintain a set of auxiliary variables, i.e., velocity. It has the same shape as the gradients\n(and variables of the optimization problem). In the implementation below we call these\nvariables states.\ndef init_momentum_states (feature_dim):\nv_w =torch .zeros((feature_dim, 1))\nv_b =torch .zeros( 1)\nreturn (v_w, v_b)\n515 Momentum\ndef sgd_momentum (params, states, hyperparams):\nfor p, v inzip(params, states):\nwith torch .no_grad():\nv[:] =hyperparams[ 'momentum ']*v+p.grad\np[:] -=hyperparams[ 'lr']*v\np.grad .data .zero_()\nLet\u2019s see how this works in practice.\ndef train_momentum (lr, momentum, num_epochs =2):\nd2l.train_ch11(sgd_momentum, init_momentum_states(feature_dim),\n{'lr': lr, 'momentum ': momentum}, data_iter,\nfeature_dim, num_epochs)\ndata_iter, feature_dim =d2l.get_data_ch11(batch_size =10)\ntrain_momentum( 0.02 ,0.5)\nloss: 0.245 ,0.153 sec/epoch\nWhen we increase the momentum hyperparameter momentum to 0.9, it amounts to a signif-\nicantly larger effective sample size of1\n1\u00000.9=10. We reduce the learning rate slightly to\n0.01to keep matters under control.\ntrain_momentum( 0.01 ,0.9)\nloss: 0.248 ,0.109 sec/epoch\nReducing the learning rate further addresses any issue of non-smooth optimization prob-\nlems. Setting it to 0.005yields good convergence properties.\ntrain_momentum( 0.005 ,0.9)\nloss: 0.243 ,0.107 sec/epoch\n516 Optimization Algorithms\nConciseImplementation\nThere is very little to do in Gluon since the standard sgdsolver already had momentum\nbuilt in. Setting matching parameters yields a very similar trajectory.\ntrainer =torch .optim .SGD\nd2l.train_concise_ch11(trainer, { 'lr':0.005 ,'momentum ':0.9}, data_iter)\nloss: 0.250 ,0.108 sec/epoch\n12.6.3TheoreticalAnalysis\nSofarthe2Dexampleof \ud835\udc53\u00b9\ud835\udc65\u00ba=0.1\ud835\udc652\n1\u00b82\ud835\udc652\n2seemedrathercontrived. Wewillnowseethat\nthis is actually quite representative of the types of problem one might encounter, at least in\nthe case of minimizing convex quadratic objective functions.\n517 Momentum\nQuadratic ConvexFunctions\nConsider the function\n\u210e\u00b9x\u00ba=1\n2x>Qx\u00b8x>c\u00b8\ud835\udc4f. (12.6.6)\nThis is a general quadratic function. For positive definite matrices Q\u001f0, i.e., for matrices\nwith positive eigenvalues this has a minimizer at x\u0003=\u0000Q\u00001cwith minimum value \ud835\udc4f\u0000\n1\n2c>Q\u00001c.", "mimetype": "text/plain", "start_char_idx": 1154576, "end_char_idx": 1157777, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e533d7a1-eac8-4b65-a0a5-a6c8fe76fc53": {"__data__": {"id_": "e533d7a1-eac8-4b65-a0a5-a6c8fe76fc53", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9abd33f9-e15a-40b1-88d6-11bae333f56a", "node_type": "1", "metadata": {}, "hash": "f5b8f4757501cb47cf7a74b82250a4cb06447bfaa38b9516ca990dd62ddc4a18", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "96664a2f-c869-47ec-8c84-1bd6863f7f1d", "node_type": "1", "metadata": {}, "hash": "3c84e7a8ddc0dc75a4460e366b0e70d7f55768518fb5ccb18d41df04793a1133", "class_name": "RelatedNodeInfo"}}, "text": "Wewillnowseethat\nthis is actually quite representative of the types of problem one might encounter, at least in\nthe case of minimizing convex quadratic objective functions.\n517 Momentum\nQuadratic ConvexFunctions\nConsider the function\n\u210e\u00b9x\u00ba=1\n2x>Qx\u00b8x>c\u00b8\ud835\udc4f. (12.6.6)\nThis is a general quadratic function. For positive definite matrices Q\u001f0, i.e., for matrices\nwith positive eigenvalues this has a minimizer at x\u0003=\u0000Q\u00001cwith minimum value \ud835\udc4f\u0000\n1\n2c>Q\u00001c. Hence we can rewrite \u210eas\n\u210e\u00b9x\u00ba=1\n2\u00b9x\u0000Q\u00001c\u00ba>Q\u00b9x\u0000Q\u00001c\u00ba\u00b8\ud835\udc4f\u00001\n2c>Q\u00001c. (12.6.7)\nThe gradient is given by \ud835\udf15x\u210e\u00b9x\u00ba=Q\u00b9x\u0000Q\u00001c\u00ba. That is, it is given by the distance\nbetween xand the minimizer, multiplied by Q. Consequently also the velocity is a linear\ncombination of terms Q\u00b9x\ud835\udc61\u0000Q\u00001c\u00ba.\nSinceQis positive definite it can be decomposed into its eigensystem via Q=O>\ud835\udeb2Ofor\nan orthogonal (rotation) matrix Oand a diagonal matrix \ud835\udeb2of positive eigenvalues. This\nallows us to perform a change of variables from xtozdef=O\u00b9x\u0000Q\u00001c\u00bato obtain a much\nsimplified expression:\n\u210e\u00b9z\u00ba=1\n2z>\ud835\udeb2z\u00b8\ud835\udc4f0. (12.6.8)\nHere\ud835\udc4f0=\ud835\udc4f\u00001\n2c>Q\u00001c. Since Ois only an orthogonal matrix this does not perturb the\ngradients in a meaningful way. Expressed in terms of zgradient descent becomes\nz\ud835\udc61=z\ud835\udc61\u00001\u0000\ud835\udeb2z\ud835\udc61\u00001=\u00b9I\u0000\ud835\udeb2\u00baz\ud835\udc61\u00001. (12.6.9)\nTheimportantfactinthisexpressionisthatgradientdescent doesnotmix betweendifferent\neigenspaces. That is, when expressed in terms of the eigensystem of Qthe optimization\nproblem proceeds in a coordinate-wise manner. This also holds for\nv\ud835\udc61=\ud835\udefdv\ud835\udc61\u00001\u00b8\ud835\udeb2z\ud835\udc61\u00001\nz\ud835\udc61=z\ud835\udc61\u00001\u0000\ud835\udf02\u00b9\ud835\udefdv\ud835\udc61\u00001\u00b8\ud835\udeb2z\ud835\udc61\u00001\u00ba\n=\u00b9I\u0000\ud835\udf02\ud835\udeb2\u00baz\ud835\udc61\u00001\u0000\ud835\udf02\ud835\udefdv\ud835\udc61\u00001.(12.6.10)\nIn doing this we just proved the following theorem: gradient descent with and without\nmomentum for a convex quadratic function decomposes into coordinate-wise optimization\nin the direction of the eigenvectors of the quadratic matrix.\nScalar Functions\nGiven the above result let\u2019s see what happens when we minimize the function \ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udf06\n2\ud835\udc652.\nFor gradient descent we have\n\ud835\udc65\ud835\udc61\u00b81=\ud835\udc65\ud835\udc61\u0000\ud835\udf02\ud835\udf06\ud835\udc65\ud835\udc61=\u00b91\u0000\ud835\udf02\ud835\udf06\u00ba\ud835\udc65\ud835\udc61. (12.6.11)\nWheneverj1\u0000\ud835\udf02\ud835\udf06j<1thisoptimizationconvergesatanexponentialratesinceafter \ud835\udc61steps\nwe have\ud835\udc65\ud835\udc61=\u00b91\u0000\ud835\udf02\ud835\udf06\u00ba\ud835\udc61\ud835\udc650. This shows how the rate of convergence improves initially as\n518 Optimization Algorithms\n175we increase the learning rate \ud835\udf02until\ud835\udf02\ud835\udf06=1. Beyond that things diverge and for \ud835\udf02\ud835\udf06> 2the\noptimization problem diverges.", "mimetype": "text/plain", "start_char_idx": 1157331, "end_char_idx": 1159557, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "96664a2f-c869-47ec-8c84-1bd6863f7f1d": {"__data__": {"id_": "96664a2f-c869-47ec-8c84-1bd6863f7f1d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e533d7a1-eac8-4b65-a0a5-a6c8fe76fc53", "node_type": "1", "metadata": {}, "hash": "f5ecfac5f610c19350aefd02af5668ac97afece4295040040c9f5618825424f3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5fb631e2-974e-4e8a-b028-db46062cda98", "node_type": "1", "metadata": {}, "hash": "f9a2d641af648c05e7262911e84213adb972c30bb3fedb7f42721ec8fd6641e5", "class_name": "RelatedNodeInfo"}}, "text": "For gradient descent we have\n\ud835\udc65\ud835\udc61\u00b81=\ud835\udc65\ud835\udc61\u0000\ud835\udf02\ud835\udf06\ud835\udc65\ud835\udc61=\u00b91\u0000\ud835\udf02\ud835\udf06\u00ba\ud835\udc65\ud835\udc61. (12.6.11)\nWheneverj1\u0000\ud835\udf02\ud835\udf06j<1thisoptimizationconvergesatanexponentialratesinceafter \ud835\udc61steps\nwe have\ud835\udc65\ud835\udc61=\u00b91\u0000\ud835\udf02\ud835\udf06\u00ba\ud835\udc61\ud835\udc650. This shows how the rate of convergence improves initially as\n518 Optimization Algorithms\n175we increase the learning rate \ud835\udf02until\ud835\udf02\ud835\udf06=1. Beyond that things diverge and for \ud835\udf02\ud835\udf06> 2the\noptimization problem diverges.\nlambdas =[0.1,1,10,19]\neta =0.1\nd2l.set_figsize(( 6,4))\nfor lam inlambdas:\nt=torch .arange( 20).detach() .numpy()\nd2l.plt.plot(t, ( 1-eta *lam) **t, label =f'lambda = {lam:.2f}')\nd2l.plt.xlabel( 'time ')\nd2l.plt.legend();\nTo analyze convergence in the case of momentum we begin by rewriting the update equa-\ntions in terms of two scalars: one for \ud835\udc65and one for velocity \ud835\udc63. This yields:\n\u0014\ud835\udc63\ud835\udc61\u00b81\n\ud835\udc65\ud835\udc61\u00b81\u0015\n=\u0014\ud835\udefd\ud835\udf06\n\u0000\ud835\udf02\ud835\udefd\u00b91\u0000\ud835\udf02\ud835\udf06\u00ba\u0015 \u0014\ud835\udc63\ud835\udc61\n\ud835\udc65\ud835\udc61\u0015\n=R\u00b9\ud835\udefd,\ud835\udf02,\ud835\udf06\u00ba\u0014\ud835\udc63\ud835\udc61\n\ud835\udc65\ud835\udc61\u0015\n. (12.6.12)\nWe used Rto denote the 2\u00022governing convergence behavior. After \ud835\udc61steps the initial\nchoice\u00bb\ud835\udc630,\ud835\udc650\u00bcbecomes R\u00b9\ud835\udefd,\ud835\udf02,\ud835\udf06\u00ba\ud835\udc61\u00bb\ud835\udc630,\ud835\udc650\u00bc. Hence, it is up to the eigenvalues of Rto\ndetermine the speed of convergence. See the Distill post175of Goh ( 2017) for a great\nanimation and Flammarion and Bach ( 2015) for a detailed analysis. One can show that\n0< \ud835\udf02\ud835\udf06 < 2\u00b82\ud835\udefdvelocity converges. This is a larger range of feasible parameters when\ncompared to 0< \ud835\udf02\ud835\udf06 < 2for gradient descent. It also suggests that in general large values\nof\ud835\udefdare desirable. Further details require a fair amount of technical detail and we suggest\nthat the interested reader consult the original publications.\n12.6.4Summary\n\u000fMomentumreplacesgradientswithaleakyaverageoverpastgradients. Thisaccelerates\nconvergence significantly.\n\u000fItisdesirableforbothnoise-freegradientdescentand(noisy)stochasticgradientdescent.\n\u000fMomentum prevents stalling of the optimization process that is much more likely to\noccur for stochastic gradient descent.\n519 Adagrad\n176\u000fThe effective number of gradients is given by1\n1\u0000\ud835\udefddue to exponentiated downweighting\nof past data.\n\u000fIn the case of convex quadratic problems this can be analyzed explicitly in detail.\n\u000fImplementation is quite straightforward but it requires us to store an additional state\nvector (velocity v).\n12.6.5Exercises\n1.Use other combinations of momentum hyperparameters and learning rates and observe\nand analyze the different experimental results.\n2.Tryoutgradientdescentandmomentumforaquadraticproblemwhereyouhavemulti-\npleeigenvalues, i.e., \ud835\udc53\u00b9\ud835\udc65\u00ba=1\n2\u00cd\n\ud835\udc56\ud835\udf06\ud835\udc56\ud835\udc652\n\ud835\udc56, e.g.,\ud835\udf06\ud835\udc56=2\u0000\ud835\udc56. Plot howthevaluesof \ud835\udc65decrease\nfor the initialization \ud835\udc65\ud835\udc56=1.\n3.Derive minimum value and minimizer for \u210e\u00b9x\u00ba=1\n2x>Qx\u00b8x>c\u00b8\ud835\udc4f.\n4.What changes when we perform stochastic gradient descent with momentum? What\nhappens when we use minibatch stochastic gradient descent with momentum? Experi-\nment with the parameters?\nDiscussions176.\n12.7Adagrad\nLet\u2019s begin by considering learning problems with features that occur infrequently.", "mimetype": "text/plain", "start_char_idx": 1159188, "end_char_idx": 1161995, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5fb631e2-974e-4e8a-b028-db46062cda98": {"__data__": {"id_": "5fb631e2-974e-4e8a-b028-db46062cda98", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "96664a2f-c869-47ec-8c84-1bd6863f7f1d", "node_type": "1", "metadata": {}, "hash": "3c84e7a8ddc0dc75a4460e366b0e70d7f55768518fb5ccb18d41df04793a1133", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "04102463-f094-42ee-afb1-96d4d77f8e27", "node_type": "1", "metadata": {}, "hash": "10423a28597f47a4b804535ddb746de89e86a5aabddc1bd3484077d8426b8578", "class_name": "RelatedNodeInfo"}}, "text": "2.Tryoutgradientdescentandmomentumforaquadraticproblemwhereyouhavemulti-\npleeigenvalues, i.e., \ud835\udc53\u00b9\ud835\udc65\u00ba=1\n2\u00cd\n\ud835\udc56\ud835\udf06\ud835\udc56\ud835\udc652\n\ud835\udc56, e.g.,\ud835\udf06\ud835\udc56=2\u0000\ud835\udc56. Plot howthevaluesof \ud835\udc65decrease\nfor the initialization \ud835\udc65\ud835\udc56=1.\n3.Derive minimum value and minimizer for \u210e\u00b9x\u00ba=1\n2x>Qx\u00b8x>c\u00b8\ud835\udc4f.\n4.What changes when we perform stochastic gradient descent with momentum? What\nhappens when we use minibatch stochastic gradient descent with momentum? Experi-\nment with the parameters?\nDiscussions176.\n12.7Adagrad\nLet\u2019s begin by considering learning problems with features that occur infrequently.\n12.7.1SparseFeatures and Learning Rates\nImagine that we are training a language model. To get good accuracy we typically want\nto decrease the learning rate as we keep on training, usually at a rate of O\u00b9\ud835\udc61\u00001\n2\u00baor slower.\nNowconsideramodeltrainingonsparsefeatures,i.e.,featuresthatoccuronlyinfrequently.\nThis is common for natural language, e.g., it is a lot less likely that we will see the word\npreconditioning thanlearning . However,itisalsocommoninotherareassuchascomputa-\ntional advertising and personalized collaborative filtering. After all, there are many things\nthat are of interest only for a small number of people.\nParameters associated with infrequent features only receive meaningful updates whenever\nthese features occur. Given a decreasing learning rate we might end up in a situation\nwhere the parameters for common features converge rather quickly to their optimal values,\nwhereas for infrequent features we are still short of observing them sufficiently frequently\nbefore their optimal values can be determined. In other words, the learning rate either\ndecreases too slowly for frequent features or too quickly for infrequent ones.\n520 Optimization Algorithms\nA possible hack to redress this issue would be to count the number of times we see a par-\nticular feature and to use this as a clock for adjusting learning rates. That is, rather than\nchoosing a learning rate of the form \ud835\udf02=\ud835\udf020p\ud835\udc61\u00b8\ud835\udc50we could use \ud835\udf02\ud835\udc56=\ud835\udf020p\n\ud835\udc60\u00b9\ud835\udc56,\ud835\udc61\u00ba\u00b8\ud835\udc50. Here\ud835\udc60\u00b9\ud835\udc56,\ud835\udc61\u00ba\ncounts the number of nonzeros for feature \ud835\udc56that we have observed up to time \ud835\udc61. This is ac-\ntually quite easy to implement at no meaningful overhead. However, it fails whenever we\ndo not quite have sparsity but rather just data where the gradients are often very small and\nonly rarely large. After all, it is unclear where one would draw the line between something\nthat qualifies as an observed feature or not.\nAdagrad by Duchi et al.(2011) addresses this by replacing the rather crude counter \ud835\udc60\u00b9\ud835\udc56,\ud835\udc61\u00ba\nby an aggregate of the squares of previously observed gradients. In particular, it uses\n\ud835\udc60\u00b9\ud835\udc56,\ud835\udc61\u00b81\u00ba=\ud835\udc60\u00b9\ud835\udc56,\ud835\udc61\u00ba\u00b8\u00b9\ud835\udf15\ud835\udc56\ud835\udc53\u00b9x\u00ba\u00ba2asameanstoadjustthelearningrate. Thishastwobenefits:\nfirst, we no longer need to decide just when a gradient is large enough. Second, it scales\nautomatically with the magnitude of the gradients. Coordinates that routinely correspond\nto large gradients are scaled down significantly, whereas others with small gradients re-\nceive a much more gentle treatment. In practice this leads to a very effective optimization\nprocedure for computational advertising and related problems. But this hides some of the\nadditional benefits inherent in Adagrad that are best understood in the context of precondi-\ntioning.\n12.7.2Preconditioning\nConvex optimization problems are good for analyzing the characteristics of algorithms.\nAfter all, for most nonconvex problems it is difficult to derive meaningful theoretical guar-\nantees, but intuition andinsightoften carry over. Let\u2019s look at the problem of minimizing\n\ud835\udc53\u00b9x\u00ba=1\n2x>Qx\u00b8c>x\u00b8\ud835\udc4f.", "mimetype": "text/plain", "start_char_idx": 1161451, "end_char_idx": 1164974, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "04102463-f094-42ee-afb1-96d4d77f8e27": {"__data__": {"id_": "04102463-f094-42ee-afb1-96d4d77f8e27", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5fb631e2-974e-4e8a-b028-db46062cda98", "node_type": "1", "metadata": {}, "hash": "f9a2d641af648c05e7262911e84213adb972c30bb3fedb7f42721ec8fd6641e5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9b27d44a-be18-44da-a473-6088b9d5de91", "node_type": "1", "metadata": {}, "hash": "4dc8da64917e7ce67f1a4fb3c676421b406c543aaf4173ad48ba19794d9df640", "class_name": "RelatedNodeInfo"}}, "text": "Second, it scales\nautomatically with the magnitude of the gradients. Coordinates that routinely correspond\nto large gradients are scaled down significantly, whereas others with small gradients re-\nceive a much more gentle treatment. In practice this leads to a very effective optimization\nprocedure for computational advertising and related problems. But this hides some of the\nadditional benefits inherent in Adagrad that are best understood in the context of precondi-\ntioning.\n12.7.2Preconditioning\nConvex optimization problems are good for analyzing the characteristics of algorithms.\nAfter all, for most nonconvex problems it is difficult to derive meaningful theoretical guar-\nantees, but intuition andinsightoften carry over. Let\u2019s look at the problem of minimizing\n\ud835\udc53\u00b9x\u00ba=1\n2x>Qx\u00b8c>x\u00b8\ud835\udc4f.\nAswesawin Section12.6 ,itispossibletorewritethisproblemintermsofitseigendecom-\nposition Q=U>\ud835\udeb2Uto arrive at a much simplified problem where each coordinate can be\nsolved individually:\n\ud835\udc53\u00b9x\u00ba=\u00af\ud835\udc53\u00b9\u00afx\u00ba=1\n2\u00afx>\ud835\udeb2\u00afx\u00b8\u00afc>\u00afx\u00b8\ud835\udc4f. (12.7.1)\nHere we used \u00afx=Uxand consequently \u00afc=Uc. The modified problem has as its min-\nimizer \u00afx=\u0000\ud835\udeb2\u00001\u00afcand minimum value \u00001\n2\u00afc>\ud835\udeb2\u00001\u00afc\u00b8\ud835\udc4f. This is much easier to compute\nsince\ud835\udeb2is a diagonal matrix containing the eigenvalues of Q.\nIf we perturb cslightly we would hope to find only slight changes in the minimizer of \ud835\udc53.\nUnfortunately this is not the case. While slight changes in clead to equally slight changes\nin\u00afc, this is not the case for the minimizer of \ud835\udc53(and of \u00af\ud835\udc53respectively). Whenever the\neigenvalues \ud835\udeb2\ud835\udc56are large we will see only small changes in \u00af\ud835\udc65\ud835\udc56and in the minimum of \u00af\ud835\udc53.\nConversely, for small \ud835\udeb2\ud835\udc56changes in \u00af\ud835\udc65\ud835\udc56can be dramatic. The ratio between the largest and\nthe smallest eigenvalue is called the condition number of an optimization problem.\n\ud835\udf05=\ud835\udeb21\n\ud835\udeb2\ud835\udc51. (12.7.2)\nIftheconditionnumber \ud835\udf05islarge,itisdifficulttosolvetheoptimizationproblemaccurately.\nWe need to ensure that we are careful in getting a large dynamic range of values right. Our\n521 Adagrad\nanalysis leads to an obvious, albeit somewhat naive question: couldn\u2019t we simply \u201cfix\u201d the\nproblem by distorting the space such that all eigenvalues are 1. In theory this is quite easy:\nwe only need the eigenvalues and eigenvectors of Qto rescale the problem from xto one\ninzdef=\ud835\udeb21\n2Ux. Inthenewcoordinatesystem x>Qxcouldbesimplifiedto kzk2. Alas,this\nis a rather impractical suggestion. Computing eigenvalues and eigenvectors is in general\nmuchmore expensive than solving the actual problem.\nWhile computing eigenvalues exactly might be expensive, guessing them and computing\nthem even somewhat approximately may already be a lot better than not doing anything at\nall. In particular, we could use the diagonal entries of Qand rescale it accordingly. This is\nmuchcheaper than computing eigenvalues.\n\u02dcQ=diag\u00001\n2\u00b9Q\u00baQdiag\u00001\n2\u00b9Q\u00ba. (12.7.3)\nIn this case we have \u02dcQ\ud835\udc56\ud835\udc57=Q\ud835\udc56\ud835\udc57\u009dp\nQ\ud835\udc56\ud835\udc56Q\ud835\udc57\ud835\udc57and specifically \u02dcQ\ud835\udc56\ud835\udc56=1for all\ud835\udc56. In most cases\nthis simplifies the condition number considerably. For instance, the cases we discussed\npreviously, this would entirely eliminate the problem at hand since the problem is axis\naligned.\nUnfortunately we face yet another problem: in deep learning we typically do not even have\naccess to the second derivative of the objective function: for x2R\ud835\udc51the second derivative\neven on a minibatch may require O\u00b9\ud835\udc512\u00baspace and work to compute, thus making it practi-\ncally infeasible.", "mimetype": "text/plain", "start_char_idx": 1164182, "end_char_idx": 1167540, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9b27d44a-be18-44da-a473-6088b9d5de91": {"__data__": {"id_": "9b27d44a-be18-44da-a473-6088b9d5de91", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "04102463-f094-42ee-afb1-96d4d77f8e27", "node_type": "1", "metadata": {}, "hash": "10423a28597f47a4b804535ddb746de89e86a5aabddc1bd3484077d8426b8578", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5e50fe11-6130-43e7-8024-d917ecfcf59f", "node_type": "1", "metadata": {}, "hash": "0c09706e7e90054edcc2feafd5705f0b9fc563004ecf4c9b4952402a3f0203d9", "class_name": "RelatedNodeInfo"}}, "text": "(12.7.3)\nIn this case we have \u02dcQ\ud835\udc56\ud835\udc57=Q\ud835\udc56\ud835\udc57\u009dp\nQ\ud835\udc56\ud835\udc56Q\ud835\udc57\ud835\udc57and specifically \u02dcQ\ud835\udc56\ud835\udc56=1for all\ud835\udc56. In most cases\nthis simplifies the condition number considerably. For instance, the cases we discussed\npreviously, this would entirely eliminate the problem at hand since the problem is axis\naligned.\nUnfortunately we face yet another problem: in deep learning we typically do not even have\naccess to the second derivative of the objective function: for x2R\ud835\udc51the second derivative\neven on a minibatch may require O\u00b9\ud835\udc512\u00baspace and work to compute, thus making it practi-\ncally infeasible. The ingenious idea of Adagrad is to use a proxy for that elusive diagonal\nof the Hessian that is both relatively cheap to compute and effective\u2014the magnitude of the\ngradient itself.\nIn order to see why this works, let\u2019s look at \u00af\ud835\udc53\u00b9\u00afx\u00ba. We have that\n\ud835\udf15\u00afx\u00af\ud835\udc53\u00b9\u00afx\u00ba=\ud835\udeb2\u00afx\u00b8\u00afc=\ud835\udeb2\u00b9\u00afx\u0000\u00afx0\u00ba, (12.7.4)\nwhere \u00afx0is the minimizer of \u00af\ud835\udc53. Hence the magnitude of the gradient depends both on \ud835\udeb2\nand the distance from optimality. If \u00afx\u0000\u00afx0did not change, this would be all that is needed.\nAfter all, in this case the magnitude of the gradient \ud835\udf15\u00afx\u00af\ud835\udc53\u00b9\u00afx\u00basuffices. Since AdaGrad is a\nstochastic gradient descent algorithm, we will see gradients with nonzero variance even at\noptimality. As a result we can safely use the variance of the gradients as a cheap proxy for\nthe scale of the Hessian. A thorough analysis is beyond the scope of this section (it would\nbe several pages). We refer the reader to ( Duchietal., 2011) for details.\n12.7.3The Algorithm\nLet\u2019s formalize the discussion from above. We use the variable s\ud835\udc61to accumulate past gra-\ndient variance as follows.\ng\ud835\udc61=\ud835\udf15w\ud835\udc59\u00b9\ud835\udc66\ud835\udc61, \ud835\udc53\u00b9x\ud835\udc61,w\u00ba\u00ba,\ns\ud835\udc61=s\ud835\udc61\u00001\u00b8g2\n\ud835\udc61,\nw\ud835\udc61=w\ud835\udc61\u00001\u0000\ud835\udf02ps\ud835\udc61\u00b8\ud835\udf16\u0001g\ud835\udc61.(12.7.5)\n522 Optimization Algorithms\nHeretheoperationareappliedcoordinatewise. Thatis, v2hasentries\ud835\udc632\n\ud835\udc56. Likewise1p\ud835\udc63has\nentries1p\ud835\udc63\ud835\udc56andu\u0001vhas entries\ud835\udc62\ud835\udc56\ud835\udc63\ud835\udc56. As before\ud835\udf02is the learning rate and \ud835\udf16is an additive\nconstant that ensures that we do not divide by 0. Last, we initialize s0=0.\nJust like in the case of momentum we need to keep track of an auxiliary variable, in this\ncase to allow for an individual learning rate per coordinate. This does not increase the cost\nofAdagradsignificantlyrelativetoSGD,simplysincethemaincostistypicallytocompute\n\ud835\udc59\u00b9\ud835\udc66\ud835\udc61, \ud835\udc53\u00b9x\ud835\udc61,w\u00ba\u00baand its derivative.\nNotethataccumulatingsquaredgradientsin s\ud835\udc61meansthat s\ud835\udc61growsessentiallyatlinearrate\n(somewhat slower than linearly in practice, since the gradients initially diminish). This\nleads to anO\u00b9\ud835\udc61\u00001\n2\u00balearning rate, albeit adjusted on a per coordinate basis. For convex\nproblems this is perfectly adequate. In deep learning, though, we might want to decrease\nthe learning rate rather more slowly. This led to a number of Adagrad variants that we will\ndiscuss in the subsequent chapters. For now let\u2019s see how it behaves in a quadratic convex\nproblem. We use the same problem as before:\n\ud835\udc53\u00b9x\u00ba=0.1\ud835\udc652\n1\u00b82\ud835\udc652\n2. (12.7.6)\nWe are going to implement Adagrad using the same learning rate previously, i.e., \ud835\udf02=0.4.\nAs we can see, the iterative trajectory of the independent variable is smoother.", "mimetype": "text/plain", "start_char_idx": 1166978, "end_char_idx": 1169990, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5e50fe11-6130-43e7-8024-d917ecfcf59f": {"__data__": {"id_": "5e50fe11-6130-43e7-8024-d917ecfcf59f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9b27d44a-be18-44da-a473-6088b9d5de91", "node_type": "1", "metadata": {}, "hash": "4dc8da64917e7ce67f1a4fb3c676421b406c543aaf4173ad48ba19794d9df640", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c768ba46-27d0-4b6a-8e27-9cdd8abb1e60", "node_type": "1", "metadata": {}, "hash": "712c055a0fa816c11c7864056b3d85c3ca32336d6215fd44b4c564f3106e8860", "class_name": "RelatedNodeInfo"}}, "text": "This\nleads to anO\u00b9\ud835\udc61\u00001\n2\u00balearning rate, albeit adjusted on a per coordinate basis. For convex\nproblems this is perfectly adequate. In deep learning, though, we might want to decrease\nthe learning rate rather more slowly. This led to a number of Adagrad variants that we will\ndiscuss in the subsequent chapters. For now let\u2019s see how it behaves in a quadratic convex\nproblem. We use the same problem as before:\n\ud835\udc53\u00b9x\u00ba=0.1\ud835\udc652\n1\u00b82\ud835\udc652\n2. (12.7.6)\nWe are going to implement Adagrad using the same learning rate previously, i.e., \ud835\udf02=0.4.\nAs we can see, the iterative trajectory of the independent variable is smoother. However,\nduetothecumulativeeffectof \ud835\udc94\ud835\udc61,thelearningratecontinuouslydecays,sotheindependent\nvariable does not move as much during later stages of iteration.\n%matplotlib inline\nimport math\nimport torch\nfrom d2l import torch asd2l\ndef adagrad_2d (x1, x2, s1, s2):\neps =1e-6\ng1, g2 =0.2 *x1, 4*x2\ns1+=g1**2\ns2+=g2**2\nx1-=eta /math .sqrt(s1 +eps) *g1\nx2-=eta /math .sqrt(s2 +eps) *g2\nreturn x1, x2, s1, s2\ndef f_2d (x1, x2):\nreturn 0.1 *x1**2+2*x2**2\neta =0.4\nd2l.show_trace_2d(f_2d, d2l .train_2d(adagrad_2d))\nepoch 20, x1: -2.382563 , x2: -0.158591\nAs we increase the learning rate to 2we see much better behavior. This already indicates\nthatthedecreaseinlearningratemightberatheraggressive,eveninthenoise-freecaseand\nwe need to ensure that parameters converge appropriately.\n523 Adagrad\neta =2\nd2l.show_trace_2d(f_2d, d2l .train_2d(adagrad_2d))\nepoch 20, x1: -0.002295 , x2: -0.000000\n12.7.4Implementation fromScratch\nJust like the momentum method, Adagrad needs to maintain a state variable of the same\nshape as the parameters.\ndef init_adagrad_states (feature_dim):\ns_w =torch .zeros((feature_dim, 1))\ns_b =torch .zeros( 1)\nreturn (s_w, s_b)\ndef adagrad (params, states, hyperparams):\neps =1e-6\nfor p, s inzip(params, states):\nwith torch .no_grad():\ns[:] +=torch .square(p .grad)\np[:] -=hyperparams[ 'lr']*p.grad /torch .sqrt(s +eps)\np.grad .data .zero_()\nCompared to the experiment in Section 12.5 we use a larger learning rate to train the\nmodel.\n524 Optimization Algorithms\ndata_iter, feature_dim =d2l.get_data_ch11(batch_size =10)\nd2l.train_ch11(adagrad, init_adagrad_states(feature_dim),\n{'lr':0.1}, data_iter, feature_dim);\nloss: 0.243 ,0.162 sec/epoch\n12.7.5ConciseImplementation\nUsing the Trainer instance of the algorithm adagrad , we can invoke the Adagrad algo-\nrithm in Gluon.\ntrainer =torch .optim .Adagrad\nd2l.train_concise_ch11(trainer, { 'lr':0.1}, data_iter)\nloss: 0.242 ,0.129 sec/epoch\n12.7.6Summary\n\u000fAdagrad decreases the learning rate dynamically on a per-coordinate basis.\n\u000fIt uses the magnitude of the gradient as a means of adjusting how quickly progress is\nachieved - coordinates with large gradients are compensated with a smaller learning\nrate.\n525 RMSProp\n177\n178\u000fComputing the exact second derivative is typically infeasible in deep learning problems\ndue to memory and computational constraints. The gradient can be a useful proxy.\n\u000fIf the optimization problem has a rather uneven structure Adagrad can help mitigate the\ndistortion.\n\u000fAdagrad is particularly effective for sparse features where the learning rate needs to de-\ncrease more slowly for infrequently occurring terms.", "mimetype": "text/plain", "start_char_idx": 1169384, "end_char_idx": 1172596, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c768ba46-27d0-4b6a-8e27-9cdd8abb1e60": {"__data__": {"id_": "c768ba46-27d0-4b6a-8e27-9cdd8abb1e60", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5e50fe11-6130-43e7-8024-d917ecfcf59f", "node_type": "1", "metadata": {}, "hash": "0c09706e7e90054edcc2feafd5705f0b9fc563004ecf4c9b4952402a3f0203d9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "df34c738-7989-48e0-a326-a69724d76c85", "node_type": "1", "metadata": {}, "hash": "613c98b454a327209f78856f25879d9d6f5a8c3f5dbee36e66b597d2ede1b55e", "class_name": "RelatedNodeInfo"}}, "text": "trainer =torch .optim .Adagrad\nd2l.train_concise_ch11(trainer, { 'lr':0.1}, data_iter)\nloss: 0.242 ,0.129 sec/epoch\n12.7.6Summary\n\u000fAdagrad decreases the learning rate dynamically on a per-coordinate basis.\n\u000fIt uses the magnitude of the gradient as a means of adjusting how quickly progress is\nachieved - coordinates with large gradients are compensated with a smaller learning\nrate.\n525 RMSProp\n177\n178\u000fComputing the exact second derivative is typically infeasible in deep learning problems\ndue to memory and computational constraints. The gradient can be a useful proxy.\n\u000fIf the optimization problem has a rather uneven structure Adagrad can help mitigate the\ndistortion.\n\u000fAdagrad is particularly effective for sparse features where the learning rate needs to de-\ncrease more slowly for infrequently occurring terms.\n\u000fOndeeplearningproblemsAdagradcansometimesbetooaggressiveinreducinglearn-\ningrates. Wewilldiscussstrategiesformitigatingthisinthecontextof Section12.10 .\n12.7.7Exercises\n1.Prove that for an orthogonal matrix Uand a vector cthe following holds: kc\u0000\ufb03k2=\nkUc\u0000U\ufb03k2. Whydoesthismeanthatthemagnitudeofperturbationsdoesnotchange\nafter an orthogonal change of variables?\n2.Try out Adagrad for \ud835\udc53\u00b9x\u00ba=0.1\ud835\udc652\n1\u00b82\ud835\udc652\n2and also for the objective function was rotated\nby 45 degrees, i.e., \ud835\udc53\u00b9x\u00ba=0.1\u00b9\ud835\udc651\u00b8\ud835\udc652\u00ba2\u00b82\u00b9\ud835\udc651\u0000\ud835\udc652\u00ba2. Does it behave differently?\n3.ProveGerschgorin\u2019s circle theorem177which states that eigenvalues \ud835\udf06\ud835\udc56of a matrix M\nsatisfyj\ud835\udf06\ud835\udc56\u0000M\ud835\udc57\ud835\udc57j\u0014\u00cd\n\ud835\udc58\u2260\ud835\udc57jM\ud835\udc57\ud835\udc58jfor at least one choice of \ud835\udc57.\n4.What does Gerschgorin\u2019s theorem tell us about the eigenvalues of the diagonally pre-\nconditioned matrix diag\u00001\n2\u00b9M\u00baMdiag\u00001\n2\u00b9M\u00ba?\n5.TryoutAdagradforaproperdeepnetwork,suchas Section7.6 whenappliedtoFashion-\nMNIST.\n6.How would you need to modify Adagrad to achieve a less aggressive decay in learning\nrate?\nDiscussions178.\n12.8RMSProp\nOne of the key issues in Section 12.7 is that the learning rate decreases at a predefined\nschedule of effectively O\u00b9\ud835\udc61\u00001\n2\u00ba. While this is generally appropriate for convex problems,\nit might not be ideal for nonconvex ones, such as those encountered in deep learning. Yet,\nthe coordinate-wise adaptivity of Adagrad is highly desirable as a preconditioner.\nTieleman and Hinton ( 2012) proposed the RMSProp algorithm as a simple fix to decouple\nrate scheduling from coordinate-adaptive learning rates. The issue is that Adagrad accu-\nmulates the squares of the gradient g\ud835\udc61into a state vector s\ud835\udc61=s\ud835\udc61\u00001\u00b8g2\n\ud835\udc61. As a result s\ud835\udc61\nkeeps on growing without bound due to the lack of normalization, essentially linearly as\nthe algorithm converges.\n526 Optimization Algorithms\nOne way of fixing this problem would be to use s\ud835\udc61\u009d\ud835\udc61. For reasonable distributions of g\ud835\udc61\nthis will converge. Unfortunately it might take a very long time until the limit behavior\nstarts to matter since the procedure remembers the full trajectory of values. An alternative\nis to use a leaky average in the same way we used in the momentum method, i.e., s\ud835\udc61 \n\ud835\udefes\ud835\udc61\u00001\u00b8\u00b91\u0000\ud835\udefe\u00bag2\n\ud835\udc61for some parameter \ud835\udefe > 0. Keeping all other parts unchanged yields\nRMSProp.\n12.8.1The Algorithm\nLet\u2019s write out the equations in detail.\ns\ud835\udc61 \ud835\udefes\ud835\udc61\u00001\u00b8\u00b91\u0000\ud835\udefe\u00bag2\n\ud835\udc61,\nx\ud835\udc61 x\ud835\udc61\u00001\u0000\ud835\udf02ps\ud835\udc61\u00b8\ud835\udf16\fg\ud835\udc61.", "mimetype": "text/plain", "start_char_idx": 1171779, "end_char_idx": 1174905, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "df34c738-7989-48e0-a326-a69724d76c85": {"__data__": {"id_": "df34c738-7989-48e0-a326-a69724d76c85", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c768ba46-27d0-4b6a-8e27-9cdd8abb1e60", "node_type": "1", "metadata": {}, "hash": "712c055a0fa816c11c7864056b3d85c3ca32336d6215fd44b4c564f3106e8860", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c8f15898-4e03-4ef7-9153-4eca7d45994b", "node_type": "1", "metadata": {}, "hash": "3e61d4de0c340804c5d5841c82a83be294d36747ce97857ef9a7a968b33ef318", "class_name": "RelatedNodeInfo"}}, "text": "For reasonable distributions of g\ud835\udc61\nthis will converge. Unfortunately it might take a very long time until the limit behavior\nstarts to matter since the procedure remembers the full trajectory of values. An alternative\nis to use a leaky average in the same way we used in the momentum method, i.e., s\ud835\udc61 \n\ud835\udefes\ud835\udc61\u00001\u00b8\u00b91\u0000\ud835\udefe\u00bag2\n\ud835\udc61for some parameter \ud835\udefe > 0. Keeping all other parts unchanged yields\nRMSProp.\n12.8.1The Algorithm\nLet\u2019s write out the equations in detail.\ns\ud835\udc61 \ud835\udefes\ud835\udc61\u00001\u00b8\u00b91\u0000\ud835\udefe\u00bag2\n\ud835\udc61,\nx\ud835\udc61 x\ud835\udc61\u00001\u0000\ud835\udf02ps\ud835\udc61\u00b8\ud835\udf16\fg\ud835\udc61.(12.8.1)\nThe constant \ud835\udf16 >0is typically set to 10\u00006to ensure that we do not suffer from division by\nzerooroverlylargestepsizes. Giventhisexpansionwearenowfreetocontrolthelearning\nrate\ud835\udf02independently of the scaling that is applied on a per-coordinate basis. In terms of\nleaky averages we can apply the same reasoning as previously applied in the case of the\nmomentum method. Expanding the definition of s\ud835\udc61yields\ns\ud835\udc61=\u00b91\u0000\ud835\udefe\u00bag2\n\ud835\udc61\u00b8\ud835\udefes\ud835\udc61\u00001\n=\u00b91\u0000\ud835\udefe\u00ba\u0010\ng2\n\ud835\udc61\u00b8\ud835\udefeg2\n\ud835\udc61\u00001\u00b8\ud835\udefe2g\ud835\udc61\u00002\u00b8...,\u0011\n.(12.8.2)\nAs before in Section 12.6 we use 1\u00b8\ud835\udefe\u00b8\ud835\udefe2\u00b8...,=1\n1\u0000\ud835\udefe. Hence the sum of weights is\nnormalized to 1with a half-life time of an observation of \ud835\udefe\u00001. Let\u2019s visualize the weights\nfor the past 40 time steps for various choices of \ud835\udefe.\nimport math\nimport torch\nfrom d2l import torch asd2l\nd2l.set_figsize()\ngammas =[0.95 ,0.9,0.8,0.7]\nfor gamma ingammas:\nx=torch .arange( 40).detach() .numpy()\nd2l.plt.plot(x, ( 1-gamma) *gamma **x, label =f'gamma = {gamma :.2f}')\nd2l.plt.xlabel( 'time ');\n12.8.2Implementation fromScratch\nAs before we use the quadratic function \ud835\udc53\u00b9x\u00ba=0.1\ud835\udc652\n1\u00b82\ud835\udc652\n2to observe the trajectory of\nRMSProp. Recall that in Section 12.7 , when we used Adagrad with a learning rate of\n0.4, the variables moved only very slowly in the later stages of the algorithm since the\nlearning rate decreased too quickly. Since \ud835\udf02is controlled separately this does not happen\nwith RMSProp.\n527 RMSProp\ndef rmsprop_2d (x1, x2, s1, s2):\ng1, g2, eps =0.2 *x1, 4*x2, 1e-6\ns1=gamma *s1+(1-gamma) *g1**2\ns2=gamma *s2+(1-gamma) *g2**2\nx1-=eta /math .sqrt(s1 +eps) *g1\nx2-=eta /math .sqrt(s2 +eps) *g2\nreturn x1, x2, s1, s2\ndef f_2d (x1, x2):\nreturn 0.1 *x1**2+2*x2**2\neta, gamma =0.4,0.9\nd2l.show_trace_2d(f_2d, d2l .train_2d(rmsprop_2d))\nepoch 20, x1: -0.010599 , x2: 0.000000\nNext, we implement RMSProp to be used in a deep network. This is equally straightfor-\nward.", "mimetype": "text/plain", "start_char_idx": 1174413, "end_char_idx": 1176725, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c8f15898-4e03-4ef7-9153-4eca7d45994b": {"__data__": {"id_": "c8f15898-4e03-4ef7-9153-4eca7d45994b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "df34c738-7989-48e0-a326-a69724d76c85", "node_type": "1", "metadata": {}, "hash": "613c98b454a327209f78856f25879d9d6f5a8c3f5dbee36e66b597d2ede1b55e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ed18ea18-8c89-4647-9698-2bbacf3b418e", "node_type": "1", "metadata": {}, "hash": "79a7c69062205d37293aaafbaa99b8d2d6d58c70368dfb648e7349cacdf6eee7", "class_name": "RelatedNodeInfo"}}, "text": "This is equally straightfor-\nward.\ndef init_rmsprop_states (feature_dim):\ns_w =torch .zeros((feature_dim, 1))\ns_b =torch .zeros( 1)\nreturn (s_w, s_b)\ndef rmsprop (params, states, hyperparams):\ngamma, eps =hyperparams[ 'gamma '],1e-6\n(continues on next page)\n528 Optimization Algorithms\n(continued from previous page)\nfor p, s inzip(params, states):\nwith torch .no_grad():\ns[:] =gamma *s+(1-gamma) *torch .square(p .grad)\np[:] -=hyperparams[ 'lr']*p.grad /torch .sqrt(s +eps)\np.grad .data .zero_()\nWesettheinitiallearningrateto0.01andtheweightingterm \ud835\udefeto0.9. Thatis, saggregates\non average over the past 1\u009d\u00b91\u0000\ud835\udefe\u00ba=10observations of the square gradient.\ndata_iter, feature_dim =d2l.get_data_ch11(batch_size =10)\nd2l.train_ch11(rmsprop, init_rmsprop_states(feature_dim),\n{'lr':0.01 ,'gamma ':0.9}, data_iter, feature_dim);\nloss: 0.245 ,0.245 sec/epoch\n12.8.3ConciseImplementation\nSince RMSProp is a rather popular algorithm it is also available in the Trainer instance.\nAll we need to do is instantiate it using an algorithm named rmsprop , assigning\ud835\udefeto the\nparameter gamma1.\ntrainer =torch .optim .RMSprop\nd2l.train_concise_ch11(trainer, { 'lr':0.01 ,'alpha ':0.9},\ndata_iter)\nloss: 0.246 ,0.129 sec/epoch\n12.8.4Summary\n\u000fRMSProp is very similar to Adagrad insofar as both use the square of the gradient to\nscale coefficients.\n\u000fRMSProp shares with momentum the leaky averaging. However, RMSProp uses the\ntechnique to adjust the coefficient-wise preconditioner.\n529 Adadelta\n179\u000fThe learning rate needs to be scheduled by the experimenter in practice.\n\u000fThe coefficient \ud835\udefedetermines how long the history is when adjusting the per-coordinate\nscale.\n12.8.5Exercises\n1.What happens experimentally if we set \ud835\udefe=1? Why?\n2.Rotate the optimization problem to minimize \ud835\udc53\u00b9x\u00ba=0.1\u00b9\ud835\udc651\u00b8\ud835\udc652\u00ba2\u00b82\u00b9\ud835\udc651\u0000\ud835\udc652\u00ba2. What\nhappens to the convergence?\n3.TryoutwhathappenstoRMSProponarealmachinelearningproblem,suchastraining\non Fashion-MNIST. Experiment with different choices for adjusting the learning rate.\n4.Would you want to adjust \ud835\udefeas optimization progresses? How sensitive is RMSProp to\nthis?\nDiscussions179.\n12.9Adadelta\nAdadelta is yet another variant of AdaGrad ( Section 12.7 ). The main difference lies in\nthe fact that it decreases the amount by which the learning rate is adaptive to coordinates.\nMoreover,traditionallyitreferredtoasnothavingalearningratesinceitusestheamountof\nchangeitselfascalibrationforfuturechange. ThealgorithmwasproposedinZeiler( 2012).\nIt is fairly straightforward, given the discussion of previous algorithms so far.\n12.9.1The Algorithm\nIn a nutshell, Adadelta uses two state variables, s\ud835\udc61to store a leaky average of the second\nmomentofthegradientand \u0394x\ud835\udc61tostorealeakyaverageofthesecondmomentofthechange\nof parameters in the model itself. Note that we use the original notation and naming of the\nauthors for compatibility with other publications and implementations (there is no other\n530 Optimization Algorithms\nreal reason why one should use different Greek variables to indicate a parameter serving\nthe same purpose in momentum, Adagrad, RMSProp, and Adadelta).\nHere are the technical details of Adadelta. Given the parameter du jour is \ud835\udf0c, we obtain the\nfollowing leaky updates similarly to Section 12.8 :\ns\ud835\udc61=\ud835\udf0cs\ud835\udc61\u00001\u00b8\u00b91\u0000\ud835\udf0c\u00bag2\n\ud835\udc61. (12.9.1)\nThe difference to Section 12.8 is that we perform updates with the rescaled gradient g0\n\ud835\udc61,\ni.e.,\nx\ud835\udc61=x\ud835\udc61\u00001\u0000g0\n\ud835\udc61. (12.9.2)\nSo what is the rescaled gradient g0\n\ud835\udc61?", "mimetype": "text/plain", "start_char_idx": 1176691, "end_char_idx": 1180086, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ed18ea18-8c89-4647-9698-2bbacf3b418e": {"__data__": {"id_": "ed18ea18-8c89-4647-9698-2bbacf3b418e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c8f15898-4e03-4ef7-9153-4eca7d45994b", "node_type": "1", "metadata": {}, "hash": "3e61d4de0c340804c5d5841c82a83be294d36747ce97857ef9a7a968b33ef318", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9b10b181-e696-478f-bba8-65e1512d9e2d", "node_type": "1", "metadata": {}, "hash": "d9d79a74bdbbc31d3e616fbaed4366ca9c916ca3af7d861a3f1efb5296950a59", "class_name": "RelatedNodeInfo"}}, "text": "Here are the technical details of Adadelta. Given the parameter du jour is \ud835\udf0c, we obtain the\nfollowing leaky updates similarly to Section 12.8 :\ns\ud835\udc61=\ud835\udf0cs\ud835\udc61\u00001\u00b8\u00b91\u0000\ud835\udf0c\u00bag2\n\ud835\udc61. (12.9.1)\nThe difference to Section 12.8 is that we perform updates with the rescaled gradient g0\n\ud835\udc61,\ni.e.,\nx\ud835\udc61=x\ud835\udc61\u00001\u0000g0\n\ud835\udc61. (12.9.2)\nSo what is the rescaled gradient g0\n\ud835\udc61? We can calculate it as follows:\ng0\n\ud835\udc61=p\u0394x\ud835\udc61\u00001\u00b8\ud835\udf16ps\ud835\udc61\u00b8\ud835\udf16\fg\ud835\udc61, (12.9.3)\nwhere \u0394x\ud835\udc61\u00001is the leaky average of the squared rescaled gradients g0\n\ud835\udc61. We initialize \u0394x0\nto be 0and update it at each step with g0\n\ud835\udc61, i.e.,\n\u0394x\ud835\udc61=\ud835\udf0c\u0394x\ud835\udc61\u00001\u00b8\u00b91\u0000\ud835\udf0c\u00bag0\n\ud835\udc612, (12.9.4)\nand\ud835\udf16(a small value such as 10\u00005) is added to maintain numerical stability.\n12.9.2Implementation\nAdadelta needs to maintain two state variables for each variable, s\ud835\udc61and\u0394x\ud835\udc61. This yields\nthe following implementation.\n%matplotlib inline\nimport torch\nfrom d2l import torch asd2l\ndef init_adadelta_states (feature_dim):\ns_w, s_b =torch .zeros((feature_dim, 1)), torch .zeros( 1)\ndelta_w, delta_b =torch .zeros((feature_dim, 1)), torch .zeros( 1)\nreturn ((s_w, delta_w), (s_b, delta_b))\ndef adadelta (params, states, hyperparams):\nrho, eps =hyperparams[ 'rho'],1e-5\nfor p, (s, delta) inzip(params, states):\nwith torch .no_grad():\n# In-place updates via [:]\ns[:] =rho *s+(1-rho) *torch .square(p .grad)\ng=(torch .sqrt(delta +eps) /torch .sqrt(s +eps)) *p.grad\np[:] -=g\ndelta[:] =rho *delta +(1-rho) *g*g\np.grad .data .zero_()\nChoosing\ud835\udf0c=0.9amounts to a half-life time of 10 for each parameter update. This tends\nto work quite well. We get the following behavior.\n531 Adadelta\ndata_iter, feature_dim =d2l.get_data_ch11(batch_size =10)\nd2l.train_ch11(adadelta, init_adadelta_states(feature_dim),\n{'rho':0.9}, data_iter, feature_dim);\nloss: 0.245 ,0.160 sec/epoch\nFor a concise implementation we simply use the Adadelta algorithm from high-level APIs.\nThis yields the following one-liner for a much more compact invocation.\ntrainer =torch .optim .Adadelta\nd2l.train_concise_ch11(trainer, { 'rho':0.9}, data_iter)\nloss: 0.243 ,0.119 sec/epoch\n12.9.3Summary\n\u000fAdadeltahasnolearningrateparameter. Instead, itusestherateofchangeintheparam-\neters itself to adapt the learning rate.\n\u000fAdadelta requires two state variables to store the second moments of gradient and the\nchange in parameters.\n\u000fAdadelta uses leaky averages to keep a running estimate of the appropriate statistics.\n532 Optimization Algorithms\n18012.9.4Exercises\n1.Adjust the value of \ud835\udf0c. What happens?\n2.Show how to implement the algorithm without the use of g0\n\ud835\udc61. Why might this be a good\nidea?\n3.Is Adadelta really learning rate free? Could you find optimization problems that break\nAdadelta?\n4.Compare Adadelta to Adagrad and RMS prop to discuss their convergence behavior.\nDiscussions180.\n12.10Adam\nIn the discussions leading up to this section we encountered a number of techniques for\nefficient optimization. Let\u2019s recap them in detail here:\n\u000fWe saw that Section 12.4 is more effective than Gradient Descent when solving opti-\nmization problems, e.g., due to its inherent resilience to redundant data.\n\u000fWe saw that Section 12.5 affords significant additional efficiency arising from vector-\nization, using larger sets of observations in one minibatch.", "mimetype": "text/plain", "start_char_idx": 1179755, "end_char_idx": 1182926, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9b10b181-e696-478f-bba8-65e1512d9e2d": {"__data__": {"id_": "9b10b181-e696-478f-bba8-65e1512d9e2d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ed18ea18-8c89-4647-9698-2bbacf3b418e", "node_type": "1", "metadata": {}, "hash": "79a7c69062205d37293aaafbaa99b8d2d6d58c70368dfb648e7349cacdf6eee7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "96eb6e4e-7e41-4bd8-a54d-64978ab74e6b", "node_type": "1", "metadata": {}, "hash": "8cb86592ad3e37033aea2b984e911014819c30fa8e944250ee30f54df3df7baf", "class_name": "RelatedNodeInfo"}}, "text": "532 Optimization Algorithms\n18012.9.4Exercises\n1.Adjust the value of \ud835\udf0c. What happens?\n2.Show how to implement the algorithm without the use of g0\n\ud835\udc61. Why might this be a good\nidea?\n3.Is Adadelta really learning rate free? Could you find optimization problems that break\nAdadelta?\n4.Compare Adadelta to Adagrad and RMS prop to discuss their convergence behavior.\nDiscussions180.\n12.10Adam\nIn the discussions leading up to this section we encountered a number of techniques for\nefficient optimization. Let\u2019s recap them in detail here:\n\u000fWe saw that Section 12.4 is more effective than Gradient Descent when solving opti-\nmization problems, e.g., due to its inherent resilience to redundant data.\n\u000fWe saw that Section 12.5 affords significant additional efficiency arising from vector-\nization, using larger sets of observations in one minibatch. This is the key to efficient\nmulti-machine, multi-GPU and overall parallel processing.\n\u000fSection12.6 addedamechanismforaggregatingahistoryofpastgradientstoaccelerate\nconvergence.\n\u000fSection12.7 usedper-coordinatescalingtoallowforacomputationallyefficientprecon-\nditioner.\n\u000fSection 12.8 decoupled per-coordinate scaling from a learning rate adjustment.\nAdam (Kingma and Ba, 2014 ) combines all these techniques into one efficient learning\nalgorithm. As expected, this is an algorithm that has become rather popular as one of the\nmore robust and effective optimization algorithms to use in deep learning. It is not without\nissues,though. Inparticular,( Reddietal.,2019)showthattherearesituationswhereAdam\ncandivergeduetopoorvariancecontrol. Inafollow-upworkZaheer etal.(2018)proposed\na hotfix to Adam, called Yogi which addresses these issues. More on this later. For now\nlet\u2019s review the Adam algorithm.\n12.10.1TheAlgorithm\nOne of the key components of Adam is that it uses exponential weighted moving averages\n(also known as leaky averaging) to obtain an estimate of both the momentum and also the\n533 Adam\nsecond moment of the gradient. That is, it uses the state variables\nv\ud835\udc61 \ud835\udefd1v\ud835\udc61\u00001\u00b8\u00b91\u0000\ud835\udefd1\u00bag\ud835\udc61,\ns\ud835\udc61 \ud835\udefd2s\ud835\udc61\u00001\u00b8\u00b91\u0000\ud835\udefd2\u00bag2\n\ud835\udc61.(12.10.1)\nHere\ud835\udefd1and\ud835\udefd2are nonnegative weighting parameters. Common choices for them are\n\ud835\udefd1=0.9and\ud835\udefd2=0.999. That is, the variance estimate moves much more slowly than the\nmomentumterm. Notethatifweinitialize v0=s0=0wehaveasignificantamountofbias\ninitiallytowardssmallervalues. Thiscanbeaddressedbyusingthefactthat\u00cd\ud835\udc61\u00001\n\ud835\udc56=0\ud835\udefd\ud835\udc56=1\u0000\ud835\udefd\ud835\udc61\n1\u0000\ud835\udefd\ntore-normalizeterms. Correspondinglythenormalizedstatevariablesaregivenby\n\u02c6v\ud835\udc61=v\ud835\udc61\n1\u0000\ud835\udefd\ud835\udc61\n1and \u02c6s\ud835\udc61=s\ud835\udc61\n1\u0000\ud835\udefd\ud835\udc61\n2. (12.10.2)\nArmed with the proper estimates we can now write out the update equations. First, we\nrescale the gradient in a manner very much akin to that of RMSProp to obtain\ng0\n\ud835\udc61=\ud835\udf02\u02c6v\ud835\udc61p\u02c6s\ud835\udc61\u00b8\ud835\udf16. (12.10.3)\nUnlike RMSProp our update uses the momentum \u02c6v\ud835\udc61rather than the gradient itself. More-\nover, there is a slight cosmetic difference as the rescaling happens using1p\u02c6s\ud835\udc61\u00b8\ud835\udf16instead of\n1p\u02c6s\ud835\udc61\u00b8\ud835\udf16. Theformerworksarguablyslightlybetterinpractice,hencethedeviationfromRM-\nSProp. Typically we pick \ud835\udf16=10\u00006for a good trade-off between numerical stability and\nfidelity.\nNow we have all the pieces in place to compute updates. This is slightly anticlimactic and\nwe have a simple update of the form\nx\ud835\udc61 x\ud835\udc61\u00001\u0000g0\n\ud835\udc61.", "mimetype": "text/plain", "start_char_idx": 1182085, "end_char_idx": 1185269, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "96eb6e4e-7e41-4bd8-a54d-64978ab74e6b": {"__data__": {"id_": "96eb6e4e-7e41-4bd8-a54d-64978ab74e6b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9b10b181-e696-478f-bba8-65e1512d9e2d", "node_type": "1", "metadata": {}, "hash": "d9d79a74bdbbc31d3e616fbaed4366ca9c916ca3af7d861a3f1efb5296950a59", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e4e204ba-f69c-431b-9b17-8e21afe443cb", "node_type": "1", "metadata": {}, "hash": "d8d18031da8a48221447e820ccf7b7e3e3cd09bfdee9a23ee67c3e026fe39319", "class_name": "RelatedNodeInfo"}}, "text": "(12.10.3)\nUnlike RMSProp our update uses the momentum \u02c6v\ud835\udc61rather than the gradient itself. More-\nover, there is a slight cosmetic difference as the rescaling happens using1p\u02c6s\ud835\udc61\u00b8\ud835\udf16instead of\n1p\u02c6s\ud835\udc61\u00b8\ud835\udf16. Theformerworksarguablyslightlybetterinpractice,hencethedeviationfromRM-\nSProp. Typically we pick \ud835\udf16=10\u00006for a good trade-off between numerical stability and\nfidelity.\nNow we have all the pieces in place to compute updates. This is slightly anticlimactic and\nwe have a simple update of the form\nx\ud835\udc61 x\ud835\udc61\u00001\u0000g0\n\ud835\udc61. (12.10.4)\nReviewing the design of Adam its inspiration is clear. Momentum and scale are clearly\nvisible in the state variables. Their rather peculiar definition forces us to debias terms\n(this could be fixed by a slightly different initialization and update condition). Second, the\ncombination of both terms is pretty straightforward, given RMSProp. Last, the explicit\nlearningrate \ud835\udf02allowsustocontrolthesteplengthtoaddressissuesofconvergence.\n12.10.2Implementation\nImplementing Adam from scratch is not very daunting. For convenience we store the time\nstep counter \ud835\udc61in the hyperparams dictionary. Beyond that all is straightforward.\n%matplotlib inline\nimport torch\nfrom d2l import torch asd2l\ndef init_adam_states (feature_dim):\nv_w, v_b =torch .zeros((feature_dim, 1)), torch .zeros( 1)\ns_w, s_b =torch .zeros((feature_dim, 1)), torch .zeros( 1)\nreturn ((v_w, s_w), (v_b, s_b))\n(continues on next page)\n534 Optimization Algorithms\n(continued from previous page)\ndef adam (params, states, hyperparams):\nbeta1, beta2, eps =0.9,0.999 ,1e-6\nfor p, (v, s) inzip(params, states):\nwith torch .no_grad():\nv[:] =beta1 *v+(1-beta1) *p.grad\ns[:] =beta2 *s+(1-beta2) *torch .square(p .grad)\nv_bias_corr =v/(1-beta1 **hyperparams[ 't'])\ns_bias_corr =s/(1-beta2 **hyperparams[ 't'])\np[:] -=hyperparams[ 'lr']*v_bias_corr /(torch .sqrt(s_bias_corr)\n+eps)\np.grad .data .zero_()\nhyperparams[ 't']+=1\nWe are ready to use Adam to train the model. We use a learning rate of \ud835\udf02=0.01.\ndata_iter, feature_dim =d2l.get_data_ch11(batch_size =10)\nd2l.train_ch11(adam, init_adam_states(feature_dim),\n{'lr':0.01 ,'t':1}, data_iter, feature_dim);\nloss: 0.243 ,0.193 sec/epoch\nA more concise implementation is straightforward since adamis one of the algorithms pro-\nvided as part of the Gluon trainer optimization library. Hence we only need to pass\nconfiguration parameters for an implementation in Gluon.\ntrainer =torch .optim .Adam\nd2l.train_concise_ch11(trainer, { 'lr':0.01 }, data_iter)\nloss: 0.243 ,0.152 sec/epoch\n12.10.3Yogi\nOneoftheproblemsofAdamisthatitcanfailtoconvergeeveninconvexsettingswhenthe\nsecond moment estimate in s\ud835\udc61blows up. As a fix Zaheer et al.(2018) proposed a refined\n535 Adam\nupdate (and initialization) for s\ud835\udc61. To understand what\u2019s going on, let\u2019s rewrite the Adam\nupdate as follows:\ns\ud835\udc61 s\ud835\udc61\u00001\u00b8\u00b91\u0000\ud835\udefd2\u00ba\u0010\ng2\n\ud835\udc61\u0000s\ud835\udc61\u00001\u0011\n. (12.10.5)\nWhenever g2\n\ud835\udc61hashighvarianceorupdatesaresparse, s\ud835\udc61mightforgetpastvaluestooquickly.\nApossiblefixforthisistoreplace g2\n\ud835\udc61\u0000s\ud835\udc61\u00001byg2\n\ud835\udc61\fsgn\u00b9g2\n\ud835\udc61\u0000s\ud835\udc61\u00001\u00ba. Nowthemagnitudeofthe\nupdate no longer depends on the amount of deviation.", "mimetype": "text/plain", "start_char_idx": 1184766, "end_char_idx": 1187811, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e4e204ba-f69c-431b-9b17-8e21afe443cb": {"__data__": {"id_": "e4e204ba-f69c-431b-9b17-8e21afe443cb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "96eb6e4e-7e41-4bd8-a54d-64978ab74e6b", "node_type": "1", "metadata": {}, "hash": "8cb86592ad3e37033aea2b984e911014819c30fa8e944250ee30f54df3df7baf", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "999c0f05-0c2b-4984-9124-7dbfda9b86f6", "node_type": "1", "metadata": {}, "hash": "7a93b59d91eb0c7d3275b131d4aa29fcb27b070c4470ff69efc9965acef67636", "class_name": "RelatedNodeInfo"}}, "text": "As a fix Zaheer et al.(2018) proposed a refined\n535 Adam\nupdate (and initialization) for s\ud835\udc61. To understand what\u2019s going on, let\u2019s rewrite the Adam\nupdate as follows:\ns\ud835\udc61 s\ud835\udc61\u00001\u00b8\u00b91\u0000\ud835\udefd2\u00ba\u0010\ng2\n\ud835\udc61\u0000s\ud835\udc61\u00001\u0011\n. (12.10.5)\nWhenever g2\n\ud835\udc61hashighvarianceorupdatesaresparse, s\ud835\udc61mightforgetpastvaluestooquickly.\nApossiblefixforthisistoreplace g2\n\ud835\udc61\u0000s\ud835\udc61\u00001byg2\n\ud835\udc61\fsgn\u00b9g2\n\ud835\udc61\u0000s\ud835\udc61\u00001\u00ba. Nowthemagnitudeofthe\nupdate no longer depends on the amount of deviation. This yields the Yogi updates\ns\ud835\udc61 s\ud835\udc61\u00001\u00b8\u00b91\u0000\ud835\udefd2\u00bag2\n\ud835\udc61\fsgn\u00b9g2\n\ud835\udc61\u0000s\ud835\udc61\u00001\u00ba. (12.10.6)\nThe authors furthermore advise to initialize the momentum on a larger initial batch rather\nthan just initial pointwise estimate. We omit the details since they are not material to the\ndiscussion and since even without this convergence remains pretty good.\ndef yogi (params, states, hyperparams):\nbeta1, beta2, eps =0.9,0.999 ,1e-3\nfor p, (v, s) inzip(params, states):\nwith torch .no_grad():\nv[:] =beta1 *v+(1-beta1) *p.grad\ns[:] =s+(1-beta2) *torch .sign(\ntorch .square(p .grad) -s)*torch .square(p .grad)\nv_bias_corr =v/(1-beta1 **hyperparams[ 't'])\ns_bias_corr =s/(1-beta2 **hyperparams[ 't'])\np[:] -=hyperparams[ 'lr']*v_bias_corr /(torch .sqrt(s_bias_corr)\n+eps)\np.grad .data .zero_()\nhyperparams[ 't']+=1\ndata_iter, feature_dim =d2l.get_data_ch11(batch_size =10)\nd2l.train_ch11(yogi, init_adam_states(feature_dim),\n{'lr':0.01 ,'t':1}, data_iter, feature_dim);\nloss: 0.243 ,0.165 sec/epoch\n12.10.4Summary\n\u000fAdam combines features of many optimization algorithms into a fairly robust update\nrule.\n536 Optimization Algorithms\n181\u000fCreated on the basis of RMSProp, Adam also uses EWMA on the minibatch stochastic\ngradient.\n\u000fAdam uses bias correction to adjust for a slow startup when estimating momentum and\na second moment.\n\u000fForgradientswithsignificantvariancewemayencounterissueswithconvergence. They\ncan be amended by using larger minibatches or by switching to an improved estimate\nfors\ud835\udc61. Yogi offers such an alternative.\n12.10.5Exercises\n1.Adjust the learning rate and observe and analyze the experimental results.\n2.Can you rewrite momentum and second moment updates such that it does not require\nbias correction?\n3.Why do you need to reduce the learning rate \ud835\udf02as we converge?\n4.Try to construct a case for which Adam diverges and Yogi converges?\nDiscussions181.\n12.11LearningRate Scheduling\nSofarweprimarilyfocusedonoptimization algorithms forhowtoupdatetheweightvectors\nratherthanonthe rateatwhichtheyarebeingupdated. Nonetheless,adjustingthelearning\nrate is often just as important as the actual algorithm. There are a number of aspects to\nconsider:\n\u000fMostobviouslythe magnitude ofthelearningratematters. Ifitistoolarge,optimization\ndiverges, if it is too small, it takes too long to train or we end up with a suboptimal\nresult. We saw previously that the condition number of the problem matters (see e.g.,\nSection 12.6 for details). Intuitively it is the ratio of the amount of change in the least\nsensitive direction vs. the most sensitive one.\n537 Learning Rate Scheduling\n\u000fSecondly,therateofdecayisjustasimportant. Ifthelearningrateremainslargewemay\nsimply end up bouncing around the minimum and thus not reach optimality. Section\n12.5discussedthisinsomedetailandweanalyzedperformanceguaranteesin Section\n12.4. Inshort,wewanttheratetodecay,butprobablymoreslowlythan O\u00b9\ud835\udc61\u00001\n2\u00bawhich\nwould be a good choice for convex problems.", "mimetype": "text/plain", "start_char_idx": 1187387, "end_char_idx": 1190720, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "999c0f05-0c2b-4984-9124-7dbfda9b86f6": {"__data__": {"id_": "999c0f05-0c2b-4984-9124-7dbfda9b86f6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e4e204ba-f69c-431b-9b17-8e21afe443cb", "node_type": "1", "metadata": {}, "hash": "d8d18031da8a48221447e820ccf7b7e3e3cd09bfdee9a23ee67c3e026fe39319", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "168b9c05-e7de-4a5a-b3f2-aed96acb1998", "node_type": "1", "metadata": {}, "hash": "4a4383cb5c81bedac14317264607f9a4306702266cc90a1693bf4e32a5554e5c", "class_name": "RelatedNodeInfo"}}, "text": "We saw previously that the condition number of the problem matters (see e.g.,\nSection 12.6 for details). Intuitively it is the ratio of the amount of change in the least\nsensitive direction vs. the most sensitive one.\n537 Learning Rate Scheduling\n\u000fSecondly,therateofdecayisjustasimportant. Ifthelearningrateremainslargewemay\nsimply end up bouncing around the minimum and thus not reach optimality. Section\n12.5discussedthisinsomedetailandweanalyzedperformanceguaranteesin Section\n12.4. Inshort,wewanttheratetodecay,butprobablymoreslowlythan O\u00b9\ud835\udc61\u00001\n2\u00bawhich\nwould be a good choice for convex problems.\n\u000fAnother aspect that is equally important is initialization . This pertains both to how the\nparameters are set initially (review Section 5.4 for details) and also how they evolve\ninitially. This goes under the moniker of warmup, i.e., how rapidly we start moving\ntowards the solution initially. Large steps in the beginning might not be beneficial, in\nparticular since the initial set of parameters is random. The initial update directions\nmight be quite meaningless, too.\n\u000fLastly, there are a number of optimization variants that perform cyclical learning rate\nadjustment. This is beyond the scope of the current chapter. We recommend the\nreader to review details in Izmailov et al.(2018), e.g., how to obtain better solutions\nby averaging over an entire pathof parameters.\nGiventhe factthat thereis a lot ofdetail needed to managelearningrates, mostdeeplearn-\ning frameworks have tools to deal with this automatically. In the current chapter we will\nreview the effects that different schedules have on accuracy and also show how this can be\nmanaged efficiently via a learning ratescheduler .\n12.11.1ToyProblem\nWe begin with a toy problem that is cheap enough to compute easily, yet sufficiently non-\ntrivial to illustrate some of the key aspects. For that we pick a slightly modernized version\nof LeNet ( reluinstead of sigmoid activation, MaxPooling rather than AveragePooling),\nasappliedtoFashion-MNIST.Moreover, wehybridizethenetworkforperformance. Since\nmostofthecodeisstandardwejustintroducethebasicswithoutfurtherdetaileddiscussion.\nSeeChapter 7 for a refresher as needed.", "mimetype": "text/plain", "start_char_idx": 1190122, "end_char_idx": 1192301, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "168b9c05-e7de-4a5a-b3f2-aed96acb1998": {"__data__": {"id_": "168b9c05-e7de-4a5a-b3f2-aed96acb1998", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "999c0f05-0c2b-4984-9124-7dbfda9b86f6", "node_type": "1", "metadata": {}, "hash": "7a93b59d91eb0c7d3275b131d4aa29fcb27b070c4470ff69efc9965acef67636", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ad0811b8-4c65-4397-b1c5-1d7f2ba8be04", "node_type": "1", "metadata": {}, "hash": "f69196a6a0da95eca6ff94a2604f59300d0068cac3e3cb31019f1c85d2cba7ca", "class_name": "RelatedNodeInfo"}}, "text": "Giventhe factthat thereis a lot ofdetail needed to managelearningrates, mostdeeplearn-\ning frameworks have tools to deal with this automatically. In the current chapter we will\nreview the effects that different schedules have on accuracy and also show how this can be\nmanaged efficiently via a learning ratescheduler .\n12.11.1ToyProblem\nWe begin with a toy problem that is cheap enough to compute easily, yet sufficiently non-\ntrivial to illustrate some of the key aspects. For that we pick a slightly modernized version\nof LeNet ( reluinstead of sigmoid activation, MaxPooling rather than AveragePooling),\nasappliedtoFashion-MNIST.Moreover, wehybridizethenetworkforperformance. Since\nmostofthecodeisstandardwejustintroducethebasicswithoutfurtherdetaileddiscussion.\nSeeChapter 7 for a refresher as needed.\n%matplotlib inline\nimport math\nimport torch\nfrom torch import nn\nfrom torch .optim import lr_scheduler\nfrom d2l import torch asd2l\ndef net_fn ():\nmodel =nn.Sequential(\nnn.Conv2d( 1,6, kernel_size =5, padding =2), nn .ReLU(),\nnn.MaxPool2d(kernel_size =2, stride =2),\nnn.Conv2d( 6,16, kernel_size =5), nn .ReLU(),\nnn.MaxPool2d(kernel_size =2, stride =2),\nnn.Flatten(),\nnn.Linear( 16*5*5,120), nn .ReLU(),\nnn.Linear( 120,84), nn .ReLU(),\nnn.Linear( 84,10))\n(continues on next page)\n538 Optimization Algorithms\n(continued from previous page)\nreturn model\nloss =nn.CrossEntropyLoss()\ndevice =d2l.try_gpu()\nbatch_size =256\ntrain_iter, test_iter =d2l.load_data_fashion_mnist(batch_size =batch_size)\n# The code is almost identical to `d2l.train_ch6` defined in the\n# lenet section of chapter convolutional neural networks\ndef train (net, train_iter, test_iter, num_epochs, loss, trainer, device,\nscheduler =None ):\nnet.to(device)\nanimator =d2l.Animator(xlabel ='epoch ', xlim =[0, num_epochs],\nlegend =['train loss ','train acc ','test acc '])\nfor epoch inrange (num_epochs):\nmetric =d2l.Accumulator( 3)# train_loss, train_acc, num_examples\nfor i, (X, y) inenumerate (train_iter):\nnet.train()\ntrainer .zero_grad()\nX, y =X.to(device), y .to(device)\ny_hat =net(X)\nl=loss(y_hat, y)\nl.backward()\ntrainer .step()\nwith torch .no_grad():\nmetric .add(l *X.shape[ 0], d2l .accuracy(y_hat, y), X .shape[ 0])\ntrain_loss =metric[ 0]/metric[ 2]\ntrain_acc =metric[ 1]/metric[ 2]\nif(i+1)%50==0:\nanimator .add(epoch +i/len(train_iter),\n(train_loss, train_acc, None ))\ntest_acc =d2l.evaluate_accuracy_gpu(net, test_iter)\nanimator .add(epoch +1, (None ,None , test_acc))\nifscheduler:\nifscheduler .__module__ ==lr_scheduler .__name__ :\n# Using PyTorch In-Built scheduler\nscheduler .step()\nelse :\n# Using custom defined scheduler\nfor param_group intrainer .param_groups:\nparam_group[ 'lr']=scheduler(epoch)\nprint (f'train loss {train_loss :.3f}, train acc {train_acc :.3f},'\nf'test acc {test_acc :.3f}')\nLet\u2019s have a look at what happens if we invoke this algorithm with default settings, such as\na learning rate of 0.3and train for 30iterations. Note how the training accuracy keeps on\nincreasing while progress in terms of test accuracy stalls beyond a point. The gap between\nboth curves indicates overfitting.\n539 Learning Rate Scheduling\nlr, num_epochs =0.3,30\nnet =net_fn()\ntrainer =torch .optim .SGD(net .parameters(), lr =lr)\ntrain(net, train_iter, test_iter, num_epochs, loss, trainer, device)\ntrain loss 0.145 , train acc 0.944 , test acc 0.877\n12.11.2Schedulers\nOne way of adjusting the learning rate is to set it explicitly at each step. This is conve-\nniently achieved by the set_learning_rate method. We could adjust it downward after\nevery epoch (or even after every minibatch), e.g., in a dynamic manner in response to how\noptimization is progressing.", "mimetype": "text/plain", "start_char_idx": 1191496, "end_char_idx": 1195140, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ad0811b8-4c65-4397-b1c5-1d7f2ba8be04": {"__data__": {"id_": "ad0811b8-4c65-4397-b1c5-1d7f2ba8be04", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "168b9c05-e7de-4a5a-b3f2-aed96acb1998", "node_type": "1", "metadata": {}, "hash": "4a4383cb5c81bedac14317264607f9a4306702266cc90a1693bf4e32a5554e5c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6dcc486f-837f-4ee3-acb4-d2944d99d7cf", "node_type": "1", "metadata": {}, "hash": "84a3224f7cfff167cee3707297bdf3e96e3f8cdf89046f12616087beabd87e7f", "class_name": "RelatedNodeInfo"}}, "text": "Note how the training accuracy keeps on\nincreasing while progress in terms of test accuracy stalls beyond a point. The gap between\nboth curves indicates overfitting.\n539 Learning Rate Scheduling\nlr, num_epochs =0.3,30\nnet =net_fn()\ntrainer =torch .optim .SGD(net .parameters(), lr =lr)\ntrain(net, train_iter, test_iter, num_epochs, loss, trainer, device)\ntrain loss 0.145 , train acc 0.944 , test acc 0.877\n12.11.2Schedulers\nOne way of adjusting the learning rate is to set it explicitly at each step. This is conve-\nniently achieved by the set_learning_rate method. We could adjust it downward after\nevery epoch (or even after every minibatch), e.g., in a dynamic manner in response to how\noptimization is progressing.\nlr=0.1\ntrainer .param_groups[ 0][\"lr\"]=lr\nprint (f'learning rate is now {trainer .param_groups[ 0][\"lr\"]:.2f}')\nlearning rate isnow 0.10\nMore generally we want to define a scheduler. When invoked with the number of updates\nit returns the appropriate value of the learning rate. Let\u2019s define a simple one that sets the\nlearning rate to \ud835\udf02=\ud835\udf020\u00b9\ud835\udc61\u00b81\u00ba\u00001\n2.\nclass SquareRootScheduler :\ndef __init__ (self , lr =0.1):\nself .lr=lr\ndef __call__ (self , num_update):\nreturn self .lr*pow(num_update +1.0,-0.5)\nLet\u2019s plot its behavior over a range of values.\nscheduler =SquareRootScheduler(lr =0.1)\nd2l.plot(torch .arange(num_epochs), [scheduler(t) for tinrange (num_epochs)])\n540 Optimization Algorithms\nNow let\u2019s see how this plays out for training on Fashion-MNIST. We simply provide the\nscheduler as an additional argument to the training algorithm.\nnet =net_fn()\ntrainer =torch .optim .SGD(net .parameters(), lr)\ntrain(net, train_iter, test_iter, num_epochs, loss, trainer, device,\nscheduler)\ntrain loss 0.273 , train acc 0.900 , test acc 0.886\nThis worked quite a bit better than previously. Two things stand out: the curve was rather\nmoresmooththan previously. Secondly, therewaslessoverfitting. Unfortunatelyitis nota\nwell-resolved question as to why certain strategies lead to less overfitting in theory. There\nis some argument that a smaller stepsize will lead to parameters that are closer to zero and\nthussimpler. However,thisdoesnotexplainthephenomenonentirelysincewedonotreally\nstop early but simply reduce the learning rate gently.\n12.11.3Policies\nWhile we cannot possibly cover the entire variety of learning rate schedulers, we attempt\nto give a brief overview of popular policies below. Common choices are polynomial decay\nand piecewise constant schedules. Beyond that, cosine learning rate schedules have been\nfoundtoworkwellempiricallyonsomeproblems. Lastly,onsomeproblemsitisbeneficial\nto warm up the optimizer prior to using large learning rates.\n541 Learning Rate Scheduling\nFactorScheduler\nOne alternative to a polynomial decay would be a multiplicative one, that is \ud835\udf02\ud835\udc61\u00b81 \ud835\udf02\ud835\udc61\u0001\ud835\udefc\nfor\ud835\udefc2\u00b90,1\u00ba. Topreventthelearningratefromdecayingbeyondareasonablelowerbound\nthe update equation is often modified to \ud835\udf02\ud835\udc61\u00b81 max\u00b9\ud835\udf02min,\ud835\udf02\ud835\udc61\u0001\ud835\udefc\u00ba.\nclass FactorScheduler :\ndef __init__ (self , factor =1, stop_factor_lr =1e-7 , base_lr =0.1):\nself .factor =factor\nself .stop_factor_lr =stop_factor_lr\nself .base_lr =base_lr\ndef __call__ (self , num_update):\nself .base_lr =max(self .stop_factor_lr, self .base_lr *self .factor)\nreturn self .base_lr\nscheduler =FactorScheduler(factor =0.9, stop_factor_lr =1e-2 , base_lr =2.0)\nd2l.plot(torch .arange( 50), [scheduler(t) for tinrange (50)])\nThis can also be accomplished by a built-in scheduler in MXNet via the lr_scheduler.\nFactorScheduler object. Ittakesafewmoreparameters,suchaswarmupperiod,warmup\nmode (linear or constant), the maximum number of desired updates, etc.", "mimetype": "text/plain", "start_char_idx": 1194421, "end_char_idx": 1198037, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6dcc486f-837f-4ee3-acb4-d2944d99d7cf": {"__data__": {"id_": "6dcc486f-837f-4ee3-acb4-d2944d99d7cf", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ad0811b8-4c65-4397-b1c5-1d7f2ba8be04", "node_type": "1", "metadata": {}, "hash": "f69196a6a0da95eca6ff94a2604f59300d0068cac3e3cb31019f1c85d2cba7ca", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f3375fb2-130c-4acc-884b-b8450f77355a", "node_type": "1", "metadata": {}, "hash": "64fc0f5a6f6efb06dcbe1e36e479a1e65d1e269eaaeb39984c540e0bbda5dca6", "class_name": "RelatedNodeInfo"}}, "text": "class FactorScheduler :\ndef __init__ (self , factor =1, stop_factor_lr =1e-7 , base_lr =0.1):\nself .factor =factor\nself .stop_factor_lr =stop_factor_lr\nself .base_lr =base_lr\ndef __call__ (self , num_update):\nself .base_lr =max(self .stop_factor_lr, self .base_lr *self .factor)\nreturn self .base_lr\nscheduler =FactorScheduler(factor =0.9, stop_factor_lr =1e-2 , base_lr =2.0)\nd2l.plot(torch .arange( 50), [scheduler(t) for tinrange (50)])\nThis can also be accomplished by a built-in scheduler in MXNet via the lr_scheduler.\nFactorScheduler object. Ittakesafewmoreparameters,suchaswarmupperiod,warmup\nmode (linear or constant), the maximum number of desired updates, etc.; Going forward\nwe will use the built-in schedulers as appropriate and only explain their functionality here.\nAs illustrated, it is fairly straightforward to build your own scheduler if needed.\nMulti FactorScheduler\nA common strategy for training deep networks is to keep the learning rate piecewise con-\nstant and to decrease it by a given amount every so often. That is, given a set of times\nwhen to decrease the rate, such as \ud835\udc60=f5,10,20gdecrease\ud835\udf02\ud835\udc61\u00b81 \ud835\udf02\ud835\udc61\u0001\ud835\udefcwhenever\ud835\udc612\ud835\udc60.\nAssuming that the values are halved at each step we can implement this as follows.\nnet =net_fn()\ntrainer =torch .optim .SGD(net .parameters(), lr =0.5)\nscheduler =lr_scheduler .MultiStepLR(trainer, milestones =[15,30], gamma =0.5)\ndef get_lr (trainer, scheduler):\nlr=scheduler .get_last_lr()[ 0]\ntrainer .step()\n(continues on next page)\n542 Optimization Algorithms\n(continued from previous page)\nscheduler .step()\nreturn lr\nd2l.plot(torch .arange(num_epochs), [get_lr(trainer, scheduler)\nfor tinrange (num_epochs)])\nThe intuition behind this piecewise constant learning rate schedule is that one lets opti-\nmization proceed until a stationary point has been reached in terms of the distribution of\nweight vectors. Then (and only then) do we decrease the rate such as to obtain a higher\nquality proxy to a good local minimum. The example below shows how this can produce\never slightly better solutions.\ntrain(net, train_iter, test_iter, num_epochs, loss, trainer, device,\nscheduler)\ntrain loss 0.194 , train acc 0.927 , test acc 0.869\nCosine Scheduler\nA rather perplexing heuristic was proposed by Loshchilov and Hutter ( 2016). It relies on\nthe observation that we might not want to decrease the learning rate too drastically in the\nbeginningandmoreover,thatwemightwantto\u201crefine\u201dthesolutionintheendusingavery\nsmall learning rate. This results in a cosine-like schedule with the following functional\n543 Learning Rate Scheduling\nform for learning rates in the range \ud835\udc612\u00bb0,\ud835\udc47\u00bc.\n\ud835\udf02\ud835\udc61=\ud835\udf02\ud835\udc47\u00b8\ud835\udf020\u0000\ud835\udf02\ud835\udc47\n2\u00b91\u00b8cos\u00b9\ud835\udf0b\ud835\udc61\u009d\ud835\udc47\u00ba\u00ba (12.11.1)\nHere\ud835\udf020is the initial learning rate, \ud835\udf02\ud835\udc47is the target rate at time \ud835\udc47. Furthermore, for \ud835\udc61 > \ud835\udc47\nwe simply pin the value to \ud835\udf02\ud835\udc47without increasing it again. In the following example, we set\nthe max update step \ud835\udc47=20.", "mimetype": "text/plain", "start_char_idx": 1197366, "end_char_idx": 1200225, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f3375fb2-130c-4acc-884b-b8450f77355a": {"__data__": {"id_": "f3375fb2-130c-4acc-884b-b8450f77355a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6dcc486f-837f-4ee3-acb4-d2944d99d7cf", "node_type": "1", "metadata": {}, "hash": "84a3224f7cfff167cee3707297bdf3e96e3f8cdf89046f12616087beabd87e7f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "96f32a2e-3ab9-42aa-889e-64099d03cea9", "node_type": "1", "metadata": {}, "hash": "6417054021be624113b54b5d9fe836f06b733bdc2567b9b1cecf4fdaf85d5a73", "class_name": "RelatedNodeInfo"}}, "text": "This results in a cosine-like schedule with the following functional\n543 Learning Rate Scheduling\nform for learning rates in the range \ud835\udc612\u00bb0,\ud835\udc47\u00bc.\n\ud835\udf02\ud835\udc61=\ud835\udf02\ud835\udc47\u00b8\ud835\udf020\u0000\ud835\udf02\ud835\udc47\n2\u00b91\u00b8cos\u00b9\ud835\udf0b\ud835\udc61\u009d\ud835\udc47\u00ba\u00ba (12.11.1)\nHere\ud835\udf020is the initial learning rate, \ud835\udf02\ud835\udc47is the target rate at time \ud835\udc47. Furthermore, for \ud835\udc61 > \ud835\udc47\nwe simply pin the value to \ud835\udf02\ud835\udc47without increasing it again. In the following example, we set\nthe max update step \ud835\udc47=20.\nclass CosineScheduler :\ndef __init__ (self , max_update, base_lr =0.01 , final_lr =0,\nwarmup_steps =0, warmup_begin_lr =0):\nself .base_lr_orig =base_lr\nself .max_update =max_update\nself .final_lr =final_lr\nself .warmup_steps =warmup_steps\nself .warmup_begin_lr =warmup_begin_lr\nself .max_steps =self .max_update -self .warmup_steps\ndef get_warmup_lr (self , epoch):\nincrease =(self .base_lr_orig -self .warmup_begin_lr) \\\n*float (epoch) /float (self .warmup_steps)\nreturn self .warmup_begin_lr +increase\ndef __call__ (self , epoch):\nifepoch <self .warmup_steps:\nreturn self .get_warmup_lr(epoch)\nifepoch <=self .max_update:\nself .base_lr =self .final_lr +(\nself .base_lr_orig -self .final_lr) *(1+math .cos(\nmath .pi*(epoch -self .warmup_steps) /self .max_steps)) /2\nreturn self .base_lr\nscheduler =CosineScheduler(max_update =20, base_lr =0.3, final_lr =0.01 )\nd2l.plot(torch .arange(num_epochs), [scheduler(t) for tinrange (num_epochs)])\nIn the context of computer vision this schedule canlead to improved results. Note, though,\nthat such improvements are not guaranteed (as can be seen below).\nnet =net_fn()\ntrainer =torch .optim .SGD(net .parameters(), lr =0.3)\ntrain(net, train_iter, test_iter, num_epochs, loss, trainer, device,\nscheduler)\n544 Optimization Algorithms\ntrain loss 0.159 , train acc 0.942 , test acc 0.904\nWarmup\nInsomecasesinitializingtheparametersisnotsufficienttoguaranteeagoodsolution. This\nis particularly a problem for some advanced network designs that may lead to unstable\noptimization problems. We could address this by choosing a sufficiently small learning\nrateto preventdivergencein the beginning. Unfortunatelythismeans that progress isslow.\nConversely, a large learning rate initially leads to divergence.\nArathersimplefixforthisdilemmaistouseawarmupperiodduringwhichthelearningrate\nincreases to its initial maximum and to cool down the rate until the end of the optimization\nprocess. For simplicity one typically uses a linear increase for this purpose. This leads to\na schedule of the form indicated below.\nscheduler =CosineScheduler( 20, warmup_steps =5, base_lr =0.3, final_lr =0.01 )\nd2l.plot(torch .arange(num_epochs), [scheduler(t) for tinrange (num_epochs)])\nNote that the network converges better initially (in particular observe the performance dur-\ning the first 5 epochs).\nnet =net_fn()\ntrainer =torch .optim .SGD(net .parameters(), lr =0.3)\ntrain(net, train_iter, test_iter, num_epochs, loss, trainer, device,\nscheduler)\n545 Learning Rate Scheduling\n182train loss 0.181 , train acc 0.934 , test acc 0.901\nWarmup can be applied to any scheduler (not just cosine). For a more detailed discussion\nof learning rate schedules and many more experiments see also ( Gotmare et al., 2018). In\nparticular they find that a warmup phase limits the amount of divergence of parameters\nin very deep networks. This makes intuitively sense since we would expect significant\ndivergence due to random initialization in those parts of the network that take the most\ntime to make progress in the beginning.\n12.11.4Summary\n\u000fDecreasing the learning rate during training can lead to improved accuracy and (most\nperplexingly) reduced overfitting of the model.\n\u000fA piecewise decrease of the learning rate whenever progress has plateaued is effective\nin practice.", "mimetype": "text/plain", "start_char_idx": 1199837, "end_char_idx": 1203508, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "96f32a2e-3ab9-42aa-889e-64099d03cea9": {"__data__": {"id_": "96f32a2e-3ab9-42aa-889e-64099d03cea9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f3375fb2-130c-4acc-884b-b8450f77355a", "node_type": "1", "metadata": {}, "hash": "64fc0f5a6f6efb06dcbe1e36e479a1e65d1e269eaaeb39984c540e0bbda5dca6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7f706f29-d30f-41bb-9478-08833679dacd", "node_type": "1", "metadata": {}, "hash": "29a7d798007eac746a0355922f1ff9966261d4e0ec08441e3b2277f419f05920", "class_name": "RelatedNodeInfo"}}, "text": "For a more detailed discussion\nof learning rate schedules and many more experiments see also ( Gotmare et al., 2018). In\nparticular they find that a warmup phase limits the amount of divergence of parameters\nin very deep networks. This makes intuitively sense since we would expect significant\ndivergence due to random initialization in those parts of the network that take the most\ntime to make progress in the beginning.\n12.11.4Summary\n\u000fDecreasing the learning rate during training can lead to improved accuracy and (most\nperplexingly) reduced overfitting of the model.\n\u000fA piecewise decrease of the learning rate whenever progress has plateaued is effective\nin practice. Essentially this ensures that we converge efficiently to a suitable solution\nand only then reduce the inherent variance of the parameters by reducing the learning\nrate.\n\u000fCosine schedulers are popular for some computer vision problems. See e.g., GluonCV\n182for details of such a scheduler.\n\u000fA warmup period before optimization can prevent divergence.\n\u000fOptimizationservesmultiplepurposesindeeplearning. Besidesminimizingthetraining\nobjective, different choices of optimization algorithms and learning rate scheduling\ncan lead to rather different amounts of generalization and overfitting on the test set\n(for the same amount of training error).\n12.11.5Exercises\n1.Experiment with the optimization behavior for a given fixed learning rate. What is the\nbest model you can obtain this way?\n2.Howdoesconvergencechangeifyouchangetheexponentofthedecreaseinthelearning\nrate? Use PolyScheduler for your convenience in the experiments.\n546 Optimization Algorithms\n1833.Apply the cosine scheduler to large computer vision problems, e.g., training ImageNet.\nHow does it affect performance relative to other schedulers?\n4.How long should warmup last?\n5.Can you connect optimization and sampling? Start by using results from Welling and\nTeh (2011) on Stochastic Gradient Langevin Dynamics.\nDiscussions183.\n13 Computational Performance\nIn deep learning, datasets and models are usually large, which involves heavy computa-\ntion. Therefore, computational performance matters a lot. This chapter will focus on the\nmajor factors that affect computational performance: imperative programming, symbolic\nprogramming, asynchronous computing, automatic parallelism, and multi-GPU computa-\ntion. By studying this chapter, you may further improve computational performance of\nthosemodelsimplementedinthepreviouschapters, forexample, byreducingtrainingtime\nwithout affecting accuracy.\n13.1Compilersand Interpreters\nSo far, this book has focused on imperative programming, which makes use of statements\nsuch as print,+, and ifto change a program\u2019s state. Consider the following example of a\nsimple imperative program.\ndef add(a, b):\nreturn a+b\ndef fancy_func (a, b, c, d):\ne=add(a, b)\nf=add(c, d)\ng=add(e, f)\nreturn g\nprint (fancy_func( 1,2,3,4))\n10\nPython is an interpreted language . When evaluating the above fancy_func function it\nperformstheoperationsmakingupthefunction\u2019sbody insequence . Thatis,itwillevaluate\ne = add(a, b) and store the results as variable e, thereby changing the program\u2019s state.\nThe next two statements f = add(c, d) andg = add(e, f) will be executed similarly,\nperforming additions and storing the results as variables. Fig. 13.1.1 illustrates the flow of\ndata.\n547\n548 Computational Performance\ntFig. 13.1.1 Data \ufb02ow in an imperative program.\nAlthough imperative programming is convenient, it may be inefficient. On the one hand,\neven if the addfunction is repeatedly called throughout fancy_func , Python will execute\nthe three function calls individually. If these are executed, say, on a GPU (or even on mul-\ntiple GPUs), the overhead arising from the Python interpreter can become overwhelming.\nMoreover, it will need to save the variable values of eandfuntil all the statements in\nfancy_func have been executed. This is because we do not know whether the variables e\nandfwill be used by other parts of the program after the statements e = add(a, b) and\nf = add(c, d) are executed.\n13.1.1SymbolicProgramming\nConsider the alternative, symbolicprogramming , where computation is usually performed\nonlyoncetheprocesshasbeenfullydefined. Thisstrategyisusedbymultipledeeplearning\nframeworks, including Theano and TensorFlow (the latter has acquired imperative exten-\nsions). It usually involves the following steps:\n1.Define the operations to be executed.\n2.Compile the operations into an executable program.", "mimetype": "text/plain", "start_char_idx": 1202836, "end_char_idx": 1207317, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7f706f29-d30f-41bb-9478-08833679dacd": {"__data__": {"id_": "7f706f29-d30f-41bb-9478-08833679dacd", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "96f32a2e-3ab9-42aa-889e-64099d03cea9", "node_type": "1", "metadata": {}, "hash": "6417054021be624113b54b5d9fe836f06b733bdc2567b9b1cecf4fdaf85d5a73", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e4832e7c-8f15-4bc8-ae93-d33ff7d0cfc5", "node_type": "1", "metadata": {}, "hash": "ab3f5d225fad5b6a25318ab3f8476e6a92560f4ee6a73b5c6b5b51b2198f62f3", "class_name": "RelatedNodeInfo"}}, "text": "If these are executed, say, on a GPU (or even on mul-\ntiple GPUs), the overhead arising from the Python interpreter can become overwhelming.\nMoreover, it will need to save the variable values of eandfuntil all the statements in\nfancy_func have been executed. This is because we do not know whether the variables e\nandfwill be used by other parts of the program after the statements e = add(a, b) and\nf = add(c, d) are executed.\n13.1.1SymbolicProgramming\nConsider the alternative, symbolicprogramming , where computation is usually performed\nonlyoncetheprocesshasbeenfullydefined. Thisstrategyisusedbymultipledeeplearning\nframeworks, including Theano and TensorFlow (the latter has acquired imperative exten-\nsions). It usually involves the following steps:\n1.Define the operations to be executed.\n2.Compile the operations into an executable program.\n3.Provide the required inputs and call the compiled program for execution.\nThis allows for a significant amount of optimization. First, we can skip the Python inter-\npreter in many cases, thus removing a performance bottleneck that can become significant\non multiple fast GPUs paired with a single Python thread on a CPU. Second, a compiler\nmight optimize and rewrite the above code into print((1 + 2) + (3 + 4)) or even\nprint(10) . This is possible since a compiler gets to see the full code before turning it into\nmachine instructions. For instance, it can release memory (or never allocate it) whenever a\nvariableisnolongerneeded. Oritcantransformthecodeentirelyintoanequivalentpiece.\nTo get a better idea, consider the following simulation of imperative programming (it is\nPython after all) below.\ndef add_ ():\nreturn '''\ndef add(a, b):\nreturn a + b\n'''\ndef fancy_func_ ():\nreturn '''\n(continues on next page)\n549 Compilers and Interpreters\n(continued from previous page)\ndef fancy_func(a, b, c, d):\ne = add(a, b)\nf = add(c, d)\ng = add(e, f)\nreturn g\n'''\ndef evoke_ ():\nreturn add_() +fancy_func_() +'print(fancy_func(1, 2, 3, 4)) '\nprog =evoke_()\nprint (prog)\ny=compile (prog, '','exec ')\nexec(y)\ndef add(a, b):\nreturn a+b\ndef fancy_func (a, b, c, d):\ne=add(a, b)\nf=add(c, d)\ng=add(e, f)\nreturn g\nprint (fancy_func( 1,2,3,4))\n10\nThedifferencesbetweenimperative(interpreted)programmingandsymbolicprogramming\nare as follows:\n\u000fImperative programming is easier. When imperative programming is used in Python,\nthe majority of the code is straightforward and easy to write. It is also easier to de-\nbug imperative programming code. This is because it is easier to obtain and print all\nrelevant intermediate variable values, or use Python\u2019s built-in debugging tools.\n\u000fSymbolic programming is more efficient and easier to port. Symbolic programming\nmakes it easier to optimize the code during compilation, while also having the ability\nto port the program into a format independent of Python. This allows the program to\nbe run in a non-Python environment, thus avoiding any potential performance issues\nrelated to the Python interpreter.\n13.1.2Hybrid Programming\nHistorically most deep learning frameworks choose between an imperative or a symbolic\napproach. For example, Theano, TensorFlow (inspired by the former), Keras, and CNTK\nformulate models symbolically. Conversely, Chainer and PyTorch take an imperative ap-\nproach. AnimperativemodewasaddedtoTensorFlow2.0andKerasinlaterrevisions.\nAsmentionedabove,PyTorchisbasedonimperativeprogrammingandusesdynamiccom-\nputationgraphs. Inanefforttoleveragetheportabilityandefficiencyofsymbolicprogram-\nming, developers considered whether it would be possible to combine the benefits of both\n550 Computational Performance\nprogramming paradigms. This led to a torchscript that lets users develop and debug us-\ning pure imperative programming, while having the ability to convert most programs into\nsymbolic programs to be run when product-level computing performance and deployment\nare required.\n13.1.3Hybridizing the Sequential Class\nTheeasiestwaytogetafeelforhowhybridizationworksistoconsiderdeepnetworkswith\nmultiple layers.", "mimetype": "text/plain", "start_char_idx": 1206468, "end_char_idx": 1210485, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e4832e7c-8f15-4bc8-ae93-d33ff7d0cfc5": {"__data__": {"id_": "e4832e7c-8f15-4bc8-ae93-d33ff7d0cfc5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7f706f29-d30f-41bb-9478-08833679dacd", "node_type": "1", "metadata": {}, "hash": "29a7d798007eac746a0355922f1ff9966261d4e0ec08441e3b2277f419f05920", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e62583b0-f0d9-49b1-b704-bee5b88b2e91", "node_type": "1", "metadata": {}, "hash": "0ef7216c2b7fe953d51fefc3e050f5cdb8f2190e0e76408a7c1301b682acb759", "class_name": "RelatedNodeInfo"}}, "text": "Conversely, Chainer and PyTorch take an imperative ap-\nproach. AnimperativemodewasaddedtoTensorFlow2.0andKerasinlaterrevisions.\nAsmentionedabove,PyTorchisbasedonimperativeprogrammingandusesdynamiccom-\nputationgraphs. Inanefforttoleveragetheportabilityandefficiencyofsymbolicprogram-\nming, developers considered whether it would be possible to combine the benefits of both\n550 Computational Performance\nprogramming paradigms. This led to a torchscript that lets users develop and debug us-\ning pure imperative programming, while having the ability to convert most programs into\nsymbolic programs to be run when product-level computing performance and deployment\nare required.\n13.1.3Hybridizing the Sequential Class\nTheeasiestwaytogetafeelforhowhybridizationworksistoconsiderdeepnetworkswith\nmultiple layers. Conventionally the Python interpreter will need to execute the code for all\nlayerstogenerateaninstructionthatcanthenbeforwardedtoaCPUoraGPU.Forasingle\n(fast) computing device this does not cause any major issues. On the other hand, if we use\nanadvanced8-GPUserversuchasanAWSP3dn.24xlargeinstancePythonwillstruggleto\nkeep all GPUs busy. The single-threaded Python interpreter becomes the bottleneck here.\nLet\u2019sseehowwecanaddressthisforsignificantpartsofthecodebyreplacing Sequential\nwith HybridSequential . We begin by defining a simple MLP.\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n# Factory for networks\ndef get_net ():\nnet =nn.Sequential(nn .Linear( 512,256),\nnn.ReLU(),\nnn.Linear( 256,128),\nnn.ReLU(),\nnn.Linear( 128,2))\nreturn net\nx=torch .randn(size =(1,512))\nnet =get_net()\nnet(x)\ntensor([[ -0.1602 ,0.0003 ]], grad_fn =<AddmmBackward0 >)\nByconvertingthemodelusing torch.jit.script function,weareabletocompileandop-\ntimizethecomputationintheMLP.Themodel\u2019scomputationresultremainsunchanged.\nnet =torch .jit.script(net)\nnet(x)\ntensor([[ -0.1602 ,0.0003 ]], grad_fn =<AddmmBackward0 >)\nThis seems almost too good to be true: write the same code as before and simply convert\nthe model using torch.jit.script . Once this happens the network is optimized (we will\nbenchmark the performance below).\n551 Compilers and Interpreters\nAccelerationbyHybridization\nTo demonstrate the performance improvement gained by compilation we compare the time\nneeded to evaluate net(x)before and after hybridization. Let\u2019s define a class to measure\nthis time first. It will come handy throughout the chapter as we set out to measure (and\nimprove) performance.\n#@save\nclass Benchmark :\n\"\"\"For measuring running time.\"\"\"\ndef __init__ (self , description ='Done '):\nself .description =description\ndef __enter__ (self ):\nself .timer =d2l.Timer()\nreturn self\ndef __exit__ (self ,*args):\nprint (f'{self .description }:{self .timer .stop() :.4f}sec')\nNow we can invoke the network twice, once with and once without torchscript.\nnet =get_net()\nwith Benchmark( 'Without torchscript '):\nfor iinrange (1000 ): net(x)\nnet =torch .jit.script(net)\nwith Benchmark( 'With torchscript '):\nfor iinrange (1000 ): net(x)\nWithout torchscript: 2.1447 sec\nWith torchscript: 4.0545 sec\nAs is observed in the above results, after an nn.Sequential instance is scripted using\nthetorch.jit.script function, computing performance is improved through the use of\nsymbolic programming.\nSerialization\nOne of the benefits of compiling the models is that we can serialize (save) the model and\nits parameters to disk. This allows us to store a model in a manner that is independent of\nthe front-end language of choice. This allows us to deploy trained models to other devices\nand easily use other front-end programming languages. At the same time the code is often\nfaster than what can be achieved in imperative programming. Let\u2019s see the savefunction\nin action.", "mimetype": "text/plain", "start_char_idx": 1209679, "end_char_idx": 1213415, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e62583b0-f0d9-49b1-b704-bee5b88b2e91": {"__data__": {"id_": "e62583b0-f0d9-49b1-b704-bee5b88b2e91", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e4832e7c-8f15-4bc8-ae93-d33ff7d0cfc5", "node_type": "1", "metadata": {}, "hash": "ab3f5d225fad5b6a25318ab3f8476e6a92560f4ee6a73b5c6b5b51b2198f62f3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4ef04176-c2a4-452b-962c-c378ef3bbbcb", "node_type": "1", "metadata": {}, "hash": "6ddb7b0b672c3da5eeed8d671278cdfc2504937be5734f5168540e9ace732ef8", "class_name": "RelatedNodeInfo"}}, "text": "Serialization\nOne of the benefits of compiling the models is that we can serialize (save) the model and\nits parameters to disk. This allows us to store a model in a manner that is independent of\nthe front-end language of choice. This allows us to deploy trained models to other devices\nand easily use other front-end programming languages. At the same time the code is often\nfaster than what can be achieved in imperative programming. Let\u2019s see the savefunction\nin action.\nnet.save('my_mlp')\n!ls -lh my_mlp*\n552 Computational Performance\n184-rw-r--r--1ci ci 651K Aug 1819:32my_mlp\n13.1.4Summary\n\u000fImperativeprogrammingmakesiteasytodesignnewmodelssinceitispossibletowrite\ncode with control flow and the ability to use a large amount of the Python software\necosystem.\n\u000fSymbolic programming requires that we specify the program and compile it before exe-\ncuting it. The benefit is improved performance.\n13.1.5Exercises\n1.Review the models that interest you in the previous chapters. Can you improve their\ncomputational performance by reimplementing them?\nDiscussions184.\n13.2AsynchronousComputation\nToday\u2019s computers are highly parallel systems, consisting of multiple CPU cores (often\nmultiplethreadspercore),multipleprocessingelementsperGPU,andoftenmultipleGPUs\nperdevice. Inshort, wecanprocessmanydifferentthingsatthesametime, oftenondiffer-\nent devices. Unfortunately Python is not a great way of writing parallel and asynchronous\ncode, at least not without some extra help. After all, Python is single-threaded and this is\nunlikely to change in the future. Deep learning frameworks such as MXNet and Tensor-\nFlow adopt an asynchronousprogramming model to improve performance, while PyTorch\nuses Python\u2019s own scheduler leading to a different performance trade-off. For PyTorch, by\ndefault,GPUoperationsareasynchronous. WhenyoucallafunctionthatusestheGPU,the\noperations are enqueued to the particular device, but not necessarily executed until later.\nThis allows us to execute more computations in parallel, including operations on the CPU\nor other GPUs.\nHence, understanding how asynchronous programming works helps us to develop more\nefficient programs, by proactively reducing computational requirements and mutual de-\npendencies. This allows us to reduce memory overhead and increase processor utiliza-\ntion.\nimport os\nimport subprocess\nimport numpy\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n553 Asynchronous Computation\n13.2.1Asynchronyvia Backend\nFor a warmup consider the following toy problem: we want to generate a random matrix\nand multiply it. Let\u2019s do that both in NumPy and in PyTorch tensor to see the difference.\nNote that PyTorch tensoris defined on a GPU.\n# Warmup for GPU computation\ndevice =d2l.try_gpu()\na=torch .randn(size =(1000 ,1000 ), device =device)\nb=torch .mm(a, a)\nwith d2l.Benchmark( 'numpy '):\nfor _inrange (10):\na=numpy .random .normal(size =(1000 ,1000 ))\nb=numpy .dot(a, a)\nwith d2l.Benchmark( 'torch '):\nfor _inrange (10):\na=torch .randn(size =(1000 ,1000 ), device =device)\nb=torch .mm(a, a)\nnumpy: 1.4693 sec\ntorch: 0.0022 sec\nThebenchmarkoutputviaPyTorchisordersofmagnitudefaster. NumPydotproductisex-\necuted on the CPU processor while PyTorchmatrix multiplication is executedon GPU and\nhence the latter is expected to be much faster. But the huge time difference suggests some-\nthing else must be going on. By default, GPU operations are asynchronous in PyTorch.\nForcing PyTorch to finish all computation prior to returning shows what happened previ-\nously: computation is being executed by the backend while the frontend returns control to\nPython.\nwith d2l.Benchmark():\nfor _inrange (10):\na=torch .randn(size =(1000 ,1000 ), device =device)\nb=torch .mm(a, a)\ntorch .cuda .synchronize(device)\nDone: 0.0058 sec\nBroadly speaking, PyTorch has a frontend for direct interaction with the users, e.g., via\nPython, as well as a backend used by the system to perform the computation. As shown\ninFig. 13.2.1 , users can write PyTorch programs in various frontend languages, such as\nPython and C++.", "mimetype": "text/plain", "start_char_idx": 1212943, "end_char_idx": 1216989, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4ef04176-c2a4-452b-962c-c378ef3bbbcb": {"__data__": {"id_": "4ef04176-c2a4-452b-962c-c378ef3bbbcb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e62583b0-f0d9-49b1-b704-bee5b88b2e91", "node_type": "1", "metadata": {}, "hash": "0ef7216c2b7fe953d51fefc3e050f5cdb8f2190e0e76408a7c1301b682acb759", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "acc3a559-70a7-4eed-9406-50d986e7e19a", "node_type": "1", "metadata": {}, "hash": "ed22ed4e7a816d041a11c5ee9148e53172595c333be6e2b84587e825eefc5977", "class_name": "RelatedNodeInfo"}}, "text": "But the huge time difference suggests some-\nthing else must be going on. By default, GPU operations are asynchronous in PyTorch.\nForcing PyTorch to finish all computation prior to returning shows what happened previ-\nously: computation is being executed by the backend while the frontend returns control to\nPython.\nwith d2l.Benchmark():\nfor _inrange (10):\na=torch .randn(size =(1000 ,1000 ), device =device)\nb=torch .mm(a, a)\ntorch .cuda .synchronize(device)\nDone: 0.0058 sec\nBroadly speaking, PyTorch has a frontend for direct interaction with the users, e.g., via\nPython, as well as a backend used by the system to perform the computation. As shown\ninFig. 13.2.1 , users can write PyTorch programs in various frontend languages, such as\nPython and C++. Regardless of the frontend programming language used, the execution of\nPyTorch programs occurs primarily in the backend of C++ implementations. Operations\nissued by the frontend language are passed on to the backend for execution. The backend\nmanages its own threads that continuously collect and execute queued tasks. Note that for\nthis to work the backend must be able to keep track of the dependencies between various\n554 Computational Performance\nsteps in the computational graph. Hence, it is not possible to parallelize operations that\ndepend on each other.\ntFig. 13.2.1 Programming language frontends and deep learning framework backends.\nLet\u2019s look at another toy example to understand the dependency graph a bit better.\nx=torch .ones(( 1,2), device =device)\ny=torch .ones(( 1,2), device =device)\nz=x*y+2\nz\ntensor([[ 3.,3.]], device ='cuda:0 ')\ntFig. 13.2.2 The backend tracks dependencies between various steps in the computational graph.\nThe code snippet above is also illustrated in Fig. 13.2.2 . Whenever the Python frontend\nthread executes one of the first three statements, it simply returns the task to the backend\nqueue. When the last statement\u2019s results need to be printed, the Python frontend thread\nwill wait for the C++ backend thread to finish computing the result of the variable z. One\nbenefit of this design is that the Python frontend thread does not need to perform actual\ncomputations. Thus,thereislittleimpactontheprogram\u2019soverallperformance,regardless\nofPython\u2019sperformance. Fig.13.2.3 illustrateshowfrontendandbackendinteract.\n13.2.2Barriers and Blockers\n13.2.3ImprovingComputation\n555 Automatic Parallelism\ntFig. 13.2.3 Interactions of the frontend and backend.\n18513.2.4Summary\n\u000fDeep learning frameworks may decouple the Python frontend from an execution back-\nend. This allows for fast asynchronous insertion of commands into the backend and\nassociated parallelism.\n\u000fAsynchrony leads to a rather responsive frontend. However, use caution not to overfill\nthetaskqueuesinceitmayleadtoexcessivememoryconsumption. Itisrecommended\nto synchronize for each minibatch to keep frontend and backend approximately syn-\nchronized.\n\u000fChip vendors offer sophisticated performance analysis tools to obtain a much more fine-\ngrained insight into the efficiency of deep learning.\n13.2.5Exercises\n1.On the CPU, benchmark the same matrix multiplication operations in this section. Can\nyou still observe asynchrony via the backend?\nDiscussions185.\n13.3AutomaticParallelism\nDeep learning frameworks (e.g., MXNet and PyTorch) automatically construct computa-\ntional graphs at the backend. Using a computational graph, the system is aware of all the\ndependencies, and can selectively execute multiple non-interdependent tasks in parallel to\nimprove speed. For instance, Fig. 13.2.2 inSection 13.2 initializes two variables indepen-\ndently. Consequently the system can choose to execute them in parallel.\nTypically,asingleoperatorwilluseallthecomputationalresourcesonallCPUsoronasin-\ngleGPU.Forexample,the dotoperatorwilluseallcores(andthreads)onallCPUs,evenif\nthere are multiple CPU processors on a single machine. The same applies to a single GPU.\nHence parallelization is not quite so useful for single-device computers. With multiple de-\nvicesthingsmattermore. Whileparallelizationistypicallymostrelevantbetweenmultiple\nGPUs,addingthelocalCPUwillincreaseperformanceslightly. Forexample,seeHadjis et\n556 Computational Performance\nal.(2016) that focuses on training computer vision models combining a GPU and a CPU.", "mimetype": "text/plain", "start_char_idx": 1216235, "end_char_idx": 1220515, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "acc3a559-70a7-4eed-9406-50d986e7e19a": {"__data__": {"id_": "acc3a559-70a7-4eed-9406-50d986e7e19a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4ef04176-c2a4-452b-962c-c378ef3bbbcb", "node_type": "1", "metadata": {}, "hash": "6ddb7b0b672c3da5eeed8d671278cdfc2504937be5734f5168540e9ace732ef8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "87e75afc-8069-40f0-a37d-b9aac3f8c281", "node_type": "1", "metadata": {}, "hash": "00fe9aff2c383a974101392015521d52ae3ce75226b642b4e6895c82cd973674", "class_name": "RelatedNodeInfo"}}, "text": "For instance, Fig. 13.2.2 inSection 13.2 initializes two variables indepen-\ndently. Consequently the system can choose to execute them in parallel.\nTypically,asingleoperatorwilluseallthecomputationalresourcesonallCPUsoronasin-\ngleGPU.Forexample,the dotoperatorwilluseallcores(andthreads)onallCPUs,evenif\nthere are multiple CPU processors on a single machine. The same applies to a single GPU.\nHence parallelization is not quite so useful for single-device computers. With multiple de-\nvicesthingsmattermore. Whileparallelizationistypicallymostrelevantbetweenmultiple\nGPUs,addingthelocalCPUwillincreaseperformanceslightly. Forexample,seeHadjis et\n556 Computational Performance\nal.(2016) that focuses on training computer vision models combining a GPU and a CPU.\nWith the convenience of an automatically parallelizing framework we can accomplish the\nsamegoalinafewlinesofPythoncode. Morebroadly,ourdiscussionofautomaticparallel\ncomputation focuses on parallel computation using both CPUs and GPUs, as well as the\nparallelization of computation and communication.\nNote that we need at least two GPUs to run the experiments in this section.\nimport torch\nfrom d2l import torch asd2l\n13.3.1ParallelComputation on GPUs\nLet\u2019s start by defining a reference workload to test: the runfunction below performs 10\nmatrix-matrix multiplications on the device of our choice using data allocated into two\nvariables: x_gpu1andx_gpu2.\ndevices =d2l.try_all_gpus()\ndef run(x):\nreturn [x.mm(x) for _inrange (50)]\nx_gpu1 =torch .rand(size =(4000 ,4000 ), device =devices[ 0])\nx_gpu2 =torch .rand(size =(4000 ,4000 ), device =devices[ 1])\nNow we apply the function to the data. To ensure that caching does not play a role in the\nresults we warm up the devices by performing a single pass on either of them prior to mea-\nsuring. torch.cuda.synchronize() waitsforallkernelsinallstreamsonaCUDAdevice\nto complete. It takes in a deviceargument, the device for which we need to synchronize.\nIt uses the current device, given by current_device() , if the device argument is None\n(default).\nrun(x_gpu1)\nrun(x_gpu2) # Warm-up all devices\ntorch .cuda .synchronize(devices[ 0])\ntorch .cuda .synchronize(devices[ 1])\nwith d2l.Benchmark( 'GPU1 time '):\nrun(x_gpu1)\ntorch .cuda .synchronize(devices[ 0])\nwith d2l.Benchmark( 'GPU2 time '):\nrun(x_gpu2)\ntorch .cuda .synchronize(devices[ 1])\nGPU1 time: 0.4660 sec\nGPU2 time: 0.4510 sec\nIfweremovethe synchronize statementbetweenbothtasksthesystemisfreetoparallelize\ncomputation on both devices automatically.\n557 Automatic Parallelism\nwith d2l.Benchmark( 'GPU1 & GPU2 '):\nrun(x_gpu1)\nrun(x_gpu2)\ntorch .cuda .synchronize()\nGPU1 &GPU2: 0.4659 sec\nIn the above case the total execution time is less than the sum of its parts, since the deep\nlearningframeworkautomaticallyschedulescomputationonbothGPUdeviceswithoutthe\nneed for sophisticated code on behalf of the user.\n13.3.2ParallelComputation and Communication\nIn many cases we need to move data between different devices, say between the CPU and\nGPU, or between different GPUs. For instance, this occurs when we want to perform dis-\ntributed optimization where we need to aggregate the gradients over multiple accelerator\ncards. Let\u2019s simulate this by computing on the GPU and then copying the results back to\nthe CPU.\ndef copy_to_cpu (x, non_blocking =False ):\nreturn [y.to('cpu', non_blocking =non_blocking) for yinx]\nwith d2l.Benchmark( 'Run on GPU1 '):\ny=run(x_gpu1)\ntorch .cuda .synchronize()\nwith d2l.Benchmark( 'Copy to CPU '):\ny_cpu =copy_to_cpu(y)\ntorch .cuda .synchronize()\nRun on GPU1: 0.4656 sec\nCopy to CPU: 2.3125 sec\nThisissomewhatinefficient. Notethatwecouldalreadystartcopyingpartsof ytotheCPU\nwhile the remainder of the list is still being computed. This situation occurs, e.g., when we\ncompute the (backprop) gradient on a minibatch.", "mimetype": "text/plain", "start_char_idx": 1219755, "end_char_idx": 1223567, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "87e75afc-8069-40f0-a37d-b9aac3f8c281": {"__data__": {"id_": "87e75afc-8069-40f0-a37d-b9aac3f8c281", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "acc3a559-70a7-4eed-9406-50d986e7e19a", "node_type": "1", "metadata": {}, "hash": "ed22ed4e7a816d041a11c5ee9148e53172595c333be6e2b84587e825eefc5977", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "11e32d85-68f1-41b2-9dec-8054d5146547", "node_type": "1", "metadata": {}, "hash": "34522b1fab90afe1233c3ea22d93116ef8f5ebd6bb2bec64b0411d9c667e491d", "class_name": "RelatedNodeInfo"}}, "text": "Let\u2019s simulate this by computing on the GPU and then copying the results back to\nthe CPU.\ndef copy_to_cpu (x, non_blocking =False ):\nreturn [y.to('cpu', non_blocking =non_blocking) for yinx]\nwith d2l.Benchmark( 'Run on GPU1 '):\ny=run(x_gpu1)\ntorch .cuda .synchronize()\nwith d2l.Benchmark( 'Copy to CPU '):\ny_cpu =copy_to_cpu(y)\ntorch .cuda .synchronize()\nRun on GPU1: 0.4656 sec\nCopy to CPU: 2.3125 sec\nThisissomewhatinefficient. Notethatwecouldalreadystartcopyingpartsof ytotheCPU\nwhile the remainder of the list is still being computed. This situation occurs, e.g., when we\ncompute the (backprop) gradient on a minibatch. The gradients of some of the parameters\nwill be available earlier than that of others. Hence it works to our advantage to start using\nPCI-Express bus bandwidth while the GPU is still running. In PyTorch, several functions\nsuchas to()andcopy_() admitanexplicit non_blocking argument, whichletsthecaller\nbypass synchronization when it is unnecessary. Setting non_blocking=True allows us to\nsimulate this scenario.\nwith d2l.Benchmark( 'Run on GPU1 and copy to CPU '):\ny=run(x_gpu1)\ny_cpu =copy_to_cpu(y, True )\ntorch .cuda .synchronize()\n558 Computational Performance\nRun on GPU1 and copy to CPU: 1.6907 sec\nThe total time required for both operations is (as expected) less than the sum of their parts.\nNote that this task is different from parallel computation as it uses a different resource: the\nbusbetweentheCPUandGPUs. Infact,wecouldcomputeonbothdevicesandcommuni-\ncate, all at the same time. As noted above, there is a dependency between computation and\ncommunication: y[i]must be computed before it can be copied to the CPU. Fortunately,\nthesystemcancopy y[i-1]whilecomputing y[i]toreducethetotalrunningtime.\nWe conclude with an illustration of the computational graph and its dependencies for a\nsimpletwo-layerMLPwhentrainingonaCPUandtwoGPUs,asdepictedin Fig.13.3.1 . It\nwouldbequitepainfultoscheduletheparallelprogramresultingfromthismanually. Thisis\nwhereitisadvantageoustohaveagraph-basedcomputingbackendforoptimization.\ntFig. 13.3.1 The computational graph and its dependencies of a two-layer MLP on a CPU and two\nGPUs.\n13.3.3Summary\n\u000fModern systems have a variety of devices, such as multiple GPUs and CPUs. They can\nbe used in parallel, asynchronously.\n\u000fModern systems also have a variety of resources for communication, such as PCI Ex-\npress, storage (typically solid-state drives or via networks), and network bandwidth.\nThey can be used in parallel for peak efficiency.\n\u000fThebackendcanimproveperformancethroughautomaticparallelcomputationandcom-\nmunication.\n559 Hardware\n186\n18713.3.4Exercises\n1.Eight operations were performed in the runfunction defined in this section. There\nare no dependencies between them. Design an experiment to see if the deep learning\nframework will automatically execute them in parallel.\n2.When the workload of an individual operator is sufficiently small, parallelization can\nhelp even on a single CPU or GPU. Design an experiment to verify this.\n3.Design an experiment that uses parallel computation on CPUs, GPUs, and communica-\ntion between both devices.\n4.Use a debugger such as NVIDIA\u2019s Nsight186to verify that your code is efficient.\n5.Designing computation tasks that include more complex data dependencies, and run\nexperiments to see if you can obtain the correct results while improving performance.\nDiscussions187.\n13.4Hardware\nBuilding systems with great performance requires a good understanding of the algorithms\nand models to capture the statistical aspects of the problem. At the same time it is also\nindispensable to have at least a modicum of knowledge of the underlying hardware. The\ncurrentsectionisnosubstituteforapropercourseonhardwareandsystemdesign. Instead,\nit might serve as a starting point for understanding why some algorithms are more efficient\nthan others and how to achieve good throughput. A good design can easily make a differ-\nenceofanorderofmagnitudeand,inturn,thiscanmakethedifferencebetweenbeingable\nto train a network (e.g., in a week) and not at all (in 3 months, thus missing the deadline).\nWe will start by looking at computers.", "mimetype": "text/plain", "start_char_idx": 1222944, "end_char_idx": 1227080, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "11e32d85-68f1-41b2-9dec-8054d5146547": {"__data__": {"id_": "11e32d85-68f1-41b2-9dec-8054d5146547", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "87e75afc-8069-40f0-a37d-b9aac3f8c281", "node_type": "1", "metadata": {}, "hash": "00fe9aff2c383a974101392015521d52ae3ce75226b642b4e6895c82cd973674", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "17d75778-1247-4631-bd0f-319f0ee3f7c3", "node_type": "1", "metadata": {}, "hash": "56ee18b57b412513773ac00fb3235e321bd35e4af7ffc0c839d6f40a2949653b", "class_name": "RelatedNodeInfo"}}, "text": "Discussions187.\n13.4Hardware\nBuilding systems with great performance requires a good understanding of the algorithms\nand models to capture the statistical aspects of the problem. At the same time it is also\nindispensable to have at least a modicum of knowledge of the underlying hardware. The\ncurrentsectionisnosubstituteforapropercourseonhardwareandsystemdesign. Instead,\nit might serve as a starting point for understanding why some algorithms are more efficient\nthan others and how to achieve good throughput. A good design can easily make a differ-\nenceofanorderofmagnitudeand,inturn,thiscanmakethedifferencebetweenbeingable\nto train a network (e.g., in a week) and not at all (in 3 months, thus missing the deadline).\nWe will start by looking at computers. Then we will zoom in to look more carefully at\nCPUs and GPUs. Lastly we zoom out to review how multiple computers are connected in\na server center or in the cloud.\ntFig. 13.4.1 Latency Numbers that every programmer should know.\n560 Computational Performance\n188\n189\n190Impatientreadersmaybeabletogetbywith Fig.13.4.1 . ItistakenfromColinScott\u2019s inter-\nactivepost188thatgivesagoodoverviewoftheprogressoverthepastdecade. Theoriginal\nnumbersareduetoJeffDean\u2019s Stanfordtalkfrom2010189. Thediscussionbelowexplains\nsomeoftherationaleforthesenumbersandhowtheycanguideusindesigningalgorithms.\nThe discussion below is very high level and cursory. It is clearly no substitute for a proper\ncoursebutratherjustmeanttoprovideenoughinformationforastatisticalmodelertomake\nsuitable design decisions. For an in-depth overview of computer architecture we refer the\nreader to ( Hennessy and Patterson, 2011 ) or a recent course on the subject, such as the one\nbyArste Asanovic190.\n13.4.1Computers\nMost deep learning researchers and practitioners have access to a computer with a fair\namount of memory, computation, some form of an accelerator such as a GPU, or multiples\nthereof. A computer consists of the following key components:\n\u000fAprocessor(alsoreferredtoasaCPU)thatisabletoexecutetheprogramswegiveit(in\naddition to running an operating system and many other things), typically consisting\nof 8 or more cores.\n\u000fMemory (RAM) to store and retrieve the results from computation, such as weight vec-\ntors and activations, and training data.\n\u000fAnEthernetnetworkconnection(sometimesmultiple)withspeedsrangingfrom1GB/s\nto 100 GB/s. On high end servers more advanced interconnects can be found.\n\u000fA high speed expansion bus (PCIe) to connect the system to one or more GPUs. Servers\nhave up to 8 accelerators, often connected in an advanced topology, while desktop\nsystems have 1 or 2, depending on the budget of the user and the size of the power\nsupply.\n\u000fDurable storage, such as a magnetic hard disk drive, a solid state drive, in many cases\nconnected using the PCIe bus. It provides efficient transfer of training data to the\nsystem and storage of intermediate checkpoints as needed.\ntFig. 13.4.2 Connectivity of components of a computer.\nAsFig. 13.4.2 indicates, most components (network, GPU, and storage) are connected to\nthe CPU across the PCIe bus. It consists of multiple lanes that are directly attached to the\nCPU. For instance AMD\u2019s Threadripper 3 has 64 PCIe 4.0 lanes, each of which is capable\n16Gbit/sdatatransferinbothdirections. ThememoryisdirectlyattachedtotheCPUwith\na total bandwidth of up to 100 GB/s.\nWhenweruncodeonacomputerweneedtoshuffledatatotheprocessors(CPUsorGPUs),\n561 Hardware\n191\n192\n193\n194performcomputation,andthenmovetheresultsofftheprocessorbacktoRAManddurable\nstorage. Hence, in order to get good performance we need to make sure that this works\nseamlessly without any one of the systems becoming a major bottleneck. For instance, if\nwecannotloadimagesquicklyenoughtheprocessorwillnothaveanyworktodo. Likewise,\nif we cannot move matrices quickly enough to the CPU (or GPU), its processing elements\nwill starve. Finally, if we want to synchronize multiple computers across the network, the\nlatter should not slow down computation. One option is to interleave communication and\ncomputation.", "mimetype": "text/plain", "start_char_idx": 1226319, "end_char_idx": 1230382, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "17d75778-1247-4631-bd0f-319f0ee3f7c3": {"__data__": {"id_": "17d75778-1247-4631-bd0f-319f0ee3f7c3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "11e32d85-68f1-41b2-9dec-8054d5146547", "node_type": "1", "metadata": {}, "hash": "34522b1fab90afe1233c3ea22d93116ef8f5ebd6bb2bec64b0411d9c667e491d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0eea75ec-3e05-4f76-8dae-8664f16e6830", "node_type": "1", "metadata": {}, "hash": "7dea3d0b0298438eadf9369b365b18b0c9609881ca826aa441e2ff2e0cfdde51", "class_name": "RelatedNodeInfo"}}, "text": "Whenweruncodeonacomputerweneedtoshuffledatatotheprocessors(CPUsorGPUs),\n561 Hardware\n191\n192\n193\n194performcomputation,andthenmovetheresultsofftheprocessorbacktoRAManddurable\nstorage. Hence, in order to get good performance we need to make sure that this works\nseamlessly without any one of the systems becoming a major bottleneck. For instance, if\nwecannotloadimagesquicklyenoughtheprocessorwillnothaveanyworktodo. Likewise,\nif we cannot move matrices quickly enough to the CPU (or GPU), its processing elements\nwill starve. Finally, if we want to synchronize multiple computers across the network, the\nlatter should not slow down computation. One option is to interleave communication and\ncomputation. Let\u2019s have a look at the various components in more detail.\n13.4.2Memory\nAt its most basic memory is used to store data that needs to be readily accessible. At\npresent CPU RAM is typically of the DDR4191variety, offering 20\u201325 GB/s bandwidth\nper module. Each module has a 64-bit-wide bus. Typically pairs of memory modules are\nused to allow for multiple channels. CPUs have between 2 and 4 memory channels, i.e.,\nthey have between 4 0GB/s and 100 GB/s peak memory bandwidth. Often there are two\nbanks per channel. For instance AMD\u2019s Zen 3 Threadripper has 8 slots.\nWhile these numbers are impressive, indeed, they only tell part of the story. When we\nwant to read a portion from memory we first need to tell the memory module where the\ninformation can be found. That is, we first need to send the address to RAM. Once this\nis accomplished we can choose to read just a single 64 bit record or a long sequence of\nrecords. The latter is called burst read . In a nutshell, sending an address to memory and\nsetting up the transfer takes approximately 100 ns (details depend on the specific timing\ncoefficients of the memory chips used), every subsequent transfer takes only 0.2 ns. In\nshort, the first read is 500 times as expensive as subsequent ones! Note that we could\nperform up to 10,000,000 random reads per second. This suggests that we avoid random\nmemory access as far as possible and use burst reads (and writes) instead.\nMatters are a bit more complex when we take into account that we have multiple banks.\nEach bank can read memory largely independently. This means two things. On the one\nhand, the effective number of random reads is up to 4 times higher, provided that they are\nspread evenly across memory. It also means that it is still a bad idea to perform random\nreadssinceburstreadsare4timesfaster, too. Ontheotherhand, duetomemoryalignment\nto 64 bit boundaries it is a good idea to align any data structures with the same boundaries.\nCompilersdothisprettymuch automatically192whentheappropriateflagsareset. Curious\nreaders are encouraged to review a lecture on DRAMs such as the one by Zeshan Chishti\n193.\nGPUmemoryissubjecttoevenhigherbandwidthrequirementssincetheyhavemanymore\nprocessing elements than CPUs. By and large there are two options to address them. The\nfirst is to make the memory bus significantly wider. For instance, NVIDIA\u2019s RTX 2080\nTi has a 352-bit-wide bus. This allows for much more information to be transferred at\nthe same time. Second, GPUs use specific high-performance memory. Consumer-grade\ndevices, such as NVIDIA\u2019s RTX and Titan series typically use GDDR6194chips with over\n500 GB/s aggregate bandwidth. An alternative is to use HBM (high bandwidth memory)\nmodules. TheyuseaverydifferentinterfaceandconnectdirectlywithGPUsonadedicated\n562 Computational Performance\nsiliconwafer. Thismakesthemveryexpensiveandtheiruseistypicallylimitedtohigh-end\nserver chips, such as the NVIDIA Volta V100 series of accelerators. Quite unsurprisingly,\nGPU memory is generally muchsmaller than CPU memory due to the higher cost of the\nformer. For our purposes, by and large their performance characteristics are similar, just a\nlot faster. We can safely ignore the details for the purpose of this book. They only matter\nwhen tuning GPU kernels for high throughput.\n13.4.3Storage\nWe saw that some of the key characteristics of RAM are bandwidth andlatency.", "mimetype": "text/plain", "start_char_idx": 1229679, "end_char_idx": 1233764, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0eea75ec-3e05-4f76-8dae-8664f16e6830": {"__data__": {"id_": "0eea75ec-3e05-4f76-8dae-8664f16e6830", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "17d75778-1247-4631-bd0f-319f0ee3f7c3", "node_type": "1", "metadata": {}, "hash": "56ee18b57b412513773ac00fb3235e321bd35e4af7ffc0c839d6f40a2949653b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fc141463-fae4-476a-be7d-73f4dccf807b", "node_type": "1", "metadata": {}, "hash": "53bc65ccea7c355d4864196d26960f77b52fbb6af69aa271d1e7dc86dffb1ab0", "class_name": "RelatedNodeInfo"}}, "text": "An alternative is to use HBM (high bandwidth memory)\nmodules. TheyuseaverydifferentinterfaceandconnectdirectlywithGPUsonadedicated\n562 Computational Performance\nsiliconwafer. Thismakesthemveryexpensiveandtheiruseistypicallylimitedtohigh-end\nserver chips, such as the NVIDIA Volta V100 series of accelerators. Quite unsurprisingly,\nGPU memory is generally muchsmaller than CPU memory due to the higher cost of the\nformer. For our purposes, by and large their performance characteristics are similar, just a\nlot faster. We can safely ignore the details for the purpose of this book. They only matter\nwhen tuning GPU kernels for high throughput.\n13.4.3Storage\nWe saw that some of the key characteristics of RAM are bandwidth andlatency. The same\nis true for storage devices, just that the differences can be even more extreme.\nHardDisk Drives\nHarddiskdrives (HDDs)havebeeninuseforoverhalfacentury. Inanutshelltheycontain\nanumberofspinningplatterswithheadsthatcanbepositionedtoreadorwriteatanygiven\ntrack. High-end disks hold up to 16 TB on 9 platters. One of the key benefits of HDDs\nis that they are relatively inexpensive. One of their many downsides are their typically\ncatastrophic failure modes and their relatively high read latency.\nTounderstandthelatter,considerthefactthatHDDsspinataround7,200RPM(revolutions\nperminute). Iftheyweremuchfastertheywouldshatterduetothecentrifugalforceexerted\non the platters. This has a major downside when it comes to accessing a specific sector\non the disk: we need to wait until the platter has rotated in position (we can move the\nheads but not accelerate the actual disks). Hence it can take over 8 ms until the requested\ndata is available. A common way this is expressed is to say that HDDs can operate at\napproximately100IOPs(input/outputoperationspersecond). Thisnumberhasessentially\nremained unchanged for the past two decades. Worse still, it is equally difficult to increase\nbandwidth (it is in the order of 100\u2013200 MB/s). After all, each head reads a track of bits,\nhence the bit rate only scales with the square root of the information density. As a result,\nHDDs are quickly becoming relegated to archival storage and low-grade storage for very\nlarge datasets.\nSolidState Drives\nSolid state drives (SSDs) use flash memory to store information persistently. This allows\nformuch faster access to stored records. Modern SSDs can operate at 100,000 to 500,000\nIOPs, i.e., up to 3 orders of magnitude faster than HDDs. Furthermore, their bandwidth\ncan reach 1\u20133GB/s, i.e., one order of magnitude faster than HDDs. These improvements\nsound almost too good to be true. Indeed, they come with the following caveats, due to the\nway SSDs are designed.\n\u000fSSDsstoreinformationinblocks(256KBorlarger). Theycanonlybewrittenasawhole,\nwhich takes significant time. Consequently bit-wise random writes on SSD have very\npoor performance. Likewise, writing data in general takes significant time since the\nblock has to be read, erased and then rewritten with new information. By now SSD\n563 Hardware\ncontrollers and firmware have developed algorithms to mitigate this. Nonetheless,\nwrites can be much slower, in particular for QLC (quad level cell) SSDs. The key\nfor improved performance is to maintain a queueof operations, to prefer reads and to\nwrite in large blocks if possible.\n\u000fThememorycellsinSSDswearoutrelativelyquickly(oftenalreadyafterafewthousand\nwrites). Wear-levelprotectionalgorithmsareabletospreadthedegradationovermany\ncells. That said, it is not recommended to use SSDs for swapping files or for large\naggregations of log-files.\n\u000fLastly, the massive increase in bandwidth has forced computer designers to attach SSDs\ndirectly to the PCIe bus. The drives capable of handling this, referred to as NVMe\n(Non Volatile Memory enhanced), can use up to 4 PCIe lanes. This amounts to up to\n8GB/s on PCIe 4.0.\nCloud Storage\nCloud storage provides a configurable range of performance. That is, the assignment of\nstorage to virtual machines is dynamic, both in terms of quantity and in terms of speed,\nas chosen by users.", "mimetype": "text/plain", "start_char_idx": 1233031, "end_char_idx": 1237088, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fc141463-fae4-476a-be7d-73f4dccf807b": {"__data__": {"id_": "fc141463-fae4-476a-be7d-73f4dccf807b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0eea75ec-3e05-4f76-8dae-8664f16e6830", "node_type": "1", "metadata": {}, "hash": "7dea3d0b0298438eadf9369b365b18b0c9609881ca826aa441e2ff2e0cfdde51", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "64c117fe-f2ca-41d3-b8dd-52609c6c65e6", "node_type": "1", "metadata": {}, "hash": "b076b5c8641149bc5f21eacf89872f427209da68653f65901ff8f4c471414c6d", "class_name": "RelatedNodeInfo"}}, "text": "\u000fThememorycellsinSSDswearoutrelativelyquickly(oftenalreadyafterafewthousand\nwrites). Wear-levelprotectionalgorithmsareabletospreadthedegradationovermany\ncells. That said, it is not recommended to use SSDs for swapping files or for large\naggregations of log-files.\n\u000fLastly, the massive increase in bandwidth has forced computer designers to attach SSDs\ndirectly to the PCIe bus. The drives capable of handling this, referred to as NVMe\n(Non Volatile Memory enhanced), can use up to 4 PCIe lanes. This amounts to up to\n8GB/s on PCIe 4.0.\nCloud Storage\nCloud storage provides a configurable range of performance. That is, the assignment of\nstorage to virtual machines is dynamic, both in terms of quantity and in terms of speed,\nas chosen by users. We recommend that users increase the provisioned number of IOPs\nwhenever latency is too high, e.g., during training with many small records.\n13.4.4CPUs\nCentral processing units (CPUs) are the centerpiece of any computer. They consist of a\nnumber of key components: processor cores that are able to execute machine code, a bus\nconnectingthem(thespecifictopologydifferssignificantlybetweenprocessormodels,gen-\nerations,andvendors),and cachestoallowforhigherbandwidthandlowerlatencymemory\naccess than what is possible by reads from main memory. Lastly, almost all modern CPUs\ncontainvector processing units to aid with high performance linear algebra and convolu-\ntions, as they are common in media processing and machine learning.\ntFig. 13.4.3 Intel Skylake consumer quad-core CPU.\nFig. 13.4.3 depicts an Intel Skylake consumer-grade quad-core CPU. It has an integrated\n564 Computational Performance\n195GPU,caches, andaringbusconnectingthefourcores. Peripherals, suchasEthernet, WiFi,\nBluetooth, SSD controller, and USB, are either part of the chipset or directly attached\n(PCIe) to the CPU.\nMicroarchitecture\nEach of the processor cores consists of a rather sophisticated set of components. While\ndetails differ between generations and vendors, the basic functionality is pretty much stan-\ndard. The front-end loads instructions and tries to predict which path will be taken (e.g.,\nfor control flow). Instructions are then decoded from assembly code to microinstructions.\nAssembly code is often not the lowest level code that a processor executes. Instead, com-\nplex instructions may be decoded into a set of more lower level operations. These are then\nprocessed by the actual execution core. Often the latter is capable of performing many op-\nerations simultaneously. For instance, the ARM Cortex A77 core of Fig. 13.4.4 is able to\nperform up to 8 operations simultaneously.\ntFig. 13.4.4 ARM Cortex A77 Microarchitecture.\nThis means that efficient programs might be able to perform more than one instruction per\nclock cycle, provided that they can be carried out independently. Not all units are created\nequal. Some specialize in integer instructions whereas others are optimized for floating\npoint performance. To increase throughput, the processor might also follow multiple code\npathssimultaneouslyinabranchinginstructionandthendiscardtheresultsofthebranches\nnot taken. This is why branch prediction units matter (on the front-end) such that only the\nmost promising paths are pursued.\nVectorization\nDeep learning is extremely compute-hungry. Hence, to make CPUs suitable for machine\nlearning, one needs to perform many operations in one clock cycle. This is achieved via\nvector units. They have different names: on ARM they are called NEON, on x86 they (a\nrecentgeneration)arereferredtoas AVX2195units. Acommonaspectisthattheyareable\nto perform SIMD (single instruction multiple data) operations. Fig. 13.4.5 shows how 8\nshort integers can be added in one clock cycle on ARM.\n565 Hardware\ntFig. 13.4.5 128 bit NEON vectorization.\n196Depending on architecture choices, such registers are up to 512 bits long, allowing for the\ncombination of up to 64 pairs of numbers. For instance, we might be multiplying two\nnumbers and adding them to a third, which is also known as a fused multiply-add. Intel\u2019s\nOpenVino196uses these to achieve respectable throughput for deep learning on server-\ngrade CPUs. Note, though, that this number is entirely dwarfed by what GPUs are capable\nof achieving.", "mimetype": "text/plain", "start_char_idx": 1236343, "end_char_idx": 1240576, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "64c117fe-f2ca-41d3-b8dd-52609c6c65e6": {"__data__": {"id_": "64c117fe-f2ca-41d3-b8dd-52609c6c65e6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fc141463-fae4-476a-be7d-73f4dccf807b", "node_type": "1", "metadata": {}, "hash": "53bc65ccea7c355d4864196d26960f77b52fbb6af69aa271d1e7dc86dffb1ab0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "281304a4-4ea0-438b-9955-15e6625d0f5c", "node_type": "1", "metadata": {}, "hash": "56953ad407286dd89fe7248a0f62f8bcb468770d45f1e186bc3fad026742a27c", "class_name": "RelatedNodeInfo"}}, "text": "Acommonaspectisthattheyareable\nto perform SIMD (single instruction multiple data) operations. Fig. 13.4.5 shows how 8\nshort integers can be added in one clock cycle on ARM.\n565 Hardware\ntFig. 13.4.5 128 bit NEON vectorization.\n196Depending on architecture choices, such registers are up to 512 bits long, allowing for the\ncombination of up to 64 pairs of numbers. For instance, we might be multiplying two\nnumbers and adding them to a third, which is also known as a fused multiply-add. Intel\u2019s\nOpenVino196uses these to achieve respectable throughput for deep learning on server-\ngrade CPUs. Note, though, that this number is entirely dwarfed by what GPUs are capable\nof achieving. For instance, NVIDIA\u2019s RTX 2080 Ti has 4,352 CUDA cores, each of which\nis capable of processing such an operation at any time.\nCache\nConsider the following situation: we have a modest CPU core with 4 cores as depicted in\nFig.13.4.3 above,runningat2GHzfrequency. Moreover,let\u2019sassumethatwehaveanIPC\n(instructionsperclock)countof1andthattheunitshaveAVX2with256-bitwidthenabled.\nLet\u2019s furthermore assume that at least one of the registers used for AVX2 operations needs\nto be retrieved from memory. This means that the CPU consumes 4\u0002256bit=128bytes\nof data per clock cycle. Unless we are able to transfer 2\u0002109\u0002128=256\u0002109bytes\nto the processor per second the processing elements are going to starve. Unfortunately the\nmemory interface of such a chip only supports 20\u201340 GB/s data transfer, i.e., one order of\nmagnitude less. The fix is to avoid loading newdata from memory as far as possible and\nrather to cache it locally on the CPU. This is where caches come in handy. Commonly the\nfollowing names or concepts are used:\n\u000fRegisters are strictly speaking not part of the cache. They help stage instructions. That\nsaid, CPU registers are memory locations that a CPU can access at clock speed with-\nout any delay penalty. CPUs have tens of registers. It is up to the compiler (or pro-\ngrammer) to use registers efficiently. For instance the C programming language has a\nregister keyword.\n\u000fL1 caches are the first line of defense against high memory bandwidth requirements.\nL1 caches are tiny (typical sizes might be 32\u201364 KB) and often split into data and\ninstructions caches. When data is found in the L1 cache, access is very fast. If they\ncannot be found there, the search progresses down the cache hierarchy.\n\u000fL2 caches are the next stop. Depending on architecture design and processor size they\nmight be exclusive. They might be accessible only by a given core or shared among\nmultiple cores. L2 caches are larger (typically 256\u2013512 KB per core) and slower than\n566 Computational Performance\nL1. Furthermore, to access something in L2 we first need to check to realize that the\ndata is not in L1, which adds a small amount of extra latency.\n\u000fL3caches aresharedamongmultiplecoresandcanbequitelarge. AMD\u2019sEpyc3server\nCPUshaveawhopping256MBofcachespreadacrossmultiplechiplets. Moretypical\nnumbers are in the 4\u20138 MB range.\nPredicting which memory elements will be needed next is one of the key optimization pa-\nrametersinchipdesign. Forinstance,itisadvisabletotraversememoryina forward direc-\ntionsincemostcachingalgorithmswilltryto readahead ratherthanbackwards. Likewise,\nkeeping memory access patterns local is a good way of improving performance.\nAdding caches is a double-edge sword. On the one hand they ensure that the processor\ncores do not starve of data. At the same time they increase chip size, using up area that\notherwise could have been spent on increasing processing power. Moreover, cache misses\ncanbeexpensive. Considertheworstcasescenario, falsesharing ,asdepictedin Fig.13.4.6 .\nA memory location is cached on processor 0 when a thread on processor 1 requests the\ndata. To obtain it, processor 0 needs to stop what it is doing, write the information back\nto main memory and then let processor 1 read it from memory. During this operation both\nprocessorswait. Quitepotentiallysuchcoderuns moreslowly onmultipleprocessorswhen\ncompared with an efficient single-processor implementation.", "mimetype": "text/plain", "start_char_idx": 1239895, "end_char_idx": 1243978, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "281304a4-4ea0-438b-9955-15e6625d0f5c": {"__data__": {"id_": "281304a4-4ea0-438b-9955-15e6625d0f5c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "64c117fe-f2ca-41d3-b8dd-52609c6c65e6", "node_type": "1", "metadata": {}, "hash": "b076b5c8641149bc5f21eacf89872f427209da68653f65901ff8f4c471414c6d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5bde89bf-7c70-4d25-afcd-527765ec4113", "node_type": "1", "metadata": {}, "hash": "6054fedcac49d16491d73cd273ded0b5667e591a0174164248587dfda12559b1", "class_name": "RelatedNodeInfo"}}, "text": "Likewise,\nkeeping memory access patterns local is a good way of improving performance.\nAdding caches is a double-edge sword. On the one hand they ensure that the processor\ncores do not starve of data. At the same time they increase chip size, using up area that\notherwise could have been spent on increasing processing power. Moreover, cache misses\ncanbeexpensive. Considertheworstcasescenario, falsesharing ,asdepictedin Fig.13.4.6 .\nA memory location is cached on processor 0 when a thread on processor 1 requests the\ndata. To obtain it, processor 0 needs to stop what it is doing, write the information back\nto main memory and then let processor 1 read it from memory. During this operation both\nprocessorswait. Quitepotentiallysuchcoderuns moreslowly onmultipleprocessorswhen\ncompared with an efficient single-processor implementation. This is one more reason for\nwhy there is a practical limit to cache sizes (besides their physical size).\ntFig. 13.4.6 False sharing (image courtesy of Intel).\n13.4.5GPUs and otherAccelerators\nItisnotanexaggerationtoclaimthatdeeplearningwouldnothavebeensuccessfulwithout\nGPUs. Bythesametoken, itisquitereasonabletoarguethatGPUmanufacturers\u2019fortunes\nhave increased significantly due to deep learning. This co-evolution of hardware and al-\ngorithms has led to a situation where for better or worse deep learning is the preferable\nstatistical modeling paradigm. Hence it pays to understand the specific benefits that GPUs\nand related accelerators such as the TPU ( Jouppietal., 2017).\nOf note is a distinction that is often made in practice: accelerators are optimized either for\ntraining or inference. For the latter we only need to compute the forward propagation in\na network. No storage of intermediate data is needed for backpropagation. Moreover, we\nmaynotneedveryprecisecomputation(FP16orINT8typicallysuffice). Ontheotherhand,\n567 Hardware\n197during training all intermediate results need storage to compute gradients. Moreover, ac-\ncumulatinggradientsrequireshigherprecisiontoavoidnumericalunderflow(oroverflow).\nThis means that FP16 (or mixed precision with FP32) is the minimum requirement. All\nof this necessitates faster and larger memory (HBM2 vs. GDDR6) and more processing\npower. For instance, NVIDIA\u2019s Turing197T4 GPUs are optimized for inference whereas\nthe V100 GPUs are preferable for training.\nRecall vectorization as illustrated in Fig. 13.4.5 . Adding vector units to a processor core\nallowed us to increase throughput significantly. For example, in the example in Fig. 13.4.5\nwe were able to perform 16 operations simultaneously. First, what if we added operations\nthatoptimizednotjustoperationsbetweenvectorsbutalsobetweenmatrices? Thisstrategy\nled to tensor cores (to be covered shortly). Second, what if we added many more cores?\nIn a nutshell, these two strategies summarize the design decisions in GPUs. Fig. 13.4.7\ngives an overview of a basic processing block. It contains 16 integer and 16 floating point\nunits. In addition to that, two tensor cores accelerate a narrow subset of additional op-\nerations relevant for deep learning. Each streaming multiprocessor consists of four such\nblocks.\ntFig. 13.4.7 NVIDIA Turing processing block (image courtesy of NVIDIA).\nNext, 12 streaming multiprocessors are grouped into graphics processing clusters which\nmake up the high-end TU102 processors. Ample memory channels and an L2 cache com-\nplement the setup. Fig. 13.4.8 has the relevant details. One of the reasons for designing\nsuchadeviceisthatindividualblockscanbeaddedorremovedasneededtoallowformore\ncompactchipsandtodealwithyieldissues(faultymodulesmightnotbeactivated). Fortu-\nnately programming such devices is well hidden from the casual deep learning researcher\nbeneathlayersofCUDAandframeworkcode. Inparticular,morethanoneoftheprograms\nmight well be executed simultaneously on the GPU, provided that there are available re-\nsources. Nonetheless it pays to be aware of the limitations of the devices to avoid picking\nmodels that do not fit into device memory.\nAlastaspectthatisworthmentioninginmoredetailare tensorcores . Theyareanexample\nof a recent trend of adding more optimized circuits that are specifically effective for deep\nlearning.", "mimetype": "text/plain", "start_char_idx": 1243139, "end_char_idx": 1247350, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5bde89bf-7c70-4d25-afcd-527765ec4113": {"__data__": {"id_": "5bde89bf-7c70-4d25-afcd-527765ec4113", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "281304a4-4ea0-438b-9955-15e6625d0f5c", "node_type": "1", "metadata": {}, "hash": "56953ad407286dd89fe7248a0f62f8bcb468770d45f1e186bc3fad026742a27c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9183f831-862b-4073-9074-62ed11c27564", "node_type": "1", "metadata": {}, "hash": "154aa5d6b40661f286f9b739d2b23d86277ceb37d8da3f52def693dd4a50417d", "class_name": "RelatedNodeInfo"}}, "text": "Fig. 13.4.8 has the relevant details. One of the reasons for designing\nsuchadeviceisthatindividualblockscanbeaddedorremovedasneededtoallowformore\ncompactchipsandtodealwithyieldissues(faultymodulesmightnotbeactivated). Fortu-\nnately programming such devices is well hidden from the casual deep learning researcher\nbeneathlayersofCUDAandframeworkcode. Inparticular,morethanoneoftheprograms\nmight well be executed simultaneously on the GPU, provided that there are available re-\nsources. Nonetheless it pays to be aware of the limitations of the devices to avoid picking\nmodels that do not fit into device memory.\nAlastaspectthatisworthmentioninginmoredetailare tensorcores . Theyareanexample\nof a recent trend of adding more optimized circuits that are specifically effective for deep\nlearning. Forinstance,theTPUaddedasystolicarray( Kung,1988 )forfastmatrixmultipli-\n568 Computational Performance\ntFig. 13.4.8 NVIDIA Turing architecture (image courtesy of NVIDIA)\n198cation. Therethedesignwastosupportaverysmallnumber(oneforthefirstgenerationof\nTPUs) of large operations. Tensor cores are at the other end. They are optimized for small\noperations involving between 4\u00024and 16\u000216matrices, depending on their numerical\nprecision. Fig. 13.4.9 gives an overview of the optimizations.\ntFig. 13.4.9 NVIDIA tensor cores in Turing (image courtesy of NVIDIA).\nObviously when optimizing for computation we end up making certain compromises. One\nof them is that GPUs are not very good at handling interrupts and sparse data. While there\narenotableexceptions,suchas Gunrock198(Wangetal.,2016),theaccesspatternofsparse\nmatrices and vectors do not go well with the high bandwidth burst read operations where\n569 Hardware\n199\n200\n201\n202\n203\n204GPUs excel. Matching both goals is an area of active research. See e.g., DGL199, a library\ntuned for deep learning on graphs.\n13.4.6Networksand Buses\nWhenever a single device is insufficient for optimization we need to transfer data to and\nfrom it to synchronize processing. This is where networks and buses come in handy. We\nhaveanumberofdesignparameters: bandwidth, cost, distance, andflexibility. Ononeend\nwehaveWiFithathasaprettygoodrange,isveryeasytouse(nowires,afterall),cheapbut\nit offers comparatively mediocre bandwidth and latency. No machine learning researcher\nwithin their right mind would use it to build a cluster of servers. In what follows we focus\non interconnects that are suitable for deep learning.\n\u000fPCIeis a dedicated bus for very high bandwidth point-to-point connections (up to 32\nGB/s on PCIe 4.0 in a 16-lane slot) per lane. Latency is in the order of single-digit\nmicroseconds (5 \u03bcs). PCIe links are precious. Processors only have a limited number\nof them: AMD\u2019s EPYC 3 has 128 lanes, Intel\u2019s Xeon has up to 48 lanes per chip;\non desktop-grade CPUs the numbers are 20 (Ryzen 9) and 16 (Core i9) respectively.\nSince GPUs have typically 16 lanes, this limits the number of GPUs that can connect\nto the CPU at full bandwidth. After all, they need to share the links with other high\nbandwidth peripherals such as storageand Ethernet. Justlike with RAM access, large\nbulk transfers are preferable due to reduced packet overhead.\n\u000fEthernet is the most commonly used way of connecting computers. While it is signifi-\ncantlyslowerthanPCIe,itisverycheapandresilienttoinstallandcoversmuchlonger\ndistances. Typical bandwidth for low-grade servers is 1 GBit/s. Higher-end devices\n(e.g.,C5 instances200in the cloud) offer between 10 and 100 GBit/s bandwidth. As\nin all previous cases data transmission has significant overheads. Note that we al-\nmost never use raw Ethernet directly but rather a protocol that is executed on top of\nthe physical interconnect (such as UDP or TCP/IP). This adds further overhead. Like\nPCIe, Ethernet is designed to connect two devices, e.g., a computer and a switch.\n\u000fSwitches allow us to connect multiple devices in a manner where any pair of them can\ncarry out a (typically full bandwidth) point-to-point connection simultaneously. For\ninstance, Ethernet switches might connect 40 servers at high cross-sectional band-\nwidth.", "mimetype": "text/plain", "start_char_idx": 1246558, "end_char_idx": 1250658, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9183f831-862b-4073-9074-62ed11c27564": {"__data__": {"id_": "9183f831-862b-4073-9074-62ed11c27564", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5bde89bf-7c70-4d25-afcd-527765ec4113", "node_type": "1", "metadata": {}, "hash": "6054fedcac49d16491d73cd273ded0b5667e591a0174164248587dfda12559b1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "83b2f2c4-4a02-4e15-934f-41c8d013c6af", "node_type": "1", "metadata": {}, "hash": "a4663c1b944f2c1097abd03d9cde0e8f83f3a88aa7f6a8b92ea0b15855bd8410", "class_name": "RelatedNodeInfo"}}, "text": "Typical bandwidth for low-grade servers is 1 GBit/s. Higher-end devices\n(e.g.,C5 instances200in the cloud) offer between 10 and 100 GBit/s bandwidth. As\nin all previous cases data transmission has significant overheads. Note that we al-\nmost never use raw Ethernet directly but rather a protocol that is executed on top of\nthe physical interconnect (such as UDP or TCP/IP). This adds further overhead. Like\nPCIe, Ethernet is designed to connect two devices, e.g., a computer and a switch.\n\u000fSwitches allow us to connect multiple devices in a manner where any pair of them can\ncarry out a (typically full bandwidth) point-to-point connection simultaneously. For\ninstance, Ethernet switches might connect 40 servers at high cross-sectional band-\nwidth. Notethatswitchesarenotuniquetotraditionalcomputernetworks. EvenPCIe\nlanes can be switched201. This occurs, e.g., to connect a large number of GPUs to a\nhost processor, as is the case for the P2 instances202.\n\u000fNVLink is an alternative to PCIe when it comes to very high bandwidth interconnects.\nIt offers up to 300 Gbit/s data transfer rate per link. Server GPUs (Volta V100) have\nsixlinkswhereasconsumer-gradeGPUs(RTX2080Ti)haveonlyonelink, operating\nat a reduced 100 Gbit/s rate. We recommend to use NCCL203to achieve high data\ntransfer between GPUs.\n13.4.7MoreLatency Numbers\n570 Computational Performance\n205The summary in Table 13.4.1 andTable 13.4.2 are from Eliot Eshelman204who maintains\nan updated version of the numbers as a GitHub gist205.\nTable 13.4.1: Common Latency Numbers.\nAction Time Notes\nL1 cache reference/hit 1.5 ns 4 cycles\nFloating-point add/mult/FMA 1.5 ns 4 cycles\nL2 cache reference/hit 5 ns 12 ~ 17 cycles\nBranch mispredict 6 ns 15 ~ 20 cycles\nL3 cache hit (unshared cache) 16 ns 42 cycles\nL3 cache hit (shared in another core) 25 ns 65 cycles\nMutex lock/unlock 25 ns\nL3 cache hit (modified in another core) 29 ns 75 cycles\nL3 cache hit (on a remote CPU socket) 40 ns 100 ~ 300 cycles (40 ~ 116 ns)\nQPI hop to a another CPU (per hop) 40 ns\n64MB memory ref. (local CPU) 46 ns TinyMemBench on Broadwell E5-2690v4\n64MB memory ref. (remote CPU) 70 ns TinyMemBench on Broadwell E5-2690v4\n256MB memory ref. (local CPU) 75 ns TinyMemBench on Broadwell E5-2690v4\nIntel Optane random write 94 ns UCSD Non-Volatile Systems Lab\n256MB memory ref.", "mimetype": "text/plain", "start_char_idx": 1249909, "end_char_idx": 1252219, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "83b2f2c4-4a02-4e15-934f-41c8d013c6af": {"__data__": {"id_": "83b2f2c4-4a02-4e15-934f-41c8d013c6af", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9183f831-862b-4073-9074-62ed11c27564", "node_type": "1", "metadata": {}, "hash": "154aa5d6b40661f286f9b739d2b23d86277ceb37d8da3f52def693dd4a50417d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7f2d0e50-7ccd-4e21-909a-46903e008260", "node_type": "1", "metadata": {}, "hash": "51c21730580d525e68b74fb583dff8c5dfe5d4b1b408471cd95c525df695fc7a", "class_name": "RelatedNodeInfo"}}, "text": "(local CPU) 46 ns TinyMemBench on Broadwell E5-2690v4\n64MB memory ref. (remote CPU) 70 ns TinyMemBench on Broadwell E5-2690v4\n256MB memory ref. (local CPU) 75 ns TinyMemBench on Broadwell E5-2690v4\nIntel Optane random write 94 ns UCSD Non-Volatile Systems Lab\n256MB memory ref. (remote CPU) 120 ns TinyMemBench on Broadwell E5-2690v4\nIntel Optane random read 305 ns UCSD Non-Volatile Systems Lab\nSend 4KB over 100 Gbps HPC fabric 1 \u03bcs MVAPICH2 over Intel Omni-Path\nCompress 1KB with Google Snappy 3 \u03bcs\nSend 4KB over 10 Gbps ethernet 10 \u03bcs\nWrite 4KB randomly to NVMe SSD 30 \u03bcs DC P3608 NVMe SSD (QOS 99% is 500\u03bcs)\nTransfer 1MB to/from NVLink GPU 30 \u03bcs ~33GB/s on NVIDIA 40GB NVLink\nTransfer 1MB to/from PCI-E GPU 80 \u03bcs ~12GB/s on PCIe 3.0 x16 link\nRead 4KB randomly from NVMe SSD 120 \u03bcs DC P3608 NVMe SSD (QOS 99%)\nRead 1MB sequentially from NVMe SSD 208 \u03bcs ~4.8GB/s DC P3608 NVMe SSD\nWrite 4KB randomly to SATA SSD 500 \u03bcs DC S3510 SATA SSD (QOS 99.9%)\nRead 4KB randomly from SATA SSD 500 \u03bcs DC S3510 SATA SSD (QOS 99.9%)\nRound trip within same data center 500 \u03bcs One-way ping is ~250\u03bcs\nRead 1MB sequentially from SATA SSD 2 ms ~550MB/s DC S3510 SATA SSD\nRead 1MB sequentially from disk 5 ms ~200MB/s server HDD\nRandom Disk Access (seek+rotation) 10 ms\nSend packet CA->Netherlands->CA 150 ms\nTable 13.4.2: Latency Numbers for NVIDIA Tesla GPUs.\n571 Hardware\nAction Time Notes\nGPU Shared Memory access 30 ns 30~90 cycles (bank conflicts add la-\ntency)\nGPU Global Memory access 200\nns200~800 cycles\nLaunch CUDA kernel on GPU 10 \u03bcs Host CPU instructs GPU to start kernel\nTransfer 1MB to/from NVLink\nGPU30 \u03bcs ~33GB/s on NVIDIA 40GB NVLink\nTransfer 1MB to/from PCI-E GPU 80 \u03bcs ~12GB/s on PCI-Express x16 link\n13.4.8Summary\n\u000fDevices have overheads for operations. Hence it is important to aim for a small number\nof large transfers rather than many small ones. This applies to RAM, SSDs, networks\nand GPUs.\n\u000fVectorization is key for performance. Make sure you are aware of the specific abilities\nof your accelerator. E.g., some Intel Xeon CPUs are particularly good for INT8 op-\nerations, NVIDIA Volta GPUs excel at FP16 matrix-matrix operations and NVIDIA\nTuring shines at FP16, INT8, and INT4 operations.\n\u000fNumerical overflow due to small data types can be a problem during training (and to a\nlesser extent during inference).\n\u000fAliasing can significantly degrade performance. For instance, memory alignment on 64\nbit CPUs should be done with respect to 64 bit boundaries. On GPUs it is a good idea\nto keep convolution sizes aligned, e.g., to tensor cores.\n\u000fMatch your algorithms to the hardware (e.g., memory footprint, and bandwidth). Great\nspeedup(ordersofmagnitude)canbeachievedwhenfittingtheparametersintocaches.\n\u000fWerecommendthatyousketchouttheperformanceofanovelalgorithmonpaperbefore\nverifying the experimental results. Discrepancies of an order-of-magnitude or more\nare reasons for concern.\n\u000fUse profilers to debug performance bottlenecks.\n\u000fTraining and inference hardware have different sweet spots in terms of price and perfor-\nmance.\n13.4.9Exercises\n1.WriteCcodetotestwhetherthereisanydifferenceinspeedbetweenaccessingmemory\naligned or misaligned relative to the external memory interface. Hint: be careful of\ncaching effects.\n2.Test the difference in speed between accessing memory in sequence or with a given\nstride.\n572 Computational Performance\n2063.How could you measure the cache sizes on a CPU?\n4.Howwouldyoulayoutdataacrossmultiplememorychannelsformaximumbandwidth?\nHow would you lay it out if you had many small threads?", "mimetype": "text/plain", "start_char_idx": 1251942, "end_char_idx": 1255473, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7f2d0e50-7ccd-4e21-909a-46903e008260": {"__data__": {"id_": "7f2d0e50-7ccd-4e21-909a-46903e008260", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "83b2f2c4-4a02-4e15-934f-41c8d013c6af", "node_type": "1", "metadata": {}, "hash": "a4663c1b944f2c1097abd03d9cde0e8f83f3a88aa7f6a8b92ea0b15855bd8410", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4d06838a-aa0a-457c-b19b-107cf8fa4841", "node_type": "1", "metadata": {}, "hash": "d119fb8f52e0c4a64a01e20de18526ea68b77c1bb0d38eec8b6cbe21442fea0f", "class_name": "RelatedNodeInfo"}}, "text": "\u000fWerecommendthatyousketchouttheperformanceofanovelalgorithmonpaperbefore\nverifying the experimental results. Discrepancies of an order-of-magnitude or more\nare reasons for concern.\n\u000fUse profilers to debug performance bottlenecks.\n\u000fTraining and inference hardware have different sweet spots in terms of price and perfor-\nmance.\n13.4.9Exercises\n1.WriteCcodetotestwhetherthereisanydifferenceinspeedbetweenaccessingmemory\naligned or misaligned relative to the external memory interface. Hint: be careful of\ncaching effects.\n2.Test the difference in speed between accessing memory in sequence or with a given\nstride.\n572 Computational Performance\n2063.How could you measure the cache sizes on a CPU?\n4.Howwouldyoulayoutdataacrossmultiplememorychannelsformaximumbandwidth?\nHow would you lay it out if you had many small threads?\n5.An enterprise-class HDD is spinning at 10,000 rpm. What is the absolutely minimum\ntime an HDD needs to spend worst case before it can read data (you can assume that\nheads move almost instantaneously)? Why are 2.5\u201d HDDs becoming popular for com-\nmercial servers (relative to 3.5\u201d and 5.25\u201d drives)?\n6.AssumethatanHDDmanufacturerincreasesthestoragedensityfrom1Tbitpersquare\ninch to 5 Tbit per square inch. How much information can you store on a ring on a 2.5\u201d\nHDD? Is there a difference between the inner and outer tracks?\n7.Going from 8 bit to 16 bit data types increases the amount of silicon approximately by\nfour times. Why? Why might NVIDIA have added INT4 operations to their Turing\nGPUs?\n8.How much faster is it to read forward through memory vs. reading backwards? Does\nthis number differ between different computers and CPU vendors? Why? Write C code\nand experiment with it.\n9.Can you measure the cache size of your disk? What is it for a typical HDD? Do SSDs\nneed a cache?\n10.Measure the packet overhead when sending messages across the Ethernet. Look up the\ndifference between UDP and TCP/IP connections.\n11.Direct memory access allows devices other than the CPU to write (and read) directly to\n(from) memory. Why is this a good idea?\n12.Look at the performance numbers for the Turing T4 GPU. Why does the performance\n\u201conly\u201d double as you go from FP16 to INT8 and INT4?\n13.What is the shortest time it should take for a packet on a round trip between San Fran-\ncisco and Amsterdam? Hint: you can assume that the distance is 10,000 km.\nDiscussions206.\n13.5Trainingon Multiple GPUs\nSo far we discussed how to train models efficiently on CPUs and GPUs. We even showed\nhow deep learning frameworks allow one to parallelize computation and communication\nautomatically between them in Section 13.3 . We also showed in Section 6.7 how to list\nall the available GPUs on a computer using the nvidia-smi command. What we did not\ndiscuss is how to actually parallelize deep learning training. Instead, we implied in pass-\ning that one would somehow split the data across multiple devices and make it work. The\n573 Training on Multiple GPUs\npresentsectionfillsinthedetailsandshowshowtotrainanetworkinparallelwhenstarting\nfrom scratch. Details on how to take advantage of functionality in high-level APIs is rele-\ngated to Section 13.6 . We assume that you are familiar with minibatch stochastic gradient\ndescent algorithms such as the ones described in Section 12.5 .\n13.5.1Splittingthe Problem\nLet\u2019sstartwithasimplecomputervisionproblemandaslightlyarchaicnetwork, e.g., with\nmultiple layers of convolutions, pooling, and possibly a few fully connected layers in the\nend. That is, let\u2019s start with a network that looks quite similar to LeNet ( LeCunet al.,\n1998) or AlexNet ( Krizhevsky et al., 2012). Given multiple GPUs (2 if it is a desktop\nserver, 4 on an AWS g4dn.12xlarge instance, 8 on a p3.16xlarge, or 16 on a p2.16xlarge),\nwe want to partition training in a manner as to achieve good speedup while simultaneously\nbenefittingfromsimpleandreproducibledesignchoices. MultipleGPUs,afterall,increase\nbothmemory andcomputation ability. In a nutshell, we have the following choices, given\na minibatch of training data that we want to classify.\nFirst, we could partition the network across multiple GPUs.", "mimetype": "text/plain", "start_char_idx": 1254651, "end_char_idx": 1258780, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4d06838a-aa0a-457c-b19b-107cf8fa4841": {"__data__": {"id_": "4d06838a-aa0a-457c-b19b-107cf8fa4841", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7f2d0e50-7ccd-4e21-909a-46903e008260", "node_type": "1", "metadata": {}, "hash": "51c21730580d525e68b74fb583dff8c5dfe5d4b1b408471cd95c525df695fc7a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "25c8c7a3-4c74-4f2f-9af9-3fdfe59cb492", "node_type": "1", "metadata": {}, "hash": "f88af33877d225649eba287f1fe29781585308f831eb775b833dfd85dd0ae534", "class_name": "RelatedNodeInfo"}}, "text": "That is, let\u2019s start with a network that looks quite similar to LeNet ( LeCunet al.,\n1998) or AlexNet ( Krizhevsky et al., 2012). Given multiple GPUs (2 if it is a desktop\nserver, 4 on an AWS g4dn.12xlarge instance, 8 on a p3.16xlarge, or 16 on a p2.16xlarge),\nwe want to partition training in a manner as to achieve good speedup while simultaneously\nbenefittingfromsimpleandreproducibledesignchoices. MultipleGPUs,afterall,increase\nbothmemory andcomputation ability. In a nutshell, we have the following choices, given\na minibatch of training data that we want to classify.\nFirst, we could partition the network across multiple GPUs. That is, each GPU takes as\ninput the data flowing into a particular layer, processes data across a number of subsequent\nlayers and then sends the data to the next GPU. This allows us to process data with larger\nnetworkswhencomparedwithwhatasingleGPUcouldhandle. Besides,memoryfootprint\nper GPU can be well controlled (it is a fraction of the total network footprint).\nHowever,theinterfacebetweenlayers(andthusGPUs)requirestightsynchronization. This\ncan be tricky, in particular if the computational workloads are not properly matched be-\ntween layers. The problem is exacerbated for large numbers of GPUs. The interface be-\ntween layers also requires large amounts of data transfer, such as activations and gradients.\nThis may overwhelm the bandwidth of the GPU buses. Moreover, compute-intensive, yet\nsequentialoperationsarenontrivialtopartition. Seee.g.,Mirhoseini etal.(2017)forabest\neffort in this regard. It remains a difficult problem and it is unclear whether it is possible\nto achieve good (linear) scaling on nontrivial problems. We do not recommend it unless\nthere is excellent framework or operating system support for chaining together multiple\nGPUs.\nSecond,wecouldsplittheworklayerwise. Forinstance,ratherthancomputing64channels\nonasingleGPUwecouldsplituptheproblemacross4GPUs,eachofwhichgeneratesdata\nfor 16 channels. Likewise, for a fully connected layer we could split the number of output\nunits.Fig. 13.5.1 (taken from Krizhevsky et al.(2012)) illustrates this design, where this\nstrategy was used to deal with GPUs that had a very small memory footprint (2 GB at the\ntime). This allows for good scaling in terms of computation, provided that the number of\nchannels(orunits)isnottoosmall. Besides,multipleGPUscanprocessincreasinglylarger\nnetworks since the available memory scales linearly.\nHowever, we need a verylarge number of synchronization or barrier operations since each\nlayer depends on the results from all the other layers. Moreover, the amount of data that\nneedstobetransferredispotentiallyevenlargerthanwhendistributinglayersacrossGPUs.\nThus,wedonotrecommendthisapproachduetoitsbandwidthcostandcomplexity.\n574 Computational Performance\ntFig. 13.5.1 Model parallelism in the original AlexNet design due to limited GPU memory.\nLast, we could partition data across multiple GPUs. This way all GPUs perform the same\ntype of work, albeit on different observations. Gradients are aggregated across GPUs after\neach minibatch of training data. This is the simplest approach and it can be applied in any\nsituation. Weonlyneedtosynchronizeaftereachminibatch. Thatsaid,itishighlydesirable\nto start exchanging gradients parameters already while others are still being computed.\nMoreover, larger numbers of GPUs lead to larger minibatch sizes, thus increasing training\nefficiency. However, adding more GPUs does not allow us to train larger models.\ntFig. 13.5.2 Parallelization on multiple GPUs. From left to right: original problem, network\npartitioning, layerwise partitioning, data parallelism.\nA comparison of different ways of parallelization on multiple GPUs is depicted in Fig.\n13.5.2. By and large, data parallelism is the most convenient way to proceed, provided\nthat we have access to GPUs with sufficiently large memory. See also ( Liet al., 2014) for\na detailed description of partitioning for distributed training. GPU memory used to be a\nproblem in the early days of deep learning. By now this issue has been resolved for all but\nthe most unusual cases. We focus on data parallelism in what follows.", "mimetype": "text/plain", "start_char_idx": 1258146, "end_char_idx": 1262311, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "25c8c7a3-4c74-4f2f-9af9-3fdfe59cb492": {"__data__": {"id_": "25c8c7a3-4c74-4f2f-9af9-3fdfe59cb492", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4d06838a-aa0a-457c-b19b-107cf8fa4841", "node_type": "1", "metadata": {}, "hash": "d119fb8f52e0c4a64a01e20de18526ea68b77c1bb0d38eec8b6cbe21442fea0f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ae2b4d2e-77ee-4568-8d22-7bc4a42a98db", "node_type": "1", "metadata": {}, "hash": "22d5fd79ea2feab083d229c14a7a313108f476a61e2468b913696da8edf269df", "class_name": "RelatedNodeInfo"}}, "text": "Moreover, larger numbers of GPUs lead to larger minibatch sizes, thus increasing training\nefficiency. However, adding more GPUs does not allow us to train larger models.\ntFig. 13.5.2 Parallelization on multiple GPUs. From left to right: original problem, network\npartitioning, layerwise partitioning, data parallelism.\nA comparison of different ways of parallelization on multiple GPUs is depicted in Fig.\n13.5.2. By and large, data parallelism is the most convenient way to proceed, provided\nthat we have access to GPUs with sufficiently large memory. See also ( Liet al., 2014) for\na detailed description of partitioning for distributed training. GPU memory used to be a\nproblem in the early days of deep learning. By now this issue has been resolved for all but\nthe most unusual cases. We focus on data parallelism in what follows.\n13.5.2Data Parallelism\nAssumethatthereare \ud835\udc58GPUsonamachine. Giventhemodeltobetrained,eachGPUwill\nmaintainacompletesetofmodelparametersindependentlythoughparametervaluesacross\n575 Training on Multiple GPUs\nthe GPUs are identical and synchronized. As an example, Fig. 13.5.3 illustrates training\nwith data parallelism when \ud835\udc58=2.\ntFig. 13.5.3 Calculation of minibatch stochastic gradient descent using data parallelism on two GPUs.\nIn general, the training proceeds as follows:\n\u000fInanyiterationoftraining, givenarandomminibatch,wesplittheexamplesinthebatch\ninto\ud835\udc58portions and distribute them evenly across the GPUs.\n\u000fEach GPU calculates loss and gradient of the model parameters based on the minibatch\nsubset it was assigned.\n\u000fThelocalgradientsofeachofthe \ud835\udc58GPUsareaggregatedtoobtainthecurrentminibatch\nstochastic gradient.\n\u000fThe aggregate gradient is re-distributed to each GPU.\n\u000fEach GPU uses this minibatch stochastic gradient to update the complete set of model\nparameters that it maintains.\nNote that in practice we increase the minibatch size \ud835\udc58-fold when training on \ud835\udc58GPUs such\nthat each GPU has the same amount of work to do as if we were training on a single GPU\nonly. On a 16-GPU server this can increase the minibatch size considerably and we may\nhavetoincreasethelearningrateaccordingly. Alsonotethatbatchnormalizationin Section\n8.5needs to be adjusted, e.g., by keeping a separate batch normalization coefficient per\nGPU. In what follows we will use a toy network to illustrate multi-GPU training.\n%matplotlib inline\nimport torch\nfrom torch import nn\nfrom torch .nnimport functional asF\nfrom d2l import torch asd2l\n13.5.3A ToyNetwork\nWe use LeNet as introduced in Section 7.6 (with slight modifications). We define it from\nscratch to illustrate parameter exchange and synchronization in detail.", "mimetype": "text/plain", "start_char_idx": 1261477, "end_char_idx": 1264109, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ae2b4d2e-77ee-4568-8d22-7bc4a42a98db": {"__data__": {"id_": "ae2b4d2e-77ee-4568-8d22-7bc4a42a98db", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "25c8c7a3-4c74-4f2f-9af9-3fdfe59cb492", "node_type": "1", "metadata": {}, "hash": "f88af33877d225649eba287f1fe29781585308f831eb775b833dfd85dd0ae534", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8916a554-80a3-436e-8a5c-d43781b23a5b", "node_type": "1", "metadata": {}, "hash": "ddd79807c992d2b53c7099b1e8914f8f7e269125de3b75f15185b619c0b228c8", "class_name": "RelatedNodeInfo"}}, "text": "On a 16-GPU server this can increase the minibatch size considerably and we may\nhavetoincreasethelearningrateaccordingly. Alsonotethatbatchnormalizationin Section\n8.5needs to be adjusted, e.g., by keeping a separate batch normalization coefficient per\nGPU. In what follows we will use a toy network to illustrate multi-GPU training.\n%matplotlib inline\nimport torch\nfrom torch import nn\nfrom torch .nnimport functional asF\nfrom d2l import torch asd2l\n13.5.3A ToyNetwork\nWe use LeNet as introduced in Section 7.6 (with slight modifications). We define it from\nscratch to illustrate parameter exchange and synchronization in detail.\n576 Computational Performance\n# Initialize model parameters\nscale =0.01\nW1=torch .randn(size =(20,1,3,3))*scale\nb1=torch .zeros( 20)\nW2=torch .randn(size =(50,20,5,5))*scale\nb2=torch .zeros( 50)\nW3=torch .randn(size =(800,128))*scale\nb3=torch .zeros( 128)\nW4=torch .randn(size =(128,10))*scale\nb4=torch .zeros( 10)\nparams =[W1, b1, W2, b2, W3, b3, W4, b4]\n# Define the model\ndef lenet (X, params):\nh1_conv =F.conv2d( input =X, weight =params[ 0], bias =params[ 1])\nh1_activation =F.relu(h1_conv)\nh1=F.avg_pool2d( input =h1_activation, kernel_size =(2,2), stride =(2,2))\nh2_conv =F.conv2d( input =h1, weight =params[ 2], bias =params[ 3])\nh2_activation =F.relu(h2_conv)\nh2=F.avg_pool2d( input =h2_activation, kernel_size =(2,2), stride =(2,2))\nh2=h2.reshape(h2 .shape[ 0],-1)\nh3_linear =torch .mm(h2, params[ 4])+params[ 5]\nh3=F.relu(h3_linear)\ny_hat =torch .mm(h3, params[ 6])+params[ 7]\nreturn y_hat\n# Cross-entropy loss function\nloss =nn.CrossEntropyLoss(reduction ='none ')\n13.5.4Data Synchronization\nFor efficient multi-GPU training we need two basic operations. First we need to have\nthe ability to distribute a list of parameters to multiple devices and to attach gradients\n(get_params ). Without parameters it is impossible to evaluate the network on a GPU.\nSecond, we need the ability to sum parameters across multiple devices, i.e., we need an\nallreduce function.\ndef get_params (params, device):\nnew_params =[p.to(device) for pinparams]\nfor pinnew_params:\np.requires_grad_()\nreturn new_params\nLet\u2019s try it out by copying the model parameters to one GPU.\nnew_params =get_params(params, d2l .try_gpu( 0))\nprint ('b1 weight: ', new_params[ 1])\nprint ('b1 grad: ', new_params[ 1].grad)\nb1 weight: tensor([ 0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,\u2423\n(continues on next page)\n577 Training on Multiple GPUs\n(continued from previous page)\n\u21a9!0.,0.,0.,0.,0.],\ndevice ='cuda:0 ', requires_grad =True )\nb1 grad: None\nSince we did not perform any computation yet, the gradient with regard to the bias param-\neter is still zero. Now let\u2019s assume that we have a vector distributed across multiple GPUs.\nThe following allreduce function adds up all vectors and broadcasts the result back to all\nGPUs. Note that for this to work we need to copy the data to the device accumulating the\nresults.\ndef allreduce (data):\nfor iinrange (1,len(data)):\ndata[ 0][:] +=data[i] .to(data[ 0].device)\nfor iinrange (1,len(data)):\ndata[i][:] =data[ 0].to(data[i] .device)\nLet\u2019s test this by creating vectors with different values on different devices and aggregate\nthem.", "mimetype": "text/plain", "start_char_idx": 1263480, "end_char_idx": 1266661, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8916a554-80a3-436e-8a5c-d43781b23a5b": {"__data__": {"id_": "8916a554-80a3-436e-8a5c-d43781b23a5b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ae2b4d2e-77ee-4568-8d22-7bc4a42a98db", "node_type": "1", "metadata": {}, "hash": "22d5fd79ea2feab083d229c14a7a313108f476a61e2468b913696da8edf269df", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "657a1771-105a-4996-bdc1-81314727d1df", "node_type": "1", "metadata": {}, "hash": "f2e77d1ba37723e121a5b5f69611ecd8d453f8d746a7f4d13e1f376eab99f0d7", "class_name": "RelatedNodeInfo"}}, "text": "],\ndevice ='cuda:0 ', requires_grad =True )\nb1 grad: None\nSince we did not perform any computation yet, the gradient with regard to the bias param-\neter is still zero. Now let\u2019s assume that we have a vector distributed across multiple GPUs.\nThe following allreduce function adds up all vectors and broadcasts the result back to all\nGPUs. Note that for this to work we need to copy the data to the device accumulating the\nresults.\ndef allreduce (data):\nfor iinrange (1,len(data)):\ndata[ 0][:] +=data[i] .to(data[ 0].device)\nfor iinrange (1,len(data)):\ndata[i][:] =data[ 0].to(data[i] .device)\nLet\u2019s test this by creating vectors with different values on different devices and aggregate\nthem.\ndata =[torch .ones(( 1,2), device =d2l.try_gpu(i)) *(i+1)for iinrange (2)]\nprint ('before allreduce: \\n', data[ 0],'\\n', data[ 1])\nallreduce(data)\nprint ('after allreduce: \\n', data[ 0],'\\n', data[ 1])\nbefore allreduce:\ntensor([[ 1.,1.]], device ='cuda:0 ')\ntensor([[ 2.,2.]], device ='cuda:1 ')\nafter allreduce:\ntensor([[ 3.,3.]], device ='cuda:0 ')\ntensor([[ 3.,3.]], device ='cuda:1 ')\n13.5.5DistributingData\nWe need a simple utility function to distribute a minibatch evenly across multiple GPUs.\nFor instance, on two GPUs we would like to have half of the data to be copied to either of\nthe GPUs. Since it is more convenient and more concise, we use the built-in function from\nthe deep learning framework to try it out on a 4\u00025matrix.\ndata =torch .arange( 20).reshape( 4,5)\ndevices =[torch .device( 'cuda:0 '), torch .device( 'cuda:1 ')]\nsplit =nn.parallel .scatter(data, devices)\nprint ('input : ', data)\nprint ('load into ', devices)\nprint ('output: ', split)\n578 Computational Performance\ninput : tensor([[ 0,1,2,3,4],\n[5,6,7,8,9],\n[10,11,12,13,14],\n[15,16,17,18,19]])\nload into [device( type ='cuda ', index =0), device( type ='cuda ', index =1)]\noutput: (tensor([[ 0,1,2,3,4],\n[5,6,7,8,9]], device ='cuda:0 '), tensor([[ 10,11,12,13,14],\n[15,16,17,18,19]], device ='cuda:1 '))\nFor later reuse we define a split_batch function that splits both data and labels.\n#@save\ndef split_batch (X, y, devices):\n\"\"\"Split `X` and `y` into multiple devices.\"\"\"\nassert X.shape[ 0]==y.shape[ 0]\nreturn (nn.parallel .scatter(X, devices),\nnn.parallel .scatter(y, devices))\n13.5.6Training\nNow we can implement multi-GPU training on a single minibatch. Its implementation is\nprimarily based on the data parallelism approach described in this section. We will use the\nauxiliaryfunctionswejustdiscussed, allreduce andsplit_and_load ,tosynchronizethe\ndata among multiple GPUs. Note that we do not need to write any specific code to achieve\nparallelism. Since the computational graph does not haveany dependencies across devices\nwithin a minibatch, it is executed in parallel automatically .\ndef train_batch (X, y, device_params, devices, lr):\nX_shards, y_shards =split_batch(X, y, devices)\n# Loss is calculated separately on each GPU\nls=[loss(lenet(X_shard, device_W), y_shard) .sum()\nfor X_shard, y_shard, device_W inzip(\nX_shards, y_shards, device_params)]\nfor linls: # Backpropagation is performed separately on each GPU\nl.backward()\n# Sum all gradients from each GPU and broadcast them to all GPUs\nwith torch .no_grad():\nfor iinrange (len(device_params[ 0])):\nallreduce([device_params[c][i] .grad for cinrange (len(devices))])\n# The model parameters are updated separately on each GPU\nfor param indevice_params:\nd2l.sgd(param, lr, X .shape[ 0])# Here, we use a full-size batch\nNow, we can define the training function.", "mimetype": "text/plain", "start_char_idx": 1265971, "end_char_idx": 1269471, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "657a1771-105a-4996-bdc1-81314727d1df": {"__data__": {"id_": "657a1771-105a-4996-bdc1-81314727d1df", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8916a554-80a3-436e-8a5c-d43781b23a5b", "node_type": "1", "metadata": {}, "hash": "ddd79807c992d2b53c7099b1e8914f8f7e269125de3b75f15185b619c0b228c8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fd5f37ce-6dc8-46d9-aa2a-227b313b411d", "node_type": "1", "metadata": {}, "hash": "82721eacd39a7ffbe508516f62bb38762c514c03f723bd7e1ddeb12bc3d4535f", "class_name": "RelatedNodeInfo"}}, "text": "It is slightly different from the ones used in the\nprevious chapters: we need to allocate the GPUs and copy all the model parameters to all\nthe devices. Obviously each batch is processed using the train_batch function to deal\nwith multiple GPUs. For convenience (and conciseness of code) we compute the accuracy\non a single GPU, though this is ine\ufb00icient since the other GPUs are idle.\n579 Training on Multiple GPUs\ndef train (num_gpus, batch_size, lr):\ntrain_iter, test_iter =d2l.load_data_fashion_mnist(batch_size)\ndevices =[d2l .try_gpu(i) for iinrange (num_gpus)]\n# Copy model parameters to `num_gpus` GPUs\ndevice_params =[get_params(params, d) for dindevices]\nnum_epochs =10\nanimator =d2l.Animator( 'epoch ','test acc ', xlim =[1, num_epochs])\ntimer =d2l.Timer()\nfor epoch inrange (num_epochs):\ntimer .start()\nfor X, y intrain_iter:\n# Perform multi-GPU training for a single minibatch\ntrain_batch(X, y, device_params, devices, lr)\ntorch .cuda .synchronize()\ntimer .stop()\n# Evaluate the model on GPU 0\nanimator .add(epoch +1, (d2l .evaluate_accuracy_gpu(\nlambda x: lenet(x, device_params[ 0]), test_iter, devices[ 0]),))\nprint (f'test acc: {animator .Y[0][-1]:.2f},{timer .avg() :.1f}sec/epoch '\nf'on{str(devices) }')\nLet\u2019s see how well this works on a single GPU. We first use a batch size of 256 and a\nlearning rate of 0.2.\ntrain(num_gpus =1, batch_size =256, lr =0.2)\ntest acc: 0.83 ,3.0 sec/epoch on [device( type ='cuda ', index =0)]\nBykeepingthebatchsizeandlearningrateunchangedandincreasingthenumberofGPUs\nto 2, we can see that the test accuracy roughly stays the same compared with the previous\nexperiment. Intermsoftheoptimizationalgorithms,theyareidentical. Unfortunatelythere\nis no meaningful speedup to be gained here: the model is simply too small; moreover we\nonly have a small dataset, where our slightly unsophisticated approach to implementing\nmulti-GPU training suffered from significant Python overhead. We will encounter more\ncomplex models and more sophisticated ways of parallelization going forward. Let\u2019s see\nwhat happens nonetheless for Fashion-MNIST.\n580 Computational Performance\n207train(num_gpus =2, batch_size =256, lr =0.2)\ntest acc: 0.84 ,2.8 sec/epoch on [device( type ='cuda ', index =0), device( type =\n\u21a9!'cuda ', index =1)]\n13.5.7Summary\n\u000fThere are multiple ways to split deep network training over multiple GPUs. We could\nsplitthembetweenlayers,acrosslayers,oracrossdata. Theformertworequiretightly\nchoreographed data transfers. Data parallelism is the simplest strategy.\n\u000fData parallel training is straightforward. However, it increases the effective minibatch\nsize to be efficient.\n\u000fIn data parallelism, data is split across multiple GPUs, where each GPU executes its\nown forward and backward operation and subsequently gradients are aggregated and\nresults are broadcast back to the GPUs.\n\u000fWe may use slightly increased learning rates for larger minibatches.\n13.5.8Exercises\n1.When training on \ud835\udc58GPUs, change the minibatch size from \ud835\udc4fto\ud835\udc58\u0001\ud835\udc4f, i.e., scale it up by\nthe number of GPUs.\n2.Compare accuracy for different learning rates. How does it scale with the number of\nGPUs?\n3.Implementamoreefficient allreduce functionthataggregatesdifferent parameterson\ndifferent GPUs? Why is it more efficient?\n4.Implement multi-GPU test accuracy computation.\nDiscussions207.\n581 Concise Implementation for Multiple GPUs\n13.6ConciseImplementation forMultiple GPUs\nImplementing parallelism from scratch for every new model is no fun. Moreover, there is\nsignificantbenefitinoptimizingsynchronizationtoolsforhighperformance. Inthefollow-\ning we will show how to do this using high-level APIs of deep learning frameworks. The\nmathematics and the algorithms are the same as in Section 13.5 . Quite unsurprisingly you\nwill need at least two GPUs to run code of this section.", "mimetype": "text/plain", "start_char_idx": 1269472, "end_char_idx": 1273269, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fd5f37ce-6dc8-46d9-aa2a-227b313b411d": {"__data__": {"id_": "fd5f37ce-6dc8-46d9-aa2a-227b313b411d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "657a1771-105a-4996-bdc1-81314727d1df", "node_type": "1", "metadata": {}, "hash": "f2e77d1ba37723e121a5b5f69611ecd8d453f8d746a7f4d13e1f376eab99f0d7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "56071c9c-7b12-4005-89a8-fede6b09e692", "node_type": "1", "metadata": {}, "hash": "e786632023321e19d5eabe2f40c9b1400ccc62c77e2988734d96982e083dce6c", "class_name": "RelatedNodeInfo"}}, "text": "2.Compare accuracy for different learning rates. How does it scale with the number of\nGPUs?\n3.Implementamoreefficient allreduce functionthataggregatesdifferent parameterson\ndifferent GPUs? Why is it more efficient?\n4.Implement multi-GPU test accuracy computation.\nDiscussions207.\n581 Concise Implementation for Multiple GPUs\n13.6ConciseImplementation forMultiple GPUs\nImplementing parallelism from scratch for every new model is no fun. Moreover, there is\nsignificantbenefitinoptimizingsynchronizationtoolsforhighperformance. Inthefollow-\ning we will show how to do this using high-level APIs of deep learning frameworks. The\nmathematics and the algorithms are the same as in Section 13.5 . Quite unsurprisingly you\nwill need at least two GPUs to run code of this section.\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n13.6.1A ToyNetwork\nLet\u2019s use a slightly more meaningful network than LeNet from Section 13.5 that is still\nsufficiently easy and quick to train. We pick a ResNet-18 variant ( Heet al., 2016). Since\ntheinputimagesaretinywemodifyitslightly. Inparticular,thedifferencefrom Section8.6\nisthatweuseasmallerconvolutionkernel,stride,andpaddingatthebeginning. Moreover,\nwe remove the max-pooling layer.\n#@save\ndef resnet18 (num_classes, in_channels =1):\n\"\"\"A slightly modified ResNet-18 model.\"\"\"\ndef resnet_block (in_channels, out_channels, num_residuals,\nfirst_block =False ):\nblk =[]\nfor iinrange (num_residuals):\nifi==0and not first_block:\nblk.append(d2l .Residual(out_channels, use_1x1conv =True ,\nstrides =2))\nelse :\nblk.append(d2l .Residual(out_channels))\nreturn nn.Sequential( *blk)\n# This model uses a smaller convolution kernel, stride, and padding and\n# removes the max-pooling layer\nnet =nn.Sequential(\nnn.Conv2d(in_channels, 64, kernel_size =3, stride =1, padding =1),\nnn.BatchNorm2d( 64),\nnn.ReLU())\nnet.add_module( \"resnet_block1 \", resnet_block( 64,64,2, first_block =True ))\nnet.add_module( \"resnet_block2 \", resnet_block( 64,128,2))\nnet.add_module( \"resnet_block3 \", resnet_block( 128,256,2))\nnet.add_module( \"resnet_block4 \", resnet_block( 256,512,2))\nnet.add_module( \"global_avg_pool \", nn .AdaptiveAvgPool2d(( 1,1)))\nnet.add_module( \"fc\", nn .Sequential(nn .Flatten(),\nnn.Linear( 512, num_classes)))\nreturn net\n582 Computational Performance\n13.6.2NetworkInitialization\nWe will initialize the network inside the training loop. For a refresher on initialization\nmethods see Section 5.4 .\nnet =resnet18( 10)\n# Get a list of GPUs\ndevices =d2l.try_all_gpus()\n# We will initialize the network inside the training loop\n13.6.3Training\nAs before, the training code needs to perform several basic functions for efficient paral-\nlelism:\n\u000fNetwork parameters need to be initialized across all devices.\n\u000fWhile iterating over the dataset minibatches are to be divided across all devices.\n\u000fWe compute the loss and its gradient in parallel across devices.\n\u000fGradients are aggregated and parameters are updated accordingly.\nIn the end we compute the accuracy (again in parallel) to report the final performance of\nthe network. The training routine is quite similar to implementations in previous chapters,\nexcept that we need to split and aggregate data.", "mimetype": "text/plain", "start_char_idx": 1272497, "end_char_idx": 1275679, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "56071c9c-7b12-4005-89a8-fede6b09e692": {"__data__": {"id_": "56071c9c-7b12-4005-89a8-fede6b09e692", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fd5f37ce-6dc8-46d9-aa2a-227b313b411d", "node_type": "1", "metadata": {}, "hash": "82721eacd39a7ffbe508516f62bb38762c514c03f723bd7e1ddeb12bc3d4535f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fa3a8e1d-9c6e-4fbc-ae2f-e341a990579b", "node_type": "1", "metadata": {}, "hash": "52616e27c0005e3f371058ac288b1a80825b0b9a12a0949cdb25c8e1f7e62b2a", "class_name": "RelatedNodeInfo"}}, "text": "For a refresher on initialization\nmethods see Section 5.4 .\nnet =resnet18( 10)\n# Get a list of GPUs\ndevices =d2l.try_all_gpus()\n# We will initialize the network inside the training loop\n13.6.3Training\nAs before, the training code needs to perform several basic functions for efficient paral-\nlelism:\n\u000fNetwork parameters need to be initialized across all devices.\n\u000fWhile iterating over the dataset minibatches are to be divided across all devices.\n\u000fWe compute the loss and its gradient in parallel across devices.\n\u000fGradients are aggregated and parameters are updated accordingly.\nIn the end we compute the accuracy (again in parallel) to report the final performance of\nthe network. The training routine is quite similar to implementations in previous chapters,\nexcept that we need to split and aggregate data.\ndef train (net, num_gpus, batch_size, lr):\ntrain_iter, test_iter =d2l.load_data_fashion_mnist(batch_size)\ndevices =[d2l .try_gpu(i) for iinrange (num_gpus)]\ndef init_weights (module):\niftype (module) in[nn.Linear, nn .Conv2d]:\nnn.init .normal_(module .weight, std =0.01 )\nnet.apply(init_weights)\n# Set the model on multiple GPUs\nnet =nn.DataParallel(net, device_ids =devices)\ntrainer =torch .optim .SGD(net .parameters(), lr)\nloss =nn.CrossEntropyLoss()\ntimer, num_epochs =d2l.Timer(), 10\nanimator =d2l.Animator( 'epoch ','test acc ', xlim =[1, num_epochs])\nfor epoch inrange (num_epochs):\nnet.train()\ntimer .start()\nfor X, y intrain_iter:\ntrainer .zero_grad()\nX, y =X.to(devices[ 0]), y .to(devices[ 0])\nl=loss(net(X), y)\nl.backward()\ntrainer .step()\ntimer .stop()\nanimator .add(epoch +1, (d2l .evaluate_accuracy_gpu(net, test_iter),))\nprint (f'test acc: {animator .Y[0][-1]:.2f},{timer .avg() :.1f}sec/epoch '\nf'on{str(devices) }')\n583 Concise Implementation for Multiple GPUs\nLet\u2019s see how this works in practice. As a warm-up we train the network on a single\nGPU.\ntrain(net, num_gpus =1, batch_size =256, lr =0.1)\ntest acc: 0.91 ,12.2 sec/epoch on [device( type ='cuda ', index =0)]\nNext we use 2 GPUs for training. Compared with LeNet evaluated in Section 13.5 , the\nmodel for ResNet-18 is considerably more complex. This is where parallelization shows\nits advantage. The time for computation is meaningfully larger than the time for synchro-\nnizing parameters. This improves scalability since the overhead for parallelization is less\nrelevant.\ntrain(net, num_gpus =2, batch_size =512, lr =0.2)\ntest acc: 0.73 ,7.5 sec/epoch on [device( type ='cuda ', index =0), device( type =\n\u21a9!'cuda ', index =1)]\n13.6.4Summary\n\u000fData is automatically evaluated on the devices where the data can be found.\n\u000fTakecaretoinitializethenetworksoneachdevicebeforetryingtoaccesstheparameters\non that device. Otherwise you will encounter an error.\n\u000fThe optimization algorithms automatically aggregate over multiple GPUs.\n584 Computational Performance\n20813.6.5Exercises\n1.This section uses ResNet-18. Try different epochs, batch sizes, and learning rates. Use\nmore GPUs for computation. What happens if you try this with 16 GPUs (e.g., on an\nAWS p2.16xlarge instance)?\n2.Sometimes, different devices provide different computing power. We could use the\nGPUs and the CPU at the same time. How should we divide the work? Is it worth the\neffort? Why? Why not?\nDiscussions208.\n13.7ParameterServers\nAs we move from a single GPU to multiple GPUs and then to multiple servers containing\nmultiple GPUs, possibly all spread out across multiple racks and network switches, our\nalgorithms for distributed and parallel training need to become much more sophisticated.\nDetails matter since different interconnects have very different bandwidth (e.g., NVLink\ncan offer up to 100 GB/s across 6 links in an appropriate setting, PCIe 4.0 (16-lane) offers\n32 GB/s, while even high speed 100GbE Ethernet only amounts to 10 GB/s).", "mimetype": "text/plain", "start_char_idx": 1274870, "end_char_idx": 1278670, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fa3a8e1d-9c6e-4fbc-ae2f-e341a990579b": {"__data__": {"id_": "fa3a8e1d-9c6e-4fbc-ae2f-e341a990579b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "56071c9c-7b12-4005-89a8-fede6b09e692", "node_type": "1", "metadata": {}, "hash": "e786632023321e19d5eabe2f40c9b1400ccc62c77e2988734d96982e083dce6c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "03ea9e79-eb86-4c7a-87db-ddd7d8a95b80", "node_type": "1", "metadata": {}, "hash": "e1f7f1f84ad66bd3545614542f9eccde84acc9f90a405e907d4ea6be02a2fe42", "class_name": "RelatedNodeInfo"}}, "text": "2.Sometimes, different devices provide different computing power. We could use the\nGPUs and the CPU at the same time. How should we divide the work? Is it worth the\neffort? Why? Why not?\nDiscussions208.\n13.7ParameterServers\nAs we move from a single GPU to multiple GPUs and then to multiple servers containing\nmultiple GPUs, possibly all spread out across multiple racks and network switches, our\nalgorithms for distributed and parallel training need to become much more sophisticated.\nDetails matter since different interconnects have very different bandwidth (e.g., NVLink\ncan offer up to 100 GB/s across 6 links in an appropriate setting, PCIe 4.0 (16-lane) offers\n32 GB/s, while even high speed 100GbE Ethernet only amounts to 10 GB/s). At the same\ntime it is unreasonable to expect that a statistical modeler be an expert in networking and\nsystems.\nThecoreideaoftheparameterserverwasintroducedinSmolaandNarayanamurthy( 2010)\nin the context of distributed latent variable models. A description of the push and pull\nsemantics then followed in Ahmed et al.(2012) and a description of the system and an\nopen source library followed in Li et al.(2014). In the following we will motivate the\ncomponents needed for efficiency.\n13.7.1Data-ParallelTraining\nLet\u2019s review the data parallel training approach to distributed training. We will use this\nto the exclusion of all others in this section since it is significantly simpler to implement\nin practice. There are virtually no use cases (besides deep learning on graphs) where any\nother strategy for parallelism is preferred since GPUs have plenty of memory nowadays.\nFig. 13.7.1 describes the variant of data parallelism that we implemented in Section 13.5 .\nThe key aspect in it is that the aggregation of gradients occurs on one single GPU (GPU 0)\nbefore the updated parameters are rebroadcast to all GPUs.\nIn retrospect, the decision to aggregate on GPU 0 seems rather ad-hoc. After all, we might\njust as well aggregate on the CPU. In fact, we could even decide to aggregate some of\nthe parameters on one GPU and some others on another. Provided that the optimization\nalgorithm supports this, there is no real reason for why we could not. For instance, if we\nhave four parameter vectors with associated gradients g1,...,g4we could aggregate the\ngradients on one GPU for each g\ud835\udc56(\ud835\udc56=1,..., 4).\n585 Parameter Servers\ntFig. 13.7.1 Left: single GPU training. Right: a variant of multi-GPU training: (1) we compute loss\nand gradient, (2) all gradients are aggregated on one GPU, (3) parameter update happens\nand the parameters are re-distributed to all GPUs.\n209Thisreasoningseemsarbitraryandfrivolous. Afterall,themathematicsisthesamethrough-\nout. However,wearedealingwithrealphysicalhardwarewheredifferentbuseshavediffer-\nentbandwidthasdiscussedin Section13.4 . Considerareal4-wayGPUserverasdescribed\ninFig. 13.7.2 . If it is particularly well connected, it might have a 100 GbE network card.\nMore typical numbers are in the 1\u201310 GbE range with an effective bandwidth of 100 MB/s\nto 1 GB/s. Since the CPUs have too few PCIe lanes to connect to all GPUs directly (e.g.,\nconsumer-grade Intel CPUs have24 lanes) we need a multiplexer209. The bandwidth from\nthe CPU on a 16x Gen3 link is 16 GB/s. This is also the speed at which eachof the GPUs\nis connected to the switch. This means that it is more effective to communicate between\nthe devices.\ntFig. 13.7.2 A 4-way GPU server.\n586 Computational Performance\n210For the sake of the argument let\u2019s assume that the gradients are of 160 MB. In this case\nit takes 30 ms to send the gradients from all 3 remaining GPUs to the fourth one (each\ntransfer takes 10 ms = 160 MB / 16 GB/s). Adding another 30 ms to transmit the weight\nvectorsbackwearriveatatotalof60ms. IfwesendalldatatotheCPUweincurapenalty\nof 40 ms since eachof the four GPUs needs to send the data to the CPU, yielding a total\nof 80 ms. Lastly assume that we are able to split the gradients into 4 parts of 40 MB each.", "mimetype": "text/plain", "start_char_idx": 1277930, "end_char_idx": 1281899, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "03ea9e79-eb86-4c7a-87db-ddd7d8a95b80": {"__data__": {"id_": "03ea9e79-eb86-4c7a-87db-ddd7d8a95b80", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fa3a8e1d-9c6e-4fbc-ae2f-e341a990579b", "node_type": "1", "metadata": {}, "hash": "52616e27c0005e3f371058ac288b1a80825b0b9a12a0949cdb25c8e1f7e62b2a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2bc3cdef-0830-43a1-83db-8f548a4aaa81", "node_type": "1", "metadata": {}, "hash": "ae9ad3d675343b8a7b93b651c361d45adef832a8cc5c16223d20c3753db4c60c", "class_name": "RelatedNodeInfo"}}, "text": "This means that it is more effective to communicate between\nthe devices.\ntFig. 13.7.2 A 4-way GPU server.\n586 Computational Performance\n210For the sake of the argument let\u2019s assume that the gradients are of 160 MB. In this case\nit takes 30 ms to send the gradients from all 3 remaining GPUs to the fourth one (each\ntransfer takes 10 ms = 160 MB / 16 GB/s). Adding another 30 ms to transmit the weight\nvectorsbackwearriveatatotalof60ms. IfwesendalldatatotheCPUweincurapenalty\nof 40 ms since eachof the four GPUs needs to send the data to the CPU, yielding a total\nof 80 ms. Lastly assume that we are able to split the gradients into 4 parts of 40 MB each.\nNow we can aggregate each of the parts on a different GPU simultaneously since the PCIe\nswitch offers a full-bandwidth operation between all links. Instead of 30 ms this takes 7.5\nms, yielding a total of 15 ms for a synchronization operation. In short, depending on how\nwe synchronize parameters the same operation can take anywhere from 15 ms to 80 ms.\nFig. 13.7.3 depicts the different strategies for exchanging parameters.\ntFig. 13.7.3 Parameter synchronization strategies.\nNotethatwehaveyetanothertoolatourdisposalwhenitcomestoimprovingperformance:\nin a deep network it takes some time to compute all gradients from the top to the bottom.\nWe can begin synchronizing gradients for some parameter groups even while we are still\nbusycomputingthemforothers. Seee.g., SergeevandDelBalso( 2018)fordetailsonhow\nto do this in Horovod210.\n13.7.2RingSynchronization\nWhen it comes to synchronization on modern deep learning hardware we often encounter\nsignificantlybespokenetworkconnectivity. Forinstance,theAWSp3.16xlargeandNVIDIA\nDGX-2 instances share the connectivity structure of Fig. 13.7.4 . Each GPU connects to a\nhost CPU via a PCIe link which operates at best at 16 GB/s. Additionally each GPU also\nhas 6 NVLink connections, each of which is capable of transferring 300 Gbit/s bidirec-\ntionally. This amounts to around 18 GB/s per link per direction. In short, the aggregate\nNVLink bandwidth is significantly higher than the PCIe bandwidth. The question is how\nto use it most efficiently.\nIt turns out that the optimal synchronization strategy is to decompose the network into two\nringsandtousethemtosynchronizedatadirectly( Wangetal.,2018).Fig.13.7.5 illustrates\nthatthenetworkcanbedecomposedintoonering(1-2-3-4-5-6-7-8-1)withdoubleNVLink\nbandwidthandintoone(1-4-6-3-5-8-2-7-1)withregularbandwidth. Designinganefficient\nsynchronization protocol in this case is nontrivial.\nConsider the following thought experiment: given a ring of \ud835\udc5bcomputing nodes (or GPUs)\n587 Parameter Servers\ntFig. 13.7.4 NVLink connectivity on 8 V100 GPU servers (image courtesy of NVIDIA).\ntFig. 13.7.5 Decomposition of the NVLink network into two rings.\nwe can send gradients from the first to the second node. There it is added to the local\ngradient and sent on to the third node, and so on. After \ud835\udc5b\u00001steps the aggregate gradient\ncanbefoundinthelast-visitednode. Thatis,thetimetoaggregategradientsgrowslinearly\nwith the number of nodes. But if we do this the algorithm is quite inefficient. After all,\nat any time there is only one of the nodes communicating. What if we broke the gradients\ninto\ud835\udc5bchunks and started synchronizing chunk \ud835\udc56starting at node \ud835\udc56? Since each chunk is of\nsize 1\u009d\ud835\udc5bthe total time is now \u00b9\ud835\udc5b\u00001\u00ba\u009d\ud835\udc5b\u00191. In other words, the time spent to aggregate\n588 Computational Performance\ngradients does not grow as we increase the size of the ring. This is quite an astonishing\nresult.Fig. 13.7.6 illustrates the sequence of steps on \ud835\udc5b=4nodes.\ntFig. 13.7.6 Ring synchronization across 4 nodes. Each node starts transmitting parts of gradients to\nits left neighbor until the assembled gradient can be found in its right neighbor.", "mimetype": "text/plain", "start_char_idx": 1281245, "end_char_idx": 1285013, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2bc3cdef-0830-43a1-83db-8f548a4aaa81": {"__data__": {"id_": "2bc3cdef-0830-43a1-83db-8f548a4aaa81", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "03ea9e79-eb86-4c7a-87db-ddd7d8a95b80", "node_type": "1", "metadata": {}, "hash": "e1f7f1f84ad66bd3545614542f9eccde84acc9f90a405e907d4ea6be02a2fe42", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "100bb1e2-1a6a-4712-bdfc-07694f518a1f", "node_type": "1", "metadata": {}, "hash": "abdd21bbfd9bc390a342485860a50856b9ff013ccb487fa1509ee7899033054d", "class_name": "RelatedNodeInfo"}}, "text": "But if we do this the algorithm is quite inefficient. After all,\nat any time there is only one of the nodes communicating. What if we broke the gradients\ninto\ud835\udc5bchunks and started synchronizing chunk \ud835\udc56starting at node \ud835\udc56? Since each chunk is of\nsize 1\u009d\ud835\udc5bthe total time is now \u00b9\ud835\udc5b\u00001\u00ba\u009d\ud835\udc5b\u00191. In other words, the time spent to aggregate\n588 Computational Performance\ngradients does not grow as we increase the size of the ring. This is quite an astonishing\nresult.Fig. 13.7.6 illustrates the sequence of steps on \ud835\udc5b=4nodes.\ntFig. 13.7.6 Ring synchronization across 4 nodes. Each node starts transmitting parts of gradients to\nits left neighbor until the assembled gradient can be found in its right neighbor.\nIf we use the same example of synchronizing 160 MB across 8 V100 GPUs we arrive\nat approximately 2\u0001160MB\u009d\u00b93\u000118GB/s\u00ba \u0019 6ms. This is better than using the PCIe\nbus, even though we are now using 8 GPUs. Note that in practice these numbers are a\nbit worse, since deep learning frameworks often fail to assemble communication into large\nburst transfers.\nNote that there is a common misconception that ring synchronization is fundamentally\ndifferent from other synchronization algorithms. The only difference is that the synchro-\nnization path is somewhat more elaborate when compared with a simple tree.\n13.7.3Multi-MachineTraining\nDistributed training on multiple machines adds a further challenge: we need to communi-\ncatewithserversthatareonlyconnectedacrossacomparativelylowerbandwidthfabricthat\ncan be over an order of magnitude slower in some cases. Synchronization across devices is\ntricky. After all, different machines running training code will have subtly different speed.\nHenceweneedto synchronize themifwewanttousesynchronousdistributedoptimization.\nFig. 13.7.7 illustrates how distributed parallel training occurs.\n1.A (different) batch of data is read on each machine, split across multiple GPUs and\ntransferred to GPU memory. There predictions and gradients are computed on each\nGPU batch separately.\n2.The gradients from all local GPUs are aggregated on one GPU (or parts of it are aggre-\ngated over different GPUs).\n589 Parameter Servers\n3.The gradients are sent to the CPUs.\n4.The CPUs send the gradients to a central parameter server which aggregates all the\ngradients.\n5.The aggregate gradients are then used to update the parameters and the updated param-\neters are broadcast back to the individual CPUs.\n6.The information is sent to one (or multiple) GPUs.\n7.The updated parameters are spread across all GPUs.\ntFig. 13.7.7 Multi-machine multi-GPU distributed parallel training.\nEach of these operations seems rather straightforward. And, indeed, they can be carried\nout efficiently withina single machine. Once we look at multiple machines, though, we\ncan see that the central parameter server becomes the bottleneck. After all, the bandwidth\nper server is limited, hence for \ud835\udc5aworkers the time it takes to send all gradients to the\nserver isO\u00b9\ud835\udc5a\u00ba. We can break through this barrier by increasing the number of servers\nto\ud835\udc5b. At this point each server only needs to store O\u00b91\u009d\ud835\udc5b\u00baof the parameters, hence the\ntotal time for updates and optimization becomes O\u00b9\ud835\udc5a\u009d\ud835\udc5b\u00ba. Matching both numbers yields\nconstantscalingregardlessofhowmanyworkerswearedealingwith. Inpracticeweusethe\nsamemachines both as workers and as servers. Fig. 13.7.8 illustrates the design (see also\n(Liet al., 2014) for details). In particular, ensuring that multiple machines work without\nunreasonable delays is nontrivial.\n13.7.4Key\u2013ValueStores\nImplementingthestepsrequiredfordistributedmulti-GPUtraininginpracticeisnontrivial.\nThis is why it pays to use a common abstraction, namely that of a key\u2013value store with\nredefined update semantics.\n590 Computational Performance\ntFig. 13.7.8 Top: a single parameter server is a bottleneck since its bandwidth is \ufb01nite. Bottom:\nmultiple parameter servers store parts of the parameters with aggregate bandwidth.", "mimetype": "text/plain", "start_char_idx": 1284316, "end_char_idx": 1288244, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "100bb1e2-1a6a-4712-bdfc-07694f518a1f": {"__data__": {"id_": "100bb1e2-1a6a-4712-bdfc-07694f518a1f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2bc3cdef-0830-43a1-83db-8f548a4aaa81", "node_type": "1", "metadata": {}, "hash": "ae9ad3d675343b8a7b93b651c361d45adef832a8cc5c16223d20c3753db4c60c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2e244c12-8eff-4d05-b84d-7cfe7ffc3df8", "node_type": "1", "metadata": {}, "hash": "618d03efcbf96ed8e30243779e6fc9f3369e06d0131320ee7dfc1e795280e5c0", "class_name": "RelatedNodeInfo"}}, "text": "Matching both numbers yields\nconstantscalingregardlessofhowmanyworkerswearedealingwith. Inpracticeweusethe\nsamemachines both as workers and as servers. Fig. 13.7.8 illustrates the design (see also\n(Liet al., 2014) for details). In particular, ensuring that multiple machines work without\nunreasonable delays is nontrivial.\n13.7.4Key\u2013ValueStores\nImplementingthestepsrequiredfordistributedmulti-GPUtraininginpracticeisnontrivial.\nThis is why it pays to use a common abstraction, namely that of a key\u2013value store with\nredefined update semantics.\n590 Computational Performance\ntFig. 13.7.8 Top: a single parameter server is a bottleneck since its bandwidth is \ufb01nite. Bottom:\nmultiple parameter servers store parts of the parameters with aggregate bandwidth.\nAcrossmanyworkersandmanyGPUsthecomputationforgradient \ud835\udc56canbedefinedas\ng\ud835\udc56=\u00d5\n\ud835\udc582workers\u00d5\n\ud835\udc572GPUsg\ud835\udc56\ud835\udc57\ud835\udc58,(13.7.1)\nwhereg\ud835\udc56\ud835\udc57\ud835\udc58ispartofgradient \ud835\udc56splitonGPU \ud835\udc57ofworker\ud835\udc58. Thekeyaspectinthisoperation\nis that it is a commutativereduction , that is, it turns many vectors into one and the order in\nwhich the operation is applied does not matter. This is great for our purposes since we do\nnot(needto)havefinegrainedcontroloverwhenwhichgradientisreceived. Besides, note\nthat this operation is independent among different \ud835\udc56.\nThis allows us to define the following two operations: push, which accumulates gradients,\nandpull, which retrieves aggregate gradients. Since we have many different sets of gra-\ndients (after all, we have many layers), we need to index the gradients with a key \ud835\udc56. This\nsimilarity to key\u2013value stores, such as the one introduced in Dynamo ( DeCandia et al.,\n2007) is not by coincidence. They, too, satisfy many similar characteristics, in particular\nwhen it comes to distributing the parameters across multiple servers.\nThe push and pull operations for key-value stores are described as follows:\n\u000fpush(key, value) sends a particular gradient (the value) from a worker to a common\nstorage. There the value is aggregated, e.g., by summing it up.\n\u000fpull(key,value) retrievesanaggregatevaluefromcommonstorage,e.g.,aftercombining\nthe gradients from all workers.\nByhidingallthecomplexityaboutsynchronizationbehindasimplepushandpulloperation\n591 Parameter Servers\n211we can decouple the concerns of statistical modelers who want to be able to express opti-\nmization in simple terms and the system engineers who need to deal with the complexity\ninherent in distributed synchronization.\n13.7.5Summary\n\u000fSynchronization needs to be highly adaptive to specific network infrastructure and con-\nnectivity within a server. This can make a significant difference to the time it takes to\nsynchronize.\n\u000fRing-synchronization can be optimal for p3 and DGX-2 servers. For others possibly not\nso much.\n\u000fA hierarchical synchronization strategy works well when adding multiple parameter\nservers for increased bandwidth.\n13.7.6Exercises\n1.Can you increase the ring synchronization even further? Hint: you can send messages\nin both directions.\n2.Is it possible to allow asynchronous communication (while computation is still ongo-\ning)? How does it affect performance?\n3.Whatifwelostaserverduringalong-runningcomputation? Howcanwedesigna fault\ntolerance mechanism to avoid restarting the computation fully?\nDiscussions211.\n14 Computer Vision\nWhether it is medical diagnosis, self-driving vehicles, camera monitoring, or smart filters,\nmany applications in the field of computer vision are closely related to our current and fu-\nture lives. In recent years, deep learning has been the transformative power for advancing\nthe performance of computer vision systems. It can be said that the most advanced com-\nputer vision applications are almost inseparable from deep learning. In view of this, this\nchapterwillfocusonthefieldofcomputervision,andinvestigatemethodsandapplications\nthat have recently been influential in academia and industry.\nInChapter 7 andChapter 8 , we studied various convolutional neural networks that are\ncommonly used in computer vision, and applied them to simple image classification tasks.\nAt the beginning of this chapter, we will describe two methods that may improve model\ngeneralization, namely imageaugmentation andfine-tuning , andapplythemtoimageclas-\nsification.", "mimetype": "text/plain", "start_char_idx": 1287491, "end_char_idx": 1291715, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2e244c12-8eff-4d05-b84d-7cfe7ffc3df8": {"__data__": {"id_": "2e244c12-8eff-4d05-b84d-7cfe7ffc3df8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "100bb1e2-1a6a-4712-bdfc-07694f518a1f", "node_type": "1", "metadata": {}, "hash": "abdd21bbfd9bc390a342485860a50856b9ff013ccb487fa1509ee7899033054d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8b7e8d6f-28d6-4550-8817-61ba1977a7eb", "node_type": "1", "metadata": {}, "hash": "a82088aeb711385d0742073a3a46f8d39fa609f5ab43cad7bf20c767214bf43b", "class_name": "RelatedNodeInfo"}}, "text": "Discussions211.\n14 Computer Vision\nWhether it is medical diagnosis, self-driving vehicles, camera monitoring, or smart filters,\nmany applications in the field of computer vision are closely related to our current and fu-\nture lives. In recent years, deep learning has been the transformative power for advancing\nthe performance of computer vision systems. It can be said that the most advanced com-\nputer vision applications are almost inseparable from deep learning. In view of this, this\nchapterwillfocusonthefieldofcomputervision,andinvestigatemethodsandapplications\nthat have recently been influential in academia and industry.\nInChapter 7 andChapter 8 , we studied various convolutional neural networks that are\ncommonly used in computer vision, and applied them to simple image classification tasks.\nAt the beginning of this chapter, we will describe two methods that may improve model\ngeneralization, namely imageaugmentation andfine-tuning , andapplythemtoimageclas-\nsification. Since deep neural networks can effectively represent images in multiple lev-\nels, such layerwise representations have been successfully used in various computer vision\ntaskssuchas objectdetection ,semanticsegmentation ,andstyletransfer . Followingthekey\nidea of leveraging layerwise representations in computer vision, we will begin with major\ncomponents and techniques for object detection. Next, we will show how to use fully con-\nvolutionalnetworks forsemanticsegmentationofimages. Thenwewillexplainhowtouse\nstyle transfer techniques to generate images like the cover of this book. In the end, we con-\nclude this chapter by applying the materials of this chapter and several previous chapters\non two popular computer vision benchmark datasets.\n14.1ImageAugmentation\nInSection 8.1 , we mentioned that large datasets are a prerequisite for the success of deep\nneuralnetworksinvariousapplications. Imageaugmentation generatessimilarbutdistinct\ntraining examples after a series of random changes to the training images, thereby expand-\ning the size of the training set. Alternatively, image augmentation can be motivated by the\nfactthatrandomtweaksoftrainingexamplesallowmodelstorelylessoncertainattributes,\nthereby improving their generalization ability. For example, we can crop an image in dif-\nferent ways to make the object of interest appear in different positions, thereby reducing\nthe dependence of a model on the position of the object. We can also adjust factors such as\nbrightness and color to reduce a model\u2019s sensitivity to color. It is probably true that image\n592\n593 Image Augmentation\naugmentation was indispensable for the success of AlexNet at that time. In this section we\nwill discuss this widely used technique in computer vision.\n%matplotlib inline\nimport torch\nimport torchvision\nfrom torch import nn\nfrom d2l import torch asd2l\n14.1.1CommonImageAugmentation Methods\nIn our investigation of common image augmentation methods, we will use the following\n400\u0002500image an example.\nd2l.set_figsize()\nimg =d2l.Image .open( '../img/cat1.jpg ')\nd2l.plt.imshow(img);\nMost image augmentation methods have a certain degree of randomness. To make it easier\nfor us to observe the effect of image augmentation, next we define an auxiliary function\napply. Thisfunctionrunstheimageaugmentationmethod augmultipletimesontheinput\nimage imgand shows all the results.\ndef apply (img, aug, num_rows =2, num_cols =4, scale =1.5):\nY=[aug(img) for _inrange (num_rows *num_cols)]\nd2l.show_images(Y, num_rows, num_cols, scale =scale)\nFlipping and Cropping\nFlippingtheimageleftandrightusuallydoesnotchangethecategoryoftheobject. Thisis\none of the earliest and most widely used methods of image augmentation. Next, we use the\ntransforms module to create the RandomHorizontalFlip instance, which flips an image\nleft and right with a 50% chance.\napply(img, torchvision .transforms .RandomHorizontalFlip())\nFlipping up and down is not as common as flipping left and right. But at least for this\n594 Computer Vision\nexample image, flipping up and down does not hinder recognition. Next, we create a Ran-\ndomVerticalFlip instance to flip an image up and down with a 50% chance.\napply(img, torchvision .transforms .RandomVerticalFlip())\nInthe exampleimageweused, the cat isin the middle of the image, but thismaynot be the\ncaseingeneral. In Section7.5 ,weexplainedthatthepoolinglayercanreducethesensitivity\nof a convolutional layer to the target position.", "mimetype": "text/plain", "start_char_idx": 1290729, "end_char_idx": 1295159, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8b7e8d6f-28d6-4550-8817-61ba1977a7eb": {"__data__": {"id_": "8b7e8d6f-28d6-4550-8817-61ba1977a7eb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2e244c12-8eff-4d05-b84d-7cfe7ffc3df8", "node_type": "1", "metadata": {}, "hash": "618d03efcbf96ed8e30243779e6fc9f3369e06d0131320ee7dfc1e795280e5c0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6e9ef3fe-735a-48e0-92f9-e9e14ea81ab6", "node_type": "1", "metadata": {}, "hash": "4167267128d87c436cd2e07f679c2170f5a178fd3499f5551b259218f0046025", "class_name": "RelatedNodeInfo"}}, "text": "Thisis\none of the earliest and most widely used methods of image augmentation. Next, we use the\ntransforms module to create the RandomHorizontalFlip instance, which flips an image\nleft and right with a 50% chance.\napply(img, torchvision .transforms .RandomHorizontalFlip())\nFlipping up and down is not as common as flipping left and right. But at least for this\n594 Computer Vision\nexample image, flipping up and down does not hinder recognition. Next, we create a Ran-\ndomVerticalFlip instance to flip an image up and down with a 50% chance.\napply(img, torchvision .transforms .RandomVerticalFlip())\nInthe exampleimageweused, the cat isin the middle of the image, but thismaynot be the\ncaseingeneral. In Section7.5 ,weexplainedthatthepoolinglayercanreducethesensitivity\nof a convolutional layer to the target position. In addition, we can also randomly crop the\nimage to make objects appear in different positions in the image at different scales, which\ncan also reduce the sensitivity of a model to the target position.\nIn the code below, we randomly crop an area with an area of 10%\u0018100%of the original\nareaeachtime, andtheratioofwidthtoheightofthisareaisrandomlyselectedfrom 0.5\u0018\n2. Then, the width and height of the region are both scaled to 200 pixels. Unless otherwise\nspecified, the random number between \ud835\udc4eand\ud835\udc4fin this section refers to a continuous value\nobtained by random and uniform sampling from the interval \u00bb\ud835\udc4e,\ud835\udc4f\u00bc.\nshape_aug =torchvision .transforms .RandomResizedCrop(\n(200,200), scale =(0.1,1), ratio =(0.5,2))\napply(img, shape_aug)\nChangingColors\nAnotheraugmentationmethodischangingcolors. Wecanchangefouraspectsoftheimage\ncolor: brightness,contrast,saturation,andhue. Intheexamplebelow,werandomlychange\nthe brightness of the image to a value between 50% ( 1\u00000.5) and 150% ( 1\u00b80.5) of the\noriginal image.\n595 Image Augmentation\napply(img, torchvision .transforms .ColorJitter(\nbrightness =0.5, contrast =0, saturation =0, hue =0))\nSimilarly, we can randomly change the hue of the image.\napply(img, torchvision .transforms .ColorJitter(\nbrightness =0, contrast =0, saturation =0, hue =0.5))\nWe can also create a RandomColorJitter instance and set how to randomly change the\nbrightness ,contrast ,saturation , and hueof the image at the same time.\ncolor_aug =torchvision .transforms .ColorJitter(\nbrightness =0.5, contrast =0.5, saturation =0.5, hue =0.5)\napply(img, color_aug)\n596 Computer Vision\nCombiningMultiple ImageAugmentation Methods\nIn practice, we will combine multiple image augmentation methods. For example, we can\ncombine the different image augmentation methods defined above and apply them to each\nimage via a Compose instance.\naugs =torchvision .transforms .Compose([\ntorchvision .transforms .RandomHorizontalFlip(), color_aug, shape_aug])\napply(img, augs)\n14.1.2Trainingwith Image Augmentation\nLet\u2019s train a model with image augmentation. Here we use the CIFAR-10 dataset instead\nof the Fashion-MNIST dataset that we used before. This is because the position and size\nof the objects in the Fashion-MNIST dataset have been normalized, while the color and\nsize of the objects in the CIFAR-10 dataset have more significant differences. The first 32\ntraining images in the CIFAR-10 dataset are shown below.\nall_images =torchvision .datasets .CIFAR10(train =True , root =\"../data \",\ndownload =True )\nd2l.show_images([all_images[i][ 0]for iinrange (32)], 4,8, scale =0.8);\nDownloading https://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz to ../data/\n\u21a9!cifar-10-python.tar.gz\n100%|\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff| 170498071/170498071 [00:04<00:00, 37716809.52it/s]\nExtracting ../data/cifar-10-python.tar.gz to ../data\nIn order to obtain definitive results during prediction, we usually only apply image aug-\n597 Image Augmentation\nmentation to training examples, and do not use image augmentation with random opera-\ntions during prediction.", "mimetype": "text/plain", "start_char_idx": 1294340, "end_char_idx": 1298187, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6e9ef3fe-735a-48e0-92f9-e9e14ea81ab6": {"__data__": {"id_": "6e9ef3fe-735a-48e0-92f9-e9e14ea81ab6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8b7e8d6f-28d6-4550-8817-61ba1977a7eb", "node_type": "1", "metadata": {}, "hash": "a82088aeb711385d0742073a3a46f8d39fa609f5ab43cad7bf20c767214bf43b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "65c24837-ffd9-4243-af83-1eeb87f7e04b", "node_type": "1", "metadata": {}, "hash": "c362bf064549cfaab69bd939e37dd801605c0b8ba3ecb8fb49ffb3b380e719f6", "class_name": "RelatedNodeInfo"}}, "text": "all_images =torchvision .datasets .CIFAR10(train =True , root =\"../data \",\ndownload =True )\nd2l.show_images([all_images[i][ 0]for iinrange (32)], 4,8, scale =0.8);\nDownloading https://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz to ../data/\n\u21a9!cifar-10-python.tar.gz\n100%|\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff| 170498071/170498071 [00:04<00:00, 37716809.52it/s]\nExtracting ../data/cifar-10-python.tar.gz to ../data\nIn order to obtain definitive results during prediction, we usually only apply image aug-\n597 Image Augmentation\nmentation to training examples, and do not use image augmentation with random opera-\ntions during prediction. Here we only use the simplest random left-right flipping method.\nIn addition, we use a ToTensor instance to convert a minibatch of images into the format\nrequired by the deep learning framework, i.e., 32-bit floating point numbers between 0 and\n1 with the shape of (batch size, number of channels, height, width).\ntrain_augs =torchvision .transforms .Compose([\ntorchvision .transforms .RandomHorizontalFlip(),\ntorchvision .transforms .ToTensor()])\ntest_augs =torchvision .transforms .Compose([\ntorchvision .transforms .ToTensor()])\nNext, we define an auxiliary function to facilitate reading the image and applying image\naugmentation. The transform argument provided by PyTorch\u2019s dataset applies augmen-\ntation to transform the images. For a detailed introduction to DataLoader , please refer to\nSection 4.2 .\ndef load_cifar10 (is_train, augs, batch_size):\ndataset =torchvision .datasets .CIFAR10(root =\"../data \", train =is_train,\ntransform =augs, download =True )\ndataloader =torch .utils .data .DataLoader(dataset, batch_size =batch_size,\nshuffle =is_train, num_workers =d2l.get_dataloader_workers())\nreturn dataloader\nMulti-GPUTraining\nWe train the ResNet-18 model from Section 8.6 on the CIFAR-10 dataset. Recall the in-\ntroduction to multi-GPU training in Section 13.6 . In the following, we define a function to\ntrain and evaluate the model using multiple GPUs.\n#@save\ndef train_batch_ch13 (net, X, y, loss, trainer, devices):\n\"\"\"Train for a minibatch with multiple GPUs (defined in Chapter 13).\"\"\"\nifisinstance (X, list ):\n# Required for BERT fine-tuning (to be covered later)\nX=[x.to(devices[ 0])for xinX]\n(continues on next page)\n598 Computer Vision\n(continued from previous page)\nelse :\nX=X.to(devices[ 0])\ny=y.to(devices[ 0])\nnet.train()\ntrainer .zero_grad()\npred =net(X)\nl=loss(pred, y)\nl.sum() .backward()\ntrainer .step()\ntrain_loss_sum =l.sum()\ntrain_acc_sum =d2l.accuracy(pred, y)\nreturn train_loss_sum, train_acc_sum\n#@save\ndef train_ch13 (net, train_iter, test_iter, loss, trainer, num_epochs,\ndevices =d2l.try_all_gpus()):\n\"\"\"Train a model with multiple GPUs (defined in Chapter 13).\"\"\"\ntimer, num_batches =d2l.Timer(), len(train_iter)\nanimator =d2l.Animator(xlabel ='epoch ', xlim =[1, num_epochs], ylim =[0,1],\nlegend =['train loss ','train acc ','test acc '])\nnet =nn.DataParallel(net, device_ids =devices) .to(devices[ 0])\nfor epoch inrange (num_epochs):\n# Sum of training loss, sum of training accuracy, no. of examples,\n# no.", "mimetype": "text/plain", "start_char_idx": 1297575, "end_char_idx": 1300638, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "65c24837-ffd9-4243-af83-1eeb87f7e04b": {"__data__": {"id_": "65c24837-ffd9-4243-af83-1eeb87f7e04b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6e9ef3fe-735a-48e0-92f9-e9e14ea81ab6", "node_type": "1", "metadata": {}, "hash": "4167267128d87c436cd2e07f679c2170f5a178fd3499f5551b259218f0046025", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c84adff4-0f77-45c2-9f07-1c799e1b91c6", "node_type": "1", "metadata": {}, "hash": "f0be3d8d1a574e672c6c0c45cf58220e46cf8f5c62bb90b3efd8ea635e88b30c", "class_name": "RelatedNodeInfo"}}, "text": "timer, num_batches =d2l.Timer(), len(train_iter)\nanimator =d2l.Animator(xlabel ='epoch ', xlim =[1, num_epochs], ylim =[0,1],\nlegend =['train loss ','train acc ','test acc '])\nnet =nn.DataParallel(net, device_ids =devices) .to(devices[ 0])\nfor epoch inrange (num_epochs):\n# Sum of training loss, sum of training accuracy, no. of examples,\n# no. of predictions\nmetric =d2l.Accumulator( 4)\nfor i, (features, labels) inenumerate (train_iter):\ntimer .start()\nl, acc =train_batch_ch13(\nnet, features, labels, loss, trainer, devices)\nmetric .add(l, acc, labels .shape[ 0], labels .numel())\ntimer .stop()\nif(i+1)%(num_batches //5)==0ori==num_batches -1:\nanimator .add(epoch +(i+1)/num_batches,\n(metric[ 0]/metric[ 2], metric[ 1]/metric[ 3],\nNone ))\ntest_acc =d2l.evaluate_accuracy_gpu(net, test_iter)\nanimator .add(epoch +1, (None ,None , test_acc))\nprint (f'loss {metric[ 0]/metric[ 2]:.3f}, train acc '\nf'{metric[ 1]/metric[ 3]:.3f}, test acc {test_acc :.3f}')\nprint (f'{metric[ 2]*num_epochs /timer .sum() :.1f}examples/sec on '\nf'{str(devices) }')\nNow we can define the train_with_data_aug function to train the model with image\naugmentation. This function gets all available GPUs, uses Adam as the optimization algo-\nrithm, appliesimageaugmentationtothetrainingdataset, andfinallycallsthe train_ch13\nfunction just defined to train and evaluate the model.\nbatch_size, devices, net =256, d2l .try_all_gpus(), d2l .resnet18( 10,3)\nnet.apply(d2l .init_cnn)\ndef train_with_data_aug (train_augs, test_augs, net, lr =0.001 ):\ntrain_iter =load_cifar10( True , train_augs, batch_size)\n(continues on next page)\n599 Image Augmentation\n(continued from previous page)\ntest_iter =load_cifar10( False , test_augs, batch_size)\nloss =nn.CrossEntropyLoss(reduction =\"none \")\ntrainer =torch .optim .Adam(net .parameters(), lr =lr)\nnet( next (iter (train_iter))[ 0])\ntrain_ch13(net, train_iter, test_iter, loss, trainer, 10, devices)\nLet\u2019strainthemodelusingimageaugmentationbasedonrandomleft-rightflipping.\ntrain_with_data_aug(train_augs, test_augs, net)\nloss 0.215 , train acc 0.925 , test acc 0.810\n4728.8 examples /sec on [device( type ='cuda ', index =0), device( type ='cuda ',\u2423\n\u21a9!index =1)]\n14.1.3Summary\n\u000fImageaugmentationgeneratesrandomimagesbasedonexistingtrainingdatatoimprove\nthe generalization ability of models.\n\u000fIn order to obtain definitive results during prediction, we usually only apply image aug-\nmentation to training examples, and do not use image augmentation with random op-\nerations during prediction.\n\u000fDeep learning frameworks provide many different image augmentation methods, which\ncan be applied simultaneously.\n14.1.4Exercises\n1.Trainthemodelwithoutusingimageaugmentation: train_with_data_aug(test_augs,\ntest_augs) . Compare training and testing accuracy when using and not using image\naugmentation. Can this comparative experiment support the argument that image aug-\nmentation can mitigate overfitting? Why?\n2.CombinemultipledifferentimageaugmentationmethodsinmodeltrainingontheCIFAR-\n10 dataset. Does it improve test accuracy?\n600 Computer Vision\n2123.Refer to the online documentation of the deep learning framework. What other image\naugmentation methods does it also provide?\nDiscussions212.\n14.2Fine-Tuning\nIn earlier chapters, we discussed how to train models on the Fashion-MNIST training\ndataset with only 60000 images. We also described ImageNet, the most widely used large-\nscale image dataset in academia, which has more than 10 million images and 1000 objects.\nHowever, the size of the dataset that we usually encounter is between those of the two\ndatasets.\nSuppose that we want to recognize different types of chairs from images, and then recom-\nmend purchase links to users.", "mimetype": "text/plain", "start_char_idx": 1300294, "end_char_idx": 1303990, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c84adff4-0f77-45c2-9f07-1c799e1b91c6": {"__data__": {"id_": "c84adff4-0f77-45c2-9f07-1c799e1b91c6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "65c24837-ffd9-4243-af83-1eeb87f7e04b", "node_type": "1", "metadata": {}, "hash": "c362bf064549cfaab69bd939e37dd801605c0b8ba3ecb8fb49ffb3b380e719f6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2115b772-8509-4d77-8f9d-9282082ac41f", "node_type": "1", "metadata": {}, "hash": "c7fd8f14e9f48f9b2b1bc957d559465be2f3e61dcdcc13654f328c824f094e20", "class_name": "RelatedNodeInfo"}}, "text": "Can this comparative experiment support the argument that image aug-\nmentation can mitigate overfitting? Why?\n2.CombinemultipledifferentimageaugmentationmethodsinmodeltrainingontheCIFAR-\n10 dataset. Does it improve test accuracy?\n600 Computer Vision\n2123.Refer to the online documentation of the deep learning framework. What other image\naugmentation methods does it also provide?\nDiscussions212.\n14.2Fine-Tuning\nIn earlier chapters, we discussed how to train models on the Fashion-MNIST training\ndataset with only 60000 images. We also described ImageNet, the most widely used large-\nscale image dataset in academia, which has more than 10 million images and 1000 objects.\nHowever, the size of the dataset that we usually encounter is between those of the two\ndatasets.\nSuppose that we want to recognize different types of chairs from images, and then recom-\nmend purchase links to users. One possible method is to first identify 100 common chairs,\ntake 1000 images of different angles for each chair, and then train a classification model\non the collected image dataset. Although this chair dataset may be larger than the Fashion-\nMNIST dataset, the number of examples is still less than one-tenth of that in ImageNet.\nThis may lead to overfitting of complicated models that are suitable for ImageNet on this\nchair dataset. Besides, due to the limited amount of training examples, the accuracy of the\ntrained model may not meet practical requirements.\nIn order to address the above problems, an obvious solution is to collect more data. How-\never, collecting and labeling data can take a lot of time and money. For example, in order\nto collect the ImageNet dataset, researchers have spent millions of dollars from research\nfunding. Although the current data collection cost has been significantly reduced, this cost\nstill cannot be ignored.\nAnother solution is to apply transfer learning to transfer the knowledge learned from the\nsourcedataset to thetargetdataset . For example, although most of the images in the Ima-\ngeNet dataset have nothing to do with chairs, the model trained on this dataset may extract\nmore general image features, which can help identify edges, textures, shapes, and object\ncomposition. These similar features may also be effective for recognizing chairs.\n14.2.1Steps\nIn this section, we will introduce a common technique in transfer learning: fine-tuning . As\nshown in Fig. 14.2.1 , fine-tuning consists of the following four steps:\n1.Pretrain a neural network model, i.e., the source model , on a source dataset (e.g., the\nImageNet dataset).\n2.Create a new neural network model, i.e., the target model . This copies all model de-\nsigns and their parameters on the source model except the output layer. We assume that\nthese model parameters contain the knowledge learned from the source dataset and this\n601 Fine-Tuning\nknowledge will also be applicable to the target dataset. We also assume that the output\nlayer of the source model is closely related to the labels of the source dataset; thus it is\nnot used in the target model.\n3.Add an output layer to the target model, whose number of outputs is the number of\ncategories in the target dataset. Then randomly initialize the model parameters of this\nlayer.\n4.Train the target model on the target dataset, such as a chair dataset. The output layer\nwill be trained from scratch, while the parameters of all the other layers are fine-tuned\nbased on the parameters of the source model.\ntFig. 14.2.1 Fine tuning.\nWhen target datasets are much smaller than source datasets, fine-tuning helps to improve\nmodels\u2019 generalization ability.\n14.2.2HotDog Recognition\nLet\u2019s demonstrate fine-tuning via a concrete case: hot dog recognition. We will fine-tune\na ResNet model on a small dataset, which was pretrained on the ImageNet dataset. This\nsmall dataset consists of thousands of images with and without hot dogs. We will use the\nfine-tuned model to recognize hot dogs from images.\n%matplotlib inline\nimport os\nimport torch\nimport torchvision\nfrom torch import nn\nfrom d2l import torch asd2l\nReadingthe Dataset\nThe hot dog dataset we use was taken from online images. This dataset consists of 1400\npositive-class images containing hot dogs, and as many negative-class images containing\nother foods. 1000 images of both classes are used for training and the rest are for test-\ning.\n602 Computer Vision\nAfterunzippingthedownloadeddataset,weobtaintwofolders hotdog/train andhotdog/\ntest. Both folders have hotdog andnot-hotdog subfolders, either of which contains\nimages of the corresponding class.", "mimetype": "text/plain", "start_char_idx": 1303101, "end_char_idx": 1307668, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2115b772-8509-4d77-8f9d-9282082ac41f": {"__data__": {"id_": "2115b772-8509-4d77-8f9d-9282082ac41f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c84adff4-0f77-45c2-9f07-1c799e1b91c6", "node_type": "1", "metadata": {}, "hash": "f0be3d8d1a574e672c6c0c45cf58220e46cf8f5c62bb90b3efd8ea635e88b30c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7c5ab1e9-f70a-472b-af4f-c3ce8399578e", "node_type": "1", "metadata": {}, "hash": "85cfd7922e233e4876089ce7be9c1d474e08c62fc6362bd89d081ec517b77237", "class_name": "RelatedNodeInfo"}}, "text": "This\nsmall dataset consists of thousands of images with and without hot dogs. We will use the\nfine-tuned model to recognize hot dogs from images.\n%matplotlib inline\nimport os\nimport torch\nimport torchvision\nfrom torch import nn\nfrom d2l import torch asd2l\nReadingthe Dataset\nThe hot dog dataset we use was taken from online images. This dataset consists of 1400\npositive-class images containing hot dogs, and as many negative-class images containing\nother foods. 1000 images of both classes are used for training and the rest are for test-\ning.\n602 Computer Vision\nAfterunzippingthedownloadeddataset,weobtaintwofolders hotdog/train andhotdog/\ntest. Both folders have hotdog andnot-hotdog subfolders, either of which contains\nimages of the corresponding class.\n#@save\nd2l.DATA_HUB[ 'hotdog ']=(d2l .DATA_URL +'hotdog.zip ',\n'fba480ffa8aa7e0febbb511d181409f899b9baa5 ')\ndata_dir =d2l.download_extract( 'hotdog ')\nDownloading ../data /hotdog .zip from http ://d2l-data .s3-accelerate .amazonaws .\n\u21a9!com/hotdog .zip...\nWe create two instances to read all the image files in the training and testing datasets, re-\nspectively.\ntrain_imgs =torchvision .datasets .ImageFolder(os .path .join(data_dir, 'train '))\ntest_imgs =torchvision .datasets .ImageFolder(os .path .join(data_dir, 'test '))\nThe first 8 positive examples and the last 8 negative images are shown below. As you can\nsee, the images vary in size and aspect ratio.\nhotdogs =[train_imgs[i][ 0]for iinrange (8)]\nnot_hotdogs =[train_imgs[ -i-1][0]for iinrange (8)]\nd2l.show_images(hotdogs +not_hotdogs, 2,8, scale =1.4);\nDuring training, we first crop a random area of random size and random aspect ratio from\ntheimage,andthenscalethisareatoa 224\u0002224inputimage. Duringtesting,wescaleboth\nthe height and width of an image to 256 pixels, and then crop a central 224\u0002224area as\ninput. In addition, for the three RGB (red, green, and blue) color channels we standardize\ntheirvalueschannelbychannel. Concretely,themeanvalueofachannelissubtractedfrom\neach value of that channel and then the result is divided by the standard deviation of that\nchannel.\n# Specify the means and standard deviations of the three RGB channels to\n# standardize each channel\nnormalize =torchvision .transforms .Normalize(\n(continues on next page)\n603 Fine-Tuning\n(continued from previous page)\n[0.485 ,0.456 ,0.406 ], [ 0.229 ,0.224 ,0.225 ])\ntrain_augs =torchvision .transforms .Compose([\ntorchvision .transforms .RandomResizedCrop( 224),\ntorchvision .transforms .RandomHorizontalFlip(),\ntorchvision .transforms .ToTensor(),\nnormalize])\ntest_augs =torchvision .transforms .Compose([\ntorchvision .transforms .Resize([ 256,256]),\ntorchvision .transforms .CenterCrop( 224),\ntorchvision .transforms .ToTensor(),\nnormalize])\nDefiningand Initializing the Model\nWe use ResNet-18, which was pretrained on the ImageNet dataset, as the source model.\nHere, we specify pretrained=True to automatically download the pretrained model pa-\nrameters. If this model is used for the first time, Internet connection is required for down-\nload.\npretrained_net =torchvision .models .resnet18(pretrained =True )\nThe pretrained source model instance contains a number of feature layers and an output\nlayer fc. The main purpose of this division is to facilitate the fine-tuning of model param-\neters of all layers but the output layer. The member variable fcof source model is given\nbelow.\npretrained_net .fc\nLinear(in_features =512, out_features =1000 , bias =True )\nAs a fully connected layer, it transforms ResNet\u2019s final global average pooling outputs into\n1000 class outputs of the ImageNet dataset. We then construct a new neural network as\nthe target model. It is defined in the same way as the pretrained source model except that\nits number of outputs in the final layer is set to the number of classes in the target dataset\n(rather than 1000).\nIn the code below, the model parameters before the output layer of the target model in-\nstance finetune_net are initialized to model parameters of the corresponding layers from\nthe source model.", "mimetype": "text/plain", "start_char_idx": 1306909, "end_char_idx": 1310956, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7c5ab1e9-f70a-472b-af4f-c3ce8399578e": {"__data__": {"id_": "7c5ab1e9-f70a-472b-af4f-c3ce8399578e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2115b772-8509-4d77-8f9d-9282082ac41f", "node_type": "1", "metadata": {}, "hash": "c7fd8f14e9f48f9b2b1bc957d559465be2f3e61dcdcc13654f328c824f094e20", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ff15a545-95a9-491e-8fbe-1c0f1435a9e5", "node_type": "1", "metadata": {}, "hash": "309747bcaaf20aae4a32abf99b7d3eaed6bbb537a90171c4d23a3b740af62f6f", "class_name": "RelatedNodeInfo"}}, "text": "The main purpose of this division is to facilitate the fine-tuning of model param-\neters of all layers but the output layer. The member variable fcof source model is given\nbelow.\npretrained_net .fc\nLinear(in_features =512, out_features =1000 , bias =True )\nAs a fully connected layer, it transforms ResNet\u2019s final global average pooling outputs into\n1000 class outputs of the ImageNet dataset. We then construct a new neural network as\nthe target model. It is defined in the same way as the pretrained source model except that\nits number of outputs in the final layer is set to the number of classes in the target dataset\n(rather than 1000).\nIn the code below, the model parameters before the output layer of the target model in-\nstance finetune_net are initialized to model parameters of the corresponding layers from\nthe source model. Since these model parameters were obtained via pretraining on Ima-\ngeNet, they are effective. Therefore, we can only use a small learning rate to fine-tune such\npretrained parameters. In contrast, model parameters in the output layer are randomly ini-\ntialized and generally require a larger learning rate to be learned from scratch. Letting the\nbase learning rate be \ud835\udf02, a learning rate of 10\ud835\udf02will be used to iterate the model parameters\nin the output layer.\n604 Computer Vision\nfinetune_net =torchvision .models .resnet18(pretrained =True )\nfinetune_net .fc=nn.Linear(finetune_net .fc.in_features, 2)\nnn.init .xavier_uniform_(finetune_net .fc.weight);\nFine-Tuningthe Model\nFirst, we define a training function train_fine_tuning that uses fine-tuning so it can be\ncalled multiple times.\n# If `param_group=True`, the model parameters in the output layer will be\n# updated using a learning rate ten times greater\ndef train_fine_tuning (net, learning_rate, batch_size =128, num_epochs =5,\nparam_group =True ):\ntrain_iter =torch .utils .data .DataLoader(torchvision .datasets .ImageFolder(\nos.path .join(data_dir, 'train '), transform =train_augs),\nbatch_size =batch_size, shuffle =True )\ntest_iter =torch .utils .data .DataLoader(torchvision .datasets .ImageFolder(\nos.path .join(data_dir, 'test '), transform =test_augs),\nbatch_size =batch_size)\ndevices =d2l.try_all_gpus()\nloss =nn.CrossEntropyLoss(reduction =\"none \")\nifparam_group:\nparams_1x =[param for name, param innet.named_parameters()\nifname not in[\"fc.weight \",\"fc.bias \"]]\ntrainer =torch .optim .SGD([{ 'params ': params_1x},\n{'params ': net .fc.parameters(),\n'lr': learning_rate *10}],\nlr=learning_rate, weight_decay =0.001 )\nelse :\ntrainer =torch .optim .SGD(net .parameters(), lr =learning_rate,\nweight_decay =0.001 )\nd2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs,\ndevices)\nWe set the base learning rate to a small value in order to fine-tune the model parameters\nobtained via pretraining. Based on the previous settings, we will train the output layer\nparameters of the target model from scratch using a learning rate ten times greater.\ntrain_fine_tuning(finetune_net, 5e-5 )\nloss 0.242 , train acc 0.909 , test acc 0.940\n1062.4 examples /sec on [device( type ='cuda ', index =0), device( type ='cuda ',\u2423\n\u21a9!index =1)]\nFor comparison, we define an identical model, but initialize all of its model parameters to\nrandomvalues. Sincetheentiremodelneedstobetrainedfromscratch,wecanusealarger\nlearning rate.\n605 Fine-Tuning\nscratch_net =torchvision .models .resnet18()\nscratch_net .fc=nn.Linear(scratch_net .fc.in_features, 2)\ntrain_fine_tuning(scratch_net, 5e-4 , param_group =False )\nloss 0.352 , train acc 0.846 , test acc 0.850\n1525.4 examples /sec on [device( type ='cuda ', index =0), device( type ='cuda ',\u2423\n\u21a9!index =1)]\nAs we can see, the fine-tuned model tends to perform better for the same epoch because its\ninitial parameter values are more effective.\n14.2.3Summary\n\u000fTransferlearningtransfersknowledgelearnedfromthesourcedatasettothetargetdataset.\nFine-tuning is a common technique for transfer learning.", "mimetype": "text/plain", "start_char_idx": 1310120, "end_char_idx": 1314053, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ff15a545-95a9-491e-8fbe-1c0f1435a9e5": {"__data__": {"id_": "ff15a545-95a9-491e-8fbe-1c0f1435a9e5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7c5ab1e9-f70a-472b-af4f-c3ce8399578e", "node_type": "1", "metadata": {}, "hash": "85cfd7922e233e4876089ce7be9c1d474e08c62fc6362bd89d081ec517b77237", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9495b846-9914-4797-8427-651d38d839f4", "node_type": "1", "metadata": {}, "hash": "90b81395292c92376aa159d7fcb5df97bb5e952253e437c5030c5ded27f235d4", "class_name": "RelatedNodeInfo"}}, "text": "Sincetheentiremodelneedstobetrainedfromscratch,wecanusealarger\nlearning rate.\n605 Fine-Tuning\nscratch_net =torchvision .models .resnet18()\nscratch_net .fc=nn.Linear(scratch_net .fc.in_features, 2)\ntrain_fine_tuning(scratch_net, 5e-4 , param_group =False )\nloss 0.352 , train acc 0.846 , test acc 0.850\n1525.4 examples /sec on [device( type ='cuda ', index =0), device( type ='cuda ',\u2423\n\u21a9!index =1)]\nAs we can see, the fine-tuned model tends to perform better for the same epoch because its\ninitial parameter values are more effective.\n14.2.3Summary\n\u000fTransferlearningtransfersknowledgelearnedfromthesourcedatasettothetargetdataset.\nFine-tuning is a common technique for transfer learning.\n\u000fThe target model copies all model designs with their parameters from the source model\nexcept the output layer, and fine-tunes these parameters based on the target dataset. In\ncontrast, the output layer of the target model needs to be trained from scratch.\n\u000fGenerally, fine-tuning parameters uses a smaller learning rate, while training the output\nlayer from scratch can use a larger learning rate.\n14.2.4Exercises\n606 Computer Vision\n2131.Keep increasing the learning rate of finetune_net . How does the accuracy of the\nmodel change?\n2.Furtheradjusthyperparametersof finetune_net andscratch_net inthecomparative\nexperiment. Do they still differ in accuracy?\n3.Settheparametersbeforetheoutputlayerof finetune_net tothoseofthesourcemodel\nand donotupdate them during training. How does the accuracy of the model change?\nYou can use the following code.\nfor param infinetune_net .parameters():\nparam .requires_grad =False\n4.In fact, there is a \u201chotdog\u201d class in the ImageNet dataset. Its corresponding weight\nparameter in the output layer can be obtained via the following code. How can we\nleverage this weight parameter?\nweight =pretrained_net .fc.weight\nhotdog_w =torch .split(weight .data, 1, dim =0)[934]\nhotdog_w .shape\ntorch .Size([ 1,512])\nDiscussions213.\n14.3Object Detectionand Bounding Boxes\nIn earlier sections (e.g., Section 8.1 \u2013Section 8.4 ), we introduced various models for image\nclassification. In image classification tasks, we assume that there is only onemajor object\nin the image and we only focus on how to recognize its category. However, there are often\nmultiple objects in the image of interest. We not only want to know their categories, but\nalso their specific positions in the image. In computer vision, we refer to such tasks as\nobjectdetection (orobjectrecognition ).\nObjectdetectionhasbeenwidelyappliedinmanyfields. Forexample,self-drivingneedsto\nplantravelingroutesbydetectingthepositionsofvehicles,pedestrians,roads,andobstacles\nin the captured video images. Besides, robots may use this technique to detect and localize\nobjectsofinterestthroughoutitsnavigationofanenvironment. Moreover,securitysystems\nmay need to detect abnormal objects, such as intruders or bombs.\nIn the next few sections, we will introduce several deep learning methods for object detec-\ntion. We will begin with an introduction to positions (orlocations ) of objects.\n607 Object Detection and Bounding Boxes\n%matplotlib inline\nimport torch\nfrom d2l import torch asd2l\nWe will load the sample image to be used in this section. We can see that there is a dog\non the left side of the image and a cat on the right. They are the two major objects in this\nimage.\nd2l.set_figsize()\nimg =d2l.plt.imread( '../img/catdog.jpg ')\nd2l.plt.imshow(img);\n14.3.1Bounding Boxes\nIn object detection, we usually use a bounding box to describe the spatial location of an\nobject. The bounding box is rectangular, which is determined by the \ud835\udc65and\ud835\udc66coordinates\nof the upper-left corner of the rectangle and the such coordinates of the lower-right corner.\nAnother commonly used bounding box representation is the \u00b9\ud835\udc65,\ud835\udc66\u00ba-axis coordinates of the\nbounding box center, and the width and height of the box.\nHerewedefinefunctionstoconvertbetweenthesetworepresentations: box_corner_to_center\nconverts from the two-corner representation to the center-width-height presentation, and\nbox_center_to_corner viceversa.", "mimetype": "text/plain", "start_char_idx": 1313367, "end_char_idx": 1317433, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9495b846-9914-4797-8427-651d38d839f4": {"__data__": {"id_": "9495b846-9914-4797-8427-651d38d839f4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ff15a545-95a9-491e-8fbe-1c0f1435a9e5", "node_type": "1", "metadata": {}, "hash": "309747bcaaf20aae4a32abf99b7d3eaed6bbb537a90171c4d23a3b740af62f6f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9d1cf90b-dfaa-421d-8087-62572f888b26", "node_type": "1", "metadata": {}, "hash": "fd029c07c0d31c140e8dcca2cea8de1b9dd12b7d26903318d0795c8c5b41a130", "class_name": "RelatedNodeInfo"}}, "text": "They are the two major objects in this\nimage.\nd2l.set_figsize()\nimg =d2l.plt.imread( '../img/catdog.jpg ')\nd2l.plt.imshow(img);\n14.3.1Bounding Boxes\nIn object detection, we usually use a bounding box to describe the spatial location of an\nobject. The bounding box is rectangular, which is determined by the \ud835\udc65and\ud835\udc66coordinates\nof the upper-left corner of the rectangle and the such coordinates of the lower-right corner.\nAnother commonly used bounding box representation is the \u00b9\ud835\udc65,\ud835\udc66\u00ba-axis coordinates of the\nbounding box center, and the width and height of the box.\nHerewedefinefunctionstoconvertbetweenthesetworepresentations: box_corner_to_center\nconverts from the two-corner representation to the center-width-height presentation, and\nbox_center_to_corner viceversa. Theinputargument boxesshouldbeatwo-dimensional\ntensor of shape ( \ud835\udc5b, 4), where\ud835\udc5bis the number of bounding boxes.\n#@save\ndef box_corner_to_center (boxes):\n\"\"\"Convert from (upper-left, lower-right) to (center, width, height).\"\"\"\nx1, y1, x2, y2 =boxes[:, 0], boxes[:, 1], boxes[:, 2], boxes[:, 3]\ncx=(x1 +x2) /2\ncy=(y1 +y2) /2\nw=x2-x1\nh=y2-y1\nboxes =torch .stack((cx, cy, w, h), axis =-1)\nreturn boxes\n#@save\ndef box_center_to_corner (boxes):\n(continues on next page)\n608 Computer Vision\n(continued from previous page)\n\"\"\"Convert from (center, width, height) to (upper-left, lower-right).\"\"\"\ncx, cy, w, h =boxes[:, 0], boxes[:, 1], boxes[:, 2], boxes[:, 3]\nx1=cx-0.5 *w\ny1=cy-0.5 *h\nx2=cx+0.5 *w\ny2=cy+0.5 *h\nboxes =torch .stack((x1, y1, x2, y2), axis =-1)\nreturn boxes\nWe will define the bounding boxes of the dog and the cat in the image based on the co-\nordinate information. The origin of the coordinates in the image is the upper-left corner\nof the image, and to the right and down are the positive directions of the \ud835\udc65and\ud835\udc66axes,\nrespectively.\n# Here `bbox` is the abbreviation for bounding box\ndog_bbox, cat_bbox =[60.0 ,45.0 ,378.0 ,516.0 ], [ 400.0 ,112.0 ,655.0 ,493.0 ]\nWe can verify the correctness of the two bounding box conversion functions by converting\ntwice.\nboxes =torch .tensor((dog_bbox, cat_bbox))\nbox_center_to_corner(box_corner_to_center(boxes)) ==boxes\ntensor([[ True ,True ,True ,True ],\n[True ,True ,True ,True ]])\nLet\u2019s draw the bounding boxes in the image to check if they are accurate. Before drawing,\nwe will define a helper function bbox_to_rect . It represents the bounding box in the\nbounding box format of the matplotlib package.\n#@save\ndef bbox_to_rect (bbox, color):\n\"\"\"Convert bounding box to matplotlib format.\"\"\"\n# Convert the bounding box (upper-left x, upper-left y, lower-right x,\n# lower-right y) format to the matplotlib format: ((upper-left x,\n# upper-left y), width, height)\nreturn d2l.plt.Rectangle(\nxy=(bbox[ 0], bbox[ 1]), width =bbox[ 2]-bbox[ 0], height =bbox[ 3]-bbox[ 1],\nfill =False , edgecolor =color, linewidth =2)\nAfter adding the bounding boxes on the image, we can see that the main outline of the two\nobjects are basically inside the two boxes.\nfig =d2l.plt.imshow(img)\nfig.axes .add_patch(bbox_to_rect(dog_bbox, 'blue '))\nfig.axes .add_patch(bbox_to_rect(cat_bbox, 'red'));\n609 Anchor Boxes\n21414.3.2Summary\n\u000fObjectdetectionnotonlyrecognizesalltheobjectsofinterestintheimage,butalsotheir\npositions. The position is generally represented by a rectangular bounding box.\n\u000fWe can convert between two commonly used bounding box representations.\n14.3.3Exercises\n1.Find another image and try to label a bounding box that contains the object. Compare\nlabeling bounding boxes and categories: which usually takes longer?", "mimetype": "text/plain", "start_char_idx": 1316667, "end_char_idx": 1320198, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9d1cf90b-dfaa-421d-8087-62572f888b26": {"__data__": {"id_": "9d1cf90b-dfaa-421d-8087-62572f888b26", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9495b846-9914-4797-8427-651d38d839f4", "node_type": "1", "metadata": {}, "hash": "90b81395292c92376aa159d7fcb5df97bb5e952253e437c5030c5ded27f235d4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "71e2e835-a40d-4238-bdd5-3825f506e252", "node_type": "1", "metadata": {}, "hash": "4a20a41a213bcf599f551ef23f629e74d65a3585e271bc9dacb6f8bf620360e7", "class_name": "RelatedNodeInfo"}}, "text": "fig =d2l.plt.imshow(img)\nfig.axes .add_patch(bbox_to_rect(dog_bbox, 'blue '))\nfig.axes .add_patch(bbox_to_rect(cat_bbox, 'red'));\n609 Anchor Boxes\n21414.3.2Summary\n\u000fObjectdetectionnotonlyrecognizesalltheobjectsofinterestintheimage,butalsotheir\npositions. The position is generally represented by a rectangular bounding box.\n\u000fWe can convert between two commonly used bounding box representations.\n14.3.3Exercises\n1.Find another image and try to label a bounding box that contains the object. Compare\nlabeling bounding boxes and categories: which usually takes longer?\n2.Whyistheinnermostdimensionoftheinputargument boxesofbox_corner_to_center\nandbox_center_to_corner always 4?\nDiscussions214.\n14.4AnchorBoxes\nObject detection algorithms usually sample a large number of regions in the input image,\ndetermine whether these regions contain objects of interest, and adjust the boundaries of\ntheregionssoastopredictthe ground-truthboundingboxes oftheobjectsmoreaccurately.\nDifferent models may adopt different region sampling schemes. Here we introduce one of\nsuch methods: it generates multiple bounding boxes with varying scales and aspect ratios\ncentered on each pixel. These bounding boxes are called anchor boxes . We will design an\nobject detection model based on anchor boxes in Section 14.7 .\nFirst, let\u2019s modify the printing accuracy just for more concise outputs.\n%matplotlib inline\nimport torch\nfrom d2l import torch asd2l\ntorch .set_printoptions( 2)# Simplify printing accuracy\n610 Computer Vision\n14.4.1Generating Multiple AnchorBoxes\nSuppose that the input image has a height of \u210eand width of \ud835\udc64. We generate anchor boxes\nwithdifferentshapescenteredoneachpixeloftheimage. Letthe scalebe\ud835\udc602\u00b90,1\u00bcandthe\naspectratio (ratioofwidthtoheight)is \ud835\udc5f >0. Thenthewidthandheightoftheanchorbox\nare\ud835\udc64\ud835\udc60p\ud835\udc5fand\u210e\ud835\udc60\u009dp\ud835\udc5f, respectively. Note that when the center position is given, an anchor\nbox with known width and height is determined.\nTogeneratemultipleanchorboxeswithdifferentshapes,let\u2019ssetaseriesofscales \ud835\udc601,...,\ud835\udc60\ud835\udc5b\nand a series of aspect ratios \ud835\udc5f1,...,\ud835\udc5f\ud835\udc5a. When using all the combinations of these scales\nand aspect ratios with each pixel as the center, the input image will have a total of \ud835\udc64\u210e\ud835\udc5b\ud835\udc5a\nanchorboxes. Althoughtheseanchorboxesmaycoveralltheground-truthboundingboxes,\nthe computational complexity is easily too high. In practice, we can only consider those\ncombinations containing \ud835\udc601or\ud835\udc5f1:\n\u00b9\ud835\udc601,\ud835\udc5f1\u00ba,\u00b9\ud835\udc601,\ud835\udc5f2\u00ba,...,\u00b9\ud835\udc601,\ud835\udc5f\ud835\udc5a\u00ba,\u00b9\ud835\udc602,\ud835\udc5f1\u00ba,\u00b9\ud835\udc603,\ud835\udc5f1\u00ba,...,\u00b9\ud835\udc60\ud835\udc5b,\ud835\udc5f1\u00ba. (14.4.1)\nThat is to say, the number of anchor boxes centered on the same pixel is \ud835\udc5b\u00b8\ud835\udc5a\u00001. For the\nentire input image, we will generate a total of \ud835\udc64\u210e\u00b9\ud835\udc5b\u00b8\ud835\udc5a\u00001\u00baanchor boxes.\nThe above method of generating anchor boxes is implemented in the following multi-\nbox_prior function. Wespecifythe inputimage, alistofscales, and alistofaspect ratios,\nthen this function will return all the anchor boxes.\n#@save\ndef multibox_prior (data, sizes, ratios):\n\"\"\"Generate anchor boxes with different shapes centered on each pixel.\"\"\"\nin_height, in_width =data .shape[ -2:]\ndevice, num_sizes, num_ratios =data .device, len(sizes), len(ratios)\nboxes_per_pixel =(num_sizes +num_ratios -1)\nsize_tensor =torch .tensor(sizes, device =device)\nratio_tensor =torch .tensor(ratios, device =device)\n# Offsets are required to move the anchor to the center of a pixel.", "mimetype": "text/plain", "start_char_idx": 1319632, "end_char_idx": 1322905, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "71e2e835-a40d-4238-bdd5-3825f506e252": {"__data__": {"id_": "71e2e835-a40d-4238-bdd5-3825f506e252", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9d1cf90b-dfaa-421d-8087-62572f888b26", "node_type": "1", "metadata": {}, "hash": "fd029c07c0d31c140e8dcca2cea8de1b9dd12b7d26903318d0795c8c5b41a130", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "57cf0d00-5651-4a1a-833e-77281d3f812f", "node_type": "1", "metadata": {}, "hash": "8d5416927aac2b984cecb0cf2287559a84efd35b7ad5757ac6a9ba3f21e8f10f", "class_name": "RelatedNodeInfo"}}, "text": "For the\nentire input image, we will generate a total of \ud835\udc64\u210e\u00b9\ud835\udc5b\u00b8\ud835\udc5a\u00001\u00baanchor boxes.\nThe above method of generating anchor boxes is implemented in the following multi-\nbox_prior function. Wespecifythe inputimage, alistofscales, and alistofaspect ratios,\nthen this function will return all the anchor boxes.\n#@save\ndef multibox_prior (data, sizes, ratios):\n\"\"\"Generate anchor boxes with different shapes centered on each pixel.\"\"\"\nin_height, in_width =data .shape[ -2:]\ndevice, num_sizes, num_ratios =data .device, len(sizes), len(ratios)\nboxes_per_pixel =(num_sizes +num_ratios -1)\nsize_tensor =torch .tensor(sizes, device =device)\nratio_tensor =torch .tensor(ratios, device =device)\n# Offsets are required to move the anchor to the center of a pixel. Since\n# a pixel has height=1 and width=1, we choose to offset our centers by 0.5\noffset_h, offset_w =0.5,0.5\nsteps_h =1.0 /in_height # Scaled steps in y axis\nsteps_w =1.0 /in_width # Scaled steps in x axis\n# Generate all center points for the anchor boxes\ncenter_h =(torch .arange(in_height, device =device) +offset_h) *steps_h\ncenter_w =(torch .arange(in_width, device =device) +offset_w) *steps_w\nshift_y, shift_x =torch .meshgrid(center_h, center_w, indexing ='ij')\nshift_y, shift_x =shift_y .reshape( -1), shift_x .reshape( -1)\n# Generate `boxes_per_pixel` number of heights and widths that are later\n# used to create anchor box corner coordinates (xmin, xmax, ymin, ymax)\nw=torch .cat((size_tensor *torch .sqrt(ratio_tensor[ 0]),\nsizes[ 0]*torch .sqrt(ratio_tensor[ 1:])))\\\n*in_height /in_width # Handle rectangular inputs\nh=torch .cat((size_tensor /torch .sqrt(ratio_tensor[ 0]),\nsizes[ 0]/torch .sqrt(ratio_tensor[ 1:])))\n# Divide by 2 to get half height and half width\nanchor_manipulations =torch .stack(( -w,-h, w, h)) .T.repeat(\n(continues on next page)\n611 Anchor Boxes\n(continued from previous page)\nin_height *in_width, 1)/2\n# Each center point will have `boxes_per_pixel` number of anchor boxes, so\n# generate a grid of all anchor box centers with `boxes_per_pixel` repeats\nout_grid =torch .stack([shift_x, shift_y, shift_x, shift_y],\ndim=1).repeat_interleave(boxes_per_pixel, dim =0)\noutput =out_grid +anchor_manipulations\nreturn output .unsqueeze( 0)\nWe can see that the shape of the returned anchor box variable Yis (batch size, number of\nanchor boxes, 4).\nimg =d2l.plt.imread( '../img/catdog.jpg ')\nh, w =img.shape[: 2]\nprint (h, w)\nX=torch .rand(size =(1,3, h, w)) # Construct input data\nY=multibox_prior(X, sizes =[0.75 ,0.5,0.25 ], ratios =[1,2,0.5])\nY.shape\n561 728\ntorch .Size([ 1,2042040 ,4])\nAfter changing the shape of the anchor box variable Yto (image height, image width, num-\nber of anchor boxes centered on the same pixel, 4), we can obtain all the anchor boxes\ncentered on a specified pixel position. In the following, we access the first anchor box cen-\nteredon(250,250). Ithasfourelements: the \u00b9\ud835\udc65,\ud835\udc66\u00ba-axiscoordinatesattheupper-leftcorner\nand the\u00b9\ud835\udc65,\ud835\udc66\u00ba-axis coordinates at the lower-right corner of the anchor box. The coordinate\nvalues of both axes are divided by the width and height of the image, respectively.\nboxes =Y.reshape(h, w, 5,4)\nboxes[ 250,250,0, :]\ntensor([ 0.06 ,0.07 ,0.63 ,0.82 ])\nIn order to show all the anchor boxes centered on one pixel in the image, we define the\nfollowing show_bboxes function to draw multiple bounding boxes on the image.\n#@save\ndef show_bboxes (axes, bboxes, labels =None , colors =None ):\n\"\"\"Show bounding boxes.\"\"\"", "mimetype": "text/plain", "start_char_idx": 1322160, "end_char_idx": 1325595, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "57cf0d00-5651-4a1a-833e-77281d3f812f": {"__data__": {"id_": "57cf0d00-5651-4a1a-833e-77281d3f812f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "71e2e835-a40d-4238-bdd5-3825f506e252", "node_type": "1", "metadata": {}, "hash": "4a20a41a213bcf599f551ef23f629e74d65a3585e271bc9dacb6f8bf620360e7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d4169122-5b86-4624-8283-0e7a93f50124", "node_type": "1", "metadata": {}, "hash": "1400e96bfe39306f224ac821f4768cd41900396139ac594ab5587a8444edeec9", "class_name": "RelatedNodeInfo"}}, "text": "In the following, we access the first anchor box cen-\nteredon(250,250). Ithasfourelements: the \u00b9\ud835\udc65,\ud835\udc66\u00ba-axiscoordinatesattheupper-leftcorner\nand the\u00b9\ud835\udc65,\ud835\udc66\u00ba-axis coordinates at the lower-right corner of the anchor box. The coordinate\nvalues of both axes are divided by the width and height of the image, respectively.\nboxes =Y.reshape(h, w, 5,4)\nboxes[ 250,250,0, :]\ntensor([ 0.06 ,0.07 ,0.63 ,0.82 ])\nIn order to show all the anchor boxes centered on one pixel in the image, we define the\nfollowing show_bboxes function to draw multiple bounding boxes on the image.\n#@save\ndef show_bboxes (axes, bboxes, labels =None , colors =None ):\n\"\"\"Show bounding boxes.\"\"\"\ndef make_list (obj, default_values =None ):\nifobj isNone :\nobj =default_values\n(continues on next page)\n612 Computer Vision\n(continued from previous page)\nelif not isinstance (obj, ( list ,tuple )):\nobj =[obj]\nreturn obj\nlabels =make_list(labels)\ncolors =make_list(colors, [ 'b','g','r','m','c'])\nfor i, bbox inenumerate (bboxes):\ncolor =colors[i %len(colors)]\nrect =d2l.bbox_to_rect(bbox .detach() .numpy(), color)\naxes .add_patch(rect)\niflabels and len(labels) >i:\ntext_color ='k'ifcolor =='w'else 'w'\naxes .text(rect .xy[0], rect .xy[1], labels[i],\nva='center ', ha ='center ', fontsize =9, color =text_color,\nbbox =dict (facecolor =color, lw =0))\nAs we just saw, the coordinate values of the \ud835\udc65and\ud835\udc66axes in the variable boxeshave been\ndivided by the width and height of the image, respectively. When drawing anchor boxes,\nwe need to restore their original coordinate values; thus, we define variable bbox_scale\nbelow. Now, we can draw all the anchor boxes centered on (250, 250) in the image. As you\ncan see, the blue anchor box with a scale of 0.75 and an aspect ratio of 1 well surrounds\nthe dog in the image.\nd2l.set_figsize()\nbbox_scale =torch .tensor((w, h, w, h))\nfig =d2l.plt.imshow(img)\nshow_bboxes(fig .axes, boxes[ 250,250, :, :] *bbox_scale,\n['s=0.75, r=1 ','s=0.5, r=1 ','s=0.25, r=1 ','s=0.75, r=2 ',\n's=0.75, r=0.5 '])\n14.4.2IntersectionoverUnion(IoU)\nWejustmentionedthatananchorbox\u201cwell\u201dsurroundsthedogintheimage. Iftheground-\ntruth bounding box of the object is known, how can \u201cwell\u201d here be quantified? Intuitively,\nwe can measure the similarity between the anchor box and the ground-truth bounding box.\nWe know that the Jaccard index can measure the similarity between two sets. Given sets\nAandB, their Jaccard index is the size of their intersection divided by the size of their\n613 Anchor Boxes\nunion:\n\ud835\udc3d\u00b9A,B\u00ba=jA\\Bj\njA[Bj. (14.4.2)\nIn fact, we can consider the pixel area of any bounding box as a set of pixels. In this way,\nwecanmeasurethesimilarityofthetwoboundingboxesbytheJaccardindexoftheirpixel\nsets. For two bounding boxes, we usually refer their Jaccard index as intersection over\nunion(IoU), which is the ratio of their intersection area to their union area, as shown in\nFig. 14.4.1 . The range of an IoU is between 0 and 1: 0 means that two bounding boxes do\nnot overlap at all, while 1 indicates that the two bounding boxes are equal.\ntFig. 14.4.1 IoU is the ratio of the intersection area to the union area of two bounding boxes.\nFortheremainderofthissection,wewilluseIoUtomeasurethesimilaritybetweenanchor\nboxes and ground-truth bounding boxes, and between different anchor boxes. Given two\nlists of anchor or bounding boxes, the following box_iou computes their pairwise IoU\nacross these two lists.\n#@save\ndef box_iou (boxes1, boxes2):\n\"\"\"Compute pairwise IoU across two lists of anchor or bounding boxes.\"\"\"", "mimetype": "text/plain", "start_char_idx": 1324939, "end_char_idx": 1328439, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d4169122-5b86-4624-8283-0e7a93f50124": {"__data__": {"id_": "d4169122-5b86-4624-8283-0e7a93f50124", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "57cf0d00-5651-4a1a-833e-77281d3f812f", "node_type": "1", "metadata": {}, "hash": "8d5416927aac2b984cecb0cf2287559a84efd35b7ad5757ac6a9ba3f21e8f10f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ddeb8977-929d-491a-93b4-eb9dc1001373", "node_type": "1", "metadata": {}, "hash": "8e6e51eeb2d05083a7b749191657627ace825ef4c769176d77e84bf693ed667d", "class_name": "RelatedNodeInfo"}}, "text": "14.4.1 . The range of an IoU is between 0 and 1: 0 means that two bounding boxes do\nnot overlap at all, while 1 indicates that the two bounding boxes are equal.\ntFig. 14.4.1 IoU is the ratio of the intersection area to the union area of two bounding boxes.\nFortheremainderofthissection,wewilluseIoUtomeasurethesimilaritybetweenanchor\nboxes and ground-truth bounding boxes, and between different anchor boxes. Given two\nlists of anchor or bounding boxes, the following box_iou computes their pairwise IoU\nacross these two lists.\n#@save\ndef box_iou (boxes1, boxes2):\n\"\"\"Compute pairwise IoU across two lists of anchor or bounding boxes.\"\"\"\nbox_area =lambda boxes: ((boxes[:, 2]-boxes[:, 0])*\n(boxes[:, 3]-boxes[:, 1]))\n# Shape of `boxes1`, `boxes2`, `areas1`, `areas2`: (no. of boxes1, 4),\n# (no. of boxes2, 4), (no. of boxes1,), (no. of boxes2,)\nareas1 =box_area(boxes1)\nareas2 =box_area(boxes2)\n# Shape of `inter_upperlefts`, `inter_lowerrights`, `inters`: (no. of\n# boxes1, no. of boxes2, 2)\ninter_upperlefts =torch .max(boxes1[:, None , :2], boxes2[:, : 2])\ninter_lowerrights =torch .min(boxes1[:, None ,2:], boxes2[:, 2:])\ninters =(inter_lowerrights -inter_upperlefts) .clamp( min=0)\n# Shape of `inter_areas` and `union_areas`: (no. of boxes1, no. of boxes2)\ninter_areas =inters[:, :, 0]*inters[:, :, 1]\nunion_areas =areas1[:, None ]+areas2 -inter_areas\nreturn inter_areas /union_areas\n14.4.3Labeling AnchorBoxesin TrainingData\nIn a training dataset, we consider each anchor box as a training example. In order to train\nan object detection model, we need classandoffsetlabels for each anchor box, where the\nformer is the class of the object relevant to the anchor box and the latter is the offset of the\nground-truth bounding box relative to the anchor box. During the prediction, for each im-\nage we generate multiple anchor boxes, predict classes and offsets for all the anchor boxes,\n614 Computer Vision\nadjust their positions according to the predicted offsets to obtain the predicted bounding\nboxes, and finally only output those predicted bounding boxes that satisfy certain crite-\nria.\nAsweknow,anobjectdetectiontrainingsetcomeswithlabelsforlocationsof ground-truth\nboundingboxes andclassesoftheirsurroundedobjects. Tolabelanygenerated anchorbox ,\nwe refer to the labeled location and class of its assigned ground-truth bounding box that is\nclosest to the anchor box. In the following, we describe an algorithm for assigning closest\nground-truth bounding boxes to anchor boxes.\nAssigningGround-TruthBounding Boxesto AnchorBoxes\nGiven an image, suppose that the anchor boxes are \ud835\udc341,\ud835\udc342,...,\ud835\udc34\ud835\udc5b\ud835\udc4eand the ground-truth\nbounding boxes are \ud835\udc351,\ud835\udc352,...,\ud835\udc35\ud835\udc5b\ud835\udc4f, where\ud835\udc5b\ud835\udc4e\u0015\ud835\udc5b\ud835\udc4f. Let\u2019s define a matrix X2R\ud835\udc5b\ud835\udc4e\u0002\ud835\udc5b\ud835\udc4f,\nwhose element \ud835\udc65\ud835\udc56\ud835\udc57in the\ud835\udc56throw and\ud835\udc57thcolumn is the IoU of the anchor box \ud835\udc34\ud835\udc56and the\nground-truth bounding box \ud835\udc35\ud835\udc57. The algorithm consists of the following steps:\n1.Find the largest element in matrix Xand denote its row and column indices as \ud835\udc561and\n\ud835\udc571, respectively. Then the ground-truth bounding box \ud835\udc35\ud835\udc571is assigned to the anchor box\n\ud835\udc34\ud835\udc561. This is quite intuitive because \ud835\udc34\ud835\udc561and\ud835\udc35\ud835\udc571are the closest among all the pairs of\nanchor boxes and ground-truth bounding boxes. After the first assignment, discard all\nthe elements in the \ud835\udc561throw and the \ud835\udc571thcolumn in matrix X.\n2.Find the largest of the remaining elements in matrix Xand denote its row and column\nindices as\ud835\udc562and\ud835\udc572, respectively.", "mimetype": "text/plain", "start_char_idx": 1327802, "end_char_idx": 1331181, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ddeb8977-929d-491a-93b4-eb9dc1001373": {"__data__": {"id_": "ddeb8977-929d-491a-93b4-eb9dc1001373", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d4169122-5b86-4624-8283-0e7a93f50124", "node_type": "1", "metadata": {}, "hash": "1400e96bfe39306f224ac821f4768cd41900396139ac594ab5587a8444edeec9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ba498d18-3a2f-4d6a-9e14-2c1ad7ebb655", "node_type": "1", "metadata": {}, "hash": "17cf08175f5d28a9e94d5b2489003d10f73b3ed6458fc30269c1d68b1e8b5625", "class_name": "RelatedNodeInfo"}}, "text": "The algorithm consists of the following steps:\n1.Find the largest element in matrix Xand denote its row and column indices as \ud835\udc561and\n\ud835\udc571, respectively. Then the ground-truth bounding box \ud835\udc35\ud835\udc571is assigned to the anchor box\n\ud835\udc34\ud835\udc561. This is quite intuitive because \ud835\udc34\ud835\udc561and\ud835\udc35\ud835\udc571are the closest among all the pairs of\nanchor boxes and ground-truth bounding boxes. After the first assignment, discard all\nthe elements in the \ud835\udc561throw and the \ud835\udc571thcolumn in matrix X.\n2.Find the largest of the remaining elements in matrix Xand denote its row and column\nindices as\ud835\udc562and\ud835\udc572, respectively. We assign ground-truth bounding box \ud835\udc35\ud835\udc572to anchor\nbox\ud835\udc34\ud835\udc562and discard all the elements in the \ud835\udc562throw and the \ud835\udc572thcolumn in matrix X.\n3.At this point, elements in two rows and two columns in matrix Xhave been discarded.\nWe proceed until all elements in \ud835\udc5b\ud835\udc4fcolumns in matrix Xare discarded. At this time,\nwe have assigned a ground-truth bounding box to each of \ud835\udc5b\ud835\udc4fanchor boxes.\n4.Only traverse through the remaining \ud835\udc5b\ud835\udc4e\u0000\ud835\udc5b\ud835\udc4fanchor boxes. For example, given any\nanchor box\ud835\udc34\ud835\udc56, find the ground-truth bounding box \ud835\udc35\ud835\udc57with the largest IoU with \ud835\udc34\ud835\udc56\nthroughout the \ud835\udc56throw of matrix X, and assign \ud835\udc35\ud835\udc57to\ud835\udc34\ud835\udc56only if this IoU is greater than\na predefined threshold.\nLet\u2019sillustratetheabovealgorithmusingaconcreteexample. Asshownin Fig.14.4.2 (left),\nassumingthatthemaximumvalueinmatrix Xis\ud835\udc6523, weassigntheground-truthbounding\nbox\ud835\udc353totheanchorbox \ud835\udc342. Then,wediscardalltheelementsinrow2andcolumn3ofthe\nmatrix, findthelargest \ud835\udc6571intheremainingelements(shadedarea), andassigntheground-\ntruthboundingbox \ud835\udc351totheanchorbox \ud835\udc347. Next,asshownin Fig.14.4.2 (middle),discard\nall the elements in row 7 and column 1 of the matrix, find the largest \ud835\udc6554in the remaining\nelements (shaded area), and assign the ground-truth bounding box \ud835\udc354to the anchor box\n\ud835\udc345. Finally, as shown in Fig. 14.4.2 (right), discard all the elements in row 5 and column 4\nof the matrix, find the largest \ud835\udc6592in the remaining elements (shaded area), and assign the\nground-truth bounding box \ud835\udc352to the anchor box \ud835\udc349. After that, we only need to traverse\nthrough the remaining anchor boxes \ud835\udc341,\ud835\udc343,\ud835\udc344,\ud835\udc346,\ud835\udc348and determine whether to assign\nthem ground-truth bounding boxes according to the threshold.\n615 Anchor Boxes\ntFig. 14.4.2 Assigning ground-truth bounding boxes to anchor boxes.\nThisalgorithmisimplementedinthefollowing assign_anchor_to_bbox function.\n#@save\ndef assign_anchor_to_bbox (ground_truth, anchors, device, iou_threshold =0.5):\n\"\"\"Assign closest ground-truth bounding boxes to anchor boxes.\"\"\"", "mimetype": "text/plain", "start_char_idx": 1330614, "end_char_idx": 1333118, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ba498d18-3a2f-4d6a-9e14-2c1ad7ebb655": {"__data__": {"id_": "ba498d18-3a2f-4d6a-9e14-2c1ad7ebb655", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ddeb8977-929d-491a-93b4-eb9dc1001373", "node_type": "1", "metadata": {}, "hash": "8e6e51eeb2d05083a7b749191657627ace825ef4c769176d77e84bf693ed667d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b35277f4-aafb-4163-b251-f09441c86327", "node_type": "1", "metadata": {}, "hash": "d9a60c76fe7864c3a4b9f4811bb1343fdbc43b7c80545a6777238a72bbe3f76b", "class_name": "RelatedNodeInfo"}}, "text": "14.4.2 (right), discard all the elements in row 5 and column 4\nof the matrix, find the largest \ud835\udc6592in the remaining elements (shaded area), and assign the\nground-truth bounding box \ud835\udc352to the anchor box \ud835\udc349. After that, we only need to traverse\nthrough the remaining anchor boxes \ud835\udc341,\ud835\udc343,\ud835\udc344,\ud835\udc346,\ud835\udc348and determine whether to assign\nthem ground-truth bounding boxes according to the threshold.\n615 Anchor Boxes\ntFig. 14.4.2 Assigning ground-truth bounding boxes to anchor boxes.\nThisalgorithmisimplementedinthefollowing assign_anchor_to_bbox function.\n#@save\ndef assign_anchor_to_bbox (ground_truth, anchors, device, iou_threshold =0.5):\n\"\"\"Assign closest ground-truth bounding boxes to anchor boxes.\"\"\"\nnum_anchors, num_gt_boxes =anchors .shape[ 0], ground_truth .shape[ 0]\n# Element x_ij in the i-th row and j-th column is the IoU of the anchor\n# box i and the ground-truth bounding box j\njaccard =box_iou(anchors, ground_truth)\n# Initialize the tensor to hold the assigned ground-truth bounding box for\n# each anchor\nanchors_bbox_map =torch .full((num_anchors,), -1, dtype =torch .long,\ndevice =device)\n# Assign ground-truth bounding boxes according to the threshold\nmax_ious, indices =torch .max(jaccard, dim =1)\nanc_i =torch .nonzero(max_ious >=iou_threshold) .reshape( -1)\nbox_j =indices[max_ious >=iou_threshold]\nanchors_bbox_map[anc_i] =box_j\ncol_discard =torch .full((num_anchors,), -1)\nrow_discard =torch .full((num_gt_boxes,), -1)\nfor _inrange (num_gt_boxes):\nmax_idx =torch .argmax(jaccard) # Find the largest IoU\nbox_idx =(max_idx %num_gt_boxes) .long()\nanc_idx =(max_idx /num_gt_boxes) .long()\nanchors_bbox_map[anc_idx] =box_idx\njaccard[:, box_idx] =col_discard\njaccard[anc_idx, :] =row_discard\nreturn anchors_bbox_map\nLabeling Classes and Offsets\nNow we can label the class and offset for each anchor box. Suppose that an anchor box\n\ud835\udc34is assigned a ground-truth bounding box \ud835\udc35. On the one hand, the class of the anchor\nbox\ud835\udc34will be labeled as that of \ud835\udc35. On the other hand, the offset of the anchor box \ud835\udc34will\nbe labeled according to the relative position between the central coordinates of \ud835\udc35and\ud835\udc34\ntogether with the relative size between these two boxes. Given varying positions and sizes\n616 Computer Vision\nof different boxes in the dataset, we can apply transformations to those relative positions\nand sizes that may lead to more uniformly distributed offsets that are easier to fit. Here we\ndescribe a common transformation. Given the central coordinates of \ud835\udc34and\ud835\udc35as\u00b9\ud835\udc65\ud835\udc4e,\ud835\udc66\ud835\udc4e\u00ba\nand\u00b9\ud835\udc65\ud835\udc4f,\ud835\udc66\ud835\udc4f\u00ba, their widths as \ud835\udc64\ud835\udc4eand\ud835\udc64\ud835\udc4f, and their heights as \u210e\ud835\udc4eand\u210e\ud835\udc4f, respectively. We\nmay label the offset of \ud835\udc34as\n \ud835\udc65\ud835\udc4f\u0000\ud835\udc65\ud835\udc4e\n\ud835\udc64\ud835\udc4e\u0000\ud835\udf07\ud835\udc65\n\ud835\udf0e\ud835\udc65,\ud835\udc66\ud835\udc4f\u0000\ud835\udc66\ud835\udc4e\n\u210e\ud835\udc4e\u0000\ud835\udf07\ud835\udc66\n\ud835\udf0e\ud835\udc66,log\ud835\udc64\ud835\udc4f\n\ud835\udc64\ud835\udc4e\u0000\ud835\udf07\ud835\udc64\n\ud835\udf0e\ud835\udc64,log\u210e\ud835\udc4f\n\u210e\ud835\udc4e\u0000\ud835\udf07\u210e\n\ud835\udf0e\u210e!\n, (14.4.3)\nwhere default values of the constants are \ud835\udf07\ud835\udc65=\ud835\udf07\ud835\udc66=\ud835\udf07\ud835\udc64=\ud835\udf07\u210e=0,\ud835\udf0e\ud835\udc65=\ud835\udf0e\ud835\udc66=0.1,\nand\ud835\udf0e\ud835\udc64=\ud835\udf0e\u210e=0.2. This transformation is implemented below in the offset_boxes\nfunction.\n#@save\ndef offset_boxes (anchors, assigned_bb, eps =1e-6 ):\n\"\"\"Transform for anchor box offsets.\"\"\"", "mimetype": "text/plain", "start_char_idx": 1332426, "end_char_idx": 1335338, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b35277f4-aafb-4163-b251-f09441c86327": {"__data__": {"id_": "b35277f4-aafb-4163-b251-f09441c86327", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ba498d18-3a2f-4d6a-9e14-2c1ad7ebb655", "node_type": "1", "metadata": {}, "hash": "17cf08175f5d28a9e94d5b2489003d10f73b3ed6458fc30269c1d68b1e8b5625", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "81663b14-04a6-46e5-9c43-4d479f62bf91", "node_type": "1", "metadata": {}, "hash": "7ead802befdcaf5bf6f2e7dffbfa176c4acaa10476db84cd7b8c9a490bc550a8", "class_name": "RelatedNodeInfo"}}, "text": ", (14.4.3)\nwhere default values of the constants are \ud835\udf07\ud835\udc65=\ud835\udf07\ud835\udc66=\ud835\udf07\ud835\udc64=\ud835\udf07\u210e=0,\ud835\udf0e\ud835\udc65=\ud835\udf0e\ud835\udc66=0.1,\nand\ud835\udf0e\ud835\udc64=\ud835\udf0e\u210e=0.2. This transformation is implemented below in the offset_boxes\nfunction.\n#@save\ndef offset_boxes (anchors, assigned_bb, eps =1e-6 ):\n\"\"\"Transform for anchor box offsets.\"\"\"\nc_anc =d2l.box_corner_to_center(anchors)\nc_assigned_bb =d2l.box_corner_to_center(assigned_bb)\noffset_xy =10*(c_assigned_bb[:, : 2]-c_anc[:, : 2])/c_anc[:, 2:]\noffset_wh =5*torch .log(eps +c_assigned_bb[:, 2:]/c_anc[:, 2:])\noffset =torch .cat([offset_xy, offset_wh], axis =1)\nreturn offset\nIf an anchor box is not assigned a ground-truth bounding box, we just label the class of\nthe anchor box as \u201cbackground\u201d. Anchor boxes whose classes are background are often\nreferred to as negative anchor boxes, and the rest are called positive anchor boxes. We\nimplementthefollowing multibox_target functiontolabelclassesandoffsetsforanchor\nboxes (the anchors argument) using ground-truth bounding boxes (the labelsargument).\nThis function sets the background class to zero and increments the integer index of a new\nclass by one.\n#@save\ndef multibox_target (anchors, labels):\n\"\"\"Label anchor boxes using ground-truth bounding boxes.\"\"\"\nbatch_size, anchors =labels .shape[ 0], anchors .squeeze( 0)\nbatch_offset, batch_mask, batch_class_labels =[], [], []\ndevice, num_anchors =anchors .device, anchors .shape[ 0]\nfor iinrange (batch_size):\nlabel =labels[i, :, :]\nanchors_bbox_map =assign_anchor_to_bbox(\nlabel[:, 1:], anchors, device)\nbbox_mask =((anchors_bbox_map >=0).float() .unsqueeze( -1)).repeat(\n1,4)\n# Initialize class labels and assigned bounding box coordinates with\n# zeros\nclass_labels =torch .zeros(num_anchors, dtype =torch .long,\ndevice =device)\nassigned_bb =torch .zeros((num_anchors, 4), dtype =torch .float32,\ndevice =device)\n# Label classes of anchor boxes using their assigned ground-truth\n# bounding boxes. If an anchor box is not assigned any, we label its\n(continues on next page)\n617 Anchor Boxes\n(continued from previous page)\n# class as background (the value remains zero)\nindices_true =torch .nonzero(anchors_bbox_map >=0)\nbb_idx =anchors_bbox_map[indices_true]\nclass_labels[indices_true] =label[bb_idx, 0].long() +1\nassigned_bb[indices_true] =label[bb_idx, 1:]\n# Offset transformation\noffset =offset_boxes(anchors, assigned_bb) *bbox_mask\nbatch_offset .append(offset .reshape( -1))\nbatch_mask .append(bbox_mask .reshape( -1))\nbatch_class_labels .append(class_labels)\nbbox_offset =torch .stack(batch_offset)\nbbox_mask =torch .stack(batch_mask)\nclass_labels =torch .stack(batch_class_labels)\nreturn (bbox_offset, bbox_mask, class_labels)\nAnExample\nLet\u2019sillustrateanchorboxlabelingviaaconcreteexample. Wedefineground-truthbound-\ning boxes for the dog and cat in the loaded image, where the first element is the class (0\nfor dog and 1 for cat) and the remaining four elements are the \u00b9\ud835\udc65,\ud835\udc66\u00ba-axis coordinates at\nthe upper-left corner and the lower-right corner (range is between 0 and 1). We also con-\nstruct five anchor boxes to be labeled using the coordinates of the upper-left corner and the\nlower-right corner: \ud835\udc340,...,\ud835\udc34 4(the index starts from 0). Then we plot these ground-truth\nbounding boxes and anchor boxes in the image.", "mimetype": "text/plain", "start_char_idx": 1335076, "end_char_idx": 1338278, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "81663b14-04a6-46e5-9c43-4d479f62bf91": {"__data__": {"id_": "81663b14-04a6-46e5-9c43-4d479f62bf91", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b35277f4-aafb-4163-b251-f09441c86327", "node_type": "1", "metadata": {}, "hash": "d9a60c76fe7864c3a4b9f4811bb1343fdbc43b7c80545a6777238a72bbe3f76b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bea6263b-747d-4a7b-8e69-f9fe68c53e9f", "node_type": "1", "metadata": {}, "hash": "06e12d20055368725b22d9c1513af30b305ae05ede8f07c2163ad4ef545ac36e", "class_name": "RelatedNodeInfo"}}, "text": "Wedefineground-truthbound-\ning boxes for the dog and cat in the loaded image, where the first element is the class (0\nfor dog and 1 for cat) and the remaining four elements are the \u00b9\ud835\udc65,\ud835\udc66\u00ba-axis coordinates at\nthe upper-left corner and the lower-right corner (range is between 0 and 1). We also con-\nstruct five anchor boxes to be labeled using the coordinates of the upper-left corner and the\nlower-right corner: \ud835\udc340,...,\ud835\udc34 4(the index starts from 0). Then we plot these ground-truth\nbounding boxes and anchor boxes in the image.\nground_truth =torch .tensor([[ 0,0.1,0.08 ,0.52 ,0.92 ],\n[1,0.55 ,0.2,0.9,0.88 ]])\nanchors =torch .tensor([[ 0,0.1,0.2,0.3], [ 0.15 ,0.2,0.4,0.4],\n[0.63 ,0.05 ,0.88 ,0.98 ], [ 0.66 ,0.45 ,0.8,0.8],\n[0.57 ,0.3,0.92 ,0.9]])\nfig =d2l.plt.imshow(img)\nshow_bboxes(fig .axes, ground_truth[:, 1:]*bbox_scale, [ 'dog','cat'],'k')\nshow_bboxes(fig .axes, anchors *bbox_scale, [ '0','1','2','3','4']);\nUsing the multibox_target function defined above, we can label classes and offsets of\nthese anchor boxes based on the ground-truth bounding boxes for the dog and cat. In this\nexample, indices of the background, dog, and cat classes are 0, 1, and 2, respectively.\n618 Computer Vision\nBelow we add an dimension for examples of anchor boxes and ground-truth bounding\nboxes.\nlabels =multibox_target(anchors .unsqueeze(dim =0),\nground_truth .unsqueeze(dim =0))\nThere are three items in the returned result, all of which are in the tensor format. The third\nitem contains the labeled classes of the input anchor boxes.\nLet\u2019sanalyzethereturnedclasslabelsbelowbasedonanchorboxandground-truthbound-\ning box positions in the image. First, among all the pairs of anchor boxes and ground-truth\nbounding boxes, the IoU of the anchor box \ud835\udc344and the ground-truth bounding box of the\ncat is the largest. Thus, the class of \ud835\udc344is labeled as the cat. Taking out pairs containing\n\ud835\udc344or the ground-truth bounding box of the cat, among the rest the pair of the anchor box\n\ud835\udc341and the ground-truth bounding box of the dog has the largest IoU. So the class of \ud835\udc341is\nlabeledasthedog. Next, weneedtotraversethroughtheremainingthreeunlabeledanchor\nboxes:\ud835\udc340,\ud835\udc342, and\ud835\udc343. For\ud835\udc340, the class of the ground-truth bounding box with the largest\nIoU is the dog, but the IoU is below the predefined threshold (0.5), so the class is labeled\nas background; for \ud835\udc342, the class of the ground-truth bounding box with the largest IoU is\nthe cat and the IoU exceedsthe threshold, so the class is labeled as the cat; for \ud835\udc343, the class\nof the ground-truth bounding box with the largest IoU is the cat, but the value is below the\nthreshold, so the class is labeled as background.\nlabels[ 2]\ntensor([[ 0,1,2,0,2]])\nThesecondreturneditemisamaskvariableoftheshape(batchsize,fourtimesthenumber\nof anchor boxes). Every four elements in the mask variable correspond to the four offset\nvaluesofeachanchorbox. Sincewedonotcareaboutbackgrounddetection,offsetsofthis\nnegative class should not affect the objective function. Through elementwise multiplica-\ntions, zeros in the mask variable will filter out negative class offsets before calculating the\nobjective function.\nlabels[ 1]\ntensor([[ 0.,0.,0.,0.,1.,1.,1.,1.,1.,1.,1.,1.,0.,0.,0.,0.,1.,1.\n\u21a9!,\n1.,1.]])\nThe first returned item contains the four offset values labeled for each anchor box. Note\nthat the offsets of negative-class anchor boxes are labeled as zeros.", "mimetype": "text/plain", "start_char_idx": 1337753, "end_char_idx": 1341123, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bea6263b-747d-4a7b-8e69-f9fe68c53e9f": {"__data__": {"id_": "bea6263b-747d-4a7b-8e69-f9fe68c53e9f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "81663b14-04a6-46e5-9c43-4d479f62bf91", "node_type": "1", "metadata": {}, "hash": "7ead802befdcaf5bf6f2e7dffbfa176c4acaa10476db84cd7b8c9a490bc550a8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "546e0c0e-6877-4a50-a9e0-577e6af9fe13", "node_type": "1", "metadata": {}, "hash": "c96ff92bd985f59009b9383ede3bed686e6f75b2bf49d11aa1cc2ca21c2c6afd", "class_name": "RelatedNodeInfo"}}, "text": "labels[ 2]\ntensor([[ 0,1,2,0,2]])\nThesecondreturneditemisamaskvariableoftheshape(batchsize,fourtimesthenumber\nof anchor boxes). Every four elements in the mask variable correspond to the four offset\nvaluesofeachanchorbox. Sincewedonotcareaboutbackgrounddetection,offsetsofthis\nnegative class should not affect the objective function. Through elementwise multiplica-\ntions, zeros in the mask variable will filter out negative class offsets before calculating the\nobjective function.\nlabels[ 1]\ntensor([[ 0.,0.,0.,0.,1.,1.,1.,1.,1.,1.,1.,1.,0.,0.,0.,0.,1.,1.\n\u21a9!,\n1.,1.]])\nThe first returned item contains the four offset values labeled for each anchor box. Note\nthat the offsets of negative-class anchor boxes are labeled as zeros.\nlabels[ 0]\n619 Anchor Boxes\ntensor([[ -0.00e+00 ,-0.00e+00 ,-0.00e+00 ,-0.00e+00 ,1.40e+00 ,1.00e+01 ,\n2.59e+00 ,7.18e+00 ,-1.20e+00 ,2.69e-01 ,1.68e+00 ,-1.57e+00 ,\n-0.00e+00 ,-0.00e+00 ,-0.00e+00 ,-0.00e+00 ,-5.71e-01 ,-1.00e+00 ,\n4.17e-06 ,6.26e-01 ]])\n14.4.4Predicting Bounding Boxeswith Non-MaximumSuppression\nDuringprediction,wegeneratemultipleanchorboxesfortheimageandpredictclassesand\noffsets for each of them. A predictedboundingbox is thus obtained according to an anchor\nboxwithitspredictedoffset. Belowweimplementthe offset_inverse functionthattakes\nin anchors and offset predictions as inputs and applies inverse offset transformations to\nreturn the predicted bounding box coordinates.\n#@save\ndef offset_inverse (anchors, offset_preds):\n\"\"\"Predict bounding boxes based on anchor boxes with predicted offsets.\"\"\"\nanc =d2l.box_corner_to_center(anchors)\npred_bbox_xy =(offset_preds[:, : 2]*anc[:, 2:]/10)+anc[:, : 2]\npred_bbox_wh =torch .exp(offset_preds[:, 2:]/5)*anc[:, 2:]\npred_bbox =torch .cat((pred_bbox_xy, pred_bbox_wh), axis =1)\npredicted_bbox =d2l.box_center_to_corner(pred_bbox)\nreturn predicted_bbox\nWhentherearemanyanchorboxes,manysimilar(withsignificantoverlap)predictedbound-\ningboxescanbepotentiallyoutputforsurroundingthesameobject. Tosimplifytheoutput,\nwe can merge similar predicted bounding boxes that belong to the same object by using\nnon-maximumsuppression (NMS).\nHereishownon-maximumsuppressionworks. Forapredictedboundingbox \ud835\udc35, theobject\ndetectionmodelcalculatesthepredictedlikelihoodforeachclass. Denotingby \ud835\udc5dthelargest\npredictedlikelihood,theclasscorrespondingtothisprobabilityisthepredictedclassfor \ud835\udc35.\nSpecifically,wereferto \ud835\udc5dastheconfidence (score)ofthepredictedboundingbox \ud835\udc35. Onthe\nsame image, all the predicted non-background bounding boxes are sorted by confidence in\ndescendingordertogeneratealist \ud835\udc3f. Thenwemanipulatethesortedlist \ud835\udc3finthefollowing\nsteps:\n1.Select the predicted bounding box \ud835\udc351with the highest confidence from \ud835\udc3fas a basis and\nremoveallnon-basispredictedboundingboxeswhoseIoUwith \ud835\udc351exceedsapredefined\nthreshold\ud835\udf16from\ud835\udc3f. At this point, \ud835\udc3fkeeps the predicted bounding box with the highest\nconfidence but drops others that are too similar to it. In a nutshell, those with non-\nmaximum confidence scores are suppressed .\n2.Select the predicted bounding box \ud835\udc352with the second highest confidence from \ud835\udc3fas\nanother basis and remove all non-basis predicted bounding boxes whose IoU with \ud835\udc352\nexceeds\ud835\udf16from\ud835\udc3f.\n3.Repeat the above process until all the predicted bounding boxes in \ud835\udc3fhave been used as\n620 Computer Vision\na basis. At this time, the IoU of any pair of predicted bounding boxes in \ud835\udc3fis below the\nthreshold\ud835\udf16; thus, no pair is too similar with each other.\n4.Output all the predicted bounding boxes in the list \ud835\udc3f.\nThe following nmsfunction sorts confidence scores in descending order and returns their\nindices.", "mimetype": "text/plain", "start_char_idx": 1340394, "end_char_idx": 1343980, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "546e0c0e-6877-4a50-a9e0-577e6af9fe13": {"__data__": {"id_": "546e0c0e-6877-4a50-a9e0-577e6af9fe13", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bea6263b-747d-4a7b-8e69-f9fe68c53e9f", "node_type": "1", "metadata": {}, "hash": "06e12d20055368725b22d9c1513af30b305ae05ede8f07c2163ad4ef545ac36e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a13cecf5-a466-4976-a0c7-bb95b78f9a56", "node_type": "1", "metadata": {}, "hash": "cb9be2e0581bafb7ad05dbadbe112c179dc66d9212103001fdd01693413f79fa", "class_name": "RelatedNodeInfo"}}, "text": "At this point, \ud835\udc3fkeeps the predicted bounding box with the highest\nconfidence but drops others that are too similar to it. In a nutshell, those with non-\nmaximum confidence scores are suppressed .\n2.Select the predicted bounding box \ud835\udc352with the second highest confidence from \ud835\udc3fas\nanother basis and remove all non-basis predicted bounding boxes whose IoU with \ud835\udc352\nexceeds\ud835\udf16from\ud835\udc3f.\n3.Repeat the above process until all the predicted bounding boxes in \ud835\udc3fhave been used as\n620 Computer Vision\na basis. At this time, the IoU of any pair of predicted bounding boxes in \ud835\udc3fis below the\nthreshold\ud835\udf16; thus, no pair is too similar with each other.\n4.Output all the predicted bounding boxes in the list \ud835\udc3f.\nThe following nmsfunction sorts confidence scores in descending order and returns their\nindices.\n#@save\ndef nms(boxes, scores, iou_threshold):\n\"\"\"Sort confidence scores of predicted bounding boxes.\"\"\"\nB=torch .argsort(scores, dim =-1, descending =True )\nkeep =[] # Indices of predicted bounding boxes that will be kept\nwhile B.numel() >0:\ni=B[0]\nkeep .append(i)\nifB.numel() ==1:break\niou =box_iou(boxes[i, :] .reshape( -1,4),\nboxes[B[ 1:], :] .reshape( -1,4)).reshape( -1)\ninds =torch .nonzero(iou <=iou_threshold) .reshape( -1)\nB=B[inds +1]\nreturn torch .tensor(keep, device =boxes .device)\nWedefinethefollowing multibox_detection toapplynon-maximumsuppressiontopre-\ndicting bounding boxes. Do not worry if you find the implementation a bit complicated:\nwe will show how it works with a concrete example right after the implementation.\n#@save\ndef multibox_detection (cls_probs, offset_preds, anchors, nms_threshold =0.5,\npos_threshold =0.009999999 ):\n\"\"\"Predict bounding boxes using non-maximum suppression.\"\"\"\ndevice, batch_size =cls_probs .device, cls_probs .shape[ 0]\nanchors =anchors .squeeze( 0)\nnum_classes, num_anchors =cls_probs .shape[ 1], cls_probs .shape[ 2]\nout =[]\nfor iinrange (batch_size):\ncls_prob, offset_pred =cls_probs[i], offset_preds[i] .reshape( -1,4)\nconf, class_id =torch .max(cls_prob[ 1:], 0)\npredicted_bb =offset_inverse(anchors, offset_pred)\nkeep =nms(predicted_bb, conf, nms_threshold)\n# Find all non-`keep` indices and set the class to background\nall_idx =torch .arange(num_anchors, dtype =torch .long, device =device)\ncombined =torch .cat((keep, all_idx))\nuniques, counts =combined .unique(return_counts =True )\nnon_keep =uniques[counts ==1]\nall_id_sorted =torch .cat((keep, non_keep))\nclass_id[non_keep] =-1\nclass_id =class_id[all_id_sorted]\nconf, predicted_bb =conf[all_id_sorted], predicted_bb[all_id_sorted]\n# Here `pos_threshold` is a threshold for positive (non-background)\n# predictions\nbelow_min_idx =(conf <pos_threshold)\nclass_id[below_min_idx] =-1\nconf[below_min_idx] =1-conf[below_min_idx]\n(continues on next page)\n621 Anchor Boxes\n(continued from previous page)\npred_info =torch .cat((class_id .unsqueeze( 1),\nconf .unsqueeze( 1),\npredicted_bb), dim =1)\nout.append(pred_info)\nreturn torch .stack(out)\nNow let\u2019s apply the above implementations to a concrete example with four anchor boxes.\nFor simplicity, we assume that the predicted offsets are all zeros. This means that the\npredicted bounding boxes are anchor boxes. For each class among the background, dog,\nand cat, we also define its predicted likelihood.", "mimetype": "text/plain", "start_char_idx": 1343198, "end_char_idx": 1346440, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a13cecf5-a466-4976-a0c7-bb95b78f9a56": {"__data__": {"id_": "a13cecf5-a466-4976-a0c7-bb95b78f9a56", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "546e0c0e-6877-4a50-a9e0-577e6af9fe13", "node_type": "1", "metadata": {}, "hash": "c96ff92bd985f59009b9383ede3bed686e6f75b2bf49d11aa1cc2ca21c2c6afd", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3fa962bb-5545-4c5e-b344-89d929ce07e4", "node_type": "1", "metadata": {}, "hash": "81b20af001fc1e8bf13feb9969299d73d34c532079f5882a6a9248811a7abcf0", "class_name": "RelatedNodeInfo"}}, "text": "For simplicity, we assume that the predicted offsets are all zeros. This means that the\npredicted bounding boxes are anchor boxes. For each class among the background, dog,\nand cat, we also define its predicted likelihood.\nanchors =torch .tensor([[ 0.1,0.08 ,0.52 ,0.92 ], [ 0.08 ,0.2,0.56 ,0.95 ],\n[0.15 ,0.3,0.62 ,0.91 ], [ 0.55 ,0.2,0.9,0.88 ]])\noffset_preds =torch .tensor([ 0]*anchors .numel())\ncls_probs =torch .tensor([[ 0]*4,# Predicted background likelihood\n[0.9,0.8,0.7,0.1], # Predicted dog likelihood\n[0.1,0.2,0.3,0.9]]) # Predicted cat likelihood\nWe can plot these predicted bounding boxes with their confidence on the image.\nfig =d2l.plt.imshow(img)\nshow_bboxes(fig .axes, anchors *bbox_scale,\n['dog=0.9 ','dog=0.8 ','dog=0.7 ','cat=0.9 '])\nNowwecaninvokethe multibox_detection functiontoperformnon-maximumsuppres-\nsion, where the threshold is set to 0.5. Note that we add a dimension for examples in the\ntensor input.\nWe can see that the shape of the returned result is (batch size, number of anchor boxes,\n6). The six elements in the innermost dimension gives the output information for the same\npredicted bounding box. The first element is the predicted class index, which starts from\n0 (0 is dog and 1 is cat). The value -1 indicates background or removal in non-maximum\nsuppression. The second element is the confidence of the predicted bounding box. The\nremaining four elements are the \u00b9\ud835\udc65,\ud835\udc66\u00ba-axis coordinates of the upper-left corner and the\nlower-right corner of the predicted bounding box, respectively (range is between 0 and\n1).\n622 Computer Vision\noutput =multibox_detection(cls_probs .unsqueeze(dim =0),\noffset_preds .unsqueeze(dim =0),\nanchors .unsqueeze(dim =0),\nnms_threshold =0.5)\noutput\ntensor([[[ 0.00 ,0.90 ,0.10 ,0.08 ,0.52 ,0.92 ],\n[1.00 ,0.90 ,0.55 ,0.20 ,0.90 ,0.88 ],\n[-1.00 ,0.80 ,0.08 ,0.20 ,0.56 ,0.95 ],\n[-1.00 ,0.70 ,0.15 ,0.30 ,0.62 ,0.91 ]]])\nAfterremovingthosepredictedboundingboxesofclass-1,wecanoutputthefinalpredicted\nbounding box kept by non-maximum suppression.\nfig =d2l.plt.imshow(img)\nfor iinoutput[ 0].detach() .numpy():\nifi[0]==-1:\ncontinue\nlabel =('dog= ','cat= ')[int(i[0])] +str(i[1])\nshow_bboxes(fig .axes, [torch .tensor(i[ 2:]) *bbox_scale], label)\nIn practice, we can remove predicted bounding boxes with lower confidence even before\nperforming non-maximum suppression, thereby reducing computation in this algorithm.\nWe may also post-process the output of non-maximum suppression, for example, by only\nkeeping results with higher confidence in the final output.\n14.4.5Summary\n\u000fWe generate anchor boxes with different shapes centered on each pixel of the image.\n\u000fIntersection over union (IoU), also known as Jaccard index, measures the similarity of\ntwo bounding boxes. It is the ratio of their intersection area to their union area.\n\u000fIn a training set, we need two types of labels for each anchor box. One is the class of\nthe object relevant to the anchor box and the other is the offset of the ground-truth\nbounding box relative to the anchor box.\n\u000fDuringprediction,wecanusenon-maximumsuppression(NMS)toremovesimilarpre-\ndicted bounding boxes, thereby simplifying the output.\n623 Multiscale Object Detection\n21514.4.6Exercises\n1.Change values of sizesandratiosin the multibox_prior function. What are the\nchanges to the generated anchor boxes?\n2.Construct and visualize two bounding boxes with an IoU of 0.5. How do they overlap\nwith each other?\n3.Modify the variable anchors inSection 14.4.3 andSection 14.4.4 . How do the results\nchange?", "mimetype": "text/plain", "start_char_idx": 1346218, "end_char_idx": 1349721, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3fa962bb-5545-4c5e-b344-89d929ce07e4": {"__data__": {"id_": "3fa962bb-5545-4c5e-b344-89d929ce07e4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a13cecf5-a466-4976-a0c7-bb95b78f9a56", "node_type": "1", "metadata": {}, "hash": "cb9be2e0581bafb7ad05dbadbe112c179dc66d9212103001fdd01693413f79fa", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3757b948-93a9-4fd0-b2c3-676754f23664", "node_type": "1", "metadata": {}, "hash": "c4809ccaed546479d150d3253252755c3df09f5bc2317a569ccaff1e48b5c585", "class_name": "RelatedNodeInfo"}}, "text": "It is the ratio of their intersection area to their union area.\n\u000fIn a training set, we need two types of labels for each anchor box. One is the class of\nthe object relevant to the anchor box and the other is the offset of the ground-truth\nbounding box relative to the anchor box.\n\u000fDuringprediction,wecanusenon-maximumsuppression(NMS)toremovesimilarpre-\ndicted bounding boxes, thereby simplifying the output.\n623 Multiscale Object Detection\n21514.4.6Exercises\n1.Change values of sizesandratiosin the multibox_prior function. What are the\nchanges to the generated anchor boxes?\n2.Construct and visualize two bounding boxes with an IoU of 0.5. How do they overlap\nwith each other?\n3.Modify the variable anchors inSection 14.4.3 andSection 14.4.4 . How do the results\nchange?\n4.Non-maximum suppression is a greedy algorithm that suppresses predicted bounding\nboxes by removing them. Is it possible that some of these removed ones are actually\nuseful? How can this algorithm be modified to suppress softly? You may refer to Soft-\nNMS (Bodlaetal., 2017).\n5.Rather than being hand-crafted, can non-maximum suppression be learned?\nDiscussions215.\n14.5MultiscaleObject Detection\nInSection 14.4 , we generated multiple anchor boxes centered on each pixel of an input\nimage. Essentially these anchor boxes represent samples of different regions of the image.\nHowever, we may end up with too many anchor boxes to compute if they are generated for\neverypixel. Think of a 561\u0002728input image. If five anchor boxes with varying shapes\nare generated for each pixel as their center, over two million anchor boxes ( 561\u0002728\u00025)\nneed to be labeled and predicted on the image.\n14.5.1Multiscale AnchorBoxes\nYoumayrealizethatitisnotdifficulttoreduceanchorboxesonanimage. Forinstance,we\ncanjustuniformlysampleasmallportionofpixelsfromtheinputimagetogenerateanchor\nboxes centered on them. In addition, at different scales we can generate different numbers\nof anchor boxes of different sizes. Intuitively, smaller objects are more likely to appear on\nan image than larger ones. As an example, 1\u00021,1\u00022, and 2\u00022objects can appear on a\n2\u00022imagein4,2,and1possibleways,respectively. Therefore,whenusingsmalleranchor\nboxes to detect smaller objects, we can sample more regions, while for larger objects we\ncan sample fewer regions.\nTo demonstrate how to generate anchor boxes at multiple scales, let\u2019s read an image. Its\nheight and width are 561 and 728 pixels, respectively.\n%matplotlib inline\nimport torch\n(continues on next page)\n624 Computer Vision\n(continued from previous page)\nfrom d2l import torch asd2l\nimg =d2l.plt.imread( '../img/catdog.jpg ')\nh, w =img.shape[: 2]\nh, w\n(561,728)\nRecall that in Section 7.2 we call a two-dimensional array output of a convolutional layer\na feature map. By defining the feature map shape, we can determine centers of uniformly\nsampled anchor boxes on any image.\nThedisplay_anchors functionisdefinedbelow. Wegenerateanchorboxes( anchors )on\nthe feature map ( fmap) with each unit (pixel) as the anchor box center. Since the \u00b9\ud835\udc65,\ud835\udc66\u00ba-\naxis coordinate values in the anchor boxes ( anchors ) have been divided by the width and\nheight of the feature map ( fmap), these values are between 0 and 1, which indicate the\nrelative positions of anchor boxes in the feature map.\nSince centers of the anchor boxes ( anchors ) are spread over all units on the feature map\n(fmap), these centers must be uniformly distributed on any input image in terms of their\nrelative spatial positions. More concretely, given the width and height of the feature map\nfmap_wandfmap_h, respectively, the following function will uniformly sample pixels in\nfmap_hrows and fmap_wcolumns on any input image. Centered on these uniformly sam-\npled pixels, anchor boxes of scale s(assuming the length of the list sis 1) and different\naspect ratios ( ratios) will be generated.", "mimetype": "text/plain", "start_char_idx": 1348950, "end_char_idx": 1352794, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3757b948-93a9-4fd0-b2c3-676754f23664": {"__data__": {"id_": "3757b948-93a9-4fd0-b2c3-676754f23664", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3fa962bb-5545-4c5e-b344-89d929ce07e4", "node_type": "1", "metadata": {}, "hash": "81b20af001fc1e8bf13feb9969299d73d34c532079f5882a6a9248811a7abcf0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c7bb4ec6-4f38-4ac2-8a6c-b3d742e0ff75", "node_type": "1", "metadata": {}, "hash": "b3c2baf8b10b68dd3ec579c54403b851f29b1336318186b0f96210e39047787a", "class_name": "RelatedNodeInfo"}}, "text": "Since the \u00b9\ud835\udc65,\ud835\udc66\u00ba-\naxis coordinate values in the anchor boxes ( anchors ) have been divided by the width and\nheight of the feature map ( fmap), these values are between 0 and 1, which indicate the\nrelative positions of anchor boxes in the feature map.\nSince centers of the anchor boxes ( anchors ) are spread over all units on the feature map\n(fmap), these centers must be uniformly distributed on any input image in terms of their\nrelative spatial positions. More concretely, given the width and height of the feature map\nfmap_wandfmap_h, respectively, the following function will uniformly sample pixels in\nfmap_hrows and fmap_wcolumns on any input image. Centered on these uniformly sam-\npled pixels, anchor boxes of scale s(assuming the length of the list sis 1) and different\naspect ratios ( ratios) will be generated.\ndef display_anchors (fmap_w, fmap_h, s):\nd2l.set_figsize()\n# Values on the first two dimensions do not affect the output\nfmap =torch .zeros(( 1,10, fmap_h, fmap_w))\nanchors =d2l.multibox_prior(fmap, sizes =s, ratios =[1,2,0.5])\nbbox_scale =torch .tensor((w, h, w, h))\nd2l.show_bboxes(d2l .plt.imshow(img) .axes,\nanchors[ 0]*bbox_scale)\nFirst, let\u2019s consider detection of small objects. In order to make it easier to distinguish\nwhen displayed, the anchor boxes with different centers here do not overlap: the anchor\nbox scale is set to 0.15 and the height and width of the feature map are set to 4. We can see\nthat the centers of the anchor boxes in 4 rows and 4 columns on the image are uniformly\ndistributed.\ndisplay_anchors(fmap_w =4, fmap_h =4, s=[0.15 ])\nWemoveontoreducetheheightandwidthofthefeaturemapbyhalfanduselargeranchor\nboxes to detect larger objects. When the scale is set to 0.4, some anchor boxes will overlap\nwith each other.\n625 Multiscale Object Detection\ndisplay_anchors(fmap_w =2, fmap_h =2, s=[0.4])\nFinally, we further reduce the height and width of the feature map by half and increase the\nanchorboxscaleto0.8. Nowthecenteroftheanchorboxisthecenteroftheimage.\ndisplay_anchors(fmap_w =1, fmap_h =1, s=[0.8])\n14.5.2Multiscale Detection\nSince we have generated multiscale anchor boxes, we will use them to detect objects of\nvarious sizes at different scales. In the following we introduce a CNN-based multiscale\nobject detection method that we will implement in Section 14.7 .\nAtsomescale,saythatwehave \ud835\udc50featuremapsofshape \u210e\u0002\ud835\udc64. Usingthemethodin Section\n14.5.1, we generate \u210e\ud835\udc64sets of anchor boxes, where each set has \ud835\udc4eanchor boxes with the\nsame center. For example, at the first scale in the experiments in Section 14.5.1 , given ten\n626 Computer Vision\n(numberofchannels) 4\u00024featuremaps, wegenerated16setsofanchorboxes, whereeach\nset contains 3 anchor boxes with the same center. Next, each anchor box is labeled with\nthe class and offset based on ground-truth bounding boxes. At the current scale, the object\ndetection model needs to predict the classes and offsets of \u210e\ud835\udc64sets of anchor boxes on the\ninput image, where different sets have different centers.\nAssume that the \ud835\udc50featuremaps here are the intermediate outputs obtained bythe CNN for-\nward propagation based on the input image. Since there are \u210e\ud835\udc64different spatial positions\non each feature map, the same spatial position can be thought of as having \ud835\udc50units. Ac-\ncording to the definition of receptive field in Section 7.2 , these\ud835\udc50units at the same spatial\nposition of the feature maps have the same receptive field on the input image: they repre-\nsent the input image information in the same receptive field. Therefore, we can transform\nthe\ud835\udc50unitsofthefeaturemapsatthesamespatialpositionintotheclassesandoffsetsofthe\n\ud835\udc4eanchor boxes generated using this spatial position. In essence, we use the information of\nthe input image in a certain receptive field to predict the classes and offsets of the anchor\nboxes that are close to that receptive field on the input image.", "mimetype": "text/plain", "start_char_idx": 1351973, "end_char_idx": 1355840, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c7bb4ec6-4f38-4ac2-8a6c-b3d742e0ff75": {"__data__": {"id_": "c7bb4ec6-4f38-4ac2-8a6c-b3d742e0ff75", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3757b948-93a9-4fd0-b2c3-676754f23664", "node_type": "1", "metadata": {}, "hash": "c4809ccaed546479d150d3253252755c3df09f5bc2317a569ccaff1e48b5c585", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9ffb9523-808d-45b5-be30-0fcd56148e7b", "node_type": "1", "metadata": {}, "hash": "d336072bf4da397531151d7a85cc1654ea6bdf2ba27b957fb1ffac80c91566f8", "class_name": "RelatedNodeInfo"}}, "text": "Assume that the \ud835\udc50featuremaps here are the intermediate outputs obtained bythe CNN for-\nward propagation based on the input image. Since there are \u210e\ud835\udc64different spatial positions\non each feature map, the same spatial position can be thought of as having \ud835\udc50units. Ac-\ncording to the definition of receptive field in Section 7.2 , these\ud835\udc50units at the same spatial\nposition of the feature maps have the same receptive field on the input image: they repre-\nsent the input image information in the same receptive field. Therefore, we can transform\nthe\ud835\udc50unitsofthefeaturemapsatthesamespatialpositionintotheclassesandoffsetsofthe\n\ud835\udc4eanchor boxes generated using this spatial position. In essence, we use the information of\nthe input image in a certain receptive field to predict the classes and offsets of the anchor\nboxes that are close to that receptive field on the input image.\nWhen the feature maps at different layers have varying-size receptive fields on the input\nimage, they can be used to detect objects of different sizes. For example, we can design a\nneural network where units of feature maps that are closer to the output layer have wider\nreceptive fields, so they can detect larger objects from the input image.\nInanutshell,wecanleveragelayerwiserepresentationsofimagesatmultiplelevelsbydeep\nneural networks for multiscale object detection. We will show how this works through a\nconcrete example in Section 14.7 .\n14.5.3Summary\n\u000fAt multiple scales, we can generate anchor boxes with different sizes to detect objects\nwith different sizes.\n\u000fBy defining the shape of feature maps, we can determine centers of uniformly sampled\nanchor boxes on any image.\n\u000fWeusetheinformationoftheinputimageinacertainreceptivefieldtopredicttheclasses\nandoffsetsoftheanchorboxesthatareclosetothatreceptivefieldontheinputimage.\n\u000fThrough deep learning, we can leverage its layerwise representations of images at mul-\ntiple levels for multiscale object detection.\n14.5.4Exercises\n1.According to our discussions in Section 8.1 , deep neural networks learn hierarchical\nfeatures with increasing levels of abstraction for images. In multiscale object detection,\ndo featuremaps at different scales correspond to different levels of abstraction? Whyor\nwhy not?\n2.At the first scale ( fmap_w=4, fmap_h=4 ) in the experiments in Section 14.5.1 , generate\nuniformly distributed anchor boxes that may overlap.\n627 The Object Detection Dataset\n2163.Given a feature map variable with shape 1\u0002\ud835\udc50\u0002\u210e\u0002\ud835\udc64, where\ud835\udc50,\u210e, and\ud835\udc64are the\nnumber of channels, height, and width of the feature maps, respectively. How can you\ntransform this variable into the classes and offsets of anchor boxes? What is the shape\nof the output?\nDiscussions216.\n14.6The Object DetectionDataset\nThere is no small dataset such as MNIST and Fashion-MNIST in the field of object detec-\ntion. In order to quickly demonstrate object detection models, we collected and labeled a\nsmall dataset. First, we took photos of free bananas from our office and generated 1000\nbanana images with different rotations and sizes. Then we placed each banana image at a\nrandom position on some background image. In the end, we labeled bounding boxes for\nthose bananas on the images.\n14.6.1Downloadingthe Dataset\nThe banana detection dataset with all the image and csv label files can be downloaded\ndirectly from the Internet.\n%matplotlib inline\nimport os\nimport pandas aspd\nimport torch\nimport torchvision\nfrom d2l import torch asd2l\n#@save\nd2l.DATA_HUB[ 'banana-detection ']=(\nd2l.DATA_URL +'banana-detection.zip ',\n'5de26c8fce5ccdea9f91267273464dc968d20d72 ')\n14.6.2Readingthe Dataset\nWe are going to read the banana detection dataset in the read_data_bananas function\nbelow. The dataset includes a csv file for object class labels and ground-truth bounding\nbox coordinates at the upper-left and lower-right corners.\n#@save\ndef read_data_bananas (is_train =True ):\n\"\"\"Read the banana detection dataset images and labels.\"\"\"", "mimetype": "text/plain", "start_char_idx": 1354974, "end_char_idx": 1358905, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9ffb9523-808d-45b5-be30-0fcd56148e7b": {"__data__": {"id_": "9ffb9523-808d-45b5-be30-0fcd56148e7b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c7bb4ec6-4f38-4ac2-8a6c-b3d742e0ff75", "node_type": "1", "metadata": {}, "hash": "b3c2baf8b10b68dd3ec579c54403b851f29b1336318186b0f96210e39047787a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "683129e2-08b9-4b10-84ba-2eb021a15378", "node_type": "1", "metadata": {}, "hash": "3425b963312c23dd0ce0b95d37e184e39e68e7732aad01af04927daf5fcad9bc", "class_name": "RelatedNodeInfo"}}, "text": "14.6.1Downloadingthe Dataset\nThe banana detection dataset with all the image and csv label files can be downloaded\ndirectly from the Internet.\n%matplotlib inline\nimport os\nimport pandas aspd\nimport torch\nimport torchvision\nfrom d2l import torch asd2l\n#@save\nd2l.DATA_HUB[ 'banana-detection ']=(\nd2l.DATA_URL +'banana-detection.zip ',\n'5de26c8fce5ccdea9f91267273464dc968d20d72 ')\n14.6.2Readingthe Dataset\nWe are going to read the banana detection dataset in the read_data_bananas function\nbelow. The dataset includes a csv file for object class labels and ground-truth bounding\nbox coordinates at the upper-left and lower-right corners.\n#@save\ndef read_data_bananas (is_train =True ):\n\"\"\"Read the banana detection dataset images and labels.\"\"\"\ndata_dir =d2l.download_extract( 'banana-detection ')\ncsv_fname =os.path .join(data_dir, 'bananas_train 'ifis_train\n(continues on next page)\n628 Computer Vision\n(continued from previous page)\nelse 'bananas_val ','label.csv ')\ncsv_data =pd.read_csv(csv_fname)\ncsv_data =csv_data .set_index( 'img_name ')\nimages, targets =[], []\nfor img_name, target incsv_data .iterrows():\nimages .append(torchvision .io.read_image(\nos.path .join(data_dir, 'bananas_train 'ifis_train else\n'bananas_val ','images ',f'{img_name }')))\n# Here `target` contains (class, upper-left x, upper-left y,\n# lower-right x, lower-right y), where all the images have the same\n# banana class (index 0)\ntargets .append( list (target))\nreturn images, torch .tensor(targets) .unsqueeze( 1)/256\nBy using the read_data_bananas function to read images and labels, the following Ba-\nnanasDataset class will allow us to create a customized Dataset instance for loading the\nbanana detection dataset.\n#@save\nclass BananasDataset (torch .utils .data .Dataset):\n\"\"\"A customized dataset to load the banana detection dataset.\"\"\"\ndef __init__ (self , is_train):\nself .features, self .labels =read_data_bananas(is_train)\nprint ('read '+str(len(self .features)) +(f'training examples 'if\nis_train else f'validation examples '))\ndef __getitem__ (self , idx):\nreturn (self .features[idx] .float(), self .labels[idx])\ndef __len__ (self ):\nreturn len(self .features)\nFinally, we define the load_data_bananas function to return two data iterator instances\nfor both the training and test sets. For the test dataset, there is no need to read it in random\norder.\n#@save\ndef load_data_bananas (batch_size):\n\"\"\"Load the banana detection dataset.\"\"\"\ntrain_iter =torch .utils .data .DataLoader(BananasDataset(is_train =True ),\nbatch_size, shuffle =True )\nval_iter =torch .utils .data .DataLoader(BananasDataset(is_train =False ),\nbatch_size)\nreturn train_iter, val_iter\nLet\u2019s read a minibatch and print the shapes of both images and labels in this minibatch.\nThe shape of the image minibatch, (batch size, number of channels, height, width), looks\nfamiliar: it is the same as in our earlier image classification tasks. The shape of the label\nminibatch is (batch size, \ud835\udc5a, 5), where\ud835\udc5ais the largest possible number of bounding boxes\nthat any image has in the dataset.\n629 The Object Detection Dataset\nAlthough computation in minibatches is more efficient, it requires that all the image exam-\nples contain the same number of bounding boxes to form a minibatch via concatenation.\nIn general, images may have a varying number of bounding boxes; thus, images with fewer\nthan\ud835\udc5aboundingboxeswillbepaddedwithillegalboundingboxesuntil \ud835\udc5aisreached. Then\nthe label of each bounding box is represented by an array of length 5. The first element in\nthearrayistheclassoftheobjectintheboundingbox, where-1indicatesanillegalbound-\ning box for padding. The remaining four elements of the array are the ( \ud835\udc65,\ud835\udc66)-coordinate\nvalues of the upper-left corner and the lower-right corner of the bounding box (the range\nis between 0 and 1). For the banana dataset, since there is only one bounding box on each\nimage, we have \ud835\udc5a=1.", "mimetype": "text/plain", "start_char_idx": 1358163, "end_char_idx": 1362041, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "683129e2-08b9-4b10-84ba-2eb021a15378": {"__data__": {"id_": "683129e2-08b9-4b10-84ba-2eb021a15378", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9ffb9523-808d-45b5-be30-0fcd56148e7b", "node_type": "1", "metadata": {}, "hash": "d336072bf4da397531151d7a85cc1654ea6bdf2ba27b957fb1ffac80c91566f8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "210b47bc-7094-4519-a2f7-6278801c87c0", "node_type": "1", "metadata": {}, "hash": "adbfe749ccc907199e75f65c91304c336e272b966ddd695c9e0b4a2075c81adb", "class_name": "RelatedNodeInfo"}}, "text": "In general, images may have a varying number of bounding boxes; thus, images with fewer\nthan\ud835\udc5aboundingboxeswillbepaddedwithillegalboundingboxesuntil \ud835\udc5aisreached. Then\nthe label of each bounding box is represented by an array of length 5. The first element in\nthearrayistheclassoftheobjectintheboundingbox, where-1indicatesanillegalbound-\ning box for padding. The remaining four elements of the array are the ( \ud835\udc65,\ud835\udc66)-coordinate\nvalues of the upper-left corner and the lower-right corner of the bounding box (the range\nis between 0 and 1). For the banana dataset, since there is only one bounding box on each\nimage, we have \ud835\udc5a=1.\nbatch_size, edge_size =32,256\ntrain_iter, _ =load_data_bananas(batch_size)\nbatch =next (iter (train_iter))\nbatch[ 0].shape, batch[ 1].shape\nDownloading ../data /banana -detection .zip from http ://d2l-data .s3-accelerate .\n\u21a9!amazonaws .com/banana -detection .zip...\nread 1000 training examples\nread 100 validation examples\n(torch .Size([ 32,3,256,256]), torch .Size([ 32,1,5]))\n14.6.3Demonstration\nLet\u2019s demonstrate ten images with their labeled ground-truth bounding boxes. We can see\nthat the rotations, sizes, and positions of bananas vary across all these images. Of course,\nthisisjustasimpleartificialdataset. Inpractice,real-worlddatasetsareusuallymuchmore\ncomplicated.\nimgs =(batch[ 0][:10].permute( 0,2,3,1))/255\naxes =d2l.show_images(imgs, 2,5, scale =2)\nfor ax, label inzip(axes, batch[ 1][:10]):\nd2l.show_bboxes(ax, [label[ 0][1:5]*edge_size], colors =['w'])\n14.6.4Summary\n\u000fThe banana detection dataset we collected can be used to demonstrate object detection\nmodels.\n\u000fThedataloadingforobjectdetectionissimilartothatforimageclassification. However,\ninobjectdetectionthelabelsalsocontaininformationofground-truthboundingboxes,\nwhich is missing in image classification.\n14.6.5Exercises\n630 Computer Vision\n2171.Demonstrate other images with ground-truth bounding boxes in the banana detection\ndataset. How do they differ with respect to bounding boxes and objects?\n2.Saythatwewanttoapplydataaugmentation, suchasrandomcropping, toobjectdetec-\ntion. How can it be different from that in image classification? Hint: what if a cropped\nimage only contains a small portion of an object?\nDiscussions217.\n14.7SingleShotMultiboxDetection\nInSection 14.3 \u2013Section 14.6 , we introduced bounding boxes, anchor boxes, multiscale\nobject detection, and the dataset for object detection. Now we are ready to use such back-\nground knowledge to design an object detection model: single shot multibox detection\n(SSD) (Liuet al., 2016). This model is simple, fast, and widely used. Although this is\njust one of vast amounts of object detection models, some of the design principles and\nimplementation details in this section are also applicable to other models.\n14.7.1Model\nFig. 14.7.1 provides an overview of the design of single-shot multibox detection. This\nmodelmainlyconsistsofabasenetworkfollowedbyseveralmultiscalefeaturemapblocks.\nThebasenetworkisforextractingfeaturesfromtheinputimage, soitcanuseadeepCNN.\nForexample,theoriginalsingle-shotmultiboxdetectionpaperadoptsaVGGnetworktrun-\ncatedbeforetheclassificationlayer( Liuetal.,2016),whileResNethasalsobeencommonly\nused. Through our design we can make the base network output larger feature maps so as\ntogeneratemoreanchorboxesfordetectingsmallerobjects. Subsequently,eachmultiscale\nfeature map block reduces (e.g., by half) the height and width of the feature maps from the\nprevious block, and enables each unit of the feature maps to increase its receptive field on\nthe input image.\n631 Single Shot Multibox Detection\nRecallthedesignofmultiscaleobjectdetectionthroughlayerwiserepresentationsofimages\nby deep neural networks in Section 14.5 . Since multiscale feature maps closer to the top of\nFig.", "mimetype": "text/plain", "start_char_idx": 1361418, "end_char_idx": 1365188, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "210b47bc-7094-4519-a2f7-6278801c87c0": {"__data__": {"id_": "210b47bc-7094-4519-a2f7-6278801c87c0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "683129e2-08b9-4b10-84ba-2eb021a15378", "node_type": "1", "metadata": {}, "hash": "3425b963312c23dd0ce0b95d37e184e39e68e7732aad01af04927daf5fcad9bc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "40017e6a-f269-45d2-80ca-66a430022027", "node_type": "1", "metadata": {}, "hash": "dfa863c7eb60aa3a1a3e9007f816a90ca3fca70940dbca0ca130c88bd90e3372", "class_name": "RelatedNodeInfo"}}, "text": "Forexample,theoriginalsingle-shotmultiboxdetectionpaperadoptsaVGGnetworktrun-\ncatedbeforetheclassificationlayer( Liuetal.,2016),whileResNethasalsobeencommonly\nused. Through our design we can make the base network output larger feature maps so as\ntogeneratemoreanchorboxesfordetectingsmallerobjects. Subsequently,eachmultiscale\nfeature map block reduces (e.g., by half) the height and width of the feature maps from the\nprevious block, and enables each unit of the feature maps to increase its receptive field on\nthe input image.\n631 Single Shot Multibox Detection\nRecallthedesignofmultiscaleobjectdetectionthroughlayerwiserepresentationsofimages\nby deep neural networks in Section 14.5 . Since multiscale feature maps closer to the top of\nFig. 14.7.1 are smaller but have larger receptive fields, they are suitable for detecting fewer\nbut larger objects.\nIn a nutshell, via its base network and several multiscale feature map blocks, single-shot\nmultibox detection generates a varying number of anchor boxes with different sizes, and\ndetects varying-size objects by predicting classes and offsets of these anchor boxes (thus\nthe bounding boxes); thus, this is a multiscale object detection model.\ntFig. 14.7.1 As a multiscale object detection model, single-shot multibox detection mainly consists of\na base network followed by several multiscale feature map blocks.\nIn the following, we will describe the implementation details of different blocks in Fig.\n14.7.1. To begin with, we discuss how to implement the class and bounding box predic-\ntion.\nClassPrediction Layer\nLetthenumberofobjectclassesbe \ud835\udc5e. Thenanchorboxeshave \ud835\udc5e\u00b81classes,whereclass0is\nbackground. Atsomescale, supposethattheheightandwidthoffeaturemapsare \u210eand\ud835\udc64,\nrespectively. When \ud835\udc4eanchorboxesaregeneratedwitheachspatialpositionofthesefeature\nmaps as their center, a total of \u210e\ud835\udc64\ud835\udc4eanchor boxes need to be classified. This often makes\nclassification with fully connected layers infeasible due to likely heavy parametrization\ncosts. Recall how we used channels of convolutional layers to predict classes in Section\n8.3. Single-shot multibox detection uses the same technique to reduce model complex-\nity.\nSpecifically, the class prediction layer uses a convolutional layer without altering width\nor height of feature maps. In this way, there can be a one-to-one correspondence between\noutputsandinputsatthesamespatialdimensions(widthandheight)offeaturemaps. More\nconcretely, channelsof the output feature maps at anyspatial position ( \ud835\udc65,\ud835\udc66) represent class\npredictionsforalltheanchorboxescenteredon( \ud835\udc65,\ud835\udc66)oftheinputfeaturemaps. Toproduce\nvalidpredictions,theremustbe \ud835\udc4e\u00b9\ud835\udc5e\u00b81\u00baoutputchannels,whereforthesamespatialposition\n632 Computer Vision\ntheoutputchannelwithindex \ud835\udc56\u00b9\ud835\udc5e\u00b81\u00ba\u00b8\ud835\udc57representsthepredictionoftheclass \ud835\udc57(0\u0014\ud835\udc57\u0014\ud835\udc5e)\nfor the anchor box \ud835\udc56(0\u0014\ud835\udc56 <\ud835\udc4e).\nBelowwedefinesuchaclasspredictionlayer,specifying \ud835\udc4eand\ud835\udc5eviaarguments num_anchors\nandnum_classes , respectively. This layer uses a 3\u00023convolutional layer with a padding\nof 1. The width and height of the input and output of this convolutional layer remain un-\nchanged.\n%matplotlib inline\nimport torch\nimport torchvision\nfrom torch import nn\nfrom torch .nnimport functional asF\nfrom d2l import torch asd2l\ndef cls_predictor (num_inputs, num_anchors, num_classes):\nreturn nn.Conv2d(num_inputs, num_anchors *(num_classes +1),\nkernel_size =3, padding =1)\nBoundingBoxPredictionLayer\nThe design of the bounding box prediction layer is similar to that of the class prediction\nlayer. The only difference lies in the number of outputs for each anchor box: here we need\nto predict four offsets rather than \ud835\udc5e\u00b81classes.\ndef bbox_predictor (num_inputs, num_anchors):\nreturn nn.Conv2d(num_inputs, num_anchors *4, kernel_size =3, padding =1)\nConcatenating PredictionsforMultiple Scales\nAs we mentioned, single-shot multibox detection uses multiscale feature maps to generate\nanchor boxes and predict their classes and offsets.", "mimetype": "text/plain", "start_char_idx": 1364445, "end_char_idx": 1368356, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "40017e6a-f269-45d2-80ca-66a430022027": {"__data__": {"id_": "40017e6a-f269-45d2-80ca-66a430022027", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "210b47bc-7094-4519-a2f7-6278801c87c0", "node_type": "1", "metadata": {}, "hash": "adbfe749ccc907199e75f65c91304c336e272b966ddd695c9e0b4a2075c81adb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "33c66e75-86b4-4636-97ba-3268898e44d9", "node_type": "1", "metadata": {}, "hash": "6c455f2102c2f5d9b41e41caf62b0b433de181d3e4326762a88338e1278b8670", "class_name": "RelatedNodeInfo"}}, "text": "The only difference lies in the number of outputs for each anchor box: here we need\nto predict four offsets rather than \ud835\udc5e\u00b81classes.\ndef bbox_predictor (num_inputs, num_anchors):\nreturn nn.Conv2d(num_inputs, num_anchors *4, kernel_size =3, padding =1)\nConcatenating PredictionsforMultiple Scales\nAs we mentioned, single-shot multibox detection uses multiscale feature maps to generate\nanchor boxes and predict their classes and offsets. At different scales, the shapes of feature\nmapsorthenumbersofanchorboxescenteredonthesameunitmayvary. Therefore,shapes\nof the prediction outputs at different scales may vary.\nIn the following example, we construct feature maps at two different scales, Y1andY2, for\nthe same minibatch, where the height and width of Y2are half of those of Y1. Let\u2019s take\nclass prediction as an example. Suppose that 5 and 3 anchor boxes are generated for every\nunit in Y1andY2, respectively. Suppose further that the number of object classes is 10.\nFor feature maps Y1andY2the numbers of channels in the class prediction outputs are\n5\u0002\u00b910\u00b81\u00ba=55and3\u0002\u00b910\u00b81\u00ba=33, respectively, where either output shape is (batch\nsize, number of channels, height, width).\ndef forward (x, block):\nreturn block(x)\n(continues on next page)\n633 Single Shot Multibox Detection\n(continued from previous page)\nY1=forward(torch .zeros(( 2,8,20,20)), cls_predictor( 8,5,10))\nY2=forward(torch .zeros(( 2,16,10,10)), cls_predictor( 16,3,10))\nY1.shape, Y2 .shape\n(torch .Size([ 2,55,20,20]), torch .Size([ 2,33,10,10]))\nAs we can see, except for the batch size dimension, the other three dimensions all have\ndifferentsizes. Toconcatenatethesetwopredictionoutputsformoreefficientcomputation,\nwe will transform these tensors into a more consistent format.\nNotethatthechanneldimensionholdsthepredictionsforanchorboxeswiththesamecenter.\nWe first move this dimension to the innermost. Since the batch size remains the same for\ndifferent scales, we can transform the prediction output into a two-dimensional tensor with\nshape (batch size, height \u0002width\u0002number of channels). Then we can concatenate such\noutputs at different scales along dimension 1.\ndef flatten_pred (pred):\nreturn torch .flatten(pred .permute( 0,2,3,1), start_dim =1)\ndef concat_preds (preds):\nreturn torch .cat([flatten_pred(p) for pinpreds], dim =1)\nIn this way, even though Y1andY2have different sizes in channels, heights, and widths,\nwe can still concatenate these two prediction outputs at two different scales for the same\nminibatch.\nconcat_preds([Y1, Y2]) .shape\ntorch .Size([ 2,25300 ])\nDownsamplingBlock\nIn order to detect objects at multiple scales, we define the following downsampling block\ndown_sample_blk thathalvestheheightandwidthofinputfeaturemaps. Infact,thisblock\napplies the design of VGG blocks in Section 8.2.1 . More concretely, each downsampling\nblock consists of two 3\u00023convolutional layers with padding of 1 followed by a 2\u00022max-\npooling layer with stride of 2. As we know, 3\u00023convolutional layers with padding of 1 do\nnot change the shape of feature maps. However, the subsequent 2\u00022max-pooling reduces\nthe height and width of input feature maps by half. For both input and output feature maps\nof this downsampling block, because 1\u00022\u00b8\u00b93\u00001\u00ba\u00b8\u00b9 3\u00001\u00ba=6, each unit in the output\nhas a 6\u00026receptive field on the input. Therefore, the downsampling block enlarges the\nreceptive field of each unit in its output feature maps.", "mimetype": "text/plain", "start_char_idx": 1367921, "end_char_idx": 1371313, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "33c66e75-86b4-4636-97ba-3268898e44d9": {"__data__": {"id_": "33c66e75-86b4-4636-97ba-3268898e44d9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "40017e6a-f269-45d2-80ca-66a430022027", "node_type": "1", "metadata": {}, "hash": "dfa863c7eb60aa3a1a3e9007f816a90ca3fca70940dbca0ca130c88bd90e3372", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8ca962dc-dedd-4e3f-a8c0-c8d389e84298", "node_type": "1", "metadata": {}, "hash": "8cb776e571e4e6fdab2cb8c46a30b7a840069e0e3315fff540ac0a6eb8896a2d", "class_name": "RelatedNodeInfo"}}, "text": "More concretely, each downsampling\nblock consists of two 3\u00023convolutional layers with padding of 1 followed by a 2\u00022max-\npooling layer with stride of 2. As we know, 3\u00023convolutional layers with padding of 1 do\nnot change the shape of feature maps. However, the subsequent 2\u00022max-pooling reduces\nthe height and width of input feature maps by half. For both input and output feature maps\nof this downsampling block, because 1\u00022\u00b8\u00b93\u00001\u00ba\u00b8\u00b9 3\u00001\u00ba=6, each unit in the output\nhas a 6\u00026receptive field on the input. Therefore, the downsampling block enlarges the\nreceptive field of each unit in its output feature maps.\n634 Computer Vision\ndef down_sample_blk (in_channels, out_channels):\nblk =[]\nfor _inrange (2):\nblk.append(nn .Conv2d(in_channels, out_channels,\nkernel_size =3, padding =1))\nblk.append(nn .BatchNorm2d(out_channels))\nblk.append(nn .ReLU())\nin_channels =out_channels\nblk.append(nn .MaxPool2d( 2))\nreturn nn.Sequential( *blk)\nInthefollowingexample,ourconstructeddownsamplingblockchangesthenumberofinput\nchannels and halves the height and width of the input feature maps.\nforward(torch .zeros(( 2,3,20,20)), down_sample_blk( 3,10)).shape\ntorch .Size([ 2,10,10,10])\nBaseNetworkBlock\nThe base network block is used to extract features from input images. For simplicity, we\nconstruct a small base network consisting of three downsampling blocks that double the\nnumber of channels at each block. Given a 256\u0002256input image, this base network block\noutputs 32\u000232feature maps ( 256\u009d23=32).\ndef base_net ():\nblk =[]\nnum_filters =[3,16,32,64]\nfor iinrange (len(num_filters) -1):\nblk.append(down_sample_blk(num_filters[i], num_filters[i +1]))\nreturn nn.Sequential( *blk)\nforward(torch .zeros(( 2,3,256,256)), base_net()) .shape\ntorch .Size([ 2,64,32,32])\nTheCompleteModel\nThe complete single shot multibox detection model consists of five blocks. The feature\nmapsproducedbyeachblockareusedforboth(i)generatinganchorboxesand(ii)predict-\ning classes and offsets of these anchor boxes. Among these five blocks, the first one is the\nbase network block, the second to the fourth are downsampling blocks, and the last block\nuses global max-pooling to reduce both the height and width to 1. Technically, the second\nto the fifth blocks are all those multiscale feature map blocks in Fig. 14.7.1 .\n635 Single Shot Multibox Detection\ndef get_blk (i):\nifi==0:\nblk =base_net()\nelif i==1:\nblk =down_sample_blk( 64,128)\nelif i==4:\nblk =nn.AdaptiveMaxPool2d(( 1,1))\nelse :\nblk =down_sample_blk( 128,128)\nreturn blk\nNow we define the forward propagation for each block. Different from in image classifica-\ntion tasks, outputs here include (i) CNN feature maps Y, (ii) anchor boxes generated using\nYat the current scale, and (iii) classes and offsets predicted (based on Y) for these anchor\nboxes.\ndef blk_forward (X, blk, size, ratio, cls_predictor, bbox_predictor):\nY=blk(X)\nanchors =d2l.multibox_prior(Y, sizes =size, ratios =ratio)\ncls_preds =cls_predictor(Y)\nbbox_preds =bbox_predictor(Y)\nreturn (Y, anchors, cls_preds, bbox_preds)\nRecall that in Fig. 14.7.1 a multiscale feature map block that is closer to the top is for\ndetectinglargerobjects;thus,itneedstogeneratelargeranchorboxes. Intheaboveforward\npropagation,ateachmultiscalefeaturemapblockwepassinalistoftwoscalevaluesviathe\nsizesargument of the invoked multibox_prior function (described in Section 14.4 ). In\nthefollowing,theintervalbetween0.2and1.05issplitevenlyintofivesectionstodetermine\nthe smaller scale values at the five blocks: 0.2, 0.37, 0.54, 0.71, and 0.88.", "mimetype": "text/plain", "start_char_idx": 1370705, "end_char_idx": 1374217, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8ca962dc-dedd-4e3f-a8c0-c8d389e84298": {"__data__": {"id_": "8ca962dc-dedd-4e3f-a8c0-c8d389e84298", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "33c66e75-86b4-4636-97ba-3268898e44d9", "node_type": "1", "metadata": {}, "hash": "6c455f2102c2f5d9b41e41caf62b0b433de181d3e4326762a88338e1278b8670", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a1d0213e-d38f-4b4a-aea1-9aa41277b3c1", "node_type": "1", "metadata": {}, "hash": "590632c2d06cc3c6e095a06000be88dd685a7f97e3ca8d45618368c5c5e8b285", "class_name": "RelatedNodeInfo"}}, "text": "14.7.1 a multiscale feature map block that is closer to the top is for\ndetectinglargerobjects;thus,itneedstogeneratelargeranchorboxes. Intheaboveforward\npropagation,ateachmultiscalefeaturemapblockwepassinalistoftwoscalevaluesviathe\nsizesargument of the invoked multibox_prior function (described in Section 14.4 ). In\nthefollowing,theintervalbetween0.2and1.05issplitevenlyintofivesectionstodetermine\nthe smaller scale values at the five blocks: 0.2, 0.37, 0.54, 0.71, and 0.88. Then their larger\nscale values are given byp\n0.2\u00020.37=0.272,p\n0.37\u00020.54=0.447, and so on.\nsizes =[[0.2,0.272 ], [ 0.37 ,0.447 ], [ 0.54 ,0.619 ], [ 0.71 ,0.79 ],\n[0.88 ,0.961 ]]\nratios =[[1,2,0.5]]*5\nnum_anchors =len(sizes[ 0])+len(ratios[ 0])-1\nNow we can define the complete model TinySSD as follows.\nclass TinySSD (nn.Module):\ndef __init__ (self , num_classes, **kwargs):\nsuper (TinySSD, self ).__init__ (**kwargs)\nself .num_classes =num_classes\nidx_to_in_channels =[64,128,128,128,128]\nfor iinrange (5):\n# Equivalent to the assignment statement `self.blk_i = get_blk(i)`\nsetattr (self ,f'blk_ {i}', get_blk(i))\nsetattr (self ,f'cls_ {i}', cls_predictor(idx_to_in_channels[i],\nnum_anchors, num_classes))\nsetattr (self ,f'bbox_ {i}', bbox_predictor(idx_to_in_channels[i],\nnum_anchors))\n(continues on next page)\n636 Computer Vision\n(continued from previous page)\ndef forward (self , X):\nanchors, cls_preds, bbox_preds =[None ]*5, [None ]*5, [None ]*5\nfor iinrange (5):\n# Here `getattr(self, 'blk_%d' % i)` accesses `self.blk_i`\nX, anchors[i], cls_preds[i], bbox_preds[i] =blk_forward(\nX,getattr (self ,f'blk_ {i}'), sizes[i], ratios[i],\ngetattr (self ,f'cls_ {i}'),getattr (self ,f'bbox_ {i}'))\nanchors =torch .cat(anchors, dim =1)\ncls_preds =concat_preds(cls_preds)\ncls_preds =cls_preds .reshape(\ncls_preds .shape[ 0],-1,self .num_classes +1)\nbbox_preds =concat_preds(bbox_preds)\nreturn anchors, cls_preds, bbox_preds\nWe create a model instance and use it to perform forward propagation on a minibatch of\n256\u0002256images X.\nAsshownearlierinthissection,thefirstblockoutputs 32\u000232featuremaps. Recallthatthe\nsecond to fourth downsampling blocks halve the height and width and the fifth block uses\nglobal pooling. Since 4 anchor boxes are generated for each unit along spatial dimensions\nof feature maps, at all the five scales a total of \u00b9322\u00b8162\u00b882\u00b842\u00b81\u00ba\u00024=5444anchor\nboxes are generated for each image.\nnet =TinySSD(num_classes =1)\nX=torch .zeros(( 32,3,256,256))\nanchors, cls_preds, bbox_preds =net(X)\nprint ('output anchors: ', anchors .shape)\nprint ('output class preds: ', cls_preds .shape)\nprint ('output bbox preds: ', bbox_preds .shape)\noutput anchors: torch .Size([ 1,5444 ,4])\noutput class preds : torch .Size([ 32,5444 ,2])\noutput bbox preds: torch .Size([ 32,21776 ])\n14.7.2Training\nNow we will explain how to train the single shot multibox detection model for object de-\ntection.\nReadingthe Datasetand Initializing the Model\nTo begin with, let\u2019s read the banana detection dataset described in Section 14.6 .\nbatch_size =32\ntrain_iter, _ =d2l.load_data_bananas(batch_size)\n637 Single Shot Multibox Detection\nread 1000 training examples\nread 100 validation examples\nThere is only one class in the banana detection dataset. After defining the model, we need\nto initialize its parameters and define the optimization algorithm.", "mimetype": "text/plain", "start_char_idx": 1373740, "end_char_idx": 1377051, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a1d0213e-d38f-4b4a-aea1-9aa41277b3c1": {"__data__": {"id_": "a1d0213e-d38f-4b4a-aea1-9aa41277b3c1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8ca962dc-dedd-4e3f-a8c0-c8d389e84298", "node_type": "1", "metadata": {}, "hash": "8cb776e571e4e6fdab2cb8c46a30b7a840069e0e3315fff540ac0a6eb8896a2d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9dc4dd20-e23a-49f8-b57b-97c4a8ff19cb", "node_type": "1", "metadata": {}, "hash": "0959e3290a19336f524866eb546dec82b1863819bc03a80e2f5e6ac53d5bf98c", "class_name": "RelatedNodeInfo"}}, "text": "Readingthe Datasetand Initializing the Model\nTo begin with, let\u2019s read the banana detection dataset described in Section 14.6 .\nbatch_size =32\ntrain_iter, _ =d2l.load_data_bananas(batch_size)\n637 Single Shot Multibox Detection\nread 1000 training examples\nread 100 validation examples\nThere is only one class in the banana detection dataset. After defining the model, we need\nto initialize its parameters and define the optimization algorithm.\ndevice, net =d2l.try_gpu(), TinySSD(num_classes =1)\ntrainer =torch .optim .SGD(net .parameters(), lr =0.2, weight_decay =5e-4 )\nDefiningLoss and EvaluationFunctions\nObject detection has two types of losses. The first loss concerns classes of anchor boxes:\nits computation can simply reuse the cross-entropy loss function that we used for image\nclassification. Thesecondlossconcernsoffsetsofpositive(non-background)anchorboxes:\nthis is a regression problem. For this regression problem, however, here we do not use the\nsquared loss described in Section 3.1.3 . Instead, we use the \u21131norm loss, the absolute\nvalue of the difference between the prediction and the ground-truth. The mask variable\nbbox_masks filters out negative anchor boxes and illegal (padded) anchor boxes in the loss\ncalculation. In the end, we sum up the anchor box class loss and the anchor box offset loss\nto obtain the loss function for the model.\ncls_loss =nn.CrossEntropyLoss(reduction ='none ')\nbbox_loss =nn.L1Loss(reduction ='none ')\ndef calc_loss (cls_preds, cls_labels, bbox_preds, bbox_labels, bbox_masks):\nbatch_size, num_classes =cls_preds .shape[ 0], cls_preds .shape[ 2]\ncls =cls_loss(cls_preds .reshape( -1, num_classes),\ncls_labels .reshape( -1)).reshape(batch_size, -1).mean(dim =1)\nbbox =bbox_loss(bbox_preds *bbox_masks,\nbbox_labels *bbox_masks) .mean(dim =1)\nreturn cls +bbox\nWe can use accuracy to evaluate the classification results. Due to the used \u21131norm loss\nfor the offsets, we use the mean absolute error to evaluate the predicted bounding boxes.\nThese prediction results are obtained from the generated anchor boxes and the predicted\noffsets for them.\ndef cls_eval (cls_preds, cls_labels):\n# Because the class prediction results are on the final dimension,\n# `argmax` needs to specify this dimension\nreturn float ((cls_preds .argmax(dim =-1).type(\ncls_labels .dtype) ==cls_labels) .sum())\ndef bbox_eval (bbox_preds, bbox_labels, bbox_masks):\nreturn float ((torch .abs((bbox_labels -bbox_preds) *bbox_masks)) .sum())\n638 Computer Vision\nTrainingthe Model\nWhen training the model, we need to generate multiscale anchor boxes ( anchors ) and pre-\ndict their classes ( cls_preds ) and offsets ( bbox_preds ) in the forward propagation. Then\nwe label the classes ( cls_labels ) and offsets ( bbox_labels ) of such generated anchor\nboxes based on the label information Y. Finally, we calculate the loss function using the\npredicted and labeled values of the classes and offsets. For concise implementations, eval-\nuation of the test dataset is omitted here.\nnum_epochs, timer =20, d2l .Timer()\nanimator =d2l.Animator(xlabel ='epoch ', xlim =[1, num_epochs],\nlegend =['class error ','bbox mae '])\nnet =net.to(device)\nfor epoch inrange (num_epochs):\n# Sum of training accuracy, no. of examples in sum of training accuracy,\n# Sum of absolute error, no.", "mimetype": "text/plain", "start_char_idx": 1376609, "end_char_idx": 1379892, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9dc4dd20-e23a-49f8-b57b-97c4a8ff19cb": {"__data__": {"id_": "9dc4dd20-e23a-49f8-b57b-97c4a8ff19cb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a1d0213e-d38f-4b4a-aea1-9aa41277b3c1", "node_type": "1", "metadata": {}, "hash": "590632c2d06cc3c6e095a06000be88dd685a7f97e3ca8d45618368c5c5e8b285", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "643dbdfd-6cfe-4ed0-a892-780a3b985eb7", "node_type": "1", "metadata": {}, "hash": "55b8701856c5afbcd1fb54db267d7c053ae417953a110392c662ac08cff3d3d2", "class_name": "RelatedNodeInfo"}}, "text": "Then\nwe label the classes ( cls_labels ) and offsets ( bbox_labels ) of such generated anchor\nboxes based on the label information Y. Finally, we calculate the loss function using the\npredicted and labeled values of the classes and offsets. For concise implementations, eval-\nuation of the test dataset is omitted here.\nnum_epochs, timer =20, d2l .Timer()\nanimator =d2l.Animator(xlabel ='epoch ', xlim =[1, num_epochs],\nlegend =['class error ','bbox mae '])\nnet =net.to(device)\nfor epoch inrange (num_epochs):\n# Sum of training accuracy, no. of examples in sum of training accuracy,\n# Sum of absolute error, no. of examples in sum of absolute error\nmetric =d2l.Accumulator( 4)\nnet.train()\nfor features, target intrain_iter:\ntimer .start()\ntrainer .zero_grad()\nX, Y =features .to(device), target .to(device)\n# Generate multiscale anchor boxes and predict their classes and\n# offsets\nanchors, cls_preds, bbox_preds =net(X)\n# Label the classes and offsets of these anchor boxes\nbbox_labels, bbox_masks, cls_labels =d2l.multibox_target(anchors, Y)\n# Calculate the loss function using the predicted and labeled values\n# of the classes and offsets\nl=calc_loss(cls_preds, cls_labels, bbox_preds, bbox_labels,\nbbox_masks)\nl.mean() .backward()\ntrainer .step()\nmetric .add(cls_eval(cls_preds, cls_labels), cls_labels .numel(),\nbbox_eval(bbox_preds, bbox_labels, bbox_masks),\nbbox_labels .numel())\ncls_err, bbox_mae =1-metric[ 0]/metric[ 1], metric[ 2]/metric[ 3]\nanimator .add(epoch +1, (cls_err, bbox_mae))\nprint (f'class err {cls_err :.2e}, bbox mae {bbox_mae :.2e}')\nprint (f'{len(train_iter .dataset) /timer .stop() :.1f}examples/sec on '\nf'{str(device) }')\nclass err 3.27e-03 , bbox mae 3.08e-03\n4279.7 examples /sec on cuda: 0\n14.7.3Prediction\nDuring prediction, the goal is to detect all the objects of interest on the image. Below we\nread and resize a test image, converting it to a four-dimensional tensor that is required by\nconvolutional layers.\n639 Single Shot Multibox Detection\nX=torchvision .io.read_image( '../img/banana.jpg ').unsqueeze( 0).float()\nimg =X.squeeze( 0).permute( 1,2,0).long()\nUsingthe multibox_detection functionbelow,thepredictedboundingboxesareobtained\nfromtheanchorboxesandtheirpredictedoffsets. Thennon-maximumsuppressionisused\nto remove similar predicted bounding boxes.\ndef predict (X):\nnet.eval()\nanchors, cls_preds, bbox_preds =net(X .to(device))\ncls_probs =F.softmax(cls_preds, dim =2).permute( 0,2,1)\noutput =d2l.multibox_detection(cls_probs, bbox_preds, anchors)\nidx =[ifor i, row inenumerate (output[ 0])ifrow[ 0]!=-1]\nreturn output[ 0, idx]\noutput =predict(X)\nFinally, we display all the predicted bounding boxes with confidence 0.9 or above as out-\nput.\ndef display (img, output, threshold):\nd2l.set_figsize(( 5,5))\nfig =d2l.plt.imshow(img)\nfor row inoutput:\nscore =float (row[ 1])\nifscore <threshold:\ncontinue\nh, w =img.shape[: 2]\nbbox =[row[ 2:6]*torch .tensor((w, h, w, h), device =row.device)]\nd2l.show_bboxes(fig .axes, bbox, '%.2f '%score, 'w')\ndisplay(img, output .cpu(), threshold =0.9)\n14.7.4Summary\n\u000fSingle shot multibox detection is a multiscale object detection model. Via its base net-\nwork and several multiscale feature map blocks, single-shot multibox detection gen-\nerates a varying number of anchor boxes with different sizes, and detects varying-size\n640 Computer Vision\nobjects by predicting classes and offsets of these anchor boxes (thus the bounding\nboxes).\n\u000fWhen training the single-shot multibox detection model, the loss function is calculated\nbased on the predicted and labeled values of the anchor box classes and offsets.\n14.7.5Exercises\n1.Canyouimprovethesingle-shotmultiboxdetectionbyimprovingthelossfunction?", "mimetype": "text/plain", "start_char_idx": 1379281, "end_char_idx": 1382957, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "643dbdfd-6cfe-4ed0-a892-780a3b985eb7": {"__data__": {"id_": "643dbdfd-6cfe-4ed0-a892-780a3b985eb7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9dc4dd20-e23a-49f8-b57b-97c4a8ff19cb", "node_type": "1", "metadata": {}, "hash": "0959e3290a19336f524866eb546dec82b1863819bc03a80e2f5e6ac53d5bf98c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3cd98c10-1fd6-46eb-a3e1-72d52c1814f3", "node_type": "1", "metadata": {}, "hash": "9671ce6258aca68c0cb9c13bc4dcbbf7d91e86e163aacd5716377600a051eace", "class_name": "RelatedNodeInfo"}}, "text": "Via its base net-\nwork and several multiscale feature map blocks, single-shot multibox detection gen-\nerates a varying number of anchor boxes with different sizes, and detects varying-size\n640 Computer Vision\nobjects by predicting classes and offsets of these anchor boxes (thus the bounding\nboxes).\n\u000fWhen training the single-shot multibox detection model, the loss function is calculated\nbased on the predicted and labeled values of the anchor box classes and offsets.\n14.7.5Exercises\n1.Canyouimprovethesingle-shotmultiboxdetectionbyimprovingthelossfunction? For\nexample, replace \u21131norm loss with smooth \u21131norm loss for the predicted offsets. This\nloss function uses a square function around zero for smoothness, which is controlled by\nthe hyperparameter \ud835\udf0e:\n\ud835\udc53\u00b9\ud835\udc65\u00ba=(\n\u00b9\ud835\udf0e\ud835\udc65\u00ba2\u009d2,ifj\ud835\udc65j<1\u009d\ud835\udf0e2\nj\ud835\udc65j\u00000.5\u009d\ud835\udf0e2,otherwise(14.7.1)\nWhen\ud835\udf0eis very large, this loss is similar to the \u21131norm loss. When its value is smaller, the\nloss function is smoother.\ndef smooth_l1 (data, scalar):\nout =[]\nfor iindata:\nifabs(i) <1/(scalar **2):\nout.append(((scalar *i)**2)/2)\nelse :\nout.append( abs(i) -0.5 /(scalar **2))\nreturn torch .tensor(out)\nsigmas =[10,1,0.5]\nlines =['-','--','-.']\nx=torch .arange( -2,2,0.1)\nd2l.set_figsize()\n(continues on next page)\n641 Single Shot Multibox Detection\n(continued from previous page)\nfor l, s inzip(lines, sigmas):\ny=smooth_l1(x, scalar =s)\nd2l.plt.plot(x, y, l, label ='sigma= %.1f '%s)\nd2l.plt.legend();\nBesides, in the experiment we used cross-entropy loss for class prediction: denoting by \ud835\udc5d\ud835\udc57\nthepredictedprobabilityfortheground-truthclass \ud835\udc57,thecross-entropylossis \u0000log\ud835\udc5d\ud835\udc57. We\ncan also use the focal loss ( Linet al., 2017): given hyperparameters \ud835\udefe > 0and\ud835\udefc> 0, this\nloss is defined as:\n\u0000\ud835\udefc\u00b91\u0000\ud835\udc5d\ud835\udc57\u00ba\ud835\udefelog\ud835\udc5d\ud835\udc57. (14.7.2)\nAs we can see, increasing \ud835\udefecan effectively reduce the relative loss for well-classified ex-\namples (e.g., \ud835\udc5d\ud835\udc57>0.5) so the training can focus more on those difficult examples that are\nmisclassified.\ndef focal_loss (gamma, x):\nreturn -(1-x)**gamma *torch .log(x)\nx=torch .arange( 0.01 ,1,0.01 )\nfor l, gamma inzip(lines, [ 0,1,5]):\ny=d2l.plt.plot(x, focal_loss(gamma, x), l, label ='gamma= %.1f '%gamma)\nd2l.plt.legend();\n2.Due to space limitations, we have omitted some implementation details of the single\nshotmultiboxdetectionmodelinthissection. Canyoufurtherimprovethemodelinthe\nfollowing aspects:\n642 Computer Vision\n2181.When an object is much smaller compared with the image, the model could resize\nthe input image bigger.\n2.There are typically a vast number of negative anchor boxes. To make the class dis-\ntribution more balanced, we could downsample negative anchor boxes.\n3.Inthelossfunction,assigndifferentweighthyperparameterstotheclasslossandthe\noffset loss.\n4.Useothermethodstoevaluatetheobjectdetectionmodel, suchasthoseinthesingle\nshot multibox detection paper ( Liuetal., 2016).\nDiscussions218.\n14.8Region-basedCNNs (R-CNNs)\nBesides single shot multibox detection described in Section 14.7 , region-based CNNs or\nregions with CNN features (R-CNNs) are also among many pioneering approaches of ap-\nplying deep learning to object detection ( Girshick et al., 2014). In this section, we will\nintroducetheR-CNNanditsseriesofimprovements: thefastR-CNN( Girshick,2015 ),the\nfaster R-CNN ( Renet al., 2015), and the mask R-CNN ( Heet al., 2017).", "mimetype": "text/plain", "start_char_idx": 1382398, "end_char_idx": 1385672, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3cd98c10-1fd6-46eb-a3e1-72d52c1814f3": {"__data__": {"id_": "3cd98c10-1fd6-46eb-a3e1-72d52c1814f3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "643dbdfd-6cfe-4ed0-a892-780a3b985eb7", "node_type": "1", "metadata": {}, "hash": "55b8701856c5afbcd1fb54db267d7c053ae417953a110392c662ac08cff3d3d2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e904659e-e60c-4692-a9ae-9d4e71b927a1", "node_type": "1", "metadata": {}, "hash": "ac6d8516768bd738206f39f78d5d380bd432d34948bf3f0ba1aad96806f00236", "class_name": "RelatedNodeInfo"}}, "text": "4.Useothermethodstoevaluatetheobjectdetectionmodel, suchasthoseinthesingle\nshot multibox detection paper ( Liuetal., 2016).\nDiscussions218.\n14.8Region-basedCNNs (R-CNNs)\nBesides single shot multibox detection described in Section 14.7 , region-based CNNs or\nregions with CNN features (R-CNNs) are also among many pioneering approaches of ap-\nplying deep learning to object detection ( Girshick et al., 2014). In this section, we will\nintroducetheR-CNNanditsseriesofimprovements: thefastR-CNN( Girshick,2015 ),the\nfaster R-CNN ( Renet al., 2015), and the mask R-CNN ( Heet al., 2017). Due to limited\nspace, we will only focus on the design of these models.\n14.8.1R-CNNs\nTheR-CNNfirstextractsmany(e.g.,2000) regionproposals fromtheinputimage(e.g.,an-\nchorboxescanalsobeconsideredasregionproposals),labelingtheirclassesandbounding\nboxes (e.g., offsets).\n(Girshicketal., 2014)\nThen a CNN is used to perform forward propagation on each region proposal to extract\nits features. Next, features of each region proposal are used for predicting the class and\nbounding box of this region proposal.\ntFig. 14.8.1 The R-CNN model.\nFig.14.8.1 showstheR-CNNmodel. Moreconcretely,theR-CNNconsistsofthefollowing\nfour steps:\n643 Region-based CNNs (R-CNNs)\n1.Performselective search to extract multiple high-quality region proposals on the input\nimage (Uijlingset al., 2013). These proposed regions are usually selected at multiple\nscales with different shapes and sizes. Each region proposal will be labeled with a class\nand a ground-truth bounding box.\n2.Choose a pretrained CNN and truncate it before the output layer. Resize each region\nproposal to the input size required by the network, and output the extracted features for\nthe region proposal through forward propagation.\n3.Take the extracted features and labeled class of each region proposal as an example.\nTrain multiple support vector machines to classify objects, where each support vector\nmachine individually determines whether the example contains a specific class.\n4.Take the extracted features and labeled bounding box of each region proposal as an\nexample. Train a linear regression model to predict the ground-truth bounding box.\nAlthough the R-CNN model uses pretrained CNNs to effectively extract image features, it\nis slow. Imagine that we select thousands of region proposals from a single input image:\nthis requires thousands of CNN forward propagations to perform object detection. This\nmassive computing load makes it infeasible to widely use R-CNNs in real-world applica-\ntions.\n14.8.2FastR-CNN\nThemainperformancebottleneckofanR-CNNliesintheindependentCNNforwardprop-\nagationforeachregionproposal,withoutsharingcomputation. Sincetheseregionsusually\nhave overlaps, independent feature extractions lead to much repeated computation. One\nof the major improvements of the fast R-CNN from the R-CNN is that the CNN forward\npropagation is only performed on the entire image ( Girshick, 2015 ).\ntFig. 14.8.2 The fast R-CNN model.\nFig.14.8.2 describesthefastR-CNNmodel. Itsmajorcomputationsareasfollows:\n1.Compared with the R-CNN, in the fast R-CNN the input of the CNN for feature extrac-\ntion is the entire image, rather than individual region proposals. Moreover, this CNN is\ntrainable. Given an input image, let the shape of the CNN output be 1\u0002\ud835\udc50\u0002\u210e1\u0002\ud835\udc641.\n644 Computer Vision\n2.Suppose that selective search generates \ud835\udc5bregion proposals. These region proposals (of\ndifferentshapes)markregionsofinterest(ofdifferentshapes)ontheCNNoutput. Then\nthese regions of interest further extract features of the same shape (say height \u210e2and\nwidth\ud835\udc642are specified) in order to be easily concatenated. To achieve this, the fast R-\nCNN introduces the region of interest (RoI) pooling layer: the CNN output and region\nproposalsareinputintothislayer,outputtingconcatenatedfeaturesofshape \ud835\udc5b\u0002\ud835\udc50\u0002\u210e2\u0002\n\ud835\udc642that are further extracted for all the region proposals.", "mimetype": "text/plain", "start_char_idx": 1385089, "end_char_idx": 1388976, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e904659e-e60c-4692-a9ae-9d4e71b927a1": {"__data__": {"id_": "e904659e-e60c-4692-a9ae-9d4e71b927a1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3cd98c10-1fd6-46eb-a3e1-72d52c1814f3", "node_type": "1", "metadata": {}, "hash": "9671ce6258aca68c0cb9c13bc4dcbbf7d91e86e163aacd5716377600a051eace", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1a808038-9f0c-4b12-9c72-12393769d7be", "node_type": "1", "metadata": {}, "hash": "4652f330332d17fae750a84b412665a8d992bfbd3c26cd083b2d97d5c6fd9359", "class_name": "RelatedNodeInfo"}}, "text": "Moreover, this CNN is\ntrainable. Given an input image, let the shape of the CNN output be 1\u0002\ud835\udc50\u0002\u210e1\u0002\ud835\udc641.\n644 Computer Vision\n2.Suppose that selective search generates \ud835\udc5bregion proposals. These region proposals (of\ndifferentshapes)markregionsofinterest(ofdifferentshapes)ontheCNNoutput. Then\nthese regions of interest further extract features of the same shape (say height \u210e2and\nwidth\ud835\udc642are specified) in order to be easily concatenated. To achieve this, the fast R-\nCNN introduces the region of interest (RoI) pooling layer: the CNN output and region\nproposalsareinputintothislayer,outputtingconcatenatedfeaturesofshape \ud835\udc5b\u0002\ud835\udc50\u0002\u210e2\u0002\n\ud835\udc642that are further extracted for all the region proposals.\n3.Using a fully connected layer, transform the concatenated features into an output of\nshape\ud835\udc5b\u0002\ud835\udc51, where\ud835\udc51depends on the model design.\n4.Predict the class and bounding box for each of the \ud835\udc5bregion proposals. More concretely,\nin class and bounding box prediction, transform the fully connected layer output into\nan output of shape \ud835\udc5b\u0002\ud835\udc5e(\ud835\udc5eis the number of classes) and an output of shape \ud835\udc5b\u00024,\nrespectively. The class prediction uses softmax regression.\nTheregionofinterestpoolinglayerproposedinthefastR-CNNisdifferentfromthepooling\nlayer introduced in Section 7.5 . In the pooling layer, we indirectly control the output shape\nbyspecifyingsizesofthepoolingwindow, padding, andstride. Incontrast, wecandirectly\nspecify the output shape in the region of interest pooling layer.\nFor example, let\u2019s specify the output height and width for each region as \u210e2and\ud835\udc642, re-\nspectively. For any region of interest window of shape \u210e\u0002\ud835\udc64, this window is divided\ninto a\u210e2\u0002\ud835\udc642grid of subwindows, where the shape of each subwindow is approximately\n\u00b9\u210e\u009d\u210e2\u00ba\u0002\u00b9\ud835\udc64\u009d\ud835\udc642\u00ba. Inpractice, theheightandwidthofanysubwindowshallberoundedup,\nand the largest element shall be used as output of the subwindow. Therefore, the region of\ninterest pooling layer can extract features of the same shape even when regions of interest\nhave different shapes.\nAs an illustrative example, in Fig. 14.8.3 , the upper-left 3\u00023region of interest is selected\nona 4\u00024input. Forthisregionofinterest,weusea 2\u00022regionofinterestpoolinglayerto\nobtain a 2\u00022output. Note that each of the four divided subwindows contains elements 0,\n1, 4, and 5 (5 is the maximum); 2 and 6 (6 is the maximum); 8 and 9 (9 is the maximum);\nand 10.\ntFig. 14.8.3 A 2\u00022 region of interest pooling layer.\nBelow we demonstrate the computation of the region of interest pooling layer. Suppose\nthat the height and width of the CNN-extracted features Xare both 4, and there is only a\nsingle channel.\nimport torch\nimport torchvision\n(continues on next page)\n645 Region-based CNNs (R-CNNs)\n(continued from previous page)\nX=torch .arange( 16.).reshape( 1,1,4,4)\nX\ntensor([[[[ 0.,1.,2.,3.],\n[4.,5.,6.,7.],\n[8.,9.,10.,11.],\n[12.,13.,14.,15.]]]])\nLet\u2019s further suppose that the height and width of the input image are both 40 pixels and\nthat selective search generates two region proposals on this image. Each region proposal is\nexpressed as five elements: its object class followed by the \u00b9\ud835\udc65,\ud835\udc66\u00ba-coordinates of its upper-\nleft and lower-right corners.\nrois =torch .Tensor([[ 0,0,0,20,20], [ 0,0,10,30,30]])\nBecause the height and width of Xare1\u009d10of the height and width of the input image,\nthe coordinates of the tworegion proposals are multiplied by0.1 according to the specified\nspatial_scale argument.", "mimetype": "text/plain", "start_char_idx": 1388296, "end_char_idx": 1391678, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1a808038-9f0c-4b12-9c72-12393769d7be": {"__data__": {"id_": "1a808038-9f0c-4b12-9c72-12393769d7be", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e904659e-e60c-4692-a9ae-9d4e71b927a1", "node_type": "1", "metadata": {}, "hash": "ac6d8516768bd738206f39f78d5d380bd432d34948bf3f0ba1aad96806f00236", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a136d892-c327-4dec-90db-51241861a6f3", "node_type": "1", "metadata": {}, "hash": "70a458cd9e90eee79faac4935665be94dcd30ac4323cd38c973a3048d53dde51", "class_name": "RelatedNodeInfo"}}, "text": "],\n[4.,5.,6.,7.],\n[8.,9.,10.,11.],\n[12.,13.,14.,15.]]]])\nLet\u2019s further suppose that the height and width of the input image are both 40 pixels and\nthat selective search generates two region proposals on this image. Each region proposal is\nexpressed as five elements: its object class followed by the \u00b9\ud835\udc65,\ud835\udc66\u00ba-coordinates of its upper-\nleft and lower-right corners.\nrois =torch .Tensor([[ 0,0,0,20,20], [ 0,0,10,30,30]])\nBecause the height and width of Xare1\u009d10of the height and width of the input image,\nthe coordinates of the tworegion proposals are multiplied by0.1 according to the specified\nspatial_scale argument. Then the two regions of interest are marked on XasX[:, :,\n0:3, 0:3] andX[:, :, 1:4, 0:4] , respectively. Finally in the 2\u00022region of interest\npooling, each region of interest is divided into a grid of sub-windows to further extract\nfeatures of the same shape 2\u00022.\ntorchvision .ops.roi_pool(X, rois, output_size =(2,2), spatial_scale =0.1)\ntensor([[[[ 5.,6.],\n[9.,10.]]],\n[[[ 9.,11.],\n[13.,15.]]]])\n14.8.3FasterR-CNN\nTo be more accurate in object detection, the fast R-CNN model usually has to generate\na lot of region proposals in selective search. To reduce region proposals without loss of\naccuracy, the faster R-CNN proposes to replace selective search with a region proposal\nnetwork (Renetal., 2015).\nFig. 14.8.4 shows the faster R-CNN model. Compared with the fast R-CNN, the faster R-\nCNN only changes the region proposal method from selective search to a region proposal\nnetwork. The rest of the model remain unchanged. The region proposal network works in\nthe following steps:\n1.Use a 3\u00023convolutional layer with padding of 1 to transform the CNN output to a\n646 Computer Vision\ntFig. 14.8.4 The faster R-CNN model.\nnew output with \ud835\udc50channels. In this way, each unit along the spatial dimensions of the\nCNN-extracted feature maps gets a new feature vector of length \ud835\udc50.\n2.Centered on each pixel of the feature maps, generate multiple anchor boxes of different\nscales and aspect ratios and label them.\n3.Using the length- \ud835\udc50feature vector at the center of each anchor box, predict the binary\nclass (background or objects) and bounding box for this anchor box.\n4.Consider those predicted bounding boxes whose predicted classes are objects. Remove\noverlappedresultsusingnon-maximumsuppression. Theremainingpredictedbounding\nboxesforobjectsaretheregionproposalsrequiredbytheregionofinterestpoolinglayer.\nIt is worth noting that, as part of the faster R-CNN model, the region proposal network\nis jointly trained with the rest of the model. In other words, the objective function of the\nfaster R-CNN includes not only the class and bounding box prediction in object detection,\nbutalsothebinaryclassandboundingboxpredictionofanchorboxesintheregionproposal\nnetwork. As a result of the end-to-end training, the region proposal network learns how to\ngenerate high-quality region proposals, so as to stay accurate in object detection with a\nreduced number of region proposals that are learned from data.\n14.8.4Mask R-CNN\nIn the training dataset, if pixel-level positions of object are also labeled on images, the\nmask R-CNN can effectively leverage such detailed labels to further improve the accuracy\nof object detection ( Heetal., 2017).\nAs shown in Fig. 14.8.5 , the mask R-CNN is modified based on the faster R-CNN. Specif-\nically, the mask R-CNN replaces the region of interest pooling layer with the region of\ninterest (RoI) alignment layer. This region of interest alignment layer uses bilinear inter-\npolation to preserve the spatial information on the feature maps, which is more suitable for\npixel-level prediction. The output of this layer contains feature maps of the same shape for\nall the regions of interest. They are used to predict not only the class and bounding box\nfor each region of interest, but also the pixel-level position of the object through an addi-\ntional fully convolutional network.", "mimetype": "text/plain", "start_char_idx": 1391063, "end_char_idx": 1394987, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a136d892-c327-4dec-90db-51241861a6f3": {"__data__": {"id_": "a136d892-c327-4dec-90db-51241861a6f3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1a808038-9f0c-4b12-9c72-12393769d7be", "node_type": "1", "metadata": {}, "hash": "4652f330332d17fae750a84b412665a8d992bfbd3c26cd083b2d97d5c6fd9359", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4849393f-ea79-483e-9afc-f52509a9a5b6", "node_type": "1", "metadata": {}, "hash": "0d7aacaba2aff4f24c6fd632dac87394f12120da19520c154bda6708bca4cf38", "class_name": "RelatedNodeInfo"}}, "text": "As shown in Fig. 14.8.5 , the mask R-CNN is modified based on the faster R-CNN. Specif-\nically, the mask R-CNN replaces the region of interest pooling layer with the region of\ninterest (RoI) alignment layer. This region of interest alignment layer uses bilinear inter-\npolation to preserve the spatial information on the feature maps, which is more suitable for\npixel-level prediction. The output of this layer contains feature maps of the same shape for\nall the regions of interest. They are used to predict not only the class and bounding box\nfor each region of interest, but also the pixel-level position of the object through an addi-\ntional fully convolutional network. More details on using a fully convolutional network to\n647 Region-based CNNs (R-CNNs)\ntFig. 14.8.5 The mask R-CNN model.\n219predict pixel-level semantics of an image will be provided in subsequent sections of this\nchapter.\n14.8.5Summary\n\u000fTheR-CNNextractsmanyregionproposalsfromtheinputimage,usesaCNNtoperform\nforward propagation on each region proposal to extract its features, then uses these\nfeatures to predict the class and bounding box of this region proposal.\n\u000fOne of the majorimprovements of the fastR-CNN from the R-CNNis that the CNN for-\nward propagation is only performed on the entire image. It also introduces the region\nof interest pooling layer, so that features of the same shape can be further extracted\nfor regions of interest that have different shapes.\n\u000fThe faster R-CNN replaces the selective search used in the fast R-CNN with a jointly\ntrained region proposal network, so that the former can stay accurate in object detec-\ntion with a reduced number of region proposals.\n\u000fBased on the faster R-CNN, the mask R-CNN additionally introduces a fully convolu-\ntional network, so as to leverage pixel-level labels to further improve the accuracy of\nobject detection.\n14.8.6Exercises\n1.Canweframeobjectdetectionasasingleregressionproblem,suchaspredictingbound-\ning boxes and class probabilities? You may refer to the design of the YOLO model\n(Redmonetal., 2016).\n2.Compare single shot multibox detection with the methods introduced in this section.\nWhat are their major differences? You may refer to Figure 2 of Zhao etal.(2019).\nDiscussions219.\n648 Computer Vision\n22014.9Semantic Segmentation and the Dataset\nWhen discussing object detection tasks in Section 14.3 \u2013Section 14.8 , rectangular bound-\ning boxes are used to label and predict objects in images. This section will discuss the\nproblem of semantic segmentation , which focuses on how to divide an image into regions\nbelonging to different semantic classes. Different from object detection, semantic seg-\nmentation recognizes and understands what are in images in pixel level: its labeling and\nprediction of semantic regions are in pixel level. Fig. 14.9.1 shows the labels of the dog,\ncat, and background of the image in semantic segmentation. Compared with in object de-\ntection, the pixel-level borders labeled in semantic segmentation are obviously more fine-\ngrained.\ntFig. 14.9.1 Labels of the dog, cat, and background of the image in semantic segmentation.\n14.9.1ImageSegmentation and Instance Segmentation\nTherearealsotwoimportanttasksinthefieldofcomputervisionthataresimilartoseman-\ntic segmentation, namely image segmentation and instance segmentation. We will briefly\ndistinguish them from semantic segmentation as follows.\n\u000fImage segmentation divides an image into several constituent regions. The methods for\nthis type of problem usually make use of the correlation between pixels in the image.\nIt does not need label information about image pixels during training, and it cannot\nguarantee that the segmented regions will have the semantics that we hope to obtain\nduring prediction. Taking the image in Fig. 14.9.1 as input, image segmentation may\ndivide the dog into two regions: one covers the mouth and eyes which are mainly\nblack, and the other covers the rest of the body which is mainly yellow.\n\u000fInstancesegmentation isalsocalled simultaneousdetectionandsegmentation . Itstudies\nhow to recognize the pixel-level regions of each object instance in an image. Differ-\nent from semantic segmentation, instance segmentation needs to distinguish not only\nsemantics, but also different object instances. For example, if there are two dogs in\nthe image, instance segmentation needs to distinguish which of the two dogs a pixel\nbelongs to.\n14.9.2The PascalVOC2012Semantic Segmentation Dataset\nOn of the most important semantic segmentation dataset is Pascal VOC2012220.", "mimetype": "text/plain", "start_char_idx": 1394313, "end_char_idx": 1398844, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4849393f-ea79-483e-9afc-f52509a9a5b6": {"__data__": {"id_": "4849393f-ea79-483e-9afc-f52509a9a5b6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a136d892-c327-4dec-90db-51241861a6f3", "node_type": "1", "metadata": {}, "hash": "70a458cd9e90eee79faac4935665be94dcd30ac4323cd38c973a3048d53dde51", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1832f8df-fcd5-4133-a245-f54f51a3e6f0", "node_type": "1", "metadata": {}, "hash": "272fe834103038f919e20c918384c25e95eb9484b1385c24c135df2281161ca4", "class_name": "RelatedNodeInfo"}}, "text": "Taking the image in Fig. 14.9.1 as input, image segmentation may\ndivide the dog into two regions: one covers the mouth and eyes which are mainly\nblack, and the other covers the rest of the body which is mainly yellow.\n\u000fInstancesegmentation isalsocalled simultaneousdetectionandsegmentation . Itstudies\nhow to recognize the pixel-level regions of each object instance in an image. Differ-\nent from semantic segmentation, instance segmentation needs to distinguish not only\nsemantics, but also different object instances. For example, if there are two dogs in\nthe image, instance segmentation needs to distinguish which of the two dogs a pixel\nbelongs to.\n14.9.2The PascalVOC2012Semantic Segmentation Dataset\nOn of the most important semantic segmentation dataset is Pascal VOC2012220. In the\n649 Semantic Segmentation and the Dataset\nfollowing, we will take a look at this dataset.\n%matplotlib inline\nimport os\nimport torch\nimport torchvision\nfrom d2l import torch asd2l\nThe tar file of the dataset is about 2 GB, so it may take a while to download the file. The\nextracted dataset is located at ../data/VOCdevkit/VOC2012 .\n#@save\nd2l.DATA_HUB[ 'voc2012 ']=(d2l .DATA_URL +'VOCtrainval_11-May-2012.tar ',\n'4e443f8a2eca6b1dac8a6c57641b67dd40621a49 ')\nvoc_dir =d2l.download_extract( 'voc2012 ','VOCdevkit/VOC2012 ')\nDownloading ../data /VOCtrainval_11 -May-2012. tar from http ://d2l-data .s3-\n\u21a9!accelerate .amazonaws .com/VOCtrainval_11 -May-2012. tar...\nAfter entering the path ../data/VOCdevkit/VOC2012 , we can see the different compo-\nnents of the dataset. The ImageSets/Segmentation path contains text files that specify\ntraining and test samples, while the JPEGImages andSegmentationClass paths store the\ninput image and label for each example, respectively. The label here is also in the im-\nage format, with the same size as its labeled input image. Besides, pixels with the same\ncolor in any label image belong to the same semantic class. The following defines the\nread_voc_images functiontoreadalltheinputimagesandlabelsintothememory.\n#@save\ndef read_voc_images (voc_dir, is_train =True ):\n\"\"\"Read all VOC feature and label images.\"\"\"\ntxt_fname =os.path .join(voc_dir, 'ImageSets ','Segmentation ',\n'train.txt 'ifis_train else 'val.txt ')\nmode =torchvision .io.image .ImageReadMode .RGB\nwith open (txt_fname, 'r')asf:\nimages =f.read() .split()\nfeatures, labels =[], []\nfor i, fname inenumerate (images):\nfeatures .append(torchvision .io.read_image(os .path .join(\nvoc_dir, 'JPEGImages ',f'{fname }.jpg ')))\nlabels .append(torchvision .io.read_image(os .path .join(\nvoc_dir, 'SegmentationClass ',f'{fname }.png '), mode))\nreturn features, labels\ntrain_features, train_labels =read_voc_images(voc_dir, True )\nWedrawthefirstfiveinputimagesandtheirlabels. Inthelabelimages,whiteandblackrep-\nresent borders and background, respectively, while the other colors correspond to different\nclasses.\n650 Computer Vision\nn=5\nimgs =train_features[:n] +train_labels[:n]\nimgs =[img .permute( 1,2,0)for img inimgs]\nd2l.show_images(imgs, 2, n);\nNext,weenumeratetheRGBcolorvaluesandclassnamesforallthelabelsinthisdataset.", "mimetype": "text/plain", "start_char_idx": 1398061, "end_char_idx": 1401170, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1832f8df-fcd5-4133-a245-f54f51a3e6f0": {"__data__": {"id_": "1832f8df-fcd5-4133-a245-f54f51a3e6f0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4849393f-ea79-483e-9afc-f52509a9a5b6", "node_type": "1", "metadata": {}, "hash": "0d7aacaba2aff4f24c6fd632dac87394f12120da19520c154bda6708bca4cf38", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9b40513b-344e-41f3-a282-0d8fb50f2d98", "node_type": "1", "metadata": {}, "hash": "b4436c720ef0614fbc93d323252c9c6589345c5665d8a82923a592d50e1c1c99", "class_name": "RelatedNodeInfo"}}, "text": "Inthelabelimages,whiteandblackrep-\nresent borders and background, respectively, while the other colors correspond to different\nclasses.\n650 Computer Vision\nn=5\nimgs =train_features[:n] +train_labels[:n]\nimgs =[img .permute( 1,2,0)for img inimgs]\nd2l.show_images(imgs, 2, n);\nNext,weenumeratetheRGBcolorvaluesandclassnamesforallthelabelsinthisdataset.\n#@save\nVOC_COLORMAP =[[0,0,0], [ 128,0,0], [ 0,128,0], [ 128,128,0],\n[0,0,128], [ 128,0,128], [ 0,128,128], [ 128,128,128],\n[64,0,0], [ 192,0,0], [ 64,128,0], [ 192,128,0],\n[64,0,128], [ 192,0,128], [ 64,128,128], [ 192,128,128],\n[0,64,0], [ 128,64,0], [ 0,192,0], [ 128,192,0],\n[0,64,128]]\n#@save\nVOC_CLASSES =['background ','aeroplane ','bicycle ','bird ','boat ',\n'bottle ','bus','car','cat','chair ','cow',\n'diningtable ','dog','horse ','motorbike ','person ',\n'potted plant ','sheep ','sofa ','train ','tv/monitor ']\nWith the two constants defined above, we can conveniently find the class index for each\npixel in a label. We define the voc_colormap2label function to build the mapping from\nthe above RGB color values to class indices, and the voc_label_indices function to map\nany RGB values to their class indices in this Pascal VOC2012 dataset.\n#@save\ndef voc_colormap2label ():\n\"\"\"Build the mapping from RGB to class indices for VOC labels.\"\"\"\ncolormap2label =torch .zeros( 256 **3, dtype =torch .long)\nfor i, colormap inenumerate (VOC_COLORMAP):\ncolormap2label[\n(colormap[ 0]*256 +colormap[ 1])*256 +colormap[ 2]]=i\nreturn colormap2label\n#@save\ndef voc_label_indices (colormap, colormap2label):\n\"\"\"Map any RGB values in VOC labels to their class indices.\"\"\"\ncolormap =colormap .permute( 1,2,0).numpy() .astype( 'int32 ')\n(continues on next page)\n651 Semantic Segmentation and the Dataset\n(continued from previous page)\nidx =((colormap[:, :, 0]*256 +colormap[:, :, 1])*256\n+colormap[:, :, 2])\nreturn colormap2label[idx]\nFor example, in the first example image, the class index for the front part of the airplane is\n1, while the background index is 0.\ny=voc_label_indices(train_labels[ 0], voc_colormap2label())\ny[105:115,130:140], VOC_CLASSES[ 1]\n(tensor([[ 0,0,0,0,0,0,0,0,0,1],\n[0,0,0,0,0,0,0,1,1,1],\n[0,0,0,0,0,0,1,1,1,1],\n[0,0,0,0,0,1,1,1,1,1],\n[0,0,0,0,0,1,1,1,1,1],\n[0,0,0,0,1,1,1,1,1,1],\n[0,0,0,0,0,1,1,1,1,1],\n[0,0,0,0,0,1,1,1,1,1],\n[0,0,0,0,0,0,1,1,1,1],\n[0,0,0,0,0,0,0,0,1,1]]),\n'aeroplane ')\nData Preprocessing\nIn previous experiments such as in Section 8.1 \u2013Section 8.4 , images are rescaled to fit the\nmodel\u2019srequiredinputshape. However,insemanticsegmentation,doingsorequiresrescal-\ningthepredictedpixelclassesbacktotheoriginalshapeoftheinputimage. Suchrescaling\nmay be inaccurate, especially for segmented regions with different classes. To avoid this\nissue, we crop the image to a fixedshape instead of rescaling. Specifically, using random\ncropping from image augmentation, we crop the same area of the input image and the la-\nbel.", "mimetype": "text/plain", "start_char_idx": 1400820, "end_char_idx": 1403727, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9b40513b-344e-41f3-a282-0d8fb50f2d98": {"__data__": {"id_": "9b40513b-344e-41f3-a282-0d8fb50f2d98", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1832f8df-fcd5-4133-a245-f54f51a3e6f0", "node_type": "1", "metadata": {}, "hash": "272fe834103038f919e20c918384c25e95eb9484b1385c24c135df2281161ca4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8527d035-deba-4ca2-b6e4-799dc328ff13", "node_type": "1", "metadata": {}, "hash": "386d7efd14f4157fa429709225fbad6efec53ef5b4dbd4ceb28a3faa6783f23d", "class_name": "RelatedNodeInfo"}}, "text": "However,insemanticsegmentation,doingsorequiresrescal-\ningthepredictedpixelclassesbacktotheoriginalshapeoftheinputimage. Suchrescaling\nmay be inaccurate, especially for segmented regions with different classes. To avoid this\nissue, we crop the image to a fixedshape instead of rescaling. Specifically, using random\ncropping from image augmentation, we crop the same area of the input image and the la-\nbel.\n#@save\ndef voc_rand_crop (feature, label, height, width):\n\"\"\"Randomly crop both feature and label images.\"\"\"\nrect =torchvision .transforms .RandomCrop .get_params(\nfeature, (height, width))\nfeature =torchvision .transforms .functional .crop(feature, *rect)\nlabel =torchvision .transforms .functional .crop(label, *rect)\nreturn feature, label\nimgs =[]\nfor _inrange (n):\nimgs +=voc_rand_crop(train_features[ 0], train_labels[ 0],200,300)\nimgs =[img .permute( 1,2,0)for img inimgs]\nd2l.show_images(imgs[:: 2]+imgs[ 1::2],2, n);\n652 Computer Vision\nCustom Semantic Segmentation DatasetClass\nWe define a custom semantic segmentation dataset class VOCSegDataset by inheriting the\nDataset class provided by high-level APIs. By implementing the __getitem__ function,\nwe can arbitrarily access the input image indexed as idxin the dataset and the class index\nof each pixel in this image. Since some images in the dataset have a smaller size than\nthe output size of random cropping, these examples are filtered out by a custom filter\nfunction. In addition, we also define the normalize_image function to standardize the\nvalues of the three RGB channels of input images.\n#@save\nclass VOCSegDataset (torch .utils .data .Dataset):\n\"\"\"A customized dataset to load the VOC dataset.\"\"\"\ndef __init__ (self , is_train, crop_size, voc_dir):\nself .transform =torchvision .transforms .Normalize(\nmean =[0.485 ,0.456 ,0.406 ], std =[0.229 ,0.224 ,0.225 ])\nself .crop_size =crop_size\nfeatures, labels =read_voc_images(voc_dir, is_train =is_train)\nself .features =[self .normalize_image(feature)\nfor feature inself .filter(features)]\nself .labels =self .filter(labels)\nself .colormap2label =voc_colormap2label()\nprint ('read '+str(len(self .features)) +'examples ')\ndef normalize_image (self , img):\nreturn self .transform(img .float() /255)\ndef filter (self , imgs):\nreturn [img for img inimgs if(\nimg.shape[ 1]>=self .crop_size[ 0]and\nimg.shape[ 2]>=self .crop_size[ 1])]\ndef __getitem__ (self , idx):\nfeature, label =voc_rand_crop( self .features[idx], self .labels[idx],\n*self .crop_size)\nreturn (feature, voc_label_indices(label, self .colormap2label))\ndef __len__ (self ):\nreturn len(self .features)\n653 Semantic Segmentation and the Dataset\nReadingthe Dataset\nWe use the custom VOCSegDatase t class to create instances of the training set and test set,\nrespectively. Suppose that we specify that the output shape of randomly cropped images is\n320\u0002480. Below we can view the number of examples that are retained in the training set\nand test set.\ncrop_size =(320,480)\nvoc_train =VOCSegDataset( True , crop_size, voc_dir)\nvoc_test =VOCSegDataset( False , crop_size, voc_dir)\nread 1114 examples\nread 1078 examples\nSetting the batch size to 64, we define the data iterator for the training set. Let\u2019s print\nthe shape of the first minibatch. Different from in image classification or object detection,\nlabels here are three-dimensional tensors.\nbatch_size =64\ntrain_iter =torch .utils .data .DataLoader(voc_train, batch_size, shuffle =True ,\ndrop_last =True ,\nnum_workers =d2l.get_dataloader_workers())\nfor X, Y intrain_iter:\nprint (X.shape)\nprint (Y.shape)\nbreak\ntorch .Size([ 64,3,320,480])\ntorch .Size([ 64,320,480])\nPuttingIt All Together\nFinally, we define the following load_data_voc function to download and read the Pascal\nVOC2012 semantic segmentation dataset. It returns data iterators for both the training and\ntest datasets.\n#@save\ndef load_data_voc (batch_size, crop_size):\n\"\"\"Load the VOC semantic segmentation dataset.\"\"\"", "mimetype": "text/plain", "start_char_idx": 1403322, "end_char_idx": 1407241, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8527d035-deba-4ca2-b6e4-799dc328ff13": {"__data__": {"id_": "8527d035-deba-4ca2-b6e4-799dc328ff13", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9b40513b-344e-41f3-a282-0d8fb50f2d98", "node_type": "1", "metadata": {}, "hash": "b4436c720ef0614fbc93d323252c9c6589345c5665d8a82923a592d50e1c1c99", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "27673371-4df1-4858-beba-f8f3f275d7d1", "node_type": "1", "metadata": {}, "hash": "163db9b5b216d6ed0635e629adbb1451717872ab97291bc38dac8e7f022f99dc", "class_name": "RelatedNodeInfo"}}, "text": "Let\u2019s print\nthe shape of the first minibatch. Different from in image classification or object detection,\nlabels here are three-dimensional tensors.\nbatch_size =64\ntrain_iter =torch .utils .data .DataLoader(voc_train, batch_size, shuffle =True ,\ndrop_last =True ,\nnum_workers =d2l.get_dataloader_workers())\nfor X, Y intrain_iter:\nprint (X.shape)\nprint (Y.shape)\nbreak\ntorch .Size([ 64,3,320,480])\ntorch .Size([ 64,320,480])\nPuttingIt All Together\nFinally, we define the following load_data_voc function to download and read the Pascal\nVOC2012 semantic segmentation dataset. It returns data iterators for both the training and\ntest datasets.\n#@save\ndef load_data_voc (batch_size, crop_size):\n\"\"\"Load the VOC semantic segmentation dataset.\"\"\"\nvoc_dir =d2l.download_extract( 'voc2012 ', os .path .join(\n'VOCdevkit ','VOC2012 '))\nnum_workers =d2l.get_dataloader_workers()\ntrain_iter =torch .utils .data .DataLoader(\nVOCSegDataset( True , crop_size, voc_dir), batch_size,\nshuffle =True , drop_last =True , num_workers =num_workers)\ntest_iter =torch .utils .data .DataLoader(\nVOCSegDataset( False , crop_size, voc_dir), batch_size,\ndrop_last =True , num_workers =num_workers)\nreturn train_iter, test_iter\n654 Computer Vision\n22114.9.3Summary\n\u000fSemantic segmentation recognizes and understands what are in an image in pixel level\nby dividing the image into regions belonging to different semantic classes.\n\u000fOne of the most important semantic segmentation dataset is Pascal VOC2012.\n\u000fIn semantic segmentation, since the input image and label correspond one-to-one on the\npixel, the input image is randomly cropped to a fixed shape rather than rescaled.\n14.9.4Exercises\n1.How can semantic segmentation be applied in autonomous vehicles and medical image\ndiagnostics? Can you think of other applications?\n2.Recall the descriptions of data augmentation in Section 14.1 . Which of the image aug-\nmentation methods used in image classification would be infeasible to be applied in\nsemantic segmentation?\nDiscussions221.\n14.10TransposedConvolution\nThe CNN layers we have seen so far, such as convolutional layers ( Section 7.2 ) and pool-\ning layers ( Section 7.5 ), typically reduce (downsample) the spatial dimensions (height and\nwidth) of the input, or keep them unchanged. In semantic segmentation that classifies at\npixel-level, it will be convenient if the spatial dimensions of the input and output are the\nsame. For example, the channel dimension at one output pixel can hold the classification\nresults for the input pixel at the same spatial position.\nTo achieve this, especially after the spatial dimensions are reduced by CNN layers, we\ncan use another type of CNN layers that can increase (upsample) the spatial dimensions of\nintermediatefeaturemaps. Inthissection,wewillintroduce transposedconvolution ,which\nis also called fractionally-strided convolution (Dumoulin and Visin, 2016 ), for reversing\ndownsampling operations by the convolution.\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n14.10.1Basic Operation\nIgnoringchannelsfornow,let\u2019sbeginwiththebasictransposedconvolutionoperationwith\nstride of1 andno padding. Supposethat weare givena \ud835\udc5b\u210e\u0002\ud835\udc5b\ud835\udc64inputtensorand a \ud835\udc58\u210e\u0002\ud835\udc58\ud835\udc64\nkernel. Sliding the kernel window with stride of 1 for \ud835\udc5b\ud835\udc64times in each row and \ud835\udc5b\u210etimes\n655 Transposed Convolution\nin each column yields a total of \ud835\udc5b\u210e\ud835\udc5b\ud835\udc64intermediate results. Each intermediate result is\na\u00b9\ud835\udc5b\u210e\u00b8\ud835\udc58\u210e\u00001\u00ba\u0002\u00b9\ud835\udc5b\ud835\udc64\u00b8\ud835\udc58\ud835\udc64\u00001\u00batensor that are initialized as zeros. To compute each\nintermediate tensor, each element in the input tensor is multiplied by the kernel so that\nthe resulting \ud835\udc58\u210e\u0002\ud835\udc58\ud835\udc64tensor replaces a portion in each intermediate tensor. Note that the\nposition of the replaced portion in each intermediate tensor corresponds to the position of\nthe element in the input tensor used for the computation. In the end, all the intermediate\nresults are summed over to produce the output.\nAs an example, Fig.", "mimetype": "text/plain", "start_char_idx": 1406501, "end_char_idx": 1410389, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "27673371-4df1-4858-beba-f8f3f275d7d1": {"__data__": {"id_": "27673371-4df1-4858-beba-f8f3f275d7d1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8527d035-deba-4ca2-b6e4-799dc328ff13", "node_type": "1", "metadata": {}, "hash": "386d7efd14f4157fa429709225fbad6efec53ef5b4dbd4ceb28a3faa6783f23d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5e195af6-959f-48bf-9c02-0ea2f0d2ec7a", "node_type": "1", "metadata": {}, "hash": "b6e76dc62e287c90bd42bc0dc92d8270c9fec16828fe5759cbc3496b85c5ceb2", "class_name": "RelatedNodeInfo"}}, "text": "Each intermediate result is\na\u00b9\ud835\udc5b\u210e\u00b8\ud835\udc58\u210e\u00001\u00ba\u0002\u00b9\ud835\udc5b\ud835\udc64\u00b8\ud835\udc58\ud835\udc64\u00001\u00batensor that are initialized as zeros. To compute each\nintermediate tensor, each element in the input tensor is multiplied by the kernel so that\nthe resulting \ud835\udc58\u210e\u0002\ud835\udc58\ud835\udc64tensor replaces a portion in each intermediate tensor. Note that the\nposition of the replaced portion in each intermediate tensor corresponds to the position of\nthe element in the input tensor used for the computation. In the end, all the intermediate\nresults are summed over to produce the output.\nAs an example, Fig. 14.10.1 illustrates how transposed convolution with a 2\u00022kernel is\ncomputed for a 2\u00022input tensor.\ntFig. 14.10.1 Transposed convolution with a 2 \u00022 kernel. The shaded portions are a portion of an\nintermediate tensor as well as the input and kernel tensor elements used for the\ncomputation.\nWe can implement this basic transposed convolution operation trans_conv for a input\nmatrix Xand a kernel matrix K.\ndef trans_conv (X, K):\nh, w =K.shape\nY=torch .zeros((X .shape[ 0]+h-1, X.shape[ 1]+w-1))\nfor iinrange (X.shape[ 0]):\nfor jinrange (X.shape[ 1]):\nY[i: i +h, j: j +w]+=X[i, j] *K\nreturn Y\nIn contrast to the regular convolution (in Section 7.2 ) thatreduces input elements via the\nkernel, the transposed convolution broadcasts input elements via the kernel, thereby pro-\nducing an output that is larger than the input. We can construct the input tensor Xand the\nkernel tensor KfromFig. 14.10.1 to validate the output of the above implementation of the\nbasic two-dimensional transposed convolution operation.\nX=torch .tensor([[ 0.0,1.0], [ 2.0,3.0]])\nK=torch .tensor([[ 0.0,1.0], [ 2.0,3.0]])\ntrans_conv(X, K)\ntensor([[ 0.,0.,1.],\n[0.,4.,6.],\n[4.,12.,9.]])\n656 Computer Vision\nAlternatively, when the input Xand kernel Kare both four-dimensional tensors, we can use\nhigh-level APIs to obtain the same results.\nX, K =X.reshape( 1,1,2,2), K .reshape( 1,1,2,2)\ntconv =nn.ConvTranspose2d( 1,1, kernel_size =2, bias =False )\ntconv .weight .data =K\ntconv(X)\ntensor([[[[ 0.,0.,1.],\n[0.,4.,6.],\n[4.,12.,9.]]]], grad_fn =<ConvolutionBackward0 >)\n14.10.2Padding,Strides, and Multiple Channels\nDifferent from in the regular convolution where padding is applied to input, it is applied to\noutput in the transposed convolution. For example, when specifying the padding number\non either side of the height and width as 1, the first and last rows and columns will be\nremoved from the transposed convolution output.\ntconv =nn.ConvTranspose2d( 1,1, kernel_size =2, padding =1, bias =False )\ntconv .weight .data =K\ntconv(X)\ntensor([[[[ 4.]]]], grad_fn =<ConvolutionBackward0 >)\nIn the transposed convolution, strides are specified for intermediate results (thus output),\nnot for input. Using the same input and kernel tensors from Fig. 14.10.1 , changing the\nstride from 1 to 2 increases both the height and weight of intermediate tensors, hence the\noutput tensor in Fig. 14.10.2 .\nThe following code snippet can validate the transposed convolution output for stride of 2\ninFig. 14.10.2 .\ntconv =nn.ConvTranspose2d( 1,1, kernel_size =2, stride =2, bias =False )\ntconv .weight .data =K\ntconv(X)\ntensor([[[[ 0.,0.,0.,1.],\n[0.,0.,2.,3.],\n[0.,2.,0.,3.],\n[4.,6.,6.,9.]]]], grad_fn =<ConvolutionBackward0 >)\nFor multiple input and output channels, the transposed convolution works in the same way\nas the regular convolution.", "mimetype": "text/plain", "start_char_idx": 1409860, "end_char_idx": 1413191, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5e195af6-959f-48bf-9c02-0ea2f0d2ec7a": {"__data__": {"id_": "5e195af6-959f-48bf-9c02-0ea2f0d2ec7a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "27673371-4df1-4858-beba-f8f3f275d7d1", "node_type": "1", "metadata": {}, "hash": "163db9b5b216d6ed0635e629adbb1451717872ab97291bc38dac8e7f022f99dc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0024d872-b833-4e4f-affd-91246c7c4def", "node_type": "1", "metadata": {}, "hash": "8e2d67810a4e026d120fad6ab2a03b5d1aab74f64e654afc6fa47ba37729e1bd", "class_name": "RelatedNodeInfo"}}, "text": "Using the same input and kernel tensors from Fig. 14.10.1 , changing the\nstride from 1 to 2 increases both the height and weight of intermediate tensors, hence the\noutput tensor in Fig. 14.10.2 .\nThe following code snippet can validate the transposed convolution output for stride of 2\ninFig. 14.10.2 .\ntconv =nn.ConvTranspose2d( 1,1, kernel_size =2, stride =2, bias =False )\ntconv .weight .data =K\ntconv(X)\ntensor([[[[ 0.,0.,0.,1.],\n[0.,0.,2.,3.],\n[0.,2.,0.,3.],\n[4.,6.,6.,9.]]]], grad_fn =<ConvolutionBackward0 >)\nFor multiple input and output channels, the transposed convolution works in the same way\nas the regular convolution. Suppose that the input has \ud835\udc50\ud835\udc56channels, and that the transposed\nconvolution assigns a \ud835\udc58\u210e\u0002\ud835\udc58\ud835\udc64kernel tensor to each input channel. When multiple output\nchannels are specified, we will have a \ud835\udc50\ud835\udc56\u0002\ud835\udc58\u210e\u0002\ud835\udc58\ud835\udc64kernel for each output channel.\n657 Transposed Convolution\ntFig. 14.10.2 Transposed convolution with a 2 \u00022 kernel with stride of 2. The shaded portions are a\nportion of an intermediate tensor as well as the input and kernel tensor elements used for\nthe computation.\nAs in all, if we feed Xinto a convolutional layer \ud835\udc53to output Y=\ud835\udc53\u00b9X\u00baand create a trans-\nposed convolutional layer \ud835\udc54with the same hyperparameters as \ud835\udc53except for the number of\noutput channels being the number of channels in X, then\ud835\udc54\u00b9\ud835\udc4c\u00bawill have the same shape as\nX. This can be illustrated in the following example.\nX=torch .rand(size =(1,10,16,16))\nconv =nn.Conv2d( 10,20, kernel_size =5, padding =2, stride =3)\ntconv =nn.ConvTranspose2d( 20,10, kernel_size =5, padding =2, stride =3)\ntconv(conv(X)) .shape ==X.shape\nTrue\n14.10.3Connectionto Matrix Transposition\nThe transposed convolution is named after the matrix transposition. To explain, let\u2019s first\nseehowtoimplementconvolutionsusingmatrixmultiplications. Intheexamplebelow,we\ndefine a 3\u00023input Xand a 2\u00022convolution kernel K, and then use the corr2dfunction\nto compute the convolution output Y.\nX=torch .arange( 9.0).reshape( 3,3)\nK=torch .tensor([[ 1.0,2.0], [ 3.0,4.0]])\nY=d2l.corr2d(X, K)\nY\ntensor([[ 27.,37.],\n[57.,67.]])\nNext, we rewrite the convolution kernel Kas a sparse weight matrix Wcontaining a lot of\n658 Computer Vision\nzeros. The shape of the weight matrix is ( 4,9), where the non-zero elements come from\nthe convolution kernel K.\ndef kernel2matrix (K):\nk, W =torch .zeros( 5), torch .zeros(( 4,9))\nk[:2], k[ 3:5]=K[0, :], K[ 1, :]\nW[0, :5], W[ 1,1:6], W[ 2,3:8], W[ 3,4:]=k, k, k, k\nreturn W\nW=kernel2matrix(K)\nW\ntensor([[ 1.,2.,0.,3.,4.,0.,0.,0.,0.],\n[0.,1.,2.,0.,3.,4.,0.,0.,0.],\n[0.,0.,0.,1.,2.,0.,3.,4.,0.],\n[0.,0.,0.,0.,1.,2.,0.,3.,4.]])\nConcatenate the input Xrow by row to get a vector of length 9. Then the matrix multiplica-\ntion of Wand the vectorized Xgives a vector of length 4. After reshaping it, we can obtain\nthesameresult Yfromtheoriginalconvolutionoperationabove: wejustimplementedcon-\nvolutions using matrix multiplications.\nY==torch .matmul(W, X .reshape( -1)).reshape( 2,2)\ntensor([[ True ,True ],\n[True ,True ]])\nLikewise, we can implement transposed convolutions using matrix multiplications.", "mimetype": "text/plain", "start_char_idx": 1412559, "end_char_idx": 1415641, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0024d872-b833-4e4f-affd-91246c7c4def": {"__data__": {"id_": "0024d872-b833-4e4f-affd-91246c7c4def", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5e195af6-959f-48bf-9c02-0ea2f0d2ec7a", "node_type": "1", "metadata": {}, "hash": "b6e76dc62e287c90bd42bc0dc92d8270c9fec16828fe5759cbc3496b85c5ceb2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "38b1bb0e-3206-4cee-9253-9de30a59a97c", "node_type": "1", "metadata": {}, "hash": "50e79e2078b27248adebde97e7356bfba1048f8d680fb8a9a75e614e2baa1893", "class_name": "RelatedNodeInfo"}}, "text": "],\n[0.,1.,2.,0.,3.,4.,0.,0.,0.],\n[0.,0.,0.,1.,2.,0.,3.,4.,0.],\n[0.,0.,0.,0.,1.,2.,0.,3.,4.]])\nConcatenate the input Xrow by row to get a vector of length 9. Then the matrix multiplica-\ntion of Wand the vectorized Xgives a vector of length 4. After reshaping it, we can obtain\nthesameresult Yfromtheoriginalconvolutionoperationabove: wejustimplementedcon-\nvolutions using matrix multiplications.\nY==torch .matmul(W, X .reshape( -1)).reshape( 2,2)\ntensor([[ True ,True ],\n[True ,True ]])\nLikewise, we can implement transposed convolutions using matrix multiplications. In the\nfollowing example, we take the 2\u00022output Yfrom the above regular convolution as input\nto the transposed convolution. To implement this operation by multiplying matrices, we\nonly need to transpose the weight matrix Wwith the new shape \u00b99,4\u00ba.\nZ=trans_conv(Y, K)\nZ==torch .matmul(W .T, Y .reshape( -1)).reshape( 3,3)\ntensor([[ True ,True ,True ],\n[True ,True ,True ],\n[True ,True ,True ]])\nConsider implementing the convolution by multiplying matrices. Given an input vector\nxand a weight matrix W, the forward propagation function of the convolution can be\nimplemented by multiplying its input with the weight matrix and outputting a vector y=\nWx. Since backpropagation follows the chain rule and rxy=W>, the backpropagation\nfunctionoftheconvolutioncanbeimplementedbymultiplyingitsinputwiththetransposed\nweight matrix W>. Therefore, the transposed convolutional layer can just exchange the\nforward propagation function and the backpropagation function of the convolutional layer:\n659 Fully Convolutional Networks\n222itsforwardpropagationandbackpropagationfunctionsmultiplytheirinputvectorwith W>\nandW, respectively.\n14.10.4Summary\n\u000fIn contrast to the regular convolution that reduces input elements via the kernel, the\ntransposed convolution broadcasts input elements via the kernel, thereby producing\nan output that is larger than the input.\n\u000fIf we feed Xinto a convolutional layer \ud835\udc53to output Y=\ud835\udc53\u00b9X\u00baand create a transposed\nconvolutional layer \ud835\udc54with the same hyperparameters as \ud835\udc53except for the number of\noutputchannelsbeingthenumberofchannelsin X,then\ud835\udc54\u00b9\ud835\udc4c\u00bawillhavethesameshape\nasX.\n\u000fWe can implement convolutions using matrix multiplications. The transposed convolu-\ntional layer can just exchange the forward propagation function and the backpropaga-\ntion function of the convolutional layer.\n14.10.5Exercises\n1.InSection14.10.3 ,theconvolutioninput Xandthetransposedconvolutionoutput Zhave\nthe same shape. Do they have the same value? Why?\n2.Is it efficient to use matrix multiplications to implement convolutions? Why?\nDiscussions222.\n14.11FullyConvolutional Networks\nAs discussed in Section 14.9 , semantic segmentation classifies images in pixel level. A\nfullyconvolutionalnetwork(FCN)usesaconvolutionalneuralnetworktotransformimage\npixels to pixel classes ( Longet al., 2015). Unlike the CNNs that we encountered earlier\nfor image classification or object detection, a fully convolutional network transforms the\nheight and width of intermediate feature maps back to those of the input image: this is\nachievedbythetransposedconvolutionallayerintroducedin Section14.10 . Asaresult,the\nclassification output and the input image have a one-to-one correspondence in pixel level:\nthe channel dimension at any output pixel holds the classification results for the input pixel\nat the same spatial position.\n%matplotlib inline\nimport torch\nimport torchvision\nfrom torch import nn\nfrom torch .nnimport functional asF\nfrom d2l import torch asd2l\n660 Computer Vision\n14.11.1The Model\nHere we describe the basic design of the fully convolutional network model. As shown\ninFig. 14.11.1 , this model first uses a CNN to extract image features, then transforms the\nnumber of channels into the number of classes via a 1\u00021convolutional layer, and finally\ntransforms the height and width of the feature maps to those of the input image via the\ntransposed convolution introduced in Section 14.10 .", "mimetype": "text/plain", "start_char_idx": 1415075, "end_char_idx": 1419029, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "38b1bb0e-3206-4cee-9253-9de30a59a97c": {"__data__": {"id_": "38b1bb0e-3206-4cee-9253-9de30a59a97c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0024d872-b833-4e4f-affd-91246c7c4def", "node_type": "1", "metadata": {}, "hash": "8e2d67810a4e026d120fad6ab2a03b5d1aab74f64e654afc6fa47ba37729e1bd", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8167dce3-dbed-4fd3-92cc-d7c82873d052", "node_type": "1", "metadata": {}, "hash": "9adf740860d87bbdf4004c2e53244c93cef67ecc9f75d36101891c24c38af39c", "class_name": "RelatedNodeInfo"}}, "text": "Asaresult,the\nclassification output and the input image have a one-to-one correspondence in pixel level:\nthe channel dimension at any output pixel holds the classification results for the input pixel\nat the same spatial position.\n%matplotlib inline\nimport torch\nimport torchvision\nfrom torch import nn\nfrom torch .nnimport functional asF\nfrom d2l import torch asd2l\n660 Computer Vision\n14.11.1The Model\nHere we describe the basic design of the fully convolutional network model. As shown\ninFig. 14.11.1 , this model first uses a CNN to extract image features, then transforms the\nnumber of channels into the number of classes via a 1\u00021convolutional layer, and finally\ntransforms the height and width of the feature maps to those of the input image via the\ntransposed convolution introduced in Section 14.10 . As a result, the model output has the\nsame height and width as the input image, where the output channel contains the predicted\nclasses for the input pixel at the same spatial position.\ntFig. 14.11.1 Fully convolutional network.\nBelow, we use a ResNet-18 model pretrained on the ImageNet dataset to extract image\nfeatures and denote the model instance as pretrained_net . The last few layers of this\nmodel include a global average pooling layer and a fully connected layer: they are not\nneeded in the fully convolutional network.\npretrained_net =torchvision .models .resnet18(pretrained =True )\nlist (pretrained_net .children())[ -3:]\nDownloading: \"https://download.pytorch.org/models/resnet18-f37072fd.pth\" to /\n\u21a9!home/ci/.cache/torch/hub/checkpoints/resnet18-f37072fd.pth\n100%|\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff| 44.7M/44.7M [00:00<00:00, 56.3MB/s]\n[Sequential(\n(0): BasicBlock(\n(conv1): Conv2d( 256,512, kernel_size =(3,3), stride =(2,2), padding =(1,\u2423\n\u21a9!1), bias =False )\n(bn1): BatchNorm2d( 512, eps =1e-05 , momentum =0.1, affine =True , track_\n\u21a9!running_stats =True )\n(relu): ReLU(inplace =True )\n(conv2): Conv2d( 512,512, kernel_size =(3,3), stride =(1,1), padding =(1,\u2423\n\u21a9!1), bias =False )\n(bn2): BatchNorm2d( 512, eps =1e-05 , momentum =0.1, affine =True , track_\n(continues on next page)\n661 Fully Convolutional Networks\n(continued from previous page)\n\u21a9!running_stats =True )\n(downsample): Sequential(\n(0): Conv2d( 256,512, kernel_size =(1,1), stride =(2,2), bias =False )\n(1): BatchNorm2d( 512, eps =1e-05 , momentum =0.1, affine =True , track_\n\u21a9!running_stats =True )\n)\n)\n(1): BasicBlock(\n(conv1): Conv2d( 512,512, kernel_size =(3,3), stride =(1,1), padding =(1,\u2423\n\u21a9!1), bias =False )\n(bn1): BatchNorm2d( 512, eps =1e-05 , momentum =0.1, affine =True , track_\n\u21a9!running_stats =True )\n(relu): ReLU(inplace =True )\n(conv2): Conv2d( 512,512, kernel_size =(3,3), stride =(1,1), padding =(1,\u2423\n\u21a9!1), bias =False )\n(bn2): BatchNorm2d( 512, eps =1e-05 , momentum =0.1, affine =True , track_\n\u21a9!running_stats =True )\n)\n),\nAdaptiveAvgPool2d(output_size =(1,1)),\nLinear(in_features =512, out_features =1000 , bias =True )]\nNext, we create the fully convolutional network instance net. It copies all the pretrained\nlayers in the ResNet-18 except for the final global average pooling layer and the fully con-\nnected layer that are closest to the output.\nnet =nn.Sequential( *list (pretrained_net .children())[: -2])\nGiven an input with height and width of 320 and 480 respectively, the forward propagation\nofnetreducestheinputheightandwidthto1/32oftheoriginal,namely10and15.", "mimetype": "text/plain", "start_char_idx": 1418221, "end_char_idx": 1421578, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8167dce3-dbed-4fd3-92cc-d7c82873d052": {"__data__": {"id_": "8167dce3-dbed-4fd3-92cc-d7c82873d052", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "38b1bb0e-3206-4cee-9253-9de30a59a97c", "node_type": "1", "metadata": {}, "hash": "50e79e2078b27248adebde97e7356bfba1048f8d680fb8a9a75e614e2baa1893", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d85ff2c0-b1df-4576-bbc7-2d0c571149e9", "node_type": "1", "metadata": {}, "hash": "4e67166070733f578e33dd85b2702d6a927223342e7fd5d4bd5021b169aad72c", "class_name": "RelatedNodeInfo"}}, "text": "It copies all the pretrained\nlayers in the ResNet-18 except for the final global average pooling layer and the fully con-\nnected layer that are closest to the output.\nnet =nn.Sequential( *list (pretrained_net .children())[: -2])\nGiven an input with height and width of 320 and 480 respectively, the forward propagation\nofnetreducestheinputheightandwidthto1/32oftheoriginal,namely10and15.\nX=torch .rand(size =(1,3,320,480))\nnet(X) .shape\ntorch .Size([ 1,512,10,15])\nNext, we use a 1\u00021convolutional layer to transform the number of output channels into\nthenumberofclasses(21)ofthePascalVOC2012dataset. Finally, weneedtoincreasethe\nheight and width of the feature maps by 32 times to change them back to the height and\nwidth of the input image. Recall how to calculate the output shape of a convolutional layer\ninSection7.3 . Since\u00b9320\u000064\u00b816\u00022\u00b832\u00ba\u009d32=10and\u00b9480\u000064\u00b816\u00022\u00b832\u00ba\u009d32=15,\nweconstructatransposedconvolutionallayerwithstrideof 32,settingtheheightandwidth\nof the kernel to 64, the padding to 16. In general, we can see that for stride \ud835\udc60, padding\ud835\udc60\u009d2\n(assuming\ud835\udc60\u009d2is an integer), and the height and width of the kernel 2\ud835\udc60, the transposed\nconvolution will increase the height and width of the input by \ud835\udc60times.\n662 Computer Vision\nnum_classes =21\nnet.add_module( 'final_conv ', nn .Conv2d( 512, num_classes, kernel_size =1))\nnet.add_module( 'transpose_conv ', nn .ConvTranspose2d(num_classes, num_classes,\nkernel_size =64, padding =16, stride =32))\n14.11.2InitializingTransposedConvolutionalLayers\nWe already know that transposed convolutional layers can increase the height and width of\nfeature maps. In image processing, we may need to scale up an image, i.e., upsampling .\nBilinearinterpolation is one of the commonly used upsampling techniques. It is also often\nused for initializing transposed convolutional layers.\nTo explain bilinear interpolation, say that given an input image we want to calculate each\npixel of the upsampled output image. In order to calculate the pixel of the output image\nat coordinate\u00b9\ud835\udc65,\ud835\udc66\u00ba, first map\u00b9\ud835\udc65,\ud835\udc66\u00bato coordinate\u00b9\ud835\udc650,\ud835\udc660\u00baon the input image, for example,\naccordingtotheratiooftheinputsizetotheoutputsize. Notethatthemapped \ud835\udc650and\ud835\udc660are\nreal numbers. Then, find the four pixels closest to coordinate \u00b9\ud835\udc650,\ud835\udc660\u00baon the input image.\nFinally, the pixel of the output image at coordinate \u00b9\ud835\udc65,\ud835\udc66\u00bais calculated based on these four\nclosest pixels on the input image and their relative distance from \u00b9\ud835\udc650,\ud835\udc660\u00ba.\nUpsampling of bilinear interpolation can be implemented by the transposed convolutional\nlayer with the kernel constructed by the following bilinear_kernel function. Due to\nspace limitations, we only provide the implementation of the bilinear_kernel function\nbelow without discussions on its algorithm design.\ndef bilinear_kernel (in_channels, out_channels, kernel_size):\nfactor =(kernel_size +1)//2\nifkernel_size %2==1:\ncenter =factor -1\nelse :\ncenter =factor -0.5\nog=(torch .arange(kernel_size) .reshape( -1,1),\ntorch .arange(kernel_size) .reshape( 1,-1))\nfilt =(1-torch .abs(og[ 0]-center) /factor) *\\\n(1-torch .abs(og[ 1]-center) /factor)\nweight =torch .zeros((in_channels, out_channels,\nkernel_size, kernel_size))\nweight[ range (in_channels), range (out_channels), :, :] =filt\nreturn weight\nLet\u2019s experiment with upsampling of bilinear interpolation that is implemented by a trans-\nposed convolutional layer. We construct a transposed convolutional layer that doubles the\nheight and weight, and initialize its kernel with the bilinear_kernel function.", "mimetype": "text/plain", "start_char_idx": 1421191, "end_char_idx": 1424668, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d85ff2c0-b1df-4576-bbc7-2d0c571149e9": {"__data__": {"id_": "d85ff2c0-b1df-4576-bbc7-2d0c571149e9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8167dce3-dbed-4fd3-92cc-d7c82873d052", "node_type": "1", "metadata": {}, "hash": "9adf740860d87bbdf4004c2e53244c93cef67ecc9f75d36101891c24c38af39c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d87bea31-b41f-47b2-a169-57a99ae23454", "node_type": "1", "metadata": {}, "hash": "74b15c4544f0ba9c731f05e6ba8d3d3301aacf9cbeb3acd8be56a27e3b94ab69", "class_name": "RelatedNodeInfo"}}, "text": "We construct a transposed convolutional layer that doubles the\nheight and weight, and initialize its kernel with the bilinear_kernel function.\nconv_trans =nn.ConvTranspose2d( 3,3, kernel_size =4, padding =1, stride =2,\nbias =False )\nconv_trans .weight .data .copy_(bilinear_kernel( 3,3,4));\n663 Fully Convolutional Networks\nRead the image Xand assign the upsampling output to Y. In order to print the image, we\nneed to adjust the position of the channel dimension.\nimg =torchvision .transforms .ToTensor()(d2l .Image .open( '../img/catdog.jpg '))\nX=img.unsqueeze( 0)\nY=conv_trans(X)\nout_img =Y[0].permute( 1,2,0).detach()\nAs we can see, the transposed convolutional layer increases both the height and width of\nthe image by a factor of two. Except for the different scales in coordinates, the image\nscaled up by bilinear interpolation and the original image printed in Section 14.3 look the\nsame.\nd2l.set_figsize()\nprint ('input image shape: ', img .permute( 1,2,0).shape)\nd2l.plt.imshow(img .permute( 1,2,0));\nprint ('output image shape: ', out_img .shape)\nd2l.plt.imshow(out_img);\ninput image shape: torch .Size([ 561,728,3])\noutput image shape: torch .Size([ 1122 ,1456 ,3])\nIn a fully convolutional network, we initialize the transposed convolutional layer with up-\nsampling of bilinear interpolation. For the 1\u00021convolutional layer, we use Xavier initial-\nization.\nW=bilinear_kernel(num_classes, num_classes, 64)\nnet.transpose_conv .weight .data .copy_(W);\n14.11.3Readingthe Dataset\nWereadthesemanticsegmentationdatasetasintroducedin Section14.9 . Theoutputimage\nshapeofrandomcroppingisspecifiedas 320\u0002480: boththeheightandwidtharedivisible\nby32.\nbatch_size, crop_size =32, (320,480)\ntrain_iter, test_iter =d2l.load_data_voc(batch_size, crop_size)\n664 Computer Vision\nread 1114 examples\nread 1078 examples\n14.11.4Training\nNow we can train our constructed fully convolutional network. The loss function and ac-\ncuracy calculation here are not essentially different from those in image classification of\nearlier chapters. Because we use the output channel of the transposed convolutional layer\ntopredicttheclassforeachpixel,thechanneldimensionisspecifiedinthelosscalculation.\nInaddition,theaccuracyiscalculatedbasedoncorrectnessofthepredictedclassforallthe\npixels.\ndef loss (inputs, targets):\nreturn F.cross_entropy(inputs, targets, reduction ='none ').mean( 1).mean( 1)\nnum_epochs, lr, wd, devices =5,0.001 ,1e-3 , d2l .try_all_gpus()\ntrainer =torch .optim .SGD(net .parameters(), lr =lr, weight_decay =wd)\nd2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)\nloss 0.449 , train acc 0.861 , test acc 0.852\n226.7 examples /sec on [device( type ='cuda ', index =0), device( type ='cuda ',\u2423\n\u21a9!index =1)]\n14.11.5Prediction\nWhenpredicting,weneedtostandardizetheinputimageineachchannelandtransformthe\nimage into the four-dimensional input format required by the CNN.\ndef predict (img):\nX=test_iter .dataset .normalize_image(img) .unsqueeze( 0)\npred =net(X .to(devices[ 0])).argmax(dim =1)\nreturn pred .reshape(pred .shape[ 1], pred .shape[ 2])\nTo visualize the predicted class of each pixel, we map the predicted class back to its label\ncolor in the dataset.\n665 Fully Convolutional Networks\ndef label2image (pred):\ncolormap =torch .tensor(d2l .VOC_COLORMAP, device =devices[ 0])\nX=pred .long()\nreturn colormap[X, :]\nImages in the test dataset vary in size and shape. Since the model uses a transposed con-\nvolutional layer with stride of 32, when the height or width of an input image is indivisible\nby 32, the output height or width of the transposed convolutional layer will deviate from\nthe shape of the input image.", "mimetype": "text/plain", "start_char_idx": 1424526, "end_char_idx": 1428170, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d87bea31-b41f-47b2-a169-57a99ae23454": {"__data__": {"id_": "d87bea31-b41f-47b2-a169-57a99ae23454", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d85ff2c0-b1df-4576-bbc7-2d0c571149e9", "node_type": "1", "metadata": {}, "hash": "4e67166070733f578e33dd85b2702d6a927223342e7fd5d4bd5021b169aad72c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fdf686f2-910a-4d24-b978-7dbecb560c30", "node_type": "1", "metadata": {}, "hash": "688d0815e23af9444a26392d0bc164a94aaf631c124f3e440b3fc49ec71c0bce", "class_name": "RelatedNodeInfo"}}, "text": "665 Fully Convolutional Networks\ndef label2image (pred):\ncolormap =torch .tensor(d2l .VOC_COLORMAP, device =devices[ 0])\nX=pred .long()\nreturn colormap[X, :]\nImages in the test dataset vary in size and shape. Since the model uses a transposed con-\nvolutional layer with stride of 32, when the height or width of an input image is indivisible\nby 32, the output height or width of the transposed convolutional layer will deviate from\nthe shape of the input image. In order to address this issue, we can crop multiple rectangu-\nlar areas with height and width that are integer multiples of 32 in the image, and perform\nforward propagation on the pixels in these areas separately. Note that the union of these\nrectangular areas needs to completely cover the input image. When a pixel is covered by\nmultiple rectangular areas, the average of the transposed convolution outputs in separate\nareas for this same pixel can be input to the softmax operation to predict the class.\nForsimplicity,weonlyreadafewlargertestimages,andcropa 320\u0002480areaforprediction\nstartingfromtheupper-leftcornerofanimage. Forthesetestimages,weprinttheircropped\nareas, prediction results, and ground-truth row by row.\nvoc_dir =d2l.download_extract( 'voc2012 ','VOCdevkit/VOC2012 ')\ntest_images, test_labels =d2l.read_voc_images(voc_dir, False )\nn, imgs =4, []\nfor iinrange (n):\ncrop_rect =(0,0,320,480)\nX=torchvision .transforms .functional .crop(test_images[i], *crop_rect)\npred =label2image(predict(X))\nimgs +=[X.permute( 1,2,0), pred .cpu(),\ntorchvision .transforms .functional .crop(\ntest_labels[i], *crop_rect) .permute( 1,2,0)]\nd2l.show_images(imgs[:: 3]+imgs[ 1::3]+imgs[ 2::3],3, n, scale =2);\n\n666 Computer Vision\n22314.11.6Summary\n\u000fThe fully convolutional network first uses a CNN to extract image features, then trans-\nforms the number of channels into the number of classes via a 1\u00021convolutional\nlayer, and finally transforms the height and width of the feature maps to those of the\ninput image via the transposed convolution.\n\u000fIn a fully convolutional network, we can use upsampling of bilinear interpolation to\ninitialize the transposed convolutional layer.\n14.11.7Exercises\n1.If we use Xavier initialization for the transposed convolutional layer in the experiment,\nhow does the result change?\n2.Can you further improve the accuracy of the model by tuning the hyperparameters?\n3.Predict the classes of all pixels in test images.\n4.The original fully convolutional network paper also uses outputs of some intermediate\nCNN layers ( Longetal., 2015). Try to implement this idea.\nDiscussions223.\n14.12NeuralStyleTransfer\nIf you are a photography enthusiast, you may be familiar with the filter. It can change\nthe color style of photos so that landscape photos become sharper or portrait photos have\nwhitenedskins. However, onefilterusuallyonlychangesoneaspectofthephoto. Toapply\nan ideal style to a photo, you probably need to try many different filter combinations. This\nprocess is as complex as tuning the hyperparameters of a model.\nIn this section, we will leverage layerwise representations of a CNN to automatically apply\nthe style of one image to another image, i.e., style transfer (Gatyset al., 2016). This task\nneeds two input images: one is the content image and the other is the style image . We will\nuseneuralnetworkstomodifythecontentimagetomakeitclosetothestyleimageinstyle.\nFor example, the content image in Fig. 14.12.1 is a landscape photo taken by us in Mount\nRainierNationalParkinthesuburbsofSeattle,whilethestyleimageisanoilpaintingwith\nthe theme of autumn oak trees. In the output synthesized image, the oil brush strokes of\nthe style image are applied, leading to more vivid colors, while preserving the main shape\nof the objects in the content image.\n14.12.1Method\nFig. 14.12.2 illustrates the CNN-based style transfer method with a simplified example.\nFirst, we initialize the synthesized image, for example, into the content image. This syn-\n667 Neural Style Transfer\ntFig. 14.12.1 Given content and style images, style transfer outputs a synthesized image.", "mimetype": "text/plain", "start_char_idx": 1427709, "end_char_idx": 1431772, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fdf686f2-910a-4d24-b978-7dbecb560c30": {"__data__": {"id_": "fdf686f2-910a-4d24-b978-7dbecb560c30", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d87bea31-b41f-47b2-a169-57a99ae23454", "node_type": "1", "metadata": {}, "hash": "74b15c4544f0ba9c731f05e6ba8d3d3301aacf9cbeb3acd8be56a27e3b94ab69", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7da223b6-cb70-4999-aef0-59f2825b1ff3", "node_type": "1", "metadata": {}, "hash": "ef3e57fb3f286d3ef1d7ff1109275016121436e815329107604989e97d020374", "class_name": "RelatedNodeInfo"}}, "text": "We will\nuseneuralnetworkstomodifythecontentimagetomakeitclosetothestyleimageinstyle.\nFor example, the content image in Fig. 14.12.1 is a landscape photo taken by us in Mount\nRainierNationalParkinthesuburbsofSeattle,whilethestyleimageisanoilpaintingwith\nthe theme of autumn oak trees. In the output synthesized image, the oil brush strokes of\nthe style image are applied, leading to more vivid colors, while preserving the main shape\nof the objects in the content image.\n14.12.1Method\nFig. 14.12.2 illustrates the CNN-based style transfer method with a simplified example.\nFirst, we initialize the synthesized image, for example, into the content image. This syn-\n667 Neural Style Transfer\ntFig. 14.12.1 Given content and style images, style transfer outputs a synthesized image.\nthesizedimageistheonlyvariablethatneedstobeupdatedduringthestyletransferprocess,\ni.e.,themodelparameterstobeupdatedduringtraining. ThenwechooseapretrainedCNN\nto extract image features and freeze its model parameters during training. This deep CNN\nuses multiple layers to extract hierarchical features for images. We can choose the output\nof some of these layers as content features or style features. Take Fig. 14.12.2 as an exam-\nple. The pretrained neural network here has 3 convolutional layers, where the second layer\noutputs the content features, and the first and third layers output the style features.\ntFig. 14.12.2 CNN-based style transfer process. Solid lines show the direction of forward propagation\nand dotted lines show backward propagation.\nNext, we calculate the loss function of style transfer through forward propagation (direc-\ntion of solid arrows), and update the model parameters (the synthesized image for output)\nthrough backpropagation (direction of dashed arrows). The loss function commonly used\nin style transfer consists of three parts: (i) content loss makes the synthesized image and\nthe content image close in content features; (ii) styleloss makes the synthesized image and\nstyle image close in style features; and (iii) total variation loss helps to reduce the noise\nin the synthesized image. Finally, when the model training is over, we output the model\nparameters of the style transfer to generate the final synthesized image.\nIn the following, we will explain the technical details of style transfer via a concrete exper-\niment.\n668 Computer Vision\n14.12.2Readingthe Content and StyleImages\nFirst, we read the content and style images. From their printed coordinate axes, we can tell\nthat these images have different sizes.\n%matplotlib inline\nimport torch\nimport torchvision\nfrom torch import nn\nfrom d2l import torch asd2l\nd2l.set_figsize()\ncontent_img =d2l.Image .open( '../img/rainier.jpg ')\nd2l.plt.imshow(content_img);\nstyle_img =d2l.Image .open( '../img/autumn-oak.jpg ')\nd2l.plt.imshow(style_img);\n14.12.3Preprocessingand Postprocessing\nBelow, we define two functions for preprocessing and postprocessing images. The pre-\nprocess function standardizes each of the three RGB channels of the input image and\ntransforms the results into the CNN input format. The postprocess function restores the\npixel values in the output image to their original values before standardization. Since the\nimage printing function requires that each pixel has a floating point value from 0 to 1, we\nreplace any value smaller than 0 or greater than 1 with 0 or 1, respectively.\n669 Neural Style Transfer\nrgb_mean =torch .tensor([ 0.485 ,0.456 ,0.406 ])\nrgb_std =torch .tensor([ 0.229 ,0.224 ,0.225 ])\ndef preprocess (img, image_shape):\ntransforms =torchvision .transforms .Compose([\ntorchvision .transforms .Resize(image_shape),\ntorchvision .transforms .ToTensor(),\ntorchvision .transforms .Normalize(mean =rgb_mean, std =rgb_std)])\nreturn transforms(img) .unsqueeze( 0)\ndef postprocess (img):\nimg =img[ 0].to(rgb_std .device)\nimg =torch .clamp(img .permute( 1,2,0)*rgb_std +rgb_mean, 0,1)\nreturn torchvision .transforms .ToPILImage()(img .permute( 2,0,1))\n14.12.4Extracting Features\nWe use the VGG-19 model pretrained on the ImageNet dataset to extract image features\n(Gatysetal., 2016).", "mimetype": "text/plain", "start_char_idx": 1430994, "end_char_idx": 1435083, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7da223b6-cb70-4999-aef0-59f2825b1ff3": {"__data__": {"id_": "7da223b6-cb70-4999-aef0-59f2825b1ff3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fdf686f2-910a-4d24-b978-7dbecb560c30", "node_type": "1", "metadata": {}, "hash": "688d0815e23af9444a26392d0bc164a94aaf631c124f3e440b3fc49ec71c0bce", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d8915676-45ef-408c-8bec-f06b0ce7ab95", "node_type": "1", "metadata": {}, "hash": "77fe023604a0958a551bd82c1eaed3fd075d9be7e0b9688aa318b96614812849", "class_name": "RelatedNodeInfo"}}, "text": "pretrained_net =torchvision .models .vgg19(pretrained =True )\nDownloading: \"https://download.pytorch.org/models/vgg19-dcbb9e9d.pth\" to /home/\n\u21a9!ci/.cache/torch/hub/checkpoints/vgg19-dcbb9e9d.pth\n100%|\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff| 548M/548M [00:02<00:00, 213MB/s]\nIn order to extract the content features and style features of the image, we can select the\noutput of certain layers in the VGG network. Generally speaking, the closer to the input\nlayer, the easier to extract details of the image, and vice versa, the easier to extract the\nglobal information of the image. In order to avoid excessively retaining the details of the\ncontent image in the synthesized image, we choose a VGG layer that is closer to the output\nas thecontent layer to output the content features of the image. We also select the output\nof different VGG layers for extracting local and global style features. These layers are also\ncalledstyle layers . As mentioned in Section 8.2 , the VGG network uses 5 convolutional\nblocks. Intheexperiment,wechoosethelastconvolutionallayerofthefourthconvolutional\nblock as the content layer, and the first convolutional layer of each convolutional block as\nthestylelayer. Theindicesoftheselayerscanbeobtainedbyprintingthe pretrained_net\ninstance.\nstyle_layers, content_layers =[0,5,10,19,28], [ 25]\nWhen extracting features using VGG layers, we only need to use all those from the input\nlayer to the content layer or style layer that is closest to the output layer. Let\u2019s construct\na new network instance net, which only retains all the VGG layers to be used for feature\nextraction.\n670 Computer Vision\nnet =nn.Sequential( *[pretrained_net .features[i] for iin\nrange (max(content_layers +style_layers) +1)])\nGiven the input X, if we simply invoke the forward propagation net(X), we can only get\nthe output of the last layer. Since we also need the outputs of intermediate layers, we need\nto perform layer-by-layer computation and keep the content and style layer outputs.\ndef extract_features (X, content_layers, style_layers):\ncontents =[]\nstyles =[]\nfor iinrange (len(net)):\nX=net[i](X)\nifiinstyle_layers:\nstyles .append(X)\nifiincontent_layers:\ncontents .append(X)\nreturn contents, styles\nTwo functions are defined below: the get_contents function extracts content features\nfrom the content image, and the get_styles function extracts style features from the style\nimage. SincethereisnoneedtoupdatethemodelparametersofthepretrainedVGGduring\ntraining, we can extract the content and the style features even before the training starts.\nSince the synthesized image is a set of model parameters to be updated for style transfer,\nwe can only extract the content and style features of the synthesized image by calling the\nextract_features function during training.\ndef get_contents (image_shape, device):\ncontent_X =preprocess(content_img, image_shape) .to(device)\ncontents_Y, _ =extract_features(content_X, content_layers, style_layers)\nreturn content_X, contents_Y\ndef get_styles (image_shape, device):\nstyle_X =preprocess(style_img, image_shape) .to(device)\n_, styles_Y =extract_features(style_X, content_layers, style_layers)\nreturn style_X, styles_Y\n14.12.5Definingthe Loss Function\nNow we will describe the loss function for style transfer. The loss function consists of the\ncontent loss, style loss, and total variation loss.\nContentLoss\nSimilar to the loss function in linear regression, the content loss measures the difference in\ncontent features between the synthesized image and the content image via the squared loss\nfunction. The two inputs of the squared loss function are both outputs of the content layer\ncomputed by the extract_features function.\n671 Neural Style Transfer\ndef content_loss (Y_hat, Y):\n# We detach the target content from the tree used to dynamically compute\n# the gradient: this is a stated value, not a variable. Otherwise the loss\n# will throw an error.\nreturn torch .square(Y_hat -Y.detach()) .mean()\nStyleLoss\nStyle loss, similar to content loss, also uses the squared loss function to measure the dif-\nference in style between the synthesized image and the style image. To express the style\noutput of any style layer, we first use the extract_features function to compute the style\nlayer output.", "mimetype": "text/plain", "start_char_idx": 1435084, "end_char_idx": 1439308, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d8915676-45ef-408c-8bec-f06b0ce7ab95": {"__data__": {"id_": "d8915676-45ef-408c-8bec-f06b0ce7ab95", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7da223b6-cb70-4999-aef0-59f2825b1ff3", "node_type": "1", "metadata": {}, "hash": "ef3e57fb3f286d3ef1d7ff1109275016121436e815329107604989e97d020374", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1b293cae-24eb-4a25-a5f4-15f93546f2b7", "node_type": "1", "metadata": {}, "hash": "ab11455510a784b6dd41b2ae7e39bc0c4b9a7e50167b95282491552af73ab0bf", "class_name": "RelatedNodeInfo"}}, "text": "ContentLoss\nSimilar to the loss function in linear regression, the content loss measures the difference in\ncontent features between the synthesized image and the content image via the squared loss\nfunction. The two inputs of the squared loss function are both outputs of the content layer\ncomputed by the extract_features function.\n671 Neural Style Transfer\ndef content_loss (Y_hat, Y):\n# We detach the target content from the tree used to dynamically compute\n# the gradient: this is a stated value, not a variable. Otherwise the loss\n# will throw an error.\nreturn torch .square(Y_hat -Y.detach()) .mean()\nStyleLoss\nStyle loss, similar to content loss, also uses the squared loss function to measure the dif-\nference in style between the synthesized image and the style image. To express the style\noutput of any style layer, we first use the extract_features function to compute the style\nlayer output. Suppose that the output has 1 example, \ud835\udc50channels, height \u210e, and width\ud835\udc64, we\ncan transform this output into matrix Xwith\ud835\udc50rows and\u210e\ud835\udc64columns. This matrix can be\nthought of as the concatenation of \ud835\udc50vectors x1,...,x\ud835\udc50, each of which has a length of \u210e\ud835\udc64.\nHere, vector x\ud835\udc56represents the style feature of channel \ud835\udc56.\nIn theGram matrix of these vectors XX>2R\ud835\udc50\u0002\ud835\udc50, element\ud835\udc65\ud835\udc56\ud835\udc57in row\ud835\udc56and column \ud835\udc57is\nthe dot product of vectors x\ud835\udc56andx\ud835\udc57. It represents the correlation of the style features of\nchannels\ud835\udc56and\ud835\udc57. We use this Gram matrix to represent the style output of any style layer.\nNote that when the value of \u210e\ud835\udc64is larger, it likely leads to larger values in the Gram matrix.\nNote also that the height and width of the Gram matrix are both the number of channels \ud835\udc50.\nTo allow style loss not to be affected by these values, the gramfunction below divides the\nGram matrix by the number of its elements, i.e., \ud835\udc50\u210e\ud835\udc64.\ndef gram (X):\nnum_channels, n =X.shape[ 1], X .numel() //X.shape[ 1]\nX=X.reshape((num_channels, n))\nreturn torch .matmul(X, X .T)/(num_channels *n)\nObviously, the two Gram matrix inputs of the squared loss function for style loss are based\non the style layer outputs for the synthesized image and the style image. It is assumed here\nthat the Gram matrix gram_Ybased on the style image has been precomputed.\ndef style_loss (Y_hat, gram_Y):\nreturn torch .square(gram(Y_hat) -gram_Y .detach()) .mean()\nTotal VariationLoss\nSometimes, the learned synthesized image has a lot of high-frequency noise, i.e., particu-\nlarly bright or dark pixels. One common noise reduction method is total variation denois-\ning. Denoteby\ud835\udc65\ud835\udc56,\ud835\udc57thepixelvalueatcoordinate \u00b9\ud835\udc56,\ud835\udc57\u00ba. Reducingtotalvariationloss\n\u00d5\n\ud835\udc56,\ud835\udc57\f\f\ud835\udc65\ud835\udc56,\ud835\udc57\u0000\ud835\udc65\ud835\udc56\u00b81,\ud835\udc57\f\f\u00b8\f\f\ud835\udc65\ud835\udc56,\ud835\udc57\u0000\ud835\udc65\ud835\udc56,\ud835\udc57\u00b81\f\f(14.12.1)\nmakes values of neighboring pixels on the synthesized image closer.\n672 Computer Vision\ndef tv_loss (Y_hat):\nreturn 0.5 *(torch .abs(Y_hat[:, :, 1:, :] -Y_hat[:, :, : -1, :]) .mean() +\ntorch .abs(Y_hat[:, :, :, 1:]-Y_hat[:, :, :, : -1]).mean())\nLoss Function\nThe loss function of style transfer is the weighted sum of content loss, style loss, and total\nvariation loss. By adjusting these weight hyperparameters, we can balance among content\nretention, style transfer, and noise reduction on the synthesized image.", "mimetype": "text/plain", "start_char_idx": 1438406, "end_char_idx": 1441536, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1b293cae-24eb-4a25-a5f4-15f93546f2b7": {"__data__": {"id_": "1b293cae-24eb-4a25-a5f4-15f93546f2b7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d8915676-45ef-408c-8bec-f06b0ce7ab95", "node_type": "1", "metadata": {}, "hash": "77fe023604a0958a551bd82c1eaed3fd075d9be7e0b9688aa318b96614812849", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b275dc52-6c6a-44c9-9c56-1dafb2bd36ee", "node_type": "1", "metadata": {}, "hash": "d20de2a48e003fb9a304c85072e9f1393970954a278e32b02c2f58da77ab467a", "class_name": "RelatedNodeInfo"}}, "text": "672 Computer Vision\ndef tv_loss (Y_hat):\nreturn 0.5 *(torch .abs(Y_hat[:, :, 1:, :] -Y_hat[:, :, : -1, :]) .mean() +\ntorch .abs(Y_hat[:, :, :, 1:]-Y_hat[:, :, :, : -1]).mean())\nLoss Function\nThe loss function of style transfer is the weighted sum of content loss, style loss, and total\nvariation loss. By adjusting these weight hyperparameters, we can balance among content\nretention, style transfer, and noise reduction on the synthesized image.\ncontent_weight, style_weight, tv_weight =1,1e4,10\ndef compute_loss (X, contents_Y_hat, styles_Y_hat, contents_Y, styles_Y_gram):\n# Calculate the content, style, and total variance losses respectively\ncontents_l =[content_loss(Y_hat, Y) *content_weight for Y_hat, Y inzip(\ncontents_Y_hat, contents_Y)]\nstyles_l =[style_loss(Y_hat, Y) *style_weight for Y_hat, Y inzip(\nstyles_Y_hat, styles_Y_gram)]\ntv_l =tv_loss(X) *tv_weight\n# Add up all the losses\nl=sum(styles_l +contents_l +[tv_l])\nreturn contents_l, styles_l, tv_l, l\n14.12.6Initializing the Synthesized Image\nIn style transfer, the synthesized image is the only variable that needs to be updated during\ntraining. Thus, we can define a simple model, SynthesizedImage , and treat the synthe-\nsized image as the model parameters. In this model, forward propagation just returns the\nmodel parameters.\nclass SynthesizedImage (nn.Module):\ndef __init__ (self , img_shape, **kwargs):\nsuper (SynthesizedImage, self ).__init__ (**kwargs)\nself .weight =nn.Parameter(torch .rand( *img_shape))\ndef forward (self ):\nreturn self .weight\nNext, we define the get_inits function. This function creates a synthesized image model\ninstance and initializes it to the image X. Gram matrices for the style image at various style\nlayers, styles_Y_gram , are computed prior to training.\ndef get_inits (X, device, lr, styles_Y):\ngen_img =SynthesizedImage(X .shape) .to(device)\ngen_img .weight .data .copy_(X .data)\ntrainer =torch .optim .Adam(gen_img .parameters(), lr =lr)\nstyles_Y_gram =[gram(Y) for Yinstyles_Y]\nreturn gen_img(), styles_Y_gram, trainer\n673 Neural Style Transfer\n14.12.7Training\nWhen training the model for style transfer, we continuously extract content features and\nstyle features of the synthesized image, and calculate the loss function. Below defines the\ntraining loop.\ndef train (X, contents_Y, styles_Y, device, lr, num_epochs, lr_decay_epoch):\nX, styles_Y_gram, trainer =get_inits(X, device, lr, styles_Y)\nscheduler =torch .optim .lr_scheduler .StepLR(trainer, lr_decay_epoch, 0.8)\nanimator =d2l.Animator(xlabel ='epoch ', ylabel ='loss ',\nxlim =[10, num_epochs],\nlegend =['content ','style ','TV'],\nncols =2, figsize =(7,2.5))\nfor epoch inrange (num_epochs):\ntrainer .zero_grad()\ncontents_Y_hat, styles_Y_hat =extract_features(\nX, content_layers, style_layers)\ncontents_l, styles_l, tv_l, l =compute_loss(\nX, contents_Y_hat, styles_Y_hat, contents_Y, styles_Y_gram)\nl.backward()\ntrainer .step()\nscheduler .step()\nif(epoch +1)%10==0:\nanimator .axes[ 1].imshow(postprocess(X))\nanimator .add(epoch +1, [float (sum(contents_l)),\nfloat (sum(styles_l)), float (tv_l)])\nreturn X\nNow we start to train the model. We rescale the height and width of the content and style\nimages to 300 by 450 pixels. We use the content image to initialize the synthesized im-\nage.\ndevice, image_shape =d2l.try_gpu(), ( 300,450)# PIL Image (h, w)\nnet =net.to(device)\ncontent_X, contents_Y =get_contents(image_shape, device)\n_, styles_Y =get_styles(image_shape, device)\noutput =train(content_X, contents_Y, styles_Y, device, 0.3,500,50)\nWecanseethatthesynthesizedimageretainsthesceneryandobjectsofthecontentimage,\nand transfers the color of the style image at the same time. For example, the synthesized\n674 Computer Vision\n224image has blocks of color like those in the style image. Some of these blocks even have the\nsubtle texture of brush strokes.", "mimetype": "text/plain", "start_char_idx": 1441090, "end_char_idx": 1444916, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b275dc52-6c6a-44c9-9c56-1dafb2bd36ee": {"__data__": {"id_": "b275dc52-6c6a-44c9-9c56-1dafb2bd36ee", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1b293cae-24eb-4a25-a5f4-15f93546f2b7", "node_type": "1", "metadata": {}, "hash": "ab11455510a784b6dd41b2ae7e39bc0c4b9a7e50167b95282491552af73ab0bf", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "731e143c-8837-4cef-85ec-9b5cbec72510", "node_type": "1", "metadata": {}, "hash": "d0b85a60ac562400b69b41a57656e69edfd587fd26376441f8212d4e626bfe26", "class_name": "RelatedNodeInfo"}}, "text": "We rescale the height and width of the content and style\nimages to 300 by 450 pixels. We use the content image to initialize the synthesized im-\nage.\ndevice, image_shape =d2l.try_gpu(), ( 300,450)# PIL Image (h, w)\nnet =net.to(device)\ncontent_X, contents_Y =get_contents(image_shape, device)\n_, styles_Y =get_styles(image_shape, device)\noutput =train(content_X, contents_Y, styles_Y, device, 0.3,500,50)\nWecanseethatthesynthesizedimageretainsthesceneryandobjectsofthecontentimage,\nand transfers the color of the style image at the same time. For example, the synthesized\n674 Computer Vision\n224image has blocks of color like those in the style image. Some of these blocks even have the\nsubtle texture of brush strokes.\n14.12.8Summary\n\u000fThelossfunctioncommonlyusedinstyletransferconsistsofthreeparts: (i)contentloss\nmakesthesynthesizedimageandthecontentimagecloseincontentfeatures; (ii)style\nlossmakesthesynthesizedimageandstyleimagecloseinstylefeatures; and(iii)total\nvariation loss helps to reduce the noise in the synthesized image.\n\u000fWe can use a pretrained CNN to extract image features and minimize the loss function\nto continuously update the synthesized image as model parameters during training.\n\u000fWe use Gram matrices to represent the style outputs from the style layers.\n14.12.9Exercises\n1.How does the output change when you select different content and style layers?\n2.Adjust the weight hyperparameters in the loss function. Does the output retain more\ncontent or have less noise?\n3.Use different content and style images. Can you create more interesting synthesized\nimages?\n4.Can we apply style transfer for text? Hint: you may refer to the survey paper by Hu et\nal.(2022).\nDiscussions224.\n14.13ImageClassification (CIFAR-10)on Kaggle\nSo far, we have been using high-level APIs of deep learning frameworks to directly obtain\nimage datasets in tensor format. However, custom image datasets often come in the form\nof image files. In this section, we will start from raw image files, and organize, read, then\ntransform them into tensor format step by step.\nWeexperimentedwiththeCIFAR-10datasetin Section14.1 ,whichisanimportantdataset\nin computer vision. In this section, we will apply the knowledge we learned in previous\nsections to practice the Kaggle competition of CIFAR-10 image classification. The web\naddress of the competition is https://www.kaggle.com/c/cifar-10\nFig. 14.13.1 shows the information on the competition\u2019s webpage. In order to submit the\nresults, you need to register a Kaggle account.\n675 Image Classi\ufb01cation (CIFAR-10) on Kaggle\ntFig. 14.13.1 CIFAR-10 image classi\ufb01cation competition webpage information. The competition\ndataset can be obtained by clicking the \u201cData\u201d tab.\nimport collections\nimport math\nimport os\nimport shutil\nimport pandas aspd\nimport torch\nimport torchvision\nfrom torch import nn\nfrom d2l import torch asd2l\n14.13.1Obtaining and Organizingthe Dataset\nThe competition dataset is divided into a training set and a test set, which contain 50000\nand 300000 images, respectively. In the test set, 10000 images will be used for evaluation,\nwhile the remaining 290000 images will not be evaluated: they are included just to make\nit hard to cheat with manually labeled results of the test set. The images in this dataset\nare all png color (RGB channels) image files, whose height and width are both 32 pixels.\nThe images cover a total of 10 categories, namely airplanes, cars, birds, cats, deer, dogs,\nfrogs, horses, boats, and trucks. The upper-left corner of Fig. 14.13.1 shows some images\nof airplanes, cars, and birds in the dataset.\nDownloadingthe Dataset\nAfter logging in to Kaggle, we can click the \u201cData\u201d tab on the CIFAR-10 image classifi-\ncation competition webpage shown in Fig. 14.13.1 and download the dataset by clicking\nthe \u201cDownload All\u201d button.", "mimetype": "text/plain", "start_char_idx": 1444198, "end_char_idx": 1448003, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "731e143c-8837-4cef-85ec-9b5cbec72510": {"__data__": {"id_": "731e143c-8837-4cef-85ec-9b5cbec72510", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b275dc52-6c6a-44c9-9c56-1dafb2bd36ee", "node_type": "1", "metadata": {}, "hash": "d20de2a48e003fb9a304c85072e9f1393970954a278e32b02c2f58da77ab467a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "404162c3-2736-4fe6-b571-41b7751a7fff", "node_type": "1", "metadata": {}, "hash": "78940fd9f223f39767f0ad533f0325617119c11e0549246edf32464917217d85", "class_name": "RelatedNodeInfo"}}, "text": "In the test set, 10000 images will be used for evaluation,\nwhile the remaining 290000 images will not be evaluated: they are included just to make\nit hard to cheat with manually labeled results of the test set. The images in this dataset\nare all png color (RGB channels) image files, whose height and width are both 32 pixels.\nThe images cover a total of 10 categories, namely airplanes, cars, birds, cats, deer, dogs,\nfrogs, horses, boats, and trucks. The upper-left corner of Fig. 14.13.1 shows some images\nof airplanes, cars, and birds in the dataset.\nDownloadingthe Dataset\nAfter logging in to Kaggle, we can click the \u201cData\u201d tab on the CIFAR-10 image classifi-\ncation competition webpage shown in Fig. 14.13.1 and download the dataset by clicking\nthe \u201cDownload All\u201d button. After unzipping the downloaded file in ../data , and un-\nzipping train.7z andtest.7z inside it, you will find the entire dataset in the following\npaths:\n\u000f../data/cifar-10/train/[1-50000].png\n\u000f../data/cifar-10/test/[1-300000].png\n676 Computer Vision\n\u000f../data/cifar-10/trainLabels.csv\n\u000f../data/cifar-10/sampleSubmission.csv\nwherethe trainandtestdirectories containthe trainingand testingimages, respectively,\ntrainLabels.csv provides labels for the training images, and sample_submission.csv\nis a sample submission file.\nTomakeiteasiertogetstarted,weprovideasmall-scalesampleofthedatasetthatcontains\nthe first 1000 training images and 5 random testing images. To use the full dataset of the\nKaggle competition, you need to set the following demovariable to False.\n#@save\nd2l.DATA_HUB[ 'cifar10_tiny ']=(d2l .DATA_URL +'kaggle_cifar10_tiny.zip ',\n'2068874e4b9a9f0fb07ebe0ad2b29754449ccacd ')\n# If you use the full dataset downloaded for the Kaggle competition, set\n# `demo` to False\ndemo =True\nifdemo:\ndata_dir =d2l.download_extract( 'cifar10_tiny ')\nelse :\ndata_dir ='../data/cifar-10/ '\nDownloading ../data /kaggle_cifar10_tiny .zip from http ://d2l-data .s3-accelerate .\n\u21a9!amazonaws .com/kaggle_cifar10_tiny .zip...\nOrganizingthe Dataset\nWe need to organize datasets to facilitate model training and testing. Let\u2019s first read the\nlabels from the csv file. The following function returns a dictionary that maps the non-\nextension part of the filename to its label.\n#@save\ndef read_csv_labels (fname):\n\"\"\"Read `fname` to return a filename to label dictionary.\"\"\"\nwith open (fname, 'r')asf:\n# Skip the file header line (column name)\nlines =f.readlines()[ 1:]\ntokens =[l.rstrip() .split( ',')for linlines]\nreturn dict (((name, label) for name, label intokens))\nlabels =read_csv_labels(os .path .join(data_dir, 'trainLabels.csv '))\nprint ('# training examples: ',len(labels))\nprint ('# classes: ',len(set(labels .values())))\n# training examples: 1000\n# classes: 10\n677 Image Classi\ufb01cation (CIFAR-10) on Kaggle\nNext,wedefinethe reorg_train_valid functiontosplitthevalidationsetoutoftheorig-\ninal training set. The argument valid_ratio in this function is the ratio of the number\nof examples in the validation set to the number of examples in the original training set.\nMore concretely, let \ud835\udc5bbe the number of images of the class with the least examples, and\n\ud835\udc5fbe the ratio. The validation set will split out max\u00b9b\ud835\udc5b\ud835\udc5fc,1\u00baimages for each class. Let\u2019s\nusevalid_ratio=0.1 as an example. Since the original training set has 50000 images,\nthere will be 45000 images used for training in the path train_valid_test/train , while\nthe other 5000 images will be split out as validation set in the path train_valid_test/\nvalid. Afterorganizingthedataset,imagesofthesameclasswillbeplacedunderthesame\nfolder.\n#@save\ndef copyfile (filename, target_dir):\n\"\"\"Copy a file into a target directory.\"\"\"", "mimetype": "text/plain", "start_char_idx": 1447225, "end_char_idx": 1450876, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "404162c3-2736-4fe6-b571-41b7751a7fff": {"__data__": {"id_": "404162c3-2736-4fe6-b571-41b7751a7fff", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "731e143c-8837-4cef-85ec-9b5cbec72510", "node_type": "1", "metadata": {}, "hash": "d0b85a60ac562400b69b41a57656e69edfd587fd26376441f8212d4e626bfe26", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "eb48d6dd-d417-496d-8f2c-2a44c91bb67e", "node_type": "1", "metadata": {}, "hash": "1092fae78ff24f9c7d9726b13c5a6a23fbb1d34cfa1b7a52408104685d29d81d", "class_name": "RelatedNodeInfo"}}, "text": "The argument valid_ratio in this function is the ratio of the number\nof examples in the validation set to the number of examples in the original training set.\nMore concretely, let \ud835\udc5bbe the number of images of the class with the least examples, and\n\ud835\udc5fbe the ratio. The validation set will split out max\u00b9b\ud835\udc5b\ud835\udc5fc,1\u00baimages for each class. Let\u2019s\nusevalid_ratio=0.1 as an example. Since the original training set has 50000 images,\nthere will be 45000 images used for training in the path train_valid_test/train , while\nthe other 5000 images will be split out as validation set in the path train_valid_test/\nvalid. Afterorganizingthedataset,imagesofthesameclasswillbeplacedunderthesame\nfolder.\n#@save\ndef copyfile (filename, target_dir):\n\"\"\"Copy a file into a target directory.\"\"\"\nos.makedirs(target_dir, exist_ok =True )\nshutil .copy(filename, target_dir)\n#@save\ndef reorg_train_valid (data_dir, labels, valid_ratio):\n\"\"\"Split the validation set out of the original training set.\"\"\"\n# The number of examples of the class that has the fewest examples in the\n# training dataset\nn=collections .Counter(labels .values()) .most_common()[ -1][1]\n# The number of examples per class for the validation set\nn_valid_per_label =max(1, math .floor(n *valid_ratio))\nlabel_count ={}\nfor train_file inos.listdir(os .path .join(data_dir, 'train ')):\nlabel =labels[train_file .split( '.')[0]]\nfname =os.path .join(data_dir, 'train ', train_file)\ncopyfile(fname, os .path .join(data_dir, 'train_valid_test ',\n'train_valid ', label))\niflabel not inlabel_count orlabel_count[label] <n_valid_per_label:\ncopyfile(fname, os .path .join(data_dir, 'train_valid_test ',\n'valid ', label))\nlabel_count[label] =label_count .get(label, 0)+1\nelse :\ncopyfile(fname, os .path .join(data_dir, 'train_valid_test ',\n'train ', label))\nreturn n_valid_per_label\nThereorg_test function below organizes the testing set for data loading during predic-\ntion.\n#@save\ndef reorg_test (data_dir):\n\"\"\"Organize the testing set for data loading during prediction.\"\"\"\nfor test_file inos.listdir(os .path .join(data_dir, 'test ')):\ncopyfile(os .path .join(data_dir, 'test ', test_file),\nos.path .join(data_dir, 'train_valid_test ','test ',\n'unknown '))\n678 Computer Vision\nFinally, we use a function to invoke the read_csv_labels ,reorg_train_valid , and re-\norg_test functions defined above.\ndef reorg_cifar10_data (data_dir, valid_ratio):\nlabels =read_csv_labels(os .path .join(data_dir, 'trainLabels.csv '))\nreorg_train_valid(data_dir, labels, valid_ratio)\nreorg_test(data_dir)\nHere we only set the batch size to 32 for the small-scale sample of the dataset. When\ntraining and testing the complete dataset of the Kaggle competition, batch_size should\nbe set to a larger integer, such as 128. We split out 10% of the training examples as the\nvalidation set for tuning hyperparameters.\nbatch_size =32ifdemo else 128\nvalid_ratio =0.1\nreorg_cifar10_data(data_dir, valid_ratio)\n14.13.2ImageAugmentation\nWeuseimageaugmentationtoaddressoverfitting. Forexample,imagescanbeflippedhor-\nizontallyatrandomduringtraining. WecanalsoperformstandardizationforthethreeRGB\nchannels of color images. Below lists some of these operations that you can tweak.", "mimetype": "text/plain", "start_char_idx": 1450108, "end_char_idx": 1453285, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "eb48d6dd-d417-496d-8f2c-2a44c91bb67e": {"__data__": {"id_": "eb48d6dd-d417-496d-8f2c-2a44c91bb67e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "404162c3-2736-4fe6-b571-41b7751a7fff", "node_type": "1", "metadata": {}, "hash": "78940fd9f223f39767f0ad533f0325617119c11e0549246edf32464917217d85", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "dcb7d909-bab1-461b-aff3-488736260ea2", "node_type": "1", "metadata": {}, "hash": "56ae7bdbedc0e9c8afef3581d0b4739f49d851bad24a8d5c88d521324fb78eff", "class_name": "RelatedNodeInfo"}}, "text": "When\ntraining and testing the complete dataset of the Kaggle competition, batch_size should\nbe set to a larger integer, such as 128. We split out 10% of the training examples as the\nvalidation set for tuning hyperparameters.\nbatch_size =32ifdemo else 128\nvalid_ratio =0.1\nreorg_cifar10_data(data_dir, valid_ratio)\n14.13.2ImageAugmentation\nWeuseimageaugmentationtoaddressoverfitting. Forexample,imagescanbeflippedhor-\nizontallyatrandomduringtraining. WecanalsoperformstandardizationforthethreeRGB\nchannels of color images. Below lists some of these operations that you can tweak.\ntransform_train =torchvision .transforms .Compose([\n# Scale the image up to a square of 40 pixels in both height and width\ntorchvision .transforms .Resize( 40),\n# Randomly crop a square image of 40 pixels in both height and width to\n# produce a small square of 0.64 to 1 times the area of the original\n# image, and then scale it to a square of 32 pixels in both height and\n# width\ntorchvision .transforms .RandomResizedCrop( 32, scale =(0.64 ,1.0),\nratio =(1.0,1.0)),\ntorchvision .transforms .RandomHorizontalFlip(),\ntorchvision .transforms .ToTensor(),\n# Standardize each channel of the image\ntorchvision .transforms .Normalize([ 0.4914 ,0.4822 ,0.4465 ],\n[0.2023 ,0.1994 ,0.2010 ])])\nDuring testing, we only perform standardization on images so as to remove randomness in\nthe evaluation results.\ntransform_test =torchvision .transforms .Compose([\ntorchvision .transforms .ToTensor(),\ntorchvision .transforms .Normalize([ 0.4914 ,0.4822 ,0.4465 ],\n[0.2023 ,0.1994 ,0.2010 ])])\n14.13.3Readingthe Dataset\nNext, we read the organized dataset consisting of raw image files. Each example includes\nan image and a label.\n679 Image Classi\ufb01cation (CIFAR-10) on Kaggle\ntrain_ds, train_valid_ds =[torchvision .datasets .ImageFolder(\nos.path .join(data_dir, 'train_valid_test ', folder),\ntransform =transform_train) for folder in['train ','train_valid ']]\nvalid_ds, test_ds =[torchvision .datasets .ImageFolder(\nos.path .join(data_dir, 'train_valid_test ', folder),\ntransform =transform_test) for folder in['valid ','test ']]\nDuring training, we need to specify all the image augmentation operations defined above.\nWhen the validation set is used for model evaluation during hyperparameter tuning, no\nrandomness from image augmentation should be introduced. Before final prediction, we\ntrain the model on the combined training set and validation set to make full use of all the\nlabeled data.\ntrain_iter, train_valid_iter =[torch .utils .data .DataLoader(\ndataset, batch_size, shuffle =True , drop_last =True )\nfor dataset in(train_ds, train_valid_ds)]\nvalid_iter =torch .utils .data .DataLoader(valid_ds, batch_size, shuffle =False ,\ndrop_last =True )\ntest_iter =torch .utils .data .DataLoader(test_ds, batch_size, shuffle =False ,\ndrop_last =False )\n14.13.4Defining the Model\nWe define the ResNet-18 model described in Section 8.6 .\ndef get_net ():\nnum_classes =10\nnet =d2l.resnet18(num_classes, 3)\nreturn net\nloss =nn.CrossEntropyLoss(reduction =\"none \")\n14.13.5Defining the TrainingFunction\nWe will select models and tune hyperparameters according to the model\u2019s performance on\nthe validation set. In the following, we define the model training function train.", "mimetype": "text/plain", "start_char_idx": 1452707, "end_char_idx": 1455938, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dcb7d909-bab1-461b-aff3-488736260ea2": {"__data__": {"id_": "dcb7d909-bab1-461b-aff3-488736260ea2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "eb48d6dd-d417-496d-8f2c-2a44c91bb67e", "node_type": "1", "metadata": {}, "hash": "1092fae78ff24f9c7d9726b13c5a6a23fbb1d34cfa1b7a52408104685d29d81d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8391ed98-00ee-451e-9a03-b801190d5456", "node_type": "1", "metadata": {}, "hash": "235cb6e6b3c4dacf0345967242558f764cf977f75d5861a0d325e31c3db2aa53", "class_name": "RelatedNodeInfo"}}, "text": "train_iter, train_valid_iter =[torch .utils .data .DataLoader(\ndataset, batch_size, shuffle =True , drop_last =True )\nfor dataset in(train_ds, train_valid_ds)]\nvalid_iter =torch .utils .data .DataLoader(valid_ds, batch_size, shuffle =False ,\ndrop_last =True )\ntest_iter =torch .utils .data .DataLoader(test_ds, batch_size, shuffle =False ,\ndrop_last =False )\n14.13.4Defining the Model\nWe define the ResNet-18 model described in Section 8.6 .\ndef get_net ():\nnum_classes =10\nnet =d2l.resnet18(num_classes, 3)\nreturn net\nloss =nn.CrossEntropyLoss(reduction =\"none \")\n14.13.5Defining the TrainingFunction\nWe will select models and tune hyperparameters according to the model\u2019s performance on\nthe validation set. In the following, we define the model training function train.\ndef train (net, train_iter, valid_iter, num_epochs, lr, wd, devices, lr_period,\nlr_decay):\ntrainer =torch .optim .SGD(net .parameters(), lr =lr, momentum =0.9,\nweight_decay =wd)\nscheduler =torch .optim .lr_scheduler .StepLR(trainer, lr_period, lr_decay)\nnum_batches, timer =len(train_iter), d2l .Timer()\nlegend =['train loss ','train acc ']\nifvalid_iter isnot None :\nlegend .append( 'valid acc ')\n(continues on next page)\n680 Computer Vision\n(continued from previous page)\nanimator =d2l.Animator(xlabel ='epoch ', xlim =[1, num_epochs],\nlegend =legend)\nnet =nn.DataParallel(net, device_ids =devices) .to(devices[ 0])\nfor epoch inrange (num_epochs):\nnet.train()\nmetric =d2l.Accumulator( 3)\nfor i, (features, labels) inenumerate (train_iter):\ntimer .start()\nl, acc =d2l.train_batch_ch13(net, features, labels,\nloss, trainer, devices)\nmetric .add(l, acc, labels .shape[ 0])\ntimer .stop()\nif(i+1)%(num_batches //5)==0ori==num_batches -1:\nanimator .add(epoch +(i+1)/num_batches,\n(metric[ 0]/metric[ 2], metric[ 1]/metric[ 2],\nNone ))\nifvalid_iter isnot None :\nvalid_acc =d2l.evaluate_accuracy_gpu(net, valid_iter)\nanimator .add(epoch +1, (None ,None , valid_acc))\nscheduler .step()\nmeasures =(f'train loss {metric[ 0]/metric[ 2]:.3f},'\nf'train acc {metric[ 1]/metric[ 2]:.3f}')\nifvalid_iter isnot None :\nmeasures +=f', valid acc {valid_acc :.3f}'\nprint (measures +f'\\n{metric[ 2]*num_epochs /timer .sum() :.1f}'\nf'examples/sec on {str(devices) }')\n14.13.6Trainingand Validatingthe Model\nNow, wecantrainandvalidatethemodel. Allthefollowinghyperparameterscanbetuned.\nFor example, we can increase the number of epochs. When lr_period andlr_decay\nare set to 4 and 0.9, respectively, the learning rate of the optimization algorithm will be\nmultiplied by 0.9 after every 4 epochs. Just for ease of demonstration, we only train 20\nepochs here.\ndevices, num_epochs, lr, wd =d2l.try_all_gpus(), 20,2e-4 ,5e-4\nlr_period, lr_decay, net =4,0.9, get_net()\nnet( next (iter (train_iter))[ 0])\ntrain(net, train_iter, valid_iter, num_epochs, lr, wd, devices, lr_period,\nlr_decay)\ntrain loss 0.654 , train acc 0.789 , valid acc 0.438\n958.1 examples /sec on [device( type ='cuda ', index =0), device( type ='cuda ',\u2423\n\u21a9!index =1)]\n14.13.7Classifying the TestingSetand Submitting Resultson Kaggle\nAfter obtaining a promising model with hyperparameters, we use all the labeled data (in-\ncluding the validation set) to retrain the model and classify the testing set.", "mimetype": "text/plain", "start_char_idx": 1455167, "end_char_idx": 1458377, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8391ed98-00ee-451e-9a03-b801190d5456": {"__data__": {"id_": "8391ed98-00ee-451e-9a03-b801190d5456", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "dcb7d909-bab1-461b-aff3-488736260ea2", "node_type": "1", "metadata": {}, "hash": "56ae7bdbedc0e9c8afef3581d0b4739f49d851bad24a8d5c88d521324fb78eff", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "61ffb61d-ad1b-42d9-be24-10c966579ce2", "node_type": "1", "metadata": {}, "hash": "c64af7481ddf6e01ad5f4e7ac59c7905840bf9577baa3a6cfd909cb2d8b66558", "class_name": "RelatedNodeInfo"}}, "text": "devices, num_epochs, lr, wd =d2l.try_all_gpus(), 20,2e-4 ,5e-4\nlr_period, lr_decay, net =4,0.9, get_net()\nnet( next (iter (train_iter))[ 0])\ntrain(net, train_iter, valid_iter, num_epochs, lr, wd, devices, lr_period,\nlr_decay)\ntrain loss 0.654 , train acc 0.789 , valid acc 0.438\n958.1 examples /sec on [device( type ='cuda ', index =0), device( type ='cuda ',\u2423\n\u21a9!index =1)]\n14.13.7Classifying the TestingSetand Submitting Resultson Kaggle\nAfter obtaining a promising model with hyperparameters, we use all the labeled data (in-\ncluding the validation set) to retrain the model and classify the testing set.\n681 Image Classi\ufb01cation (CIFAR-10) on Kaggle\nnet, preds =get_net(), []\nnet( next (iter (train_valid_iter))[ 0])\ntrain(net, train_valid_iter, None , num_epochs, lr, wd, devices, lr_period,\nlr_decay)\nfor X, _ intest_iter:\ny_hat =net(X .to(devices[ 0]))\npreds .extend(y_hat .argmax(dim =1).type(torch .int32) .cpu() .numpy())\nsorted_ids =list (range (1,len(test_ds) +1))\nsorted_ids .sort(key =lambda x:str(x))\ndf=pd.DataFrame({ 'id': sorted_ids, 'label ': preds})\ndf['label ']=df['label '].apply( lambda x: train_valid_ds .classes[x])\ndf.to_csv( 'submission.csv ', index =False )\ntrain loss 0.608 , train acc 0.786\n1040.8 examples /sec on [device( type ='cuda ', index =0), device( type ='cuda ',\u2423\n\u21a9!index =1)]\nThe abovecode will generatea submission.csv file, whose format meets the requirement\nof the Kaggle competition. The method for submitting results to Kaggle is similar to that\ninSection 5.7 .\n14.13.8Summary\n\u000fWe can read datasets containing raw image files after organizing them into the required\nformat.\n682 Computer Vision\n225\u000fWe can use convolutional neural networks and image augmentation in an image classi-\nfication competition.\n14.13.9Exercises\n1.Use the complete CIFAR-10 dataset for this Kaggle competition. Set hyperparameters\nasbatch_size = 128 ,num_epochs = 100 ,lr = 0.1 ,lr_period = 50 ,and lr_decay\n= 0.1. See what accuracy and ranking you can achieve in this competition. Can you\nfurther improve them?\n2.What accuracy can you get when not using image augmentation?\nDiscussions225.\n14.14Dog BreedIdentification (ImageNetDogs) on\nKaggle\nIn this section, we will practice the dog breed identification problem on Kaggle. The web\naddress of this competition is https://www.kaggle.com/c/dog-breed-identification\nIn this competition, 120 different breeds of dogs will be recognized. In fact, the dataset for\nthis competition is a subset of the ImageNet dataset. Unlike the images in the CIFAR-10\ndataset in Section 14.13 , the images in the ImageNet dataset are both higher and wider in\nvarying dimensions. Fig. 14.14.1 shows the information on the competition\u2019s webpage.\nYou need a Kaggle account to submit your results.\nimport os\nimport torch\nimport torchvision\nfrom torch import nn\nfrom d2l import torch asd2l\n14.14.1Obtaining and Organizingthe Dataset\nThe competition dataset is divided into a training set and a test set, which contain 10222\nand 10357 JPEG images of three RGB (color) channels, respectively. Among the training\ndataset, there are 120 breeds of dogs such as Labradors, Poodles, Dachshunds, Samoyeds,\nHuskies, Chihuahuas, and Yorkshire Terriers.\nDownloadingthe Dataset\nAfter logging into Kaggle, you can click on the \u201cData\u201d tab on the competition webpage\nshown in Fig. 14.14.1 and download the dataset by clicking the \u201cDownload All\u201d button.\nAfter unzipping the downloaded file in ../data , you will find the entire dataset in the\nfollowing paths:\n683 Dog Breed Identi\ufb01cation (ImageNet Dogs) on Kaggle\ntFig. 14.14.1 The dog breed identi\ufb01cation competition website. The competition dataset can be\nobtained by clicking the \u201cData\u201d tab.", "mimetype": "text/plain", "start_char_idx": 1457771, "end_char_idx": 1461444, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "61ffb61d-ad1b-42d9-be24-10c966579ce2": {"__data__": {"id_": "61ffb61d-ad1b-42d9-be24-10c966579ce2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8391ed98-00ee-451e-9a03-b801190d5456", "node_type": "1", "metadata": {}, "hash": "235cb6e6b3c4dacf0345967242558f764cf977f75d5861a0d325e31c3db2aa53", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "29516556-776c-4ce8-82fa-7cba9f49be79", "node_type": "1", "metadata": {}, "hash": "5cb3762514e37d46ebb16c74df917b400cf99101eae2409904bdb7c04d80e418", "class_name": "RelatedNodeInfo"}}, "text": "Among the training\ndataset, there are 120 breeds of dogs such as Labradors, Poodles, Dachshunds, Samoyeds,\nHuskies, Chihuahuas, and Yorkshire Terriers.\nDownloadingthe Dataset\nAfter logging into Kaggle, you can click on the \u201cData\u201d tab on the competition webpage\nshown in Fig. 14.14.1 and download the dataset by clicking the \u201cDownload All\u201d button.\nAfter unzipping the downloaded file in ../data , you will find the entire dataset in the\nfollowing paths:\n683 Dog Breed Identi\ufb01cation (ImageNet Dogs) on Kaggle\ntFig. 14.14.1 The dog breed identi\ufb01cation competition website. The competition dataset can be\nobtained by clicking the \u201cData\u201d tab.\n\u000f../data/dog-breed-identification/labels.csv\n\u000f../data/dog-breed-identification/sample_submission.csv\n\u000f../data/dog-breed-identification/train\n\u000f../data/dog-breed-identification/test\nYoumayhavenoticedthattheabovestructureissimilartothatoftheCIFAR-10competition\ninSection14.13 ,wherefolders train/andtest/containtrainingandtestingdogimages,\nrespectively, and labels.csv contains the labels for the training images. Similarly, to\nmake it easier to get started, we provide a small sample of the dataset mentioned above:\ntrain_valid_test_tiny.zip . If you are going to use the full dataset for the Kaggle\ncompetition, you need to change the demovariable below to False.\n#@save\nd2l.DATA_HUB[ 'dog_tiny ']=(d2l .DATA_URL +'kaggle_dog_tiny.zip ',\n'0cb91d09b814ecdc07b50f31f8dcad3e81d6a86d ')\n# If you use the full dataset downloaded for the Kaggle competition, change\n# the variable below to `False`\ndemo =True\nifdemo:\ndata_dir =d2l.download_extract( 'dog_tiny ')\n(continues on next page)\n684 Computer Vision\n(continued from previous page)\nelse :\ndata_dir =os.path .join( '..','data ','dog-breed-identification ')\nDownloading ../data /kaggle_dog_tiny .zip from http ://d2l-data .s3-accelerate .\n\u21a9!amazonaws .com/kaggle_dog_tiny .zip...\nOrganizingthe Dataset\nWe can organize the dataset similarly to what we did in Section 14.13 , namely splitting out\na validation set from the original training set, and moving images into subfolders grouped\nby labels.\nThereorg_dog_data functionbelowreadsthetrainingdatalabels,splitsoutthevalidation\nset, and organizes the training set.\ndef reorg_dog_data (data_dir, valid_ratio):\nlabels =d2l.read_csv_labels(os .path .join(data_dir, 'labels.csv '))\nd2l.reorg_train_valid(data_dir, labels, valid_ratio)\nd2l.reorg_test(data_dir)\nbatch_size =32ifdemo else 128\nvalid_ratio =0.1\nreorg_dog_data(data_dir, valid_ratio)\n14.14.2ImageAugmentation\nRecall that this dog breed dataset is a subset of the ImageNet dataset, whose images are\nlargerthanthoseoftheCIFAR-10datasetin Section14.13 . Thefollowinglistsafewimage\naugmentation operations that might be useful for relatively larger images.\ntransform_train =torchvision .transforms .Compose([\n# Randomly crop the image to obtain an image with an area of 0.08 to 1 of\n# the original area and height-to-width ratio between 3/4 and 4/3. Then,\n# scale the image to create a new 224 x 224 image\ntorchvision .transforms .RandomResizedCrop( 224, scale =(0.08 ,1.0),\nratio =(3.0/4.0,4.0/3.0)),\ntorchvision .transforms .RandomHorizontalFlip(),\n# Randomly change the brightness, contrast, and saturation\ntorchvision .transforms .ColorJitter(brightness =0.4,\ncontrast =0.4,\nsaturation =0.4),\n# Add random noise\ntorchvision .transforms .ToTensor(),\n# Standardize each channel of the image\ntorchvision .transforms .Normalize([ 0.485 ,0.456 ,0.406 ],\n[0.229 ,0.224 ,0.225 ])])\nDuringprediction,weonlyuseimagepreprocessingoperationswithoutrandomness.", "mimetype": "text/plain", "start_char_idx": 1460807, "end_char_idx": 1464345, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "29516556-776c-4ce8-82fa-7cba9f49be79": {"__data__": {"id_": "29516556-776c-4ce8-82fa-7cba9f49be79", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "61ffb61d-ad1b-42d9-be24-10c966579ce2", "node_type": "1", "metadata": {}, "hash": "c64af7481ddf6e01ad5f4e7ac59c7905840bf9577baa3a6cfd909cb2d8b66558", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4c2a4489-d811-4b67-a762-865abadd57f9", "node_type": "1", "metadata": {}, "hash": "a4c0e7c18ba73208f81bf4a84ec080ca7cefa68036265dbee53d38f03283e0cd", "class_name": "RelatedNodeInfo"}}, "text": "Then,\n# scale the image to create a new 224 x 224 image\ntorchvision .transforms .RandomResizedCrop( 224, scale =(0.08 ,1.0),\nratio =(3.0/4.0,4.0/3.0)),\ntorchvision .transforms .RandomHorizontalFlip(),\n# Randomly change the brightness, contrast, and saturation\ntorchvision .transforms .ColorJitter(brightness =0.4,\ncontrast =0.4,\nsaturation =0.4),\n# Add random noise\ntorchvision .transforms .ToTensor(),\n# Standardize each channel of the image\ntorchvision .transforms .Normalize([ 0.485 ,0.456 ,0.406 ],\n[0.229 ,0.224 ,0.225 ])])\nDuringprediction,weonlyuseimagepreprocessingoperationswithoutrandomness.\n685 Dog Breed Identi\ufb01cation (ImageNet Dogs) on Kaggle\ntransform_test =torchvision .transforms .Compose([\ntorchvision .transforms .Resize( 256),\n# Crop a 224 x 224 square area from the center of the image\ntorchvision .transforms .CenterCrop( 224),\ntorchvision .transforms .ToTensor(),\ntorchvision .transforms .Normalize([ 0.485 ,0.456 ,0.406 ],\n[0.229 ,0.224 ,0.225 ])])\n14.14.3Readingthe Dataset\nAsinSection14.13 ,wecanreadtheorganizeddatasetconsistingofrawimagefiles.\ntrain_ds, train_valid_ds =[torchvision .datasets .ImageFolder(\nos.path .join(data_dir, 'train_valid_test ', folder),\ntransform =transform_train) for folder in['train ','train_valid ']]\nvalid_ds, test_ds =[torchvision .datasets .ImageFolder(\nos.path .join(data_dir, 'train_valid_test ', folder),\ntransform =transform_test) for folder in['valid ','test ']]\nBelow we create data iterator instances the same way as in Section 14.13 .\ntrain_iter, train_valid_iter =[torch .utils .data .DataLoader(\ndataset, batch_size, shuffle =True , drop_last =True )\nfor dataset in(train_ds, train_valid_ds)]\nvalid_iter =torch .utils .data .DataLoader(valid_ds, batch_size, shuffle =False ,\ndrop_last =True )\ntest_iter =torch .utils .data .DataLoader(test_ds, batch_size, shuffle =False ,\ndrop_last =False )\n14.14.4Fine-Tuninga PretrainedModel\nAgain, the dataset for this competition is a subset of the ImageNet dataset. Therefore, we\ncan use the approach discussed in Section 14.2 to select a model pretrained on the full\nImageNet dataset and use it to extract image features to be fed into a custom small-scale\noutput network. High-level APIs of deep learning frameworks provide a wide range of\nmodelspretrainedontheImageNetdataset. Here,wechooseapretrainedResNet-34model,\nwhere we simply reuse the input of this model\u2019s output layer (i.e., the extracted features).\nThen we can replace the original output layer with a small custom output network that can\nbe trained, such as stacking two fully connected layers. Different from the experiment in\nSection14.2 ,thefollowingdoesnotretrainthepretrainedmodelusedforfeatureextraction.\nThis reduces training time and memory for storing gradients.\nRecall that we standardized images using the means and standard deviations of the three\nRGB channels for the full ImageNet dataset. In fact, this is also consistent with the stan-\ndardization operation by the pretrained model on ImageNet.\n686 Computer Vision\ndef get_net (devices):\nfinetune_net =nn.Sequential()\nfinetune_net .features =torchvision .models .resnet34(pretrained =True )\n# Define a new output network (there are 120 output categories)\nfinetune_net .output_new =nn.Sequential(nn .Linear( 1000 ,256),\nnn.ReLU(),\nnn.Linear( 256,120))\n# Move the model to devices\nfinetune_net =finetune_net .to(devices[ 0])\n# Freeze parameters of feature layers\nfor param infinetune_net .features .parameters():\nparam .requires_grad =False\nreturn finetune_net\nBefore calculating the loss, we first obtain the input of the pretrained model\u2019s output layer,\ni.e., the extracted feature. Then we use this feature as input for our small custom output\nnetwork to calculate the loss.", "mimetype": "text/plain", "start_char_idx": 1463744, "end_char_idx": 1467457, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4c2a4489-d811-4b67-a762-865abadd57f9": {"__data__": {"id_": "4c2a4489-d811-4b67-a762-865abadd57f9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "29516556-776c-4ce8-82fa-7cba9f49be79", "node_type": "1", "metadata": {}, "hash": "5cb3762514e37d46ebb16c74df917b400cf99101eae2409904bdb7c04d80e418", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0e095c44-0846-43f0-8856-1eca7aacb70b", "node_type": "1", "metadata": {}, "hash": "7deaa958bda7105b4a23b9e0260e9d19768eeaedcc4908f29299bed1e7f0600d", "class_name": "RelatedNodeInfo"}}, "text": "686 Computer Vision\ndef get_net (devices):\nfinetune_net =nn.Sequential()\nfinetune_net .features =torchvision .models .resnet34(pretrained =True )\n# Define a new output network (there are 120 output categories)\nfinetune_net .output_new =nn.Sequential(nn .Linear( 1000 ,256),\nnn.ReLU(),\nnn.Linear( 256,120))\n# Move the model to devices\nfinetune_net =finetune_net .to(devices[ 0])\n# Freeze parameters of feature layers\nfor param infinetune_net .features .parameters():\nparam .requires_grad =False\nreturn finetune_net\nBefore calculating the loss, we first obtain the input of the pretrained model\u2019s output layer,\ni.e., the extracted feature. Then we use this feature as input for our small custom output\nnetwork to calculate the loss.\nloss =nn.CrossEntropyLoss(reduction ='none ')\ndef evaluate_loss (data_iter, net, devices):\nl_sum, n =0.0,0\nfor features, labels indata_iter:\nfeatures, labels =features .to(devices[ 0]), labels .to(devices[ 0])\noutputs =net(features)\nl=loss(outputs, labels)\nl_sum +=l.sum()\nn+=labels .numel()\nreturn l_sum /n\n14.14.5Defining the TrainingFunction\nWe will select the model and tune hyperparameters according to the model\u2019s performance\non the validation set. The model training function trainonly iterates parameters of the\nsmall custom output network.\ndef train (net, train_iter, valid_iter, num_epochs, lr, wd, devices, lr_period,\nlr_decay):\n# Only train the small custom output network\nnet =nn.DataParallel(net, device_ids =devices) .to(devices[ 0])\ntrainer =torch .optim .SGD((param for param innet.parameters()\nifparam .requires_grad), lr =lr,\nmomentum =0.9, weight_decay =wd)\nscheduler =torch .optim .lr_scheduler .StepLR(trainer, lr_period, lr_decay)\nnum_batches, timer =len(train_iter), d2l .Timer()\nlegend =['train loss ']\nifvalid_iter isnot None :\nlegend .append( 'valid loss ')\nanimator =d2l.Animator(xlabel ='epoch ', xlim =[1, num_epochs],\nlegend =legend)\nfor epoch inrange (num_epochs):\nmetric =d2l.Accumulator( 2)\n(continues on next page)\n687 Dog Breed Identi\ufb01cation (ImageNet Dogs) on Kaggle\n(continued from previous page)\nfor i, (features, labels) inenumerate (train_iter):\ntimer .start()\nfeatures, labels =features .to(devices[ 0]), labels .to(devices[ 0])\ntrainer .zero_grad()\noutput =net(features)\nl=loss(output, labels) .sum()\nl.backward()\ntrainer .step()\nmetric .add(l, labels .shape[ 0])\ntimer .stop()\nif(i+1)%(num_batches //5)==0ori==num_batches -1:\nanimator .add(epoch +(i+1)/num_batches,\n(metric[ 0]/metric[ 1],None ))\nmeasures =f'train loss {metric[ 0]/metric[ 1]:.3f}'\nifvalid_iter isnot None :\nvalid_loss =evaluate_loss(valid_iter, net, devices)\nanimator .add(epoch +1, (None , valid_loss .detach() .cpu()))\nscheduler .step()\nifvalid_iter isnot None :\nmeasures +=f', valid loss {valid_loss :.3f}'\nprint (measures +f'\\n{metric[ 1]*num_epochs /timer .sum() :.1f}'\nf'examples/sec on {str(devices) }')\n14.14.6Trainingand Validatingthe Model\nNow we can train and validate the model. The following hyperparameters are all tunable.\nFor example, the number of epochs can be increased. Because lr_period andlr_decay\nare set to 2 and 0.9, respectively, the learning rate of the optimization algorithm will be\nmultiplied by 0.9 after every 2 epochs.", "mimetype": "text/plain", "start_char_idx": 1466727, "end_char_idx": 1469921, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0e095c44-0846-43f0-8856-1eca7aacb70b": {"__data__": {"id_": "0e095c44-0846-43f0-8856-1eca7aacb70b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4c2a4489-d811-4b67-a762-865abadd57f9", "node_type": "1", "metadata": {}, "hash": "a4c0e7c18ba73208f81bf4a84ec080ca7cefa68036265dbee53d38f03283e0cd", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d761b3af-3655-48d5-87c0-779853445479", "node_type": "1", "metadata": {}, "hash": "160db5f4df7293bea2b0f3991abb01480b98f042ec656370146741421c2f289f", "class_name": "RelatedNodeInfo"}}, "text": "The following hyperparameters are all tunable.\nFor example, the number of epochs can be increased. Because lr_period andlr_decay\nare set to 2 and 0.9, respectively, the learning rate of the optimization algorithm will be\nmultiplied by 0.9 after every 2 epochs.\ndevices, num_epochs, lr, wd =d2l.try_all_gpus(), 10,1e-4 ,1e-4\nlr_period, lr_decay, net =2,0.9, get_net(devices)\ntrain(net, train_iter, valid_iter, num_epochs, lr, wd, devices, lr_period,\nlr_decay)\ntrain loss 1.240 , valid loss 1.545\n577.5 examples /sec on [device( type ='cuda ', index =0), device( type ='cuda ',\u2423\n\u21a9!index =1)]\n\n688 Computer Vision\n14.14.7Classifying the TestingSetand Submitting Resultson Kaggle\nSimilar to the final step in Section 14.13 , in the end all the labeled data (including the\nvalidation set) are used for training the model and classifying the testing set. We will use\nthe trained custom output network for classification.\nnet =get_net(devices)\ntrain(net, train_valid_iter, None , num_epochs, lr, wd, devices, lr_period,\nlr_decay)\npreds =[]\nfor data, label intest_iter:\noutput =torch .nn.functional .softmax(net(data .to(devices[ 0])), dim =1)\npreds .extend(output .cpu() .detach() .numpy())\nids =sorted (os.listdir(\nos.path .join(data_dir, 'train_valid_test ','test ','unknown ')))\nwith open ('submission.csv ','w')asf:\nf.write( 'id,'+','.join(train_valid_ds .classes) +'\\n')\nfor i, output inzip(ids, preds):\nf.write(i .split( '.')[0]+','+','.join(\n[str(num) for num inoutput]) +'\\n')\ntrain loss 1.217\n742.7 examples /sec on [device( type ='cuda ', index =0), device( type ='cuda ',\u2423\n\u21a9!index =1)]\nTheabovecodewillgeneratea submission.csv filetobesubmittedtoKaggleinthesame\nway described in Section 5.7 .\n14.14.8Summary\n\u000fImagesintheImageNetdatasetarelarger(withvaryingdimensions)thanCIFAR-10im-\nages. We may modify image augmentation operations for tasks on a different dataset.\n\u000fTo classify a subset of the ImageNet dataset, we can leverage pre-trained models on the\nfull ImageNet dataset to extract features and only train a custom small-scale output\nnetwork. This will lead to less computational time and memory cost.\n14.14.9Exercises\n689 Dog Breed Identi\ufb01cation (ImageNet Dogs) on Kaggle\n2261.WhenusingthefullKagglecompetitiondataset,whatresultscanyouachievewhenyou\nincrease batch_size (batch size) and num_epochs (number of epochs) while setting\nsome other hyperparameters as lr = 0.01 ,lr_period = 10 , and lr_decay = 0.1 ?\n2.Do you get better results if you use a deeper pretrained model? How do you tune hyper-\nparameters? Can you further improve the results?\nDiscussions226.\n15Natural Language Processing: Pretraining\nHumansneedtocommunicate. Outofthisbasicneedofthehumancondition,avastamount\nof written text has been generated on an everyday basis. Given rich text in social media,\nchat apps, emails, product reviews, news articles, research papers, and books, it becomes\nvital to enable computers to understand them to offer assistance or make decisions based\non human languages.\nNatural language processing studies interactions between computers and humans using\nnatural languages. In practice, it is very common to use natural language processing tech-\nniquestoprocessandanalyzetext(humannaturallanguage)data, suchaslanguagemodels\ninSection 9.3 and machine translation models in Section 10.5 .\nTo understand text, we can begin by learning its representations. Leveraging the existing\ntext sequences from large corpora, self-supervised learning has been extensively used to\npretrain text representations, such as by predicting some hidden part of the text using some\nother part of their surrounding text. In this way, models learn through supervision from\nmassive text data without expensive labeling efforts!\nAs we will see in this chapter, when treating each word or subword as an individual token,\nthe representation of each token can be pretrained using word2vec, GloVe, or subword\nembedding models on large corpora.", "mimetype": "text/plain", "start_char_idx": 1469661, "end_char_idx": 1473585, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d761b3af-3655-48d5-87c0-779853445479": {"__data__": {"id_": "d761b3af-3655-48d5-87c0-779853445479", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0e095c44-0846-43f0-8856-1eca7aacb70b", "node_type": "1", "metadata": {}, "hash": "7deaa958bda7105b4a23b9e0260e9d19768eeaedcc4908f29299bed1e7f0600d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ffc66e9d-80e1-4b4f-adb3-6c7a0c57d752", "node_type": "1", "metadata": {}, "hash": "cfe40af21d96560cf405869c2656a52f4e125402e666f410dfb9f2d0a5748499", "class_name": "RelatedNodeInfo"}}, "text": "Natural language processing studies interactions between computers and humans using\nnatural languages. In practice, it is very common to use natural language processing tech-\nniquestoprocessandanalyzetext(humannaturallanguage)data, suchaslanguagemodels\ninSection 9.3 and machine translation models in Section 10.5 .\nTo understand text, we can begin by learning its representations. Leveraging the existing\ntext sequences from large corpora, self-supervised learning has been extensively used to\npretrain text representations, such as by predicting some hidden part of the text using some\nother part of their surrounding text. In this way, models learn through supervision from\nmassive text data without expensive labeling efforts!\nAs we will see in this chapter, when treating each word or subword as an individual token,\nthe representation of each token can be pretrained using word2vec, GloVe, or subword\nembedding models on large corpora. After pretraining, representation of each token can\nbe a vector, however, it remains the same no matter what the context is. For instance,\nthe vector representation of \u201cbank\u201d is the same in both \u201cgo to the bank to deposit some\nmoney\u201d and \u201cgo to the bank to sit down\u201d. Thus, many more recent pretraining models\nadaptrepresentationofthesametokentodifferentcontexts. AmongthemisBERT,amuch\ndeeper self-supervised model based on the Transformer encoder. In this chapter, we will\nfocus on how to pretrain such representations for text, as highlighted in Fig. 15.1 .\nFor sight of the big picture, Fig. 15.1 shows that the pretrained text representations can be\nfed to a variety of deep learning architectures for different downstream natural language\nprocessing applications. We will cover them in Chapter 16 .\n690\n691 Word Embedding (word2vec)\ntFig. 15.1 Pretrained text representations can be fed to various deep learning architectures for\ndifferent downstream natural language processing applications. This chapter focuses on\nthe upstream text representation pretraining.\n22715.1WordEmbedding (word2vec)\nNatural language is a complex system used to express meanings. In this system, words\nare the basic unit of the meaning. As the name implies, word vectors are vectors used to\nrepresent words, and can also be considered as feature vectors or representations of words.\nThe technique of mapping words to real vectors is called wordembedding . In recent years,\nword embedding has gradually become the basic knowledge of natural language process-\ning.\n15.1.1One-HotVectorsArea Bad Choice\nWe used one-hot vectorsto represent words(characters are words)in Section 9.5 . Suppose\nthat the number of different words in the dictionary (the dictionary size) is \ud835\udc41, and each\nword corresponds to a different integer (index) from 0to\ud835\udc41\u00001. To obtain the one-hot\nvectorrepresentationforanywordwithindex \ud835\udc56, wecreatealength- \ud835\udc41vectorwithall0sand\nset the element at position \ud835\udc56to 1. In this way, each word is represented as a vector of length\n\ud835\udc41, and it can be used directly by neural networks.\nAlthoughone-hot wordvectorsare easyto construct, theyare usuallynot a goodchoice. A\nmain reason is that one-hot word vectors cannot accurately express the similarity between\ndifferentwords,suchasthe cosinesimilarity thatweoftenuse. Forvectors x,y2R\ud835\udc51,their\ncosine similarity is the cosine of the angle between them:\nx>y\nkxkkyk2\u00bb\u0000 1,1\u00bc. (15.1.1)\nSincethecosinesimilaritybetweenone-hotvectorsofanytwodifferentwordsis0,one-hot\nvectors cannot encode similarities among words.\n15.1.2Self-Supervisedword2vec\nTheword2vec227tool was proposed to address the above issue. It maps each word to a\n692 Natural Language Processing: Pretraining\nfixed-lengthvector,andthesevectorscanbetterexpressthesimilarityandanalogyrelation-\nship among different words. The word2vec tool contains two models, namely skip-gram\n(Mikolovet al., 2013) andcontinuous bag of words (CBOW) ( Mikolovet al., 2013). For\nsemantically meaningful representations, their training relies on conditional probabilities\nthatcanbeviewedaspredictingsomewordsusingsomeoftheirsurroundingwordsincor-\npora. Sincesupervisioncomesfromthedatawithoutlabels,bothskip-gramandcontinuous\nbag of words are self-supervised models.\nIn the following, we will introduce these two models and their training methods.", "mimetype": "text/plain", "start_char_idx": 1472644, "end_char_idx": 1476902, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ffc66e9d-80e1-4b4f-adb3-6c7a0c57d752": {"__data__": {"id_": "ffc66e9d-80e1-4b4f-adb3-6c7a0c57d752", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d761b3af-3655-48d5-87c0-779853445479", "node_type": "1", "metadata": {}, "hash": "160db5f4df7293bea2b0f3991abb01480b98f042ec656370146741421c2f289f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d3ebdc93-a33e-4c04-886b-52c491e5f78f", "node_type": "1", "metadata": {}, "hash": "f41eb8c80e18bcb3b96a4d218212840c0315ce339e28587d21ba763951eba448", "class_name": "RelatedNodeInfo"}}, "text": "15.1.2Self-Supervisedword2vec\nTheword2vec227tool was proposed to address the above issue. It maps each word to a\n692 Natural Language Processing: Pretraining\nfixed-lengthvector,andthesevectorscanbetterexpressthesimilarityandanalogyrelation-\nship among different words. The word2vec tool contains two models, namely skip-gram\n(Mikolovet al., 2013) andcontinuous bag of words (CBOW) ( Mikolovet al., 2013). For\nsemantically meaningful representations, their training relies on conditional probabilities\nthatcanbeviewedaspredictingsomewordsusingsomeoftheirsurroundingwordsincor-\npora. Sincesupervisioncomesfromthedatawithoutlabels,bothskip-gramandcontinuous\nbag of words are self-supervised models.\nIn the following, we will introduce these two models and their training methods.\n15.1.3TheSkip-Gram Model\nTheskip-gram modelassumesthatawordcanbeusedtogenerateitssurroundingwordsin\na text sequence. Take the text sequence \u201cthe\u201d, \u201cman\u201d, \u201cloves\u201d, \u201chis\u201d, \u201cson\u201d as an example.\nLet\u2019s choose \u201cloves\u201d as the centerword and set the context window size to 2. As shown in\nFig. 15.1.1 , given the center word \u201cloves\u201d, the skip-gram model considers the conditional\nprobability for generating the contextwords : \u201cthe\u201d, \u201cman\u201d, \u201chis\u201d, and \u201cson\u201d, which are no\nmore than 2 words away from the center word:\n\ud835\udc43\u00b9\u201dthe\u201d,\u201dman\u201d,\u201dhis\u201d,\u201dson\u201dj\u201dloves\u201d\u00ba. (15.1.2)\nAssume that the context words are independently generated given the center word (i.e.,\nconditional independence). In this case, the above conditional probability can be rewritten\nas\n\ud835\udc43\u00b9\u201dthe\u201dj\u201dloves\u201d\u00ba\u0001\ud835\udc43\u00b9\u201dman\u201dj\u201dloves\u201d\u00ba\u0001\ud835\udc43\u00b9\u201dhis\u201dj\u201dloves\u201d\u00ba\u0001\ud835\udc43\u00b9\u201dson\u201dj\u201dloves\u201d\u00ba.\n(15.1.3)\ntFig. 15.1.1 The skip-gram model considers the conditional probability of generating the surrounding\ncontext words given a center word.\nIn the skip-gram model, each word has two \ud835\udc51-dimensional-vector representations for cal-\nculating conditional probabilities. More concretely, for any word with index \ud835\udc56in the dic-\ntionary, denote by v\ud835\udc562R\ud835\udc51andu\ud835\udc562R\ud835\udc51its two vectors when used as a centerword and a\ncontextword, respectively. The conditional probability of generating any context word \ud835\udc64\ud835\udc5c\n(with index\ud835\udc5cin the dictionary) given the center word \ud835\udc64\ud835\udc50(with index\ud835\udc50in the dictionary)\ncan be modeled by a softmax operation on vector dot products:\n\ud835\udc43\u00b9\ud835\udc64\ud835\udc5cj\ud835\udc64\ud835\udc50\u00ba=exp\u00b9u>\n\ud835\udc5cv\ud835\udc50\u00ba\u00cd\n\ud835\udc562Vexp\u00b9u>\n\ud835\udc56v\ud835\udc50\u00ba, (15.1.4)\n693 Word Embedding (word2vec)\nwhere the vocabulary index set V=f0,1,...,jVj\u0000 1g. Given a text sequence of length\n\ud835\udc47, where the word at time step \ud835\udc61is denoted as \ud835\udc64\u00b9\ud835\udc61\u00ba. Assume that context words are in-\ndependently generated given any center word. For context window size \ud835\udc5a, the likelihood\nfunction of the skip-gram model is the probability of generating all context words given\nany center word:\n\ud835\udc47\u00d6\n\ud835\udc61=1\u00d6\n\u0000\ud835\udc5a\u0014\ud835\udc57\u0014\ud835\udc5a, \ud835\udc57\u22600\ud835\udc43\u00b9\ud835\udc64\u00b9\ud835\udc61\u00b8\ud835\udc57\u00baj\ud835\udc64\u00b9\ud835\udc61\u00ba\u00ba, (15.1.5)\nwhere any time step that is less than 1or greater than \ud835\udc47can be omitted.\nTraining\nThe skip-gram model parameters are the center word vector and context word vector for\neachwordinthevocabulary. Intraining,welearnthemodelparametersbymaximizingthe\nlikelihoodfunction(i.e.,maximumlikelihoodestimation).", "mimetype": "text/plain", "start_char_idx": 1476126, "end_char_idx": 1479126, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d3ebdc93-a33e-4c04-886b-52c491e5f78f": {"__data__": {"id_": "d3ebdc93-a33e-4c04-886b-52c491e5f78f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ffc66e9d-80e1-4b4f-adb3-6c7a0c57d752", "node_type": "1", "metadata": {}, "hash": "cfe40af21d96560cf405869c2656a52f4e125402e666f410dfb9f2d0a5748499", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6f23de83-87cf-4dd2-a932-ace03c8c56d9", "node_type": "1", "metadata": {}, "hash": "f50e0cf2ddd34f2b13a2e35b9604717c1fdbf1ed0f77c6e5223e6129c178eb42", "class_name": "RelatedNodeInfo"}}, "text": "Assume that context words are in-\ndependently generated given any center word. For context window size \ud835\udc5a, the likelihood\nfunction of the skip-gram model is the probability of generating all context words given\nany center word:\n\ud835\udc47\u00d6\n\ud835\udc61=1\u00d6\n\u0000\ud835\udc5a\u0014\ud835\udc57\u0014\ud835\udc5a, \ud835\udc57\u22600\ud835\udc43\u00b9\ud835\udc64\u00b9\ud835\udc61\u00b8\ud835\udc57\u00baj\ud835\udc64\u00b9\ud835\udc61\u00ba\u00ba, (15.1.5)\nwhere any time step that is less than 1or greater than \ud835\udc47can be omitted.\nTraining\nThe skip-gram model parameters are the center word vector and context word vector for\neachwordinthevocabulary. Intraining,welearnthemodelparametersbymaximizingthe\nlikelihoodfunction(i.e.,maximumlikelihoodestimation). Thisisequivalenttominimizing\nthe following loss function:\n\u0000\ud835\udc47\u00d5\n\ud835\udc61=1\u00d5\n\u0000\ud835\udc5a\u0014\ud835\udc57\u0014\ud835\udc5a, \ud835\udc57\u22600log\ud835\udc43\u00b9\ud835\udc64\u00b9\ud835\udc61\u00b8\ud835\udc57\u00baj\ud835\udc64\u00b9\ud835\udc61\u00ba\u00ba. (15.1.6)\nWhen using stochastic gradient descent to minimize the loss, in each iteration we can ran-\ndomly sample a shorter subsequence to calculate the (stochastic) gradient for this subse-\nquence to update the model parameters. To calculate this (stochastic) gradient, we need\nto obtain the gradients of the log conditional probability with respect to the center word\nvector and the context word vector. In general, according to (15.1.4 )the log conditional\nprobability involving any pair of the center word \ud835\udc64\ud835\udc50and the context word \ud835\udc64\ud835\udc5cis\nlog\ud835\udc43\u00b9\ud835\udc64\ud835\udc5cj\ud835\udc64\ud835\udc50\u00ba=u>\n\ud835\udc5cv\ud835\udc50\u0000log \u00d5\n\ud835\udc562Vexp\u00b9u>\n\ud835\udc56v\ud835\udc50\u00ba!\n. (15.1.7)\nThrough differentiation, we can obtain its gradient with respect to the center word vector\nv\ud835\udc50as\n\ud835\udf15log\ud835\udc43\u00b9\ud835\udc64\ud835\udc5cj\ud835\udc64\ud835\udc50\u00ba\n\ud835\udf15v\ud835\udc50=u\ud835\udc5c\u0000\u00cd\n\ud835\udc572Vexp\u00b9u>\n\ud835\udc57v\ud835\udc50\u00bau\ud835\udc57\u00cd\n\ud835\udc562Vexp\u00b9u>\n\ud835\udc56v\ud835\udc50\u00ba\n=u\ud835\udc5c\u0000\u00d5\n\ud835\udc572V exp\u00b9u>\n\ud835\udc57v\ud835\udc50\u00ba\n\u00cd\n\ud835\udc562Vexp\u00b9u>\n\ud835\udc56v\ud835\udc50\u00ba!\nu\ud835\udc57\n=u\ud835\udc5c\u0000\u00d5\n\ud835\udc572V\ud835\udc43\u00b9\ud835\udc64\ud835\udc57j\ud835\udc64\ud835\udc50\u00bau\ud835\udc57.(15.1.8)\nNote that the calculation in (15.1.8 )requires the conditional probabilities of all words in\nthe dictionary with \ud835\udc64\ud835\udc50as the center word. The gradients for the other word vectors can be\nobtained in the same way.\nAfter training, for any word with index \ud835\udc56in the dictionary, we obtain both word vectors\n694 Natural Language Processing: Pretraining\nv\ud835\udc56(as the center word) and u\ud835\udc56(as the context word). In natural language processing ap-\nplications, the center word vectors of the skip-gram model are typically used as the word\nrepresentations.\n15.1.4TheContinuous Bag of Words(CBOW)Model\nThecontinuousbagofwords (CBOW)modelissimilartotheskip-grammodel. Themajor\ndifferencefromtheskip-grammodelisthatthecontinuousbagofwordsmodelassumesthat\nacenterwordisgeneratedbasedonitssurroundingcontextwordsinthetextsequence. For\nexample,inthesametextsequence\u201cthe\u201d,\u201cman\u201d,\u201cloves\u201d,\u201chis\u201d,and\u201cson\u201d,with\u201cloves\u201das\nthe center word and the context window size being 2, the continuous bag of words model\nconsiders the conditional probability of generating the center word \u201cloves\u201d based on the\ncontext words \u201cthe\u201d, \u201cman\u201d, \u201chis\u201d and \u201cson\u201d (as shown in Fig. 15.1.2 ), which is\n\ud835\udc43\u00b9\u201dloves\u201dj\u201dthe\u201d,\u201dman\u201d,\u201dhis\u201d,\u201dson\u201d\u00ba. (15.1.9)\ntFig. 15.1.2 The continuous bag of words model considers the conditional probability of generating\nthe center word given its surrounding context words.", "mimetype": "text/plain", "start_char_idx": 1478558, "end_char_idx": 1481376, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6f23de83-87cf-4dd2-a932-ace03c8c56d9": {"__data__": {"id_": "6f23de83-87cf-4dd2-a932-ace03c8c56d9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d3ebdc93-a33e-4c04-886b-52c491e5f78f", "node_type": "1", "metadata": {}, "hash": "f41eb8c80e18bcb3b96a4d218212840c0315ce339e28587d21ba763951eba448", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a1f5496c-c780-4073-b394-ace49f9964ef", "node_type": "1", "metadata": {}, "hash": "2259afa671db1a99a7874c44e54004ef1d8c7785d0e3da2e1b1e8deec2b96125", "class_name": "RelatedNodeInfo"}}, "text": "For\nexample,inthesametextsequence\u201cthe\u201d,\u201cman\u201d,\u201cloves\u201d,\u201chis\u201d,and\u201cson\u201d,with\u201cloves\u201das\nthe center word and the context window size being 2, the continuous bag of words model\nconsiders the conditional probability of generating the center word \u201cloves\u201d based on the\ncontext words \u201cthe\u201d, \u201cman\u201d, \u201chis\u201d and \u201cson\u201d (as shown in Fig. 15.1.2 ), which is\n\ud835\udc43\u00b9\u201dloves\u201dj\u201dthe\u201d,\u201dman\u201d,\u201dhis\u201d,\u201dson\u201d\u00ba. (15.1.9)\ntFig. 15.1.2 The continuous bag of words model considers the conditional probability of generating\nthe center word given its surrounding context words.\nSincetherearemultiplecontextwordsinthecontinuousbagofwordsmodel, thesecontext\nword vectorsare averagedin the calculation of the conditional probability. Specifically, for\nany word with index \ud835\udc56in the dictionary, denote by v\ud835\udc562R\ud835\udc51andu\ud835\udc562R\ud835\udc51its two vectors\nwhen used as a contextword and a centerword (meanings are switched in the skip-gram\nmodel), respectively. The conditional probability of generating any center word \ud835\udc64\ud835\udc50(with\nindex\ud835\udc50in the dictionary) given its surrounding context words \ud835\udc64\ud835\udc5c1,...,\ud835\udc64\ud835\udc5c2\ud835\udc5a(with index\n\ud835\udc5c1,...,\ud835\udc5c 2\ud835\udc5ain the dictionary) can be modeled by\n\ud835\udc43\u00b9\ud835\udc64\ud835\udc50j\ud835\udc64\ud835\udc5c1,...,\ud835\udc64\ud835\udc5c2\ud835\udc5a\u00ba=exp\u0010\n1\n2\ud835\udc5au>\n\ud835\udc50\u00b9v\ud835\udc5c1\u00b8...\u00b8v\ud835\udc5c2\ud835\udc5a\u00ba\u0011\n\u00cd\n\ud835\udc562Vexp\u0010\n1\n2\ud835\udc5au>\n\ud835\udc56\u00b9v\ud835\udc5c1\u00b8...\u00b8v\ud835\udc5c2\ud835\udc5a\u00ba\u0011. (15.1.10)\nForbrevity,letW\ud835\udc5c=f\ud835\udc64\ud835\udc5c1,...,\ud835\udc64\ud835\udc5c2\ud835\udc5agand \u00afv\ud835\udc5c=\u0000v\ud835\udc5c1\u00b8...\u00b8v\ud835\udc5c2\ud835\udc5a\u0001\u009d\u00b92\ud835\udc5a\u00ba. Then (15.1.10 )\ncan be simplified as\n\ud835\udc43\u00b9\ud835\udc64\ud835\udc50jW\ud835\udc5c\u00ba=exp\u0000u>\n\ud835\udc50\u00afv\ud835\udc5c\u0001\n\u00cd\n\ud835\udc562Vexp\u0000u>\n\ud835\udc56\u00afv\ud835\udc5c\u0001. (15.1.11)\nGiven a text sequence of length \ud835\udc47, where the word at time step \ud835\udc61is denoted as \ud835\udc64\u00b9\ud835\udc61\u00ba. For\n695 Word Embedding (word2vec)\ncontext window size \ud835\udc5a, the likelihood function of the continuous bag of words model is\nthe probability of generating all center words given their context words:\n\ud835\udc47\u00d6\n\ud835\udc61=1\ud835\udc43\u00b9\ud835\udc64\u00b9\ud835\udc61\u00baj\ud835\udc64\u00b9\ud835\udc61\u0000\ud835\udc5a\u00ba,...,\ud835\udc64\u00b9\ud835\udc61\u00001\u00ba,\ud835\udc64\u00b9\ud835\udc61\u00b81\u00ba,...,\ud835\udc64\u00b9\ud835\udc61\u00b8\ud835\udc5a\u00ba\u00ba. (15.1.12)\nTraining\nTrainingcontinuousbagofwordsmodelsisalmostthesameastrainingskip-grammodels.\nThe maximum likelihood estimation of the continuous bag of words model is equivalent to\nminimizing the following loss function:\n\u0000\ud835\udc47\u00d5\n\ud835\udc61=1log\ud835\udc43\u00b9\ud835\udc64\u00b9\ud835\udc61\u00baj\ud835\udc64\u00b9\ud835\udc61\u0000\ud835\udc5a\u00ba,...,\ud835\udc64\u00b9\ud835\udc61\u00001\u00ba,\ud835\udc64\u00b9\ud835\udc61\u00b81\u00ba,...,\ud835\udc64\u00b9\ud835\udc61\u00b8\ud835\udc5a\u00ba\u00ba. (15.1.13)\nNotice that\nlog\ud835\udc43\u00b9\ud835\udc64\ud835\udc50jW\ud835\udc5c\u00ba=u>\n\ud835\udc50\u00afv\ud835\udc5c\u0000log \u00d5\n\ud835\udc562Vexp\u0000u>\n\ud835\udc56\u00afv\ud835\udc5c\u0001!\n.", "mimetype": "text/plain", "start_char_idx": 1480841, "end_char_idx": 1482847, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a1f5496c-c780-4073-b394-ace49f9964ef": {"__data__": {"id_": "a1f5496c-c780-4073-b394-ace49f9964ef", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6f23de83-87cf-4dd2-a932-ace03c8c56d9", "node_type": "1", "metadata": {}, "hash": "f50e0cf2ddd34f2b13a2e35b9604717c1fdbf1ed0f77c6e5223e6129c178eb42", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "10211d91-9ae7-404c-946e-cf40ea3aef94", "node_type": "1", "metadata": {}, "hash": "c5546917d44e539417fea880fa0dcf505745375444821f78883a592dd3786695", "class_name": "RelatedNodeInfo"}}, "text": "(15.1.12)\nTraining\nTrainingcontinuousbagofwordsmodelsisalmostthesameastrainingskip-grammodels.\nThe maximum likelihood estimation of the continuous bag of words model is equivalent to\nminimizing the following loss function:\n\u0000\ud835\udc47\u00d5\n\ud835\udc61=1log\ud835\udc43\u00b9\ud835\udc64\u00b9\ud835\udc61\u00baj\ud835\udc64\u00b9\ud835\udc61\u0000\ud835\udc5a\u00ba,...,\ud835\udc64\u00b9\ud835\udc61\u00001\u00ba,\ud835\udc64\u00b9\ud835\udc61\u00b81\u00ba,...,\ud835\udc64\u00b9\ud835\udc61\u00b8\ud835\udc5a\u00ba\u00ba. (15.1.13)\nNotice that\nlog\ud835\udc43\u00b9\ud835\udc64\ud835\udc50jW\ud835\udc5c\u00ba=u>\n\ud835\udc50\u00afv\ud835\udc5c\u0000log \u00d5\n\ud835\udc562Vexp\u0000u>\n\ud835\udc56\u00afv\ud835\udc5c\u0001!\n. (15.1.14)\nThrough differentiation, we can obtain its gradient with respect to any context word vector\nv\ud835\udc5c\ud835\udc56(\ud835\udc56=1,..., 2\ud835\udc5a) as\n\ud835\udf15log\ud835\udc43\u00b9\ud835\udc64\ud835\udc50jW\ud835\udc5c\u00ba\n\ud835\udf15v\ud835\udc5c\ud835\udc56=1\n2\ud835\udc5a\u00a9\u00ad\n\u00abu\ud835\udc50\u0000\u00d5\n\ud835\udc572Vexp\u00b9u>\n\ud835\udc57\u00afv\ud835\udc5c\u00bau\ud835\udc57\u00cd\n\ud835\udc562Vexp\u00b9u>\n\ud835\udc56\u00afv\ud835\udc5c\u00ba\u00aa\u00ae\n\u00ac=1\n2\ud835\udc5a\u00a9\u00ad\n\u00abu\ud835\udc50\u0000\u00d5\n\ud835\udc572V\ud835\udc43\u00b9\ud835\udc64\ud835\udc57jW\ud835\udc5c\u00bau\ud835\udc57\u00aa\u00ae\n\u00ac.\n(15.1.15)\nThe gradients for the other word vectors can be obtained in the same way. Unlike the skip-\ngram model, the continuous bag of words model typically uses context word vectors as the\nword representations.\n15.1.5Summary\n\u000fWord vectors are vectors used to represent words, and can also be considered as feature\nvectors or representations of words. The technique of mapping words to real vectors\nis called word embedding.\n\u000fThe word2vec tool contains both the skip-gram and continuous bag of words models.\n\u000fTheskip-grammodelassumesthatawordcanbeusedtogenerateitssurroundingwords\nin a text sequence; while the continuous bag of words model assumes that a center\nword is generated based on its surrounding context words.\n15.1.6Exercises\n1.Whatis the computational complexityforcalculating eachgradient? What could be the\nissue if the dictionary size is huge?\n696 Natural Language Processing: Pretraining\n2282.Some fixed phrases in English consist of multiple words, such as \u201cnew york\u201d. How to\ntrain their word vectors? Hint: see Section 4 in the word2vec paper ( Mikolovet al.,\n2013).\n3.Let\u2019sreflectontheword2vecdesignbytakingtheskip-grammodelasanexample. What\nis the relationship between the dot product of two word vectors in the skip-gram model\nand the cosine similarity? For a pair of words with similar semantics, why may the\ncosine similarity of their word vectors (trained by the skip-gram model) be high?\nDiscussions228.\n15.2ApproximateTraining\nRecall our discussions in Section 15.1 . The main idea of the skip-gram model is using\nsoftmax operations to calculate the conditional probability of generating a context word\n\ud835\udc64\ud835\udc5cbased on the given center word \ud835\udc64\ud835\udc50in(15.1.4 ), whose corresponding logarithmic loss\nis given by the opposite of (15.1.7 ).\nDue to the nature of the softmax operation, since a context word may be anyone in the\ndictionaryV, the opposite of (15.1.7 )contains the summation of items as many as the\nentire size of the vocabulary. Consequently, the gradient calculation for the skip-gram\nmodelin (15.1.8 )andthatforthecontinuousbag-of-wordsmodelin (15.1.15 )bothcontain\nthe summation. Unfortunately, the computational cost for such gradients that sum over a\nlarge dictionary (often with hundreds of thousands or millions of words) is huge!\nInordertoreducetheaforementionedcomputationalcomplexity,thissectionwillintroduce\ntwoapproximatetrainingmethods: negativesampling andhierarchicalsoftmax . Duetothe\nsimilarity between the skip-gram model and the continuous bag of words model, we will\njust take the skip-gram model as an example to describe these two approximate training\nmethods.\n15.2.1NegativeSampling\nNegative sampling modifies the original objective function.", "mimetype": "text/plain", "start_char_idx": 1482503, "end_char_idx": 1485763, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "10211d91-9ae7-404c-946e-cf40ea3aef94": {"__data__": {"id_": "10211d91-9ae7-404c-946e-cf40ea3aef94", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a1f5496c-c780-4073-b394-ace49f9964ef", "node_type": "1", "metadata": {}, "hash": "2259afa671db1a99a7874c44e54004ef1d8c7785d0e3da2e1b1e8deec2b96125", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "18a08a9b-7b9f-4b09-ac5c-af5fa10ff3cf", "node_type": "1", "metadata": {}, "hash": "d913a33870aeaea8a8a68869a5c2359295f4e8dcf1fddf5f18bdf3a5d7137b12", "class_name": "RelatedNodeInfo"}}, "text": "Consequently, the gradient calculation for the skip-gram\nmodelin (15.1.8 )andthatforthecontinuousbag-of-wordsmodelin (15.1.15 )bothcontain\nthe summation. Unfortunately, the computational cost for such gradients that sum over a\nlarge dictionary (often with hundreds of thousands or millions of words) is huge!\nInordertoreducetheaforementionedcomputationalcomplexity,thissectionwillintroduce\ntwoapproximatetrainingmethods: negativesampling andhierarchicalsoftmax . Duetothe\nsimilarity between the skip-gram model and the continuous bag of words model, we will\njust take the skip-gram model as an example to describe these two approximate training\nmethods.\n15.2.1NegativeSampling\nNegative sampling modifies the original objective function. Given the context window of\na center word \ud835\udc64\ud835\udc50, the fact that any (context) word \ud835\udc64\ud835\udc5ccomes from this context window is\nconsidered as an event with the probability modeled by\n\ud835\udc43\u00b9\ud835\udc37=1j\ud835\udc64\ud835\udc50,\ud835\udc64\ud835\udc5c\u00ba=\ud835\udf0e\u00b9u>\n\ud835\udc5cv\ud835\udc50\u00ba, (15.2.1)\nwhere\ud835\udf0euses the definition of the sigmoid activation function:\n\ud835\udf0e\u00b9\ud835\udc65\u00ba=1\n1\u00b8exp\u00b9\u0000\ud835\udc65\u00ba. (15.2.2)\nLet\u2019s begin by maximizing the joint probability of all such events in text sequences to train\nword embeddings. Specifically, given a text sequence of length \ud835\udc47, denote by\ud835\udc64\u00b9\ud835\udc61\u00bathe word\n697 Approximate Training\nat time step\ud835\udc61and let the context window size be \ud835\udc5a, consider maximizing the joint proba-\nbility\n\ud835\udc47\u00d6\n\ud835\udc61=1\u00d6\n\u0000\ud835\udc5a\u0014\ud835\udc57\u0014\ud835\udc5a, \ud835\udc57\u22600\ud835\udc43\u00b9\ud835\udc37=1j\ud835\udc64\u00b9\ud835\udc61\u00ba,\ud835\udc64\u00b9\ud835\udc61\u00b8\ud835\udc57\u00ba\u00ba. (15.2.3)\nHowever, (15.2.3 )only considers those events that involve positive examples. As a result,\nthe joint probability in (15.2.3 )is maximized to 1 only if all the word vectors are equal\nto infinity. Of course, such results are meaningless. To make the objective function more\nmeaningful, negative sampling adds negative examples sampled from a predefined distri-\nbution.\nDenote by\ud835\udc46the event that a context word \ud835\udc64\ud835\udc5ccomes from the context window of a cen-\nter word\ud835\udc64\ud835\udc50. For this event involving \ud835\udc64\ud835\udc5c, from a predefined distribution \ud835\udc43\u00b9\ud835\udc64\u00basample\ud835\udc3e\nnoise words that are not from this context window. Denote by \ud835\udc41\ud835\udc58the event that a noise\nword\ud835\udc64\ud835\udc58(\ud835\udc58=1,...,\ud835\udc3e) does not come from the context window of \ud835\udc64\ud835\udc50. Assume that these\neventsinvolvingboththepositiveexampleandnegativeexamples \ud835\udc46,\ud835\udc41 1,...,\ud835\udc41\ud835\udc3earemutu-\nally independent. Negative sampling rewrites the joint probability (involving only positive\nexamples) in (15.2.3 )as\n\ud835\udc47\u00d6\n\ud835\udc61=1\u00d6\n\u0000\ud835\udc5a\u0014\ud835\udc57\u0014\ud835\udc5a, \ud835\udc57\u22600\ud835\udc43\u00b9\ud835\udc64\u00b9\ud835\udc61\u00b8\ud835\udc57\u00baj\ud835\udc64\u00b9\ud835\udc61\u00ba\u00ba, (15.2.4)\nwhere the conditional probability is approximated through events \ud835\udc46,\ud835\udc41 1,...,\ud835\udc41\ud835\udc3e:\n\ud835\udc43\u00b9\ud835\udc64\u00b9\ud835\udc61\u00b8\ud835\udc57\u00baj\ud835\udc64\u00b9\ud835\udc61\u00ba\u00ba=\ud835\udc43\u00b9\ud835\udc37=1j\ud835\udc64\u00b9\ud835\udc61\u00ba,\ud835\udc64\u00b9\ud835\udc61\u00b8\ud835\udc57\u00ba\u00ba\ud835\udc3e\u00d6\n\ud835\udc58=1, \ud835\udc64\ud835\udc58\u0018\ud835\udc43\u00b9\ud835\udc64\u00ba\ud835\udc43\u00b9\ud835\udc37=0j\ud835\udc64\u00b9\ud835\udc61\u00ba,\ud835\udc64\ud835\udc58\u00ba.(15.2.5)\nDenote by\ud835\udc56\ud835\udc61and\u210e\ud835\udc58the indices of a word \ud835\udc64\u00b9\ud835\udc61\u00baat time step\ud835\udc61of a text sequence and a noise\nword\ud835\udc64\ud835\udc58, respectively.", "mimetype": "text/plain", "start_char_idx": 1485027, "end_char_idx": 1487603, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "18a08a9b-7b9f-4b09-ac5c-af5fa10ff3cf": {"__data__": {"id_": "18a08a9b-7b9f-4b09-ac5c-af5fa10ff3cf", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "10211d91-9ae7-404c-946e-cf40ea3aef94", "node_type": "1", "metadata": {}, "hash": "c5546917d44e539417fea880fa0dcf505745375444821f78883a592dd3786695", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fd13fe4b-ecd3-4a3a-9590-5036fd87c338", "node_type": "1", "metadata": {}, "hash": "07eebde8571c1fbc79d627ff6f8dae771e67a7f8cfac507da429c06b291a96cd", "class_name": "RelatedNodeInfo"}}, "text": "(15.2.5)\nDenote by\ud835\udc56\ud835\udc61and\u210e\ud835\udc58the indices of a word \ud835\udc64\u00b9\ud835\udc61\u00baat time step\ud835\udc61of a text sequence and a noise\nword\ud835\udc64\ud835\udc58, respectively. The logarithmic loss with respect to the conditional probabilities in\n(15.2.5 )is\n\u0000log\ud835\udc43\u00b9\ud835\udc64\u00b9\ud835\udc61\u00b8\ud835\udc57\u00baj\ud835\udc64\u00b9\ud835\udc61\u00ba\u00ba=\u0000log\ud835\udc43\u00b9\ud835\udc37=1j\ud835\udc64\u00b9\ud835\udc61\u00ba,\ud835\udc64\u00b9\ud835\udc61\u00b8\ud835\udc57\u00ba\u00ba\u0000\ud835\udc3e\u00d5\n\ud835\udc58=1, \ud835\udc64\ud835\udc58\u0018\ud835\udc43\u00b9\ud835\udc64\u00balog\ud835\udc43\u00b9\ud835\udc37=0j\ud835\udc64\u00b9\ud835\udc61\u00ba,\ud835\udc64\ud835\udc58\u00ba\n=\u0000log\ud835\udf0e\u0010\nu>\n\ud835\udc56\ud835\udc61\u00b8\ud835\udc57v\ud835\udc56\ud835\udc61\u0011\n\u0000\ud835\udc3e\u00d5\n\ud835\udc58=1, \ud835\udc64\ud835\udc58\u0018\ud835\udc43\u00b9\ud835\udc64\u00balog\u0010\n1\u0000\ud835\udf0e\u0010\nu>\n\u210e\ud835\udc58v\ud835\udc56\ud835\udc61\u0011\u0011\n=\u0000log\ud835\udf0e\u0010\nu>\n\ud835\udc56\ud835\udc61\u00b8\ud835\udc57v\ud835\udc56\ud835\udc61\u0011\n\u0000\ud835\udc3e\u00d5\n\ud835\udc58=1, \ud835\udc64\ud835\udc58\u0018\ud835\udc43\u00b9\ud835\udc64\u00balog\ud835\udf0e\u0010\n\u0000u>\n\u210e\ud835\udc58v\ud835\udc56\ud835\udc61\u0011\n.\n(15.2.6)\nWe can see that now the computational cost for gradients at each training step has nothing\ntodowiththedictionarysize, butlinearlydependson \ud835\udc3e. Whensettingthehyperparameter\n\ud835\udc3etoasmallervalue,thecomputationalcostforgradientsateachtrainingstepwithnegative\nsampling is smaller.\n698 Natural Language Processing: Pretraining\n15.2.2HierarchicalSoftmax\nAsanalternativeapproximatetrainingmethod, hierarchicalsoftmax usesthebinarytree, a\ndata structure illustrated in Fig. 15.2.1 , where each leaf node of the tree represents a word\nin dictionaryV.\ntFig. 15.2.1 Hierarchical softmax for approximate training, where each leaf node of the tree represents\na word in the dictionary.\nDenote by\ud835\udc3f\u00b9\ud835\udc64\u00bathe number of nodes (including both ends) on the path from the root node\nto the leaf node representing word \ud835\udc64in the binary tree. Let \ud835\udc5b\u00b9\ud835\udc64,\ud835\udc57\u00babe the\ud835\udc57thnode on this\npath, with its context word vector being u\ud835\udc5b\u00b9\ud835\udc64,\ud835\udc57\u00ba. For example, \ud835\udc3f\u00b9\ud835\udc643\u00ba=4inFig. 15.2.1 .\nHierarchical softmax approximates the conditional probability in (15.1.4 )as\n\ud835\udc43\u00b9\ud835\udc64\ud835\udc5cj\ud835\udc64\ud835\udc50\u00ba=\ud835\udc3f\u00b9\ud835\udc64\ud835\udc5c\u00ba\u00001\u00d6\n\ud835\udc57=1\ud835\udf0e\u0010\n\u00bb\u00bb\ud835\udc5b\u00b9\ud835\udc64\ud835\udc5c,\ud835\udc57\u00b81\u00ba=leftChild\u00b9\ud835\udc5b\u00b9\ud835\udc64\ud835\udc5c,\ud835\udc57\u00ba\u00ba\u00bc\u00bc\u0001u>\n\ud835\udc5b\u00b9\ud835\udc64\ud835\udc5c,\ud835\udc57\u00bav\ud835\udc50\u0011\n,\n(15.2.7)\nwhere function \ud835\udf0eis defined in (15.2.2 ), and leftChild\u00b9\ud835\udc5b\u00bais the left child node of node \ud835\udc5b:\nif\ud835\udc65is true,\u00bb\u00bb\ud835\udc65\u00bc\u00bc=1; otherwise\u00bb\u00bb\ud835\udc65\u00bc\u00bc=\u00001.\nTo illustrate, let\u2019s calculate the conditional probability of generating word \ud835\udc643given word\n\ud835\udc64\ud835\udc50inFig. 15.2.1 . This requires dot products between the word vector v\ud835\udc50of\ud835\udc64\ud835\udc50and non-\nleaf node vectors on the path (the path in bold in Fig.", "mimetype": "text/plain", "start_char_idx": 1487487, "end_char_idx": 1489328, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fd13fe4b-ecd3-4a3a-9590-5036fd87c338": {"__data__": {"id_": "fd13fe4b-ecd3-4a3a-9590-5036fd87c338", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "18a08a9b-7b9f-4b09-ac5c-af5fa10ff3cf", "node_type": "1", "metadata": {}, "hash": "d913a33870aeaea8a8a68869a5c2359295f4e8dcf1fddf5f18bdf3a5d7137b12", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f137b538-04d9-4b12-a449-9fa9d9a1193e", "node_type": "1", "metadata": {}, "hash": "1823c55b6eb64b3a02c28a2bd5945eed8064cc038e83c8414a8fdad6273c6355", "class_name": "RelatedNodeInfo"}}, "text": "To illustrate, let\u2019s calculate the conditional probability of generating word \ud835\udc643given word\n\ud835\udc64\ud835\udc50inFig. 15.2.1 . This requires dot products between the word vector v\ud835\udc50of\ud835\udc64\ud835\udc50and non-\nleaf node vectors on the path (the path in bold in Fig. 15.2.1 ) from the root to \ud835\udc643, which is\ntraversed left, right, then left:\n\ud835\udc43\u00b9\ud835\udc643j\ud835\udc64\ud835\udc50\u00ba=\ud835\udf0e\u00b9u>\n\ud835\udc5b\u00b9\ud835\udc643,1\u00bav\ud835\udc50\u00ba\u0001\ud835\udf0e\u00b9\u0000u>\n\ud835\udc5b\u00b9\ud835\udc643,2\u00bav\ud835\udc50\u00ba\u0001\ud835\udf0e\u00b9u>\n\ud835\udc5b\u00b9\ud835\udc643,3\u00bav\ud835\udc50\u00ba. (15.2.8)\nSince\ud835\udf0e\u00b9\ud835\udc65\u00ba\u00b8\ud835\udf0e\u00b9\u0000\ud835\udc65\u00ba=1, it holds that the conditional probabilities of generating all the\nwords in dictionary Vbased on any word \ud835\udc64\ud835\udc50sum up to one:\n\u00d5\n\ud835\udc642V\ud835\udc43\u00b9\ud835\udc64j\ud835\udc64\ud835\udc50\u00ba=1.(15.2.9)\nFortunately, since \ud835\udc3f\u00b9\ud835\udc64\ud835\udc5c\u00ba\u00001is on the order ofO\u00b9log2jVj\u00badue to the binary tree struc-\nture, when the dictionary size Vis huge, the computational cost for each training step us-\ning hierarchical softmax is significantly reduced compared with that without approximate\ntraining.\n699 The Dataset for Pretraining Word Embeddings\n229\n23015.2.3Summary\n\u000fNegative sampling constructs the loss function by considering mutually independent\nevents that involve both positive and negative examples. The computational cost for\ntraining is linearly dependent on the number of noise words at each step.\n\u000fHierarchical softmax constructs the loss function using the path from the root node to\nthe leaf node in the binary tree. The computational cost for training is dependent on\nthe logarithm of the dictionary size at each step.\n15.2.4Exercises\n1.How can we sample noise words in negative sampling?\n2.Verify that (15.2.9 )holds.\n3.Howtotrainthecontinuousbagofwordsmodelusingnegativesamplingandhierarchi-\ncal softmax, respectively?\nDiscussions229.\n15.3The DatasetforPretrainingWordEmbeddings\nNow that we know the technical details of the word2vec models and approximate training\nmethods, let\u2019s walk through their implementations. Specifically, we will take the skip-\ngram model in Section 15.1 and negative sampling in Section 15.2 as an example. In this\nsection, we begin with the dataset for pretraining the word embedding model: the original\nformat of the data will be transformed into minibatches that can be iterated over during\ntraining.\nimport collections\nimport math\nimport os\nimport random\nimport torch\nfrom d2l import torch asd2l\n15.3.1Readingthe Dataset\nThedatasetthatweusehereis PennTreeBank(PTB)230.ThiscorpusissampledfromWall\nStreet Journal articles, split into training, validation, and test sets. In the original format,\neach line of the text file represents a sentence of words that are separated by spaces. Here\nwe treat each word as a token.\n700 Natural Language Processing: Pretraining\n#@save\nd2l.DATA_HUB[ 'ptb']=(d2l .DATA_URL +'ptb.zip ',\n'319d85e578af0cdc590547f26231e4e31cdf1e42 ')\n#@save\ndef read_ptb ():\n\"\"\"Load the PTB dataset into a list of text lines.\"\"\"\ndata_dir =d2l.download_extract( 'ptb')\n# Read the training set\nwith open (os.path .join(data_dir, 'ptb.train.txt '))asf:\nraw_text =f.read()\nreturn [line .split() for line inraw_text .split( '\\n')]\nsentences =read_ptb()\nf'# sentences: {len(sentences) }'\nDownloading ../data /ptb.zip from http ://d2l-data .s3-accelerate .amazonaws .com/\n\u21a9!ptb.zip...\n'# sentences: 42069 '\nAfter reading the training set, we build a vocabulary for the corpus, where any word that\nappears less than 10 times is replaced by the \u201c<unk>\u201d token. Note that the original dataset\nalso contains \u201c<unk>\u201d tokens that represent rare (unknown) words.", "mimetype": "text/plain", "start_char_idx": 1489098, "end_char_idx": 1492418, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f137b538-04d9-4b12-a449-9fa9d9a1193e": {"__data__": {"id_": "f137b538-04d9-4b12-a449-9fa9d9a1193e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fd13fe4b-ecd3-4a3a-9590-5036fd87c338", "node_type": "1", "metadata": {}, "hash": "07eebde8571c1fbc79d627ff6f8dae771e67a7f8cfac507da429c06b291a96cd", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "758e590b-5a22-47d9-94c5-0738db8f6d43", "node_type": "1", "metadata": {}, "hash": "4abaf70b3a0b0fb01cb53260ef0b3d079af0b5f50ab9342856b10bbd07adc9bf", "class_name": "RelatedNodeInfo"}}, "text": "data_dir =d2l.download_extract( 'ptb')\n# Read the training set\nwith open (os.path .join(data_dir, 'ptb.train.txt '))asf:\nraw_text =f.read()\nreturn [line .split() for line inraw_text .split( '\\n')]\nsentences =read_ptb()\nf'# sentences: {len(sentences) }'\nDownloading ../data /ptb.zip from http ://d2l-data .s3-accelerate .amazonaws .com/\n\u21a9!ptb.zip...\n'# sentences: 42069 '\nAfter reading the training set, we build a vocabulary for the corpus, where any word that\nappears less than 10 times is replaced by the \u201c<unk>\u201d token. Note that the original dataset\nalso contains \u201c<unk>\u201d tokens that represent rare (unknown) words.\nvocab =d2l.Vocab(sentences, min_freq =10)\nf'vocab size: {len(vocab) }'\n'vocab size: 6719 '\n15.3.2Subsampling\nText data typically have high-frequency words such as \u201cthe\u201d, \u201ca\u201d, and \u201cin\u201d: they may even\noccur billions of times in very large corpora. However, these words often co-occur with\nmany different words in context windows, providing little useful signals. For instance,\nconsider the word \u201cchip\u201d in a context window: intuitively its co-occurrence with a low-\nfrequency word \u201cintel\u201d is more useful in training than the co-occurrence with a high-\nfrequency word \u201ca\u201d. Moreover, training with vast amounts of (high-frequency) words is\nslow. Thus, when training word embedding models, high-frequency words can be sub-\nsampled (Mikolovet al., 2013). Specifically, each indexed word \ud835\udc64\ud835\udc56in the dataset will be\ndiscarded with probability\n\ud835\udc43\u00b9\ud835\udc64\ud835\udc56\u00ba=max\u0012\n1\u0000r\ud835\udc61\n\ud835\udc53\u00b9\ud835\udc64\ud835\udc56\u00ba,0\u0013\n, (15.3.1)\nwhere\ud835\udc53\u00b9\ud835\udc64\ud835\udc56\u00bais the ratio of the number of words \ud835\udc64\ud835\udc56to the total number of words in the\ndataset, and the constant \ud835\udc61is a hyperparameter ( 10\u00004in the experiment). We can see that\n701 The Dataset for Pretraining Word Embeddings\nonlywhentherelativefrequency \ud835\udc53\u00b9\ud835\udc64\ud835\udc56\u00ba>\ud835\udc61canthe(high-frequency)word \ud835\udc64\ud835\udc56bediscarded,\nand the higher the relative frequency of the word, the greater the probability of being dis-\ncarded.\n#@save\ndef subsample (sentences, vocab):\n\"\"\"Subsample high-frequency words.\"\"\"\n# Exclude unknown tokens ('<unk>')\nsentences =[[token for token inline ifvocab[token] !=vocab .unk]\nfor line insentences]\ncounter =collections .Counter([\ntoken for line insentences for token inline])\nnum_tokens =sum(counter .values())\n# Return True if `token` is kept during subsampling\ndef keep (token):\nreturn (random .uniform( 0,1)<\nmath .sqrt( 1e-4 /counter[token] *num_tokens))\nreturn ([[token for token inline ifkeep(token)] for line insentences],\ncounter)\nsubsampled, counter =subsample(sentences, vocab)\nThe following code snippet plots the histogram of the number of tokens per sentence be-\nfore and after subsampling. As expected, subsampling significantly shortens sentences by\ndropping high-frequency words, which will lead to training speedup.\nd2l.show_list_len_pair_hist([ 'origin ','subsampled '],'# tokens per sentence ',\n'count ', sentences, subsampled);\nFor individual tokens, the sampling rate of the high-frequency word \u201cthe\u201d is less than\n1/20.\ndef compare_counts (token):\nreturn (f'# of \"{token }\":'\nf'before= {sum([l.count(token) for linsentences]) },'\nf'after= {sum([l.count(token) for linsubsampled]) }')\ncompare_counts( 'the')\n702 Natural Language Processing: Pretraining\n'# of \"the\": before=50770, after=2010 '\nIn contrast, low-frequency words \u201cjoin\u201d are completely kept.\ncompare_counts( 'join ')\n'# of \"join \": before=45, after=45 '\nAfter subsampling, we map tokens to their indices for the corpus.", "mimetype": "text/plain", "start_char_idx": 1491800, "end_char_idx": 1495191, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "758e590b-5a22-47d9-94c5-0738db8f6d43": {"__data__": {"id_": "758e590b-5a22-47d9-94c5-0738db8f6d43", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f137b538-04d9-4b12-a449-9fa9d9a1193e", "node_type": "1", "metadata": {}, "hash": "1823c55b6eb64b3a02c28a2bd5945eed8064cc038e83c8414a8fdad6273c6355", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "71a7ba79-fafd-4a22-9eee-b6f0135aef1c", "node_type": "1", "metadata": {}, "hash": "d11ff43d0aa3d5f961c424256dbf34c55820ff161f91b6754d24e9471168fb43", "class_name": "RelatedNodeInfo"}}, "text": "d2l.show_list_len_pair_hist([ 'origin ','subsampled '],'# tokens per sentence ',\n'count ', sentences, subsampled);\nFor individual tokens, the sampling rate of the high-frequency word \u201cthe\u201d is less than\n1/20.\ndef compare_counts (token):\nreturn (f'# of \"{token }\":'\nf'before= {sum([l.count(token) for linsentences]) },'\nf'after= {sum([l.count(token) for linsubsampled]) }')\ncompare_counts( 'the')\n702 Natural Language Processing: Pretraining\n'# of \"the\": before=50770, after=2010 '\nIn contrast, low-frequency words \u201cjoin\u201d are completely kept.\ncompare_counts( 'join ')\n'# of \"join \": before=45, after=45 '\nAfter subsampling, we map tokens to their indices for the corpus.\ncorpus =[vocab[line] for line insubsampled]\ncorpus[: 3]\n[[], [ 4127 ,3228 ,1773 ], [ 3922 ,1922 ,4743 ,2696 ]]\n15.3.3Extracting Center Wordsand ContextWords\nThefollowing get_centers_and_contexts functionextractsallthecenterwordsandtheir\ncontextwordsfrom corpus. Ituniformlysamplesanintegerbetween1and max_window_size\nat random as the context window size. For any center word, those words whose distance\nfrom it does not exceed the sampled context window size are its context words.\n#@save\ndef get_centers_and_contexts (corpus, max_window_size):\n\"\"\"Return center words and context words in skip-gram.\"\"\"\ncenters, contexts =[], []\nfor line incorpus:\n# To form a \"center word--context word\" pair, each sentence needs to\n# have at least 2 words\niflen(line) <2:\ncontinue\ncenters +=line\nfor iinrange (len(line)): # Context window centered at `i`\nwindow_size =random .randint( 1, max_window_size)\nindices =list (range (max(0, i -window_size),\nmin(len(line), i +1+window_size)))\n# Exclude the center word from the context words\nindices .remove(i)\ncontexts .append([line[idx] for idx inindices])\nreturn centers, contexts\nNext,wecreateanartificialdatasetcontainingtwosentencesof7and3words,respectively.\nLet the maximum context window size be 2 and print all the center words and their context\nwords.\n703 The Dataset for Pretraining Word Embeddings\ntiny_dataset =[list (range (7)), list (range (7,10))]\nprint ('dataset ', tiny_dataset)\nfor center, context inzip(*get_centers_and_contexts(tiny_dataset, 2)):\nprint ('center ', center, 'has contexts ', context)\ndataset [[ 0,1,2,3,4,5,6], [ 7,8,9]]\ncenter 0has contexts [ 1]\ncenter 1has contexts [ 0,2]\ncenter 2has contexts [ 0,1,3,4]\ncenter 3has contexts [ 1,2,4,5]\ncenter 4has contexts [ 2,3,5,6]\ncenter 5has contexts [ 3,4,6]\ncenter 6has contexts [ 5]\ncenter 7has contexts [ 8,9]\ncenter 8has contexts [ 7,9]\ncenter 9has contexts [ 7,8]\nWhen training on the PTB dataset, we set the maximum context window size to 5. The\nfollowing extracts all the center words and their context words in the dataset.\nall_centers, all_contexts =get_centers_and_contexts(corpus, 5)\nf'# center-context pairs: {sum([len(contexts) for contexts inall_contexts]) }'\n'# center-context pairs: 1503420 '\n15.3.4NegativeSampling\nWe use negative sampling for approximate training. To sample noise words according to a\npredefineddistribution,wedefinethefollowing RandomGenerator class,wherethe(possi-\nblyunnormalized)samplingdistributionispassedviatheargument sampling_weights .\n#@save\nclass RandomGenerator :\n\"\"\"Randomly draw among {1, ..., n} according to n sampling weights.\"\"\"", "mimetype": "text/plain", "start_char_idx": 1494523, "end_char_idx": 1497779, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "71a7ba79-fafd-4a22-9eee-b6f0135aef1c": {"__data__": {"id_": "71a7ba79-fafd-4a22-9eee-b6f0135aef1c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "758e590b-5a22-47d9-94c5-0738db8f6d43", "node_type": "1", "metadata": {}, "hash": "4abaf70b3a0b0fb01cb53260ef0b3d079af0b5f50ab9342856b10bbd07adc9bf", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ec50e8ee-346b-4904-817e-cce8a8829bf9", "node_type": "1", "metadata": {}, "hash": "8ab4430d8c2c68f17e56e53c1a9b4795e297da3620567821c8c207521b150986", "class_name": "RelatedNodeInfo"}}, "text": "The\nfollowing extracts all the center words and their context words in the dataset.\nall_centers, all_contexts =get_centers_and_contexts(corpus, 5)\nf'# center-context pairs: {sum([len(contexts) for contexts inall_contexts]) }'\n'# center-context pairs: 1503420 '\n15.3.4NegativeSampling\nWe use negative sampling for approximate training. To sample noise words according to a\npredefineddistribution,wedefinethefollowing RandomGenerator class,wherethe(possi-\nblyunnormalized)samplingdistributionispassedviatheargument sampling_weights .\n#@save\nclass RandomGenerator :\n\"\"\"Randomly draw among {1, ..., n} according to n sampling weights.\"\"\"\ndef __init__ (self , sampling_weights):\n# Exclude\nself .population =list (range (1,len(sampling_weights) +1))\nself .sampling_weights =sampling_weights\nself .candidates =[]\nself .i=0\ndef draw (self ):\nifself .i==len(self .candidates):\n# Cache `k` random sampling results\nself .candidates =random .choices(\nself .population, self .sampling_weights, k =10000 )\nself .i=0\nself .i+=1\nreturn self .candidates[ self .i-1]\n704 Natural Language Processing: Pretraining\nFor example, we can draw 10 random variables \ud835\udc4bamong indices 1, 2, and 3 with sampling\nprobabilities \ud835\udc43\u00b9\ud835\udc4b=1\u00ba=2\u009d9,\ud835\udc43\u00b9\ud835\udc4b=2\u00ba=3\u009d9, and\ud835\udc43\u00b9\ud835\udc4b=3\u00ba=4\u009d9as follows.\nFor a pair of center word and context word, we randomly sample K(5 in the experiment)\nnoisewords. Accordingtothesuggestionsintheword2vecpaper, thesamplingprobability\n\ud835\udc43\u00b9\ud835\udc64\u00baof a noise word \ud835\udc64is set to its relative frequency in the dictionary raised to the power\nof 0.75 ( Mikolovetal., 2013).\n#@save\ndef get_negatives (all_contexts, vocab, counter, K):\n\"\"\"Return noise words in negative sampling.\"\"\"\n# Sampling weights for words with indices 1, 2, ... (index 0 is the\n# excluded unknown token) in the vocabulary\nsampling_weights =[counter[vocab .to_tokens(i)] **0.75\nfor iinrange (1,len(vocab))]\nall_negatives, generator =[], RandomGenerator(sampling_weights)\nfor contexts inall_contexts:\nnegatives =[]\nwhile len(negatives) <len(contexts) *K:\nneg =generator .draw()\n# Noise words cannot be context words\nifneg not incontexts:\nnegatives .append(neg)\nall_negatives .append(negatives)\nreturn all_negatives\nall_negatives =get_negatives(all_contexts, vocab, counter, 5)\n15.3.5LoadingTrainingExamplesin Minibatches\nAfter all the center words together with their context words and sampled noise words are\nextracted, they will be transformed into minibatches of examples that can be iteratively\nloaded during training.\nInaminibatch,the \ud835\udc56thexampleincludesacenterwordandits \ud835\udc5b\ud835\udc56contextwordsand \ud835\udc5a\ud835\udc56noise\nwords. Due to varying context window sizes, \ud835\udc5b\ud835\udc56\u00b8\ud835\udc5a\ud835\udc56varies for different \ud835\udc56. Thus, for each\nexample we concatenate its context words and noise words in the contexts_negatives\nvariable, and pad zeros until the concatenation length reaches max\ud835\udc56\ud835\udc5b\ud835\udc56\u00b8\ud835\udc5a\ud835\udc56(max_len ). To\nexcludepaddingsinthecalculationoftheloss,wedefineamaskvariable masks. Thereisa\none-to-onecorrespondencebetweenelementsin masksandelementsin contexts_negatives ,\nwherezeros(otherwiseones)in maskscorrespondtopaddingsin contexts_negatives .\nTo distinguish between positive and negative examples, we separate context words from\nnoisewordsin contexts_negatives viaa labelsvariable. Similarto masks,thereisalso\naone-to-onecorrespondencebetweenelementsin labelsandelementsin contexts_negatives ,\nwhere ones (otherwise zeros) in labelscorrespond to context words (positive examples)\nincontexts_negatives .\nThe above idea is implemented in the following batchify function. Its input datais a\nlist with length equal to the batch size, where each element is an example consisting of\nthe center word center, its context words context , and its noise words negative . This\n705 The Dataset for Pretraining Word Embeddings\nfunction returns a minibatch that can be loaded for calculations during training, such as\nincluding the mask variable.", "mimetype": "text/plain", "start_char_idx": 1497146, "end_char_idx": 1500958, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ec50e8ee-346b-4904-817e-cce8a8829bf9": {"__data__": {"id_": "ec50e8ee-346b-4904-817e-cce8a8829bf9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "71a7ba79-fafd-4a22-9eee-b6f0135aef1c", "node_type": "1", "metadata": {}, "hash": "d11ff43d0aa3d5f961c424256dbf34c55820ff161f91b6754d24e9471168fb43", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "57961b04-9358-4554-ae3f-3a8dea55ec6c", "node_type": "1", "metadata": {}, "hash": "737a1edbb00cad37f475f801ece10fef291a3bcacc669c498883a103b0484b45", "class_name": "RelatedNodeInfo"}}, "text": "To distinguish between positive and negative examples, we separate context words from\nnoisewordsin contexts_negatives viaa labelsvariable. Similarto masks,thereisalso\naone-to-onecorrespondencebetweenelementsin labelsandelementsin contexts_negatives ,\nwhere ones (otherwise zeros) in labelscorrespond to context words (positive examples)\nincontexts_negatives .\nThe above idea is implemented in the following batchify function. Its input datais a\nlist with length equal to the batch size, where each element is an example consisting of\nthe center word center, its context words context , and its noise words negative . This\n705 The Dataset for Pretraining Word Embeddings\nfunction returns a minibatch that can be loaded for calculations during training, such as\nincluding the mask variable.\n#@save\ndef batchify (data):\n\"\"\"Return a minibatch of examples for skip-gram with negative sampling.\"\"\"\nmax_len =max(len(c) +len(n) for _, c, n indata)\ncenters, contexts_negatives, masks, labels =[], [], [], []\nfor center, context, negative indata:\ncur_len =len(context) +len(negative)\ncenters +=[center]\ncontexts_negatives +=[context +negative +[0]*(max_len -cur_len)]\nmasks +=[[1]*cur_len +[0]*(max_len -cur_len)]\nlabels +=[[1]*len(context) +[0]*(max_len -len(context))]\nreturn (torch .tensor(centers) .reshape(( -1,1)), torch .tensor(\ncontexts_negatives), torch .tensor(masks), torch .tensor(labels))\nLet\u2019s test this function using a minibatch of two examples.\nx_1 =(1, [2,2], [ 3,3,3,3])\nx_2 =(1, [2,2,2], [ 3,3])\nbatch =batchify((x_1, x_2))\nnames =['centers ','contexts_negatives ','masks ','labels ']\nfor name, data inzip(names, batch):\nprint (name, '=', data)\ncenters =tensor([[ 1],\n[1]])\ncontexts_negatives =tensor([[ 2,2,3,3,3,3],\n[2,2,2,3,3,0]])\nmasks =tensor([[ 1,1,1,1,1,1],\n[1,1,1,1,1,0]])\nlabels =tensor([[ 1,1,0,0,0,0],\n[1,1,1,0,0,0]])\n15.3.6PuttingIt All Together\nLast,wedefinethe load_data_ptb functionthatreadsthePTBdatasetandreturnsthedata\niterator and the vocabulary.\n#@save\ndef load_data_ptb (batch_size, max_window_size, num_noise_words):\n\"\"\"Download the PTB dataset and then load it into memory.\"\"\"\nnum_workers =d2l.get_dataloader_workers()\nsentences =read_ptb()\nvocab =d2l.Vocab(sentences, min_freq =10)\nsubsampled, counter =subsample(sentences, vocab)\ncorpus =[vocab[line] for line insubsampled]\nall_centers, all_contexts =get_centers_and_contexts(\ncorpus, max_window_size)\n(continues on next page)\n706 Natural Language Processing: Pretraining\n(continued from previous page)\nall_negatives =get_negatives(\nall_contexts, vocab, counter, num_noise_words)\nclass PTBDataset (torch .utils .data .Dataset):\ndef __init__ (self , centers, contexts, negatives):\nassert len(centers) ==len(contexts) ==len(negatives)\nself .centers =centers\nself .contexts =contexts\nself .negatives =negatives\ndef __getitem__ (self , index):\nreturn (self .centers[index], self .contexts[index],\nself .negatives[index])\ndef __len__ (self ):\nreturn len(self .centers)\ndataset =PTBDataset(all_centers, all_contexts, all_negatives)\ndata_iter =torch .utils .data .DataLoader(dataset, batch_size, shuffle =True ,\ncollate_fn =batchify,\nnum_workers =num_workers)\nreturn data_iter, vocab\nLet\u2019s print the first minibatch of the data iterator.\ndata_iter, vocab =load_data_ptb( 512,5,5)\nfor batch indata_iter:\nfor name, data inzip(names, batch):\nprint (name, 'shape: ', data .shape)\nbreak\ncenters shape: torch .Size([ 512,1])\ncontexts_negatives shape: torch .Size([ 512,60])\nmasks shape: torch .Size([ 512,60])\nlabels shape: torch .Size([ 512,60])\n15.3.7Summary\n\u000fHigh-frequency words may not be so useful in training.", "mimetype": "text/plain", "start_char_idx": 1500170, "end_char_idx": 1503758, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "57961b04-9358-4554-ae3f-3a8dea55ec6c": {"__data__": {"id_": "57961b04-9358-4554-ae3f-3a8dea55ec6c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ec50e8ee-346b-4904-817e-cce8a8829bf9", "node_type": "1", "metadata": {}, "hash": "8ab4430d8c2c68f17e56e53c1a9b4795e297da3620567821c8c207521b150986", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "50eb6a2b-3299-475d-a63d-2273ddf245b2", "node_type": "1", "metadata": {}, "hash": "78f5be8342d31a54a0c41a192ccd1463f5c36bfbcd4d852e58ff75a50a2404bc", "class_name": "RelatedNodeInfo"}}, "text": "data_iter, vocab =load_data_ptb( 512,5,5)\nfor batch indata_iter:\nfor name, data inzip(names, batch):\nprint (name, 'shape: ', data .shape)\nbreak\ncenters shape: torch .Size([ 512,1])\ncontexts_negatives shape: torch .Size([ 512,60])\nmasks shape: torch .Size([ 512,60])\nlabels shape: torch .Size([ 512,60])\n15.3.7Summary\n\u000fHigh-frequency words may not be so useful in training. We can subsample them for\nspeedup in training.\n\u000fFor computational efficiency, we load examples in minibatches. We can define other\nvariablestodistinguishpaddingsfromnon-paddings,andpositiveexamplesfromneg-\native ones.\n15.3.8Exercises\n1.How does the running time of code in this section changes if not using subsampling?\n707 Pretraining word2vec\n2312.TheRandomGenerator class caches krandom sampling results. Set kto other values\nand see how it affects the data loading speed.\n3.What other hyperparameters in the code of this section may affect the data loading\nspeed?\nDiscussions231.\n15.4Pretrainingword2vec\nWegoontoimplementtheskip-grammodeldefinedin Section15.1 . Thenwewillpretrain\nword2vec using negative sampling on the PTB dataset. First of all, let\u2019s obtain the data\niterator and the vocabulary for this dataset by calling the d2l.load_data_ptb function,\nwhich was described in Section 15.3\nimport math\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\nbatch_size, max_window_size, num_noise_words =512,5,5\ndata_iter, vocab =d2l.load_data_ptb(batch_size, max_window_size,\nnum_noise_words)\n15.4.1TheSkip-Gram Model\nWe implement the skip-gram model by using embedding layers and batch matrix multipli-\ncations. First, let\u2019s review how embedding layers work.\nEmbedding Layer\nAs described in Section 10.7 , an embedding layer maps a token\u2019s index to its feature vec-\ntor. The weight of this layer is a matrix whose number of rows equals to the dictio-\nnary size ( input_dim ) and number of columns equals to the vector dimension for each\ntoken ( output_dim ). After a word embedding model is trained, this weight is what we\nneed.\nembed =nn.Embedding(num_embeddings =20, embedding_dim =4)\nprint (f'Parameter embedding_weight ( {embed .weight .shape },'\nf'dtype= {embed .weight .dtype })')\nParameter embedding_weight (torch .Size([ 20,4]), dtype =torch .float32)\nThe input of an embedding layer is the index of a token (word). For any token index \ud835\udc56, its\n708 Natural Language Processing: Pretraining\nvectorrepresentationcanbeobtainedfromthe \ud835\udc56throwoftheweightmatrixintheembedding\nlayer. Since the vector dimension ( output_dim ) was set to 4, the embedding layer returns\nvectors with shape (2, 3, 4) for a minibatch of token indices with shape (2, 3).\nx=torch .tensor([[ 1,2,3], [ 4,5,6]])\nembed(x)\ntensor([[[ 0.7606 ,0.3872 ,-0.1864 ,1.1732 ],\n[1.5035 ,2.3623 ,-1.7542 ,-1.4990 ],\n[-1.2639 ,-1.5313 ,2.1719 ,0.4151 ]],\n[[-1.9079 ,0.2434 ,1.5395 ,1.2990 ],\n[0.7470 ,1.0129 ,0.4039 ,0.0591 ],\n[-0.6293 ,-0.1814 ,-0.4782 ,-0.5289 ]]], grad_fn =<EmbeddingBackward0 >)\nDefining the ForwardPropagation\nIn the forward propagation, the input of the skip-gram model includes the center word\nindices centerofshape(batchsize,1)andtheconcatenatedcontextandnoisewordindices\ncontexts_and_negatives of shape (batch size, max_len ), where max_len is defined in\nSection15.3.5 . Thesetwovariablesarefirsttransformedfromthetokenindicesintovectors\nviatheembeddinglayer,thentheirbatchmatrixmultiplication(describedin Section11.3.2 )\nreturns an output of shape (batch size, 1, max_len ). Each element in the output is the dot\nproduct of a center word vector and a context or noise word vector.", "mimetype": "text/plain", "start_char_idx": 1503386, "end_char_idx": 1506942, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "50eb6a2b-3299-475d-a63d-2273ddf245b2": {"__data__": {"id_": "50eb6a2b-3299-475d-a63d-2273ddf245b2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "57961b04-9358-4554-ae3f-3a8dea55ec6c", "node_type": "1", "metadata": {}, "hash": "737a1edbb00cad37f475f801ece10fef291a3bcacc669c498883a103b0484b45", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "29107840-2bf5-43c6-b33d-17a520f61d7a", "node_type": "1", "metadata": {}, "hash": "a0b94c0722119d903388adb3ea667a6d21a6cb54e28602975b7485df7a85eb6d", "class_name": "RelatedNodeInfo"}}, "text": "Thesetwovariablesarefirsttransformedfromthetokenindicesintovectors\nviatheembeddinglayer,thentheirbatchmatrixmultiplication(describedin Section11.3.2 )\nreturns an output of shape (batch size, 1, max_len ). Each element in the output is the dot\nproduct of a center word vector and a context or noise word vector.\ndef skip_gram (center, contexts_and_negatives, embed_v, embed_u):\nv=embed_v(center)\nu=embed_u(contexts_and_negatives)\npred =torch .bmm(v, u .permute( 0,2,1))\nreturn pred\nLet\u2019s print the output shape of this skip_gram function for some example inputs.\nskip_gram(torch .ones(( 2,1), dtype =torch .long),\ntorch .ones(( 2,4), dtype =torch .long), embed, embed) .shape\ntorch .Size([ 2,1,4])\n15.4.2Training\nBefore training the skip-gram model with negative sampling, let\u2019s first define its loss func-\ntion.\nBinaryCross-EntropyLoss\nAccording to the definition of the loss function for negative sampling in Section 15.2.1 , we\nwill use the binary cross-entropy loss.\n709 Pretraining word2vec\nclass SigmoidBCELoss (nn.Module):\n# Binary cross-entropy loss with masking\ndef __init__ (self ):\nsuper ().__init__ ()\ndef forward (self , inputs, target, mask =None ):\nout =nn.functional .binary_cross_entropy_with_logits(\ninputs, target, weight =mask, reduction =\"none \")\nreturn out.mean(dim =1)\nloss =SigmoidBCELoss()\nRecall our descriptions of the mask variable and the label variable in Section 15.3.5 . The\nfollowing calculates the binary cross-entropy loss for the given variables.\npred =torch .tensor([[ 1.1,-2.2,3.3,-4.4]]*2)\nlabel =torch .tensor([[ 1.0,0.0,0.0,0.0], [ 0.0,1.0,0.0,0.0]])\nmask =torch .tensor([[ 1,1,1,1], [ 1,1,0,0]])\nloss(pred, label, mask) *mask .shape[ 1]/mask .sum(axis =1)\ntensor([ 0.9352 ,1.8462 ])\nBelowshowshowtheaboveresultsarecalculated(inalessefficientway)usingthesigmoid\nactivationfunctioninthebinarycross-entropyloss. Wecanconsiderthetwooutputsastwo\nnormalized losses that are averaged over non-masked predictions.\ndef sigmd (x):\nreturn -math .log( 1/(1+math .exp( -x)))\nprint (f'{(sigmd( 1.1)+sigmd( 2.2)+sigmd( -3.3)+sigmd( 4.4))/4:.4f}')\nprint (f'{(sigmd( -1.1)+sigmd( -2.2))/2:.4f}')\n0.9352\n1.8462\nInitializingModel Parameters\nWe define two embedding layers for all the words in the vocabulary when they are used as\ncenter words and context words, respectively. The word vector dimension embed_size is\nset to 100.\nembed_size =100\nnet =nn.Sequential(nn .Embedding(num_embeddings =len(vocab),\nembedding_dim =embed_size),\nnn.Embedding(num_embeddings =len(vocab),\nembedding_dim =embed_size))\n710 Natural Language Processing: Pretraining\nDefining the TrainingLoop\nThe training loop is defined below. Because of the existence of padding, the calculation of\nthe loss function is slightly different compared to the previous training functions.\ndef train (net, data_iter, lr, num_epochs, device =d2l.try_gpu()):\ndef init_weights (module):\niftype (module) ==nn.Embedding:\nnn.init .xavier_uniform_(module .weight)\nnet.apply(init_weights)\nnet =net.to(device)\noptimizer =torch .optim .Adam(net .parameters(), lr =lr)\nanimator =d2l.Animator(xlabel ='epoch ', ylabel ='loss ',\nxlim =[1, num_epochs])\n# Sum of normalized losses, no.", "mimetype": "text/plain", "start_char_idx": 1506632, "end_char_idx": 1509784, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "29107840-2bf5-43c6-b33d-17a520f61d7a": {"__data__": {"id_": "29107840-2bf5-43c6-b33d-17a520f61d7a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "50eb6a2b-3299-475d-a63d-2273ddf245b2", "node_type": "1", "metadata": {}, "hash": "78f5be8342d31a54a0c41a192ccd1463f5c36bfbcd4d852e58ff75a50a2404bc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ed4a7b55-44a6-4d88-b9ee-e278d300be71", "node_type": "1", "metadata": {}, "hash": "a04b781da4a15c9074fc03923ced66da59a12a6c8f9d8f41f59a7e86832904ba", "class_name": "RelatedNodeInfo"}}, "text": "Because of the existence of padding, the calculation of\nthe loss function is slightly different compared to the previous training functions.\ndef train (net, data_iter, lr, num_epochs, device =d2l.try_gpu()):\ndef init_weights (module):\niftype (module) ==nn.Embedding:\nnn.init .xavier_uniform_(module .weight)\nnet.apply(init_weights)\nnet =net.to(device)\noptimizer =torch .optim .Adam(net .parameters(), lr =lr)\nanimator =d2l.Animator(xlabel ='epoch ', ylabel ='loss ',\nxlim =[1, num_epochs])\n# Sum of normalized losses, no. of normalized losses\nmetric =d2l.Accumulator( 2)\nfor epoch inrange (num_epochs):\ntimer, num_batches =d2l.Timer(), len(data_iter)\nfor i, batch inenumerate (data_iter):\noptimizer .zero_grad()\ncenter, context_negative, mask, label =[\ndata .to(device) for data inbatch]\npred =skip_gram(center, context_negative, net[ 0], net[ 1])\nl=(loss(pred .reshape(label .shape) .float(), label .float(), mask)\n/mask .sum(axis =1)*mask .shape[ 1])\nl.sum() .backward()\noptimizer .step()\nmetric .add(l .sum(), l .numel())\nif(i+1)%(num_batches //5)==0ori==num_batches -1:\nanimator .add(epoch +(i+1)/num_batches,\n(metric[ 0]/metric[ 1],))\nprint (f'loss {metric[ 0]/metric[ 1]:.3f},'\nf'{metric[ 1]/timer .stop() :.1f}tokens/sec on {str(device) }')\nNow we can train a skip-gram model using negative sampling.\nlr, num_epochs =0.002 ,5\ntrain(net, data_iter, lr, num_epochs)\nloss 0.410 ,223485.0 tokens /sec on cuda: 0\n\n711 Word Embedding with Global Vectors (GloVe)\n23215.4.3ApplyingWordEmbeddings\nAfter training the word2vec model, we can use the cosine similarity of word vectors from\nthe trained model to find words from the dictionary that are most semantically similar to\nan input word.\ndef get_similar_tokens (query_token, k, embed):\nW=embed .weight .data\nx=W[vocab[query_token]]\n# Compute the cosine similarity. Add 1e-9 for numerical stability\ncos =torch .mv(W, x) /torch .sqrt(torch .sum(W *W, dim =1)*\ntorch .sum(x *x)+1e-9 )\ntopk =torch .topk(cos, k =k+1)[1].cpu() .numpy() .astype( 'int32 ')\nfor iintopk[ 1:]: # Remove the input words\nprint (f'cosine sim= {float (cos[i]) :.3f}:{vocab .to_tokens(i) }')\nget_similar_tokens( 'chip ',3, net[ 0])\ncosine sim =0.702 : microprocessor\ncosine sim =0.649 : mips\ncosine sim =0.643 : intel\n15.4.4Summary\n\u000fWe can train a skip-gram model with negative sampling using embedding layers and the\nbinary cross-entropy loss.\n\u000fApplicationsofwordembeddingsincludefindingsemanticallysimilarwordsforagiven\nword based on the cosine similarity of word vectors.\n15.4.5Exercises\n1.Usingthetrainedmodel,findsemanticallysimilarwordsforotherinputwords. Canyou\nimprove the results by tuning hyperparameters?\n2.When a training corpus is huge, we often sample context words and noise words for\nthe center words in the current minibatch when updating model parameters . In other\nwords,thesamecenterwordmayhavedifferentcontextwordsornoisewordsindifferent\ntraining epochs. What are the benefits of this method? Try to implement this training\nmethod.\nDiscussions232.\n15.5WordEmbedding with Global Vectors (GloVe)\nWord-word co-occurrences within context windows may carry rich semantic information.\nFor example, in a large corpus word \u201csolid\u201d is more likely to co-occur with \u201cice\u201d than\n712 Natural Language Processing: Pretraining\n\u201csteam\u201d, but word \u201cgas\u201d probably co-occurs with \u201csteam\u201d more frequently than \u201cice\u201d. Be-\nsides, global corpus statistics of such co-occurrences can be precomputed: this can lead\nto more efficient training.", "mimetype": "text/plain", "start_char_idx": 1509263, "end_char_idx": 1512719, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ed4a7b55-44a6-4d88-b9ee-e278d300be71": {"__data__": {"id_": "ed4a7b55-44a6-4d88-b9ee-e278d300be71", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "29107840-2bf5-43c6-b33d-17a520f61d7a", "node_type": "1", "metadata": {}, "hash": "a0b94c0722119d903388adb3ea667a6d21a6cb54e28602975b7485df7a85eb6d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0e0a4085-51c9-47bd-b355-1ec9d825c61a", "node_type": "1", "metadata": {}, "hash": "a6919b59a61abdae0f4bc9bd1d832304613305dc8f22ee5dbf5ba3c1fba656dc", "class_name": "RelatedNodeInfo"}}, "text": "2.When a training corpus is huge, we often sample context words and noise words for\nthe center words in the current minibatch when updating model parameters . In other\nwords,thesamecenterwordmayhavedifferentcontextwordsornoisewordsindifferent\ntraining epochs. What are the benefits of this method? Try to implement this training\nmethod.\nDiscussions232.\n15.5WordEmbedding with Global Vectors (GloVe)\nWord-word co-occurrences within context windows may carry rich semantic information.\nFor example, in a large corpus word \u201csolid\u201d is more likely to co-occur with \u201cice\u201d than\n712 Natural Language Processing: Pretraining\n\u201csteam\u201d, but word \u201cgas\u201d probably co-occurs with \u201csteam\u201d more frequently than \u201cice\u201d. Be-\nsides, global corpus statistics of such co-occurrences can be precomputed: this can lead\nto more efficient training. To leverage statistical information in the entire corpus for word\nembedding,let\u2019sfirstrevisittheskip-grammodelin Section15.1.3 ,butinterpretingitusing\nglobal corpus statistics such as co-occurrence counts.\n15.5.1Skip-Gramwith Global Corpus Statistics\nDenoting by \ud835\udc5e\ud835\udc56\ud835\udc57the conditional probability \ud835\udc43\u00b9\ud835\udc64\ud835\udc57j\ud835\udc64\ud835\udc56\u00baof word\ud835\udc64\ud835\udc57given word\ud835\udc64\ud835\udc56in the\nskip-gram model, we have\n\ud835\udc5e\ud835\udc56\ud835\udc57=exp\u00b9u>\n\ud835\udc57v\ud835\udc56\u00ba\n\u00cd\n\ud835\udc582Vexp\u00b9u>\n\ud835\udc58v\ud835\udc56\u00ba, (15.5.1)\nwhere for any index \ud835\udc56vectors v\ud835\udc56andu\ud835\udc56represent word \ud835\udc64\ud835\udc56as the center word and context\nword, respectively, and V=f0,1,...,jVj\u0000 1gis the index set of the vocabulary.\nConsider word \ud835\udc64\ud835\udc56that may occur multiple times in the corpus. In the entire corpus, all the\ncontext words wherever \ud835\udc64\ud835\udc56is taken as their center word form a multisetC\ud835\udc56of word indices\nthatallows for multiple instances of the same element . For any element, its number of in-\nstancesiscalledits multiplicity . Toillustratewithanexample,supposethatword \ud835\udc64\ud835\udc56occurs\ntwice in the corpus and indices of the context words that take \ud835\udc64\ud835\udc56as their center word in the\ntwocontextwindowsare \ud835\udc58,\ud835\udc57,\ud835\udc5a,\ud835\udc58 and\ud835\udc58,\ud835\udc59,\ud835\udc58,\ud835\udc57. Thus,multisetC\ud835\udc56=f\ud835\udc57,\ud835\udc57,\ud835\udc58,\ud835\udc58,\ud835\udc58,\ud835\udc58,\ud835\udc59,\ud835\udc5ag,\nwhere multiplicities of elements \ud835\udc57,\ud835\udc58,\ud835\udc59,\ud835\udc5a are 2, 4, 1, 1, respectively.\nNow let\u2019s denote the multiplicity of element \ud835\udc57in multisetC\ud835\udc56as\ud835\udc65\ud835\udc56\ud835\udc57. This is the global co-\noccurrence count of word \ud835\udc64\ud835\udc57(as the context word) and word \ud835\udc64\ud835\udc56(as the center word) in\nthe same context window in the entire corpus. Using such global corpus statistics, the loss\nfunction of the skip-gram model is equivalent to\n\u0000\u00d5\n\ud835\udc562V\u00d5\n\ud835\udc572V\ud835\udc65\ud835\udc56\ud835\udc57log\ud835\udc5e\ud835\udc56\ud835\udc57.(15.5.2)\nWe further denote by \ud835\udc65\ud835\udc56the number of all the context words in the context windows where\n\ud835\udc64\ud835\udc56occurs as their center word, which is equivalent to jC\ud835\udc56j. Letting\ud835\udc5d\ud835\udc56\ud835\udc57be the conditional\nprobability\ud835\udc65\ud835\udc56\ud835\udc57\u009d\ud835\udc65\ud835\udc56for generating context word \ud835\udc64\ud835\udc57given center word \ud835\udc64\ud835\udc56,(15.5.2 )can be\nrewritten as\n\u0000\u00d5\n\ud835\udc562V\ud835\udc65\ud835\udc56\u00d5\n\ud835\udc572V\ud835\udc5d\ud835\udc56\ud835\udc57log\ud835\udc5e\ud835\udc56\ud835\udc57.", "mimetype": "text/plain", "start_char_idx": 1511899, "end_char_idx": 1514516, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0e0a4085-51c9-47bd-b355-1ec9d825c61a": {"__data__": {"id_": "0e0a4085-51c9-47bd-b355-1ec9d825c61a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ed4a7b55-44a6-4d88-b9ee-e278d300be71", "node_type": "1", "metadata": {}, "hash": "a04b781da4a15c9074fc03923ced66da59a12a6c8f9d8f41f59a7e86832904ba", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "dd481b27-c04c-491e-a3a6-28665f177ee5", "node_type": "1", "metadata": {}, "hash": "da8903c78843e9ef861789ed2ea84c92fdd30df179b8246fd54e5d995ad01f89", "class_name": "RelatedNodeInfo"}}, "text": "(15.5.2)\nWe further denote by \ud835\udc65\ud835\udc56the number of all the context words in the context windows where\n\ud835\udc64\ud835\udc56occurs as their center word, which is equivalent to jC\ud835\udc56j. Letting\ud835\udc5d\ud835\udc56\ud835\udc57be the conditional\nprobability\ud835\udc65\ud835\udc56\ud835\udc57\u009d\ud835\udc65\ud835\udc56for generating context word \ud835\udc64\ud835\udc57given center word \ud835\udc64\ud835\udc56,(15.5.2 )can be\nrewritten as\n\u0000\u00d5\n\ud835\udc562V\ud835\udc65\ud835\udc56\u00d5\n\ud835\udc572V\ud835\udc5d\ud835\udc56\ud835\udc57log\ud835\udc5e\ud835\udc56\ud835\udc57.(15.5.3)\nIn(15.5.3 ),\u0000\u00cd\n\ud835\udc572V\ud835\udc5d\ud835\udc56\ud835\udc57log\ud835\udc5e\ud835\udc56\ud835\udc57calculatesthecross-entropyoftheconditionaldistribution\n\ud835\udc5d\ud835\udc56\ud835\udc57ofglobalcorpusstatisticsandtheconditionaldistribution \ud835\udc5e\ud835\udc56\ud835\udc57ofmodelpredictions. This\nloss is also weighted by \ud835\udc65\ud835\udc56as explained above. Minimizing the loss function in (15.5.3 )\nwill allow the predicted conditional distribution to get close to the conditional distribution\nfrom the global corpus statistics.\nThoughbeingcommonlyusedformeasuringthedistancebetweenprobabilitydistributions,\nthe cross-entropy loss function may not be a good choice here. On the one hand, as we\nmentioned in Section 15.2 , the cost of properly normalizing \ud835\udc5e\ud835\udc56\ud835\udc57results in the sum over\n713 Word Embedding with Global Vectors (GloVe)\nthe entire vocabulary, which can be computationally expensive. On the other hand, a large\nnumber of rare events from a large corpus are often modeled by the cross-entropy loss to\nbe assigned with too much weight.\n15.5.2The GloVeModel\nIn view of this, the GloVemodel makes three changes to the skip-gram model based on\nsquared loss ( Pennington etal., 2014):\n1.Use variables \ud835\udc5d0\n\ud835\udc56\ud835\udc57=\ud835\udc65\ud835\udc56\ud835\udc57and\ud835\udc5e0\n\ud835\udc56\ud835\udc57=exp\u00b9u>\n\ud835\udc57v\ud835\udc56\u00bathat are not probability distributions\nand take the logarithm of both, so the squared loss term is\u0010\nlog\ud835\udc5d0\n\ud835\udc56\ud835\udc57\u0000log\ud835\udc5e0\n\ud835\udc56\ud835\udc57\u00112\n=\n\u0010\nu>\n\ud835\udc57v\ud835\udc56\u0000log\ud835\udc65\ud835\udc56\ud835\udc57\u00112\n.\n2.Add two scalar model parameters for each word \ud835\udc64\ud835\udc56: the center word bias \ud835\udc4f\ud835\udc56and the\ncontext word bias \ud835\udc50\ud835\udc56.\n3.Replace the weight of each loss term with the weight function \u210e\u00b9\ud835\udc65\ud835\udc56\ud835\udc57\u00ba, where\u210e\u00b9\ud835\udc65\u00bais\nincreasing in the interval of \u00bb0,1\u00bc.\nPuttingallthingstogether,trainingGloVeistominimizethefollowinglossfunction:\n\u00d5\n\ud835\udc562V\u00d5\n\ud835\udc572V\u210e\u00b9\ud835\udc65\ud835\udc56\ud835\udc57\u00ba\u0010\nu>\n\ud835\udc57v\ud835\udc56\u00b8\ud835\udc4f\ud835\udc56\u00b8\ud835\udc50\ud835\udc57\u0000log\ud835\udc65\ud835\udc56\ud835\udc57\u00112\n. (15.5.4)\nFor the weight function, a suggested choice is: \u210e\u00b9\ud835\udc65\u00ba=\u00b9\ud835\udc65\u009d\ud835\udc50\u00ba\ud835\udefc(e.g\ud835\udefc=0.75) if\ud835\udc65 <\ud835\udc50(e.g.,\n\ud835\udc50=100); otherwise \u210e\u00b9\ud835\udc65\u00ba=1. In this case, because \u210e\u00b90\u00ba=0, the squared loss term for any\n\ud835\udc65\ud835\udc56\ud835\udc57=0can be omitted for computational efficiency. For example, when using minibatch\nstochastic gradient descent for training, at each iteration we randomly sample a minibatch\nofnon-zero\ud835\udc65\ud835\udc56\ud835\udc57to calculate gradients and update the model parameters. Note that these\nnon-zero\ud835\udc65\ud835\udc56\ud835\udc57are precomputed global corpus statistics; thus, the model is called GloVe for\nGlobalVectors .\nIt should be emphasized that if word \ud835\udc64\ud835\udc56appears in the context window of word \ud835\udc64\ud835\udc57, then\nvice versa .", "mimetype": "text/plain", "start_char_idx": 1514210, "end_char_idx": 1516742, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dd481b27-c04c-491e-a3a6-28665f177ee5": {"__data__": {"id_": "dd481b27-c04c-491e-a3a6-28665f177ee5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0e0a4085-51c9-47bd-b355-1ec9d825c61a", "node_type": "1", "metadata": {}, "hash": "a6919b59a61abdae0f4bc9bd1d832304613305dc8f22ee5dbf5ba3c1fba656dc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "28fb0d26-ed06-4898-a099-44b4f9af5054", "node_type": "1", "metadata": {}, "hash": "09f19e0a4d387fd6c691628eafe56d38639febb2c38bae4876dea958fe77fdf4", "class_name": "RelatedNodeInfo"}}, "text": "In this case, because \u210e\u00b90\u00ba=0, the squared loss term for any\n\ud835\udc65\ud835\udc56\ud835\udc57=0can be omitted for computational efficiency. For example, when using minibatch\nstochastic gradient descent for training, at each iteration we randomly sample a minibatch\nofnon-zero\ud835\udc65\ud835\udc56\ud835\udc57to calculate gradients and update the model parameters. Note that these\nnon-zero\ud835\udc65\ud835\udc56\ud835\udc57are precomputed global corpus statistics; thus, the model is called GloVe for\nGlobalVectors .\nIt should be emphasized that if word \ud835\udc64\ud835\udc56appears in the context window of word \ud835\udc64\ud835\udc57, then\nvice versa . Therefore, \ud835\udc65\ud835\udc56\ud835\udc57=\ud835\udc65\ud835\udc57\ud835\udc56. Unlike word2vec that fits the asymmetric conditional\nprobability\ud835\udc5d\ud835\udc56\ud835\udc57, GloVe fits the symmetric log\ud835\udc65\ud835\udc56\ud835\udc57. Therefore, the center word vector and\nthe context word vector of any word are mathematically equivalent in the GloVe model.\nHowever in practice, owing to different initialization values, the same word may still get\ndifferent values in these two vectors after training: GloVe sums them up as the output\nvector.\n15.5.3InterpretingGloVefromthe Ratio of Co-occurrence\nProbabilities\nWe can also interpret the GloVe model from another perspective. Using the same notation\ninSection 15.5.1 , let\ud835\udc5d\ud835\udc56\ud835\udc57def=\ud835\udc43\u00b9\ud835\udc64\ud835\udc57j\ud835\udc64\ud835\udc56\u00babe the conditional probability of generating the\ncontext word \ud835\udc64\ud835\udc57given\ud835\udc64\ud835\udc56as the center word in the corpus. tab_glove lists several co-\noccurrence probabilities given words \u201cice\u201d and \u201csteam\u201d and their ratios based on statistics\nfrom a large corpus.\n714 Natural Language Processing: Pretraining\n:Word-word co-occurrence probabilities and their ratios from a large corpus (adapted from\nTable 1 in Pennington etal.(2014))\nTable 15.5.1: label: tab_glove\n\ud835\udc64\ud835\udc58= solid gas water fashion\n\ud835\udc5d1=\ud835\udc43\u00b9\ud835\udc64\ud835\udc58jice\u00ba0.00019 0.000066 0.003 0.000017\n\ud835\udc5d2=\ud835\udc43\u00b9\ud835\udc64\ud835\udc58jsteam\u00ba0.000022 0.00078 0.0022 0.000018\n\ud835\udc5d1\u009d\ud835\udc5d2 8.9 0.085 1.36 0.96\nWe can observe the following from tab_glove :\n\u000fFor a word\ud835\udc64\ud835\udc58that is related to \u201cice\u201d but unrelated to \u201csteam\u201d, such as \ud835\udc64\ud835\udc58=solid, we\nexpect a larger ratio of co-occurence probabilities, such as 8.9.\n\u000fFor a word\ud835\udc64\ud835\udc58that is related to \u201csteam\u201d but unrelated to \u201cice\u201d, such as \ud835\udc64\ud835\udc58=gas, we\nexpect a smaller ratio of co-occurence probabilities, such as 0.085.\n\u000fFor a word\ud835\udc64\ud835\udc58that is related to both \u201cice\u201d and \u201csteam\u201d, such as \ud835\udc64\ud835\udc58=water, we expect\na ratio of co-occurence probabilities that is close to 1, such as 1.36.\n\u000fFor a word\ud835\udc64\ud835\udc58that is unrelated to both \u201cice\u201d and \u201csteam\u201d, such as \ud835\udc64\ud835\udc58=fashion, we\nexpect a ratio of co-occurence probabilities that is close to 1, such as 0.96.\nIt can be seen that the ratio of co-occurrence probabilities can intuitively express the rela-\ntionship between words. Thus, we can design a function of three word vectors to fit this\nratio. Fortheratioofco-occurrenceprobabilities \ud835\udc5d\ud835\udc56\ud835\udc57\u009d\ud835\udc5d\ud835\udc56\ud835\udc58with\ud835\udc64\ud835\udc56beingthecenterwordand\n\ud835\udc64\ud835\udc57and\ud835\udc64\ud835\udc58being the context words, we want to fit this ratio using some function \ud835\udc53:\n\ud835\udc53\u00b9u\ud835\udc57,u\ud835\udc58,v\ud835\udc56\u00ba\u0019\ud835\udc5d\ud835\udc56\ud835\udc57\n\ud835\udc5d\ud835\udc56\ud835\udc58. (15.5.5)\nAmong many possible designs for \ud835\udc53, we only pick a reasonable choice in the following.", "mimetype": "text/plain", "start_char_idx": 1516219, "end_char_idx": 1519087, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "28fb0d26-ed06-4898-a099-44b4f9af5054": {"__data__": {"id_": "28fb0d26-ed06-4898-a099-44b4f9af5054", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "dd481b27-c04c-491e-a3a6-28665f177ee5", "node_type": "1", "metadata": {}, "hash": "da8903c78843e9ef861789ed2ea84c92fdd30df179b8246fd54e5d995ad01f89", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6af41214-d677-42ad-9247-e888244059cb", "node_type": "1", "metadata": {}, "hash": "070e30d93b3de7aa3f7860aaf23d15c65467e0d035f859d8f1a5e0c630a8fe2e", "class_name": "RelatedNodeInfo"}}, "text": "It can be seen that the ratio of co-occurrence probabilities can intuitively express the rela-\ntionship between words. Thus, we can design a function of three word vectors to fit this\nratio. Fortheratioofco-occurrenceprobabilities \ud835\udc5d\ud835\udc56\ud835\udc57\u009d\ud835\udc5d\ud835\udc56\ud835\udc58with\ud835\udc64\ud835\udc56beingthecenterwordand\n\ud835\udc64\ud835\udc57and\ud835\udc64\ud835\udc58being the context words, we want to fit this ratio using some function \ud835\udc53:\n\ud835\udc53\u00b9u\ud835\udc57,u\ud835\udc58,v\ud835\udc56\u00ba\u0019\ud835\udc5d\ud835\udc56\ud835\udc57\n\ud835\udc5d\ud835\udc56\ud835\udc58. (15.5.5)\nAmong many possible designs for \ud835\udc53, we only pick a reasonable choice in the following.\nSince the ratio of co-occurrence probabilities is a scalar, we require that \ud835\udc53be a scalar\nfunction, such as \ud835\udc53\u00b9u\ud835\udc57,u\ud835\udc58,v\ud835\udc56\u00ba=\ud835\udc53\u0000\u00b9u\ud835\udc57\u0000u\ud835\udc58\u00ba>v\ud835\udc56\u0001. Switching word indices \ud835\udc57and\ud835\udc58in\n(15.5.5 ), it must hold that \ud835\udc53\u00b9\ud835\udc65\u00ba\ud835\udc53\u00b9\u0000\ud835\udc65\u00ba=1, so one possibility is \ud835\udc53\u00b9\ud835\udc65\u00ba=exp\u00b9\ud835\udc65\u00ba, i.e.,\n\ud835\udc53\u00b9u\ud835\udc57,u\ud835\udc58,v\ud835\udc56\u00ba=exp\u0010\nu>\n\ud835\udc57v\ud835\udc56\u0011\nexp\u0010\nu>\n\ud835\udc58v\ud835\udc56\u0011\u0019\ud835\udc5d\ud835\udc56\ud835\udc57\n\ud835\udc5d\ud835\udc56\ud835\udc58. (15.5.6)\nNow let\u2019s pick exp\u0010\nu>\n\ud835\udc57v\ud835\udc56\u0011\n\u0019\ud835\udefc\ud835\udc5d\ud835\udc56\ud835\udc57, where\ud835\udefcis a constant. Since \ud835\udc5d\ud835\udc56\ud835\udc57=\ud835\udc65\ud835\udc56\ud835\udc57\u009d\ud835\udc65\ud835\udc56, after taking\nthe logarithm on both sides we get u>\n\ud835\udc57v\ud835\udc56\u0019log\ud835\udefc\u00b8log\ud835\udc65\ud835\udc56\ud835\udc57\u0000log\ud835\udc65\ud835\udc56. We may use additional\nbias terms to fit\u0000log\ud835\udefc\u00b8log\ud835\udc65\ud835\udc56, such as the center word bias \ud835\udc4f\ud835\udc56and the context word bias\n\ud835\udc50\ud835\udc57:\nu>\n\ud835\udc57v\ud835\udc56\u00b8\ud835\udc4f\ud835\udc56\u00b8\ud835\udc50\ud835\udc57\u0019log\ud835\udc65\ud835\udc56\ud835\udc57. (15.5.7)\nMeasuring the squared error of (15.5.7 )with weights, the GloVe loss function in (15.5.4 )\nis obtained.\n715 Subword Embedding\n23315.5.4Summary\n\u000fTheskip-grammodelcanbeinterpretedusingglobalcorpusstatisticssuchasword-word\nco-occurrence counts.\n\u000fThe cross-entropy loss may not be a good choice for measuring the difference of two\nprobability distributions, especially for a large corpus. GloVe uses squared loss to fit\nprecomputed global corpus statistics.\n\u000fThe center word vector and the context word vector are mathematically equivalent for\nany word in GloVe.\n\u000fGloVe can be interpreted from the ratio of word-word co-occurrence probabilities.\n15.5.5Exercises\n1.Ifwords\ud835\udc64\ud835\udc56and\ud835\udc64\ud835\udc57co-occurinthesamecontextwindow,howcanweusetheirdistance\nin the text sequence to redesign the method for calculating the conditional probability\n\ud835\udc5d\ud835\udc56\ud835\udc57? Hint: see Section 4.2 of the GloVe paper ( Pennington etal., 2014).\n2.For any word, are its center word bias and context word bias mathematically equivalent\nin GloVe? Why?\nDiscussions233.\n15.6SubwordEmbedding\nIn English, words such as \u201chelps\u201d, \u201chelped\u201d, and \u201chelping\u201d are inflected forms of the same\nword\u201chelp\u201d. Therelationshipbetween\u201cdog\u201d and\u201cdogs\u201dis thesameas thatbetween\u201ccat\u201d\nand\u201ccats\u201d,andtherelationshipbetween\u201cboy\u201dand\u201cboyfriend\u201disthesameasthatbetween\n\u201cgirl\u201d and \u201cgirlfriend\u201d. In other languages such as French and Spanish, many verbs have\nover 40 inflected forms, while in Finnish, a noun may have up to 15 cases.", "mimetype": "text/plain", "start_char_idx": 1518625, "end_char_idx": 1521124, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6af41214-d677-42ad-9247-e888244059cb": {"__data__": {"id_": "6af41214-d677-42ad-9247-e888244059cb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "28fb0d26-ed06-4898-a099-44b4f9af5054", "node_type": "1", "metadata": {}, "hash": "09f19e0a4d387fd6c691628eafe56d38639febb2c38bae4876dea958fe77fdf4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "24029408-8ced-4525-a4ad-b40c9aad9fd0", "node_type": "1", "metadata": {}, "hash": "72489a91152562d24ad9d1039599201eb7cf071e03369007b61b0b1ee0e31fa4", "class_name": "RelatedNodeInfo"}}, "text": "Hint: see Section 4.2 of the GloVe paper ( Pennington etal., 2014).\n2.For any word, are its center word bias and context word bias mathematically equivalent\nin GloVe? Why?\nDiscussions233.\n15.6SubwordEmbedding\nIn English, words such as \u201chelps\u201d, \u201chelped\u201d, and \u201chelping\u201d are inflected forms of the same\nword\u201chelp\u201d. Therelationshipbetween\u201cdog\u201d and\u201cdogs\u201dis thesameas thatbetween\u201ccat\u201d\nand\u201ccats\u201d,andtherelationshipbetween\u201cboy\u201dand\u201cboyfriend\u201disthesameasthatbetween\n\u201cgirl\u201d and \u201cgirlfriend\u201d. In other languages such as French and Spanish, many verbs have\nover 40 inflected forms, while in Finnish, a noun may have up to 15 cases. In linguistics,\nmorphologystudieswordformationandwordrelationships. However,theinternalstructure\nof words was neither explored in word2vec nor in GloVe.\n15.6.1ThefastTextModel\nRecall how words are represented in word2vec. In both the skip-gram model and the con-\ntinuous bag-of-words model, different inflected forms of the same word are directly repre-\nsented by different vectors without shared parameters. To use morphological information,\nthefastTextmodel proposed a subwordembedding approach, where a subword is a charac-\nter\ud835\udc5b-gram(Bojanowski etal.,2017). Insteadoflearningword-levelvectorrepresentations,\nfastText can be considered as the subword-level skip-gram, where each centerword is rep-\nresented by the sum of its subword vectors.\nLet\u2019s illustrate how to obtain subwords for each center word in fastText using the word\n716 Natural Language Processing: Pretraining\n\u201cwhere\u201d. First, add special characters \u201c<\u201d and \u201c>\u201d at the beginning and end of the word\nto distinguish prefixes and suffixes from other subwords. Then, extract character \ud835\udc5b-grams\nfrom the word. For example, when \ud835\udc5b=3, we obtain all subwords of length 3: \u201c<wh\u201d,\n\u201cwhe\u201d, \u201cher\u201d, \u201cere\u201d, \u201cre>\u201d, and the special subword \u201c<where>\u201d.\nIn fastText, for any word \ud835\udc64, denote byG\ud835\udc64the union of all its subwords of length between\n3 and 6 and its special subword. The vocabulary is the union of the subwords of all words.\nLetting z\ud835\udc54bethevectorofsubword \ud835\udc54inthedictionary,thevector v\ud835\udc64forword\ud835\udc64asacenter\nword in the skip-gram model is the sum of its subword vectors:\nv\ud835\udc64=\u00d5\n\ud835\udc542G\ud835\udc64z\ud835\udc54.(15.6.1)\nThe rest of fastText is the same as the skip-gram model. Compared with the skip-gram\nmodel, the vocabulary in fastText is larger, resulting in more model parameters. Besides,\ntocalculatetherepresentationofaword,allitssubwordvectorshavetobesummed,leading\nto higher computational complexity. However, thanks to shared parameters from subwords\namong words with similar structures, rare words and even out-of-vocabulary words may\nobtain better vector representations in fastText.\n15.6.2BytePairEncoding\nIn fastText, all the extracted subwords have to be of the specified lengths, such as 3to6,\nthus the vocabulary size cannot be predefined. To allow for variable-length subwords in\na fixed-size vocabulary, we can apply a compression algorithm called byte pair encoding\n(BPE) to extract subwords ( Sennrich etal., 2015).\nByte pair encoding performs a statistical analysis of the training dataset to discover com-\nmon symbols within a word, such as consecutive characters of arbitrary length. Starting\nfrom symbols of length 1, byte pair encoding iteratively merges the most frequent pair of\nconsecutive symbols to produce new longer symbols. Note that for efficiency, pairs cross-\ning word boundaries are not considered. In the end, we can use such symbols as subwords\nto segment words. Byte pair encoding and its variants has been used for input representa-\ntions in popular natural language processing pretraining models such as GPT-2 ( Radford\net al., 2019) and RoBERTa ( Liuet al., 2019). In the following, we will illustrate how byte\npair encoding works.\nFirst, we initialize the vocabulary of symbols as all the English lowercase characters, a\nspecial end-of-word symbol '_', and a special unknown symbol '[UNK]' .", "mimetype": "text/plain", "start_char_idx": 1520506, "end_char_idx": 1524381, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "24029408-8ced-4525-a4ad-b40c9aad9fd0": {"__data__": {"id_": "24029408-8ced-4525-a4ad-b40c9aad9fd0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6af41214-d677-42ad-9247-e888244059cb", "node_type": "1", "metadata": {}, "hash": "070e30d93b3de7aa3f7860aaf23d15c65467e0d035f859d8f1a5e0c630a8fe2e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fcb0185f-dbf8-40ba-924b-8fae181b073c", "node_type": "1", "metadata": {}, "hash": "f793a2e84c263330c4180915254053255df6d24f3fa749c0aa3cde67e3147768", "class_name": "RelatedNodeInfo"}}, "text": "Byte pair encoding performs a statistical analysis of the training dataset to discover com-\nmon symbols within a word, such as consecutive characters of arbitrary length. Starting\nfrom symbols of length 1, byte pair encoding iteratively merges the most frequent pair of\nconsecutive symbols to produce new longer symbols. Note that for efficiency, pairs cross-\ning word boundaries are not considered. In the end, we can use such symbols as subwords\nto segment words. Byte pair encoding and its variants has been used for input representa-\ntions in popular natural language processing pretraining models such as GPT-2 ( Radford\net al., 2019) and RoBERTa ( Liuet al., 2019). In the following, we will illustrate how byte\npair encoding works.\nFirst, we initialize the vocabulary of symbols as all the English lowercase characters, a\nspecial end-of-word symbol '_', and a special unknown symbol '[UNK]' .\nimport collections\nsymbols =['a','b','c','d','e','f','g','h','i','j','k','l','m',\n'n','o','p','q','r','s','t','u','v','w','x','y','z',\n'_','[UNK] ']\nSince we do not consider symbol pairs that cross boundaries of words, we only need a\ndictionary raw_token_freqs thatmapswordstotheirfrequencies(numberofoccurrences)\nin a dataset. Note that the special symbol '_'is appended to each word so that we can\n717 Subword Embedding\neasily recover a word sequence (e.g., \u201ca taller man\u201d) from a sequence of output symbols\n( e.g., \u201ca_ tall er_ man\u201d). Since we start the merging process from a vocabulary of only\nsingle characters and special symbols, space is inserted between every pair of consecutive\ncharacters within each word (keys of the dictionary token_freqs ). In other words, space\nis the delimiter between symbols within a word.\nraw_token_freqs ={'fast_ ':4,'faster_ ':3,'tall_ ':5,'taller_ ':4}\ntoken_freqs ={}\nfor token, freq inraw_token_freqs .items():\ntoken_freqs[ ''.join( list (token))] =raw_token_freqs[token]\ntoken_freqs\n{'f a s t _ ':4,'f a s t e r _ ':3,'t a l l _ ':5,'t a l l e r _ ':4}\nWe define the following get_max_freq_pair function that returns the most frequent pair\nofconsecutivesymbolswithinaword,wherewordscomefromkeysoftheinputdictionary\ntoken_freqs .\ndef get_max_freq_pair (token_freqs):\npairs =collections .defaultdict( int)\nfor token, freq intoken_freqs .items():\nsymbols =token .split()\nfor iinrange (len(symbols) -1):\n# Key of `pairs` is a tuple of two consecutive symbols\npairs[symbols[i], symbols[i +1]]+=freq\nreturn max(pairs, key =pairs .get) # Key of `pairs` with the max value\nAs a greedy approach based on frequency of consecutive symbols, byte pair encoding will\nuse the following merge_symbols function to merge the most frequent pair of consecutive\nsymbols to produce new symbols.\ndef merge_symbols (max_freq_pair, token_freqs, symbols):\nsymbols .append( ''.join(max_freq_pair))\nnew_token_freqs =dict ()\nfor token, freq intoken_freqs .items():\nnew_token =token .replace( ''.join(max_freq_pair),\n''.join(max_freq_pair))\nnew_token_freqs[new_token] =token_freqs[token]\nreturn new_token_freqs\nNowweiterativelyperformthebytepairencodingalgorithmoverthekeysofthedictionary\ntoken_freqs . In the first iteration, the most frequent pair of consecutive symbols are 't'\nand'a', thus byte pair encoding merges them to produce a new symbol 'ta'. In the\nsecond iteration, byte pair encoding continues to merge 'ta'and'l'to result in another\nnew symbol 'tal'.", "mimetype": "text/plain", "start_char_idx": 1523482, "end_char_idx": 1526862, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fcb0185f-dbf8-40ba-924b-8fae181b073c": {"__data__": {"id_": "fcb0185f-dbf8-40ba-924b-8fae181b073c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "24029408-8ced-4525-a4ad-b40c9aad9fd0", "node_type": "1", "metadata": {}, "hash": "72489a91152562d24ad9d1039599201eb7cf071e03369007b61b0b1ee0e31fa4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5e4149ba-612a-4888-8e4f-e9aca4be2611", "node_type": "1", "metadata": {}, "hash": "62fc713a0cfbc8dabc49f844202a875a1c64d618cb5a67d97e93c94092feaa58", "class_name": "RelatedNodeInfo"}}, "text": "def merge_symbols (max_freq_pair, token_freqs, symbols):\nsymbols .append( ''.join(max_freq_pair))\nnew_token_freqs =dict ()\nfor token, freq intoken_freqs .items():\nnew_token =token .replace( ''.join(max_freq_pair),\n''.join(max_freq_pair))\nnew_token_freqs[new_token] =token_freqs[token]\nreturn new_token_freqs\nNowweiterativelyperformthebytepairencodingalgorithmoverthekeysofthedictionary\ntoken_freqs . In the first iteration, the most frequent pair of consecutive symbols are 't'\nand'a', thus byte pair encoding merges them to produce a new symbol 'ta'. In the\nsecond iteration, byte pair encoding continues to merge 'ta'and'l'to result in another\nnew symbol 'tal'.\nnum_merges =10\nfor iinrange (num_merges):\n(continues on next page)\n718 Natural Language Processing: Pretraining\n(continued from previous page)\nmax_freq_pair =get_max_freq_pair(token_freqs)\ntoken_freqs =merge_symbols(max_freq_pair, token_freqs, symbols)\nprint (f'merge # {i+1}:', max_freq_pair)\nmerge #1: ('t', 'a')\nmerge #2: ('ta', 'l')\nmerge #3: ('tal', 'l')\nmerge #4: ('f', 'a')\nmerge #5: ('fa', 's')\nmerge #6: ('fas', 't')\nmerge #7: ('e', 'r')\nmerge #8: ('er', '_')\nmerge #9: ('tall', '_')\nmerge #10: ('fast', '_')\nAfter 10 iterations of byte pair encoding, we can see that list symbols now contains 10\nmore symbols that are iteratively merged from other symbols.\nprint (symbols)\n['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p\n\u21a9!','q','r','s','t','u','v','w','x','y','z','_','[UNK] ','ta','tal\n\u21a9!','tall ','fa','fas','fast ','er','er_','tall_ ','fast_ ']\nFor the same dataset specified in the keys of the dictionary raw_token_freqs , each word\nin the dataset is now segmented by subwords \u201cfast_\u201d, \u201cfast\u201d, \u201cer_\u201d, \u201ctall_\u201d, and \u201ctall\u201d as a\nresult of the byte pair encoding algorithm. For instance, words \u201cfaster_\u201d and \u201ctaller_\u201d are\nsegmented as \u201cfast er_\u201d and \u201ctall er_\u201d, respectively.\nprint (list (token_freqs .keys()))\n['fast_ ','fast er_ ','tall_ ','tall er_ ']\nNote that the result of byte pair encoding depends on the dataset being used. We can also\nuse the subwords learned from one dataset to segment words of another dataset. As a\ngreedyapproach, thefollowing segment_BPE functiontriestobreakwordsintothelongest\npossible subwords from the input argument symbols .\ndef segment_BPE (tokens, symbols):\noutputs =[]\nfor token intokens:\nstart, end =0,len(token)\ncur_output =[]\n# Segment token with the longest possible subwords from symbols\nwhile start <len(token) and start <end:\niftoken[start: end] insymbols:\n(continues on next page)\n719 Subword Embedding\n234(continued from previous page)\ncur_output .append(token[start: end])\nstart =end\nend =len(token)\nelse :\nend -=1\nifstart <len(token):\ncur_output .append( '[UNK] ')\noutputs .append( ''.join(cur_output))\nreturn outputs\nInthefollowing, weusethesubwordsinlist symbols , whichislearnedfromtheaforemen-\ntioned dataset, to segment tokensthat represent another dataset.\ntokens =['tallest_ ','fatter_ ']\nprint (segment_BPE(tokens, symbols))\n['tall e s t _ ','fa t t er_ ']\n15.6.3Summary\n\u000fThe fastText model proposes a subword embedding approach. Based on the skip-gram\nmodel in word2vec, it represents a center word as the sum of its subword vectors.\n\u000fBytepairencodingperformsastatisticalanalysisofthetrainingdatasettodiscovercom-\nmon symbols within a word. As a greedy approach, byte pair encoding iteratively\nmerges the most frequent pair of consecutive symbols.\n\u000fSubword embedding may improve the quality of representations of rare words and out-\nof-dictionary words.\n15.6.4Exercises\n1.As an example, there are about 3\u0002108possible 6-grams in English.", "mimetype": "text/plain", "start_char_idx": 1526199, "end_char_idx": 1529786, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5e4149ba-612a-4888-8e4f-e9aca4be2611": {"__data__": {"id_": "5e4149ba-612a-4888-8e4f-e9aca4be2611", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fcb0185f-dbf8-40ba-924b-8fae181b073c", "node_type": "1", "metadata": {}, "hash": "f793a2e84c263330c4180915254053255df6d24f3fa749c0aa3cde67e3147768", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "08eb9bca-53e5-4359-baf9-7ad3e9d8e3f9", "node_type": "1", "metadata": {}, "hash": "4ccb0c0fed5ae6a2adb85b74dc8a91bffc8fd55d2b5812b4827faa3f3b441e5a", "class_name": "RelatedNodeInfo"}}, "text": "tokens =['tallest_ ','fatter_ ']\nprint (segment_BPE(tokens, symbols))\n['tall e s t _ ','fa t t er_ ']\n15.6.3Summary\n\u000fThe fastText model proposes a subword embedding approach. Based on the skip-gram\nmodel in word2vec, it represents a center word as the sum of its subword vectors.\n\u000fBytepairencodingperformsastatisticalanalysisofthetrainingdatasettodiscovercom-\nmon symbols within a word. As a greedy approach, byte pair encoding iteratively\nmerges the most frequent pair of consecutive symbols.\n\u000fSubword embedding may improve the quality of representations of rare words and out-\nof-dictionary words.\n15.6.4Exercises\n1.As an example, there are about 3\u0002108possible 6-grams in English. What is the issue\nwhen there are too many subwords? How to address the issue? Hint: refer to the end of\nSection 3.2 of the fastText paper ( Bojanowski etal., 2017).\n2.How to design a subword embedding model based on the continuous bag-of-words\nmodel?\n3.Togetavocabularyofsize \ud835\udc5a,howmanymergingoperationsareneededwhentheinitial\nsymbol vocabulary size is \ud835\udc5b?\n4.How to extend the idea of byte pair encoding to extract phrases?\nDiscussions234.\n720 Natural Language Processing: Pretraining\n235\n23615.7WordSimilarity and Analogy\nInSection 15.4 , we trained a word2vec model on a small dataset, and applied it to find\nsemantically similar words for an input word. In practice, word vectors that are pretrained\non large corpora can be applied to downstream natural language processing tasks, which\nwill be covered later in Chapter 16 . To demonstrate semantics of pretrained word vectors\nfrom large corpora in a straightforward way, let\u2019s apply them in the word similarity and\nanalogy tasks.\nimport os\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n15.7.1LoadingPretrainedWordVectors\nBelow lists pretrained GloVe embeddings of dimension 50, 100, and 300, which can be\ndownloaded from the GloVe website235. The pretrained fastText embeddings are available\nin multiple languages. Here we consider one English version (300-dimensional \u201cwiki.en\u201d)\nthat can be downloaded from the fastText website236.\n#@save\nd2l.DATA_HUB[ 'glove.6b.50d ']=(d2l .DATA_URL +'glove.6B.50d.zip ',\n'0b8703943ccdb6eb788e6f091b8946e82231bc4d ')\n#@save\nd2l.DATA_HUB[ 'glove.6b.100d ']=(d2l .DATA_URL +'glove.6B.100d.zip ',\n'cd43bfb07e44e6f27cbcc7bc9ae3d80284fdaf5a ')\n#@save\nd2l.DATA_HUB[ 'glove.42b.300d ']=(d2l .DATA_URL +'glove.42B.300d.zip ',\n'b5116e234e9eb9076672cfeabf5469f3eec904fa ')\n#@save\nd2l.DATA_HUB[ 'wiki.en ']=(d2l .DATA_URL +'wiki.en.zip ',\n'c1816da3821ae9f43899be655002f6c723e91b88 ')\nTo load these pretrained GloVe and fastText embeddings, we define the following Token-\nEmbedding class.\n#@save\nclass TokenEmbedding :\n\"\"\"Token Embedding.\"\"\"", "mimetype": "text/plain", "start_char_idx": 1529104, "end_char_idx": 1531820, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "08eb9bca-53e5-4359-baf9-7ad3e9d8e3f9": {"__data__": {"id_": "08eb9bca-53e5-4359-baf9-7ad3e9d8e3f9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5e4149ba-612a-4888-8e4f-e9aca4be2611", "node_type": "1", "metadata": {}, "hash": "62fc713a0cfbc8dabc49f844202a875a1c64d618cb5a67d97e93c94092feaa58", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "aab111d3-5a77-454b-bde9-9126ccfb096c", "node_type": "1", "metadata": {}, "hash": "716d9ea19f1f0d7a411edc7fa1c1680f55b46e885daa6c02b1e95b72700a59ad", "class_name": "RelatedNodeInfo"}}, "text": "#@save\nclass TokenEmbedding :\n\"\"\"Token Embedding.\"\"\"\ndef __init__ (self , embedding_name):\nself .idx_to_token, self .idx_to_vec =self ._load_embedding(\nembedding_name)\nself .unknown_idx =0\n(continues on next page)\n721 Word Similarity and Analogy\n(continued from previous page)\nself .token_to_idx ={token: idx for idx, token in\nenumerate (self .idx_to_token)}\ndef _load_embedding (self , embedding_name):\nidx_to_token, idx_to_vec =['<unk> '], []\ndata_dir =d2l.download_extract(embedding_name)\n# GloVe website: https://nlp.stanford.edu/projects/glove/\n# fastText website: https://fasttext.cc/\nwith open (os.path .join(data_dir, 'vec.txt '),'r')asf:\nfor line inf:\nelems =line .rstrip() .split( '')\ntoken, elems =elems[ 0], [ float (elem) for elem inelems[ 1:]]\n# Skip header information, such as the top row in fastText\niflen(elems) >1:\nidx_to_token .append(token)\nidx_to_vec .append(elems)\nidx_to_vec =[[0]*len(idx_to_vec[ 0])] +idx_to_vec\nreturn idx_to_token, torch .tensor(idx_to_vec)\ndef __getitem__ (self , tokens):\nindices =[self .token_to_idx .get(token, self .unknown_idx)\nfor token intokens]\nvecs =self .idx_to_vec[torch .tensor(indices)]\nreturn vecs\ndef __len__ (self ):\nreturn len(self .idx_to_token)\nBelow we load the 50-dimensional GloVe embeddings (pretrained on a Wikipedia sub-\nset). When creating the TokenEmbedding instance, the specified embedding file has to be\ndownloaded if it was not yet.\nglove_6b50d =TokenEmbedding( 'glove.6b.50d ')\nDownloading ../data /glove .6B.50d.zip from http ://d2l-data .s3-accelerate .\n\u21a9!amazonaws .com/glove .6B.50d.zip...\nOutput the vocabulary size. The vocabulary contains 400000 words (tokens) and a special\nunknown token.\nlen(glove_6b50d)\n400001\nWe can get the index of a word in the vocabulary, and vice versa.\nglove_6b50d .token_to_idx[ 'beautiful '], glove_6b50d .idx_to_token[ 3367 ]\n722 Natural Language Processing: Pretraining\n(3367 ,'beautiful ')\n15.7.2ApplyingPretrained WordVectors\nUsing the loaded GloVe vectors, we will demonstrate their semantics by applying them in\nthe following word similarity and analogy tasks.\nWordSimilarity\nSimilar to Section 15.4.3 , in order to find semantically similar words for an input word\nbased on cosine similarities between word vectors, we implement the following knn(\ud835\udc58-\nnearest neighbors) function.\ndef knn(W, x, k):\n# Add 1e-9 for numerical stability\ncos =torch .mv(W, x .reshape( -1,)) /(\ntorch .sqrt(torch .sum(W *W, axis =1)+1e-9 )*\ntorch .sqrt((x *x).sum()))\n_, topk =torch .topk(cos, k =k)\nreturn topk, [cos[ int(i)] for iintopk]\nThen, we search for similar words using the pretrained word vectors from the TokenEm-\nbedding instance embed.\ndef get_similar_tokens (query_token, k, embed):\ntopk, cos =knn(embed .idx_to_vec, embed[[query_token]], k +1)\nfor i, c inzip(topk[ 1:], cos[ 1:]): # Exclude the input word\nprint (f'cosine sim= {float (c):.3f}:{embed .idx_to_token[ int(i)] }')\nThe vocabulary of the pretrained word vectors in glove_6b50d contains 400000 words\nand a special unknown token. Excluding the input word and unknown token, among this\nvocabulary let\u2019s find three most semantically similar words to word \u201cchip\u201d.\nget_similar_tokens( 'chip ',3, glove_6b50d)\ncosine sim =0.856 : chips\ncosine sim =0.749 : intel\ncosine sim =0.749 : electronics\nBelow outputs similar words to \u201cbaby\u201d and \u201cbeautiful\u201d.", "mimetype": "text/plain", "start_char_idx": 1531768, "end_char_idx": 1535082, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "aab111d3-5a77-454b-bde9-9126ccfb096c": {"__data__": {"id_": "aab111d3-5a77-454b-bde9-9126ccfb096c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "08eb9bca-53e5-4359-baf9-7ad3e9d8e3f9", "node_type": "1", "metadata": {}, "hash": "4ccb0c0fed5ae6a2adb85b74dc8a91bffc8fd55d2b5812b4827faa3f3b441e5a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "717f6a15-fd93-4b21-9a10-f3da311ccf80", "node_type": "1", "metadata": {}, "hash": "5f80e252502b2d90d6e46fc560a0cae131b9f465a7d52f07a3f5b5f5380efd66", "class_name": "RelatedNodeInfo"}}, "text": "Excluding the input word and unknown token, among this\nvocabulary let\u2019s find three most semantically similar words to word \u201cchip\u201d.\nget_similar_tokens( 'chip ',3, glove_6b50d)\ncosine sim =0.856 : chips\ncosine sim =0.749 : intel\ncosine sim =0.749 : electronics\nBelow outputs similar words to \u201cbaby\u201d and \u201cbeautiful\u201d.\nget_similar_tokens( 'baby ',3, glove_6b50d)\ncosine sim =0.839 : babies\ncosine sim =0.800 : boy\ncosine sim =0.792 : girl\n723 Word Similarity and Analogy\nget_similar_tokens( 'beautiful ',3, glove_6b50d)\ncosine sim =0.921 : lovely\ncosine sim =0.893 : gorgeous\ncosine sim =0.830 : wonderful\nWordAnalogy\nBesides finding similar words, we can also apply word vectors to word analogy tasks. For\nexample, \u201cman\u201d:\u201cwoman\u201d::\u201cson\u201d:\u201cdaughter\u201d is the form of a word analogy: \u201cman\u201d is to\n\u201cwoman\u201d as \u201cson\u201d is to \u201cdaughter\u201d. Specifically, the word analogy completion task can be\ndefined as: for a word analogy \ud835\udc4e:\ud835\udc4f::\ud835\udc50:\ud835\udc51, given the first three words \ud835\udc4e,\ud835\udc4fand\ud835\udc50, find\ud835\udc51.\nDenote the vector of word \ud835\udc64by vec\u00b9\ud835\udc64\u00ba. To complete the analogy, we will find the word\nwhose vector is most similar to the result of vec \u00b9\ud835\udc50\u00ba\u00b8vec\u00b9\ud835\udc4f\u00ba\u0000vec\u00b9\ud835\udc4e\u00ba.\ndef get_analogy (token_a, token_b, token_c, embed):\nvecs =embed[[token_a, token_b, token_c]]\nx=vecs[ 1]-vecs[ 0]+vecs[ 2]\ntopk, cos =knn(embed .idx_to_vec, x, 1)\nreturn embed .idx_to_token[ int(topk[ 0])] # Remove unknown words\nLet\u2019s verify the \u201cmale-female\u201d analogy using the loaded word vectors.\nget_analogy( 'man','woman ','son', glove_6b50d)\n'daughter '\nBelow completes a \u201ccapital-country\u201d analogy: \u201cbeijing\u201d:\u201cchina\u201d::\u201ctokyo\u201d:\u201cjapan\u201d. This\ndemonstrates semantics in the pretrained word vectors.\nget_analogy( 'beijing ','china ','tokyo ', glove_6b50d)\n'japan '\nFor the \u201cadjective-superlative adjective\u201d analogy such as \u201cbad\u201d:\u201cworst\u201d::\u201cbig\u201d:\u201cbiggest\u201d,\nwe can see that the pretrained word vectors may capture the syntactic information.\nget_analogy( 'bad','worst ','big', glove_6b50d)\n'biggest '\nTo show the captured notion of past tense in the pretrained word vectors, we can test the\nsyntax using the \u201cpresent tense-past tense\u201d analogy: \u201cdo\u201d:\u201cdid\u201d::\u201cgo\u201d:\u201cwent\u201d.\n724 Natural Language Processing: Pretraining\n237get_analogy( 'do','did','go', glove_6b50d)\n'went '\n15.7.3Summary\n\u000fIn practice, word vectors that are pretrained on large corpora can be applied to down-\nstream natural language processing tasks.\n\u000fPretrained word vectors can be applied to the word similarity and analogy tasks.\n15.7.4Exercises\n1.Test the fastText results using TokenEmbedding('wiki.en') .\n2.When the vocabulary is extremely large, how can we find similar words or complete a\nword analogy faster?\nDiscussions237.\n15.8BidirectionalEncoder Representations from\nTransformers(BERT)\nWe have introduced several word embedding models for natural language understanding.\nAfter pretraining, the output can be thought of as a matrix where each row is a vector that\nrepresents a word of a predefined vocabulary. In fact, these word embedding models are\nallcontext-independent . Let\u2019s begin by illustrating this property.\n15.8.1FromContext-Independent to Context-Sensitive\nRecalltheexperimentsin Section15.4 andSection15.7 . Forinstance,word2vecandGloVe\nboth assign the same pretrained vector to the same word regardless of the context of the\nword (if any). Formally, a context-independent representation of any token \ud835\udc65is a func-\ntion\ud835\udc53\u00b9\ud835\udc65\u00bathat only takes \ud835\udc65as its input. Given the abundance of polysemy and complex\nsemantics in natural languages, context-independent representations have obvious limita-\ntions.", "mimetype": "text/plain", "start_char_idx": 1534769, "end_char_idx": 1538256, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "717f6a15-fd93-4b21-9a10-f3da311ccf80": {"__data__": {"id_": "717f6a15-fd93-4b21-9a10-f3da311ccf80", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "aab111d3-5a77-454b-bde9-9126ccfb096c", "node_type": "1", "metadata": {}, "hash": "716d9ea19f1f0d7a411edc7fa1c1680f55b46e885daa6c02b1e95b72700a59ad", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d87f29a6-ddb6-4a34-ab86-2fe9a317e63b", "node_type": "1", "metadata": {}, "hash": "342d67ce9d48e928a3b1bc773aafeaf910638fccb1313aab0f58125bf3ce1a81", "class_name": "RelatedNodeInfo"}}, "text": "After pretraining, the output can be thought of as a matrix where each row is a vector that\nrepresents a word of a predefined vocabulary. In fact, these word embedding models are\nallcontext-independent . Let\u2019s begin by illustrating this property.\n15.8.1FromContext-Independent to Context-Sensitive\nRecalltheexperimentsin Section15.4 andSection15.7 . Forinstance,word2vecandGloVe\nboth assign the same pretrained vector to the same word regardless of the context of the\nword (if any). Formally, a context-independent representation of any token \ud835\udc65is a func-\ntion\ud835\udc53\u00b9\ud835\udc65\u00bathat only takes \ud835\udc65as its input. Given the abundance of polysemy and complex\nsemantics in natural languages, context-independent representations have obvious limita-\ntions. For instance, the word \u201ccrane\u201d in contexts \u201ca crane is flying\u201d and \u201ca crane driver\ncame\u201d has completely different meanings; thus, the same word may be assigned different\nrepresentations depending on contexts.\nThismotivatesthedevelopmentof context-sensitive wordrepresentations, whererepresen-\ntations of words depend on their contexts. Hence, a context-sensitive representation of\n725 Bidirectional Encoder Representations from Transformers (BERT)\ntoken\ud835\udc65is a function \ud835\udc53\u00b9\ud835\udc65,\ud835\udc50\u00b9\ud835\udc65\u00ba\u00badepending on both \ud835\udc65and its context \ud835\udc50\u00b9\ud835\udc65\u00ba. Popular context-\nsensitiverepresentationsincludeTagLM(language-model-augmentedsequencetagger)( Pe-\ntersetal., 2017), CoVe (Context Vectors) ( McCannetal., 2017), and ELMo (Embeddings\nfrom Language Models) ( Petersetal., 2018).\nFor example, by taking the entire sequence as input, ELMo is a function that assigns a rep-\nresentation to each word from the input sequence. Specifically, ELMo combines all the\nintermediate layer representations from pretrained bidirectional LSTM as the output rep-\nresentation. Then the ELMo representation will be added to a downstream task\u2019s existing\nsupervised model as additional features, such as by concatenating ELMo representation\nand the original representation (e.g., GloVe) of tokens in the existing model. On the one\nhand, all the weights in the pretrained bidirectional LSTM model are frozen after ELMo\nrepresentations are added. On the other hand, the existing supervised model is specifically\ncustomized for a given task. Leveraging different best models for different tasks at that\ntime, adding ELMo improved the state of the art across six natural language processing\ntasks: sentiment analysis, natural language inference, semantic role labeling, coreference\nresolution, named entity recognition, and question answering.\n15.8.2FromTask-Specificto Task-Agnostic\nAlthough ELMo has significantly improved solutions to a diverse set of natural language\nprocessing tasks, each solution still hinges on a task-specific architecture. However, it is\npractically non-trivial to craft a specific architecture for every natural language processing\ntask. The GPT (Generative Pre-Training) model represents an effort in designing a general\ntask-agnostic model for context-sensitive representations ( Radfordet al., 2018). Built on\na Transformer decoder, GPT pretrains a language model that will be used to represent text\nsequences. When applying GPT to a downstream task, the output of the language model\nwillbefedintoanaddedlinearoutputlayertopredictthelabelofthetask. Insharpcontrast\nto ELMo that freezes parameters of the pretrained model, GPT fine-tunes allthe parame-\nters in the pretrained Transformer decoder during supervised learning of the downstream\ntask. GPT was evaluated on twelve tasks of natural language inference, question answer-\ning, sentencesimilarity, andclassification, andimprovedthestateoftheartinnineofthem\nwith minimal changes to the model architecture.\nHowever, due to the autoregressive nature of language models, GPT only looks forward\n(left-to-right). In contexts \u201ci went to the bank to deposit cash\u201d and \u201ci went to the bank\nto sit down\u201d, as \u201cbank\u201d is sensitive to the context to its left, GPT will return the same\nrepresentation for \u201cbank\u201d, though it has different meanings.\n15.8.3BERT:Combining the Best of BothWorlds\nAswehaveseen,ELMoencodescontextbidirectionallybutusestask-specificarchitectures;\nwhile GPT is task-agnostic but encodes context left-to-right.", "mimetype": "text/plain", "start_char_idx": 1537523, "end_char_idx": 1541701, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d87f29a6-ddb6-4a34-ab86-2fe9a317e63b": {"__data__": {"id_": "d87f29a6-ddb6-4a34-ab86-2fe9a317e63b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "717f6a15-fd93-4b21-9a10-f3da311ccf80", "node_type": "1", "metadata": {}, "hash": "5f80e252502b2d90d6e46fc560a0cae131b9f465a7d52f07a3f5b5f5380efd66", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d5696b51-3619-4906-bc37-9abd85ea5a53", "node_type": "1", "metadata": {}, "hash": "63a1b530d5a5fa9a585b6a382d03ae0702007dad2109c3dc3ba2bb161d86f18b", "class_name": "RelatedNodeInfo"}}, "text": "GPT was evaluated on twelve tasks of natural language inference, question answer-\ning, sentencesimilarity, andclassification, andimprovedthestateoftheartinnineofthem\nwith minimal changes to the model architecture.\nHowever, due to the autoregressive nature of language models, GPT only looks forward\n(left-to-right). In contexts \u201ci went to the bank to deposit cash\u201d and \u201ci went to the bank\nto sit down\u201d, as \u201cbank\u201d is sensitive to the context to its left, GPT will return the same\nrepresentation for \u201cbank\u201d, though it has different meanings.\n15.8.3BERT:Combining the Best of BothWorlds\nAswehaveseen,ELMoencodescontextbidirectionallybutusestask-specificarchitectures;\nwhile GPT is task-agnostic but encodes context left-to-right. Combining the best of both\nworlds, BERT (Bidirectional Encoder Representations from Transformers) encodes con-\ntext bidirectionally and requires minimal architecture changes for a wide range of natural\nlanguage processing tasks ( Devlinet al., 2018). Using a pretrained Transformer encoder,\nBERT is able to represent any token based on its bidirectional context. During supervised\n726 Natural Language Processing: Pretraining\nlearning of downstream tasks, BERT is similar to GPT in two aspects. First, BERT rep-\nresentations will be fed into an added output layer, with minimal changes to the model\narchitecture depending on nature of tasks, such as predicting for every token vs. predicting\nfor the entire sequence. Second, all the parameters of the pretrained Transformer encoder\nare fine-tuned, while the additional output layer will be trained from scratch. Fig. 15.8.1\ndepicts the differences among ELMo, GPT, and BERT.\ntFig. 15.8.1 A comparison of ELMo, GPT, and BERT.\nBERT further improved the state of the art on eleven natural language processing tasks\nunderbroadcategoriesof(i)singletextclassification(e.g.,sentimentanalysis),(ii)textpair\nclassification (e.g., natural language inference), (iii) question answering, (iv) text tagging\n(e.g., named entity recognition). All proposed in 2018, from context-sensitive ELMo to\ntask-agnostic GPT and BERT, conceptually simple yet empirically powerful pretraining of\ndeep representations for natural languages have revolutionized solutions to various natural\nlanguage processing tasks.\nIntherestofthischapter,wewilldiveintothepretrainingofBERT.Whennaturallanguage\nprocessingapplicationsareexplainedin Chapter16 , wewillillustratefine-tuningofBERT\nfor downstream applications.\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n15.8.4InputRepresentation\nIn natural language processing, some tasks (e.g., sentiment analysis) take single text as\ninput, while in some other tasks (e.g., natural language inference), the input is a pair of\ntext sequences. The BERT input sequence unambiguously represents both single text and\ntext pairs. In the former, the BERT input sequence is the concatenation of the special\nclassification token \u201c<cls>\u201d, tokens of a text sequence, and the special separation token\n\u201c<sep>\u201d. In the latter, the BERT input sequence is the concatenation of \u201c<cls>\u201d, tokens\nof the first text sequence, \u201c<sep>\u201d, tokens of the second text sequence, and \u201c<sep>\u201d. We\nwill consistently distinguish the terminology \u201cBERT input sequence\u201d from other types of\n727 Bidirectional Encoder Representations from Transformers (BERT)\n\u201csequences\u201d. For instance, one BERTinputsequence may include either one textsequence\nor twotextsequences .\nTo distinguish text pairs, the learned segment embeddings e\ud835\udc34ande\ud835\udc35are added to the\ntoken embeddings of the first sequence and the second sequence, respectively. For single\ntext inputs, only e\ud835\udc34is used.\nThe following get_tokens_and_segments takes either one sentence or two sentences as\ninput, then returns tokens of the BERT input sequence and their corresponding segment\nIDs.\n#@save\ndef get_tokens_and_segments (tokens_a, tokens_b =None ):\n\"\"\"Get tokens of the BERT input sequence and their segment IDs.\"\"\"\ntokens =['<cls> ']+tokens_a +['<sep> ']\n# 0 and 1 are marking segment A and B, respectively\nsegments =[0]*(len(tokens_a) +2)\niftokens_b isnot None :\ntokens +=tokens_b +['<sep> ']\nsegments +=[1]*(len(tokens_b) +1)\nreturn tokens, segments\nBERT chooses the Transformer encoder as its bidirectional architecture.", "mimetype": "text/plain", "start_char_idx": 1540975, "end_char_idx": 1545216, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d5696b51-3619-4906-bc37-9abd85ea5a53": {"__data__": {"id_": "d5696b51-3619-4906-bc37-9abd85ea5a53", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d87f29a6-ddb6-4a34-ab86-2fe9a317e63b", "node_type": "1", "metadata": {}, "hash": "342d67ce9d48e928a3b1bc773aafeaf910638fccb1313aab0f58125bf3ce1a81", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ba664613-e34d-4d2f-8d7d-219b4dde655b", "node_type": "1", "metadata": {}, "hash": "88f3a7c6c1e46a38479112702c4f28039843cea6ce5099ca2a3a8a4e4fa6d356", "class_name": "RelatedNodeInfo"}}, "text": "For single\ntext inputs, only e\ud835\udc34is used.\nThe following get_tokens_and_segments takes either one sentence or two sentences as\ninput, then returns tokens of the BERT input sequence and their corresponding segment\nIDs.\n#@save\ndef get_tokens_and_segments (tokens_a, tokens_b =None ):\n\"\"\"Get tokens of the BERT input sequence and their segment IDs.\"\"\"\ntokens =['<cls> ']+tokens_a +['<sep> ']\n# 0 and 1 are marking segment A and B, respectively\nsegments =[0]*(len(tokens_a) +2)\niftokens_b isnot None :\ntokens +=tokens_b +['<sep> ']\nsegments +=[1]*(len(tokens_b) +1)\nreturn tokens, segments\nBERT chooses the Transformer encoder as its bidirectional architecture. Common in the\nTransformerencoder,positionalembeddingsareaddedateverypositionoftheBERTinput\nsequence. However,differentfromtheoriginalTransformerencoder,BERTuses learnable\npositional embeddings. To sum up, Fig. 15.8.2 shows that the embeddings of the BERT\ninput sequence are the sum of the token embeddings, segment embeddings, and positional\nembeddings.\ntFig. 15.8.2 The embeddings of the BERT input sequence are the sum of the token embeddings,\nsegment embeddings, and positional embeddings.\nThe following BERTEncoder class is similar to the TransformerEncoder class as imple-\nmentedin Section11.7 . Differentfrom TransformerEncoder ,BERTEncoder usessegment\nembeddings and learnable positional embeddings.\n#@save\nclass BERTEncoder (nn.Module):\n\"\"\"BERT encoder.\"\"\"\ndef __init__ (self , vocab_size, num_hiddens, ffn_num_hiddens, num_heads,\nnum_blks, dropout, max_len =1000 ,**kwargs):\n(continues on next page)\n728 Natural Language Processing: Pretraining\n(continued from previous page)\nsuper (BERTEncoder, self ).__init__ (**kwargs)\nself .token_embedding =nn.Embedding(vocab_size, num_hiddens)\nself .segment_embedding =nn.Embedding( 2, num_hiddens)\nself .blks =nn.Sequential()\nfor iinrange (num_blks):\nself .blks .add_module( f\"{i}\", d2l .TransformerEncoderBlock(\nnum_hiddens, ffn_num_hiddens, num_heads, dropout, True ))\n# In BERT, positional embeddings are learnable, thus we create a\n# parameter of positional embeddings that are long enough\nself .pos_embedding =nn.Parameter(torch .randn( 1, max_len,\nnum_hiddens))\ndef forward (self , tokens, segments, valid_lens):\n# Shape of `X` remains unchanged in the following code snippet:\n# (batch size, max sequence length, `num_hiddens`)\nX=self .token_embedding(tokens) +self .segment_embedding(segments)\nX=X+self .pos_embedding[:, :X .shape[ 1], :]\nfor blk inself .blks:\nX=blk(X, valid_lens)\nreturn X\nSuppose that the vocabulary size is 10000. To demonstrate forward inference of BERTEn-\ncoder, let\u2019s create an instance of it and initialize its parameters.\nvocab_size, num_hiddens, ffn_num_hiddens, num_heads =10000 ,768,1024 ,4\nffn_num_input, num_blks, dropout =768,2,0.2\nencoder =BERTEncoder(vocab_size, num_hiddens, ffn_num_hiddens, num_heads,\nnum_blks, dropout)\nWe define tokensto be 2 BERT input sequences of length 8, where each token is an index\nof the vocabulary. The forward inference of BERTEncoder with the input tokensreturns\nthe encoded result where each token is represented by a vector whose length is predefined\nby the hyperparameter num_hiddens . This hyperparameter is usually referred to as the\nhiddensize (number of hidden units) of the Transformer encoder.\ntokens =torch .randint( 0, vocab_size, ( 2,8))\nsegments =torch .tensor([[ 0,0,0,0,1,1,1,1], [ 0,0,0,1,1,1,1,1]])\nencoded_X =encoder(tokens, segments, None )\nencoded_X .shape\ntorch .Size([ 2,8,768])\n15.8.5PretrainingTasks\nThe forward inference of BERTEncoder gives the BERT representation of each token of\nthe input text and the inserted special tokens \u201c<cls>\u201d and \u201c<seq>\u201d. Next, we will use\nthese representations to compute the loss function for pretraining BERT. The pretraining\nis composed of the following two tasks: masked language modeling and next sentence\nprediction.", "mimetype": "text/plain", "start_char_idx": 1544562, "end_char_idx": 1548416, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ba664613-e34d-4d2f-8d7d-219b4dde655b": {"__data__": {"id_": "ba664613-e34d-4d2f-8d7d-219b4dde655b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d5696b51-3619-4906-bc37-9abd85ea5a53", "node_type": "1", "metadata": {}, "hash": "63a1b530d5a5fa9a585b6a382d03ae0702007dad2109c3dc3ba2bb161d86f18b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "362b25b1-ae2a-42ba-bf01-b0d30f39b0b3", "node_type": "1", "metadata": {}, "hash": "c841b5789953bbc6caa99267f8c453246c86b1e7461ff7162e90ae7f2cc97fb8", "class_name": "RelatedNodeInfo"}}, "text": "This hyperparameter is usually referred to as the\nhiddensize (number of hidden units) of the Transformer encoder.\ntokens =torch .randint( 0, vocab_size, ( 2,8))\nsegments =torch .tensor([[ 0,0,0,0,1,1,1,1], [ 0,0,0,1,1,1,1,1]])\nencoded_X =encoder(tokens, segments, None )\nencoded_X .shape\ntorch .Size([ 2,8,768])\n15.8.5PretrainingTasks\nThe forward inference of BERTEncoder gives the BERT representation of each token of\nthe input text and the inserted special tokens \u201c<cls>\u201d and \u201c<seq>\u201d. Next, we will use\nthese representations to compute the loss function for pretraining BERT. The pretraining\nis composed of the following two tasks: masked language modeling and next sentence\nprediction.\n729 Bidirectional Encoder Representations from Transformers (BERT)\nMaskedLanguage Modeling\nAs illustrated in Section 9.3 , a language model predicts a token using the context on its\nleft. To encode context bidirectionally for representing each token, BERT randomly masks\ntokens and uses tokens from the bidirectional context to predict the masked tokens in a\nself-supervised fashion. This task is referred to as a masked languagemodel .\nIn this pretraining task, 15% of tokens will be selected at random as the masked tokens for\nprediction. To predict a masked token without cheating by using the label, one straight-\nforward approach is to always replace it with a special \u201c<mask>\u201d token in the BERT input\nsequence. However, the artificial special token \u201c<mask>\u201d will never appear in fine-tuning.\nTo avoid such a mismatch between pretraining and fine-tuning, if a token is masked for\nprediction (e.g., \u201cgreat\u201d is selected to be masked and predicted in \u201cthis movie is great\u201d), in\nthe input it will be replaced with:\n\u000fa special \u201c<mask>\u201d token for 80% of the time (e.g., \u201cthis movie is great\u201d becomes \u201cthis\nmovie is <mask>\u201d);\n\u000fa random token for 10% of the time (e.g., \u201cthis movie is great\u201d becomes \u201cthis movie is\ndrink\u201d);\n\u000fthe unchanged label token for 10% of the time (e.g., \u201cthis movie is great\u201d becomes \u201cthis\nmovie is great\u201d).\nNotethatfor10%of15%timearandomtokenisinserted. Thisoccasionalnoiseencourages\nBERTtobelessbiasedtowardsthemaskedtoken(especiallywhenthelabeltokenremains\nunchanged) in its bidirectional context encoding.\nWeimplementthefollowing MaskLMclasstopredictmaskedtokensinthemaskedlanguage\nmodeltaskofBERTpretraining. Thepredictionusesaone-hidden-layerMLP( self.mlp ).\nIn forward inference, it takes two inputs: the encoded result of BERTEncoder and the token\npositions for prediction. The output is the prediction results at these positions.\n#@save\nclass MaskLM (nn.Module):\n\"\"\"The masked language model task of BERT.\"\"\"\ndef __init__ (self , vocab_size, num_hiddens, **kwargs):\nsuper (MaskLM, self ).__init__ (**kwargs)\nself .mlp =nn.Sequential(nn .LazyLinear(num_hiddens),\nnn.ReLU(),\nnn.LayerNorm(num_hiddens),\nnn.LazyLinear(vocab_size))\ndef forward (self , X, pred_positions):\nnum_pred_positions =pred_positions .shape[ 1]\npred_positions =pred_positions .reshape( -1)\nbatch_size =X.shape[ 0]\nbatch_idx =torch .arange( 0, batch_size)\n# Suppose that `batch_size` = 2, `num_pred_positions` = 3, then\n# `batch_idx` is `torch.tensor([0, 0, 0, 1, 1, 1])`\nbatch_idx =torch .repeat_interleave(batch_idx, num_pred_positions)\nmasked_X =X[batch_idx, pred_positions]\n(continues on next page)\n730 Natural Language Processing: Pretraining\n(continued from previous page)\nmasked_X =masked_X .reshape((batch_size, num_pred_positions, -1))\nmlm_Y_hat =self .mlp(masked_X)\nreturn mlm_Y_hat\nTo demonstrate the forward inference of MaskLM, we create its instance mlmand initialize\nit. Recall that encoded_X from the forward inference of BERTEncoder represents 2 BERT\ninputsequences.", "mimetype": "text/plain", "start_char_idx": 1547728, "end_char_idx": 1551397, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "362b25b1-ae2a-42ba-bf01-b0d30f39b0b3": {"__data__": {"id_": "362b25b1-ae2a-42ba-bf01-b0d30f39b0b3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ba664613-e34d-4d2f-8d7d-219b4dde655b", "node_type": "1", "metadata": {}, "hash": "88f3a7c6c1e46a38479112702c4f28039843cea6ce5099ca2a3a8a4e4fa6d356", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ddfc4157-b6ba-4b22-88a4-369b0145eea9", "node_type": "1", "metadata": {}, "hash": "83b40f04fcb22da2ca4071507e113b8b3d134566dfc9863ce6693f5620dc2f21", "class_name": "RelatedNodeInfo"}}, "text": "Recall that encoded_X from the forward inference of BERTEncoder represents 2 BERT\ninputsequences. Wedefine mlm_positions asthe3indicestopredictineitherBERTinput\nsequenceof encoded_X .Theforwardinferenceof mlmreturnspredictionresults mlm_Y_hat\nat all the masked positions mlm_positions ofencoded_X . For each prediction, the size of\nthe result is equal to the vocabulary size.\nmlm =MaskLM(vocab_size, num_hiddens)\nmlm_positions =torch .tensor([[ 1,5,2], [ 6,1,5]])\nmlm_Y_hat =mlm(encoded_X, mlm_positions)\nmlm_Y_hat .shape\ntorch .Size([ 2,3,10000 ])\nWith the ground truth labels mlm_Yof the predicted tokens mlm_Y_hat under masks, we\ncan calculate the cross-entropy loss of the masked language model task in BERT pretrain-\ning.\nmlm_Y =torch .tensor([[ 7,8,9], [ 10,20,30]])\nloss =nn.CrossEntropyLoss(reduction ='none ')\nmlm_l =loss(mlm_Y_hat .reshape(( -1, vocab_size)), mlm_Y .reshape( -1))\nmlm_l .shape\ntorch .Size([ 6])\nNextSentence Prediction\nAlthough masked language modeling is able to encode bidirectional context for represent-\ning words, it does not explicitly model the logical relationship between text pairs. To help\nunderstand the relationship between two text sequences, BERT considers a binary classi-\nfication task, next sentence prediction , in its pretraining. When generating sentence pairs\nfor pretraining, for half of the time they are indeed consecutive sentences with the label\n\u201cTrue\u201d; while for the other half of the time the second sentence is randomly sampled from\nthe corpus with the label \u201cFalse\u201d.\nThe following NextSentencePred class uses a one-hidden-layer MLP to predict whether\nthe second sentence is the next sentence of the first in the BERT input sequence. Due to\nself-attention in the Transformer encoder, the BERT representation of the special token\n\u201c<cls>\u201d encodes both the two sentences from the input. Hence, the output layer ( self.\n731 Bidirectional Encoder Representations from Transformers (BERT)\noutput) of the MLP classifier takes Xas input, where Xis the output of the MLP hidden\nlayer whose input is the encoded \u201c<cls>\u201d token.\n#@save\nclass NextSentencePred (nn.Module):\n\"\"\"The next sentence prediction task of BERT.\"\"\"\ndef __init__ (self ,**kwargs):\nsuper (NextSentencePred, self ).__init__ (**kwargs)\nself .output =nn.LazyLinear( 2)\ndef forward (self , X):\n# `X` shape: (batch size, `num_hiddens`)\nreturn self .output(X)\nWe can see that the forward inference of an NextSentencePred instance returns binary\npredictions for each BERT input sequence.\n# PyTorch by default will not flatten the tensor as seen in mxnet where, if\n# flatten=True, all but the first axis of input data are collapsed together\nencoded_X =torch .flatten(encoded_X, start_dim =1)\n# input_shape for NSP: (batch size, `num_hiddens`)\nnsp =NextSentencePred()\nnsp_Y_hat =nsp(encoded_X)\nnsp_Y_hat .shape\ntorch .Size([ 2,2])\nThe cross-entropy loss of the 2 binary classifications can also be computed.\nnsp_y =torch .tensor([ 0,1])\nnsp_l =loss(nsp_Y_hat, nsp_y)\nnsp_l .shape\ntorch .Size([ 2])\nIt is noteworthy that all the labels in both the aforementioned pretraining tasks can be triv-\nially obtained from the pretraining corpus without manual labeling effort. The original\nBERT has been pretrained on the concatenation of BookCorpus ( Zhuetal., 2015) and En-\nglish Wikipedia. These two text corpora are huge: they have 800 million words and 2.5\nbillion words, respectively.\n15.8.6PuttingIt All Together\nWhen pretraining BERT, the final loss function is a linear combination of both the loss\nfunctions for masked language modeling and next sentence prediction. Now we can de-\nfine the BERTModel class by instantiating the three classes BERTEncoder ,MaskLM, and\nNextSentencePred . TheforwardinferencereturnstheencodedBERTrepresentations en-\n732 Natural Language Processing: Pretraining\ncoded_X , predictions of masked language modeling mlm_Y_hat , and next sentence predic-\ntions nsp_Y_hat .\n#@save\nclass BERTModel (nn.Module):\n\"\"\"The BERT model.\"\"\"", "mimetype": "text/plain", "start_char_idx": 1551300, "end_char_idx": 1555261, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ddfc4157-b6ba-4b22-88a4-369b0145eea9": {"__data__": {"id_": "ddfc4157-b6ba-4b22-88a4-369b0145eea9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "362b25b1-ae2a-42ba-bf01-b0d30f39b0b3", "node_type": "1", "metadata": {}, "hash": "c841b5789953bbc6caa99267f8c453246c86b1e7461ff7162e90ae7f2cc97fb8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "31dafcb9-20a3-46f5-b892-4741dcdf3ddf", "node_type": "1", "metadata": {}, "hash": "0ba26301d1886bdcdde9b292fc800b500d75b2e736913b4068e63bb20f097689", "class_name": "RelatedNodeInfo"}}, "text": "The original\nBERT has been pretrained on the concatenation of BookCorpus ( Zhuetal., 2015) and En-\nglish Wikipedia. These two text corpora are huge: they have 800 million words and 2.5\nbillion words, respectively.\n15.8.6PuttingIt All Together\nWhen pretraining BERT, the final loss function is a linear combination of both the loss\nfunctions for masked language modeling and next sentence prediction. Now we can de-\nfine the BERTModel class by instantiating the three classes BERTEncoder ,MaskLM, and\nNextSentencePred . TheforwardinferencereturnstheencodedBERTrepresentations en-\n732 Natural Language Processing: Pretraining\ncoded_X , predictions of masked language modeling mlm_Y_hat , and next sentence predic-\ntions nsp_Y_hat .\n#@save\nclass BERTModel (nn.Module):\n\"\"\"The BERT model.\"\"\"\ndef __init__ (self , vocab_size, num_hiddens, ffn_num_hiddens,\nnum_heads, num_blks, dropout, max_len =1000 ):\nsuper (BERTModel, self ).__init__ ()\nself .encoder =BERTEncoder(vocab_size, num_hiddens, ffn_num_hiddens,\nnum_heads, num_blks, dropout,\nmax_len =max_len)\nself .hidden =nn.Sequential(nn .LazyLinear(num_hiddens),\nnn.Tanh())\nself .mlm =MaskLM(vocab_size, num_hiddens)\nself .nsp =NextSentencePred()\ndef forward (self , tokens, segments, valid_lens =None , pred_positions =None ):\nencoded_X =self .encoder(tokens, segments, valid_lens)\nifpred_positions isnot None :\nmlm_Y_hat =self .mlm(encoded_X, pred_positions)\nelse :\nmlm_Y_hat =None\n# The hidden layer of the MLP classifier for next sentence prediction.\n# 0 is the index of the '<cls>' token\nnsp_Y_hat =self .nsp( self .hidden(encoded_X[:, 0, :]))\nreturn encoded_X, mlm_Y_hat, nsp_Y_hat\n15.8.7Summary\n\u000fWord embedding models such as word2vec and GloVe are context-independent. They\nassign the same pretrained vector to the same word regardless of the context of the\nword (if any). It is hard for them to handle well polysemy or complex semantics in\nnatural languages.\n\u000fFor context-sensitive word representations such as ELMo and GPT, representations of\nwords depend on their contexts.\n\u000fELMo encodes context bidirectionally but uses task-specific architectures (however, it is\npractically non-trivial to craft a specific architecture for every natural language pro-\ncessing task); while GPT is task-agnostic but encodes context left-to-right.\n\u000fBERT combines the best of both worlds: it encodes context bidirectionally and requires\nminimal architecture changes for a wide range of natural language processing tasks.\n\u000fThe embeddings of the BERT input sequence are the sum of the token embeddings,\nsegment embeddings, and positional embeddings.\n\u000fPretraining BERT is composed of two tasks: masked language modeling and next sen-\ntence prediction. The former is able to encode bidirectional context for representing\nwords, while the latter explicitly models the logical relationship between text pairs.\n733 The Dataset for Pretraining BERT\n23815.8.8Exercises\n1.All other things being equal, will a masked language model require more or fewer pre-\ntraining steps to converge than a left-to-right language model? Why?\n2.IntheoriginalimplementationofBERT,thepositionwisefeed-forwardnetworkin BERTEn-\ncoder(viad2l.TransformerEncoderBlock ) and the fully connected layer in MaskLM\nboth use the Gaussian error linear unit (GELU) ( Hendrycks and Gimpel, 2016 ) as the\nactivation function. Research into the difference between GELU and ReLU.\nDiscussions238.\n15.9TheDatasetforPretrainingBERT\nTopretraintheBERTmodelasimplementedin Section15.8 ,weneedtogeneratethedataset\nin the ideal format to facilitate the two pretraining tasks: masked language modeling and\nnext sentence prediction. On the one hand, the original BERT model is pretrained on\nthe concatenation of two huge corpora BookCorpus and English Wikipedia (see Section\n15.8.5), making it hard to run for most readers of this book. On the other hand, the off-\nthe-shelf pretrained BERT model may not fit for applications from specific domains like\nmedicine. Thus, it is getting popular to pretrain BERT on a customized dataset. To facil-\nitate the demonstration of BERT pretraining, we use a smaller corpus WikiText-2 ( Merity\netal., 2016).", "mimetype": "text/plain", "start_char_idx": 1554474, "end_char_idx": 1558603, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "31dafcb9-20a3-46f5-b892-4741dcdf3ddf": {"__data__": {"id_": "31dafcb9-20a3-46f5-b892-4741dcdf3ddf", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ddfc4157-b6ba-4b22-88a4-369b0145eea9", "node_type": "1", "metadata": {}, "hash": "83b40f04fcb22da2ca4071507e113b8b3d134566dfc9863ce6693f5620dc2f21", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cf73f85d-e095-4d93-8ac1-15a099abce90", "node_type": "1", "metadata": {}, "hash": "5ce496da13acd48b68e454064a690457dd0207e836a07a3f11b10fb1e30a94d9", "class_name": "RelatedNodeInfo"}}, "text": "Research into the difference between GELU and ReLU.\nDiscussions238.\n15.9TheDatasetforPretrainingBERT\nTopretraintheBERTmodelasimplementedin Section15.8 ,weneedtogeneratethedataset\nin the ideal format to facilitate the two pretraining tasks: masked language modeling and\nnext sentence prediction. On the one hand, the original BERT model is pretrained on\nthe concatenation of two huge corpora BookCorpus and English Wikipedia (see Section\n15.8.5), making it hard to run for most readers of this book. On the other hand, the off-\nthe-shelf pretrained BERT model may not fit for applications from specific domains like\nmedicine. Thus, it is getting popular to pretrain BERT on a customized dataset. To facil-\nitate the demonstration of BERT pretraining, we use a smaller corpus WikiText-2 ( Merity\netal., 2016).\nComparing with the PTB dataset used for pretraining word2vec in Section 15.3 , WikiText-\n2 (i) retains the original punctuation, making it suitable for next sentence prediction; (ii)\nretains the original case and numbers; (iii) is over twice larger.\nimport os\nimport random\nimport torch\nfrom d2l import torch asd2l\nIn the WikiText-2 dataset, each line represents a paragraph where space is inserted be-\ntween any punctuation and its preceding token. Paragraphs with at least two sentences are\nretained. To split sentences, we only use the period as the delimiter for simplicity. We\nleave discussions of more complex sentence splitting techniques in the exercises at the end\nof this section.\n#@save\nd2l.DATA_HUB[ 'wikitext-2 ']=(\n'https://s3.amazonaws.com/research.metamind.io/wikitext/ '\n'wikitext-2-v1.zip ','3c914d17d80b1459be871a5039ac23e752a53cbe ')\n#@save\n(continues on next page)\n734 Natural Language Processing: Pretraining\n(continued from previous page)\ndef _read_wiki (data_dir):\nfile_name =os.path .join(data_dir, 'wiki.train.tokens ')\nwith open (file_name, 'r')asf:\nlines =f.readlines()\n# Uppercase letters are converted to lowercase ones\nparagraphs =[line .strip() .lower() .split( '.')\nfor line inlines iflen(line .split( '.'))>=2]\nrandom .shuffle(paragraphs)\nreturn paragraphs\n15.9.1Defining Helper Functions forPretrainingTasks\nIn the following, we begin by implementing helper functions for the two BERT pretraining\ntasks: next sentence prediction and masked language modeling. These helper functions\nwill be invoked later when transforming the raw text corpus into the dataset of the ideal\nformat to pretrain BERT.\nGenerating the NextSentence PredictionTask\nAccording to descriptions of Section 15.8.5 , the _get_next_sentence function generates\na training example for the binary classification task.\n#@save\ndef _get_next_sentence (sentence, next_sentence, paragraphs):\nifrandom .random() <0.5:\nis_next =True\nelse :\n# `paragraphs` is a list of lists of lists\nnext_sentence =random .choice(random .choice(paragraphs))\nis_next =False\nreturn sentence, next_sentence, is_next\nThe following function generates training examples for next sentence prediction from the\ninput paragraph byinvokingthe _get_next_sentence function. Here paragraph isalist\nof sentences, where each sentence is a list of tokens. The argument max_len specifies the\nmaximum length of a BERT input sequence during pretraining.\n#@save\ndef _get_nsp_data_from_paragraph (paragraph, paragraphs, vocab, max_len):\nnsp_data_from_paragraph =[]\nfor iinrange (len(paragraph) -1):\ntokens_a, tokens_b, is_next =_get_next_sentence(\nparagraph[i], paragraph[i +1], paragraphs)\n# Consider 1 '<cls>' token and 2 '<sep>' tokens\niflen(tokens_a) +len(tokens_b) +3>max_len:\ncontinue\ntokens, segments =d2l.get_tokens_and_segments(tokens_a, tokens_b)\nnsp_data_from_paragraph .append((tokens, segments, is_next))\nreturn nsp_data_from_paragraph\n735 The Dataset for Pretraining BERT\nGeneratingthe MaskedLanguageModeling Task\nInordertogeneratetrainingexamplesforthemaskedlanguagemodelingtaskfromaBERT\ninputsequence,wedefinethefollowing _replace_mlm_tokens function.", "mimetype": "text/plain", "start_char_idx": 1557796, "end_char_idx": 1561725, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cf73f85d-e095-4d93-8ac1-15a099abce90": {"__data__": {"id_": "cf73f85d-e095-4d93-8ac1-15a099abce90", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "31dafcb9-20a3-46f5-b892-4741dcdf3ddf", "node_type": "1", "metadata": {}, "hash": "0ba26301d1886bdcdde9b292fc800b500d75b2e736913b4068e63bb20f097689", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5cb38e66-60a6-46c9-ad6d-f68a7327f624", "node_type": "1", "metadata": {}, "hash": "14559389c06dd823547baa3b0d060cbb778e00eab37ad4769ae1dbb5c43b6f71", "class_name": "RelatedNodeInfo"}}, "text": "#@save\ndef _get_nsp_data_from_paragraph (paragraph, paragraphs, vocab, max_len):\nnsp_data_from_paragraph =[]\nfor iinrange (len(paragraph) -1):\ntokens_a, tokens_b, is_next =_get_next_sentence(\nparagraph[i], paragraph[i +1], paragraphs)\n# Consider 1 '<cls>' token and 2 '<sep>' tokens\niflen(tokens_a) +len(tokens_b) +3>max_len:\ncontinue\ntokens, segments =d2l.get_tokens_and_segments(tokens_a, tokens_b)\nnsp_data_from_paragraph .append((tokens, segments, is_next))\nreturn nsp_data_from_paragraph\n735 The Dataset for Pretraining BERT\nGeneratingthe MaskedLanguageModeling Task\nInordertogeneratetrainingexamplesforthemaskedlanguagemodelingtaskfromaBERT\ninputsequence,wedefinethefollowing _replace_mlm_tokens function. Initsinputs, to-\nkensisalistoftokensrepresentingaBERTinputsequence, candidate_pred_positions\nisalistoftokenindicesoftheBERTinputsequenceexcludingthoseofspecialtokens(spe-\ncial tokens are not predicted in the masked language modeling task), and num_mlm_preds\nindicates the number of predictions (recall 15% random tokens to predict). Following the\ndefinitionofthemaskedlanguagemodelingtaskin Section15.8.5 , at eachpredictionposi-\ntion, the input may be replaced by a special \u201c<mask>\u201d token or a random token, or remain\nunchanged. Intheend, thefunctionreturnstheinputtokensafterpossiblereplacement, the\ntoken indices where predictions take place and labels for these predictions.\n#@save\ndef _replace_mlm_tokens (tokens, candidate_pred_positions, num_mlm_preds,\nvocab):\n# For the input of a masked language model, make a new copy of tokens and\n# replace some of them by '<mask>' or random tokens\nmlm_input_tokens =[token for token intokens]\npred_positions_and_labels =[]\n# Shuffle for getting 15% random tokens for prediction in the masked\n# language modeling task\nrandom .shuffle(candidate_pred_positions)\nfor mlm_pred_position incandidate_pred_positions:\niflen(pred_positions_and_labels) >=num_mlm_preds:\nbreak\nmasked_token =None\n# 80% of the time: replace the word with the '<mask>' token\nifrandom .random() <0.8:\nmasked_token ='<mask> '\nelse :\n# 10% of the time: keep the word unchanged\nifrandom .random() <0.5:\nmasked_token =tokens[mlm_pred_position]\n# 10% of the time: replace the word with a random word\nelse :\nmasked_token =random .choice(vocab .idx_to_token)\nmlm_input_tokens[mlm_pred_position] =masked_token\npred_positions_and_labels .append(\n(mlm_pred_position, tokens[mlm_pred_position]))\nreturn mlm_input_tokens, pred_positions_and_labels\nBy invoking the aforementioned _replace_mlm_tokens function, the following function\ntakes a BERT input sequence ( tokens) as an input and returns indices of the input tokens\n(after possible token replacement as described in Section 15.8.5 ), the token indices where\npredictions take place, and label indices for these predictions.\n#@save\ndef _get_mlm_data_from_tokens (tokens, vocab):\ncandidate_pred_positions =[]\n# `tokens` is a list of strings\nfor i, token inenumerate (tokens):\n(continues on next page)\n736 Natural Language Processing: Pretraining\n(continued from previous page)\n# Special tokens are not predicted in the masked language modeling\n# task\niftoken in['<cls> ','<sep> ']:\ncontinue\ncandidate_pred_positions .append(i)\n# 15% of random tokens are predicted in the masked language modeling task\nnum_mlm_preds =max(1,round (len(tokens) *0.15 ))\nmlm_input_tokens, pred_positions_and_labels =_replace_mlm_tokens(\ntokens, candidate_pred_positions, num_mlm_preds, vocab)\npred_positions_and_labels =sorted (pred_positions_and_labels,\nkey=lambda x: x[ 0])\npred_positions =[v[0]for vinpred_positions_and_labels]\nmlm_pred_labels =[v[1]for vinpred_positions_and_labels]\nreturn vocab[mlm_input_tokens], pred_positions, vocab[mlm_pred_labels]\n15.9.2TransformingTextinto the PretrainingDataset\nNow we are almost ready to customize a Dataset class for pretraining BERT. Before that,\nwestillneedtodefineahelperfunction _pad_bert_inputs toappendthespecial\u201c<pad>\u201d\ntokens to the inputs. Its argument examples contain the outputs from the helper func-\ntions _get_nsp_data_from_paragraph and_get_mlm_data_from_tokens for the two\npretraining tasks.", "mimetype": "text/plain", "start_char_idx": 1561014, "end_char_idx": 1565114, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5cb38e66-60a6-46c9-ad6d-f68a7327f624": {"__data__": {"id_": "5cb38e66-60a6-46c9-ad6d-f68a7327f624", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cf73f85d-e095-4d93-8ac1-15a099abce90", "node_type": "1", "metadata": {}, "hash": "5ce496da13acd48b68e454064a690457dd0207e836a07a3f11b10fb1e30a94d9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "436560a5-e974-4910-9c44-d0a2d5034950", "node_type": "1", "metadata": {}, "hash": "72fc485c907796da7fdfd48c4600e031149f47a84b14d22f390a65fa6ea0f7af", "class_name": "RelatedNodeInfo"}}, "text": "Before that,\nwestillneedtodefineahelperfunction _pad_bert_inputs toappendthespecial\u201c<pad>\u201d\ntokens to the inputs. Its argument examples contain the outputs from the helper func-\ntions _get_nsp_data_from_paragraph and_get_mlm_data_from_tokens for the two\npretraining tasks.\n#@save\ndef _pad_bert_inputs (examples, max_len, vocab):\nmax_num_mlm_preds =round (max_len *0.15 )\nall_token_ids, all_segments, valid_lens, =[], [], []\nall_pred_positions, all_mlm_weights, all_mlm_labels =[], [], []\nnsp_labels =[]\nfor (token_ids, pred_positions, mlm_pred_label_ids, segments,\nis_next) inexamples:\nall_token_ids .append(torch .tensor(token_ids +[vocab[ '<pad> ']]*(\nmax_len -len(token_ids)), dtype =torch .long))\nall_segments .append(torch .tensor(segments +[0]*(\nmax_len -len(segments)), dtype =torch .long))\n# `valid_lens` excludes count of '<pad>' tokens\nvalid_lens .append(torch .tensor( len(token_ids), dtype =torch .float32))\nall_pred_positions .append(torch .tensor(pred_positions +[0]*(\nmax_num_mlm_preds -len(pred_positions)), dtype =torch .long))\n# Predictions of padded tokens will be filtered out in the loss via\n# multiplication of 0 weights\nall_mlm_weights .append(\ntorch .tensor([ 1.0]*len(mlm_pred_label_ids) +[0.0]*(\nmax_num_mlm_preds -len(pred_positions)),\ndtype =torch .float32))\nall_mlm_labels .append(torch .tensor(mlm_pred_label_ids +[0]*(\nmax_num_mlm_preds -len(mlm_pred_label_ids)), dtype =torch .long))\nnsp_labels .append(torch .tensor(is_next, dtype =torch .long))\nreturn (all_token_ids, all_segments, valid_lens, all_pred_positions,\nall_mlm_weights, all_mlm_labels, nsp_labels)\nPutting the helper functions for generating training examples of the two pretraining tasks,\n737 The Dataset for Pretraining BERT\nand the helper function for padding inputs together, we customize the following _Wiki-\nTextDataset class as the WikiText-2 dataset for pretraining BERT. By implementing the\n__getitem__ function, we can arbitrarily access the pretraining (masked language model-\ning and next sentence prediction) examples generated from a pair of sentences from the\nWikiText-2 corpus.\nThe original BERT model uses WordPiece embeddings whose vocabulary size is 30000\n(Wuet al., 2016). The tokenization method of WordPiece is a slight modification of the\noriginal byte pair encoding algorithm in Section 15.6.2 . For simplicity, we use the d2l.\ntokenize function for tokenization. Infrequent tokens that appear less than five times are\nfiltered out.", "mimetype": "text/plain", "start_char_idx": 1564843, "end_char_idx": 1567293, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "436560a5-e974-4910-9c44-d0a2d5034950": {"__data__": {"id_": "436560a5-e974-4910-9c44-d0a2d5034950", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5cb38e66-60a6-46c9-ad6d-f68a7327f624", "node_type": "1", "metadata": {}, "hash": "14559389c06dd823547baa3b0d060cbb778e00eab37ad4769ae1dbb5c43b6f71", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b20d81a9-d671-4b73-a2a8-26c234f21e1f", "node_type": "1", "metadata": {}, "hash": "8e2febec3c49ad91dc1b434f033fe7211678b2e679a35e14e018315ce040b88d", "class_name": "RelatedNodeInfo"}}, "text": "By implementing the\n__getitem__ function, we can arbitrarily access the pretraining (masked language model-\ning and next sentence prediction) examples generated from a pair of sentences from the\nWikiText-2 corpus.\nThe original BERT model uses WordPiece embeddings whose vocabulary size is 30000\n(Wuet al., 2016). The tokenization method of WordPiece is a slight modification of the\noriginal byte pair encoding algorithm in Section 15.6.2 . For simplicity, we use the d2l.\ntokenize function for tokenization. Infrequent tokens that appear less than five times are\nfiltered out.\n#@save\nclass _WikiTextDataset (torch .utils .data .Dataset):\ndef __init__ (self , paragraphs, max_len):\n# Input `paragraphs[i]` is a list of sentence strings representing a\n# paragraph; while output `paragraphs[i]` is a list of sentences\n# representing a paragraph, where each sentence is a list of tokens\nparagraphs =[d2l .tokenize(\nparagraph, token ='word ')for paragraph inparagraphs]\nsentences =[sentence for paragraph inparagraphs\nfor sentence inparagraph]\nself .vocab =d2l.Vocab(sentences, min_freq =5, reserved_tokens =[\n'<pad> ','<mask> ','<cls> ','<sep> '])\n# Get data for the next sentence prediction task\nexamples =[]\nfor paragraph inparagraphs:\nexamples .extend(_get_nsp_data_from_paragraph(\nparagraph, paragraphs, self .vocab, max_len))\n# Get data for the masked language model task\nexamples =[(_get_mlm_data_from_tokens(tokens, self .vocab)\n+(segments, is_next))\nfor tokens, segments, is_next inexamples]\n# Pad inputs\n(self .all_token_ids, self .all_segments, self .valid_lens,\nself .all_pred_positions, self .all_mlm_weights,\nself .all_mlm_labels, self .nsp_labels) =_pad_bert_inputs(\nexamples, max_len, self .vocab)\ndef __getitem__ (self , idx):\nreturn (self .all_token_ids[idx], self .all_segments[idx],\nself .valid_lens[idx], self .all_pred_positions[idx],\nself .all_mlm_weights[idx], self .all_mlm_labels[idx],\nself .nsp_labels[idx])\ndef __len__ (self ):\nreturn len(self .all_token_ids)\nByusingthe _read_wiki functionandthe _WikiTextDataset class,wedefinethefollow-\ningload_data_wiki to download and WikiText-2 dataset and generate pretraining exam-\nples from it.\n738 Natural Language Processing: Pretraining\n#@save\ndef load_data_wiki (batch_size, max_len):\n\"\"\"Load the WikiText-2 dataset.\"\"\"\nnum_workers =d2l.get_dataloader_workers()\ndata_dir =d2l.download_extract( 'wikitext-2 ','wikitext-2 ')\nparagraphs =_read_wiki(data_dir)\ntrain_set =_WikiTextDataset(paragraphs, max_len)\ntrain_iter =torch .utils .data .DataLoader(train_set, batch_size,\nshuffle =True , num_workers =num_workers)\nreturn train_iter, train_set .vocab\nSetting the batch size to 512 and the maximum length of a BERT input sequence to be\n64, we print out the shapes of a minibatch of BERT pretraining examples. Note that in\neach BERT input sequence, 10(64\u00020.15) positions are predicted for the masked language\nmodeling task.\nbatch_size, max_len =512,64\ntrain_iter, vocab =load_data_wiki(batch_size, max_len)\nfor (tokens_X, segments_X, valid_lens_x, pred_positions_X, mlm_weights_X,\nmlm_Y, nsp_y) intrain_iter:\nprint (tokens_X .shape, segments_X .shape, valid_lens_x .shape,\npred_positions_X .shape, mlm_weights_X .shape, mlm_Y .shape,\nnsp_y .shape)\nbreak\nDownloading ../data /wikitext -2-v1.zip from https ://s3.amazonaws .com/research .\n\u21a9!metamind .io/wikitext /wikitext -2-v1.zip...\ntorch .Size([ 512,64]) torch .Size([ 512,64]) torch .Size([ 512]) torch .Size([ 512,\u2423\n\u21a9!10]) torch .Size([ 512,10]) torch .Size([ 512,10]) torch .Size([ 512])\nIntheend,let\u2019stakealookatthevocabularysize. Evenafterfilteringoutinfrequenttokens,\nit is still over twice larger than that of the PTB dataset.", "mimetype": "text/plain", "start_char_idx": 1566717, "end_char_idx": 1570367, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b20d81a9-d671-4b73-a2a8-26c234f21e1f": {"__data__": {"id_": "b20d81a9-d671-4b73-a2a8-26c234f21e1f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "436560a5-e974-4910-9c44-d0a2d5034950", "node_type": "1", "metadata": {}, "hash": "72fc485c907796da7fdfd48c4600e031149f47a84b14d22f390a65fa6ea0f7af", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b610ebb2-8deb-49db-977f-535a81c03e5e", "node_type": "1", "metadata": {}, "hash": "75c33c13b82688fd85ea979abbe2f773167945cb08135459bbeb7f6e50062348", "class_name": "RelatedNodeInfo"}}, "text": "\u21a9!metamind .io/wikitext /wikitext -2-v1.zip...\ntorch .Size([ 512,64]) torch .Size([ 512,64]) torch .Size([ 512]) torch .Size([ 512,\u2423\n\u21a9!10]) torch .Size([ 512,10]) torch .Size([ 512,10]) torch .Size([ 512])\nIntheend,let\u2019stakealookatthevocabularysize. Evenafterfilteringoutinfrequenttokens,\nit is still over twice larger than that of the PTB dataset.\nlen(vocab)\n20256\n15.9.3Summary\n\u000fComparingwiththePTBdataset,theWikiText-2datesetretainstheoriginalpunctuation,\ncase and numbers, and is over twice larger.\n\u000fWe can arbitrarily access the pretraining (masked language modeling and next sentence\nprediction) examples generated from a pair of sentences from the WikiText-2 corpus.\n15.9.4Exercises\n739 Pretraining BERT\n2391.For simplicity, the period is used as the only delimiter for splitting sentences. Try other\nsentence splitting techniques, such as the spaCy and NLTK. Take NLTK as an exam-\nple. You need to install NLTK first: pip install nltk . In the code, first import\nnltk. Then, download the Punkt sentence tokenizer: nltk.download('punkt') . To\nsplit sentences such as sentences = 'This is great ! Why not ?' , invok-\ningnltk.tokenize.sent_tokenize(sentences) will return a list of two sentence\nstrings: ['This is great !', 'Why not ?'] .\n2.What is the vocabulary size if we do not filter out any infrequent token?\nDiscussions239.\n15.10PretrainingBERT\nWiththeBERTmodelimplementedin Section15.8 andthepretrainingexamplesgenerated\nfrom the WikiText-2 dataset in Section 15.9 , we will pretrain BERT on the WikiText-2\ndataset in this section.\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\nTostart,weloadtheWikiText-2datasetasminibatchesofpretrainingexamplesformasked\nlanguage modeling and next sentence prediction. The batch size is 512 and the maximum\nlengthofaBERTinputsequenceis64. NotethatintheoriginalBERTmodel,themaximum\nlength is 512.\nbatch_size, max_len =512,64\ntrain_iter, vocab =d2l.load_data_wiki(batch_size, max_len)\n15.10.1PretrainingBERT\nTheoriginalBERThastwoversionsofdifferentmodelsizes( Devlinetal.,2018). Thebase\nmodel (BERT BASE) uses 12 layers (Transformer encoder blocks) with 768 hidden units\n(hidden size) and 12 self-attention heads. The large model (BERT LARGE) uses 24 layers\nwith 1024 hidden units and 16 self-attention heads. Notably, the former has 110 million\nparameters while the latter has 340 million parameters. For demonstration with ease, we\ndefine a small BERT, using 2 layers, 128 hidden units, and 2 self-attention heads.\nnet =d2l.BERTModel( len(vocab), num_hiddens =128,\nffn_num_hiddens =256, num_heads =2, num_blks =2, dropout =0.2)\ndevices =d2l.try_all_gpus()\nloss =nn.CrossEntropyLoss()\n740 Natural Language Processing: Pretraining\nBefore defining the training loop, we define a helper function _get_batch_loss_bert .\nGiven the shard of training examples, this function computes the loss for both the masked\nlanguage modeling and next sentence prediction tasks. Note that the final loss of BERT\npretrainingisjustthesumofboththemaskedlanguagemodelinglossandthenextsentence\nprediction loss.", "mimetype": "text/plain", "start_char_idx": 1570019, "end_char_idx": 1573068, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b610ebb2-8deb-49db-977f-535a81c03e5e": {"__data__": {"id_": "b610ebb2-8deb-49db-977f-535a81c03e5e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b20d81a9-d671-4b73-a2a8-26c234f21e1f", "node_type": "1", "metadata": {}, "hash": "8e2febec3c49ad91dc1b434f033fe7211678b2e679a35e14e018315ce040b88d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "85d3c9dc-5542-40d2-af57-996131303f4c", "node_type": "1", "metadata": {}, "hash": "e59b1fb03a8a608d8262b7f8fe510158e2bc1f37228263970ae0581f4d12ea81", "class_name": "RelatedNodeInfo"}}, "text": "For demonstration with ease, we\ndefine a small BERT, using 2 layers, 128 hidden units, and 2 self-attention heads.\nnet =d2l.BERTModel( len(vocab), num_hiddens =128,\nffn_num_hiddens =256, num_heads =2, num_blks =2, dropout =0.2)\ndevices =d2l.try_all_gpus()\nloss =nn.CrossEntropyLoss()\n740 Natural Language Processing: Pretraining\nBefore defining the training loop, we define a helper function _get_batch_loss_bert .\nGiven the shard of training examples, this function computes the loss for both the masked\nlanguage modeling and next sentence prediction tasks. Note that the final loss of BERT\npretrainingisjustthesumofboththemaskedlanguagemodelinglossandthenextsentence\nprediction loss.\n#@save\ndef _get_batch_loss_bert (net, loss, vocab_size, tokens_X,\nsegments_X, valid_lens_x,\npred_positions_X, mlm_weights_X,\nmlm_Y, nsp_y):\n# Forward pass\n_, mlm_Y_hat, nsp_Y_hat =net(tokens_X, segments_X,\nvalid_lens_x .reshape( -1),\npred_positions_X)\n# Compute masked language model loss\nmlm_l =loss(mlm_Y_hat .reshape( -1, vocab_size), mlm_Y .reshape( -1))*\\\nmlm_weights_X .reshape( -1,1)\nmlm_l =mlm_l .sum() /(mlm_weights_X .sum() +1e-8 )\n# Compute next sentence prediction loss\nnsp_l =loss(nsp_Y_hat, nsp_y)\nl=mlm_l +nsp_l\nreturn mlm_l, nsp_l, l\nInvoking the two aforementioned helper functions, the following train_bert function de-\nfinestheproceduretopretrainBERT( net)ontheWikiText-2( train_iter )dataset. Train-\ning BERT can take very long. Instead of specifying the number of epochs for training as in\nthetrain_ch13 function(see Section14.1 ),theinput num_steps ofthefollowingfunction\nspecifies the number of iteration steps for training.\ndef train_bert (train_iter, net, loss, vocab_size, devices, num_steps):\nnet( *next (iter (train_iter))[: 4])\nnet =nn.DataParallel(net, device_ids =devices) .to(devices[ 0])\ntrainer =torch .optim .Adam(net .parameters(), lr =0.01 )\nstep, timer =0, d2l .Timer()\nanimator =d2l.Animator(xlabel ='step ', ylabel ='loss ',\nxlim =[1, num_steps], legend =['mlm','nsp'])\n# Sum of masked language modeling losses, sum of next sentence prediction\n# losses, no.", "mimetype": "text/plain", "start_char_idx": 1572383, "end_char_idx": 1574466, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "85d3c9dc-5542-40d2-af57-996131303f4c": {"__data__": {"id_": "85d3c9dc-5542-40d2-af57-996131303f4c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b610ebb2-8deb-49db-977f-535a81c03e5e", "node_type": "1", "metadata": {}, "hash": "75c33c13b82688fd85ea979abbe2f773167945cb08135459bbeb7f6e50062348", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7e89e79f-4550-4a1c-bd33-f56d6a21777a", "node_type": "1", "metadata": {}, "hash": "cceb8d160ce08778675775d553cd914983a7a724b4142af87a94bf96de4657b7", "class_name": "RelatedNodeInfo"}}, "text": "Train-\ning BERT can take very long. Instead of specifying the number of epochs for training as in\nthetrain_ch13 function(see Section14.1 ),theinput num_steps ofthefollowingfunction\nspecifies the number of iteration steps for training.\ndef train_bert (train_iter, net, loss, vocab_size, devices, num_steps):\nnet( *next (iter (train_iter))[: 4])\nnet =nn.DataParallel(net, device_ids =devices) .to(devices[ 0])\ntrainer =torch .optim .Adam(net .parameters(), lr =0.01 )\nstep, timer =0, d2l .Timer()\nanimator =d2l.Animator(xlabel ='step ', ylabel ='loss ',\nxlim =[1, num_steps], legend =['mlm','nsp'])\n# Sum of masked language modeling losses, sum of next sentence prediction\n# losses, no. of sentence pairs, count\nmetric =d2l.Accumulator( 4)\nnum_steps_reached =False\nwhile step <num_steps and not num_steps_reached:\nfor tokens_X, segments_X, valid_lens_x, pred_positions_X,\\\nmlm_weights_X, mlm_Y, nsp_y intrain_iter:\ntokens_X =tokens_X .to(devices[ 0])\nsegments_X =segments_X .to(devices[ 0])\nvalid_lens_x =valid_lens_x .to(devices[ 0])\npred_positions_X =pred_positions_X .to(devices[ 0])\nmlm_weights_X =mlm_weights_X .to(devices[ 0])\nmlm_Y, nsp_y =mlm_Y .to(devices[ 0]), nsp_y .to(devices[ 0])\ntrainer .zero_grad()\ntimer .start()\nmlm_l, nsp_l, l =_get_batch_loss_bert(\n(continues on next page)\n741 Pretraining BERT\n(continued from previous page)\nnet, loss, vocab_size, tokens_X, segments_X, valid_lens_x,\npred_positions_X, mlm_weights_X, mlm_Y, nsp_y)\nl.backward()\ntrainer .step()\nmetric .add(mlm_l, nsp_l, tokens_X .shape[ 0],1)\ntimer .stop()\nanimator .add(step +1,\n(metric[ 0]/metric[ 3], metric[ 1]/metric[ 3]))\nstep +=1\nifstep ==num_steps:\nnum_steps_reached =True\nbreak\nprint (f'MLM loss {metric[ 0]/metric[ 3]:.3f},'\nf'NSP loss {metric[ 1]/metric[ 3]:.3f}')\nprint (f'{metric[ 2]/timer .sum() :.1f}sentence pairs/sec on '\nf'{str(devices) }')\nWe can plot both the masked language modeling loss and the next sentence prediction loss\nduring BERT pretraining.\ntrain_bert(train_iter, net, loss, len(vocab), devices, 50)\nMLM loss 5.885 , NSP loss 0.760\n4413.2 sentence pairs /sec on [device( type ='cuda ', index =0), device( type ='cuda ',\n\u21a9!index =1)]\n15.10.2RepresentingTextwith BERT\nAfter pretraining BERT, we can use it to represent single text, text pairs, or any token in\nthem. The following function returns the BERT ( net) representations for all tokens in\ntokens_a andtokens_b .\ndef get_bert_encoding (net, tokens_a, tokens_b =None ):\ntokens, segments =d2l.get_tokens_and_segments(tokens_a, tokens_b)\ntoken_ids =torch .tensor(vocab[tokens], device =devices[ 0]).unsqueeze( 0)\nsegments =torch .tensor(segments, device =devices[ 0]).unsqueeze( 0)\n(continues on next page)\n742 Natural Language Processing: Pretraining\n(continued from previous page)\nvalid_len =torch .tensor( len(tokens), device =devices[ 0]).unsqueeze( 0)\nencoded_X, _, _ =net(token_ids, segments, valid_len)\nreturn encoded_X\nConsider the sentence \u201ca crane is flying\u201d. Recall the input representation of BERT as dis-\ncussed in Section 15.8.4 . After inserting special tokens \u201c<cls>\u201d (used for classification)\nand \u201c<sep>\u201d (used for separation), the BERT input sequence has a length of six. Since\nzero is the index of the \u201c<cls>\u201d token, encoded_text[:, 0, :] is the BERT represen-\ntation of the entire input sentence. To evaluate the polysemy token \u201ccrane\u201d, we also print\nout the first three elements of the BERT representation of the token.", "mimetype": "text/plain", "start_char_idx": 1573782, "end_char_idx": 1577191, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7e89e79f-4550-4a1c-bd33-f56d6a21777a": {"__data__": {"id_": "7e89e79f-4550-4a1c-bd33-f56d6a21777a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "85d3c9dc-5542-40d2-af57-996131303f4c", "node_type": "1", "metadata": {}, "hash": "e59b1fb03a8a608d8262b7f8fe510158e2bc1f37228263970ae0581f4d12ea81", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "91b4f30c-c6ae-44e1-9fd5-bbe750f6a465", "node_type": "1", "metadata": {}, "hash": "9b4b47346e2d40db0397f3906a2f95d171545b2b6d723c25d4a525e461177ad8", "class_name": "RelatedNodeInfo"}}, "text": "Recall the input representation of BERT as dis-\ncussed in Section 15.8.4 . After inserting special tokens \u201c<cls>\u201d (used for classification)\nand \u201c<sep>\u201d (used for separation), the BERT input sequence has a length of six. Since\nzero is the index of the \u201c<cls>\u201d token, encoded_text[:, 0, :] is the BERT represen-\ntation of the entire input sentence. To evaluate the polysemy token \u201ccrane\u201d, we also print\nout the first three elements of the BERT representation of the token.\ntokens_a =['a','crane ','is','flying ']\nencoded_text =get_bert_encoding(net, tokens_a)\n# Tokens: '<cls>', 'a', 'crane', 'is', 'flying', '<sep>'\nencoded_text_cls =encoded_text[:, 0, :]\nencoded_text_crane =encoded_text[:, 2, :]\nencoded_text .shape, encoded_text_cls .shape, encoded_text_crane[ 0][:3]\n(torch .Size([ 1,6,128]),\ntorch .Size([ 1,128]),\ntensor([ 0.8414 ,1.4830 ,0.8226 ], device ='cuda:0 ', grad_fn =<SliceBackward0 >))\nNowconsiderasentencepair\u201cacranedrivercame\u201dand\u201chejustleft\u201d. Similarly, encoded_pair[:,\n0, :]istheencodedresultoftheentiresentencepairfromthepretrainedBERT.Notethat\nthe first three elements of the polysemy token \u201ccrane\u201d are different from those when the\ncontext is different. This supports that BERT representations are context-sensitive.\ntokens_a, tokens_b =['a','crane ','driver ','came '], [ 'he','just ','left ']\nencoded_pair =get_bert_encoding(net, tokens_a, tokens_b)\n# Tokens: '<cls>', 'a', 'crane', 'driver', 'came', '<sep>', 'he', 'just',\n# 'left', '<sep>'\nencoded_pair_cls =encoded_pair[:, 0, :]\nencoded_pair_crane =encoded_pair[:, 2, :]\nencoded_pair .shape, encoded_pair_cls .shape, encoded_pair_crane[ 0][:3]\n(torch .Size([ 1,10,128]),\ntorch .Size([ 1,128]),\ntensor([ 0.0430 ,1.6132 ,0.0437 ], device ='cuda:0 ', grad_fn =<SliceBackward0 >))\nInChapter16 ,wewillfine-tuneapretrainedBERTmodelfordownstreamnaturallanguage\nprocessing applications.\n15.10.3Summary\n\u000fThe original BERT has two versions, where the base model has 110 million parameters\nand the large model has 340 million parameters.\n743 Pretraining BERT\n240\u000fAfter pretraining BERT, we can use it to represent single text, text pairs, or any token in\nthem.\n\u000fIntheexperiment,thesametokenhasdifferentBERTrepresentationwhentheircontexts\nare different. This supports that BERT representations are context-sensitive.\n15.10.4Exercises\n1.In the experiment, we can see that the masked language modeling loss is significantly\nhigher than the next sentence prediction loss. Why?\n2.SetthemaximumlengthofaBERTinputsequencetobe512(sameastheoriginalBERT\nmodel). Use the configurations of the original BERT model such as BERT LARGE. Do\nyou encounter any error when running this section? Why?\nDiscussions240.\n16Natural Language Processing:\nApplications\nWe have seen how to represent tokens in text sequences and train their representations in\nChapter 15 . Such pretrained text representations can be fed to various models for different\ndownstream natural language processing tasks.\nIn fact, earlier chapters have already discussed some natural language processing applica-\ntionswithout pretraining , just for explaining deep learning architectures. For instance, in\nChapter9 ,wehavereliedonRNNstodesignlanguagemodelstogeneratenovella-liketext.\nInChapter10 andChapter11 , wehavealsodesignedmodelsbasedonRNNsandattention\nmechanisms for machine translation.\nHowever, this book does not intend to cover all such applications in a comprehensive man-\nner. Instead, our focus is on how to apply (deep) representation learning of languages to\naddressing natural language processing problems . Given pretrained text representations,\nthis chapter will explore two popular and representative downstream natural language pro-\ncessing tasks: sentiment analysis and natural language inference, which analyze single text\nand relationships of text pairs, respectively.\ntFig. 16.1 Pretrained text representations can be fed to various deep learning architectures for\ndifferent downstream natural language processing applications.", "mimetype": "text/plain", "start_char_idx": 1576721, "end_char_idx": 1580687, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "91b4f30c-c6ae-44e1-9fd5-bbe750f6a465": {"__data__": {"id_": "91b4f30c-c6ae-44e1-9fd5-bbe750f6a465", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7e89e79f-4550-4a1c-bd33-f56d6a21777a", "node_type": "1", "metadata": {}, "hash": "cceb8d160ce08778675775d553cd914983a7a724b4142af87a94bf96de4657b7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5ccfaa56-c362-4bf0-acae-05bdc9761d1e", "node_type": "1", "metadata": {}, "hash": "ea868c630bfdc67986a168472b41fe9d98f3fb9be455bdcdbc6c581969521c34", "class_name": "RelatedNodeInfo"}}, "text": "For instance, in\nChapter9 ,wehavereliedonRNNstodesignlanguagemodelstogeneratenovella-liketext.\nInChapter10 andChapter11 , wehavealsodesignedmodelsbasedonRNNsandattention\nmechanisms for machine translation.\nHowever, this book does not intend to cover all such applications in a comprehensive man-\nner. Instead, our focus is on how to apply (deep) representation learning of languages to\naddressing natural language processing problems . Given pretrained text representations,\nthis chapter will explore two popular and representative downstream natural language pro-\ncessing tasks: sentiment analysis and natural language inference, which analyze single text\nand relationships of text pairs, respectively.\ntFig. 16.1 Pretrained text representations can be fed to various deep learning architectures for\ndifferent downstream natural language processing applications. This chapter focuses on\nhow to design models for different downstream natural language processing applications.\nAsdepictedin Fig.16.1 ,thischapterfocusesondescribingthebasicideasofdesigningnat-\nural language processing models using different types of deep learning architectures, such\nas MLPs, CNNs, RNNs, and attention. Though it is possible to combine any pretrained\ntextrepresentationswithanyarchitectureforeitherapplicationin Fig.16.1 ,weselectafew\nrepresentative combinations. Specifically, we will explore popular architectures based on\nRNNs and CNNs for sentiment analysis. For natural language inference, we choose atten-\n744\n745 Sentiment Analysis and the Dataset\n241tion and MLPs to demonstrate how to analyze text pairs. In the end, we introduce how to\nfine-tune a pretrained BERT model for a wide range of natural language processing appli-\ncations, such as on a sequence level (single text classification and text pair classification)\nand a token level (text tagging and question answering). As a concrete empirical case, we\nwill fine-tune BERT for natural language inference.\nAs we have introduced in Section 15.8 , BERT requires minimal architecture changes for a\nwide range of natural language processing applications. However, this benefit comes at the\ncost of fine-tuning a huge number of BERT parameters for the downstream applications.\nWhen space or time is limited, those crafted models based on MLPs, CNNs, RNNs, and\nattention are more feasible. In the following, we start by the sentiment analysis application\nand illustrate the model design based on RNNs and CNNs, respectively.\n16.1SentimentAnalysisand the Dataset\nWith the proliferation of online social media and review platforms, a plethora of opinion-\nateddatahasbeenlogged,bearinggreatpotentialforsupportingdecisionmakingprocesses.\nSentiment analysis studies people\u2019s sentiments in their produced text, such as product re-\nviews, blog comments, and forum discussions. It enjoys wide applications to fields as\ndiverse as politics (e.g., analysis of public sentiments towards policies), finance (e.g., anal-\nysisofsentimentsofthemarket), andmarketing(e.g., productresearchandbrandmanage-\nment).\nSince sentiments can be categorized as discrete polarities or scales (e.g., positive and neg-\native), we can consider sentiment analysis as a text classification task, which transforms a\nvarying-length text sequence into a fixed-length text category. In this chapter, we will use\nStanford\u2019s largemoviereviewdataset241forsentimentanalysis. Itconsistsofatrainingset\nand a testing set, either containing 25000 movie reviews downloaded from IMDb. In both\ndatasets, there are equal number of \u201cpositive\u201d and \u201cnegative\u201d labels, indicating different\nsentiment polarities.\nimport os\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n16.1.1Readingthe Dataset\nFirst,downloadandextractthisIMDbreviewdatasetinthepath ../data/aclImdb .\n#@save\nd2l.DATA_HUB[ 'aclImdb ']=(d2l .DATA_URL +'aclImdb_v1.tar.gz ',\n'01ada507287d82875905620988597833ad4e0903 ')\n(continues on next page)\n746 Natural Language Processing: Applications\n(continued from previous page)\ndata_dir =d2l.download_extract( 'aclImdb ','aclImdb ')\nDownloading ../data /aclImdb_v1 .tar.gzfrom http ://d2l-data .s3-accelerate .\n\u21a9!amazonaws .com/aclImdb_v1 .tar.gz...\nNext, read the training and test datasets. Each example is a review and its label: 1 for\n\u201cpositive\u201d and 0 for \u201cnegative\u201d.\n#@save\ndef read_imdb (data_dir, is_train):\n\"\"\"Read the IMDb review dataset text sequences and labels.\"\"\"", "mimetype": "text/plain", "start_char_idx": 1579824, "end_char_idx": 1584211, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5ccfaa56-c362-4bf0-acae-05bdc9761d1e": {"__data__": {"id_": "5ccfaa56-c362-4bf0-acae-05bdc9761d1e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "91b4f30c-c6ae-44e1-9fd5-bbe750f6a465", "node_type": "1", "metadata": {}, "hash": "9b4b47346e2d40db0397f3906a2f95d171545b2b6d723c25d4a525e461177ad8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7bcdaf01-e30a-45ea-a9e5-b82d9558bf04", "node_type": "1", "metadata": {}, "hash": "99fd419f40bef2d17eab86c583d0726e2923d6acf0c0fdefa9daf013410dd9e3", "class_name": "RelatedNodeInfo"}}, "text": "#@save\nd2l.DATA_HUB[ 'aclImdb ']=(d2l .DATA_URL +'aclImdb_v1.tar.gz ',\n'01ada507287d82875905620988597833ad4e0903 ')\n(continues on next page)\n746 Natural Language Processing: Applications\n(continued from previous page)\ndata_dir =d2l.download_extract( 'aclImdb ','aclImdb ')\nDownloading ../data /aclImdb_v1 .tar.gzfrom http ://d2l-data .s3-accelerate .\n\u21a9!amazonaws .com/aclImdb_v1 .tar.gz...\nNext, read the training and test datasets. Each example is a review and its label: 1 for\n\u201cpositive\u201d and 0 for \u201cnegative\u201d.\n#@save\ndef read_imdb (data_dir, is_train):\n\"\"\"Read the IMDb review dataset text sequences and labels.\"\"\"\ndata, labels =[], []\nfor label in('pos','neg'):\nfolder_name =os.path .join(data_dir, 'train 'ifis_train else 'test ',\nlabel)\nfor file inos.listdir(folder_name):\nwith open (os.path .join(folder_name, file), 'rb')asf:\nreview =f.read() .decode( 'utf-8 ').replace( '\\n','')\ndata .append(review)\nlabels .append( 1iflabel =='pos'else 0)\nreturn data, labels\ntrain_data =read_imdb(data_dir, is_train =True )\nprint ('# trainings: ',len(train_data[ 0]))\nfor x, y inzip(train_data[ 0][:3], train_data[ 1][:3]):\nprint ('label: ', y, 'review: ', x[: 60])\n# trainings: 25000\nlabel: 1review: Zentropa has much incommon with The Third Man, another noir\nlabel: 1review: Zentropa isthe most original movie I 've seen in years. If y\nlabel: 1review: Lars Von Trier isnever backward intrying out new technique\n16.1.2Preprocessingthe Dataset\nTreating each word as a token and filtering out words that appear less than 5 times, we\ncreate a vocabulary out of the training dataset.\ntrain_tokens =d2l.tokenize(train_data[ 0], token ='word ')\nvocab =d2l.Vocab(train_tokens, min_freq =5, reserved_tokens =['<pad> '])\nAfter tokenization, let\u2019s plot the histogram of review lengths in tokens.\nd2l.set_figsize()\nd2l.plt.xlabel( '# tokens per review ')\nd2l.plt.ylabel( 'count ')\nd2l.plt.hist([ len(line) for line intrain_tokens], bins =range (0,1000 ,50));\n747 Sentiment Analysis and the Dataset\nAs we expected, the reviews have varying lengths. To process a minibatch of such reviews\nat each time, we set the length of each review to 500 with truncation and padding, which is\nsimilartothepreprocessingstepforthemachinetranslationdatasetin Section10.5 .\nnum_steps =500 # sequence length\ntrain_features =torch .tensor([d2l .truncate_pad(\nvocab[line], num_steps, vocab[ '<pad> '])for line intrain_tokens])\nprint (train_features .shape)\ntorch .Size([ 25000 ,500])\n16.1.3CreatingData Iterators\nNowwecancreatedataiterators. Ateachiteration,aminibatchofexamplesarereturned.\ntrain_iter =d2l.load_array((train_features, torch .tensor(train_data[ 1])), 64)\nfor X, y intrain_iter:\nprint ('X:', X.shape, ', y: ', y.shape)\nbreak\nprint ('# batches: ',len(train_iter))\nX: torch .Size([ 64,500]) , y: torch .Size([ 64])\n# batches: 391\n16.1.4PuttingIt All Together\nLast, we wrap up the above steps into the load_data_imdb function. It returns training\nand test data iterators and the vocabulary of the IMDb review dataset.\n#@save\ndef load_data_imdb (batch_size, num_steps =500):\n\"\"\"Return data iterators and the vocabulary of the IMDb review dataset.\"\"\"", "mimetype": "text/plain", "start_char_idx": 1583595, "end_char_idx": 1586717, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7bcdaf01-e30a-45ea-a9e5-b82d9558bf04": {"__data__": {"id_": "7bcdaf01-e30a-45ea-a9e5-b82d9558bf04", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5ccfaa56-c362-4bf0-acae-05bdc9761d1e", "node_type": "1", "metadata": {}, "hash": "ea868c630bfdc67986a168472b41fe9d98f3fb9be455bdcdbc6c581969521c34", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5c2ae046-771d-412c-bda0-3393a696a5c6", "node_type": "1", "metadata": {}, "hash": "6782541800d8fc1221bddfa6348504df6872ecbd57faa5d28c189454eb611501", "class_name": "RelatedNodeInfo"}}, "text": "Ateachiteration,aminibatchofexamplesarereturned.\ntrain_iter =d2l.load_array((train_features, torch .tensor(train_data[ 1])), 64)\nfor X, y intrain_iter:\nprint ('X:', X.shape, ', y: ', y.shape)\nbreak\nprint ('# batches: ',len(train_iter))\nX: torch .Size([ 64,500]) , y: torch .Size([ 64])\n# batches: 391\n16.1.4PuttingIt All Together\nLast, we wrap up the above steps into the load_data_imdb function. It returns training\nand test data iterators and the vocabulary of the IMDb review dataset.\n#@save\ndef load_data_imdb (batch_size, num_steps =500):\n\"\"\"Return data iterators and the vocabulary of the IMDb review dataset.\"\"\"\ndata_dir =d2l.download_extract( 'aclImdb ','aclImdb ')\ntrain_data =read_imdb(data_dir, True )\ntest_data =read_imdb(data_dir, False )\n(continues on next page)\n748 Natural Language Processing: Applications\n242\n243(continued from previous page)\ntrain_tokens =d2l.tokenize(train_data[ 0], token ='word ')\ntest_tokens =d2l.tokenize(test_data[ 0], token ='word ')\nvocab =d2l.Vocab(train_tokens, min_freq =5)\ntrain_features =torch .tensor([d2l .truncate_pad(\nvocab[line], num_steps, vocab[ '<pad> '])for line intrain_tokens])\ntest_features =torch .tensor([d2l .truncate_pad(\nvocab[line], num_steps, vocab[ '<pad> '])for line intest_tokens])\ntrain_iter =d2l.load_array((train_features, torch .tensor(train_data[ 1])),\nbatch_size)\ntest_iter =d2l.load_array((test_features, torch .tensor(test_data[ 1])),\nbatch_size,\nis_train =False )\nreturn train_iter, test_iter, vocab\n16.1.5Summary\n\u000fSentiment analysis studies people\u2019s sentiments in their produced text, which is consid-\nered as a text classification problem that transforms a varying-length text sequence\ninto a fixed-length text category.\n\u000fAfter preprocessing, we can load Stanford\u2019s large movie review dataset (IMDb review\ndataset) into data iterators with a vocabulary.\n16.1.6Exercises\n1.What hyperparameters in this section can we modify to accelerate training sentiment\nanalysis models?\n2.Can you implement a function to load the dataset of Amazon reviews242into data\niterators and labels for sentiment analysis?\nDiscussions243.\n16.2Sentiment Analysis: Using RecurrentNeural\nNetworks\nLike word similarity and analogy tasks, we can also apply pretrained word vectors to sen-\ntiment analysis. Since the IMDb review dataset in Section 16.1 is not very big, using text\nrepresentations that were pretrained on large-scale corpora may reduce overfitting of the\nmodel. As a specific example illustrated in Fig. 16.2.1 , we will represent each token using\nthe pretrained GloVe model, and feed these token representations into a multilayer bidi-\nrectional RNN to obtain the text sequence representation, which will be transformed into\nsentiment analysis outputs ( Maaset al., 2011). For the same downstream application, we\nwill consider a different architectural choice later.\n749 Sentiment Analysis: Using Recurrent Neural Networks\ntFig. 16.2.1 This section feeds pretrained GloVe to an RNN-based architecture for sentiment analysis.\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\nbatch_size =64\ntrain_iter, test_iter, vocab =d2l.load_data_imdb(batch_size)\n16.2.1RepresentingSingle Textwith RNNs\nIn text classifications tasks, such as sentiment analysis, a varying-length text sequence will\nbetransformedintofixed-lengthcategories. Inthefollowing BiRNNclass,whileeachtoken\nof a text sequence gets its individual pretrained GloVe representation via the embedding\nlayer ( self.embedding ), the entire sequence is encoded by a bidirectional RNN ( self.\nencoder ). More concretely, the hidden states (at the last layer) of the bidirectional LSTM\nat both the initial and final time steps are concatenated as the representation of the text\nsequence. This single text representation is then transformed into output categories by a\nfullyconnectedlayer( self.decoder )withtwooutputs(\u201cpositive\u201dand\u201cnegative\u201d).", "mimetype": "text/plain", "start_char_idx": 1586099, "end_char_idx": 1589973, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5c2ae046-771d-412c-bda0-3393a696a5c6": {"__data__": {"id_": "5c2ae046-771d-412c-bda0-3393a696a5c6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7bcdaf01-e30a-45ea-a9e5-b82d9558bf04", "node_type": "1", "metadata": {}, "hash": "99fd419f40bef2d17eab86c583d0726e2923d6acf0c0fdefa9daf013410dd9e3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a94527e4-4014-4265-9f2d-c50204060837", "node_type": "1", "metadata": {}, "hash": "ef07605a125ed2630d2c917a243e059e1e1a838b35c73b06a5090625cbae0c37", "class_name": "RelatedNodeInfo"}}, "text": "Inthefollowing BiRNNclass,whileeachtoken\nof a text sequence gets its individual pretrained GloVe representation via the embedding\nlayer ( self.embedding ), the entire sequence is encoded by a bidirectional RNN ( self.\nencoder ). More concretely, the hidden states (at the last layer) of the bidirectional LSTM\nat both the initial and final time steps are concatenated as the representation of the text\nsequence. This single text representation is then transformed into output categories by a\nfullyconnectedlayer( self.decoder )withtwooutputs(\u201cpositive\u201dand\u201cnegative\u201d).\nclass BiRNN (nn.Module):\ndef __init__ (self , vocab_size, embed_size, num_hiddens,\nnum_layers, **kwargs):\nsuper (BiRNN, self ).__init__ (**kwargs)\nself .embedding =nn.Embedding(vocab_size, embed_size)\n# Set `bidirectional` to True to get a bidirectional RNN\nself .encoder =nn.LSTM(embed_size, num_hiddens, num_layers =num_layers,\nbidirectional =True )\nself .decoder =nn.Linear( 4*num_hiddens, 2)\ndef forward (self , inputs):\n# The shape of `inputs` is (batch size, no. of time steps). Because\n# LSTM requires its input's first dimension to be the temporal\n# dimension, the input is transposed before obtaining token\n# representations. The output shape is (no. of time steps, batch size,\n# word vector dimension)\nembeddings =self .embedding(inputs .T)\nself .encoder .flatten_parameters()\n# Returns hidden states of the last hidden layer at different time\n(continues on next page)\n750 Natural Language Processing: Applications\n(continued from previous page)\n# steps. The shape of `outputs` is (no. of time steps, batch size,\n# 2 * no. of hidden units)\noutputs, _ =self .encoder(embeddings)\n# Concatenate the hidden states at the initial and final time steps as\n# the input of the fully connected layer. Its shape is (batch size,\n# 4 * no. of hidden units)\nencoding =torch .cat((outputs[ 0], outputs[ -1]), dim =1)\nouts =self .decoder(encoding)\nreturn outs\nLet\u2019s construct a bidirectional RNN with two hidden layers to represent single text for sen-\ntiment analysis.\nembed_size, num_hiddens, num_layers, devices =100,100,2, d2l .try_all_gpus()\nnet =BiRNN( len(vocab), embed_size, num_hiddens, num_layers)\ndef init_weights (module):\niftype (module) ==nn.Linear:\nnn.init .xavier_uniform_(module .weight)\niftype (module) ==nn.LSTM:\nfor param inmodule ._flat_weights_names:\nif\"weight \"inparam:\nnn.init .xavier_uniform_(module ._parameters[param])\nnet.apply(init_weights);\n16.2.2LoadingPretrainedWordVectors\nBelow we load the pretrained 100-dimensional (needs to be consistent with embed_size )\nGloVe embeddings for tokens in the vocabulary.\nglove_embedding =d2l.TokenEmbedding( 'glove.6b.100d ')\nPrint the shape of the vectors for all the tokens in the vocabulary.\nembeds =glove_embedding[vocab .idx_to_token]\nembeds .shape\ntorch .Size([ 49346 ,100])\nWeusethesepretrainedwordvectorstorepresenttokensinthereviewsandwillnotupdate\nthese vectors during training.\nnet.embedding .weight .data .copy_(embeds)\nnet.embedding .weight .requires_grad =False\n16.2.3Trainingand Evaluatingthe Model\n751 Sentiment Analysis: Using Recurrent Neural Networks\nNow we can train the bidirectional RNN for sentiment analysis.\nlr, num_epochs =0.01 ,5\ntrainer =torch .optim .Adam(net .parameters(), lr =lr)\nloss =nn.CrossEntropyLoss(reduction =\"none \")\nd2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)\nloss 0.277 , train acc 0.884 , test acc 0.861\n2608.4 examples /sec on [device( type ='cuda ', index =0), device( type ='cuda ',\u2423\n\u21a9!index =1)]\nWedefinethefollowingfunctiontopredictthesentimentofatextsequenceusingthetrained\nmodel net.\n#@save\ndef predict_sentiment (net, vocab, sequence):\n\"\"\"Predict the sentiment of a text sequence.\"\"\"", "mimetype": "text/plain", "start_char_idx": 1589406, "end_char_idx": 1593107, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a94527e4-4014-4265-9f2d-c50204060837": {"__data__": {"id_": "a94527e4-4014-4265-9f2d-c50204060837", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5c2ae046-771d-412c-bda0-3393a696a5c6", "node_type": "1", "metadata": {}, "hash": "6782541800d8fc1221bddfa6348504df6872ecbd57faa5d28c189454eb611501", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9a8ef49c-f904-4312-976d-e2b295402e11", "node_type": "1", "metadata": {}, "hash": "7771a14a21a2f883b54cc13a81464c9feaeaf5ae4d47e338ff62dbe1b8378c48", "class_name": "RelatedNodeInfo"}}, "text": "lr, num_epochs =0.01 ,5\ntrainer =torch .optim .Adam(net .parameters(), lr =lr)\nloss =nn.CrossEntropyLoss(reduction =\"none \")\nd2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)\nloss 0.277 , train acc 0.884 , test acc 0.861\n2608.4 examples /sec on [device( type ='cuda ', index =0), device( type ='cuda ',\u2423\n\u21a9!index =1)]\nWedefinethefollowingfunctiontopredictthesentimentofatextsequenceusingthetrained\nmodel net.\n#@save\ndef predict_sentiment (net, vocab, sequence):\n\"\"\"Predict the sentiment of a text sequence.\"\"\"\nsequence =torch .tensor(vocab[sequence .split()], device =d2l.try_gpu())\nlabel =torch .argmax(net(sequence .reshape( 1,-1)), dim =1)\nreturn 'positive 'iflabel ==1else 'negative '\nFinally,let\u2019susethetrainedmodeltopredictthesentimentfortwosimplesentences.\npredict_sentiment(net, vocab, 'this movie is so great ')\n'positive '\npredict_sentiment(net, vocab, 'this movie is so bad ')\n'negative '\n16.2.4Summary\n\u000fPretrained word vectors can represent individual tokens in a text sequence.\n752 Natural Language Processing: Applications\n244\u000fBidirectional RNNs can represent a text sequence, such as via the concatenation of its\nhidden states at the initial and final time steps. This single text representation can be\ntransformed into categories using a fully connected layer.\n16.2.5Exercises\n1.Increase the number of epochs. Can you improve the training and testing accuracies?\nHow about tuning other hyperparameters?\n2.Use larger pretrained word vectors, such as 300-dimensional GloVe embeddings. Does\nit improve classification accuracy?\n3.Can we improve the classification accuracy by using the spaCy tokenization? You need\nto install spaCy ( pip install spacy ) and install the English package ( python -m\nspacy download en ). In the code, first, import spaCy ( import spacy ). Then, load\nthe spaCy English package ( spacy_en = spacy.load('en') ). Finally, define the\nfunction def tokenizer(text): return [tok.text for tok in spacy_en.\ntokenizer(text)] and replace the original tokenizer function. Note the different\nforms of phrase tokens in GloVe and spaCy. For example, the phrase token \u201cnew york\u201d\ntakes the form of \u201cnew-york\u201d in GloVe and the form of \u201cnew york\u201d after the spaCy\ntokenization.\nDiscussions244.\n16.3SentimentAnalysis: Using Convolutional\nNeuralNetworks\nInChapter7 , weinvestigatedmechanismsforprocessingtwo-dimensionalimagedatawith\ntwo-dimensionalCNNs,whichwereappliedtolocalfeaturessuchasadjacentpixels. Though\noriginally designed for computer vision, CNNs are also widely used for natural language\nprocessing. Simplyput, justthinkofanytextsequenceasaone-dimensionalimage. Inthis\nway, one-dimensional CNNs can process local features such as \ud835\udc5b-grams in text.\nIn this section, we will use the textCNN model to demonstrate how to design a CNN ar-\nchitecture for representing single text ( Kim, 2014 ). Compared with Fig. 16.2.1 that uses\nan RNN architecture with GloVe pretraining for sentiment analysis, the only difference in\nFig. 16.3.1 lies in the choice of the architecture.\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\nbatch_size =64\ntrain_iter, test_iter, vocab =d2l.load_data_imdb(batch_size)\n753 Sentiment Analysis: Using Convolutional Neural Networks\ntFig. 16.3.1 This section feeds pretrained GloVe to a CNN-based architecture for sentiment analysis.\n16.3.1One-DimensionalConvolutions\nBefore introducing the model, let\u2019s see how a one-dimensional convolution works. Bear\nin mind that it is just a special case of a two-dimensional convolution based on the cross-\ncorrelation operation.\ntFig. 16.3.2 One-dimensional cross-correlation operation. The shaded portions are the \ufb01rst output\nelement as well as the input and kernel tensor elements used for the output computation:\n0\u00021\u00b81\u00022=2.\nAs shown in Fig. 16.3.2 , in the one-dimensional case, the convolution window slides from\nleft to right across the input tensor.", "mimetype": "text/plain", "start_char_idx": 1592570, "end_char_idx": 1596457, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9a8ef49c-f904-4312-976d-e2b295402e11": {"__data__": {"id_": "9a8ef49c-f904-4312-976d-e2b295402e11", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a94527e4-4014-4265-9f2d-c50204060837", "node_type": "1", "metadata": {}, "hash": "ef07605a125ed2630d2c917a243e059e1e1a838b35c73b06a5090625cbae0c37", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2f7d3508-4e64-4f90-88ba-a547657a7fb3", "node_type": "1", "metadata": {}, "hash": "b984b5dd35025216f179c1f227d8e7d94c659d724919db2c34d9ed0afd24e0c1", "class_name": "RelatedNodeInfo"}}, "text": "16.3.1 This section feeds pretrained GloVe to a CNN-based architecture for sentiment analysis.\n16.3.1One-DimensionalConvolutions\nBefore introducing the model, let\u2019s see how a one-dimensional convolution works. Bear\nin mind that it is just a special case of a two-dimensional convolution based on the cross-\ncorrelation operation.\ntFig. 16.3.2 One-dimensional cross-correlation operation. The shaded portions are the \ufb01rst output\nelement as well as the input and kernel tensor elements used for the output computation:\n0\u00021\u00b81\u00022=2.\nAs shown in Fig. 16.3.2 , in the one-dimensional case, the convolution window slides from\nleft to right across the input tensor. During sliding, the input subtensor (e.g., 0and 1in\nFig.16.3.2 )containedintheconvolutionwindowatacertainpositionandthekerneltensor\n(e.g., 1and2inFig. 16.3.2 ) are multiplied elementwise. The sum of these multiplications\ngives the single scalar value (e.g., 0\u00021\u00b81\u00022=2inFig. 16.3.2 ) at the corresponding\nposition of the output tensor.\nWeimplementone-dimensionalcross-correlationinthefollowing corr1dfunction. Given\nan input tensor Xand a kernel tensor K, it returns the output tensor Y.\ndef corr1d (X, K):\nw=K.shape[ 0]\nY=torch .zeros((X .shape[ 0]-w+1))\nfor iinrange (Y.shape[ 0]):\nY[i] =(X[i: i +w]*K).sum()\nreturn Y\nWe can construct the input tensor Xand the kernel tensor KfromFig. 16.3.2 to validate the\noutput of the above one-dimensional cross-correlation implementation.\nX, K =torch .tensor([ 0,1,2,3,4,5,6]), torch .tensor([ 1,2])\ncorr1d(X, K)\n754 Natural Language Processing: Applications\ntensor([ 2.,5.,8.,11.,14.,17.])\nForanyone-dimensionalinputwithmultiplechannels,theconvolutionkernelneedstohave\nthe same number of input channels. Then for each channel, perform a cross-correlation\noperation on the one-dimensional tensor of the input and the one-dimensional tensor of\nthe convolution kernel, summing the results over all the channels to produce the one-\ndimensional output tensor. Fig. 16.3.3 shows a one-dimensional cross-correlation oper-\nation with 3 input channels.\ntFig. 16.3.3 One-dimensional cross-correlation operation with 3 input channels. The shaded portions\nare the \ufb01rst output element as well as the input and kernel tensor elements used for the\noutput computation: 0 \u00021\u00b81\u00022\u00b81\u00023\u00b82\u00024\u00b82\u0002\u00b9\u00001\u00ba\u00b83\u0002\u00b9\u00003\u00ba=2.\nWecanimplementtheone-dimensionalcross-correlationoperationformultipleinputchan-\nnels and validate the results in Fig. 16.3.3 .\ndef corr1d_multi_in (X, K):\n# First, iterate through the 0th dimension (channel dimension) of `X` and\n# `K`. Then, add them together\nreturn sum(corr1d(x, k) for x, k inzip(X, K))\nX=torch .tensor([[ 0,1,2,3,4,5,6],\n[1,2,3,4,5,6,7],\n[2,3,4,5,6,7,8]])\nK=torch .tensor([[ 1,2], [ 3,4], [ -1,-3]])\ncorr1d_multi_in(X, K)\ntensor([ 2.,8.,14.,20.,26.,32.])\nNote that multi-input-channel one-dimensional cross-correlations are equivalent to single-\ninput-channel two-dimensional cross-correlations. To illustrate, an equivalent form of the\nmulti-input-channel one-dimensional cross-correlation in Fig. 16.3.3 is the single-input-\nchannel two-dimensional cross-correlation in Fig. 16.3.4 , where the height of the convolu-\ntion kernel has to be the same as that of the input tensor.\nBoth the outputs in Fig. 16.3.2 andFig. 16.3.3 have only one channel. Same as two-\ndimensional convolutions with multiple output channels described in Section 7.4.2 , we\ncan also specify multiple output channels for one-dimensional convolutions.", "mimetype": "text/plain", "start_char_idx": 1595801, "end_char_idx": 1599230, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2f7d3508-4e64-4f90-88ba-a547657a7fb3": {"__data__": {"id_": "2f7d3508-4e64-4f90-88ba-a547657a7fb3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9a8ef49c-f904-4312-976d-e2b295402e11", "node_type": "1", "metadata": {}, "hash": "7771a14a21a2f883b54cc13a81464c9feaeaf5ae4d47e338ff62dbe1b8378c48", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9aea6539-0d3c-474f-89ca-f26119fdefae", "node_type": "1", "metadata": {}, "hash": "d4e19c6542905958b14afa3de031f5fad48c5f152d1763e2c3181ba44aa7c3dd", "class_name": "RelatedNodeInfo"}}, "text": "Note that multi-input-channel one-dimensional cross-correlations are equivalent to single-\ninput-channel two-dimensional cross-correlations. To illustrate, an equivalent form of the\nmulti-input-channel one-dimensional cross-correlation in Fig. 16.3.3 is the single-input-\nchannel two-dimensional cross-correlation in Fig. 16.3.4 , where the height of the convolu-\ntion kernel has to be the same as that of the input tensor.\nBoth the outputs in Fig. 16.3.2 andFig. 16.3.3 have only one channel. Same as two-\ndimensional convolutions with multiple output channels described in Section 7.4.2 , we\ncan also specify multiple output channels for one-dimensional convolutions.\n16.3.2Max-Over-Time Pooling\nSimilarly, we can use pooling to extract the highest value from sequence representations as\nthe most important feature across time steps. The max-over-timepooling used in textCNN\n755 Sentiment Analysis: Using Convolutional Neural Networks\ntFig. 16.3.4 Two-dimensional cross-correlation operation with a single input channel. The shaded\nportions are the \ufb01rst output element as well as the input and kernel tensor elements used\nfor the output computation: 2 \u0002\u00b9\u00001\u00ba\u00b83\u0002\u00b9\u00003\u00ba\u00b81\u00023\u00b82\u00024\u00b80\u00021\u00b81\u00022=2.\nworks like the one-dimensional global max-pooling ( Collobert et al., 2011). For a multi-\nchannel input where each channel stores values at different time steps, the output at each\nchannelisthemaximumvalueforthatchannel. Notethatthemax-over-timepoolingallows\ndifferent numbers of time steps at different channels.\n16.3.3The textCNNModel\nUsing the one-dimensional convolution and max-over-time pooling, the textCNN model\ntakes individual pretrained token representations as input, then obtains and transforms se-\nquence representations for the downstream application.\nFor a single text sequence with \ud835\udc5btokens represented by \ud835\udc51-dimensional vectors, the width,\nheight, and number of channels of the input tensor are \ud835\udc5b,1, and\ud835\udc51, respectively. The\ntextCNN model transforms the input into the output as follows:\n1.Define multiple one-dimensional convolution kernels and perform convolution opera-\ntions separately on the inputs. Convolution kernels with different widths may capture\nlocal features among different numbers of adjacent tokens.\n2.Perform max-over-time pooling on all the output channels, and then concatenate all the\nscalar pooling outputs as a vector.\n3.Transform the concatenated vector into the output categories using the fully connected\nlayer. Dropout can be used for reducing overfitting.\nFig.16.3.5 illustratesthemodelarchitectureoftextCNNwithaconcreteexample. Theinput\nis a sentence with 11 tokens, where each token is represented by a 6-dimensional vectors.\nSo we have a 6-channel input with width 11. Define two one-dimensional convolution\nkernelsofwidths2and4,with4and5outputchannels,respectively. Theyproduce4output\nchannelswithwidth 11\u00002\u00b81=10and5outputchannelswithwidth 11\u00004\u00b81=8. Despite\ndifferent widths of these 9 channels, the max-over-time pooling gives a concatenated 9-\ndimensional vector, which is finally transformed into a 2-dimensional output vector for\nbinary sentiment predictions.\nDefiningthe Model\nWe implement the textCNN model in the following class. Compared with the bidirectional\nRNN model in Section 16.2 , besides replacing recurrent layers with convolutional layers,\n756 Natural Language Processing: Applications\ntFig. 16.3.5 The model architecture of textCNN.\nwe also use two embedding layers: one with trainable weights and the other with fixed\nweights.", "mimetype": "text/plain", "start_char_idx": 1598561, "end_char_idx": 1602042, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9aea6539-0d3c-474f-89ca-f26119fdefae": {"__data__": {"id_": "9aea6539-0d3c-474f-89ca-f26119fdefae", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2f7d3508-4e64-4f90-88ba-a547657a7fb3", "node_type": "1", "metadata": {}, "hash": "b984b5dd35025216f179c1f227d8e7d94c659d724919db2c34d9ed0afd24e0c1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e96294ca-271a-4eb2-b996-1033f856b4af", "node_type": "1", "metadata": {}, "hash": "3bc9c54572ad3b1263b67a39c40444830e6f063d4cec22717b5482c99db98f35", "class_name": "RelatedNodeInfo"}}, "text": "Define two one-dimensional convolution\nkernelsofwidths2and4,with4and5outputchannels,respectively. Theyproduce4output\nchannelswithwidth 11\u00002\u00b81=10and5outputchannelswithwidth 11\u00004\u00b81=8. Despite\ndifferent widths of these 9 channels, the max-over-time pooling gives a concatenated 9-\ndimensional vector, which is finally transformed into a 2-dimensional output vector for\nbinary sentiment predictions.\nDefiningthe Model\nWe implement the textCNN model in the following class. Compared with the bidirectional\nRNN model in Section 16.2 , besides replacing recurrent layers with convolutional layers,\n756 Natural Language Processing: Applications\ntFig. 16.3.5 The model architecture of textCNN.\nwe also use two embedding layers: one with trainable weights and the other with fixed\nweights.\nclass TextCNN (nn.Module):\ndef __init__ (self , vocab_size, embed_size, kernel_sizes, num_channels,\n**kwargs):\nsuper (TextCNN, self ).__init__ (**kwargs)\nself .embedding =nn.Embedding(vocab_size, embed_size)\n# The embedding layer not to be trained\nself .constant_embedding =nn.Embedding(vocab_size, embed_size)\nself .dropout =nn.Dropout( 0.5)\nself .decoder =nn.Linear( sum(num_channels), 2)\n# The max-over-time pooling layer has no parameters, so this instance\n# can be shared\nself .pool =nn.AdaptiveAvgPool1d( 1)\nself .relu =nn.ReLU()\n# Create multiple one-dimensional convolutional layers\nself .convs =nn.ModuleList()\nfor c, k inzip(num_channels, kernel_sizes):\nself .convs .append(nn .Conv1d( 2*embed_size, c, k))\ndef forward (self , inputs):\n# Concatenate two embedding layer outputs with shape (batch size, no.\n# of tokens, token vector dimension) along vectors\nembeddings =torch .cat((\nself .embedding(inputs), self .constant_embedding(inputs)), dim =2)\n# Per the input format of one-dimensional convolutional layers,\n# rearrange the tensor so that the second dimension stores channels\nembeddings =embeddings .permute( 0,2,1)\n# For each one-dimensional convolutional layer, after max-over-time\n# pooling, a tensor of shape (batch size, no. of channels, 1) is\n# obtained. Remove the last dimension and concatenate along channels\nencoding =torch .cat([\n(continues on next page)\n757 Sentiment Analysis: Using Convolutional Neural Networks\n(continued from previous page)\ntorch .squeeze( self .relu( self .pool(conv(embeddings))), dim =-1)\nfor conv inself .convs], dim =1)\noutputs =self .decoder( self .dropout(encoding))\nreturn outputs\nLet\u2019s create a textCNN instance. It has 3 convolutional layers with kernel widths of 3, 4,\nand 5, all with 100 output channels.\nembed_size, kernel_sizes, nums_channels =100, [3,4,5], [ 100,100,100]\ndevices =d2l.try_all_gpus()\nnet =TextCNN( len(vocab), embed_size, kernel_sizes, nums_channels)\ndef init_weights (module):\niftype (module) in(nn.Linear, nn .Conv1d):\nnn.init .xavier_uniform_(module .weight)\nnet.apply(init_weights);\nLoadingPretrainedWordVectors\nSame as Section 16.2 , we load pretrained 100-dimensional GloVe embeddings as the ini-\ntialized token representations. These token representations (embedding weights) will be\ntrained in embedding and fixed in constant_embedding .\nglove_embedding =d2l.TokenEmbedding( 'glove.6b.100d ')\nembeds =glove_embedding[vocab .idx_to_token]\nnet.embedding .weight .data .copy_(embeds)\nnet.constant_embedding .weight .data .copy_(embeds)\nnet.constant_embedding .weight .requires_grad =False\nTrainingand Evaluatingthe Model\nNow we can train the textCNN model for sentiment analysis.\nlr, num_epochs =0.001 ,5\ntrainer =torch .optim .Adam(net .parameters(), lr =lr)\nloss =nn.CrossEntropyLoss(reduction =\"none \")\nd2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)\nloss 0.066 , train acc 0.979 , test acc 0.868\n4354.2 examples /sec on [device( type ='cuda ', index =0), device( type ='cuda ',\u2423\n\u21a9!index =1)]\nBelow we use the trained model to predict the sentiment for two simple sentences.", "mimetype": "text/plain", "start_char_idx": 1601263, "end_char_idx": 1605136, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e96294ca-271a-4eb2-b996-1033f856b4af": {"__data__": {"id_": "e96294ca-271a-4eb2-b996-1033f856b4af", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9aea6539-0d3c-474f-89ca-f26119fdefae", "node_type": "1", "metadata": {}, "hash": "d4e19c6542905958b14afa3de031f5fad48c5f152d1763e2c3181ba44aa7c3dd", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "aff623f3-f1f2-4b01-b89e-b0252c199668", "node_type": "1", "metadata": {}, "hash": "74e4419a3f2e02a78b011210ca78a9df9767ac24e809d90310fa4d220e520431", "class_name": "RelatedNodeInfo"}}, "text": "lr, num_epochs =0.001 ,5\ntrainer =torch .optim .Adam(net .parameters(), lr =lr)\nloss =nn.CrossEntropyLoss(reduction =\"none \")\nd2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)\nloss 0.066 , train acc 0.979 , test acc 0.868\n4354.2 examples /sec on [device( type ='cuda ', index =0), device( type ='cuda ',\u2423\n\u21a9!index =1)]\nBelow we use the trained model to predict the sentiment for two simple sentences.\nd2l.predict_sentiment(net, vocab, 'this movie is so great ')\n758 Natural Language Processing: Applications\n245'positive '\nd2l.predict_sentiment(net, vocab, 'this movie is so bad ')\n'negative '\n16.3.4Summary\n\u000fOne-dimensional CNNs can process local features such as \ud835\udc5b-grams in text.\n\u000fMulti-input-channel one-dimensional cross-correlations are equivalent to single-input-\nchannel two-dimensional cross-correlations.\n\u000fThe max-over-time pooling allows different numbers of time steps at different channels.\n\u000fThetextCNNmodeltransformsindividualtokenrepresentationsintodownstreamappli-\ncationoutputsusingone-dimensionalconvolutionallayersandmax-over-timepooling\nlayers.\n16.3.5Exercises\n1.Tune hyperparameters and compare the two architectures for sentiment analysis in Sec-\ntion 16.2 and in this section, such as in classification accuracy and computational effi-\nciency.\n2.Can you further improve the classification accuracy of the model by using the methods\nintroduced in the exercises of Section 16.2 ?\n3.Add positional encoding in the input representations. Does it improve the classification\naccuracy?\nDiscussions245.\n759 Natural Language Inference and the Dataset\n16.4Natural LanguageInferenceand the Dataset\nInSection 16.1 , we discussed the problem of sentiment analysis. This task aims to clas-\nsify a single text sequence into predefined categories, such as a set of sentiment polarities.\nHowever, when there is a need to decide whether one sentence can be inferred form an-\nother, or eliminate redundancy by identifying sentences that are semantically equivalent,\nknowing how to classify one text sequence is insufficient. Instead, we need to be able to\nreason over pairs of text sequences.\n16.4.1NaturalLanguageInference\nNatural language inference studies whether a hypothesis can be inferred from a premise,\nwhere both are a text sequence. In other words, natural language inference determines the\nlogical relationship between a pair of text sequences. Such relationships usually fall into\nthree types:\n\u000fEntailment : the hypothesis can be inferred from the premise.\n\u000fContradiction : the negation of the hypothesis can be inferred from the premise.\n\u000fNeutral: all the other cases.\nNatural language inference is also known as the recognizing textual entailment task. For\nexample, the following pair will be labeled as entailment because \u201cshowing affection\u201d in\nthe hypothesis can be inferred from \u201chugging one another\u201d in the premise.\nPremise: Two women are hugging each other.\nHypothesis: Two women are showing affection.\nThe following is an example of contradiction as \u201crunning the coding example\u201d indicates\n\u201cnot sleeping\u201d rather than \u201csleeping\u201d.\nPremise: A man is running the coding example from Dive into Deep Learning.\nHypothesis: The man is sleeping.\nThe third example shows a neutrality relationship because neither \u201cfamous\u201d nor \u201cnot fa-\nmous\u201d can be inferred from the fact that \u201care performing for us\u201d.\nPremise: The musicians are performing for us.\nHypothesis: The musicians are famous.\nNatural language inference has been a central topic for understanding natural language.\nIt enjoys wide applications ranging from information retrieval to open-domain question\nanswering. Tostudythisproblem,wewillbeginbyinvestigatingapopularnaturallanguage\ninference benchmark dataset.\n760 Natural Language Processing: Applications\n16.4.2The StanfordNaturalLanguageInference(SNLI) Dataset\nStanfordNaturalLanguageInference(SNLI)Corpusisacollectionofover500000labeled\nEnglish sentence pairs ( Bowman etal., 2015). We download and store the extracted SNLI\ndataset in the path ../data/snli_1.0 .", "mimetype": "text/plain", "start_char_idx": 1604708, "end_char_idx": 1608723, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "aff623f3-f1f2-4b01-b89e-b0252c199668": {"__data__": {"id_": "aff623f3-f1f2-4b01-b89e-b0252c199668", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e96294ca-271a-4eb2-b996-1033f856b4af", "node_type": "1", "metadata": {}, "hash": "3bc9c54572ad3b1263b67a39c40444830e6f063d4cec22717b5482c99db98f35", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d95a7860-9d26-4dc2-a297-cf7368e8d370", "node_type": "1", "metadata": {}, "hash": "e791ffb08bab5f4b493d23bcd55ff9e8fd09b9d6bdd4fb8eb3fd8e4984cf0cdc", "class_name": "RelatedNodeInfo"}}, "text": "The third example shows a neutrality relationship because neither \u201cfamous\u201d nor \u201cnot fa-\nmous\u201d can be inferred from the fact that \u201care performing for us\u201d.\nPremise: The musicians are performing for us.\nHypothesis: The musicians are famous.\nNatural language inference has been a central topic for understanding natural language.\nIt enjoys wide applications ranging from information retrieval to open-domain question\nanswering. Tostudythisproblem,wewillbeginbyinvestigatingapopularnaturallanguage\ninference benchmark dataset.\n760 Natural Language Processing: Applications\n16.4.2The StanfordNaturalLanguageInference(SNLI) Dataset\nStanfordNaturalLanguageInference(SNLI)Corpusisacollectionofover500000labeled\nEnglish sentence pairs ( Bowman etal., 2015). We download and store the extracted SNLI\ndataset in the path ../data/snli_1.0 .\nimport os\nimport re\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n#@save\nd2l.DATA_HUB[ 'SNLI ']=(\n'https://nlp.stanford.edu/projects/snli/snli_1.0.zip ',\n'9fcde07509c7e87ec61c640c1b2753d9041758e4 ')\ndata_dir =d2l.download_extract( 'SNLI ')\nReadingthe Dataset\nThe original SNLI dataset contains much richer information than what we really need in\nour experiments. Thus, we define a function read_snli to only extract part of the dataset,\nthen return lists of premises, hypotheses, and their labels.\n#@save\ndef read_snli (data_dir, is_train):\n\"\"\"Read the SNLI dataset into premises, hypotheses, and labels.\"\"\"\ndef extract_text (s):\n# Remove information that will not be used by us\ns=re.sub( '\\\\(','', s)\ns=re.sub( '\\\\)','', s)\n# Substitute two or more consecutive whitespace with space\ns=re.sub( '\\\\s{2,}','', s)\nreturn s.strip()\nlabel_set ={'entailment ':0,'contradiction ':1,'neutral ':2}\nfile_name =os.path .join(data_dir, 'snli_1.0_train.txt '\nifis_train else 'snli_1.0_test.txt ')\nwith open (file_name, 'r')asf:\nrows =[row .split( '\\t')for row inf.readlines()[ 1:]]\npremises =[extract_text(row[ 1])for row inrows ifrow[ 0]inlabel_set]\nhypotheses =[extract_text(row[ 2])for row inrows ifrow[ 0]inlabel_set]\nlabels =[label_set[row[ 0]]for row inrows ifrow[ 0]inlabel_set]\nreturn premises, hypotheses, labels\nNow let\u2019s print the first 3 pairs of premise and hypothesis, as well as their labels (\u201c0\u201d, \u201c1\u201d,\nand \u201c2\u201d correspond to \u201centailment\u201d, \u201ccontradiction\u201d, and \u201cneutral\u201d, respectively ).\ntrain_data =read_snli(data_dir, is_train =True )\nfor x0, x1, y inzip(train_data[ 0][:3], train_data[ 1][:3], train_data[ 2][:3]):\nprint ('premise: ', x0)\n(continues on next page)\n761 Natural Language Inference and the Dataset\n(continued from previous page)\nprint ('hypothesis: ', x1)\nprint ('label: ', y)\npremise: A person on a horse jumps over a broken down airplane .\nhypothesis: A person istraining his horse for a competition .\nlabel: 2\npremise: A person on a horse jumps over a broken down airplane .\nhypothesis: A person isat a diner , ordering an omelette .\nlabel: 1\npremise: A person on a horse jumps over a broken down airplane .\nhypothesis: A person isoutdoors , on a horse .\nlabel: 0\nThe training set has about 550000 pairs, and the testing set has about 10000 pairs. The fol-\nlowingshowsthatthethreelabels\u201centailment\u201d,\u201ccontradiction\u201d,and\u201cneutral\u201darebalanced\nin both the training set and the testing set.\ntest_data =read_snli(data_dir, is_train =False )\nfor data in[train_data, test_data]:\nprint ([[row for row indata[ 2]].count(i) for iinrange (3)])\n[183416 ,183187 ,182764 ]\n[3368 ,3237 ,3219 ]\nDefininga Class forLoading the Dataset\nBelow we define a class for loading the SNLI dataset by inheriting from the Dataset class\nin Gluon.", "mimetype": "text/plain", "start_char_idx": 1607896, "end_char_idx": 1611475, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d95a7860-9d26-4dc2-a297-cf7368e8d370": {"__data__": {"id_": "d95a7860-9d26-4dc2-a297-cf7368e8d370", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "aff623f3-f1f2-4b01-b89e-b0252c199668", "node_type": "1", "metadata": {}, "hash": "74e4419a3f2e02a78b011210ca78a9df9767ac24e809d90310fa4d220e520431", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9b20ef12-ea90-4f6d-898f-f090f2d683ec", "node_type": "1", "metadata": {}, "hash": "067af8ef76d00ba4cef19467f4164855e26f2cad75994b9dd38b846793bd5d28", "class_name": "RelatedNodeInfo"}}, "text": "label: 1\npremise: A person on a horse jumps over a broken down airplane .\nhypothesis: A person isoutdoors , on a horse .\nlabel: 0\nThe training set has about 550000 pairs, and the testing set has about 10000 pairs. The fol-\nlowingshowsthatthethreelabels\u201centailment\u201d,\u201ccontradiction\u201d,and\u201cneutral\u201darebalanced\nin both the training set and the testing set.\ntest_data =read_snli(data_dir, is_train =False )\nfor data in[train_data, test_data]:\nprint ([[row for row indata[ 2]].count(i) for iinrange (3)])\n[183416 ,183187 ,182764 ]\n[3368 ,3237 ,3219 ]\nDefininga Class forLoading the Dataset\nBelow we define a class for loading the SNLI dataset by inheriting from the Dataset class\nin Gluon. The argument num_steps in the class constructor specifies the length of a text\nsequence so that each minibatch of sequences will have the same shape. In other words,\ntokens after the first num_steps ones in longer sequence are trimmed, while special tokens\n\u201c<pad>\u201d will be appended to shorter sequences until their length becomes num_steps . By\nimplementingthe __getitem__ function,wecanarbitrarilyaccessthepremise,hypothesis,\nand label with the index idx.\n#@save\nclass SNLIDataset (torch .utils .data .Dataset):\n\"\"\"A customized dataset to load the SNLI dataset.\"\"\"\ndef __init__ (self , dataset, num_steps, vocab =None ):\nself .num_steps =num_steps\nall_premise_tokens =d2l.tokenize(dataset[ 0])\nall_hypothesis_tokens =d2l.tokenize(dataset[ 1])\nifvocab isNone :\nself .vocab =d2l.Vocab(all_premise_tokens +all_hypothesis_tokens,\nmin_freq =5, reserved_tokens =['<pad> '])\nelse :\nself .vocab =vocab\nself .premises =self ._pad(all_premise_tokens)\n(continues on next page)\n762 Natural Language Processing: Applications\n(continued from previous page)\nself .hypotheses =self ._pad(all_hypothesis_tokens)\nself .labels =torch .tensor(dataset[ 2])\nprint ('read '+str(len(self .premises)) +'examples ')\ndef _pad (self , lines):\nreturn torch .tensor([d2l .truncate_pad(\nself .vocab[line], self .num_steps, self .vocab[ '<pad> '])\nfor line inlines])\ndef __getitem__ (self , idx):\nreturn (self .premises[idx], self .hypotheses[idx]), self .labels[idx]\ndef __len__ (self ):\nreturn len(self .premises)\nPuttingIt All Together\nNow we can invoke the read_snli function and the SNLIDataset class to download the\nSNLI dataset and return DataLoader instances for both training and testing sets, together\nwith the vocabulary of the training set. It is noteworthy that we must use the vocabulary\nconstructed from the training set as that of the testing set. As a result, any new token from\nthe testing set will be unknown to the model trained on the training set.\n#@save\ndef load_data_snli (batch_size, num_steps =50):\n\"\"\"Download the SNLI dataset and return data iterators and vocabulary.\"\"\"\nnum_workers =d2l.get_dataloader_workers()\ndata_dir =d2l.download_extract( 'SNLI ')\ntrain_data =read_snli(data_dir, True )\ntest_data =read_snli(data_dir, False )\ntrain_set =SNLIDataset(train_data, num_steps)\ntest_set =SNLIDataset(test_data, num_steps, train_set .vocab)\ntrain_iter =torch .utils .data .DataLoader(train_set, batch_size,\nshuffle =True ,\nnum_workers =num_workers)\ntest_iter =torch .utils .data .DataLoader(test_set, batch_size,\nshuffle =False ,\nnum_workers =num_workers)\nreturn train_iter, test_iter, train_set .vocab\nHerewesetthebatchsizeto128andsequencelengthto50,andinvokethe load_data_snli\nfunctiontogetthedataiteratorsandvocabulary. Thenweprintthevocabularysize.\ntrain_iter, test_iter, vocab =load_data_snli( 128,50)\nlen(vocab)\nread 549367 examples\nread 9824 examples\n763 Natural Language Inference: Using Attention\n24618678\nNow we print the shape of the first minibatch. Contrary to sentiment analysis, we have two\ninputs X[0]andX[1]representing pairs of premises and hypotheses.", "mimetype": "text/plain", "start_char_idx": 1610794, "end_char_idx": 1614542, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9b20ef12-ea90-4f6d-898f-f090f2d683ec": {"__data__": {"id_": "9b20ef12-ea90-4f6d-898f-f090f2d683ec", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d95a7860-9d26-4dc2-a297-cf7368e8d370", "node_type": "1", "metadata": {}, "hash": "e791ffb08bab5f4b493d23bcd55ff9e8fd09b9d6bdd4fb8eb3fd8e4984cf0cdc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d6e2a5f2-13e6-4a45-a193-9680a8b3f024", "node_type": "1", "metadata": {}, "hash": "c5d74bbca97ea58a4d550aa854420ce5113621231563943b1f571b5a2c1f6a7e", "class_name": "RelatedNodeInfo"}}, "text": "Thenweprintthevocabularysize.\ntrain_iter, test_iter, vocab =load_data_snli( 128,50)\nlen(vocab)\nread 549367 examples\nread 9824 examples\n763 Natural Language Inference: Using Attention\n24618678\nNow we print the shape of the first minibatch. Contrary to sentiment analysis, we have two\ninputs X[0]andX[1]representing pairs of premises and hypotheses.\nfor X, Y intrain_iter:\nprint (X[0].shape)\nprint (X[1].shape)\nprint (Y.shape)\nbreak\ntorch .Size([ 128,50])\ntorch .Size([ 128,50])\ntorch .Size([ 128])\n16.4.3Summary\n\u000fNatural language inference studies whether a hypothesis can be inferred from a premise,\nwhere both are a text sequence.\n\u000fIn natural language inference, relationships between premises and hypotheses include\nentailment, contradiction, and neutral.\n\u000fStanford Natural Language Inference (SNLI) Corpus is a popular benchmark dataset of\nnatural language inference.\n16.4.4Exercises\n1.Machine translation has long been evaluated based on superficial \ud835\udc5b-gram matching be-\ntween an output translation and a ground-truth translation. Can you design a measure\nfor evaluating machine translation results by using natural language inference?\n2.How can we change hyperparameters to reduce the vocabulary size?\nDiscussions246.\n16.5NaturalLanguageInference: Using Attention\nWeintroducedthenaturallanguageinferencetaskandtheSNLIdatasetin Section16.4 . In\nviewofmanymodelsthatarebasedoncomplexanddeeparchitectures,Parikh etal.(2016)\nproposed to address natural language inference with attention mechanisms and called it a\n\u201cdecomposableattentionmodel\u201d. Thisresultsinamodelwithoutrecurrentorconvolutional\nlayers,achievingthebestresultatthetimeontheSNLIdatasetwithmuchfewerparameters.\n764 Natural Language Processing: Applications\nIn this section, we will describe and implement this attention-based method (with MLPs)\nfor natural language inference, as depicted in Fig. 16.5.1 .\ntFig. 16.5.1 This section feeds pretrained GloVe to an architecture based on attention and MLPs for\nnatural language inference.\n16.5.1TheModel\nSimpler than preserving the order of tokens in premises and hypotheses, we can just align\ntokens in one text sequence to every token in the other, and vice versa, then compare and\naggregate such information to predict the logical relationships between premises and hy-\npotheses. Similar to alignment of tokens between source and target sentences in machine\ntranslation,thealignmentoftokensbetweenpremisesandhypothesescanbeneatlyaccom-\nplished by attention mechanisms.\ntFig. 16.5.2 Natural language inference using attention mechanisms.\nFig.16.5.2 depictsthenaturallanguageinferencemethodusingattentionmechanisms. Ata\nhigh level, it consists of three jointly trained steps: attending, comparing, and aggregating.\nWe will illustrate them step by step in the following.\nimport torch\nfrom torch import nn\nfrom torch .nnimport functional asF\nfrom d2l import torch asd2l\n765 Natural Language Inference: Using Attention\nAttending\nThe first step is to align tokens in one text sequence to each token in the other sequence.\nSuppose that the premise is \u201ci do need sleep\u201d and the hypothesis is \u201ci am tired\u201d. Due to\nsemantical similarity, we may wish to align \u201ci\u201d in the hypothesis with \u201ci\u201d in the premise,\nand align \u201ctired\u201d in the hypothesis with \u201csleep\u201d in the premise. Likewise, we may wish\nto align \u201ci\u201d in the premise with \u201ci\u201d in the hypothesis, and align \u201cneed\u201d and \u201csleep\u201d in the\npremise with \u201ctired\u201d in the hypothesis. Note that such alignment is softusing weighted\naverage, where ideally large weights are associated with the tokens to be aligned. For ease\nof demonstration, Fig. 16.5.2 shows such alignment in a hardway.\nNow we describe the soft alignment using attention mechanisms in more detail. Denote\nbyA=\u00b9a1,...,a\ud835\udc5a\u00baandB=\u00b9b1,...,b\ud835\udc5b\u00bathe premise and hypothesis, whose number\nof tokens are \ud835\udc5aand\ud835\udc5b, respectively, where a\ud835\udc56,b\ud835\udc572R\ud835\udc51(\ud835\udc56=1,...,\ud835\udc5a,\ud835\udc57 =1,...,\ud835\udc5b) is a\n\ud835\udc51-dimensional word vector.", "mimetype": "text/plain", "start_char_idx": 1614195, "end_char_idx": 1618085, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d6e2a5f2-13e6-4a45-a193-9680a8b3f024": {"__data__": {"id_": "d6e2a5f2-13e6-4a45-a193-9680a8b3f024", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9b20ef12-ea90-4f6d-898f-f090f2d683ec", "node_type": "1", "metadata": {}, "hash": "067af8ef76d00ba4cef19467f4164855e26f2cad75994b9dd38b846793bd5d28", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2cfa4121-8687-4330-ae60-7acd5c90c175", "node_type": "1", "metadata": {}, "hash": "3df2d6532acf0c30a2e0fa7a7933939deda82a93fc959f9cb6085496225f1325", "class_name": "RelatedNodeInfo"}}, "text": "Note that such alignment is softusing weighted\naverage, where ideally large weights are associated with the tokens to be aligned. For ease\nof demonstration, Fig. 16.5.2 shows such alignment in a hardway.\nNow we describe the soft alignment using attention mechanisms in more detail. Denote\nbyA=\u00b9a1,...,a\ud835\udc5a\u00baandB=\u00b9b1,...,b\ud835\udc5b\u00bathe premise and hypothesis, whose number\nof tokens are \ud835\udc5aand\ud835\udc5b, respectively, where a\ud835\udc56,b\ud835\udc572R\ud835\udc51(\ud835\udc56=1,...,\ud835\udc5a,\ud835\udc57 =1,...,\ud835\udc5b) is a\n\ud835\udc51-dimensional word vector. For soft alignment, we compute the attention weights \ud835\udc52\ud835\udc56\ud835\udc572R\nas\n\ud835\udc52\ud835\udc56\ud835\udc57=\ud835\udc53\u00b9a\ud835\udc56\u00ba>\ud835\udc53\u00b9b\ud835\udc57\u00ba, (16.5.1)\nwhere the function \ud835\udc53is an MLP defined in the following mlpfunction. The output dimen-\nsion of\ud835\udc53is specified by the num_hiddens argument of mlp.\ndef mlp(num_inputs, num_hiddens, flatten):\nnet =[]\nnet.append(nn .Dropout( 0.2))\nnet.append(nn .Linear(num_inputs, num_hiddens))\nnet.append(nn .ReLU())\nifflatten:\nnet.append(nn .Flatten(start_dim =1))\nnet.append(nn .Dropout( 0.2))\nnet.append(nn .Linear(num_hiddens, num_hiddens))\nnet.append(nn .ReLU())\nifflatten:\nnet.append(nn .Flatten(start_dim =1))\nreturn nn.Sequential( *net)\nIt should be highlighted that, in (16.5.1 )\ud835\udc53takes inputs a\ud835\udc56andb\ud835\udc57separately rather than\ntakesapairofthemtogetherasinput. This decomposition trickleadstoonly \ud835\udc5a\u00b8\ud835\udc5bapplica-\ntions (linear complexity) of \ud835\udc53rather than\ud835\udc5a\ud835\udc5bapplications (quadratic complexity).\nNormalizing the attention weights in (16.5.1 ), we compute the weighted average of all\nthe token vectors in the hypothesis to obtain representation of the hypothesis that is softly\naligned with the token indexed by \ud835\udc56in the premise:\n\ud835\udf37\ud835\udc56=\ud835\udc5b\u00d5\n\ud835\udc57=1exp\u00b9\ud835\udc52\ud835\udc56\ud835\udc57\u00ba\u00cd\ud835\udc5b\n\ud835\udc58=1exp\u00b9\ud835\udc52\ud835\udc56\ud835\udc58\u00bab\ud835\udc57. (16.5.2)\nLikewise, we compute soft alignment of premise tokens for each token indexed by \ud835\udc57in the\n766 Natural Language Processing: Applications\nhypothesis:\n\ud835\udf36\ud835\udc57=\ud835\udc5a\u00d5\n\ud835\udc56=1exp\u00b9\ud835\udc52\ud835\udc56\ud835\udc57\u00ba\u00cd\ud835\udc5a\n\ud835\udc58=1exp\u00b9\ud835\udc52\ud835\udc58\ud835\udc57\u00baa\ud835\udc56. (16.5.3)\nBelowwedefinethe Attendclasstocomputethesoftalignmentofhypotheses( beta)with\ninput premises Aand soft alignment of premises ( alpha) with input hypotheses B.\nclass Attend (nn.Module):\ndef __init__ (self , num_inputs, num_hiddens, **kwargs):\nsuper (Attend, self ).__init__ (**kwargs)\nself .f=mlp(num_inputs, num_hiddens, flatten =False )\ndef forward (self , A, B):\n# Shape of `A`/`B`: (`batch_size`, no. of tokens in sequence A/B,\n# `embed_size`)\n# Shape of `f_A`/`f_B`: (`batch_size`, no. of tokens in sequence A/B,\n# `num_hiddens`)\nf_A =self .f(A)\nf_B =self .f(B)\n# Shape of `e`: (`batch_size`, no. of tokens in sequence A,\n# no. of tokens in sequence B)\ne=torch .bmm(f_A, f_B .permute( 0,2,1))\n# Shape of `beta`: (`batch_size`, no. of tokens in sequence A,\n# `embed_size`), where sequence B is softly aligned with each token\n# (axis 1 of `beta`) in sequence A\nbeta =torch .bmm(F .softmax(e, dim =-1), B)\n# Shape of `alpha`: (`batch_size`, no.", "mimetype": "text/plain", "start_char_idx": 1617621, "end_char_idx": 1620355, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2cfa4121-8687-4330-ae60-7acd5c90c175": {"__data__": {"id_": "2cfa4121-8687-4330-ae60-7acd5c90c175", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d6e2a5f2-13e6-4a45-a193-9680a8b3f024", "node_type": "1", "metadata": {}, "hash": "c5d74bbca97ea58a4d550aa854420ce5113621231563943b1f571b5a2c1f6a7e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c3470aa7-69fc-4ca9-a6b5-69d9015cbabf", "node_type": "1", "metadata": {}, "hash": "ccff685ecc79c6e82bcd877043027eb04efbc334d38a11d73ec0aa6cd06948db", "class_name": "RelatedNodeInfo"}}, "text": "of tokens in sequence A/B,\n# `embed_size`)\n# Shape of `f_A`/`f_B`: (`batch_size`, no. of tokens in sequence A/B,\n# `num_hiddens`)\nf_A =self .f(A)\nf_B =self .f(B)\n# Shape of `e`: (`batch_size`, no. of tokens in sequence A,\n# no. of tokens in sequence B)\ne=torch .bmm(f_A, f_B .permute( 0,2,1))\n# Shape of `beta`: (`batch_size`, no. of tokens in sequence A,\n# `embed_size`), where sequence B is softly aligned with each token\n# (axis 1 of `beta`) in sequence A\nbeta =torch .bmm(F .softmax(e, dim =-1), B)\n# Shape of `alpha`: (`batch_size`, no. of tokens in sequence B,\n# `embed_size`), where sequence A is softly aligned with each token\n# (axis 1 of `alpha`) in sequence B\nalpha =torch .bmm(F .softmax(e .permute( 0,2,1), dim =-1), A)\nreturn beta, alpha\nComparing\nIn the next step, we compare a token in one sequence with the other sequence that is softly\naligned with that token. Note that in soft alignment, all the tokens from one sequence,\nthough with probably different attention weights, will be compared with a token in the\nother sequence. For easy of demonstration, Fig. 16.5.2 pairs tokens with aligned tokens\nin ahardway. For example, suppose that the attending step determines that \u201cneed\u201d and\n\u201csleep\u201d in the premise are both aligned with \u201ctired\u201d in the hypothesis, the pair \u201ctired\u2013need\nsleep\u201d will be compared.\nIn the comparing step, we feed the concatenation (operator \u00bb\u0001,\u0001\u00bc) of tokens from one se-\nquence and aligned tokens from the other sequence into a function \ud835\udc54(an MLP):\nv\ud835\udc34,\ud835\udc56=\ud835\udc54\u00b9\u00bba\ud835\udc56,\ud835\udf37\ud835\udc56\u00bc\u00ba,\ud835\udc56=1,...,\ud835\udc5a\nv\ud835\udc35,\ud835\udc57=\ud835\udc54\u00b9\u00bbb\ud835\udc57,\ud835\udf36\ud835\udc57\u00bc\u00ba,\ud835\udc57=1,...,\ud835\udc5b.(16.5.4)\nIn(16.5.4 ),v\ud835\udc34,\ud835\udc56is the comparison between token \ud835\udc56in the premise and all the hypothesis\ntokensthataresoftlyalignedwithtoken \ud835\udc56; while v\ud835\udc35,\ud835\udc57isthecomparisonbetweentoken \ud835\udc57in\n767 Natural Language Inference: Using Attention\nthehypothesisandallthepremisetokensthataresoftlyalignedwithtoken \ud835\udc57. Thefollowing\nCompare class defines such as comparing step.\nclass Compare (nn.Module):\ndef __init__ (self , num_inputs, num_hiddens, **kwargs):\nsuper (Compare, self ).__init__ (**kwargs)\nself .g=mlp(num_inputs, num_hiddens, flatten =False )\ndef forward (self , A, B, beta, alpha):\nV_A =self .g(torch .cat([A, beta], dim =2))\nV_B =self .g(torch .cat([B, alpha], dim =2))\nreturn V_A, V_B\nAggregating\nWith two sets of comparison vectors v\ud835\udc34,\ud835\udc56(\ud835\udc56=1,...,\ud835\udc5a) andv\ud835\udc35,\ud835\udc57(\ud835\udc57=1,...,\ud835\udc5b) on hand,\nin the last step we will aggregate such information to infer the logical relationship. We\nbegin by summing up both sets:\nv\ud835\udc34=\ud835\udc5a\u00d5\n\ud835\udc56=1v\ud835\udc34,\ud835\udc56,v\ud835\udc35=\ud835\udc5b\u00d5\n\ud835\udc57=1v\ud835\udc35,\ud835\udc57. (16.5.5)\nNext we feed the concatenation of both summarization results into function \u210e(an MLP) to\nobtain the classification result of the logical relationship:\n\u02c6y=\u210e\u00b9\u00bbv\ud835\udc34,v\ud835\udc35\u00bc\u00ba. (16.5.6)\nThe aggregation step is defined in the following Aggregate class.", "mimetype": "text/plain", "start_char_idx": 1619814, "end_char_idx": 1622520, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c3470aa7-69fc-4ca9-a6b5-69d9015cbabf": {"__data__": {"id_": "c3470aa7-69fc-4ca9-a6b5-69d9015cbabf", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2cfa4121-8687-4330-ae60-7acd5c90c175", "node_type": "1", "metadata": {}, "hash": "3df2d6532acf0c30a2e0fa7a7933939deda82a93fc959f9cb6085496225f1325", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6c826fd3-fe51-4d34-9d6e-d3be471307f1", "node_type": "1", "metadata": {}, "hash": "672d0f18f6b2412e36fae1b0341b8bd42108d08327de201f74797af1dec34b26", "class_name": "RelatedNodeInfo"}}, "text": "We\nbegin by summing up both sets:\nv\ud835\udc34=\ud835\udc5a\u00d5\n\ud835\udc56=1v\ud835\udc34,\ud835\udc56,v\ud835\udc35=\ud835\udc5b\u00d5\n\ud835\udc57=1v\ud835\udc35,\ud835\udc57. (16.5.5)\nNext we feed the concatenation of both summarization results into function \u210e(an MLP) to\nobtain the classification result of the logical relationship:\n\u02c6y=\u210e\u00b9\u00bbv\ud835\udc34,v\ud835\udc35\u00bc\u00ba. (16.5.6)\nThe aggregation step is defined in the following Aggregate class.\nclass Aggregate (nn.Module):\ndef __init__ (self , num_inputs, num_hiddens, num_outputs, **kwargs):\nsuper (Aggregate, self ).__init__ (**kwargs)\nself .h=mlp(num_inputs, num_hiddens, flatten =True )\nself .linear =nn.Linear(num_hiddens, num_outputs)\ndef forward (self , V_A, V_B):\n# Sum up both sets of comparison vectors\nV_A =V_A.sum(dim =1)\nV_B =V_B.sum(dim =1)\n# Feed the concatenation of both summarization results into an MLP\nY_hat =self .linear( self .h(torch .cat([V_A, V_B], dim =1)))\nreturn Y_hat\nPuttingIt All Together\nBy putting the attending, comparing, and aggregating steps together, we define the decom-\nposable attention model to jointly train these three steps.\n768 Natural Language Processing: Applications\nclass DecomposableAttention (nn.Module):\ndef __init__ (self , vocab, embed_size, num_hiddens, num_inputs_attend =100,\nnum_inputs_compare =200, num_inputs_agg =400,**kwargs):\nsuper (DecomposableAttention, self ).__init__ (**kwargs)\nself .embedding =nn.Embedding( len(vocab), embed_size)\nself .attend =Attend(num_inputs_attend, num_hiddens)\nself .compare =Compare(num_inputs_compare, num_hiddens)\n# There are 3 possible outputs: entailment, contradiction, and neutral\nself .aggregate =Aggregate(num_inputs_agg, num_hiddens, num_outputs =3)\ndef forward (self , X):\npremises, hypotheses =X\nA=self .embedding(premises)\nB=self .embedding(hypotheses)\nbeta, alpha =self .attend(A, B)\nV_A, V_B =self .compare(A, B, beta, alpha)\nY_hat =self .aggregate(V_A, V_B)\nreturn Y_hat\n16.5.2Trainingand Evaluatingthe Model\nNow we will train and evaluate the defined decomposable attention model on the SNLI\ndataset. We begin by reading the dataset.\nReadingthe dataset\nWe download and read the SNLI dataset using the function defined in Section 16.4 . The\nbatch size and sequence length are set to 256and50, respectively.\nbatch_size, num_steps =256,50\ntrain_iter, test_iter, vocab =d2l.load_data_snli(batch_size, num_steps)\nDownloading ../data /snli_1 .0.zip from https ://nlp.stanford .edu/projects /snli /\n\u21a9!snli_1 .0.zip...\nread 549367 examples\nread 9824 examples\nCreatingthe Model\nWe use the pretrained 100-dimensional GloVe embedding to represent the input tokens.\nThus, we predefine the dimension of vectors a\ud835\udc56andb\ud835\udc57in(16.5.1 )as 100. The output\ndimension of functions \ud835\udc53in(16.5.1 )and\ud835\udc54in(16.5.4 )is set to 200. Then we create a\nmodelinstance,initializeitsparameters,andloadtheGloVeembeddingtoinitializevectors\nof input tokens.\nembed_size, num_hiddens, devices =100,200, d2l .try_all_gpus()\nnet =DecomposableAttention(vocab, embed_size, num_hiddens)\n(continues on next page)\n769 Natural Language Inference: Using Attention\n(continued from previous page)\nglove_embedding =d2l.TokenEmbedding( 'glove.6b.100d ')\nembeds =glove_embedding[vocab .idx_to_token]\nnet.embedding .weight .data .copy_(embeds);\nDownloading ../data /glove .6B.100 d.zip from http ://d2l-data .s3-accelerate .", "mimetype": "text/plain", "start_char_idx": 1622209, "end_char_idx": 1625403, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6c826fd3-fe51-4d34-9d6e-d3be471307f1": {"__data__": {"id_": "6c826fd3-fe51-4d34-9d6e-d3be471307f1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c3470aa7-69fc-4ca9-a6b5-69d9015cbabf", "node_type": "1", "metadata": {}, "hash": "ccff685ecc79c6e82bcd877043027eb04efbc334d38a11d73ec0aa6cd06948db", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a1579f83-abc5-4e54-ae01-4f2b4e50bff2", "node_type": "1", "metadata": {}, "hash": "49d2f4041bc696520362eb5b671a40eaa84b5e237a0943da748636551aa6890e", "class_name": "RelatedNodeInfo"}}, "text": "The output\ndimension of functions \ud835\udc53in(16.5.1 )and\ud835\udc54in(16.5.4 )is set to 200. Then we create a\nmodelinstance,initializeitsparameters,andloadtheGloVeembeddingtoinitializevectors\nof input tokens.\nembed_size, num_hiddens, devices =100,200, d2l .try_all_gpus()\nnet =DecomposableAttention(vocab, embed_size, num_hiddens)\n(continues on next page)\n769 Natural Language Inference: Using Attention\n(continued from previous page)\nglove_embedding =d2l.TokenEmbedding( 'glove.6b.100d ')\nembeds =glove_embedding[vocab .idx_to_token]\nnet.embedding .weight .data .copy_(embeds);\nDownloading ../data /glove .6B.100 d.zip from http ://d2l-data .s3-accelerate .\n\u21a9!amazonaws .com/glove .6B.100 d.zip...\nTrainingand Evaluatingthe Model\nIncontrasttothe split_batch functionin Section13.5 thattakessingleinputssuchastext\nsequences(orimages), wedefinea split_batch_multi_inputs functiontotakemultiple\ninputs such as premises and hypotheses in minibatches.\nNow we can train and evaluate the model on the SNLI dataset.\nlr, num_epochs =0.001 ,4\ntrainer =torch .optim .Adam(net .parameters(), lr =lr)\nloss =nn.CrossEntropyLoss(reduction =\"none \")\nd2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)\nloss 0.496 , train acc 0.805 , test acc 0.828\n20383.2 examples /sec on [device( type ='cuda ', index =0), device( type ='cuda ',\u2423\n\u21a9!index =1)]\nUsing the Model\nFinally, define the prediction function to output the logical relationship between a pair of\npremise and hypothesis.\n#@save\ndef predict_snli (net, vocab, premise, hypothesis):\n\"\"\"Predict the logical relationship between the premise and hypothesis.\"\"\"\nnet.eval()\npremise =torch .tensor(vocab[premise], device =d2l.try_gpu())\n(continues on next page)\n770 Natural Language Processing: Applications\n247(continued from previous page)\nhypothesis =torch .tensor(vocab[hypothesis], device =d2l.try_gpu())\nlabel =torch .argmax(net([premise .reshape(( 1,-1)),\nhypothesis .reshape(( 1,-1))]), dim =1)\nreturn 'entailment 'iflabel ==0else 'contradiction 'iflabel ==1\\\nelse 'neutral '\nWe can use the trained model to obtain the natural language inference result for a sample\npair of sentences.\npredict_snli(net, vocab, [ 'he','is','good ','.'], [ 'he','is','bad','.'])\n'contradiction '\n16.5.3Summary\n\u000fThe decomposable attention model consists of three steps for predicting the logical rela-\ntionships between premises and hypotheses: attending, comparing, and aggregating.\n\u000fWith attention mechanisms, we can align tokens in one text sequence to every token in\ntheother,andviceversa. Suchalignmentissoftusingweightedaverage,whereideally\nlarge weights are associated with the tokens to be aligned.\n\u000fThedecompositiontrickleadstoamoredesirablelinearcomplexitythanquadraticcom-\nplexity when computing attention weights.\n\u000fWe can use pretrained word vectors as the input representation for downstream natural\nlanguage processing task such as natural language inference.\n16.5.4Exercises\n1.Train the model with other combinations of hyperparameters. Can you get better accu-\nracy on the test set?\n2.What are major drawbacks of the decomposable attention model for natural language\ninference?\n3.Suppose that we want to get the level of semantical similarity (e.g., a continuous value\nbetween 0 and 1) for any pair of sentences. How shall we collect and label the dataset?\nCan you design a model with attention mechanisms?\nDiscussions247.\n771 Fine-Tuning BERT for Sequence-Level and Token-Level Applications\n16.6Fine-TuningBERTforSequence-Leveland\nToken-LevelApplications\nIn the previous sections of this chapter, we have designed different models for natural lan-\nguageprocessingapplications,suchasbasedonRNNs,CNNs,attention,andMLPs. These\nmodelsarehelpfulwhenthereisspaceortimeconstraint,however,craftingaspecificmodel\nfor every natural language processing task is practically infeasible. In Section 15.8 , we in-\ntroduced a pretraining model, BERT, that requires minimal architecture changes fora wide\nrange of natural language processing tasks.", "mimetype": "text/plain", "start_char_idx": 1624762, "end_char_idx": 1628741, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a1579f83-abc5-4e54-ae01-4f2b4e50bff2": {"__data__": {"id_": "a1579f83-abc5-4e54-ae01-4f2b4e50bff2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6c826fd3-fe51-4d34-9d6e-d3be471307f1", "node_type": "1", "metadata": {}, "hash": "672d0f18f6b2412e36fae1b0341b8bd42108d08327de201f74797af1dec34b26", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "85011d4b-a961-44a2-9bc6-c16b28b4fa74", "node_type": "1", "metadata": {}, "hash": "ffb727f8442b2f66757e73b5e4ac58f5f6d6f1fc83f729da96fac947b8fa876a", "class_name": "RelatedNodeInfo"}}, "text": "3.Suppose that we want to get the level of semantical similarity (e.g., a continuous value\nbetween 0 and 1) for any pair of sentences. How shall we collect and label the dataset?\nCan you design a model with attention mechanisms?\nDiscussions247.\n771 Fine-Tuning BERT for Sequence-Level and Token-Level Applications\n16.6Fine-TuningBERTforSequence-Leveland\nToken-LevelApplications\nIn the previous sections of this chapter, we have designed different models for natural lan-\nguageprocessingapplications,suchasbasedonRNNs,CNNs,attention,andMLPs. These\nmodelsarehelpfulwhenthereisspaceortimeconstraint,however,craftingaspecificmodel\nfor every natural language processing task is practically infeasible. In Section 15.8 , we in-\ntroduced a pretraining model, BERT, that requires minimal architecture changes fora wide\nrange of natural language processing tasks. On the one hand, at the time of its proposal,\nBERT improved the state of the art on various natural language processing tasks. On the\nother hand, as noted in Section 15.10 , the two versions of the original BERT model come\nwith110millionand340millionparameters. Thus,whentherearesufficientcomputational\nresources,wemayconsiderfine-tuningBERTfordownstreamnaturallanguageprocessing\napplications.\nIn the following, we generalize a subset of natural language processing applications as\nsequence-level and token-level. On the sequence level, we introduce how to transform the\nBERT representation of the text input to the output label in single text classification and\ntext pair classification or regression. On the token level, we will briefly introduce new ap-\nplications such as text tagging and question answering and shed light on how BERT can\nrepresenttheirinputsandgettransformedintooutputlabels. Duringfine-tuning,the\u201cmini-\nmalarchitecturechanges\u201drequiredbyBERTacrossdifferentapplicationsaretheextrafully\nconnected layers. During supervised learning of a downstream application, parameters of\nthe extra layers are learned from scratch while all the parameters in the pretrained BERT\nmodel are fine-tuned.\n16.6.1SingleTextClassification\nSingle text classification takes a single text sequence as input and outputs its classification\nresult. Besides sentiment analysis that we have studied in this chapter, the Corpus of Lin-\nguisticAcceptability(CoLA)isalsoadatasetforsingletextclassification,judgingwhether\na given sentence is grammatically acceptable or not ( Warstadt et al., 2019). For instance,\n\u201cI should study.\u201d is acceptable but \u201cI should studying.\u201d is not.\nSection15.8 describestheinputrepresentationofBERT.TheBERTinputsequenceunam-\nbiguously represents both single text and text pairs, where the special classification token\n\u201c<cls>\u201d is used for sequence classification and the special classification token \u201c<sep>\u201d\nmarks the end of single text or separates a pair of text. As shown in Fig. 16.6.1 , in single\ntext classification applications, the BERT representation of the special classification token\n\u201c<cls>\u201d encodes the information of the entire input text sequence. As the representation of\nthe input single text, it will be fed into a small MLP consisting of fully connected (dense)\nlayers to output the distribution of all the discrete label values.\n16.6.2TextPairClassification or Regression\n772 Natural Language Processing: Applications\ntFig. 16.6.1 Fine-tuning BERT for single text classi\ufb01cation applications, such as sentiment analysis\nand testing linguistic acceptability. Suppose that the input single text has six tokens.\nWe have also examined natural language inference in this chapter. It belongs to text pair\nclassification , a type of application classifying a pair of text.\nTaking a pair of text as input but outputting a continuous value, semantictextualsimilarity\nis a popular textpairregression task. This task measures semantic similarity of sentences.\nFor instance, in the Semantic Textual Similarity Benchmark dataset, the similarity score of\na pair of sentences is an ordinal scale ranging from 0 (no meaning overlap) to 5 (meaning\nequivalence) ( Ceret al., 2017). The goal is to predict these scores. Examples from the\nSemantic Textual Similarity Benchmark dataset include (sentence 1, sentence 2, similarity\nscore):\n\u000f\u201cA plane is taking off.\u201d, \u201cAn air plane is taking off.\u201d, 5.000;\n\u000f\u201cA woman is eating something.\u201d, \u201cA woman is eating meat.\u201d, 3.000;\n\u000f\u201cA woman is dancing.\u201d, \u201cA man is talking.\u201d, 0.000.\ntFig.", "mimetype": "text/plain", "start_char_idx": 1627887, "end_char_idx": 1632283, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "85011d4b-a961-44a2-9bc6-c16b28b4fa74": {"__data__": {"id_": "85011d4b-a961-44a2-9bc6-c16b28b4fa74", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a1579f83-abc5-4e54-ae01-4f2b4e50bff2", "node_type": "1", "metadata": {}, "hash": "49d2f4041bc696520362eb5b671a40eaa84b5e237a0943da748636551aa6890e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0742ec95-a573-461b-aaec-d8cc5a6cfa82", "node_type": "1", "metadata": {}, "hash": "0c50a142aaec2179c423c805fc74c1c3524b90d4c70b21b2f22514f7288b0494", "class_name": "RelatedNodeInfo"}}, "text": "Taking a pair of text as input but outputting a continuous value, semantictextualsimilarity\nis a popular textpairregression task. This task measures semantic similarity of sentences.\nFor instance, in the Semantic Textual Similarity Benchmark dataset, the similarity score of\na pair of sentences is an ordinal scale ranging from 0 (no meaning overlap) to 5 (meaning\nequivalence) ( Ceret al., 2017). The goal is to predict these scores. Examples from the\nSemantic Textual Similarity Benchmark dataset include (sentence 1, sentence 2, similarity\nscore):\n\u000f\u201cA plane is taking off.\u201d, \u201cAn air plane is taking off.\u201d, 5.000;\n\u000f\u201cA woman is eating something.\u201d, \u201cA woman is eating meat.\u201d, 3.000;\n\u000f\u201cA woman is dancing.\u201d, \u201cA man is talking.\u201d, 0.000.\ntFig. 16.6.2 Fine-tuning BERT for text pair classi\ufb01cation or regression applications, such as natural\nlanguage inference and semantic textual similarity. Suppose that the input text pair has\ntwo and three tokens.\nComparing with single text classification in Fig. 16.6.1 , fine-tuning BERT for text pair\nclassification in Fig. 16.6.2 is different in the input representation. For text pair regression\ntasks such as semantic textual similarity, trivial changes can be applied such as outputting\n773 Fine-Tuning BERT for Sequence-Level and Token-Level Applications\na continuous label value and using the mean squared loss: they are common for regres-\nsion.\n16.6.3TextTagging\nNow let\u2019s consider token-level tasks, such as text tagging , where each token is assigned a\nlabel. Amongtexttaggingtasks, part-of-speechtagging assignseachwordapart-of-speech\ntag (e.g., adjective and determiner) according to the role of the word in the sentence. For\nexample, according to the Penn Treebank II tag set, the sentence \u201cJohn Smith \u2019s car is\nnew\u201d should be tagged as \u201cNNP (noun, proper singular) NNP POS (possessive ending)\nNN (noun, singular or mass) VB (verb, base form) JJ (adjective)\u201d.\ntFig. 16.6.3 Fine-tuning BERT for text tagging applications, such as part-of-speech tagging. Suppose\nthat the input single text has six tokens.\nFine-tuning BERT for text tagging applications is illustrated in Fig. 16.6.3 . Comparing\nwithFig. 16.6.1 , the only distinction lies in that in text tagging, the BERT representation\nofevery token of the input text is fed into the same extra fully connected layers to output\nthe label of the token, such as a part-of-speech tag.\n16.6.4QuestionAnswering\nAsanothertoken-levelapplication, questionanswering reflectscapabilitiesofreadingcom-\nprehension. Forexample,theStanfordQuestionAnsweringDataset(SQuADv1.1)consists\nof reading passages and questions, where the answer to every question is just a segment of\ntext (text span) from the passage that the question is about ( Rajpurkar et al., 2016). To\nexplain, consider a passage \u201cSome experts report that a mask\u2019s efficacy is inconclusive.\nHowever, mask makers insist that their products, such as N95 respirator masks, can guard\nagainst the virus.\u201d and a question \u201cWho say that N95 respirator masks can guard against\nthe virus?\u201d. The answer should be the text span \u201cmask makers\u201d in the passage. Thus, the\ngoal in SQuAD v1.1 is to predict the start and end of the text span in the passage given a\npair of question and passage.\nTo fine-tune BERT for question answering, the question and passage are packed as the first\nand second text sequence, respectively, in the input of BERT. To predict the position of the\nstart of the text span, the same additional fully connected layer will transform the BERT\n774 Natural Language Processing: Applications\ntFig. 16.6.4 Fine-tuning BERT for question answering. Suppose that the input text pair has two and\nthree tokens.\nrepresentationofanytokenfromthepassageofposition \ud835\udc56intoascalarscore \ud835\udc60\ud835\udc56. Suchscores\nofallthepassagetokensarefurthertransformedbythesoftmaxoperationintoaprobability\ndistribution,sothateachtokenposition \ud835\udc56inthepassageisassignedaprobability \ud835\udc5d\ud835\udc56ofbeing\nthestartofthetextspan.", "mimetype": "text/plain", "start_char_idx": 1631543, "end_char_idx": 1635468, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0742ec95-a573-461b-aaec-d8cc5a6cfa82": {"__data__": {"id_": "0742ec95-a573-461b-aaec-d8cc5a6cfa82", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "85011d4b-a961-44a2-9bc6-c16b28b4fa74", "node_type": "1", "metadata": {}, "hash": "ffb727f8442b2f66757e73b5e4ac58f5f6d6f1fc83f729da96fac947b8fa876a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5d8e209c-8ad4-41cd-b7fd-5c06aac5ee81", "node_type": "1", "metadata": {}, "hash": "69e02139e8ec291ec76a051a99b9d9e9a6e18d83c46650fc0b89fdf843553506", "class_name": "RelatedNodeInfo"}}, "text": "To fine-tune BERT for question answering, the question and passage are packed as the first\nand second text sequence, respectively, in the input of BERT. To predict the position of the\nstart of the text span, the same additional fully connected layer will transform the BERT\n774 Natural Language Processing: Applications\ntFig. 16.6.4 Fine-tuning BERT for question answering. Suppose that the input text pair has two and\nthree tokens.\nrepresentationofanytokenfromthepassageofposition \ud835\udc56intoascalarscore \ud835\udc60\ud835\udc56. Suchscores\nofallthepassagetokensarefurthertransformedbythesoftmaxoperationintoaprobability\ndistribution,sothateachtokenposition \ud835\udc56inthepassageisassignedaprobability \ud835\udc5d\ud835\udc56ofbeing\nthestartofthetextspan. Predictingtheendofthetextspanisthesameasabove,exceptthat\nparametersinitsadditionalfullyconnectedlayerareindependentfromthoseforpredicting\nthe start. When predicting the end, any passage token of position \ud835\udc56is transformed by the\nsame fully connected layer into a scalar score \ud835\udc52\ud835\udc56.Fig. 16.6.4 depicts fine-tuning BERT for\nquestion answering.\nForquestionanswering,thesupervisedlearning\u2019strainingobjectiveisasstraightforwardas\nmaximizing the log-likelihoods of the ground-truth start and end positions. When predict-\ning the span, we can compute the score \ud835\udc60\ud835\udc56\u00b8\ud835\udc52\ud835\udc57for a valid span from position \ud835\udc56to position\n\ud835\udc57(\ud835\udc56\u0014\ud835\udc57), and output the span with the highest score.\n16.6.5Summary\n\u000fBERTrequiresminimalarchitecturechanges(extrafullyconnectedlayers)forsequence-\nlevelandtoken-levelnaturallanguageprocessingapplications,suchassingletextclas-\nsification(e.g.,sentimentanalysisandtestinglinguisticacceptability),textpairclassi-\nficationorregression(e.g.,naturallanguageinferenceandsemantictextualsimilarity),\ntext tagging (e.g., part-of-speech tagging), and question answering.\n\u000fDuring supervised learning of a downstream application, parameters of the extra layers\nare learned from scratch while all the parameters in the pretrained BERT model are\nfine-tuned.\n16.6.6Exercises\n1.Let\u2019s design a search engine algorithm for news articles. When the system receives an\nquery (e.g., \u201coil industry during the coronavirus outbreak\u201d), it should return a ranked\nlistofnewsarticlesthataremostrelevanttothequery. Supposethatwehaveahugepool\nof news articles and a large number of queries. To simplify the problem, suppose that\nthe most relevant article has been labeled for each query. How can we apply negative\nsampling (see Section 15.2.1 ) and BERT in the algorithm design?\n775 Natural Language Inference: Fine-Tuning BERT\n2482.How can we leverage BERT in training language models?\n3.Can we leverage BERT in machine translation?\nDiscussions248.\n16.7NaturalLanguageInference: Fine-Tuning\nBERT\nIn earlier sections of this chapter, we have designed an attention-based architecture (in\nSection 16.5 ) for the natural language inference task on the SNLI dataset (as described\ninSection 16.4 ). Now we revisit this task by fine-tuning BERT. As discussed in Section\n16.6, natural language inference is a sequence-level text pair classification problem, and\nfine-tuningBERTonlyrequiresanadditionalMLP-basedarchitecture,asillustratedin Fig.\n16.7.1.\ntFig. 16.7.1 This section feeds pretrained BERT to an MLP-based architecture for natural language\ninference.\nIn this section, we will download a pretrained small version of BERT, then fine-tune it for\nnatural language inference on the SNLI dataset.\nimport json\nimport multiprocessing\nimport os\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n16.7.1LoadingPretrainedBERT\nWe have explained how to pretrain BERT on the WikiText-2 dataset in Section 15.9 and\nSection 15.10 (note that the original BERT model is pretrained on much bigger corpora).\nAsdiscussedin Section15.10 ,theoriginalBERTmodelhashundredsofmillionsofparam-\neters. In the following, we provide two versions of pretrained BERT: \u201cbert.base\u201d is about\n776 Natural Language Processing: Applications\nas big as the original BERT base model that requires a lot of computational resources to\nfine-tune, while \u201cbert.small\u201d is a small version to facilitate demonstration.", "mimetype": "text/plain", "start_char_idx": 1634768, "end_char_idx": 1638816, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5d8e209c-8ad4-41cd-b7fd-5c06aac5ee81": {"__data__": {"id_": "5d8e209c-8ad4-41cd-b7fd-5c06aac5ee81", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0742ec95-a573-461b-aaec-d8cc5a6cfa82", "node_type": "1", "metadata": {}, "hash": "0c50a142aaec2179c423c805fc74c1c3524b90d4c70b21b2f22514f7288b0494", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b42f59fd-091c-4579-9792-51645c108dd7", "node_type": "1", "metadata": {}, "hash": "4bdc0dad69eddf7a7f3c0ac24be9ac69ab5f8f0bb1e575934125a8f9cf42f324", "class_name": "RelatedNodeInfo"}}, "text": "import json\nimport multiprocessing\nimport os\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n16.7.1LoadingPretrainedBERT\nWe have explained how to pretrain BERT on the WikiText-2 dataset in Section 15.9 and\nSection 15.10 (note that the original BERT model is pretrained on much bigger corpora).\nAsdiscussedin Section15.10 ,theoriginalBERTmodelhashundredsofmillionsofparam-\neters. In the following, we provide two versions of pretrained BERT: \u201cbert.base\u201d is about\n776 Natural Language Processing: Applications\nas big as the original BERT base model that requires a lot of computational resources to\nfine-tune, while \u201cbert.small\u201d is a small version to facilitate demonstration.\nd2l.DATA_HUB[ 'bert.base ']=(d2l .DATA_URL +'bert.base.torch.zip ',\n'225d66f04cae318b841a13d32af3acc165f253ac ')\nd2l.DATA_HUB[ 'bert.small ']=(d2l .DATA_URL +'bert.small.torch.zip ',\n'c72329e68a732bef0452e4b96a1c341c8910f81f ')\nEither pretrained BERT model contains a \u201cvocab.json\u201d file that defines the vocabulary set\nand a \u201cpretrained.params\u201d file of the pretrained parameters. We implement the following\nload_pretrained_model function to load pretrained BERT parameters.\ndef load_pretrained_model (pretrained_model, num_hiddens, ffn_num_hiddens,\nnum_heads, num_blks, dropout, max_len, devices):\ndata_dir =d2l.download_extract(pretrained_model)\n# Define an empty vocabulary to load the predefined vocabulary\nvocab =d2l.Vocab()\nvocab .idx_to_token =json .load( open (os.path .join(data_dir, 'vocab.json ')))\nvocab .token_to_idx ={token: idx for idx, token inenumerate (\nvocab .idx_to_token)}\nbert =d2l.BERTModel(\nlen(vocab), num_hiddens, ffn_num_hiddens =ffn_num_hiddens, num_heads =4,\nnum_blks =2, dropout =0.2, max_len =max_len)\n# Load pretrained BERT parameters\nbert .load_state_dict(torch .load(os .path .join(data_dir,\n'pretrained.params ')))\nreturn bert, vocab\nTo facilitate demonstration on most of machines, we will load and fine-tune the small ver-\nsion (\u201cbert.small\u201d) of the pretrained BERT in this section. In the exercise, we will show\nhow to fine-tune the much larger \u201cbert.base\u201d to significantly improve the testing accu-\nracy.\ndevices =d2l.try_all_gpus()\nbert, vocab =load_pretrained_model(\n'bert.small ', num_hiddens =256, ffn_num_hiddens =512, num_heads =4,\nnum_blks =2, dropout =0.1, max_len =512, devices =devices)\nDownloading ../data /bert .small .torch .zip from http ://d2l-data .s3-accelerate .\n\u21a9!amazonaws .com/bert .small .torch .zip...\n16.7.2TheDatasetforFine-TuningBERT\nFor the downstream task natural language inference on the SNLI dataset, we define a cus-\ntomized dataset class SNLIBERTDataset . In each example, the premise and hypothesis\nform a pair of text sequence and is packed into one BERT input sequence as depicted in\nFig. 16.6.2 . Recall Section 15.8.4 that segment IDs are used to distinguish the premise\nand the hypothesis in a BERT input sequence. With the predefined maximum length of a\nBERT input sequence ( max_len ), the last token of the longer of the input text pair keeps\n777 Natural Language Inference: Fine-Tuning BERT\ngetting removed until max_len is met. To accelerate generation of the SNLI dataset for\nfine-tuning BERT, we use 4 worker processes to generate training or testing examples in\nparallel.", "mimetype": "text/plain", "start_char_idx": 1638128, "end_char_idx": 1641372, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b42f59fd-091c-4579-9792-51645c108dd7": {"__data__": {"id_": "b42f59fd-091c-4579-9792-51645c108dd7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5d8e209c-8ad4-41cd-b7fd-5c06aac5ee81", "node_type": "1", "metadata": {}, "hash": "69e02139e8ec291ec76a051a99b9d9e9a6e18d83c46650fc0b89fdf843553506", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9e5d968f-e9bb-4018-84b7-5cc22b9acf9d", "node_type": "1", "metadata": {}, "hash": "d296f0c2828b33ac18b3e820058ee47753488d0e925a7a9af13e2bd128799209", "class_name": "RelatedNodeInfo"}}, "text": "In each example, the premise and hypothesis\nform a pair of text sequence and is packed into one BERT input sequence as depicted in\nFig. 16.6.2 . Recall Section 15.8.4 that segment IDs are used to distinguish the premise\nand the hypothesis in a BERT input sequence. With the predefined maximum length of a\nBERT input sequence ( max_len ), the last token of the longer of the input text pair keeps\n777 Natural Language Inference: Fine-Tuning BERT\ngetting removed until max_len is met. To accelerate generation of the SNLI dataset for\nfine-tuning BERT, we use 4 worker processes to generate training or testing examples in\nparallel.\nclass SNLIBERTDataset (torch .utils .data .Dataset):\ndef __init__ (self , dataset, max_len, vocab =None ):\nall_premise_hypothesis_tokens =[[\np_tokens, h_tokens] for p_tokens, h_tokens inzip(\n*[d2l .tokenize([s .lower() for sinsentences])\nfor sentences indataset[: 2]])]\nself .labels =torch .tensor(dataset[ 2])\nself .vocab =vocab\nself .max_len =max_len\n(self .all_token_ids, self .all_segments,\nself .valid_lens) =self ._preprocess(all_premise_hypothesis_tokens)\nprint ('read '+str(len(self .all_token_ids)) +'examples ')\ndef _preprocess (self , all_premise_hypothesis_tokens):\npool =multiprocessing .Pool( 4)# Use 4 worker processes\nout =pool .map( self ._mp_worker, all_premise_hypothesis_tokens)\nall_token_ids =[\ntoken_ids for token_ids, segments, valid_len inout]\nall_segments =[segments for token_ids, segments, valid_len inout]\nvalid_lens =[valid_len for token_ids, segments, valid_len inout]\nreturn (torch .tensor(all_token_ids, dtype =torch .long),\ntorch .tensor(all_segments, dtype =torch .long),\ntorch .tensor(valid_lens))\ndef _mp_worker (self , premise_hypothesis_tokens):\np_tokens, h_tokens =premise_hypothesis_tokens\nself ._truncate_pair_of_tokens(p_tokens, h_tokens)\ntokens, segments =d2l.get_tokens_and_segments(p_tokens, h_tokens)\ntoken_ids =self .vocab[tokens] +[self .vocab[ '<pad> ']] \\\n*(self .max_len -len(tokens))\nsegments =segments +[0]*(self .max_len -len(segments))\nvalid_len =len(tokens)\nreturn token_ids, segments, valid_len\ndef _truncate_pair_of_tokens (self , p_tokens, h_tokens):\n# Reserve slots for '<CLS>', '<SEP>', and '<SEP>' tokens for the BERT\n# input\nwhile len(p_tokens) +len(h_tokens) >self .max_len -3:\niflen(p_tokens) >len(h_tokens):\np_tokens .pop()\nelse :\nh_tokens .pop()\ndef __getitem__ (self , idx):\nreturn (self .all_token_ids[idx], self .all_segments[idx],\nself .valid_lens[idx]), self .labels[idx]\ndef __len__ (self ):\nreturn len(self .all_token_ids)\nAfter downloading the SNLI dataset, we generate training and testing examples by instan-\n778 Natural Language Processing: Applications\ntiating the SNLIBERTDataset class. Such examples will be read in minibatches during\ntraining and testing of natural language inference.\n# Reduce `batch_size` if there is an out of memory error. In the original BERT\n# model, `max_len` = 512\nbatch_size, max_len, num_workers =512,128, d2l .get_dataloader_workers()\ndata_dir =d2l.download_extract( 'SNLI ')\ntrain_set =SNLIBERTDataset(d2l .read_snli(data_dir, True ), max_len, vocab)\ntest_set =SNLIBERTDataset(d2l .read_snli(data_dir, False ), max_len, vocab)\ntrain_iter =torch .utils .data .DataLoader(train_set, batch_size, shuffle =True ,\nnum_workers =num_workers)\ntest_iter =torch .utils .data .DataLoader(test_set, batch_size,\nnum_workers =num_workers)\nread 549367 examples\nread 9824 examples\n16.7.3Fine-TuningBERT\nAsFig. 16.6.2 indicates, fine-tuning BERT for natural language inference requires only an\nextra MLP consisting of two fully connected layers (see self.hidden andself.output\nin the following BERTClassifier class). This MLP transforms the BERT representation\nof the special \u201c<cls>\u201d token, which encodes the information of both the premise and the\nhypothesis, intothreeoutputsofnaturallanguageinference: entailment, contradiction, and\nneutral.", "mimetype": "text/plain", "start_char_idx": 1640743, "end_char_idx": 1644611, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9e5d968f-e9bb-4018-84b7-5cc22b9acf9d": {"__data__": {"id_": "9e5d968f-e9bb-4018-84b7-5cc22b9acf9d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b42f59fd-091c-4579-9792-51645c108dd7", "node_type": "1", "metadata": {}, "hash": "4bdc0dad69eddf7a7f3c0ac24be9ac69ab5f8f0bb1e575934125a8f9cf42f324", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1068d22a-9227-4c98-b10a-60b728b278c4", "node_type": "1", "metadata": {}, "hash": "8421c9991763a329c856004f230b750f912a12655f75e1d25ff455493f85d923", "class_name": "RelatedNodeInfo"}}, "text": "16.6.2 indicates, fine-tuning BERT for natural language inference requires only an\nextra MLP consisting of two fully connected layers (see self.hidden andself.output\nin the following BERTClassifier class). This MLP transforms the BERT representation\nof the special \u201c<cls>\u201d token, which encodes the information of both the premise and the\nhypothesis, intothreeoutputsofnaturallanguageinference: entailment, contradiction, and\nneutral.\nclass BERTClassifier (nn.Module):\ndef __init__ (self , bert):\nsuper (BERTClassifier, self ).__init__ ()\nself .encoder =bert .encoder\nself .hidden =bert .hidden\nself .output =nn.LazyLinear( 3)\ndef forward (self , inputs):\ntokens_X, segments_X, valid_lens_x =inputs\nencoded_X =self .encoder(tokens_X, segments_X, valid_lens_x)\nreturn self .output( self .hidden(encoded_X[:, 0, :]))\nInthefollowing,thepretrainedBERTmodel bertisfedintothe BERTClassifier instance\nnetfor the downstream application. In common implementations of BERT fine-tuning,\nonlytheparametersoftheoutputlayeroftheadditionalMLP( net.output )willbelearned\nfrom scratch. All the parameters of the pretrained BERT encoder ( net.encoder ) and the\nhidden layer of the additional MLP ( net.hidden ) will be fine-tuned.\nnet =BERTClassifier(bert)\nRecall that in Section 15.8 both the MaskLMclass and the NextSentencePred class have\nparameters in their employed MLPs. These parameters are part of those in the pretrained\nBERT model bert, and thus part of parameters in net. However, such parameters are\n779 Natural Language Inference: Fine-Tuning BERT\nonly for computing the masked language modeling loss and the next sentence prediction\nloss during pretraining. These two loss functions are irrelevant to fine-tuning downstream\napplications,thustheparametersoftheemployedMLPsin MaskLMandNextSentencePred\nare not updated (staled) when BERT is fine-tuned.\nTo allow parameters with stale gradients, the flag ignore_stale_grad=True is set in the\nstepfunction of d2l.train_batch_ch13 . We use this function to train and evaluate the\nmodel netusing the training set ( train_iter ) and the testing set ( test_iter ) of SNLI.\nDuetothelimitedcomputationalresources,thetrainingandtestingaccuracycanbefurther\nimproved: we leave its discussions in the exercises.\nlr, num_epochs =1e-4 ,5\ntrainer =torch .optim .Adam(net .parameters(), lr =lr)\nloss =nn.CrossEntropyLoss(reduction ='none ')\nnet( next (iter (train_iter))[ 0])\nd2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)\nloss 0.520 , train acc 0.791 , test acc 0.786\n10588.8 examples /sec on [device( type ='cuda ', index =0), device( type ='cuda ',\u2423\n\u21a9!index =1)]\n16.7.4Summary\n\u000fWe can fine-tune the pretrained BERT model for downstream applications, such as nat-\nural language inference on the SNLI dataset.\n\u000fDuring fine-tuning, the BERT model becomes part of the model for the downstream\napplication. Parameters that are only related to pretraining loss will not be updated\nduring fine-tuning.\n16.7.5Exercises\n1.Fine-tuneamuchlargerpretrainedBERTmodelthatisaboutasbigastheoriginalBERT\nbasemodelifyourcomputationalresourceallows. Setargumentsinthe load_pretrained_model\nfunctionas: replacing\u2018bert.small\u2019with\u2018bert.base\u2019,increasingvaluesof num_hiddens=256 ,\nffn_num_hiddens=512 ,num_heads=4 , and num_blks=2 to 768, 3072, 12, and 12, re-\n780 Natural Language Processing: Applications\n249spectively. By increasing fine-tuning epochs (and possibly tuning other hyperparame-\nters), can you get a testing accuracy higher than 0.86?\n2.How to truncate a pair of sequences according to their ratio of length? Compare this\npair truncation method and the one used in the SNLIBERTDataset class. What are their\npros and cons?\nDiscussions249.\n250\n17 Reinforcement Learning\nPratik Chaudhari (University of Pennsylvania and Amazon ),Rasool Fakoor (Amazon),\nandKavoshAsadi (Amazon)\nReinforcementLearning(RL)isasuiteoftechniquesthatallowsustobuildmachinelearn-\ningsystemsthattakedecisionssequentially.", "mimetype": "text/plain", "start_char_idx": 1644178, "end_char_idx": 1648122, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1068d22a-9227-4c98-b10a-60b728b278c4": {"__data__": {"id_": "1068d22a-9227-4c98-b10a-60b728b278c4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9e5d968f-e9bb-4018-84b7-5cc22b9acf9d", "node_type": "1", "metadata": {}, "hash": "d296f0c2828b33ac18b3e820058ee47753488d0e925a7a9af13e2bd128799209", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a456d989-0671-4f8b-b2e0-f59f3dbfda16", "node_type": "1", "metadata": {}, "hash": "591e524c8ed2e897194e534c15b0ab2938ba0a628e34d46e0c831a5735d8cb85", "class_name": "RelatedNodeInfo"}}, "text": "By increasing fine-tuning epochs (and possibly tuning other hyperparame-\nters), can you get a testing accuracy higher than 0.86?\n2.How to truncate a pair of sequences according to their ratio of length? Compare this\npair truncation method and the one used in the SNLIBERTDataset class. What are their\npros and cons?\nDiscussions249.\n250\n17 Reinforcement Learning\nPratik Chaudhari (University of Pennsylvania and Amazon ),Rasool Fakoor (Amazon),\nandKavoshAsadi (Amazon)\nReinforcementLearning(RL)isasuiteoftechniquesthatallowsustobuildmachinelearn-\ningsystemsthattakedecisionssequentially. Forexample,apackagecontainingnewclothes\nthat you purchased from an online retailer arrives at your doorstep after a sequence of de-\ncisions, e.g., the retailer finding the clothes in the warehouse closest to your house, putting\nthe clothes in a box, transporting the box via land or by air, and delivering it to your house\nwithin the city. There are many variables that affect the delivery of the package along the\nway, e.g., whether or not the clothes were available in the warehouse, how long it took to\ntransport the box, whether it arrived in your city before the daily delivery truck left, etc.\nThe key idea is that at each stage these variables that we do not often control affect the\nentire sequence of events in the future, e.g., if there were delays in packing the box in the\nwarehouse the retailer may need to send the package via air instead of ground to ensure a\ntimely delivery. Reinforcement Learning methods allow us to take the appropriate action\nat each stage of a sequential decision making problem in order to maximize some utility\neventually, e.g., the timely delivery of the package to you.\nSuch sequential decision making problems are seen in numerous other places, e.g., while\nplayingGo250yourcurrent move determines the next moves and the opponent\u2019s movesare\nthevariablesthatyoucannotcontrol\u2026asequenceofmoveseventuallydetermineswhether\nornotyouwin; themoviesthatNetflixrecommendstoyounowdeterminewhatyouwatch,\nwhether you like the movie or not is unknown to Netflix, eventually a sequence of movie\nrecommendations determines how satisfied you are with Netflix. Reinforcement learning\nis being used today to develop effective solutions to these problems ( Mnihet al., 2013,\nSilveretal., 2016). The key distinction between reinforcement learning and standard deep\nlearningisthatinstandarddeeplearningthepredictionofatrainedmodelononetestdatum\ndoes not affect the predictions on a future test datum; in reinforcement learning decisions\nat future instants (in RL, decisions are also called actions) are affected by what decisions\nwere made in the past.\nIn this chapter, we will develop the fundamentals of reinforcement learning and obtain\nhands-on experience in implementing some popular reinforcement learning methods. We\nwill first develop a concept called a Markov Decision Process (MDP) which allows us to\nthink of such sequential decision making problems. An algorithm called Value Iteration\nwill be our first insight into solving reinforcement learning problems under the assumption\nthat we know how the uncontrolled variables in an MDP (in RL, these controlled variables\n781\n782 Reinforcement Learning\nare called the environment) typically behave. Using the more general version of Value\nIteration, an algorithm called Q-Learning, we will be able to take appropriate actions even\nwhen we do not necessarily have full knowledge of the environment. We will then study\nhow to use deep networks for reinforcement learning problems by imitating the actions of\nan expert. And finally, we will develop a reinforcement learning method that uses a deep\nnetworktotakeactionsinunknownenvironments. Thesetechniquesformthebasisofmore\nadvanced RL algorithms that are used today in a variety of real-world applications, some\nof which we will point to in the chapter.\ntFig. 17.1 Reinforcement Learning Structure\n17.1MarkovDecision Process(MDP)\nIn this section, we will discuss how to formulate reinforcement learning problems using\nMarkov decision processes (MDPs) and describe various components of MDPs in de-\ntail.\n17.1.1Definition of an MDP\nAMarkovdecisionprocess(MDP)( Bellman,1957 )isamodelforhowthestateofasystem\nevolves as different actions are applied to the system. A few different quantities come\ntogether to form an MDP.\n\u000fLetSbe the set of states in the MDP. As a concrete example see Fig. 17.1.1 , for a robot\nthat is navigating a gridworld.", "mimetype": "text/plain", "start_char_idx": 1647536, "end_char_idx": 1651989, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a456d989-0671-4f8b-b2e0-f59f3dbfda16": {"__data__": {"id_": "a456d989-0671-4f8b-b2e0-f59f3dbfda16", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1068d22a-9227-4c98-b10a-60b728b278c4", "node_type": "1", "metadata": {}, "hash": "8421c9991763a329c856004f230b750f912a12655f75e1d25ff455493f85d923", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3025ae38-324e-4b42-8ac6-cbbd067deb63", "node_type": "1", "metadata": {}, "hash": "67b19c0c012b5db0f1ddb6d0259787e9d02aac44f5e52236ceaef033cd31b9a0", "class_name": "RelatedNodeInfo"}}, "text": "Thesetechniquesformthebasisofmore\nadvanced RL algorithms that are used today in a variety of real-world applications, some\nof which we will point to in the chapter.\ntFig. 17.1 Reinforcement Learning Structure\n17.1MarkovDecision Process(MDP)\nIn this section, we will discuss how to formulate reinforcement learning problems using\nMarkov decision processes (MDPs) and describe various components of MDPs in de-\ntail.\n17.1.1Definition of an MDP\nAMarkovdecisionprocess(MDP)( Bellman,1957 )isamodelforhowthestateofasystem\nevolves as different actions are applied to the system. A few different quantities come\ntogether to form an MDP.\n\u000fLetSbe the set of states in the MDP. As a concrete example see Fig. 17.1.1 , for a robot\nthat is navigating a gridworld. In this case, Scorresponds to the set of locations that\nthe robot can be at any given timestep.\n\u000fLetAbe the set of actions that the robot can take at each state, e.g., \u201cgo forward\u201d, \u201cturn\n783 Markov Decision Process (MDP)\ntFig. 17.1.1 A simple gridworld navigation task where the robot not only has to \ufb01nd its way to the goal\nlocation (shown as a green house) but also has to avoid trap locations (shown as red cross\nsigns).\nright\u201d, \u201cturn left\u201d, \u201cstay at the same location\u201d, etc. Actions can change the current\nstate of the robot to some other state within the set S.\n\u000fIt may happen that we do not know how the robot moves exactlybut only know it up to\nsome approximation. We model this situation in reinforcement learning as follows: if\nthe robot takes an action \u201cgo forward\u201d, there might be a small probability that it stays\nat the current state, another small probability that it \u201cturns left\u201d, etc. Mathematically,\nthis amounts to defining a \u201ctransition function\u201d \ud835\udc47:S\u0002A\u0002S!\u00bb 0,1\u00bcsuch that\n\ud835\udc47\u00b9\ud835\udc60,\ud835\udc4e,\ud835\udc600\u00ba=\ud835\udc43\u00b9\ud835\udc600j\ud835\udc60,\ud835\udc4e\u00bausing the conditional probability of reaching a state \ud835\udc600given\nthattherobotwasatstate \ud835\udc60andtookanaction \ud835\udc4e. Thetransitionfunctionisaprobability\ndistribution and we therefore have\u00cd\n\ud835\udc6002S\ud835\udc47\u00b9\ud835\udc60,\ud835\udc4e,\ud835\udc600\u00ba=1for all\ud835\udc602Sand\ud835\udc4e2A, i.e.,\nthe robot has to go to some state if it takes an action.\n\u000fWe now construct a notion of which actions are useful and which ones are not using the\nconcept of a \u201creward\u201d \ud835\udc5f:S\u0002A! R. We say that the robot gets a reward \ud835\udc5f\u00b9\ud835\udc60,\ud835\udc4e\u00ba\nif the robot takes an action \ud835\udc4eat state\ud835\udc60. If the reward \ud835\udc5f\u00b9\ud835\udc60,\ud835\udc4e\u00bais large, this indicates\nthat taking the action \ud835\udc4eat state\ud835\udc60is more useful to achieving the goal of the robot, i.e.,\ngoing to the green house. If the reward \ud835\udc5f\u00b9\ud835\udc60,\ud835\udc4e\u00bais small, then action \ud835\udc4eis less useful to\nachieving this goal. It is important to note that the reward is designed by the user (the\nperson who creates the reinforcement learning algorithm) with the goal in mind.\n17.1.2Returnand Discount Factor\nThe different components above together form a Markov decision process (MDP)\nMDP :\u00b9S,A,\ud835\udc47,\ud835\udc5f\u00ba. (17.1.1)\n784 Reinforcement Learning\nLet\u2019s now consider the situation when the robot starts at a particular state \ud835\udc6002 Sand\ncontinues taking actions to result in a trajectory\n\ud835\udf0f=\u00b9\ud835\udc600,\ud835\udc4e0,\ud835\udc5f0,\ud835\udc601,\ud835\udc4e1,\ud835\udc5f1,\ud835\udc602,\ud835\udc4e2,\ud835\udc5f2,...\u00ba. (17.1.2)\nAt each time step \ud835\udc61the robot is at a state \ud835\udc60\ud835\udc61and takes an action \ud835\udc4e\ud835\udc61which results in a reward\n\ud835\udc5f\ud835\udc61=\ud835\udc5f\u00b9\ud835\udc60\ud835\udc61,\ud835\udc4e\ud835\udc61\u00ba.", "mimetype": "text/plain", "start_char_idx": 1651238, "end_char_idx": 1654317, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3025ae38-324e-4b42-8ac6-cbbd067deb63": {"__data__": {"id_": "3025ae38-324e-4b42-8ac6-cbbd067deb63", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a456d989-0671-4f8b-b2e0-f59f3dbfda16", "node_type": "1", "metadata": {}, "hash": "591e524c8ed2e897194e534c15b0ab2938ba0a628e34d46e0c831a5735d8cb85", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "42461474-7491-4d56-9021-ccd0ebb6d537", "node_type": "1", "metadata": {}, "hash": "ad1da94c23c3d5980a8f24e251bd8a7d5652d11ad9bfdf49642153a8fd437c83", "class_name": "RelatedNodeInfo"}}, "text": "(17.1.1)\n784 Reinforcement Learning\nLet\u2019s now consider the situation when the robot starts at a particular state \ud835\udc6002 Sand\ncontinues taking actions to result in a trajectory\n\ud835\udf0f=\u00b9\ud835\udc600,\ud835\udc4e0,\ud835\udc5f0,\ud835\udc601,\ud835\udc4e1,\ud835\udc5f1,\ud835\udc602,\ud835\udc4e2,\ud835\udc5f2,...\u00ba. (17.1.2)\nAt each time step \ud835\udc61the robot is at a state \ud835\udc60\ud835\udc61and takes an action \ud835\udc4e\ud835\udc61which results in a reward\n\ud835\udc5f\ud835\udc61=\ud835\udc5f\u00b9\ud835\udc60\ud835\udc61,\ud835\udc4e\ud835\udc61\u00ba. Thereturnof a trajectory is the total reward obtained by the robot along\nsuch a trajectory\n\ud835\udc45\u00b9\ud835\udf0f\u00ba=\ud835\udc5f0\u00b8\ud835\udc5f1\u00b8\ud835\udc5f2\u00b8\u0001\u0001\u0001. (17.1.3)\nThe goal in reinforcement learning is to find a trajectory that has the largest return.\nThink of the situation when the robot continues to travel in the gridworld without ever\nreaching the goal location. The sequence of states and actions in a trajectory can be in-\nfinitelylonginthiscaseandthe returnofanysuchinfinitelylongtrajectorywillbeinfinite.\nIn order to keep the reinforcement learning formulation meaningful even for such trajecto-\nries, we introduce the notion of a discount factor \ud835\udefe < 1. We write the discounted return\nas\n\ud835\udc45\u00b9\ud835\udf0f\u00ba=\ud835\udc5f0\u00b8\ud835\udefe\ud835\udc5f1\u00b8\ud835\udefe2\ud835\udc5f2\u00b8\u0001\u0001\u0001=1\u00d5\n\ud835\udc61=0\ud835\udefe\ud835\udc61\ud835\udc5f\ud835\udc61. (17.1.4)\nNote that if \ud835\udefeis very small, the rewards earned by the robot in the far future, say \ud835\udc61=\n1000, are heavily discounted by the factor \ud835\udefe1000. This encourages the robot to select short\ntrajectories that achieve its goal, namely that of going to the green house in the gridwold\nexample (see Fig. 17.1.1 ). For large values of the discount factor, say \ud835\udefe=0.99, the robot\nis encouraged to exploreand then find the best trajectory to go to the goal location.\n17.1.3Discussionof the MarkovAssumption\nLet us think of a new robot where the state \ud835\udc60\ud835\udc61is the location as above but the action \ud835\udc4e\ud835\udc61is\ntheaccelerationthattherobotappliestoitswheelsinsteadofanabstractcommandlike\u201cgo\nforward\u201d. If this robot has some non-zero velocity at state \ud835\udc60\ud835\udc61, then the next location \ud835\udc60\ud835\udc61\u00b81is\na function of the past location \ud835\udc60\ud835\udc61, the acceleration \ud835\udc4e\ud835\udc61, also the velocity of the robot at time\n\ud835\udc61which is proportional to \ud835\udc60\ud835\udc61\u0000\ud835\udc60\ud835\udc61\u00001. This indicates that we should have\n\ud835\udc60\ud835\udc61\u00b81=some function\u00b9\ud835\udc60\ud835\udc61,\ud835\udc4e\ud835\udc61,\ud835\udc60\ud835\udc61\u00001\u00ba; (17.1.5)\nthe \u201csome function\u201d in our case would be Newton\u2019s law of motion. This is quite different\nfrom our transition function that simply depends upon \ud835\udc60\ud835\udc61and\ud835\udc4e\ud835\udc61.\nMarkov systems are all systems where the next state \ud835\udc60\ud835\udc61\u00b81is only a function of the current\nstate\ud835\udc60\ud835\udc61and the action \ud835\udc4e\ud835\udc61taken at the current state. In Markov systems, the next state does\nnot depend on which actions were taken in the past or the states that the robot was at in the\npast. Forexample, thenewrobotthathasaccelerationastheactionaboveisnotMarkovian\nbecause the next location \ud835\udc60\ud835\udc61\u00b81depends upon the previous state \ud835\udc60\ud835\udc61\u00001through the velocity.\nIt may seem that Markovian nature of a system is a restrictive assumption, but it is not so.\nMarkov Decision Processes are still capable of modeling a very large class of real systems.", "mimetype": "text/plain", "start_char_idx": 1653994, "end_char_idx": 1656749, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "42461474-7491-4d56-9021-ccd0ebb6d537": {"__data__": {"id_": "42461474-7491-4d56-9021-ccd0ebb6d537", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3025ae38-324e-4b42-8ac6-cbbd067deb63", "node_type": "1", "metadata": {}, "hash": "67b19c0c012b5db0f1ddb6d0259787e9d02aac44f5e52236ceaef033cd31b9a0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "03a96b86-71c1-439a-b005-0fabbb0c29bb", "node_type": "1", "metadata": {}, "hash": "1c8223a96883aeb838df8482fd21aa05618545cbdf14470fd26c481f5222287a", "class_name": "RelatedNodeInfo"}}, "text": "Markov systems are all systems where the next state \ud835\udc60\ud835\udc61\u00b81is only a function of the current\nstate\ud835\udc60\ud835\udc61and the action \ud835\udc4e\ud835\udc61taken at the current state. In Markov systems, the next state does\nnot depend on which actions were taken in the past or the states that the robot was at in the\npast. Forexample, thenewrobotthathasaccelerationastheactionaboveisnotMarkovian\nbecause the next location \ud835\udc60\ud835\udc61\u00b81depends upon the previous state \ud835\udc60\ud835\udc61\u00001through the velocity.\nIt may seem that Markovian nature of a system is a restrictive assumption, but it is not so.\nMarkov Decision Processes are still capable of modeling a very large class of real systems.\nFor example, for our new robot, if we chose our state \ud835\udc60\ud835\udc61to the tuple\u00b9location,velocity\u00ba\n785 Value Iteration\n251\n252\n253then the system is Markovian because its next state \u00b9location\ud835\udc61\u00b81,velocity\ud835\udc61\u00b81\u00badepends only\nupon the current state \u00b9location\ud835\udc61,velocity\ud835\udc61\u00baand the action at the current state \ud835\udc4e\ud835\udc61.\n17.1.4Summary\nThe reinforcement learning problem is typically modeled using Markov Decision Pro-\ncesses. AMarkovdecisionprocess(MDP)isdefinedbyatupleoffourentities \u00b9S,A,\ud835\udc47,\ud835\udc5f\u00ba\nwhereSis the state space,Ais the action space, \ud835\udc47is the transition function that encodes\nthe transition probabilities of the MDP and \ud835\udc5fis the immediate reward obtained by taking\naction at a particular state.\n17.1.5Exercises\n1.Suppose that we want to design an MDP to model MountainCar251problem.\n1.What would be the set of states?\n2.What would be the set of actions?\n3.What would be the possible reward functions?\n2.How would you design an MDP for an Atari game like Pong game252?\nDiscussions253.\n17.2ValueIteration\nIn this section we will discuss how to pick the best action for the robot at each state to\nmaximize the returnof the trajectory. We will describe an algorithm called Value Iteration\nand implement it for a simulated robot that travels over a frozen lake.\n17.2.1StochasticPolicy\nA stochastic policy denoted as \ud835\udf0b\u00b9\ud835\udc4ej\ud835\udc60\u00ba(policy for short) is a conditional distribution over\nthe actions\ud835\udc4e2Agiven the state \ud835\udc602S,\ud835\udf0b\u00b9\ud835\udc4ej\ud835\udc60\u00ba\u0011\ud835\udc43\u00b9\ud835\udc4ej\ud835\udc60\u00ba. As an example, if the\nrobot has four actions A={go left, go down, go right, go up}. The policy at a state\n\ud835\udc602Sfor such a set of actions Ais a categorical distribution where the probabilities of\nthe four actions could be \u00bb0.4,0.2,0.1,0.3\u00bc; at some other state \ud835\udc6002Sthe probabilities\n\ud835\udf0b\u00b9\ud835\udc4ej\ud835\udc600\u00baof the same four actions could be \u00bb0.1,0.1,0.2,0.6\u00bc. Note that we should have\u00cd\n\ud835\udc4e\ud835\udf0b\u00b9\ud835\udc4ej\ud835\udc60\u00ba=1for any state \ud835\udc60. A deterministic policy is a special case of a stochastic\npolicy in that the distribution \ud835\udf0b\u00b9\ud835\udc4ej\ud835\udc60\u00baonly gives non-zero probability to one particular\naction, e.g.,\u00bb1,0,0,0\u00bcfor our example with four actions.\nTo make the notation less cumbersome, we will often write \ud835\udf0b\u00b9\ud835\udc60\u00baas the conditional distri-\nbution instead of \ud835\udf0b\u00b9\ud835\udc4ej\ud835\udc60\u00ba.\n786 Reinforcement Learning\n17.2.2ValueFunction\nImagine now that the robot starts at a state \ud835\udc600and at each time instant, it first samples\nan action from the policy \ud835\udc4e\ud835\udc61\u0018\ud835\udf0b\u00b9\ud835\udc60\ud835\udc61\u00baand takes this action to result in the next state\n\ud835\udc60\ud835\udc61\u00b81. The trajectory \ud835\udf0f=\u00b9\ud835\udc600,\ud835\udc4e0,\ud835\udc5f0,\ud835\udc601,\ud835\udc4e1,\ud835\udc5f1,...\u00ba, can be different depending upon which\nparticular action \ud835\udc4e\ud835\udc61is sampled at intermediate instants.", "mimetype": "text/plain", "start_char_idx": 1656123, "end_char_idx": 1659220, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "03a96b86-71c1-439a-b005-0fabbb0c29bb": {"__data__": {"id_": "03a96b86-71c1-439a-b005-0fabbb0c29bb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "42461474-7491-4d56-9021-ccd0ebb6d537", "node_type": "1", "metadata": {}, "hash": "ad1da94c23c3d5980a8f24e251bd8a7d5652d11ad9bfdf49642153a8fd437c83", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b87de440-03fc-439a-b84e-86aea492da7b", "node_type": "1", "metadata": {}, "hash": "9b0e3efa8b0e0b23f41ab563767440ff37e796d9d8e42c40edc4b08063c3f5a7", "class_name": "RelatedNodeInfo"}}, "text": "To make the notation less cumbersome, we will often write \ud835\udf0b\u00b9\ud835\udc60\u00baas the conditional distri-\nbution instead of \ud835\udf0b\u00b9\ud835\udc4ej\ud835\udc60\u00ba.\n786 Reinforcement Learning\n17.2.2ValueFunction\nImagine now that the robot starts at a state \ud835\udc600and at each time instant, it first samples\nan action from the policy \ud835\udc4e\ud835\udc61\u0018\ud835\udf0b\u00b9\ud835\udc60\ud835\udc61\u00baand takes this action to result in the next state\n\ud835\udc60\ud835\udc61\u00b81. The trajectory \ud835\udf0f=\u00b9\ud835\udc600,\ud835\udc4e0,\ud835\udc5f0,\ud835\udc601,\ud835\udc4e1,\ud835\udc5f1,...\u00ba, can be different depending upon which\nparticular action \ud835\udc4e\ud835\udc61is sampled at intermediate instants. We define the average return\n\ud835\udc45\u00b9\ud835\udf0f\u00ba=\u00cd1\n\ud835\udc61=0\ud835\udefe\ud835\udc61\ud835\udc5f\u00b9\ud835\udc60\ud835\udc61,\ud835\udc4e\ud835\udc61\u00baof all such trajectories\n\ud835\udc49\ud835\udf0b\u00b9\ud835\udc600\u00ba=\ud835\udc38\ud835\udc4e\ud835\udc61\u0018\ud835\udf0b\u00b9\ud835\udc60\ud835\udc61\u00bah\n\ud835\udc45\u00b9\ud835\udf0f\u00bai\n=\ud835\udc38\ud835\udc4e\ud835\udc61\u0018\ud835\udf0b\u00b9\ud835\udc60\ud835\udc61\u00bah1\u00d5\n\ud835\udc61=0\ud835\udefe\ud835\udc61\ud835\udc5f\u00b9\ud835\udc60\ud835\udc61,\ud835\udc4e\ud835\udc61\u00bai\n, (17.2.1)\nwhere\ud835\udc60\ud835\udc61\u00b81\u0018\ud835\udc43\u00b9\ud835\udc60\ud835\udc61\u00b81j\ud835\udc60\ud835\udc61,\ud835\udc4e\ud835\udc61\u00bais the next state of the robot and \ud835\udc5f\u00b9\ud835\udc60\ud835\udc61,\ud835\udc4e\ud835\udc61\u00bais the instantaneous\nreward obtained by taking action \ud835\udc4e\ud835\udc61in state\ud835\udc60\ud835\udc61at time\ud835\udc61. This is called the \u201cvalue function\u201d\nfor the policy \ud835\udf0b. In simple words, the value of a state \ud835\udc600for a policy\ud835\udf0b, denoted by \ud835\udc49\ud835\udf0b\u00b9\ud835\udc600\u00ba,\nis the expected \ud835\udefe-discounted returnobtained by the robot if it begins at state \ud835\udc600and takes\nactions from the policy \ud835\udf0bat each time instant.\nWe next break down the trajectory into two stages (i) the first stage which corresponds to\n\ud835\udc600!\ud835\udc601upon taking the action \ud835\udc4e0, and (ii) a second stage which is the trajectory \ud835\udf0f0=\n\u00b9\ud835\udc601,\ud835\udc4e1,\ud835\udc5f1,...\u00bathereafter. The key idea behind all algorithms in reinforcement learning is\nthat the value of state \ud835\udc600can be written as the average reward obtained in the first stage\nand the value function averaged over all possible next states \ud835\udc601. This is quite intuitive and\narises from our Markov assumption: the average return from the current state is the sum\nof the average return from the next state and the average reward of going to the next state.\nMathematically, we write the two stages as\n\ud835\udc49\ud835\udf0b\u00b9\ud835\udc600\u00ba=\ud835\udc5f\u00b9\ud835\udc600,\ud835\udc4e0\u00ba\u00b8\ud835\udefe\ud835\udc38\ud835\udc4e0\u0018\ud835\udf0b\u00b9\ud835\udc600\u00bah\n\ud835\udc38\ud835\udc601\u0018\ud835\udc43\u00b9\ud835\udc601j\ud835\udc600,\ud835\udc4e0\u00bah\n\ud835\udc49\ud835\udf0b\u00b9\ud835\udc601\u00baii\n. (17.2.2)\nThis decomposition is very powerful: it is the foundation of the principle of dynamic pro-\ngramming upon which all reinforcement learning algorithms are based. Notice that the\nsecond stage gets two expectations, one over the choices of the action \ud835\udc4e0taken in the first\nstage using the stochastic policy and another over the possible states \ud835\udc601obtained from the\nchosen action. We can write (17.2.2 )using the transition probabilities in the Markov de-\ncision process (MDP) as\n\ud835\udc49\ud835\udf0b\u00b9\ud835\udc60\u00ba=\u00d5\n\ud835\udc4e2A\ud835\udf0b\u00b9\ud835\udc4ej\ud835\udc60\u00bah\n\ud835\udc5f\u00b9\ud835\udc60,\ud835\udc4e\u00ba\u00b8\ud835\udefe\u00d5\n\ud835\udc6002S\ud835\udc43\u00b9\ud835\udc600j\ud835\udc60,\ud835\udc4e\u00ba\ud835\udc49\ud835\udf0b\u00b9\ud835\udc600\u00bai\n;for all\ud835\udc602S.", "mimetype": "text/plain", "start_char_idx": 1658742, "end_char_idx": 1661042, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b87de440-03fc-439a-b84e-86aea492da7b": {"__data__": {"id_": "b87de440-03fc-439a-b84e-86aea492da7b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "03a96b86-71c1-439a-b005-0fabbb0c29bb", "node_type": "1", "metadata": {}, "hash": "1c8223a96883aeb838df8482fd21aa05618545cbdf14470fd26c481f5222287a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3feced31-14f1-4a7a-b2d5-36c9ad3a36db", "node_type": "1", "metadata": {}, "hash": "11be3bb31e0a2dc0398c76f6a4121c668f193e403e785f04d6461fe65fcc17d3", "class_name": "RelatedNodeInfo"}}, "text": "Notice that the\nsecond stage gets two expectations, one over the choices of the action \ud835\udc4e0taken in the first\nstage using the stochastic policy and another over the possible states \ud835\udc601obtained from the\nchosen action. We can write (17.2.2 )using the transition probabilities in the Markov de-\ncision process (MDP) as\n\ud835\udc49\ud835\udf0b\u00b9\ud835\udc60\u00ba=\u00d5\n\ud835\udc4e2A\ud835\udf0b\u00b9\ud835\udc4ej\ud835\udc60\u00bah\n\ud835\udc5f\u00b9\ud835\udc60,\ud835\udc4e\u00ba\u00b8\ud835\udefe\u00d5\n\ud835\udc6002S\ud835\udc43\u00b9\ud835\udc600j\ud835\udc60,\ud835\udc4e\u00ba\ud835\udc49\ud835\udf0b\u00b9\ud835\udc600\u00bai\n;for all\ud835\udc602S.(17.2.3)\nAnimportantthingtonoticehereisthattheaboveidentityholdsforallstates \ud835\udc602Sbecause\nwe can think of any trajectory that begins at that state and break down the trajectory into\ntwo stages.\n17.2.3Action-ValueFunction\nIn implementations, it is often useful to maintain a quantity called the \u201caction value\u201d func-\ntion which is a closely related quantity to the value function. This is defined to be the\naveragereturnof a trajectory that begins at \ud835\udc600but when the action of the first stage is fixed\n787 Value Iteration\nto be\ud835\udc4e0\n\ud835\udc44\ud835\udf0b\u00b9\ud835\udc600,\ud835\udc4e0\u00ba=\ud835\udc5f\u00b9\ud835\udc600,\ud835\udc4e0\u00ba\u00b8\ud835\udc38\ud835\udc4e\ud835\udc61\u0018\ud835\udf0b\u00b9\ud835\udc60\ud835\udc61\u00bah1\u00d5\n\ud835\udc61=1\ud835\udefe\ud835\udc61\ud835\udc5f\u00b9\ud835\udc60\ud835\udc61,\ud835\udc4e\ud835\udc61\u00bai\n, (17.2.4)\nnote that the summation inside the expectation is from \ud835\udc61=1,...,1because the reward of\nthe first stage is fixed in this case. We can again break down the trajectory into two parts\nand write\n\ud835\udc44\ud835\udf0b\u00b9\ud835\udc60,\ud835\udc4e\u00ba=\ud835\udc5f\u00b9\ud835\udc60,\ud835\udc4e\u00ba\u00b8\ud835\udefe\u00d5\n\ud835\udc6002S\ud835\udc43\u00b9\ud835\udc600j\ud835\udc60,\ud835\udc4e\u00ba\u00d5\n\ud835\udc4e02A\ud835\udf0b\u00b9\ud835\udc4e0j\ud835\udc600\u00ba\ud835\udc44\ud835\udf0b\u00b9\ud835\udc600,\ud835\udc4e0\u00ba;for all\ud835\udc602S,\ud835\udc4e2A.\n(17.2.5)\nThis version is the analog of (17.2.3 )for the action value function.\n17.2.4OptimalStochasticPolicy\nBoththevaluefunctionandtheaction-valuefunctiondependuponthepolicythattherobot\nchooses. We will next think of the \u201coptimal policy\u201d that achieves the maximal average\nreturn\n\ud835\udf0b\u0003=argmax\n\ud835\udf0b\ud835\udc49\ud835\udf0b\u00b9\ud835\udc600\u00ba. (17.2.6)\nOf all possible stochastic policies that the robot could have taken, the optimal policy \ud835\udf0b\u0003\nachieves the largest average discounted returnfor trajectories starting from state \ud835\udc600. Let us\ndenote the value function and the action-value function of the optimal policy as \ud835\udc49\u0003\u0011\ud835\udc49\ud835\udf0b\u0003\nand\ud835\udc44\u0003\u0011\ud835\udc44\ud835\udf0b\u0003.\nLet us observe that for a deterministic policy where there is only one action that is possible\nunder the policy at any given state. This gives us\n\ud835\udf0b\u0003\u00b9\ud835\udc60\u00ba=argmax\n\ud835\udc4e2Ah\n\ud835\udc5f\u00b9\ud835\udc60,\ud835\udc4e\u00ba\u00b8\ud835\udefe\u00d5\n\ud835\udc6002S\ud835\udc43\u00b9\ud835\udc600j\ud835\udc60,\ud835\udc4e\u00ba\ud835\udc49\u0003\u00b9\ud835\udc600\u00bai\n.(17.2.7)\nA good mnemonic to remember this is that the optimal action at state \ud835\udc60(for a deterministic\npolicy) is the one that maximizes the sum of reward \ud835\udc5f\u00b9\ud835\udc60,\ud835\udc4e\u00bafrom the first stage and the\naveragereturnof the trajectories starting from the next sate \ud835\udc600, averaged over all possible\nnext states\ud835\udc600from the second stage.", "mimetype": "text/plain", "start_char_idx": 1660667, "end_char_idx": 1662987, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3feced31-14f1-4a7a-b2d5-36c9ad3a36db": {"__data__": {"id_": "3feced31-14f1-4a7a-b2d5-36c9ad3a36db", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b87de440-03fc-439a-b84e-86aea492da7b", "node_type": "1", "metadata": {}, "hash": "9b0e3efa8b0e0b23f41ab563767440ff37e796d9d8e42c40edc4b08063c3f5a7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "be4607c6-9c12-4dad-b226-ec6a1ff03a17", "node_type": "1", "metadata": {}, "hash": "e7e276e6844a144d4a81d624665e55eb92622ee3e420e4f8a7c762764cb5e6ce", "class_name": "RelatedNodeInfo"}}, "text": "Let us observe that for a deterministic policy where there is only one action that is possible\nunder the policy at any given state. This gives us\n\ud835\udf0b\u0003\u00b9\ud835\udc60\u00ba=argmax\n\ud835\udc4e2Ah\n\ud835\udc5f\u00b9\ud835\udc60,\ud835\udc4e\u00ba\u00b8\ud835\udefe\u00d5\n\ud835\udc6002S\ud835\udc43\u00b9\ud835\udc600j\ud835\udc60,\ud835\udc4e\u00ba\ud835\udc49\u0003\u00b9\ud835\udc600\u00bai\n.(17.2.7)\nA good mnemonic to remember this is that the optimal action at state \ud835\udc60(for a deterministic\npolicy) is the one that maximizes the sum of reward \ud835\udc5f\u00b9\ud835\udc60,\ud835\udc4e\u00bafrom the first stage and the\naveragereturnof the trajectories starting from the next sate \ud835\udc600, averaged over all possible\nnext states\ud835\udc600from the second stage.\n17.2.5Principle of Dynamic Programming\nOur developement in the previous section in (17.2.2 )or(17.2.5 )can be turned into an\nalgorithm to compute the optimal value function \ud835\udc49\u0003or the action-value function \ud835\udc44\u0003, re-\nspectively. Observe that\n\ud835\udc49\u0003\u00b9\ud835\udc60\u00ba=\u00d5\n\ud835\udc4e2A\ud835\udf0b\u0003\u00b9\ud835\udc4ej\ud835\udc60\u00bah\n\ud835\udc5f\u00b9\ud835\udc60,\ud835\udc4e\u00ba\u00b8\ud835\udefe\u00d5\n\ud835\udc6002S\ud835\udc43\u00b9\ud835\udc600j\ud835\udc60,\ud835\udc4e\u00ba\ud835\udc49\u0003\u00b9\ud835\udc600\u00bai\n;for all\ud835\udc602S.(17.2.8)\nFor a deterministic optimal policy \ud835\udf0b\u0003, since there is only one action that can be taken at\nstate\ud835\udc60, we can also write\n\ud835\udc49\u0003\u00b9\ud835\udc60\u00ba=argmax\ud835\udc4e2An\n\ud835\udc5f\u00b9\ud835\udc60,\ud835\udc4e\u00ba\u00b8\ud835\udefe\u00d5\n\ud835\udc6002S\ud835\udc43\u00b9\ud835\udc600j\ud835\udc60,\ud835\udc4e\u00ba\ud835\udc49\u0003\u00b9\ud835\udc600\u00bao\n(17.2.9)\n788 Reinforcement Learning\nfor all states \ud835\udc602S. This identity is called the \u201cprinciple of dynamic programming\u201d ( Bell-\nman, 1952 ,Bellman, 1957 ). It was formulated by Richard Bellman in 1950s and we can\nremember it as \u201cthe remainder of an optimal trajectory is also optimal\u201d.\n17.2.6ValueIteration\nWecanturntheprincipleofdynamicprogrammingintoanalgorithmforfindingtheoptimal\nvalue function called value iteration. The key idea behind value iteration is to think of this\nidentity as a set of constraints that tie together \ud835\udc49\u0003\u00b9\ud835\udc60\u00baat different states \ud835\udc602S. We initialize\nthe value function to some arbitrary values \ud835\udc490\u00b9\ud835\udc60\u00bafor all states \ud835\udc602S. At the\ud835\udc58thiteration,\nthe Value Iteration algorithm updates the value function as\n\ud835\udc49\ud835\udc58\u00b81\u00b9\ud835\udc60\u00ba=max\n\ud835\udc4e2An\n\ud835\udc5f\u00b9\ud835\udc60,\ud835\udc4e\u00ba\u00b8\ud835\udefe\u00d5\n\ud835\udc6002S\ud835\udc43\u00b9\ud835\udc600j\ud835\udc60,\ud835\udc4e\u00ba\ud835\udc49\ud835\udc58\u00b9\ud835\udc600\u00bao\n;for all\ud835\udc602S.(17.2.10)\nIt turns out that as \ud835\udc58!1the value function estimated by the Value Iteration algorithm\nconverges to the optimal value function irrespective of the initialization \ud835\udc490,\n\ud835\udc49\u0003\u00b9\ud835\udc60\u00ba=lim\n\ud835\udc58!1\ud835\udc49\ud835\udc58\u00b9\ud835\udc60\u00ba;for all states \ud835\udc602S. (17.2.11)\nThesameValueIterationalgorithmcanbeequivalentlywrittenusingtheaction-valuefunc-\ntion as\n\ud835\udc44\ud835\udc58\u00b81\u00b9\ud835\udc60,\ud835\udc4e\u00ba=\ud835\udc5f\u00b9\ud835\udc60,\ud835\udc4e\u00ba\u00b8\ud835\udefemax\n\ud835\udc4e02A\u00d5\n\ud835\udc6002S\ud835\udc43\u00b9\ud835\udc600j\ud835\udc60,\ud835\udc4e\u00ba\ud835\udc44\ud835\udc58\u00b9\ud835\udc600,\ud835\udc4e0\u00ba;for all\ud835\udc602S,\ud835\udc4e2A.\n(17.2.12)\nIn this case we initialize \ud835\udc440\u00b9\ud835\udc60,\ud835\udc4e\u00bato some arbitrary values for all \ud835\udc602Sand\ud835\udc4e2A.", "mimetype": "text/plain", "start_char_idx": 1662477, "end_char_idx": 1664710, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "be4607c6-9c12-4dad-b226-ec6a1ff03a17": {"__data__": {"id_": "be4607c6-9c12-4dad-b226-ec6a1ff03a17", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3feced31-14f1-4a7a-b2d5-36c9ad3a36db", "node_type": "1", "metadata": {}, "hash": "11be3bb31e0a2dc0398c76f6a4121c668f193e403e785f04d6461fe65fcc17d3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "13a6febd-9565-42bf-bcbc-9fb6623c8637", "node_type": "1", "metadata": {}, "hash": "5aa911572b57ab0c423024a417d83f913051ce5c635f329236bc3e4cc3372ce8", "class_name": "RelatedNodeInfo"}}, "text": "(17.2.11)\nThesameValueIterationalgorithmcanbeequivalentlywrittenusingtheaction-valuefunc-\ntion as\n\ud835\udc44\ud835\udc58\u00b81\u00b9\ud835\udc60,\ud835\udc4e\u00ba=\ud835\udc5f\u00b9\ud835\udc60,\ud835\udc4e\u00ba\u00b8\ud835\udefemax\n\ud835\udc4e02A\u00d5\n\ud835\udc6002S\ud835\udc43\u00b9\ud835\udc600j\ud835\udc60,\ud835\udc4e\u00ba\ud835\udc44\ud835\udc58\u00b9\ud835\udc600,\ud835\udc4e0\u00ba;for all\ud835\udc602S,\ud835\udc4e2A.\n(17.2.12)\nIn this case we initialize \ud835\udc440\u00b9\ud835\udc60,\ud835\udc4e\u00bato some arbitrary values for all \ud835\udc602Sand\ud835\udc4e2A. Again\nwe have\ud835\udc44\u0003\u00b9\ud835\udc60,\ud835\udc4e\u00ba=lim\ud835\udc58!1\ud835\udc44\ud835\udc58\u00b9\ud835\udc60,\ud835\udc4e\u00bafor all\ud835\udc602Sand\ud835\udc4e2A.\n17.2.7Policy Evaluation\nValue Iteration enables us to compute the optimal value function, i.e., \ud835\udc49\ud835\udf0b\u0003of the optimal\ndeterministic policy \ud835\udf0b\u0003. We can also use similar iterative updates to compute the value\nfunction associated with any other, potentially stochastic, policy \ud835\udf0b. We again initialize\n\ud835\udc49\ud835\udf0b\n0\u00b9\ud835\udc60\u00bato some arbitrary values for all states \ud835\udc602Sand at the\ud835\udc58thiteration, perform the\nupdates\n\ud835\udc49\ud835\udf0b\n\ud835\udc58\u00b81\u00b9\ud835\udc60\u00ba=\u00d5\n\ud835\udc4e2A\ud835\udf0b\u00b9\ud835\udc4ej\ud835\udc60\u00bah\n\ud835\udc5f\u00b9\ud835\udc60,\ud835\udc4e\u00ba\u00b8\ud835\udefe\u00d5\n\ud835\udc6002S\ud835\udc43\u00b9\ud835\udc600j\ud835\udc60,\ud835\udc4e\u00ba\ud835\udc49\ud835\udf0b\n\ud835\udc58\u00b9\ud835\udc600\u00bai\n;for all\ud835\udc602S.(17.2.13)\nThis algorithm is known as policy evaluation and is useful to compute the value function\ngiven the policy. Again, it turns out that as \ud835\udc58!1these updates converge to the correct\nvalue function irrespective of the initialization \ud835\udc490,\n\ud835\udc49\ud835\udf0b\u00b9\ud835\udc60\u00ba=lim\n\ud835\udc58!1\ud835\udc49\ud835\udf0b\n\ud835\udc58\u00b9\ud835\udc60\u00ba;for all states \ud835\udc602S. (17.2.14)\nThe algorithm for computing the action-value function \ud835\udc44\ud835\udf0b\u00b9\ud835\udc60,\ud835\udc4e\u00baof a policy\ud835\udf0bis analo-\ngous.\n789 Value Iteration\n25417.2.8Implementation of ValueIteration\nWenextshowhowtoimplementValueIterationforanavigationproblemcalledFrozenLake\nfromOpen AI Gym254. We first need to setup the enviroment as shown in the following\ncode.\n%matplotlib inline\nimport random\nimport numpy asnp\nfrom d2l import torch asd2l\nseed =0# Random number generator seed\ngamma =0.95 # Discount factor\nnum_iters =10 # Number of iterations\nrandom .seed(seed) # Set the random seed to ensure results can be reproduced\nnp.random .seed(seed)\n# Now set up the environment\nenv_info =d2l.make_env( 'FrozenLake-v1 ', seed =seed)\nIn the FrozenLake environment, the robot moves on a 4\u00024grid (these are the states) with\nactions that are \u201cup\u201d ( \"), \u201cdown\u201d (!), \u201cleft\u201d ( ), and \u201cright\u201d (!). The environment\ncontains a number of holes (H) cells and frozen (F) cells as well as a goal cell (G), all of\nwhich are unknown to the robot. To keep the problem simple, we assume the robot has\nreliable actions, i.e. \ud835\udc43\u00b9\ud835\udc600j\ud835\udc60,\ud835\udc4e\u00ba=1for all\ud835\udc602S,\ud835\udc4e2A. If the robot reaches the goal, the\ntrial ends and the robot receives a reward of 1irrespective of the action; the reward at any\notherstateis 0forallactions. Theobjectiveoftherobotistolearnapolicythatreachesthe\ngoal location (G) from a given start location (S) (this is \ud835\udc600) to maximize the return.", "mimetype": "text/plain", "start_char_idx": 1664458, "end_char_idx": 1666887, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "13a6febd-9565-42bf-bcbc-9fb6623c8637": {"__data__": {"id_": "13a6febd-9565-42bf-bcbc-9fb6623c8637", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "be4607c6-9c12-4dad-b226-ec6a1ff03a17", "node_type": "1", "metadata": {}, "hash": "e7e276e6844a144d4a81d624665e55eb92622ee3e420e4f8a7c762764cb5e6ce", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "71765722-539b-42f2-8781-889529263c05", "node_type": "1", "metadata": {}, "hash": "f7b711da14702fef597bc3a40c6e6e86b74acb15ba97b069ec857170cf000316", "class_name": "RelatedNodeInfo"}}, "text": "), \u201cleft\u201d ( ), and \u201cright\u201d (!). The environment\ncontains a number of holes (H) cells and frozen (F) cells as well as a goal cell (G), all of\nwhich are unknown to the robot. To keep the problem simple, we assume the robot has\nreliable actions, i.e. \ud835\udc43\u00b9\ud835\udc600j\ud835\udc60,\ud835\udc4e\u00ba=1for all\ud835\udc602S,\ud835\udc4e2A. If the robot reaches the goal, the\ntrial ends and the robot receives a reward of 1irrespective of the action; the reward at any\notherstateis 0forallactions. Theobjectiveoftherobotistolearnapolicythatreachesthe\ngoal location (G) from a given start location (S) (this is \ud835\udc600) to maximize the return.\nThe following function implements Value Iteration, where env_info contains MDP and\nenvironment related information and gammais the discount factor:\ndef value_iteration (env_info, gamma, num_iters):\nenv_desc =env_info[ 'desc ']# 2D array shows what each item means\nprob_idx =env_info[ 'trans_prob_idx ']\nnextstate_idx =env_info[ 'nextstate_idx ']\nreward_idx =env_info[ 'reward_idx ']\nnum_states =env_info[ 'num_states ']\nnum_actions =env_info[ 'num_actions ']\nmdp =env_info[ 'mdp']\nV=np.zeros((num_iters +1, num_states))\nQ=np.zeros((num_iters +1, num_states, num_actions))\npi=np.zeros((num_iters +1, num_states))\nfor kinrange (1, num_iters +1):\nfor sinrange (num_states):\nfor ainrange (num_actions):\n# Calculate \\sum_{s'} p(s'\\mid s,a) [r + \\gamma v_k(s')]\nfor pxrds inmdp[(s,a)]:\n# mdp(s,a): [(p1,next1,r1,d1),(p2,next2,r2,d2),..]\npr=pxrds[prob_idx] # p(s'\\mid s,a)\n(continues on next page)\n790 Reinforcement Learning\n(continued from previous page)\nnextstate =pxrds[nextstate_idx] # Next state\nreward =pxrds[reward_idx] # Reward\nQ[k,s,a] +=pr*(reward +gamma *V[k -1, nextstate])\n# Record max value and max action\nV[k,s] =np.max(Q[k,s,:])\npi[k,s] =np.argmax(Q[k,s,:])\nd2l.show_value_function_progress(env_desc, V[: -1], pi[: -1])\nvalue_iteration(env_info =env_info, gamma =gamma, num_iters =num_iters)\nThe above pictures show the policy (the arrow indicates the action) and value function (the\nchangeincolorshowshowthevaluefunctionchangesovertimefromtheinitialvalueshown\nby dark color to the optimal value shown by light colors.). As we see, Value Iteration finds\nthe optimal value function after 10 iterations and the goal state (G) can be reached starting\nfromanystateaslongasitisnotanHcell. Anotherinterestingaspectoftheimplementation\nis that in addition to finding the optimal value function, we also automatically found the\noptimal policy \ud835\udf0b\u0003corresponding to this value function.\n17.2.9Summary\nThe main idea behind the Value Iteration algorithm is to use the principle of dynamic pro-\ngramming to find the optimal average return obtained from a given state. Note that imple-\n791 Q-Learning\n255menting the Value Iteration algorithm requires that we know the Markov decision process\n(MDP), e.g., the transition and reward functions, completely.\n17.2.10Exercises\n1.Try increasing the grid size to 8\u00028. Compared with 4\u00024grid, how many iterations\ndoes it take to find the optimal value function?\n2.What is the computational complexity of the Value Iteration algorithm?\n3.Run the Value Iteration algorithm again with \ud835\udefe(i.e. \u201cgamma\u201d in the above code) when\nit equals to 0,0.5, and 1and analyze its results.\n4.How does the value of \ud835\udefeaffect the number of iterations taken by Value Iteration to\nconverge? What happens when \ud835\udefe=1?\nDiscussions255.\n17.3Q-Learning\nIntheprevioussection,wediscussedtheValueIterationalgorithmwhichrequiresaccessing\nthe complete Markov decision process (MDP), e.g., the transition and reward functions.", "mimetype": "text/plain", "start_char_idx": 1666316, "end_char_idx": 1669807, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "71765722-539b-42f2-8781-889529263c05": {"__data__": {"id_": "71765722-539b-42f2-8781-889529263c05", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "13a6febd-9565-42bf-bcbc-9fb6623c8637", "node_type": "1", "metadata": {}, "hash": "5aa911572b57ab0c423024a417d83f913051ce5c635f329236bc3e4cc3372ce8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3f0eaee1-af63-4bb1-8f56-7c949fc4286c", "node_type": "1", "metadata": {}, "hash": "f33a47486dda8119e992f46f7faa38d936f280d92ba2cb901c0bfc9ce3287135", "class_name": "RelatedNodeInfo"}}, "text": "17.2.10Exercises\n1.Try increasing the grid size to 8\u00028. Compared with 4\u00024grid, how many iterations\ndoes it take to find the optimal value function?\n2.What is the computational complexity of the Value Iteration algorithm?\n3.Run the Value Iteration algorithm again with \ud835\udefe(i.e. \u201cgamma\u201d in the above code) when\nit equals to 0,0.5, and 1and analyze its results.\n4.How does the value of \ud835\udefeaffect the number of iterations taken by Value Iteration to\nconverge? What happens when \ud835\udefe=1?\nDiscussions255.\n17.3Q-Learning\nIntheprevioussection,wediscussedtheValueIterationalgorithmwhichrequiresaccessing\nthe complete Markov decision process (MDP), e.g., the transition and reward functions. In\nthis section, we will look at Q-Learning ( Watkins and Dayan, 1992 ) which is an algorithm\ntolearnthevaluefunctionwithoutnecessarilyknowingtheMDP.Thisalgorithmembodies\nthe central idea behind reinforcement learning: it will enable the robot to obtain its own\ndata.\n17.3.1The Q-Learning Algorithm\nRecall that value iteration for the action-value function in Value Iteration (page 785) cor-\nresponds to the update\n\ud835\udc44\ud835\udc58\u00b81\u00b9\ud835\udc60,\ud835\udc4e\u00ba=\ud835\udc5f\u00b9\ud835\udc60,\ud835\udc4e\u00ba\u00b8\ud835\udefe\u00d5\n\ud835\udc6002S\ud835\udc43\u00b9\ud835\udc600j\ud835\udc60,\ud835\udc4e\u00bamax\n\ud835\udc4e02A\ud835\udc44\ud835\udc58\u00b9\ud835\udc600,\ud835\udc4e0\u00ba;for all\ud835\udc602Sand\ud835\udc4e2A.\n(17.3.1)\nAs we discussed, implementing this algorithm requires knowing the MDP, specifically the\ntransition function \ud835\udc43\u00b9\ud835\udc600j\ud835\udc60,\ud835\udc4e\u00ba. The key idea behind Q-Learning is to replace the summa-\ntion over all \ud835\udc6002Sin the above expression by a summation over the states visited by the\nrobot. This allows us to subvert the need to know the transition function.\n17.3.2AnOptimizationProblemUnderlyingQ-Learning\nLet us imagine that the robot uses a policy \ud835\udf0b\ud835\udc52\u00b9\ud835\udc4ej\ud835\udc60\u00bato take actions. Just like the previous\nchapter,itcollectsadatasetof \ud835\udc5btrajectoriesof \ud835\udc47timestepseachf\u00b9\ud835\udc60\ud835\udc56\n\ud835\udc61,\ud835\udc4e\ud835\udc56\n\ud835\udc61\u00ba\ud835\udc61=0,...,\ud835\udc47\u00001g\ud835\udc56=1,...,\ud835\udc5b.\nRecall that value iteration is really a set of constraints that ties together the action-value\n792 Reinforcement Learning\n\ud835\udc44\u0003\u00b9\ud835\udc60,\ud835\udc4e\u00baof different states and actions to each other. We can implement an approximate\nversion of value iteration using the data that the robot has collected using \ud835\udf0b\ud835\udc52as\n\u02c6\ud835\udc44=min\n\ud835\udc441\n\ud835\udc5b\ud835\udc47\ud835\udc5b\u00d5\n\ud835\udc56=1\ud835\udc47\u00001\u00d5\n\ud835\udc61=0\u00b9\ud835\udc44\u00b9\ud835\udc60\ud835\udc56\n\ud835\udc61,\ud835\udc4e\ud835\udc56\n\ud835\udc61\u00ba\u0000\ud835\udc5f\u00b9\ud835\udc60\ud835\udc56\n\ud835\udc61,\ud835\udc4e\ud835\udc56\n\ud835\udc61\u00ba\u0000\ud835\udefemax\n\ud835\udc4e0\ud835\udc44\u00b9\ud835\udc60\ud835\udc56\n\ud835\udc61\u00b81,\ud835\udc4e0\u00ba\u00ba2\n|                                                                   {z                                                                   }\ndef=\u2113\u00b9\ud835\udc44\u00ba.\n(17.3.2)\nLet us first observe the similarities and differences between this expression and value iter-\nation above. If the robot\u2019s policy \ud835\udf0b\ud835\udc52were equal to the optimal policy \ud835\udf0b\u0003, and if it collected\nan infinite amount of data, then this optimization problem would be identical to the opti-\nmization problem underlying value iteration. But while value iteration requires us to know\n\ud835\udc43\u00b9\ud835\udc600j\ud835\udc60,\ud835\udc4e\u00ba, the optimization objective does not have this term. We have not cheated: as\nthe robot uses the policy \ud835\udf0b\ud835\udc52to take an action \ud835\udc4e\ud835\udc56\n\ud835\udc61at state\ud835\udc60\ud835\udc56\n\ud835\udc61, the next state \ud835\udc60\ud835\udc56\n\ud835\udc61\u00b81is a sample\ndrawn from the transition function.", "mimetype": "text/plain", "start_char_idx": 1669134, "end_char_idx": 1671984, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3f0eaee1-af63-4bb1-8f56-7c949fc4286c": {"__data__": {"id_": "3f0eaee1-af63-4bb1-8f56-7c949fc4286c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "71765722-539b-42f2-8781-889529263c05", "node_type": "1", "metadata": {}, "hash": "f7b711da14702fef597bc3a40c6e6e86b74acb15ba97b069ec857170cf000316", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e7f97ad7-75c0-493f-9152-2122c7224606", "node_type": "1", "metadata": {}, "hash": "311a0ba35471318ea6328b702f755c4330b18394050ae0ca09cf75cba8233837", "class_name": "RelatedNodeInfo"}}, "text": "(17.3.2)\nLet us first observe the similarities and differences between this expression and value iter-\nation above. If the robot\u2019s policy \ud835\udf0b\ud835\udc52were equal to the optimal policy \ud835\udf0b\u0003, and if it collected\nan infinite amount of data, then this optimization problem would be identical to the opti-\nmization problem underlying value iteration. But while value iteration requires us to know\n\ud835\udc43\u00b9\ud835\udc600j\ud835\udc60,\ud835\udc4e\u00ba, the optimization objective does not have this term. We have not cheated: as\nthe robot uses the policy \ud835\udf0b\ud835\udc52to take an action \ud835\udc4e\ud835\udc56\n\ud835\udc61at state\ud835\udc60\ud835\udc56\n\ud835\udc61, the next state \ud835\udc60\ud835\udc56\n\ud835\udc61\u00b81is a sample\ndrawn from the transition function. So the optimization objective also has access to the\ntransition function, but implicitly in terms of the data collected by the robot.\nThe variables of our optimization problem are \ud835\udc44\u00b9\ud835\udc60,\ud835\udc4e\u00bafor all\ud835\udc602Sand\ud835\udc4e2A. We can\nminimize the objective using gradient descent. For every pair \u00b9\ud835\udc60\ud835\udc56\n\ud835\udc61,\ud835\udc4e\ud835\udc56\n\ud835\udc61\u00bain our dataset, we\ncan write\n\ud835\udc44\u00b9\ud835\udc60\ud835\udc56\n\ud835\udc61,\ud835\udc4e\ud835\udc56\n\ud835\udc61\u00ba \ud835\udc44\u00b9\ud835\udc60\ud835\udc56\n\ud835\udc61,\ud835\udc4e\ud835\udc56\n\ud835\udc61\u00ba\u0000\ud835\udefcr\ud835\udc44\u00b9\ud835\udc60\ud835\udc56\n\ud835\udc61,\ud835\udc4e\ud835\udc56\n\ud835\udc61\u00ba\u2113\u00b9\ud835\udc44\u00ba\n=\u00b91\u0000\ud835\udefc\u00ba\ud835\udc44\u00b9\ud835\udc60\ud835\udc56\n\ud835\udc61,\ud835\udc4e\ud835\udc56\n\ud835\udc61\u00ba\u0000\ud835\udefc\u0010\n\ud835\udc5f\u00b9\ud835\udc60\ud835\udc56\n\ud835\udc61,\ud835\udc4e\ud835\udc56\n\ud835\udc61\u00ba\u00b8\ud835\udefemax\n\ud835\udc4e0\ud835\udc44\u00b9\ud835\udc60\ud835\udc56\n\ud835\udc61\u00b81,\ud835\udc4e0\u00ba\u0011\n,(17.3.3)\nwhere\ud835\udefcis the learning rate. Typically in real problems, when the robot reaches the goal\nlocation, the trajectories end. The value of such a terminal state is zero because the robot\ndoes not take any further actions beyond this state. We should modify our update to handle\nsuch states as\n\ud835\udc44\u00b9\ud835\udc60\ud835\udc56\n\ud835\udc61,\ud835\udc4e\ud835\udc56\n\ud835\udc61\u00ba=\u00b91\u0000\ud835\udefc\u00ba\ud835\udc44\u00b9\ud835\udc60\ud835\udc56\n\ud835\udc61,\ud835\udc4e\ud835\udc56\n\ud835\udc61\u00ba\u0000\ud835\udefc\u0010\n\ud835\udc5f\u00b9\ud835\udc60\ud835\udc56\n\ud835\udc61,\ud835\udc4e\ud835\udc56\n\ud835\udc61\u00ba\u00b8\ud835\udefe\u00b91\u0000\u22ae\ud835\udc60\ud835\udc56\n\ud835\udc61\u00b81is terminal\u00bamax\n\ud835\udc4e0\ud835\udc44\u00b9\ud835\udc60\ud835\udc56\n\ud835\udc61\u00b81,\ud835\udc4e0\u00ba\u0011\n.\n(17.3.4)\nwhere \u22ae\ud835\udc60\ud835\udc56\n\ud835\udc61\u00b81is terminal is an indicator variable that is one if \ud835\udc60\ud835\udc56\n\ud835\udc61\u00b81is a terminal state and zero\notherwise. The value of state-action tuples \u00b9\ud835\udc60,\ud835\udc4e\u00bathat are not a part of the dataset is set to\n\u00001. This algorithm is known as Q-Learning.\nGiven the solution of these updates \u02c6\ud835\udc44, which is an approximation of the optimal value\nfunction\ud835\udc44\u0003, we can obtain the optimal deterministic policy corresponding to this value\nfunction easily using\n\u02c6\ud835\udf0b\u00b9\ud835\udc60\u00ba=argmax\ud835\udc4e\u02c6\ud835\udc44\u00b9\ud835\udc60,\ud835\udc4e\u00ba. (17.3.5)\nThere can be situations when there are multiple deterministic policies that correspond to\nthe same optimal value function; such ties can be broken arbitrarily because they have the\nsame value function.\n17.3.3Exploration in Q-Learning\n793 Q-Learning\nThe policy used by the robot to collect data \ud835\udf0b\ud835\udc52is critical to ensure that Q-Learning works\nwell. Afterall, we have replaced the expectation over \ud835\udc600using the transition function \ud835\udc43\u00b9\ud835\udc600j\n\ud835\udc60,\ud835\udc4e\u00bausing the data collected by the robot.", "mimetype": "text/plain", "start_char_idx": 1671386, "end_char_idx": 1673735, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e7f97ad7-75c0-493f-9152-2122c7224606": {"__data__": {"id_": "e7f97ad7-75c0-493f-9152-2122c7224606", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3f0eaee1-af63-4bb1-8f56-7c949fc4286c", "node_type": "1", "metadata": {}, "hash": "f33a47486dda8119e992f46f7faa38d936f280d92ba2cb901c0bfc9ce3287135", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9a792f79-dbaf-4fcb-925a-26a7bc0f88ce", "node_type": "1", "metadata": {}, "hash": "b7221dc9b3b72d6a3b326795c861745e5da1310be0d8fbd365ee48f0b68bc804", "class_name": "RelatedNodeInfo"}}, "text": "(17.3.5)\nThere can be situations when there are multiple deterministic policies that correspond to\nthe same optimal value function; such ties can be broken arbitrarily because they have the\nsame value function.\n17.3.3Exploration in Q-Learning\n793 Q-Learning\nThe policy used by the robot to collect data \ud835\udf0b\ud835\udc52is critical to ensure that Q-Learning works\nwell. Afterall, we have replaced the expectation over \ud835\udc600using the transition function \ud835\udc43\u00b9\ud835\udc600j\n\ud835\udc60,\ud835\udc4e\u00bausing the data collected by the robot. If the policy \ud835\udf0b\ud835\udc52does not reach diverse parts of\nthestate-actionspace,thenitiseasytoimagineourestimate \u02c6\ud835\udc44willbeapoorapproximation\nof the optimal \ud835\udc44\u0003. It is also important to note that in such a situation, the estimate of \ud835\udc44\u0003at\nallstates\ud835\udc602Swill be bad, not just the ones visited by \ud835\udf0b\ud835\udc52. This is because the Q-Learning\nobjective (or value iteration) is a constraint that ties together the value of all state-action\npairs. It is therefore critical to pick the correct policy \ud835\udf0b\ud835\udc52to collect data.\nWecanmitigatethisconcernbypickingacompletelyrandompolicy \ud835\udf0b\ud835\udc52thatsamplesactions\nuniformly randomly from A. Such a policy would visit all states, but it will take a large\nnumber of trajectories before it does so.\nWe thus arrive at the second key idea in Q-Learning, namely exploration. Typical im-\nplementations of Q-Learning tie together the current estimate of \ud835\udc44and the policy \ud835\udf0b\ud835\udc52to\nset\n\ud835\udf0b\ud835\udc52\u00b9\ud835\udc4ej\ud835\udc60\u00ba=(\nargmax\ud835\udc4e0\u02c6\ud835\udc44\u00b9\ud835\udc60,\ud835\udc4e0\u00bawith prob. 1\u0000\ud835\udf16\nuniform\u00b9A\u00ba with prob.\ud835\udf16,(17.3.6)\nwhere\ud835\udf16is called the \u201cexploration parameter\u201d and is chosen by the user. The policy \ud835\udf0b\ud835\udc52is\ncalled an exploration policy. This particular \ud835\udf0b\ud835\udc52is called an\ud835\udf16-greedy exploration policy\nbecause it chooses the optimal action (under the current estimate \u02c6\ud835\udc44) with probability 1\u0000\ud835\udf16\nbut explores randomly with the remainder probability \ud835\udf16. We can also use the so-called\nsoftmax exploration policy\n\ud835\udf0b\ud835\udc52\u00b9\ud835\udc4ej\ud835\udc60\u00ba=\ud835\udc52\u02c6\ud835\udc44\u00b9\ud835\udc60,\ud835\udc4e\u00ba\u009d\ud835\udc47\n\u00cd\n\ud835\udc4e0\ud835\udc52\u02c6\ud835\udc44\u00b9\ud835\udc60,\ud835\udc4e0\u00ba\u009d\ud835\udc47; (17.3.7)\nwhere the hyper-parameter \ud835\udc47is called temperature. A large value of \ud835\udf16in\ud835\udf16-greedy policy\nfunctions similarly to a large value of temperature \ud835\udc47for the softmax policy.\nIt is important to note that when we pick an exploration that depends upon the current\nestimate of the action-value function \u02c6\ud835\udc44, we need to resolve the optimization problem peri-\nodically. Typical implementations of Q-Learning make one mini-batch update using a few\nstate-action pairs in the collected dataset (typically the ones collected from the previous\ntimestep of the robot) after taking every action using \ud835\udf0b\ud835\udc52.\n17.3.4The \u201cSelf-correcting\u201dPropertyof Q-Learning\nThedatasetcollectedbytherobotduringQ-Learninggrowswithtime. Boththeexploration\npolicy\ud835\udf0b\ud835\udc52and the estimate \u02c6\ud835\udc44evolve as the robot collects more data. This gives us a key\ninsight into why Q-Learning works well. Consider a state \ud835\udc60: if a particular action \ud835\udc4ehas\na large value under the current estimate \u02c6\ud835\udc44\u00b9\ud835\udc60,\ud835\udc4e\u00ba, then both the \ud835\udf16-greedy and the softmax\nexplorationpolicieshavealargerprobabilityofpickingthisaction. Ifthisactionactuallyis\nnottheidealaction,thenthefuturestatesthatarisefromthisactionwillhavepoorrewards.", "mimetype": "text/plain", "start_char_idx": 1673252, "end_char_idx": 1676242, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9a792f79-dbaf-4fcb-925a-26a7bc0f88ce": {"__data__": {"id_": "9a792f79-dbaf-4fcb-925a-26a7bc0f88ce", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e7f97ad7-75c0-493f-9152-2122c7224606", "node_type": "1", "metadata": {}, "hash": "311a0ba35471318ea6328b702f755c4330b18394050ae0ca09cf75cba8233837", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d292bce9-817f-4945-ab26-222dd5544c0a", "node_type": "1", "metadata": {}, "hash": "03fb25704ee439b9efdde60ae9f284d927ff72e9b47d3b84e64cdb335c9d5564", "class_name": "RelatedNodeInfo"}}, "text": "17.3.4The \u201cSelf-correcting\u201dPropertyof Q-Learning\nThedatasetcollectedbytherobotduringQ-Learninggrowswithtime. Boththeexploration\npolicy\ud835\udf0b\ud835\udc52and the estimate \u02c6\ud835\udc44evolve as the robot collects more data. This gives us a key\ninsight into why Q-Learning works well. Consider a state \ud835\udc60: if a particular action \ud835\udc4ehas\na large value under the current estimate \u02c6\ud835\udc44\u00b9\ud835\udc60,\ud835\udc4e\u00ba, then both the \ud835\udf16-greedy and the softmax\nexplorationpolicieshavealargerprobabilityofpickingthisaction. Ifthisactionactuallyis\nnottheidealaction,thenthefuturestatesthatarisefromthisactionwillhavepoorrewards.\nThenextupdateoftheQ-Learningobjectivewillthereforereducethevalue \u02c6\ud835\udc44\u00b9\ud835\udc60,\ud835\udc4e\u00ba, which\nwill reduce the probability of picking this action the next time the robot visits state \ud835\udc60. Bad\n794 Reinforcement Learning\n256actions, e.g., ones whose value is overestimated in \u02c6\ud835\udc44\u00b9\ud835\udc60,\ud835\udc4e\u00ba, are explored by the robot but\ntheir value is correct in the next update of the Q-Learning objective. Good actions, e.g.,\nwhose value \u02c6\ud835\udc44\u00b9\ud835\udc60,\ud835\udc4e\u00bais large, are explored more often by the robot and thereby reinforced.\nThispropertycanbeusedtoshowthatQ-Learningcanconvergetotheoptimalpolicyeven\nif it begins with a random policy \ud835\udf0b\ud835\udc52(Watkins and Dayan, 1992 ).\nThis ability to not only collect new data but also collect the right kind of data is the cen-\ntral feature of reinforcement learning algorithms, and this is what distinguishes them from\nsupervised learning. Q-Learning, using deep neural networks (which we will see in the\nDQN chapeter later), is responsible for the resurgence of reinforcement learning ( Mnihet\nal., 2013).\n17.3.5Implementation of Q-Learning\nWenowshowhowtoimplementQ-LearningonFrozenLakefrom OpenAIGym256. Note\nthis is the same setup as we consider in ValueIteration (page 785) experiment.\n%matplotlib inline\nimport random\nimport numpy asnp\nfrom d2l import torch asd2l\nseed =0# Random number generator seed\ngamma =0.95 # Discount factor\nnum_iters =256 # Number of iterations\nalpha =0.9 # Learing rate\nepsilon =0.9 # Epsilon in epsilion gready algorithm\nrandom .seed(seed) # Set the random seed\nnp.random .seed(seed)\n# Now set up the environment\nenv_info =d2l.make_env( 'FrozenLake-v1 ', seed =seed)\nIn the FrozenLake environment, the robot moves on a 4\u00024grid (these are the states) with\nactions that are \u201cup\u201d ( \"), \u201cdown\u201d (!), \u201cleft\u201d ( ), and \u201cright\u201d (!). The environment\ncontains a number of holes (H) cells and frozen (F) cells as well as a goal cell (G), all of\nwhich are unknown to the robot. To keep the problem simple, we assume the robot has\nreliable actions, i.e. \ud835\udc43\u00b9\ud835\udc600j\ud835\udc60,\ud835\udc4e\u00ba=1for all\ud835\udc602S,\ud835\udc4e2A. If the robot reaches the goal, the\ntrial ends and the robot receives a reward of 1irrespective of the action; the reward at any\notherstateis 0forallactions. Theobjectiveoftherobotistolearnapolicythatreachesthe\ngoal location (G) from a given start location (S) (this is \ud835\udc600) to maximize the return.", "mimetype": "text/plain", "start_char_idx": 1675685, "end_char_idx": 1678521, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d292bce9-817f-4945-ab26-222dd5544c0a": {"__data__": {"id_": "d292bce9-817f-4945-ab26-222dd5544c0a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9a792f79-dbaf-4fcb-925a-26a7bc0f88ce", "node_type": "1", "metadata": {}, "hash": "b7221dc9b3b72d6a3b326795c861745e5da1310be0d8fbd365ee48f0b68bc804", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b62a9260-a482-44a9-9c36-96ae2fb536cd", "node_type": "1", "metadata": {}, "hash": "4740e1bb52cb62259e307a7c0047256d08d520ca7a31a55d0bb8c45c461a9307", "class_name": "RelatedNodeInfo"}}, "text": "), \u201cleft\u201d ( ), and \u201cright\u201d (!). The environment\ncontains a number of holes (H) cells and frozen (F) cells as well as a goal cell (G), all of\nwhich are unknown to the robot. To keep the problem simple, we assume the robot has\nreliable actions, i.e. \ud835\udc43\u00b9\ud835\udc600j\ud835\udc60,\ud835\udc4e\u00ba=1for all\ud835\udc602S,\ud835\udc4e2A. If the robot reaches the goal, the\ntrial ends and the robot receives a reward of 1irrespective of the action; the reward at any\notherstateis 0forallactions. Theobjectiveoftherobotistolearnapolicythatreachesthe\ngoal location (G) from a given start location (S) (this is \ud835\udc600) to maximize the return.\nWe first implement \ud835\udf16-greedy method as follows:\ndef e_greedy (env, Q, s, epsilon):\nifrandom .random() <epsilon:\nreturn env.action_space .sample()\nelse :\nreturn np.argmax(Q[s,:])\n795 Q-Learning\nWe are now ready to implement Q-learning:\ndef q_learning (env_info, gamma, num_iters, alpha, epsilon):\nenv_desc =env_info[ 'desc ']# 2D array specifying what each grid item \u2423\n\u21a9!means\nenv =env_info[ 'env']# 2D array specifying what each grid item means\nnum_states =env_info[ 'num_states ']\nnum_actions =env_info[ 'num_actions ']\nQ=np.zeros((num_states, num_actions))\nV=np.zeros((num_iters +1, num_states))\npi=np.zeros((num_iters +1, num_states))\nfor kinrange (1, num_iters +1):\n# Reset environment\nstate, done =env.reset(), False\nwhile not done:\n# Select an action for a given state and acts in env based on \u2423\n\u21a9!selected action\naction =e_greedy(env, Q, state, epsilon)\nnext_state, reward, done, _ =env.step(action)\n# Q-update:\ny=reward +gamma *np.max(Q[next_state,:])\nQ[state, action] =Q[state, action] +alpha *(y-Q[state, \u2423\n\u21a9!action])\n# Move to the next state\nstate =next_state\n# Record max value and max action for visualization purpose only\nfor sinrange (num_states):\nV[k,s] =np.max(Q[s,:])\npi[k,s] =np.argmax(Q[s,:])\nd2l.show_Q_function_progress(env_desc, V[: -1], pi[: -1])\nq_learning(env_info =env_info, gamma =gamma, num_iters =num_iters, alpha =alpha, \u2423\n\u21a9!epsilon =epsilon)\nThisresultshowsthatQ-learningcanfindtheoptimalsolutionforthisproblemroughlyafter\n250 iterations. However, when we compare this result with the Value Iteration algorithm\u2019s\nresult(see ImplementationofValueIteration (page789)),wecanseethattheValueIteration\nalgorithm needs way fewer iterations to find the optimal solution for this problem. This\nhappens because the Value Iteration algorithm has access to the full MDP whereas Q-\nlearning does not.\n17.3.6Summary\nQ-learning is one of the most fundamental reinforcement-learning algorithms. It has been\nat the epicenter of the recent success of reinforcement learning, most notably in learning\nto play video games ( Mnihet al., 2013). Implementing Q-learning does not require that\nwe know the Markov decision process (MDP), e.g., the transition and reward functions,\ncompletely.\n796 Reinforcement Learning\n25717.3.7Exercises\n1.Try increasing the grid size to 8\u00028. Compared with 4\u00024grid, how many iterations\ndoes it take to find the optimal value function?\n2.Run the Q-learning algorithm again with \ud835\udefe(i.e. \u201cgamma\u201d in the above code) when it\nequals to 0,0.5, and 1and analyze its results.\n3.Run the Q-learning algorithm again with \ud835\udf16(i.e. \u201cepsilon\u201d in the above code) when it\nequals to 0,0.5, and 1and analyze its results.\nDiscussions257.\n258\n18 Gaussian Processes\nAndrewGordonWilson (NewYorkUniversityand Amazon )\nGaussianprocesses(GPs)areubitiquous. Youhavealreadyencounteredmanyexamplesof\nGPs without realizing it. Any model that is linear in its parameters with a Gaussian distri-\nbutionovertheparametersisaGaussianprocess.", "mimetype": "text/plain", "start_char_idx": 1677950, "end_char_idx": 1681465, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b62a9260-a482-44a9-9c36-96ae2fb536cd": {"__data__": {"id_": "b62a9260-a482-44a9-9c36-96ae2fb536cd", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d292bce9-817f-4945-ab26-222dd5544c0a", "node_type": "1", "metadata": {}, "hash": "03fb25704ee439b9efdde60ae9f284d927ff72e9b47d3b84e64cdb335c9d5564", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "40c285f1-c60f-4ae5-93ff-5a1c3eaa38e0", "node_type": "1", "metadata": {}, "hash": "c862060fc28065de50f6b7488c6882b926ba13da8e1052ffd7c9b1dd96a86ddf", "class_name": "RelatedNodeInfo"}}, "text": "Compared with 4\u00024grid, how many iterations\ndoes it take to find the optimal value function?\n2.Run the Q-learning algorithm again with \ud835\udefe(i.e. \u201cgamma\u201d in the above code) when it\nequals to 0,0.5, and 1and analyze its results.\n3.Run the Q-learning algorithm again with \ud835\udf16(i.e. \u201cepsilon\u201d in the above code) when it\nequals to 0,0.5, and 1and analyze its results.\nDiscussions257.\n258\n18 Gaussian Processes\nAndrewGordonWilson (NewYorkUniversityand Amazon )\nGaussianprocesses(GPs)areubitiquous. Youhavealreadyencounteredmanyexamplesof\nGPs without realizing it. Any model that is linear in its parameters with a Gaussian distri-\nbutionovertheparametersisaGaussianprocess. Thisclassspansdiscretemodels, includ-\ning random walks, and autoregressive processes, as well as continuous models, including\nBayesian linear regression models, polynomials, Fourier series, radial basis functions, and\neven neural networks with an infinite number of hidden units. There is a running joke that\n\u201ceverything is a special case of a Gaussian process\u201d.\nLearning about Gaussian processes is important for three reasons: (1) they provide a func-\ntionspace perspectiveofmodelling,whichmakesunderstandingavarietyofmodelclasses,\nincluding deep neural networks, much more approachable; (2) they have an extraordinary\nrange of applications where they are state-of-the-art, including active learning, hyperpa-\nrameter learning, auto-ML, and spatiotemporal regression; (3) over the last few years,\nalgorithmic advances have made Gaussian processes increasingly scalable and relevant,\nharmonizing with deep learning through frameworks such as GPyTorch258(Gardneret\nal., 2018). Indeed, GPs and and deep neural networks are not competing approaches, but\nhighly complementary, and can be combined to great effect. These algorithmic advances\nare not just relevant to Gaussian processes, but provide a foundation in numerical methods\nthat is broadly useful in deep learning.\nIn this chapter, we introduce Gaussian processes. In the introductory notebook, we start\nby reasoning intuitively about what Gaussian processes are and how they directly model\nfunctions. In the priors notebook, we focus on how to specify Gaussian process priors.\nWedirectlyconnectthetradiationalweight-spaceapproachtomodellingtofunctionspace,\nwhich will help us reason about constructing and understanding machine learning mod-\nels, including deep neural networks. We then introduce popular covariance functions, also\nknown as kernels, which control the generalization properties of a Gaussian process. A\nGP with a given kernel defines a prior over functions. In the inference notebook, we will\nshow how to use data to infer a posterior , in order to make predictions. This notebook\ncontains from-scratch code for making predictions with a Gaussian process, as well as an\nintroduction to GPyTorch. In upcoming notebooks, we will introduce the numerics behind\nGaussianprocesses,whichisusefulforscalingGaussianprocessesbutalsoapowerfulgen-\neralfoundationfordeeplearning,andadvanceduse-casessuchashyperparametertuningin\ndeeplearning. OurexampleswillmakeuseofGPyTorch,whichmakesGaussianprocesses\nscale, and is closely integrated with deep learning functionality and PyTorch.\n797\n798 Gaussian Processes\n18.1Introductionto Gaussian Processes\nIn many cases, machine learning amounts to estimating parameters from data. These pa-\nrametersareoftennumerousandrelativelyuninterpretable\u2014suchastheweightsofaneu-\nral network. Gaussian processes, by contrast, provide a mechanism for directly reasoning\nabout the high-level properties of functions that could fit our data. For example, we may\nhave a sense of whether these functions are quickly varying, periodic, involve conditional\nindependencies, or translation invariance. Gaussian processes enable us to easily incorpo-\nratethesepropertiesintoourmodel, bydirectlyspecifyingaGaussiandistributionoverthe\nfunction values that could fit our data.\nLet\u2019sgetafeelforhowGaussianprocessesoperate,bystartingwithsomeexamples.\nSuppose we observe the following dataset, of regression targets (outputs), \ud835\udc66, indexed by\ninputs,\ud835\udc65. As an example, the targets could be changes in carbon dioxide concentrations,\nand the inputs could be the times at which these targets have been recorded. What are\nsome features of the data? How quickly does it seem to varying? Do we have data points\ncollected at regular intervals, or are there missing inputs?", "mimetype": "text/plain", "start_char_idx": 1680805, "end_char_idx": 1685201, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "40c285f1-c60f-4ae5-93ff-5a1c3eaa38e0": {"__data__": {"id_": "40c285f1-c60f-4ae5-93ff-5a1c3eaa38e0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b62a9260-a482-44a9-9c36-96ae2fb536cd", "node_type": "1", "metadata": {}, "hash": "4740e1bb52cb62259e307a7c0047256d08d520ca7a31a55d0bb8c45c461a9307", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0d69bb94-5121-4932-a3f3-4835db45f0f3", "node_type": "1", "metadata": {}, "hash": "204d72cff2ed8fbef8454142baffffbca18877251f97c9bfc93b2b00b2cc130b", "class_name": "RelatedNodeInfo"}}, "text": "For example, we may\nhave a sense of whether these functions are quickly varying, periodic, involve conditional\nindependencies, or translation invariance. Gaussian processes enable us to easily incorpo-\nratethesepropertiesintoourmodel, bydirectlyspecifyingaGaussiandistributionoverthe\nfunction values that could fit our data.\nLet\u2019sgetafeelforhowGaussianprocessesoperate,bystartingwithsomeexamples.\nSuppose we observe the following dataset, of regression targets (outputs), \ud835\udc66, indexed by\ninputs,\ud835\udc65. As an example, the targets could be changes in carbon dioxide concentrations,\nand the inputs could be the times at which these targets have been recorded. What are\nsome features of the data? How quickly does it seem to varying? Do we have data points\ncollected at regular intervals, or are there missing inputs? How would you imagine filling\nin the missing regions, or forecasting up until \ud835\udc65=25?\ntFig. 18.1.1 Observed data.\nIn order to fit the data with a Gaussian process, we start by specifying a prior distribution\nover what types of functions we might believe to be reasonable. Here we show several\nsample functions from a Gaussian process. Does this prior look reasonable? Note here\nwe are not looking for functions that fit our dataset, but instead for specifying reasonable\nhigh-level properties of the solutions, such as how quickly they vary with inputs. Note that\nwe will see code for reproducing all of the plots in this notebook, in the next notebooks on\npriors and inference.\nOnce we condition on data, we can use this prior to infer a posterior distribution over func-\ntions that could fit the data. Here we show sample posterior functions.\nWe see that each of these functions are entirely consistent with our data, perfectly running\nthrough each observation. In order to use these posterior samples to make predictions, we\ncan average the values of every possible sample function from the posterior, to create the\n799 Introduction to Gaussian Processes\ntFig. 18.1.2 Sample prior functions that we may want to represent with our model.\ntFig. 18.1.3 Sample posterior functions, once we have observed the data.\ncurve below, in thick blue. Note that we do not actually have to take an infinite number of\nsamples to compute this expectation; as we will see later, we can compute the expectation\nin closed form.\ntFig. 18.1.4 Posterior samples, alongside posterior mean, which can be used for point predictions, in\nblue.\nWe may also want a representation of uncertainty, so we know how confident we should\nbe in our predictions. Intuitively, we should have more uncertainty where there is more\nvariability in the sample posterior functions, as this tells us there are many more possible\nvaluesthetruefunctioncouldtake. Thistypeofuncertaintyiscalled epistemicuncertainty ,\nwhichisthe reducibleuncertainty associatedwithlackofinformation. Asweacquiremore\ndata, this type of uncertainty disappears, as there will be increasingly fewer solutions con-\nsistent with what we observe. Like with the posterior mean, we can compute the posterior\nvariance (the variability of these functions in the posterior) in closed form. With shade,\nwe show two times the posterior standard deviation on either side of the mean, creating a\n800 Gaussian Processes\ncredibleinterval that has a 95% probability of containing the true value of the function for\nany input\ud835\udc65.\ntFig. 18.1.5 Posterior samples, including 95% credible set.\nThe plot looks somewhat cleaner if we remove the posterior samples, simply visualizing\nthe data, posterior mean, and 95% credible set. Notice how the uncertainty grows away\nfrom the data, a property of epistemic uncertainty.\ntFig. 18.1.6 Point predictions, and credible set.\nThe properties of the Gaussian process that we used to fit the data are strongly controlled\nby what\u2019s called a covariance function , also known as a kernel. The covariance function\nwe used is called the RBF (Radial Basis Function)kernel , which has the form\n\ud835\udc58RBF\u00b9\ud835\udc65,\ud835\udc650\u00ba=Cov\u00b9\ud835\udc53\u00b9\ud835\udc65\u00ba, \ud835\udc53\u00b9\ud835\udc650\u00ba\u00ba=\ud835\udc4e2exp\u0012\n\u00001\n2\u21132jj\ud835\udc65\u0000\ud835\udc650jj2\u0013\n(18.1.1)\nThehyperparameters of this kernel are interpretable. The amplitude parameter\ud835\udc4econtrols\nthe vertical scale over which the function is varying, and the length-scale parameter\u2113con-\ntrols the rate of variation (the wiggliness) of the function.", "mimetype": "text/plain", "start_char_idx": 1684394, "end_char_idx": 1688635, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0d69bb94-5121-4932-a3f3-4835db45f0f3": {"__data__": {"id_": "0d69bb94-5121-4932-a3f3-4835db45f0f3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "40c285f1-c60f-4ae5-93ff-5a1c3eaa38e0", "node_type": "1", "metadata": {}, "hash": "c862060fc28065de50f6b7488c6882b926ba13da8e1052ffd7c9b1dd96a86ddf", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e7b06f7a-090d-493f-b4ee-b5e1ae15f3c0", "node_type": "1", "metadata": {}, "hash": "bf6695aeefddf1d661942570af7eac4094c90e744e197b2a8491c93c4f69caf2", "class_name": "RelatedNodeInfo"}}, "text": "tFig. 18.1.6 Point predictions, and credible set.\nThe properties of the Gaussian process that we used to fit the data are strongly controlled\nby what\u2019s called a covariance function , also known as a kernel. The covariance function\nwe used is called the RBF (Radial Basis Function)kernel , which has the form\n\ud835\udc58RBF\u00b9\ud835\udc65,\ud835\udc650\u00ba=Cov\u00b9\ud835\udc53\u00b9\ud835\udc65\u00ba, \ud835\udc53\u00b9\ud835\udc650\u00ba\u00ba=\ud835\udc4e2exp\u0012\n\u00001\n2\u21132jj\ud835\udc65\u0000\ud835\udc650jj2\u0013\n(18.1.1)\nThehyperparameters of this kernel are interpretable. The amplitude parameter\ud835\udc4econtrols\nthe vertical scale over which the function is varying, and the length-scale parameter\u2113con-\ntrols the rate of variation (the wiggliness) of the function. Larger \ud835\udc4emeans larger function\nvalues, and larger \u2113means more slowly varying functions. Let\u2019s see what happens to our\nsample prior and posterior functions as we vary \ud835\udc4eand\u2113.\nThelength-scale has a particularly pronounced effect on the predictions and uncertainty of\na GP. Atjj\ud835\udc65\u0000\ud835\udc650jj=\u2113, the covariance between a pair of function values is \ud835\udc4e2exp\u00b9\u00000.5\u00ba.\nAt larger distances than \u2113, the values of the function values becomes nearly uncorrelated.\nThis means that if we want to make a prediction at a point \ud835\udc65\u0003, then function values with\ninputs\ud835\udc65such thatjj\ud835\udc65\u0000\ud835\udc650jj>\u2113will not have a strong effect on our predictions.\nLet\u2019s see how changing the lengthscale affects sample prior and posterior functions, and\n801 Introduction to Gaussian Processes\ncrediblesets. Theabovefitsusealength-scaleof 2. Let\u2019snowconsider \u2113=0.1,0.5,2,5,10\n. Alength-scaleof 0.1isverysmallrelativetotherangeoftheinputdomainweareconsid-\nering, 25. For example, the values of the function at \ud835\udc65=5and\ud835\udc65=10will have essentially\nno correlation at such a length-scale. On the other hand, for a length-scale of 10, the func-\ntion values at these inputs will be highly correlated. Note that the vertical scale changes in\nthe following figures.\n\n802 Gaussian Processes\n\n803 Introduction to Gaussian Processes\nNotice as the length-scale increases the \u2018wiggliness\u2019 of the functions decrease, and our\nuncertainty decreases. If the length-scale is small, the uncertainty will quickly increase as\nwe move away from the data, as the datapoints become less informative about the function\nvalues.\nNow, let\u2019s vary the amplitude parameter, holding the length-scale fixed at 2. Note the ver-\ntical scale is held fixed for the prior samples, and varies for the posterior samples, so you\ncan clearly see both the increasing scale of the function, and the fits to the data.\n\n804 Gaussian Processes\nWeseetheamplitudeparameteraffectsthescaleofthefunction,butnottherateofvariation.\nAt this point, we also have the sense that the generalization performance of our procedure\nwilldependonhavingreasonablevaluesforthesehyperparameters. Valuesof \u2113=2and\ud835\udc4e=\n1appeared to provide reasonable fits, while some of the other values did not. Fortunately,\nthere is a robust and automatic way to specify these hyperparameters, using what is called\nthemarginallikelihood , which we will return to in the notebook on inference.\n805 Introduction to Gaussian Processes\nSo what is a GP, really? As we started, a GP simply says that any collection of function\nvalues\ud835\udc53\u00b9\ud835\udc651\u00ba,..., \ud835\udc53\u00b9\ud835\udc65\ud835\udc5b\u00ba, indexed by any collection of inputs \ud835\udc651,...,\ud835\udc65\ud835\udc5bhas a joint multi-\nvariate Gaussian distribution. The mean vector \ud835\udf07of this distribution is given by a mean\nfunction, which is typically taken to be a constant or zero. The covariance matrix of this\ndistribution is given by the kernelevaluated at all pairs of the inputs \ud835\udc65.", "mimetype": "text/plain", "start_char_idx": 1688028, "end_char_idx": 1691444, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e7b06f7a-090d-493f-b4ee-b5e1ae15f3c0": {"__data__": {"id_": "e7b06f7a-090d-493f-b4ee-b5e1ae15f3c0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0d69bb94-5121-4932-a3f3-4835db45f0f3", "node_type": "1", "metadata": {}, "hash": "204d72cff2ed8fbef8454142baffffbca18877251f97c9bfc93b2b00b2cc130b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ad7cad6b-46db-4336-a5d0-cf4bca1889ca", "node_type": "1", "metadata": {}, "hash": "feb587251acbb23a161f7cb285cfe58c73e0eba902051cb15ea4aad5326c6d40", "class_name": "RelatedNodeInfo"}}, "text": "Fortunately,\nthere is a robust and automatic way to specify these hyperparameters, using what is called\nthemarginallikelihood , which we will return to in the notebook on inference.\n805 Introduction to Gaussian Processes\nSo what is a GP, really? As we started, a GP simply says that any collection of function\nvalues\ud835\udc53\u00b9\ud835\udc651\u00ba,..., \ud835\udc53\u00b9\ud835\udc65\ud835\udc5b\u00ba, indexed by any collection of inputs \ud835\udc651,...,\ud835\udc65\ud835\udc5bhas a joint multi-\nvariate Gaussian distribution. The mean vector \ud835\udf07of this distribution is given by a mean\nfunction, which is typically taken to be a constant or zero. The covariance matrix of this\ndistribution is given by the kernelevaluated at all pairs of the inputs \ud835\udc65.\n266666664\ud835\udc53\u00b9\ud835\udc65\u00ba\n\ud835\udc53\u00b9\ud835\udc651\u00ba\n...\n\ud835\udc53\u00b9\ud835\udc65\ud835\udc5b\u00ba377777775\u0018N\u00a9\u00ad\u00ad\u00ad\u00ad\u00ad\n\u00ab\ud835\udf07,266666664\ud835\udc58\u00b9\ud835\udc65,\ud835\udc65\u00ba\ud835\udc58\u00b9\ud835\udc65,\ud835\udc65 1\u00ba... \ud835\udc58\u00b9\ud835\udc65,\ud835\udc65\ud835\udc5b\u00ba\n\ud835\udc58\u00b9\ud835\udc651,\ud835\udc65\u00ba\ud835\udc58\u00b9\ud835\udc651,\ud835\udc651\u00ba... \ud835\udc58\u00b9\ud835\udc651,\ud835\udc65\ud835\udc5b\u00ba\n............\n\ud835\udc58\u00b9\ud835\udc65\ud835\udc5b,\ud835\udc65\u00ba\ud835\udc58\u00b9\ud835\udc65\ud835\udc5b,\ud835\udc651\u00ba... \ud835\udc58\u00b9\ud835\udc65\ud835\udc5b,\ud835\udc65\ud835\udc5b\u00ba377777775\u00aa\u00ae\u00ae\u00ae\u00ae\u00ae\n\u00ac(18.1.2)\nEquation (18.1.2 )specifiesaGPprior. Wecancomputetheconditionaldistributionof \ud835\udc53\u00b9\ud835\udc65\u00ba\nfor any\ud835\udc65given\ud835\udc53\u00b9\ud835\udc651\u00ba,..., \ud835\udc53\u00b9\ud835\udc65\ud835\udc5b\u00ba, the function values we have observed. This conditional\ndistribution is called the posterior , and it is what we use to make predictions.\nIn particular,\n\ud835\udc53\u00b9\ud835\udc65\u00baj\ud835\udc53\u00b9\ud835\udc651\u00ba,..., \ud835\udc53\u00b9\ud835\udc65\ud835\udc5b\u00ba\u0018N\u00b9\ud835\udc5a,\ud835\udc602\u00ba (18.1.3)\nwhere\n\ud835\udc5a=\ud835\udc58\u00b9\ud835\udc65,\ud835\udc65 1:\ud835\udc5b\u00ba\ud835\udc58\u00b9\ud835\udc651:\ud835\udc5b,\ud835\udc651:\ud835\udc5b\u00ba\u00001\ud835\udc53\u00b9\ud835\udc651:\ud835\udc5b\u00ba (18.1.4)\n\ud835\udc602=\ud835\udc58\u00b9\ud835\udc65,\ud835\udc65\u00ba\u0000\ud835\udc58\u00b9\ud835\udc65,\ud835\udc65 1:\ud835\udc5b\u00ba\ud835\udc58\u00b9\ud835\udc651:\ud835\udc5b,\ud835\udc651:\ud835\udc5b\u00ba\u00001\ud835\udc58\u00b9\ud835\udc65,\ud835\udc65 1:\ud835\udc5b\u00ba (18.1.5)\nwhere\ud835\udc58\u00b9\ud835\udc65,\ud835\udc65 1:\ud835\udc5b\u00bais a 1\u0002\ud835\udc5bvector formed by evaluating \ud835\udc58\u00b9\ud835\udc65,\ud835\udc65\ud835\udc56\u00bafor\ud835\udc56=1,...,\ud835\udc5band\n\ud835\udc58\u00b9\ud835\udc651:\ud835\udc5b,\ud835\udc651:\ud835\udc5b\u00bais an\ud835\udc5b\u0002\ud835\udc5bmatrix formed by evaluating \ud835\udc58\u00b9\ud835\udc65\ud835\udc56,\ud835\udc65\ud835\udc57\u00bafor\ud835\udc56,\ud835\udc57=1,...,\ud835\udc5b.\ud835\udc5ais\nwhat we can use as a point predictor for any \ud835\udc65, and\ud835\udc602is what we use for uncertainty: if we\nwant to create an interval with a 95% probability that \ud835\udc53\u00b9\ud835\udc65\u00bais in the interval, we would use\n\ud835\udc5a\u00062\ud835\udc60. The predictivemeans and uncertainties forall the above figures werecreated using\ntheseequations. Theobserveddatapointsweregivenby \ud835\udc53\u00b9\ud835\udc651\u00ba,..., \ud835\udc53\u00b9\ud835\udc65\ud835\udc5b\u00baandchoseafine\ngrained set of \ud835\udc65points to make predictions.\nLet\u2019s suppose we observe a single datapoint, \ud835\udc53\u00b9\ud835\udc651\u00ba, and we want to determine the value\nof\ud835\udc53\u00b9\ud835\udc65\u00baat some\ud835\udc65.", "mimetype": "text/plain", "start_char_idx": 1690793, "end_char_idx": 1692676, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ad7cad6b-46db-4336-a5d0-cf4bca1889ca": {"__data__": {"id_": "ad7cad6b-46db-4336-a5d0-cf4bca1889ca", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e7b06f7a-090d-493f-b4ee-b5e1ae15f3c0", "node_type": "1", "metadata": {}, "hash": "bf6695aeefddf1d661942570af7eac4094c90e744e197b2a8491c93c4f69caf2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b75352c8-a8bb-484d-81af-d1b615d9e5d4", "node_type": "1", "metadata": {}, "hash": "bf4328490c0b852f3ea4baa5d4cd799ea09ef9ad8c0028543ffc80b13ee83828", "class_name": "RelatedNodeInfo"}}, "text": "The predictivemeans and uncertainties forall the above figures werecreated using\ntheseequations. Theobserveddatapointsweregivenby \ud835\udc53\u00b9\ud835\udc651\u00ba,..., \ud835\udc53\u00b9\ud835\udc65\ud835\udc5b\u00baandchoseafine\ngrained set of \ud835\udc65points to make predictions.\nLet\u2019s suppose we observe a single datapoint, \ud835\udc53\u00b9\ud835\udc651\u00ba, and we want to determine the value\nof\ud835\udc53\u00b9\ud835\udc65\u00baat some\ud835\udc65. Because\ud835\udc53\u00b9\ud835\udc65\u00bais described by a Gaussian process, we know the joint\ndistribution over\u00b9\ud835\udc53\u00b9\ud835\udc65\u00ba, \ud835\udc53\u00b9\ud835\udc651\u00ba\u00bais Gaussian:\n\u0014\ud835\udc53\u00b9\ud835\udc65\u00ba\n\ud835\udc53\u00b9\ud835\udc651\u00ba\u0015\n\u0018N\u0012\n\ud835\udf07,\u0014\ud835\udc58\u00b9\ud835\udc65,\ud835\udc65\u00ba\ud835\udc58\u00b9\ud835\udc65,\ud835\udc65 1\u00ba\n\ud835\udc58\u00b9\ud835\udc651,\ud835\udc65\u00ba\ud835\udc58\u00b9\ud835\udc651,\ud835\udc651\u00ba\u0015\u0013\n(18.1.6)\nThe off-diagonal expression \ud835\udc58\u00b9\ud835\udc65,\ud835\udc65 1\u00ba=\ud835\udc58\u00b9\ud835\udc651,\ud835\udc65\u00batells us how correlated the function values\nwill be \u2014 how strongly determined \ud835\udc53\u00b9\ud835\udc65\u00bawill be from \ud835\udc53\u00b9\ud835\udc651\u00ba. We have seen already that if\nwe use a large length-scale, relative to the distance between \ud835\udc65and\ud835\udc651,jj\ud835\udc65\u0000\ud835\udc651jj, then the\nfunctionvalueswillbehighlycorrelated. Wecanvisualizetheprocessofdetermining \ud835\udc53\u00b9\ud835\udc65\u00ba\nfrom\ud835\udc53\u00b9\ud835\udc651\u00baboth in the space of functions, and in the joint distribution over \ud835\udc53\u00b9\ud835\udc651\u00ba, \ud835\udc53\u00b9\ud835\udc65\u00ba.\nLet\u2019s initially consider an \ud835\udc65such that\ud835\udc58\u00b9\ud835\udc65,\ud835\udc65 1\u00ba=0.9, and\ud835\udc58\u00b9\ud835\udc65,\ud835\udc65\u00ba=1, meaning that the\nvalueof\ud835\udc53\u00b9\ud835\udc65\u00baismoderatelycorrelatedwiththevalueof \ud835\udc53\u00b9\ud835\udc651\u00ba. Inthejointdistribution,the\ncontours of constant probability will be relatively narrow ellipses.\nSuppose we observe \ud835\udc53\u00b9\ud835\udc651\u00ba=1.2. To condition on this value of \ud835\udc53\u00b9\ud835\udc651\u00ba, we can draw a\n806 Gaussian Processes\nhorizontal line at 1.2on our plot of the density, and see that the value of \ud835\udc53\u00b9\ud835\udc65\u00bais mostly\nconstrained to\u00bb0.64,1.52\u00bc. We have also drawn this plot in function space, showing the\nobservedpoint \ud835\udc53\u00b9\ud835\udc651\u00bainorange,and1standarddeviationoftheGaussianprocesspredictive\ndistribution for \ud835\udc53\u00b9\ud835\udc65\u00bain blue, about the mean value of 1.08.\nNow suppose we have a stronger correlation, \ud835\udc58\u00b9\ud835\udc65,\ud835\udc65 1\u00ba=0.95. Now the ellipses have nar-\nrowed further, and the value of \ud835\udc53\u00b9\ud835\udc65\u00bais even more strongly determined by \ud835\udc53\u00b9\ud835\udc651\u00ba. Draw-\ning a horizontal line at 1.2, we see the contours for \ud835\udc53\u00b9\ud835\udc65\u00basupport values mostly within\n\u00bb0.83,1.45\u00bc. Again, we also show the plot in function space, with one standard deviation\nabout the mean predictive value of 1.14.\n\n807 Introduction to Gaussian Processes\nWe see that the posterior mean predictor of our Gaussian process is closer to 1.2, be-\ncause there is now a stronger correlation. We also see that our uncertainty (the error bars)\nhave somewhat decreased. Despite the strong correlation between these function values,\nour uncertainty is still righly quite large, because we have only observed a single data\npoint!\nThis procedure can give us a posterior on \ud835\udc53\u00b9\ud835\udc65\u00bafor any\ud835\udc65, for any number of points we have\nobserved. Suppose we observe \ud835\udc53\u00b9\ud835\udc651\u00ba, \ud835\udc53\u00b9\ud835\udc652\u00ba. We now visualize the posterior for \ud835\udc53\u00b9\ud835\udc65\u00baat a\nparticular\ud835\udc65=\ud835\udc650in function space.", "mimetype": "text/plain", "start_char_idx": 1692370, "end_char_idx": 1694933, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b75352c8-a8bb-484d-81af-d1b615d9e5d4": {"__data__": {"id_": "b75352c8-a8bb-484d-81af-d1b615d9e5d4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ad7cad6b-46db-4336-a5d0-cf4bca1889ca", "node_type": "1", "metadata": {}, "hash": "feb587251acbb23a161f7cb285cfe58c73e0eba902051cb15ea4aad5326c6d40", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2a0b1413-c297-4845-8f50-887220c6f48e", "node_type": "1", "metadata": {}, "hash": "ac1da532d86ea98c25438059690a7a331618f40c8e3124358660771764bacdc9", "class_name": "RelatedNodeInfo"}}, "text": "Again, we also show the plot in function space, with one standard deviation\nabout the mean predictive value of 1.14.\n\n807 Introduction to Gaussian Processes\nWe see that the posterior mean predictor of our Gaussian process is closer to 1.2, be-\ncause there is now a stronger correlation. We also see that our uncertainty (the error bars)\nhave somewhat decreased. Despite the strong correlation between these function values,\nour uncertainty is still righly quite large, because we have only observed a single data\npoint!\nThis procedure can give us a posterior on \ud835\udc53\u00b9\ud835\udc65\u00bafor any\ud835\udc65, for any number of points we have\nobserved. Suppose we observe \ud835\udc53\u00b9\ud835\udc651\u00ba, \ud835\udc53\u00b9\ud835\udc652\u00ba. We now visualize the posterior for \ud835\udc53\u00b9\ud835\udc65\u00baat a\nparticular\ud835\udc65=\ud835\udc650in function space. The exact distribution for \ud835\udc53\u00b9\ud835\udc65\u00bais given by the above\nequations.\ud835\udc53\u00b9\ud835\udc65\u00bais Gaussian distributed, with mean\n\ud835\udc5a=\ud835\udc58\u00b9\ud835\udc65,\ud835\udc65 1:3\u00ba\ud835\udc58\u00b9\ud835\udc651:3,\ud835\udc651:3\u00ba\u00001\ud835\udc53\u00b9\ud835\udc651:3\u00ba (18.1.7)\nand variance\n\ud835\udc602=\ud835\udc58\u00b9\ud835\udc65,\ud835\udc65\u00ba\u0000\ud835\udc58\u00b9\ud835\udc65,\ud835\udc65 1:3\u00ba\ud835\udc58\u00b9\ud835\udc651:3,\ud835\udc651:3\u00ba\u00001\ud835\udc58\u00b9\ud835\udc65,\ud835\udc65 1:3\u00ba (18.1.8)\nInthisintroductorynotebook,wehavebeenconsidering noisefree observations. Aswewill\nsee, it is easy to include observation noise. If we assume that the data are generated from a\nlatent noise free function \ud835\udc53\u00b9\ud835\udc65\u00baplus iid Gaussian noise \ud835\udf16\u00b9\ud835\udc65\u00ba\u0018N\u00b9 0,\ud835\udf0e2\u00bawith variance \ud835\udf0e2,\nthenourcovariancefunctionsimplybecomes \ud835\udc58\u00b9\ud835\udc65\ud835\udc56,\ud835\udc65\ud835\udc57\u00ba!\ud835\udc58\u00b9\ud835\udc65\ud835\udc56,\ud835\udc65\ud835\udc57\u00ba\u00b8\ud835\udeff\ud835\udc56\ud835\udc57\ud835\udf0e2, where\ud835\udeff\ud835\udc56\ud835\udc57=1\nif\ud835\udc56=\ud835\udc57and0otherwise.\nWe have already started getting some intuition about how we can use a Gaussian process\nto specify a prior and posterior over solutions, and how the kernel function affects the\nproperties of these solutions. In the following notebooks, we will precisely show how to\nspecify a Gaussian process prior, introduce and derive various kernel functions, and then\ngo through the mechanics of how to automatically learn kernel hyperparameters, and form\na Gaussian process posterior to make predictions. While it takes time and practice to get\nused to concepts such as a \u201cdistributions over functions\u201d, the actual mechanics of finding\nthe GP predictive equations is actually quite simple \u2014 making it easy to get practice to\nform an intuitive understanding of these concepts.\n18.1.1Summary\nIn typical machine learning, we specify a function with some free parameters (such as\na neural network and its weights), and we focus on estimating those parameters, which\n808 Gaussian Processes\nmay not be interpretable. With a Gaussian process, we instead reason about distributions\nover functions directly, which enables us to reason about the high-level properties of the\nsolutions. These properties are controlled by a covariance function (kernel), which often\nhasafewhighlyinterpretablehyperparameters. Thesehyperparametersincludethe length-\nscale,whichcontrolshowrapidly(howwiggily)thefunctionsare. Anotherhyperparameter\nis the amplitude, which controls the vertical scale over which our functions are varying.\nRepresentingmanydifferentfunctionsthatcanfitthedata,andcombiningthemalltogether\ninto a predictive distribution, is a distinctive feature of Bayesian methods. Because there\nis a greater amount of variability between possible solutions far away from the data, our\nuncertainty intuitively grows as we move from the data.\nA Gaussian process represents a distribution over functions by specifying a multivariate\nnormal (Gaussian) distribution over all possible function values. It is possible to easily\nmanipulate Gaussian distributions to find the distribution of one function value based on\nthe values of any set of other values. In other words, if we observe a set of points, then we\ncan condition on these points and infer a distribution over what the value of the function\nmight look like at any other input.", "mimetype": "text/plain", "start_char_idx": 1694205, "end_char_idx": 1697806, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2a0b1413-c297-4845-8f50-887220c6f48e": {"__data__": {"id_": "2a0b1413-c297-4845-8f50-887220c6f48e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b75352c8-a8bb-484d-81af-d1b615d9e5d4", "node_type": "1", "metadata": {}, "hash": "bf4328490c0b852f3ea4baa5d4cd799ea09ef9ad8c0028543ffc80b13ee83828", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1854b75e-1faf-4491-95b4-6cc73bf2dfd4", "node_type": "1", "metadata": {}, "hash": "c97e80473a71e97a52517dc0029b1c8d2a1c3fc05fc41ce31567bff235a44f5e", "class_name": "RelatedNodeInfo"}}, "text": "Anotherhyperparameter\nis the amplitude, which controls the vertical scale over which our functions are varying.\nRepresentingmanydifferentfunctionsthatcanfitthedata,andcombiningthemalltogether\ninto a predictive distribution, is a distinctive feature of Bayesian methods. Because there\nis a greater amount of variability between possible solutions far away from the data, our\nuncertainty intuitively grows as we move from the data.\nA Gaussian process represents a distribution over functions by specifying a multivariate\nnormal (Gaussian) distribution over all possible function values. It is possible to easily\nmanipulate Gaussian distributions to find the distribution of one function value based on\nthe values of any set of other values. In other words, if we observe a set of points, then we\ncan condition on these points and infer a distribution over what the value of the function\nmight look like at any other input. How we model the correlations between these points is\ndetermined by the covariance function and is what defines the generalization properties of\nthe Gaussian process. While it takes time to get used to Gaussian processes, they are easy\nto work with, have many applications, and help us understand and develop other model\nclasses, like neural networks.\n18.1.2Exercises\n1.What is the difference between epistemic uncertainty versus observation uncertainty?\n2.Besides rate of variation and amplitude, what other properties of functions might we\nwant to consider, and what would be real-world examples of functions that have those\nproperties?\n3.The RBF covariance function we considered says that covariances (and correlations)\nbetween observations decrease with their distance in the input space (times, spatial lo-\ncations, etc.). Is this a reasonable assumption? Why or why not?\n4.Is a sum of two Gaussian variables Gaussian? Is a product of two Gaussian variables\nGaussian? If (a,b) have a joint Gaussian distribution, is a|b (a given b) Gaussian? Is a\nGaussian?\n5.Repeat the exercise where we observe a data point at \ud835\udc53\u00b9\ud835\udc651\u00ba=1.2, but now suppose we\nadditionally observe \ud835\udc53\u00b9\ud835\udc652\u00ba=1.4. Let\ud835\udc58\u00b9\ud835\udc65,\ud835\udc65 1\u00ba=0.9, and\ud835\udc58\u00b9\ud835\udc65,\ud835\udc65 2\u00ba=0.8. Will we be\nmore or less certain about the value of \ud835\udc53\u00b9\ud835\udc65\u00ba, than when we had only observed \ud835\udc53\u00b9\ud835\udc651\u00ba?\nWhat is the mean and 95% credible set for our value of \ud835\udc53\u00b9\ud835\udc65\u00banow?\n6.Do you think increasing our estimate of observation noise would increase or decrease\nour estimate of the length-scale of the ground truth function?\n7.As we move away from the data, suppose the uncertainty in our predictive distribution\nincreases to a point, then stops increasing. Why might that happen?\n809 Gaussian Process Priors\n259Discussions259.\n18.2GaussianProcess Priors\nUnderstandingGaussianprocesses(GPs)isimportantforreasoningaboutmodelconstruc-\ntionandgeneralization,andforachievingstate-of-the-artperformanceinavarietyofappli-\ncations,includingactivelearning,andhyperparametertuningindeeplearning. GPsareev-\nerywhere, anditisinourintereststoknowwhattheyareandhowwecanusethem.\nIn this section, we introduce Gaussian process priorsover functions. In the next notebook,\nwe show how to use these priors to do posterior inference and make predictions. The\nnext section can be viewed as \u201cGPs in a nutshell\u201d, quickly giving what you need to apply\nGaussian processes in practice.\nimport numpy asnp\nfrom scipy .spatial import distance_matrix\nfrom d2l import torch asd2l\nd2l.set_figsize()\n18.2.1Definition\nA Gaussian process is defined as a collection of random variables, any finite number of\nwhich have a joint Gaussian distribution . If a function \ud835\udc53\u00b9\ud835\udc65\u00bais a Gaussian process, with\nmeanfunction \ud835\udc5a\u00b9\ud835\udc65\u00baandcovariancefunction orkernel\ud835\udc58\u00b9\ud835\udc65,\ud835\udc650\u00ba,\ud835\udc53\u00b9\ud835\udc65\u00ba\u0018GP\u00b9\ud835\udc5a,\ud835\udc58\u00ba,thenany\ncollection of function values queried at any collection of input points \ud835\udc65(times, spatial lo-\ncations, imagepixels, etc.", "mimetype": "text/plain", "start_char_idx": 1696886, "end_char_idx": 1700662, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1854b75e-1faf-4491-95b4-6cc73bf2dfd4": {"__data__": {"id_": "1854b75e-1faf-4491-95b4-6cc73bf2dfd4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2a0b1413-c297-4845-8f50-887220c6f48e", "node_type": "1", "metadata": {}, "hash": "ac1da532d86ea98c25438059690a7a331618f40c8e3124358660771764bacdc9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "278211b7-2d8c-41c8-bf27-316ca001f527", "node_type": "1", "metadata": {}, "hash": "a4fe80bb8cf32181bd2da036d3d6a4280d6538d56351b86f32eaf3a3ca2d6b43", "class_name": "RelatedNodeInfo"}}, "text": "The\nnext section can be viewed as \u201cGPs in a nutshell\u201d, quickly giving what you need to apply\nGaussian processes in practice.\nimport numpy asnp\nfrom scipy .spatial import distance_matrix\nfrom d2l import torch asd2l\nd2l.set_figsize()\n18.2.1Definition\nA Gaussian process is defined as a collection of random variables, any finite number of\nwhich have a joint Gaussian distribution . If a function \ud835\udc53\u00b9\ud835\udc65\u00bais a Gaussian process, with\nmeanfunction \ud835\udc5a\u00b9\ud835\udc65\u00baandcovariancefunction orkernel\ud835\udc58\u00b9\ud835\udc65,\ud835\udc650\u00ba,\ud835\udc53\u00b9\ud835\udc65\u00ba\u0018GP\u00b9\ud835\udc5a,\ud835\udc58\u00ba,thenany\ncollection of function values queried at any collection of input points \ud835\udc65(times, spatial lo-\ncations, imagepixels, etc.), hasajointmultivariateGaussiandistributionwithmeanvector\n\ud835\udf07and covariance matrix \ud835\udc3e:\ud835\udc53\u00b9\ud835\udc651\u00ba,..., \ud835\udc53\u00b9\ud835\udc65\ud835\udc5b\u00ba\u0018N\u00b9\ud835\udf07,\ud835\udc3e\u00ba, where\ud835\udf07\ud835\udc56=\ud835\udc38\u00bb\ud835\udc53\u00b9\ud835\udc65\ud835\udc56\u00ba\u00bc=\ud835\udc5a\u00b9\ud835\udc65\ud835\udc56\u00ba\nand\ud835\udc3e\ud835\udc56\ud835\udc57=Cov\u00b9\ud835\udc53\u00b9\ud835\udc65\ud835\udc56\u00ba, \ud835\udc53\u00b9\ud835\udc65\ud835\udc57\u00ba\u00ba=\ud835\udc58\u00b9\ud835\udc65\ud835\udc56,\ud835\udc65\ud835\udc57\u00ba.\nThis definition may seem abstract and inaccessible, but Gaussian processes are in fact very\nsimple objects. Any function\n\ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc64>\ud835\udf19\u00b9\ud835\udc65\u00ba=h\ud835\udc64,\ud835\udf19\u00b9\ud835\udc65\u00bai, (18.2.1)\nwith\ud835\udc64drawn from a Gaussian (normal) distribution, and \ud835\udf19being any vector of basis func-\ntions, for example \ud835\udf19\u00b9\ud835\udc65\u00ba=\u00b91,\ud835\udc65,\ud835\udc652,...,\ud835\udc65\ud835\udc51\u00ba>, is a Gaussian process. Moreover, any Gaus-\nsian process f(x) can be expressed in the form of equation (18.2.1 ). Let\u2019s consider a few\nconcrete examples, to begin getting acquainted with Gaussian processes, after which we\ncan appreciate how simple and useful they really are.\n18.2.2ASimpleGaussian Process\n810 Gaussian Processes\nSuppose\ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc640\u00b8\ud835\udc641\ud835\udc65, and\ud835\udc640,\ud835\udc641\u0018N\u00b9 0,1\u00ba, with\ud835\udc640,\ud835\udc641,\ud835\udc65all in one dimension.\nWe can equivalently write this function as the inner product \ud835\udc53\u00b9\ud835\udc65\u00ba=\u00b9\ud835\udc640,\ud835\udc641\u00ba\u00b91,\ud835\udc65\u00ba>. In\n(18.2.1 )above,\ud835\udc64=\u00b9\ud835\udc640,\ud835\udc641\u00ba>and\ud835\udf19\u00b9\ud835\udc65\u00ba=\u00b91,\ud835\udc65\u00ba>.\nFor any\ud835\udc65,\ud835\udc53\u00b9\ud835\udc65\u00bais a sum of two Gaussian random variables. Since Gaussians are closed\nunder addition, \ud835\udc53\u00b9\ud835\udc65\u00bais also a Gaussian random variable for any \ud835\udc65. In fact, we can compute\nfor any particular \ud835\udc65that\ud835\udc53\u00b9\ud835\udc65\u00baisN\u00b90,1\u00b8\ud835\udc652\u00ba. Similarly, the joint distribution for any col-\nlection of function values, \u00b9\ud835\udc53\u00b9\ud835\udc651\u00ba,..., \ud835\udc53\u00b9\ud835\udc65\ud835\udc5b\u00ba\u00ba, for any collection of inputs \ud835\udc651,...,\ud835\udc65\ud835\udc5b, is a\nmultivariate Gaussian distribution. Therefore \ud835\udc53\u00b9\ud835\udc65\u00bais a Gaussian process.\nIn short,\ud835\udc53\u00b9\ud835\udc65\u00bais arandom function , or adistribution over functions .", "mimetype": "text/plain", "start_char_idx": 1700041, "end_char_idx": 1702129, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "278211b7-2d8c-41c8-bf27-316ca001f527": {"__data__": {"id_": "278211b7-2d8c-41c8-bf27-316ca001f527", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1854b75e-1faf-4491-95b4-6cc73bf2dfd4", "node_type": "1", "metadata": {}, "hash": "c97e80473a71e97a52517dc0029b1c8d2a1c3fc05fc41ce31567bff235a44f5e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "78234772-c54f-414e-a047-40a991152d53", "node_type": "1", "metadata": {}, "hash": "244e195a8cda0d2ff46533388122451ebf2a34e358ba7b82072fe72721381362", "class_name": "RelatedNodeInfo"}}, "text": "For any\ud835\udc65,\ud835\udc53\u00b9\ud835\udc65\u00bais a sum of two Gaussian random variables. Since Gaussians are closed\nunder addition, \ud835\udc53\u00b9\ud835\udc65\u00bais also a Gaussian random variable for any \ud835\udc65. In fact, we can compute\nfor any particular \ud835\udc65that\ud835\udc53\u00b9\ud835\udc65\u00baisN\u00b90,1\u00b8\ud835\udc652\u00ba. Similarly, the joint distribution for any col-\nlection of function values, \u00b9\ud835\udc53\u00b9\ud835\udc651\u00ba,..., \ud835\udc53\u00b9\ud835\udc65\ud835\udc5b\u00ba\u00ba, for any collection of inputs \ud835\udc651,...,\ud835\udc65\ud835\udc5b, is a\nmultivariate Gaussian distribution. Therefore \ud835\udc53\u00b9\ud835\udc65\u00bais a Gaussian process.\nIn short,\ud835\udc53\u00b9\ud835\udc65\u00bais arandom function , or adistribution over functions . We can gain some\ninsights into this distribution by repeatedly sampling values for \ud835\udc640,\ud835\udc641, and visualizing the\ncorresponding functions \ud835\udc53\u00b9\ud835\udc65\u00ba, which are straight lines with slopes and different intercepts,\nas follows:\ndef lin_func (x, n_sample):\npreds =np.zeros((n_sample, x .shape[ 0]))\nfor iiinrange (n_sample):\nw=np.random .normal( 0,1,2)\ny=w[0]+w[1]*x\npreds[ii, :] =y\nreturn preds\nx_points =np.linspace( -5,5,50)\nouts =lin_func(x_points, 10)\nlw_bd =-2*np.sqrt(( 1+x_points **2))\nup_bd =2*np.sqrt(( 1+x_points **2))\nd2l.plt.fill_between(x_points, lw_bd, up_bd, alpha =0.25 )\nd2l.plt.plot(x_points, np .zeros( len(x_points)), linewidth =4, color ='black ')\nd2l.plt.plot(x_points, outs .T)\nd2l.plt.xlabel( \"x\", fontsize =20)\nd2l.plt.ylabel( \"f(x) \", fontsize =20)\nd2l.plt.show()\nIf\ud835\udc640and\ud835\udc641are instead drawn from N\u00b90,\ud835\udefc2\u00ba, how do you imagine varying \ud835\udefcaffects the\ndistribution over functions?\n18.2.3FromWeightSpace to Function Space\n811 Gaussian Process Priors\nIn the plot above, we saw how a distribution over parameters in a model induces a distri-\nbution over functions. While we often have ideas about the functions we want to model \u2014\nwhether they\u2019re smooth, periodic, quickly varying, etc. \u2014 it is relatively tedious to reason\nabout the parameters, which are largely uninterpretable. Fortunately, Gaussian processes\nprovide an easy mechanism to reason directlyabout functions. Since a Gaussian distribu-\ntionisentirelydefinedbyitsfirsttwomoments,itsmeanandcovariancematrix,aGaussian\nprocess by extension is defined by its mean function and covariance function.\nIn the above example, the mean function\n\ud835\udc5a\u00b9\ud835\udc65\u00ba=\ud835\udc38\u00bb\ud835\udc53\u00b9\ud835\udc65\u00ba\u00bc=\ud835\udc38\u00bb\ud835\udc640\u00b8\ud835\udc641\ud835\udc65\u00bc=\ud835\udc38\u00bb\ud835\udc640\u00bc\u00b8\ud835\udc38\u00bb\ud835\udc641\u00bc\ud835\udc65=0\u00b80=0. (18.2.2)\nSimilarly, the covariance function is\n\ud835\udc58\u00b9\ud835\udc65,\ud835\udc650\u00ba=Cov\u00b9\ud835\udc53\u00b9\ud835\udc65\u00ba, \ud835\udc53\u00b9\ud835\udc650\u00ba\u00ba=\ud835\udc38\u00bb\ud835\udc53\u00b9\ud835\udc65\u00ba\ud835\udc53\u00b9\ud835\udc650\u00ba\u00bc\u0000\ud835\udc38\u00bb\ud835\udc53\u00b9\ud835\udc65\u00ba\u00bc\ud835\udc38\u00bb\ud835\udc53\u00b9\ud835\udc650\u00ba\u00bc=\ud835\udc38\u00bb\ud835\udc642\n0\u00b8\ud835\udc640\ud835\udc641\ud835\udc650\u00b8\ud835\udc641\ud835\udc640\ud835\udc65\u00b8\ud835\udc642\n1\ud835\udc65\ud835\udc650\u00bc=1\u00b8\ud835\udc65\ud835\udc650.\n(18.2.3)\nOur distribution over functions can now be directly specified and sampled from, without\nneeding to sample from the distribution over parameters. For example, to draw from \ud835\udc53\u00b9\ud835\udc65\u00ba,\nwecansimplyformourmultivariateGaussiandistributionassociatedwithanycollectionof\n\ud835\udc65wewanttoquery,andsamplefromitdirectly. Wewillbegintoseejusthowadvantageous\nthis formulation will be.", "mimetype": "text/plain", "start_char_idx": 1701634, "end_char_idx": 1704277, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "78234772-c54f-414e-a047-40a991152d53": {"__data__": {"id_": "78234772-c54f-414e-a047-40a991152d53", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "278211b7-2d8c-41c8-bf27-316ca001f527", "node_type": "1", "metadata": {}, "hash": "a4fe80bb8cf32181bd2da036d3d6a4280d6538d56351b86f32eaf3a3ca2d6b43", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c001f618-7031-4d55-a2e7-bf9ce23f658c", "node_type": "1", "metadata": {}, "hash": "4c7df1dc123aed17b52f453d5fa45bc6c1f9d8e373502608f5b5f266a5417191", "class_name": "RelatedNodeInfo"}}, "text": "(18.2.3)\nOur distribution over functions can now be directly specified and sampled from, without\nneeding to sample from the distribution over parameters. For example, to draw from \ud835\udc53\u00b9\ud835\udc65\u00ba,\nwecansimplyformourmultivariateGaussiandistributionassociatedwithanycollectionof\n\ud835\udc65wewanttoquery,andsamplefromitdirectly. Wewillbegintoseejusthowadvantageous\nthis formulation will be.\nFirst, we note that essentially the same derivation for the simple straight line model above\ncan be applied to find the mean and covariance function for anymodel of the form \ud835\udc53\u00b9\ud835\udc65\u00ba=\n\ud835\udc64>\ud835\udf19\u00b9\ud835\udc65\u00ba, with\ud835\udc64\u0018N\u00b9\ud835\udc62,\ud835\udc46\u00ba. In this case, the mean function \ud835\udc5a\u00b9\ud835\udc65\u00ba=\ud835\udc62>\ud835\udf19\u00b9\ud835\udc65\u00ba, and the\ncovariancefunction \ud835\udc58\u00b9\ud835\udc65,\ud835\udc650\u00ba=\ud835\udf19\u00b9\ud835\udc65\u00ba>\ud835\udc46\ud835\udf19\u00b9\ud835\udc650\u00ba. Since\ud835\udf19\u00b9\ud835\udc65\u00bacanrepresentavectorofanynon-\nlinear basis functions, we are considering a very general model class, including models\nwith an even an infinitenumber of parameters.\n18.2.4TheRadial Basis Function (RBF) Kernel\nTheradial basis function (RBF) kernel is the most popular covariance function for Gaus-\nsian processes, and kernel machines in general. This kernel has the form \ud835\udc58RBF\u00b9\ud835\udc65,\ud835\udc650\u00ba=\n\ud835\udc4e2exp\u0010\n\u00001\n2\u21132jj\ud835\udc65\u0000\ud835\udc650jj2\u0011\n, where\ud835\udc4eis an amplitude parameter, and \u2113is alengthscale hyper-\nparameter.\nLet\u2019s derive this kernel starting from weight space. Consider the function\n\ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc3d\u00d5\n\ud835\udc56=1\ud835\udc64\ud835\udc56\ud835\udf19\ud835\udc56\u00b9\ud835\udc65\u00ba,\ud835\udc64\ud835\udc56\u0018N\u0012\n0,\ud835\udf0e2\n\ud835\udc3d\u0013\n,\ud835\udf19\ud835\udc56\u00b9\ud835\udc65\u00ba=exp\u0012\n\u0000\u00b9\ud835\udc65\u0000\ud835\udc50\ud835\udc56\u00ba2\n2\u21132\u0013\n. (18.2.4)\n\ud835\udc53\u00b9\ud835\udc65\u00bais a sum of radial basis functions, with width \u2113, centred at the points \ud835\udc50\ud835\udc56, as shown in\nthe following figure.\nWe can recognize \ud835\udc53\u00b9\ud835\udc65\u00baas having the form \ud835\udc64>\ud835\udf19\u00b9\ud835\udc65\u00ba, where\ud835\udc64=\u00b9\ud835\udc641,...,\ud835\udc64\ud835\udc3d\u00ba>and\ud835\udf19\u00b9\ud835\udc65\u00ba\nis a vector containing each of the radial basis functions. The covariance function of this\n812 Gaussian Processes\nGaussian process is then\n\ud835\udc58\u00b9\ud835\udc65,\ud835\udc650\u00ba=\ud835\udf0e2\n\ud835\udc3d\ud835\udc3d\u00d5\n\ud835\udc56=1\ud835\udf19\ud835\udc56\u00b9\ud835\udc65\u00ba\ud835\udf19\ud835\udc56\u00b9\ud835\udc650\u00ba. (18.2.5)\nNowlet\u2019sconsiderwhathappensaswetakethenumberofparameters(andbasisfunctions)\nto infinity. Let \ud835\udc50\ud835\udc3d=log\ud835\udc3d,\ud835\udc501=\u0000log\ud835\udc3d, and\ud835\udc50\ud835\udc56\u00b81\u0000\ud835\udc50\ud835\udc56= \u0394\ud835\udc50=2log\ud835\udc3d\n\ud835\udc3d, and\ud835\udc3d!1. The\ncovariance function becomes the Riemann sum:\n\ud835\udc58\u00b9\ud835\udc65,\ud835\udc650\u00ba=lim\n\ud835\udc3d!1\ud835\udf0e2\n\ud835\udc3d\ud835\udc3d\u00d5\n\ud835\udc56=1\ud835\udf19\ud835\udc56\u00b9\ud835\udc65\u00ba\ud835\udf19\ud835\udc56\u00b9\ud835\udc650\u00ba=\u00b9\ud835\udc501\n\ud835\udc500\ud835\udf19\ud835\udc50\u00b9\ud835\udc65\u00ba\ud835\udf19\ud835\udc50\u00b9\ud835\udc650\u00ba\ud835\udc51\ud835\udc50.", "mimetype": "text/plain", "start_char_idx": 1703910, "end_char_idx": 1705822, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c001f618-7031-4d55-a2e7-bf9ce23f658c": {"__data__": {"id_": "c001f618-7031-4d55-a2e7-bf9ce23f658c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "78234772-c54f-414e-a047-40a991152d53", "node_type": "1", "metadata": {}, "hash": "244e195a8cda0d2ff46533388122451ebf2a34e358ba7b82072fe72721381362", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fa4f03f8-a7af-43e8-91c4-b4e0c879a814", "node_type": "1", "metadata": {}, "hash": "9bdcac51a09be941d8292a7a3376905f58a0254f7674a40036da7bfaf9985a5c", "class_name": "RelatedNodeInfo"}}, "text": "Let \ud835\udc50\ud835\udc3d=log\ud835\udc3d,\ud835\udc501=\u0000log\ud835\udc3d, and\ud835\udc50\ud835\udc56\u00b81\u0000\ud835\udc50\ud835\udc56= \u0394\ud835\udc50=2log\ud835\udc3d\n\ud835\udc3d, and\ud835\udc3d!1. The\ncovariance function becomes the Riemann sum:\n\ud835\udc58\u00b9\ud835\udc65,\ud835\udc650\u00ba=lim\n\ud835\udc3d!1\ud835\udf0e2\n\ud835\udc3d\ud835\udc3d\u00d5\n\ud835\udc56=1\ud835\udf19\ud835\udc56\u00b9\ud835\udc65\u00ba\ud835\udf19\ud835\udc56\u00b9\ud835\udc650\u00ba=\u00b9\ud835\udc501\n\ud835\udc500\ud835\udf19\ud835\udc50\u00b9\ud835\udc65\u00ba\ud835\udf19\ud835\udc50\u00b9\ud835\udc650\u00ba\ud835\udc51\ud835\udc50. (18.2.6)\nBy setting\ud835\udc500=\u00001and\ud835\udc501=1, we spread the infinitely many basis functions across the\nwhole real line, each a distance \u0394\ud835\udc50!0apart:\n\ud835\udc58\u00b9\ud835\udc65,\ud835\udc650\u00ba=\u00b91\n\u00001exp\u00b9\u0000\u00b9\ud835\udc65\u0000\ud835\udc50\u00ba2\n2\u21132\u00baexp\u00b9\u0000\u00b9\ud835\udc650\u0000\ud835\udc50\u00ba2\n2\u21132\u00ba\ud835\udc51\ud835\udc50=p\ud835\udf0b\u2113\ud835\udf0e2exp\u00b9\u0000\u00b9\ud835\udc65\u0000\ud835\udc650\u00ba2\n2\u00b9p\n2\u2113\u00ba2\u00ba/\ud835\udc58RBF\u00b9\ud835\udc65,\ud835\udc650\u00ba.\n(18.2.7)\nItisworthtakingamomenttoabsorbwhatwehavedonehere. Bymovingintothefunction\nspace representation, we have derived how to represent a model with an infinitenumber of\nparameters, using a finite amount of computation. A Gaussian process with an RBF kernel\nis auniversal approximator , capable of representing any continuous function to arbitrary\nprecision. We can intuitively see why from the above derivation. We can collapse each\nradial basis function to a point mass taking \u2113!0, and give each point mass any height we\nwish.\nSo a Gaussian process with an RBF kernel is a model with an infinite number of param-\neters and much more flexibility than any finite neural network. Perhaps all the fuss about\noverparametrized neural networks is misplaced. As we will see, GPs with RBF kernels\ndo not overfit, and in fact provide especially compelling generalization performance on\nsmall datasets. Moreover, the examples in ( Zhanget al., 2021), such as the ability to fit\nimages with random labels perfectly, but still generalize well on structured problems, (can\nbe perfectly reproduced using Gaussian processes) ( Wilson and Izmailov, 2020 ). Neural\nnetworks are not as distinct as we make them out to be.\nWe can build further intuition about Gaussian processes with RBF kernels, and hyperpa-\nrameters such as length-scale , by sampling directly from the distribution over functions.\nAs before, this involves a simple procedure:\n1.Choose the input \ud835\udc65points we want to query the GP: \ud835\udc651,...,\ud835\udc65\ud835\udc5b.\n2.Evaluate\ud835\udc5a\u00b9\ud835\udc65\ud835\udc56\u00ba,\ud835\udc56=1,...,\ud835\udc5b, and\ud835\udc58\u00b9\ud835\udc65\ud835\udc56,\ud835\udc65\ud835\udc57\u00bafor\ud835\udc56,\ud835\udc57=1,...,\ud835\udc5bto respectively form the\nmean vector and covariance matrix \ud835\udf07and\ud835\udc3e, where\u00b9\ud835\udc53\u00b9\ud835\udc651\u00ba,..., \ud835\udc53\u00b9\ud835\udc65\ud835\udc5b\u00ba\u00ba\u0018N\u00b9\ud835\udf07,\ud835\udc3e\u00ba.\n3.Sample from this multivariate Gaussian distribution to obtain the sample function val-\nues.\n4.Sample more times to visualize more sample functions queried at those points.\nWe illustrate this process in the figure below.\n813 Gaussian Process Priors\ndef rbfkernel (x1, x2, ls =4.): #@save\ndist =distance_matrix(np .expand_dims(x1, 1), np .expand_dims(x2, 1))\nreturn np.exp( -(1./ls/2)*(dist **2))\nx_points =np.linspace( 0,5,50)\nmeanvec =np.zeros( len(x_points))\ncovmat =rbfkernel(x_points,x_points, 1)\nprior_samples =np.random .multivariate_normal(meanvec, covmat, size =5);\nd2l.plt.plot(x_points, prior_samples .T, alpha =0.5)\nd2l.plt.show()\n18.2.5TheNeuralNetworkKernel\nResearch on Gaussian processes in machine learning was triggered by research on neu-\nral networks.", "mimetype": "text/plain", "start_char_idx": 1705662, "end_char_idx": 1708459, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fa4f03f8-a7af-43e8-91c4-b4e0c879a814": {"__data__": {"id_": "fa4f03f8-a7af-43e8-91c4-b4e0c879a814", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c001f618-7031-4d55-a2e7-bf9ce23f658c", "node_type": "1", "metadata": {}, "hash": "4c7df1dc123aed17b52f453d5fa45bc6c1f9d8e373502608f5b5f266a5417191", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "25ddc4eb-6ecd-4ad4-9378-44b79b47661f", "node_type": "1", "metadata": {}, "hash": "48b65c36c91d96cd16c4a0315120fa2652d128007de8581fd8579307d188af91", "class_name": "RelatedNodeInfo"}}, "text": "4.Sample more times to visualize more sample functions queried at those points.\nWe illustrate this process in the figure below.\n813 Gaussian Process Priors\ndef rbfkernel (x1, x2, ls =4.): #@save\ndist =distance_matrix(np .expand_dims(x1, 1), np .expand_dims(x2, 1))\nreturn np.exp( -(1./ls/2)*(dist **2))\nx_points =np.linspace( 0,5,50)\nmeanvec =np.zeros( len(x_points))\ncovmat =rbfkernel(x_points,x_points, 1)\nprior_samples =np.random .multivariate_normal(meanvec, covmat, size =5);\nd2l.plt.plot(x_points, prior_samples .T, alpha =0.5)\nd2l.plt.show()\n18.2.5TheNeuralNetworkKernel\nResearch on Gaussian processes in machine learning was triggered by research on neu-\nral networks. Radford Neal was pursuing ever larger Bayesian neural networks, ultimately\nshowing in 1994 (later published in 1996, as it was one of the most infamous NeurIPS\nrejections) that such networks with an infinite number of hidden units become Gaussian\nprocesses with particular kernel functions ( Neal, 1996 ). Interest in this derivation has re-\nsurfaced, with ideas like the neural tangent kernel being used to investigate the generaliza-\ntion properties of neural networks ( Matthews et al., 2018) (Novaket al., 2018). We can\nderive the neural network kernel as follows.\nConsider a neural network function \ud835\udc53\u00b9\ud835\udc65\u00bawith one hidden layer:\n\ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc4f\u00b8\ud835\udc3d\u00d5\n\ud835\udc56=1\ud835\udc63\ud835\udc56\u210e\u00b9\ud835\udc65;\ud835\udc62\ud835\udc56\u00ba. (18.2.8)\n\ud835\udc4fis a bias,\ud835\udc63\ud835\udc56are the hidden to output weights, \u210eis any bounded hidden unit transfer\nfunction,\ud835\udc62\ud835\udc56are the input to hidden weights, and \ud835\udc3dis the number of hidden units. Let \ud835\udc4fand\n\ud835\udc63\ud835\udc56be independent with zero mean and variances \ud835\udf0e2\n\ud835\udc4fand\ud835\udf0e2\n\ud835\udc63\u009d\ud835\udc3d, respectively, and let the \ud835\udc62\ud835\udc56\nhaveindependentidenticaldistributions. Wecanthenusethecentrallimittheoremtoshow\nthat any collection of function values \ud835\udc53\u00b9\ud835\udc651\u00ba,..., \ud835\udc53\u00b9\ud835\udc65\ud835\udc5b\u00bahas a joint multivariate Gaussian\ndistribution.\nThe mean and covariance function of the corresponding Gaussian process are:\n\ud835\udc5a\u00b9\ud835\udc65\u00ba=\ud835\udc38\u00bb\ud835\udc53\u00b9\ud835\udc65\u00ba\u00bc=0 (18.2.9)\n814 Gaussian Processes\n\ud835\udc58\u00b9\ud835\udc65,\ud835\udc650\u00ba=cov\u00bb\ud835\udc53\u00b9\ud835\udc65\u00ba, \ud835\udc53\u00b9\ud835\udc650\u00ba\u00bc=\ud835\udc38\u00bb\ud835\udc53\u00b9\ud835\udc65\u00ba\ud835\udc53\u00b9\ud835\udc650\u00ba\u00bc=\ud835\udf0e2\n\ud835\udc4f\u00b81\n\ud835\udc3d\ud835\udc3d\u00d5\n\ud835\udc56=1\ud835\udf0e2\n\ud835\udc63\ud835\udc38\u00bb\u210e\ud835\udc56\u00b9\ud835\udc65;\ud835\udc62\ud835\udc56\u00ba\u210e\ud835\udc56\u00b9\ud835\udc650;\ud835\udc62\ud835\udc56\u00ba\u00bc\n(18.2.10)\nIn some cases, we can essentially evaluate this covariance function in closed form. Let\n\u210e\u00b9\ud835\udc65;\ud835\udc62\u00ba=erf\u00b9\ud835\udc620\u00b8\u00cd\ud835\udc43\n\ud835\udc57=1\ud835\udc62\ud835\udc57\ud835\udc65\ud835\udc57\u00ba, where erf\u00b9\ud835\udc67\u00ba=2p\ud835\udf0b\u00af\ud835\udc67\n0\ud835\udc52\u0000\ud835\udc612\ud835\udc51\ud835\udc61, and\ud835\udc62\u0018N\u00b9 0,\u03a3\u00ba. Then\n\ud835\udc58\u00b9\ud835\udc65,\ud835\udc650\u00ba=2\n\ud835\udf0bsin\u00b92 \u02dc\ud835\udc65>\u03a3\u02dc\ud835\udc650p\n\u00b91\u00b82 \u02dc\ud835\udc65>\u03a3\u02dc\ud835\udc65\u00ba\u00b91\u00b82 \u02dc\ud835\udc650>\u03a3\u02dc\ud835\udc650\u00ba\u00ba.\nThe RBF kernel is stationary , meaning that it is translation invariant , and therefore can\nbe written as a function of \ud835\udf0f=\ud835\udc65\u0000\ud835\udc650.", "mimetype": "text/plain", "start_char_idx": 1707783, "end_char_idx": 1710124, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "25ddc4eb-6ecd-4ad4-9378-44b79b47661f": {"__data__": {"id_": "25ddc4eb-6ecd-4ad4-9378-44b79b47661f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fa4f03f8-a7af-43e8-91c4-b4e0c879a814", "node_type": "1", "metadata": {}, "hash": "9bdcac51a09be941d8292a7a3376905f58a0254f7674a40036da7bfaf9985a5c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4cf04562-8f51-4a87-9a36-5ace5410436b", "node_type": "1", "metadata": {}, "hash": "384a31b34ee63b51a3d08209098a18aab358ba4a2130919ada0010e356f6d5d0", "class_name": "RelatedNodeInfo"}}, "text": "Then\n\ud835\udc58\u00b9\ud835\udc65,\ud835\udc650\u00ba=2\n\ud835\udf0bsin\u00b92 \u02dc\ud835\udc65>\u03a3\u02dc\ud835\udc650p\n\u00b91\u00b82 \u02dc\ud835\udc65>\u03a3\u02dc\ud835\udc65\u00ba\u00b91\u00b82 \u02dc\ud835\udc650>\u03a3\u02dc\ud835\udc650\u00ba\u00ba.\nThe RBF kernel is stationary , meaning that it is translation invariant , and therefore can\nbe written as a function of \ud835\udf0f=\ud835\udc65\u0000\ud835\udc650. Intuitively, stationarity means that the high-level\nproperties of the function, such as rate of variation, do not change as we move in input\nspace. The neural network kernel, however, is non-stationary . Below, we show sample\nfunctions from a Gaussian process with this kernel. We can see that the function looks\nqualitatively different near the origin.\n18.2.6Summary\nThe first step in performing Bayesian inference involves specifying a prior. Gaussian pro-\ncesses can be used to specify a whole prior over functions. Starting from a traditional\n\u201cweightspace\u201dviewofmodelling,wecaninduceaprioroverfunctionsbystartingwiththe\nfunctional form of a model, and introducing a distribution over its parameters. We can al-\nternativelyspecifyapriordistributiondirectlyinfunctionspace,withpropertiescontrolled\nby a kernel. The function-space approach has many advantages. We can build models that\nactually correspond to an infinite number of parameters, but use a finite amount of com-\nputation! Moreover, while these models have a great amount of flexibility, they also make\nstrong assumptions about what types of functions are a priori likely, leading to relatively\ngood generalization on small datasets.\nTheassumptionsofmodelsinfunctionspaceareintuitivelycontrolledbykernels,whichof-\nten encode higher level properties of functions, such as smoothness and periodicity. Many\nkernels are stationary, meaning that they are translation invariant. Functions drawn from\na Gaussian process with a stationary kernel have roughly the same high-level properties\n(such as rate of variation) regardless of where we look in the input space.\nGaussianprocessesarearelativelygeneralmodelclass,containingmanyexamplesofmod-\nels we are already familiar with, including polynomials, Fourier series, and so on, as long\nas we have a Gaussian prior over the parameters. They also include neural networks with\nan infinite number of parameters, even without Gaussian distributions over the parameters.\nThis connection, discovered by Radford Neal, triggered machine learning researchers to\nmove away from neural networks, and towards Gaussian processes.\n18.2.7Exercises\n1.DrawsamplepriorfunctionsfromaGPwithanOrnstein-Uhlenbeck(OU)kernel, \ud835\udc58OU\u00b9\ud835\udc65,\ud835\udc650\u00ba=\nexp\u0010\n\u00001\n2\u2113jj\ud835\udc65\u0000\ud835\udc650j\u0011\n. If you fix the lengthscale \u2113to be the same, how do these functions\nlook different than sample functions from a GP with an RBF kernel?\n815 Gaussian Process Inference\n260\n2612.How does changing the amplitude\ud835\udc4e2of the RBF kernel affect the distribution over\nfunctions?\n3.Supposeweform \ud835\udc62\u00b9\ud835\udc65\u00ba=\ud835\udc53\u00b9\ud835\udc65\u00ba\u00b82\ud835\udc54\u00b9\ud835\udc65\u00ba,where\ud835\udc53\u00b9\ud835\udc65\u00ba\u0018GP\u00b9\ud835\udc5a1,\ud835\udc581\u00baand\ud835\udc54\u00b9\ud835\udc65\u00ba\u0018GP\u00b9\ud835\udc5a2,\ud835\udc582\u00ba.\nIs\ud835\udc62\u00b9\ud835\udc65\u00baa Gaussian process, and if so, what is its mean and covariance function?\n4.Suppose we form \ud835\udc54\u00b9\ud835\udc65\u00ba=\ud835\udc4e\u00b9\ud835\udc65\u00ba\ud835\udc53\u00b9\ud835\udc65\u00ba, where\ud835\udc53\u00b9\ud835\udc65\u00ba\u0018GP\u00b9 0,\ud835\udc58\u00baand\ud835\udc4e\u00b9\ud835\udc65\u00ba=\ud835\udc652. Is\ud835\udc54\u00b9\ud835\udc65\u00ba\na Gaussian process, and if so, what is its mean and covariance function? What is the\neffect of\ud835\udc4e\u00b9\ud835\udc65\u00ba? What do sample functions drawn from \ud835\udc54\u00b9\ud835\udc65\u00balook like?\n5.Supposeweform \ud835\udc62\u00b9\ud835\udc65\u00ba=\ud835\udc53\u00b9\ud835\udc65\u00ba\ud835\udc54\u00b9\ud835\udc65\u00ba,where\ud835\udc53\u00b9\ud835\udc65\u00ba\u0018GP\u00b9\ud835\udc5a1,\ud835\udc581\u00baand\ud835\udc54\u00b9\ud835\udc65\u00ba\u0018GP\u00b9\ud835\udc5a2,\ud835\udc582\u00ba.", "mimetype": "text/plain", "start_char_idx": 1709937, "end_char_idx": 1713065, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4cf04562-8f51-4a87-9a36-5ace5410436b": {"__data__": {"id_": "4cf04562-8f51-4a87-9a36-5ace5410436b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "25ddc4eb-6ecd-4ad4-9378-44b79b47661f", "node_type": "1", "metadata": {}, "hash": "48b65c36c91d96cd16c4a0315120fa2652d128007de8581fd8579307d188af91", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8609a38c-b9b3-483a-b596-d0c11beb5551", "node_type": "1", "metadata": {}, "hash": "80b45c071b6e401a13b88d4c529a821d17fa26cd7e93e3182c2d3df6430c066a", "class_name": "RelatedNodeInfo"}}, "text": "Is\ud835\udc54\u00b9\ud835\udc65\u00ba\na Gaussian process, and if so, what is its mean and covariance function? What is the\neffect of\ud835\udc4e\u00b9\ud835\udc65\u00ba? What do sample functions drawn from \ud835\udc54\u00b9\ud835\udc65\u00balook like?\n5.Supposeweform \ud835\udc62\u00b9\ud835\udc65\u00ba=\ud835\udc53\u00b9\ud835\udc65\u00ba\ud835\udc54\u00b9\ud835\udc65\u00ba,where\ud835\udc53\u00b9\ud835\udc65\u00ba\u0018GP\u00b9\ud835\udc5a1,\ud835\udc581\u00baand\ud835\udc54\u00b9\ud835\udc65\u00ba\u0018GP\u00b9\ud835\udc5a2,\ud835\udc582\u00ba.\nIs\ud835\udc62\u00b9\ud835\udc65\u00baa Gaussian process, and if so, what is its mean and covariance function?\nDiscussions260.\n18.3Gaussian ProcessInference\nInthissection,wewillshowhowtoperformposteriorinferenceandmakepredictionsusing\ntheGPpriorsweintroducedinthelastsection. Wewillstartwithregression,wherewecan\nperform inference in closed form . This is a \u201cGPs in a nutshell\u201d section to quickly get up\nandrunningwithGaussianprocessesinpractice. We\u2019llstartcodingallthebasicoperations\nfromscratch,andthenintroduce GPyTorch261,whichwillmakeworkingwithstate-of-the-\nart Gaussian processes and integration with deep neural networks much more convenient.\nWe will consider these more advanced topics in depth in the next section. In that section,\nwe will also consider settings where approximate inference is required \u2014 classification,\npoint processes, or any non-Gaussian likelihoods.\n18.3.1PosteriorInferencefor Regression\nAnobservation model relates the function we want to learn, \ud835\udc53\u00b9\ud835\udc65\u00ba, to our observations\n\ud835\udc66\u00b9\ud835\udc65\u00ba, both indexed by some input \ud835\udc65. In classification, \ud835\udc65could be the pixels of an image,\nand\ud835\udc66couldbe the associated classlabel. In regression, \ud835\udc66typicallyrepresents a continuous\noutput, such as a land surface temperature, a sea-level, a \ud835\udc36\ud835\udc42 2concentration, etc.\nIn regression, we often assume the outputs are given by a latent noise-free function \ud835\udc53\u00b9\ud835\udc65\u00ba\nplus i.i.d. Gaussian noise \ud835\udf16\u00b9\ud835\udc65\u00ba:\n\ud835\udc66\u00b9\ud835\udc65\u00ba=\ud835\udc53\u00b9\ud835\udc65\u00ba\u00b8\ud835\udf16\u00b9\ud835\udc65\u00ba, (18.3.1)\nwith\ud835\udf16\u00b9\ud835\udc65\u00ba\u0018N\u00b9 0,\ud835\udf0e2\u00ba. Lety=\ud835\udc66\u00b9\ud835\udc4b\u00ba=\u00b9\ud835\udc66\u00b9\ud835\udc651\u00ba,...,\ud835\udc66\u00b9\ud835\udc65\ud835\udc5b\u00ba\u00ba>be a vector of our training\nobservations, and f=\u00b9\ud835\udc53\u00b9\ud835\udc651\u00ba,..., \ud835\udc53\u00b9\ud835\udc65\ud835\udc5b\u00ba\u00ba>be a vector of the latent noise-free function\nvalues, queried at the training inputs \ud835\udc4b=\ud835\udc651,...,\ud835\udc65\ud835\udc5b.\nWe will assume \ud835\udc53\u00b9\ud835\udc65\u00ba\u0018GP\u00b9\ud835\udc5a,\ud835\udc58\u00ba, which means that any collection of function values f\nhasajointmultivariateGaussiandistribution,withmeanvector \ud835\udf07\ud835\udc56=\ud835\udc5a\u00b9\ud835\udc65\ud835\udc56\u00baandcovariance\nmatrix\ud835\udc3e\ud835\udc56\ud835\udc57=\ud835\udc58\u00b9\ud835\udc65\ud835\udc56,\ud835\udc65\ud835\udc57\u00ba. The RBF kernel \ud835\udc58\u00b9\ud835\udc65\ud835\udc56,\ud835\udc65\ud835\udc57\u00ba=\ud835\udc4e2exp\u0010\n\u00001\n2\u21132jj\ud835\udc65\ud835\udc56\u0000\ud835\udc65\ud835\udc57jj2\u0011\nwould be a\n816 Gaussian Processes\nstandardchoiceofcovariancefunction. Fornotationalsimplicity,wewillassumethemean\nfunction\ud835\udc5a\u00b9\ud835\udc65\u00ba=0; our derivations can easily be generalized later on.\nSuppose we want to make predictions at a set of inputs\n\ud835\udc4b\u0003=\ud835\udc65\u00031,\ud835\udc65\u00032,...,\ud835\udc65\u0003\ud835\udc5a. (18.3.2)\nThen we want to find \ud835\udc652and\ud835\udc5d\u00b9f\u0003jy,\ud835\udc4b\u00ba. In the regression setting, we can conveniently\nfind this distribution by using Gaussian identities, after finding the joint distribution over\nf\u0003=\ud835\udc53\u00b9\ud835\udc4b\u0003\u00baandy.\nIf we evaluate equation (18.3.1 )at the training inputs \ud835\udc4b, we have y=f\u00b8\ufb04.", "mimetype": "text/plain", "start_char_idx": 1712840, "end_char_idx": 1715421, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8609a38c-b9b3-483a-b596-d0c11beb5551": {"__data__": {"id_": "8609a38c-b9b3-483a-b596-d0c11beb5551", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4cf04562-8f51-4a87-9a36-5ace5410436b", "node_type": "1", "metadata": {}, "hash": "384a31b34ee63b51a3d08209098a18aab358ba4a2130919ada0010e356f6d5d0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0b422f79-ce42-4436-b3e0-0efbb204de9c", "node_type": "1", "metadata": {}, "hash": "b6bcd167fcb9403816859ffb78697092438aa55cae795a09acc264bc87fa9577", "class_name": "RelatedNodeInfo"}}, "text": "Fornotationalsimplicity,wewillassumethemean\nfunction\ud835\udc5a\u00b9\ud835\udc65\u00ba=0; our derivations can easily be generalized later on.\nSuppose we want to make predictions at a set of inputs\n\ud835\udc4b\u0003=\ud835\udc65\u00031,\ud835\udc65\u00032,...,\ud835\udc65\u0003\ud835\udc5a. (18.3.2)\nThen we want to find \ud835\udc652and\ud835\udc5d\u00b9f\u0003jy,\ud835\udc4b\u00ba. In the regression setting, we can conveniently\nfind this distribution by using Gaussian identities, after finding the joint distribution over\nf\u0003=\ud835\udc53\u00b9\ud835\udc4b\u0003\u00baandy.\nIf we evaluate equation (18.3.1 )at the training inputs \ud835\udc4b, we have y=f\u00b8\ufb04. By the\ndefinition of a Gaussian process (see last section), f\u0018N\u00b9 0,\ud835\udc3e\u00b9\ud835\udc4b,\ud835\udc4b\u00ba\u00bawhere\ud835\udc3e\u00b9\ud835\udc4b,\ud835\udc4b\u00bais\nan\ud835\udc5b\u0002\ud835\udc5bmatrix formed by evaluating our covariance function (aka kernel) at all possible\npairs of inputs \ud835\udc65\ud835\udc56,\ud835\udc65\ud835\udc572\ud835\udc4b.\ufb04is simply a vector comprised of iid samples from N\u00b90,\ud835\udf0e2\u00ba\nand thus has distribution N\u00b90,\ud835\udf0e2\ud835\udc3c\u00ba.yis therefore a sum of two independent multivariate\nGaussian variables, and thus has distribution N\u00b90,\ud835\udc3e\u00b9\ud835\udc4b,\ud835\udc4b\u00ba\u00b8\ud835\udf0e2\ud835\udc3c\u00ba. One can also show\nthat cov\u00b9f\u0003,y\u00ba=cov\u00b9y,f\u0003\u00ba>=\ud835\udc3e\u00b9\ud835\udc4b\u0003,\ud835\udc4b\u00bawhere\ud835\udc3e\u00b9\ud835\udc4b\u0003,\ud835\udc4b\u00bais an\ud835\udc5a\u0002\ud835\udc5bmatrix formed by\nevaluating the kernel at all pairs of test and training inputs.\n\u0014y\nf\u0003\u0015\n\u0018N\u0012\n0,A=\u0014\ud835\udc3e\u00b9\ud835\udc4b,\ud835\udc4b\u00ba\u00b8\ud835\udf0e2\ud835\udc3c \ud835\udc3e\u00b9\ud835\udc4b,\ud835\udc4b\u0003\u00ba\n\ud835\udc3e\u00b9\ud835\udc4b\u0003,\ud835\udc4b\u00ba\ud835\udc3e\u00b9\ud835\udc4b\u0003,\ud835\udc4b\u0003\u00ba\u0015\u0013\n(18.3.3)\nWe can then use standard Gaussian identities to find the conditional distribution from the\njoint distribution (see, e.g., Bishop Chapter 2), f\u0003jy,\ud835\udc4b,\ud835\udc4b\u0003\u0018 N\u00b9\ud835\udc5a\u0003,\ud835\udc46\u0003\u00ba, where\ud835\udc5a\u0003=\n\ud835\udc3e\u00b9\ud835\udc4b\u0003,\ud835\udc4b\u00ba\u00bb\ud835\udc3e\u00b9\ud835\udc4b,\ud835\udc4b\u00ba\u00b8\ud835\udf0e2\ud835\udc3c\u00bc\u00001y,and\ud835\udc46=\ud835\udc3e\u00b9\ud835\udc4b\u0003,\ud835\udc4b\u0003\u00ba\u0000\ud835\udc3e\u00b9\ud835\udc4b\u0003,\ud835\udc4b\u00ba\u00bb\ud835\udc3e\u00b9\ud835\udc4b,\ud835\udc4b\u00ba\u00b8\ud835\udf0e2\ud835\udc3c\u00bc\u00001\ud835\udc3e\u00b9\ud835\udc4b,\ud835\udc4b\u0003\u00ba.\nTypically, we do not need to make use of the full predictive covariance matrix \ud835\udc46, and in-\nstead use the diagonal of \ud835\udc46for uncertainty about each prediction. Often for this reason we\nwrite the predictive distribution for a single test point \ud835\udc65\u0003, rather than a collection of test\npoints.\nThekernelmatrixhasparameters \ud835\udf03thatwealsowishtoestimate, suchtheamplitude \ud835\udc4eand\nlengthscale\u2113of the RBF kernel above. For these purposes we use the marginallikelihood ,\n\ud835\udc5d\u00b9yj\ud835\udf03,\ud835\udc4b\u00ba, which we already derived in working out the marginal distributions to find the\njointdistributionover y,f\u0003. Aswewillsee,themarginallikelihoodcompartmentalizesinto\nmodelfitandmodelcomplexityterms,andautomaticallyencodesanotionofOccam\u2019srazor\nfor learning hyperparameters. For a full discussion, see MacKay Ch. 28 ( MacKay, 2003 ),\nand Rasmussen and Williams Ch. 5 ( Rasmussen and Williams, 2006 ).", "mimetype": "text/plain", "start_char_idx": 1714959, "end_char_idx": 1717134, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0b422f79-ce42-4436-b3e0-0efbb204de9c": {"__data__": {"id_": "0b422f79-ce42-4436-b3e0-0efbb204de9c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8609a38c-b9b3-483a-b596-d0c11beb5551", "node_type": "1", "metadata": {}, "hash": "80b45c071b6e401a13b88d4c529a821d17fa26cd7e93e3182c2d3df6430c066a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "981098bb-eef9-4fbf-a02a-b45b14c6e7c6", "node_type": "1", "metadata": {}, "hash": "1a0ca8af08d7abf09c43e2880dd38c42214103ac507847576e58b1d0c58ede00", "class_name": "RelatedNodeInfo"}}, "text": "Thekernelmatrixhasparameters \ud835\udf03thatwealsowishtoestimate, suchtheamplitude \ud835\udc4eand\nlengthscale\u2113of the RBF kernel above. For these purposes we use the marginallikelihood ,\n\ud835\udc5d\u00b9yj\ud835\udf03,\ud835\udc4b\u00ba, which we already derived in working out the marginal distributions to find the\njointdistributionover y,f\u0003. Aswewillsee,themarginallikelihoodcompartmentalizesinto\nmodelfitandmodelcomplexityterms,andautomaticallyencodesanotionofOccam\u2019srazor\nfor learning hyperparameters. For a full discussion, see MacKay Ch. 28 ( MacKay, 2003 ),\nand Rasmussen and Williams Ch. 5 ( Rasmussen and Williams, 2006 ).\nimport math\nimport os\nimport gpytorch\nimport matplotlib .pyplot asplt\nimport numpy asnp\nimport torch\nfrom scipy import optimize\nfrom scipy .spatial import distance_matrix\nfrom d2l import torch asd2l\nd2l.set_figsize()\n817 Gaussian Process Inference\n18.3.2EquationsforMaking Predictionsand Learning Kernel\nHyperparametersin GP Regression\nWelistheretheequationsyouwilluseforlearninghyperparametersandmakingpredictions\nin Gaussian process regression. Again, we assume a vector of regression targets y, indexed\nbyinputs\ud835\udc4b=f\ud835\udc651,...,\ud835\udc65\ud835\udc5bg,andwewishtomakeapredictionatatestinput \ud835\udc65\u0003. Weassume\ni.i.d. additive zero-mean Gaussian noise with variance \ud835\udf0e2. We use a Gaussian process\nprior\ud835\udc53\u00b9\ud835\udc65\u00ba\u0018GP\u00b9\ud835\udc5a,\ud835\udc58\u00baforthelatentnoise-freefunction,withmeanfunction \ud835\udc5aandkernel\nfunction\ud835\udc58. The kernel itself has parameters \ud835\udf03that we want to learn. For example, if we\nuse an RBF kernel, \ud835\udc58\u00b9\ud835\udc65\ud835\udc56,\ud835\udc65\ud835\udc57\u00ba=\ud835\udc4e2exp\u0010\n\u00001\n2\u21132jj\ud835\udc65\u0000\ud835\udc650jj2\u0011\n, we want to learn \ud835\udf03=f\ud835\udc4e2,\u21132g. Let\n\ud835\udc3e\u00b9\ud835\udc4b,\ud835\udc4b\u00barepresent an \ud835\udc5b\u0002\ud835\udc5bmatrix corresponding to evaluating the kernel for all possible\npairs of\ud835\udc5btraining inputs. Let \ud835\udc3e\u00b9\ud835\udc65\u0003,\ud835\udc4b\u00barepresent a 1\u0002\ud835\udc5bvector formed by evaluating\n\ud835\udc58\u00b9\ud835\udc65\u0003,\ud835\udc65\ud835\udc56\u00ba,\ud835\udc56=1,...,\ud835\udc5b. Let\ud835\udf07be a mean vector formed by evaluating the mean function\n\ud835\udc5a\u00b9\ud835\udc65\u00baat every training points \ud835\udc65.\nTypically in working with Gaussian processes, we follow a two-step procedure. 1. Learn\nkernel hyperparameters \u02c6\ud835\udf03by maximizing the marginal likelihood with respect to these hy-\nperparameters. 2. Use the predictive mean as a point predictor, and 2 times the predictive\nstandard deviation to form a 95% credible set, conditioning on these learned hyperparam-\neters \u02c6\ud835\udf03.", "mimetype": "text/plain", "start_char_idx": 1716564, "end_char_idx": 1718691, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "981098bb-eef9-4fbf-a02a-b45b14c6e7c6": {"__data__": {"id_": "981098bb-eef9-4fbf-a02a-b45b14c6e7c6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0b422f79-ce42-4436-b3e0-0efbb204de9c", "node_type": "1", "metadata": {}, "hash": "b6bcd167fcb9403816859ffb78697092438aa55cae795a09acc264bc87fa9577", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9724efee-9716-4bc6-af76-98cda7acbeed", "node_type": "1", "metadata": {}, "hash": "36e5760e544dd1118c792579ed869c7e916d1d2996f8efd47f2f9127fdbdfc7b", "class_name": "RelatedNodeInfo"}}, "text": "Let \ud835\udc3e\u00b9\ud835\udc65\u0003,\ud835\udc4b\u00barepresent a 1\u0002\ud835\udc5bvector formed by evaluating\n\ud835\udc58\u00b9\ud835\udc65\u0003,\ud835\udc65\ud835\udc56\u00ba,\ud835\udc56=1,...,\ud835\udc5b. Let\ud835\udf07be a mean vector formed by evaluating the mean function\n\ud835\udc5a\u00b9\ud835\udc65\u00baat every training points \ud835\udc65.\nTypically in working with Gaussian processes, we follow a two-step procedure. 1. Learn\nkernel hyperparameters \u02c6\ud835\udf03by maximizing the marginal likelihood with respect to these hy-\nperparameters. 2. Use the predictive mean as a point predictor, and 2 times the predictive\nstandard deviation to form a 95% credible set, conditioning on these learned hyperparam-\neters \u02c6\ud835\udf03.\nThe log marginal likelihood is simply a log Gaussian density, which has the form:\nlog\ud835\udc5d\u00b9yj\ud835\udf03,\ud835\udc4b\u00ba=\u00001\n2y>\u00bb\ud835\udc3e\ud835\udf03\u00b9\ud835\udc4b,\ud835\udc4b\u00ba\u00b8\ud835\udf0e2\ud835\udc3c\u00bc\u00001y\u00001\n2logj\ud835\udc3e\ud835\udf03\u00b9\ud835\udc4b,\ud835\udc4b\u00baj\u00b8\ud835\udc50 (18.3.4)\nThe predictive distribution has the form:\n\ud835\udc5d\u00b9\ud835\udc66\u0003j\ud835\udc65\u0003,y,\ud835\udf03\u00ba=N\u00b9\ud835\udc4e\u0003,\ud835\udc63\u0003\u00ba (18.3.5)\n\ud835\udc4e\u0003=\ud835\udc58\ud835\udf03\u00b9\ud835\udc65\u0003,\ud835\udc4b\u00ba\u00bb\ud835\udc3e\ud835\udf03\u00b9\ud835\udc4b,\ud835\udc4b\u00ba\u00b8\ud835\udf0e2\ud835\udc3c\u00bc\u00001\u00b9y\u0000\ud835\udf07\u00ba\u00b8\ud835\udf07 (18.3.6)\n\ud835\udc63\u0003=\ud835\udc58\ud835\udf03\u00b9\ud835\udc65\u0003,\ud835\udc65\u0003\u00ba\u0000\ud835\udc3e\ud835\udf03\u00b9\ud835\udc65\u0003,\ud835\udc4b\u00ba\u00bb\ud835\udc3e\ud835\udf03\u00b9\ud835\udc4b,\ud835\udc4b\u00ba\u00b8\ud835\udf0e2\ud835\udc3c\u00bc\u00001\ud835\udc58\ud835\udf03\u00b9\ud835\udc4b,\ud835\udc65\u0003\u00ba (18.3.7)\n18.3.3InterpretingEquations forLearning and Predictions\nThere are some key points to note about the predictive distributions for Gaussian pro-\ncesses:\n\u000fDespitetheflexibilityofthemodelclass,itispossibletodo exactBayesianinferencefor\nGP regression in closed form . Aside from learning the kernel hyperparameters, there\nis notraining. We can write down exactly what equations we want to use to make\npredictions. Gaussian processes are relatively exceptional in this respect, and it has\ngreatly contributed to their convenience, versatility, and continued popularity.\n\u000fThe predictive mean \ud835\udc4e\u0003is a linear combination of the training targets y, weighted by the\nkernel\ud835\udc58\ud835\udf03\u00b9\ud835\udc65\u0003,\ud835\udc4b\u00ba\u00bb\ud835\udc3e\ud835\udf03\u00b9\ud835\udc4b,\ud835\udc4b\u00ba\u00b8\ud835\udf0e2\ud835\udc3c\u00bc\u00001. Aswewillsee,thekernel(anditshyperparam-\neters) thus plays a crucial role in the generalization properties of the model.\n818 Gaussian Processes\n\u000fThe predictivemean explicitlydepends on the targetvalues ybut the predictivevariance\ndoes not. The predictive uncertainty instead grows as the test input \ud835\udc65\u0003moves away\nfrom the target locations \ud835\udc4b, as governed by the kernel function. However, uncertainty\nwillimplicitlydependonthevaluesofthetargets ythroughthekernelhyperparameters\n\ud835\udf03, which are learned from the data.\n\u000fThe marginal likelihood compartmentalizes into model fit and model complexity (log\ndeterminant) terms. The marginal likelihood tends to select for hyperparameters that\nprovide the simplest fits that are still consistent with the data.\n\u000fThe key computational bottlenecks come from solving a linear system and computing\na log determinant over an \ud835\udc5b\u0002\ud835\udc5bsymmetric positive definite matrix \ud835\udc3e\u00b9\ud835\udc4b,\ud835\udc4b\u00bafor\ud835\udc5b\ntraining points. Naively, these operations each incur O\u00b9\ud835\udc5b3\u00bacomputations, as well as\nO\u00b9\ud835\udc5b2\u00bastorage for each entry of the kernel (covariance) matrix, often starting with a\nCholeskydecomposition. Historically,thesebottleneckshavelimitedGPstoproblems\nwith fewer than about 10,000 training points, and have given GPs a reputation for\n\u201cbeing slow\u201d that has been inaccurate now for almost a decade. In advanced topics,\nwe will discuss how GPs can be scaled to problems with millions of points.", "mimetype": "text/plain", "start_char_idx": 1718160, "end_char_idx": 1721080, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9724efee-9716-4bc6-af76-98cda7acbeed": {"__data__": {"id_": "9724efee-9716-4bc6-af76-98cda7acbeed", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "981098bb-eef9-4fbf-a02a-b45b14c6e7c6", "node_type": "1", "metadata": {}, "hash": "1a0ca8af08d7abf09c43e2880dd38c42214103ac507847576e58b1d0c58ede00", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8d8a1f93-c17f-4b3b-9b54-9a020282838f", "node_type": "1", "metadata": {}, "hash": "46cc181b6adbb1ae60e092394971c087b1d8e757b5263f9ed4b70c0a0ede1387", "class_name": "RelatedNodeInfo"}}, "text": "The marginal likelihood tends to select for hyperparameters that\nprovide the simplest fits that are still consistent with the data.\n\u000fThe key computational bottlenecks come from solving a linear system and computing\na log determinant over an \ud835\udc5b\u0002\ud835\udc5bsymmetric positive definite matrix \ud835\udc3e\u00b9\ud835\udc4b,\ud835\udc4b\u00bafor\ud835\udc5b\ntraining points. Naively, these operations each incur O\u00b9\ud835\udc5b3\u00bacomputations, as well as\nO\u00b9\ud835\udc5b2\u00bastorage for each entry of the kernel (covariance) matrix, often starting with a\nCholeskydecomposition. Historically,thesebottleneckshavelimitedGPstoproblems\nwith fewer than about 10,000 training points, and have given GPs a reputation for\n\u201cbeing slow\u201d that has been inaccurate now for almost a decade. In advanced topics,\nwe will discuss how GPs can be scaled to problems with millions of points.\n\u000fFor popular choices of kernel functions, \ud835\udc3e\u00b9\ud835\udc4b,\ud835\udc4b\u00bais often close to singular, which can\ncause numerical issues when performing Cholesky decompositions or other opera-\ntionsintendedtosolvelinearsystems. Fortunately,inregressionweareoftenworking\nwith\ud835\udc3e\ud835\udf03\u00b9\ud835\udc4b,\ud835\udc4b\u00ba\u00b8\ud835\udf0e2\ud835\udc3c, such that the noise variance \ud835\udf0e2gets added to the diagonal of\n\ud835\udc3e\u00b9\ud835\udc4b,\ud835\udc4b\u00ba, significantly improving its conditioning. If the noise variance is small, or\nwe are doing noise free regression, it is common practice to add a small amount of\n\u201cjitter\u201d to the diagonal, on the order of 10\u00006, to improve conditioning.\n18.3.4WorkedExamplefromScratch\nLet\u2019s create some regression data, and then fit the data with a GP, implementing every step\nfrom scratch. We\u2019ll sample data from\n\ud835\udc66\u00b9\ud835\udc65\u00ba=sin\u00b9\ud835\udc65\u00ba\u00b81\n2sin\u00b94\ud835\udc65\u00ba\u00b8\ud835\udf16, (18.3.8)\nwith\ud835\udf16\u0018N\u00b9 0,\ud835\udf0e2\u00ba. The noise free function we wish to find is \ud835\udc53\u00b9\ud835\udc65\u00ba=sin\u00b9\ud835\udc65\u00ba\u00b81\n2sin\u00b94\ud835\udc65\u00ba.\nWe\u2019ll start by using a noise standard deviation \ud835\udf0e=0.25.\ndef data_maker1 (x, sig):\nreturn np.sin(x) +0.5 *np.sin( 4*x)+np.random .randn(x .shape[ 0])*sig\nsig =0.25\ntrain_x, test_x =np.linspace( 0,5,50), np .linspace( 0,5,500)\ntrain_y, test_y =data_maker1(train_x, sig =sig), data_maker1(test_x, sig =0.)\nd2l.plt.scatter(train_x, train_y)\nd2l.plt.plot(test_x, test_y)\nd2l.plt.xlabel( \"x\", fontsize =20)\nd2l.plt.ylabel( \"Observations y \", fontsize =20)\nd2l.plt.show()\n819 Gaussian Process Inference\nHere we see the noisy observations as circles, and the noise-free function in blue that we\nwish to find.\nNow, let\u2019s specify a GP prior over the latent noise-free function, \ud835\udc53\u00b9\ud835\udc65\u00ba\u0018GP\u00b9\ud835\udc5a,\ud835\udc58\u00ba. We\u2019ll\nuse a mean function \ud835\udc5a\u00b9\ud835\udc65\u00ba=0, and an RBF covariance function (kernel)\n\ud835\udc58\u00b9\ud835\udc65\ud835\udc56,\ud835\udc65\ud835\udc57\u00ba=\ud835\udc4e2exp\u0012\n\u00001\n2\u21132jj\ud835\udc65\u0000\ud835\udc650jj2\u0013\n. (18.3.9)\nmean =np.zeros(test_x .shape[ 0])\ncov =d2l.rbfkernel(test_x, test_x, ls =0.2)\nWehavestartedwithalength-scaleof0.2. Beforewefitthedata,itisimportanttoconsider\nwhether we have specified a reasonable prior. Let\u2019s visualize some sample functions from\nthis prior, as well as the 95% credible set (we believe there\u2019s a 95% chance that the true\nfunction is within this region).\nprior_samples =np.random .multivariate_normal(mean =mean, cov =cov, size =5)\nd2l.plt.plot(test_x, prior_samples .T, color ='black ', alpha =0.5)\nd2l.plt.plot(test_x, mean, linewidth =2.)", "mimetype": "text/plain", "start_char_idx": 1720305, "end_char_idx": 1723277, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8d8a1f93-c17f-4b3b-9b54-9a020282838f": {"__data__": {"id_": "8d8a1f93-c17f-4b3b-9b54-9a020282838f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9724efee-9716-4bc6-af76-98cda7acbeed", "node_type": "1", "metadata": {}, "hash": "36e5760e544dd1118c792579ed869c7e916d1d2996f8efd47f2f9127fdbdfc7b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bb850212-4186-4087-9aaf-7f2c79b9f1f3", "node_type": "1", "metadata": {}, "hash": "7e4d6b60b64e08c20e41599b83bc6d05ec8f15eb5d41dfde6f2451ab26b19e57", "class_name": "RelatedNodeInfo"}}, "text": "(18.3.9)\nmean =np.zeros(test_x .shape[ 0])\ncov =d2l.rbfkernel(test_x, test_x, ls =0.2)\nWehavestartedwithalength-scaleof0.2. Beforewefitthedata,itisimportanttoconsider\nwhether we have specified a reasonable prior. Let\u2019s visualize some sample functions from\nthis prior, as well as the 95% credible set (we believe there\u2019s a 95% chance that the true\nfunction is within this region).\nprior_samples =np.random .multivariate_normal(mean =mean, cov =cov, size =5)\nd2l.plt.plot(test_x, prior_samples .T, color ='black ', alpha =0.5)\nd2l.plt.plot(test_x, mean, linewidth =2.)\nd2l.plt.fill_between(test_x, mean -2*np.diag(cov), mean +2*np.diag(cov),\nalpha =0.25 )\nd2l.plt.show()\nDo these samples look reasonable? Are the high-level properties of the functions aligned\nwith the type of data we are trying to model?\nNowlet\u2019sformthemeanandvarianceoftheposteriorpredictivedistributionatanyarbitrary\n820 Gaussian Processes\ntest point\ud835\udc65\u0003.\n\u00af\ud835\udc53\u0003=\ud835\udc3e\u00b9\ud835\udc65,\ud835\udc65\u0003\u00ba\ud835\udc47\u00b9\ud835\udc3e\u00b9\ud835\udc65,\ud835\udc65\u00ba\u00b8\ud835\udf0e2\ud835\udc3c\u00ba\u00001\ud835\udc66 (18.3.10)\n\ud835\udc49\u00b9\ud835\udc53\u0003\u00ba=\ud835\udc3e\u00b9\ud835\udc65\u0003,\ud835\udc65\u0003\u00ba\u0000\ud835\udc3e\u00b9\ud835\udc65,\ud835\udc65\u0003\u00ba\ud835\udc47\u00b9\ud835\udc3e\u00b9\ud835\udc65,\ud835\udc65\u00ba\u00b8\ud835\udf0e2\ud835\udc3c\u00ba\u00001\ud835\udc3e\u00b9\ud835\udc65,\ud835\udc65\u0003\u00ba (18.3.11)\nBefore we make predictions, we should learn our kernel hyperparameters \ud835\udf03and noise vari-\nance\ud835\udf0e2. Let\u2019s initialize our length-scale at 0.75, as our prior functions looked too quickly\nvarying compared to the data we are fitting. We\u2019ll also guess a noise standard deviation \ud835\udf0e\nof 0.75.\nIn order to learn these parameters, we will maximize the marginal likelihood with respect\nto these parameters.\nlog\ud835\udc5d\u00b9\ud835\udc66j\ud835\udc4b\u00ba=log\u00b9\n\ud835\udc5d\u00b9\ud835\udc66j\ud835\udc53,\ud835\udc4b\u00ba\ud835\udc5d\u00b9\ud835\udc53j\ud835\udc4b\u00ba\ud835\udc51\ud835\udc53 (18.3.12)\nlog\ud835\udc5d\u00b9\ud835\udc66j\ud835\udc4b\u00ba=\u00001\n2\ud835\udc66\ud835\udc47\u00b9\ud835\udc3e\u00b9\ud835\udc65,\ud835\udc65\u00ba\u00b8\ud835\udf0e2\ud835\udc3c\u00ba\u00001\ud835\udc66\u00001\n2logj\ud835\udc3e\u00b9\ud835\udc65,\ud835\udc65\u00ba\u00b8\ud835\udf0e2\ud835\udc3cj\u0000\ud835\udc5b\n2log 2\ud835\udf0b(18.3.13)\nPerhaps our prior functions were too quickly varying. Let\u2019s guess a length-scale of 0.4.\nWe\u2019ll also guess a noise standard deviation of 0.75. These are simply hyperparameter ini-\ntializations \u2014 we will learn these parameters from the marginal likelihood.\nell_est =0.4\npost_sig_est =0.5\ndef neg_MLL (pars):\nK=d2l.rbfkernel(train_x, train_x, ls =pars[ 0])\nkernel_term =-0.5 *train_y @\\\nnp.linalg .inv(K +pars[ 1]**2*np.eye(train_x .shape[ 0])) @train_y\nlogdet =-0.5 *np.log(np .linalg .det(K +pars[ 1]**2*\\\nnp.eye(train_x .shape[ 0])))\nconst =-train_x .shape[ 0]/2.*np.log( 2*np.pi)\nreturn -(kernel_term +logdet +const)\nlearned_hypers =optimize .minimize(neg_MLL, x0 =np.array([ell_est,post_sig_\n\u21a9!est]),\nbounds =((0.01 ,10.), ( 0.01 ,10.)))\nell =learned_hypers .x[0]\npost_sig_est =learned_hypers .x[1]\nIn this instance, we learn a length-scale of 0.299, and a noise standard deviation of 0.24.\nNote that the learned noise is extremely close to the true noise, which helps indicate that\nour GP is a very well-specified to this problem.", "mimetype": "text/plain", "start_char_idx": 1722711, "end_char_idx": 1725263, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bb850212-4186-4087-9aaf-7f2c79b9f1f3": {"__data__": {"id_": "bb850212-4186-4087-9aaf-7f2c79b9f1f3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8d8a1f93-c17f-4b3b-9b54-9a020282838f", "node_type": "1", "metadata": {}, "hash": "46cc181b6adbb1ae60e092394971c087b1d8e757b5263f9ed4b70c0a0ede1387", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a7c4082a-a126-44e6-bd05-abf0284e4f63", "node_type": "1", "metadata": {}, "hash": "46dd498632fe7eeeaa04e1dde98b6bc08a0330bba4450d8a78f41ebdc0a188f7", "class_name": "RelatedNodeInfo"}}, "text": "*np.log( 2*np.pi)\nreturn -(kernel_term +logdet +const)\nlearned_hypers =optimize .minimize(neg_MLL, x0 =np.array([ell_est,post_sig_\n\u21a9!est]),\nbounds =((0.01 ,10.), ( 0.01 ,10.)))\nell =learned_hypers .x[0]\npost_sig_est =learned_hypers .x[1]\nIn this instance, we learn a length-scale of 0.299, and a noise standard deviation of 0.24.\nNote that the learned noise is extremely close to the true noise, which helps indicate that\nour GP is a very well-specified to this problem.\nIn general, it is crucial to put careful thought into selecting the kernel and initializing the\nhyperparameters. While marginal likelihood optimization can be relatively robust to ini-\ntialization, it is not immune to poor initializations. Try running the above script with a\nvariety of initializations and see what results you find.\nNow, let\u2019s make predictions with these learned hypers.\n821 Gaussian Process Inference\nK_x_xstar =d2l.rbfkernel(train_x, test_x, ls =ell)\nK_x_x =d2l.rbfkernel(train_x, train_x, ls =ell)\nK_xstar_xstar =d2l.rbfkernel(test_x, test_x, ls =ell)\npost_mean =K_x_xstar .T@np.linalg .inv((K_x_x +\\\npost_sig_est **2*np.eye(train_x .shape[ 0]))) @train_y\npost_cov =K_xstar_xstar -K_x_xstar .T@np.linalg .inv((K_x_x +\\\npost_sig_est **2*np.eye(train_x .shape[ 0]))) @K_x_xstar\nlw_bd =post_mean -2*np.sqrt(np .diag(post_cov))\nup_bd =post_mean +2*np.sqrt(np .diag(post_cov))\nd2l.plt.scatter(train_x, train_y)\nd2l.plt.plot(test_x, test_y, linewidth =2.)\nd2l.plt.plot(test_x, post_mean, linewidth =2.)\nd2l.plt.fill_between(test_x, lw_bd, up_bd, alpha =0.25 )\nd2l.plt.legend([ 'Observed Data ','True Function ','Predictive Mean ','95%Set\u2423\n\u21a9!on True Func '])\nd2l.plt.show()\nWe see the posterior mean in orange almost perfectly matches the true noise free function!\nNote that the 95% credible set we are showing is for the latent noise free (true) function,\nandnotthedatapoints. Weseethatthiscrediblesetentirelycontainsthetruefunction,and\ndoes not seem overly wide or narrow. We would not want nor expect it to contain the data\npoints. If we wish to have a credible set for the observations, we should compute\nlw_bd_observed =post_mean -2*np.sqrt(np .diag(post_cov) +post_sig_est **2)\nup_bd_observed =post_mean +2*np.sqrt(np .diag(post_cov) +post_sig_est **2)\nThere are two sources of uncertainty, epistemic uncertainty, representing reducible uncer-\ntainty, and aleatoric orirreducible uncertainty. The epistemic uncertainty here represents\nuncertainty about the true values of the noise free function. This uncertainty should grow\nas we move away from the data points, as away from the data there are a greater variety of\nfunction values consistent with our data. As we observe more and more data, our beliefs\nabout the true function become more confident, and the epistemic uncertainty disappears.\nThealeatoric uncertainty in this instance is the observation noise, since the data are given\nto us with this noise, and it cannot be reduced.\nTheepistemic uncertaintyinthedataiscapturedbyvarianceofthelatentnoisefreefunction\nnp.diag(post_cov). The aleatoric uncertaintyiscapturedbythenoisevariancepost_sig_est**2.\n822 Gaussian Processes\nUnfortunately, people are often careless about how they represent uncertainty, with many\npapers showing error bars that are completely undefined, no clear sense of whether we are\nvisualizing epistemic or aleatoric uncertainty or both, and confusing noise variances with\nnoise standard deviations, standard deviations with standard errors, confidence intervals\nwith credible sets, and so on. Without being precise about what the uncertainty represents,\nit is essentially meaningless.\nIn the spirit of playing close attention to what our uncertainty represents, it is crucial to\nnote that we are taking twotimes thesquareroot of our variance estimate for the noise free\nfunction.", "mimetype": "text/plain", "start_char_idx": 1724793, "end_char_idx": 1728591, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a7c4082a-a126-44e6-bd05-abf0284e4f63": {"__data__": {"id_": "a7c4082a-a126-44e6-bd05-abf0284e4f63", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bb850212-4186-4087-9aaf-7f2c79b9f1f3", "node_type": "1", "metadata": {}, "hash": "7e4d6b60b64e08c20e41599b83bc6d05ec8f15eb5d41dfde6f2451ab26b19e57", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0e2bee3e-830a-4f39-a9c9-0e43a3ea562e", "node_type": "1", "metadata": {}, "hash": "e70dc6e9a78b6b9ce81a3116dbeba320a203d57d93f662063a3b84daff23f7ca", "class_name": "RelatedNodeInfo"}}, "text": "Theepistemic uncertaintyinthedataiscapturedbyvarianceofthelatentnoisefreefunction\nnp.diag(post_cov). The aleatoric uncertaintyiscapturedbythenoisevariancepost_sig_est**2.\n822 Gaussian Processes\nUnfortunately, people are often careless about how they represent uncertainty, with many\npapers showing error bars that are completely undefined, no clear sense of whether we are\nvisualizing epistemic or aleatoric uncertainty or both, and confusing noise variances with\nnoise standard deviations, standard deviations with standard errors, confidence intervals\nwith credible sets, and so on. Without being precise about what the uncertainty represents,\nit is essentially meaningless.\nIn the spirit of playing close attention to what our uncertainty represents, it is crucial to\nnote that we are taking twotimes thesquareroot of our variance estimate for the noise free\nfunction. Since our predictive distribution is Gaussian, this quantity enables us to form a\n95% credible set, representing our beliefs about the interval which is 95% likely to contain\nthe ground truth function. The noise variance is living on a completely different scale, and\nis much less interpretable.\nFinally, let\u2019s take a look at 20 posterior samples. These samples tell us what types of\nfunctions we believe might fit our data, a posteriori.\npost_samples =np.random .multivariate_normal(post_mean, post_cov, size =20)\nd2l.plt.scatter(train_x, train_y)\nd2l.plt.plot(test_x, test_y, linewidth =2.)\nd2l.plt.plot(test_x, post_mean, linewidth =2.)\nd2l.plt.plot(test_x, post_samples .T, color ='gray ', alpha =0.25 )\nd2l.plt.fill_between(test_x, lw_bd, up_bd, alpha =0.25 )\nplt.legend([ 'Observed Data ','True Function ','Predictive Mean ','Posterior \u2423\n\u21a9!Samples '])\nd2l.plt.show()\nIn basic regression applications, it is most common to use the posterior predictive mean\nand standard deviation as a point predictor and metric for uncertainty, respectively. In\nmore advanced applications, such as Bayesian optimization with Monte Carlo acquisition\nfunctions, or Gaussian processes for model-based RL, it often necessary to take posterior\nsamples. However, even if not strictly required in the basic applications, these samples\ngive us more intuition about the fit we have for the data, and are often useful to include in\nvisualizations.\n18.3.5Making LifeEasy with GPyTorch\nAs we have seen, it is actually pretty easy to implement basic Gaussian process regres-\nsion entirely from scratch. However, as soon as we want to explore a variety of kernel\n823 Gaussian Process Inference\n262\n263choices, considerapproximateinference(whichisneededevenforclassification), combine\nGPs with neural networks, or even have a dataset larger than about 10,000 points, then an\nimplementationfromscratchbecomesunwieldyandcumbersome. Someofthemosteffec-\ntive methods for scalable GP inference, such as SKI (also known as KISS-GP), can require\nhundredsoflinesofcodeimplementingadvancednumericallinearalgebraroutines.\nIn these cases, the GPyTorch library will make our lives a lot easier. We\u2019ll be discussing\nGPyTorchmoreinfuturenotebooksonGaussianprocessnumerics,andadvancedmethods.\nThe GPyTorch library contains many examples262. To get a feel for the package, we will\nwalkthroughthe simpleregressionexample263,showinghowitcanbeadaptedtoreproduce\nouraboveresultsusingGPyTorch. Thismayseemlikealotofcodetosimplyreproducethe\nbasicregressionabove,andinasense,itis. Butwecanimmediatelyuseavarietyofkernels,\nscalable inference techniques, and approximate inference, by only changing a few lines of\ncode from below, instead of writing potentially thousands of lines of new code.", "mimetype": "text/plain", "start_char_idx": 1727720, "end_char_idx": 1731334, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0e2bee3e-830a-4f39-a9c9-0e43a3ea562e": {"__data__": {"id_": "0e2bee3e-830a-4f39-a9c9-0e43a3ea562e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a7c4082a-a126-44e6-bd05-abf0284e4f63", "node_type": "1", "metadata": {}, "hash": "46dd498632fe7eeeaa04e1dde98b6bc08a0330bba4450d8a78f41ebdc0a188f7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c503baab-8e2d-433b-980c-37079534d9fe", "node_type": "1", "metadata": {}, "hash": "69225d1c9ac11aab44ff66bf6ee7bb9d8b4c5495e5b1d05f332f60375c0a0c62", "class_name": "RelatedNodeInfo"}}, "text": "In these cases, the GPyTorch library will make our lives a lot easier. We\u2019ll be discussing\nGPyTorchmoreinfuturenotebooksonGaussianprocessnumerics,andadvancedmethods.\nThe GPyTorch library contains many examples262. To get a feel for the package, we will\nwalkthroughthe simpleregressionexample263,showinghowitcanbeadaptedtoreproduce\nouraboveresultsusingGPyTorch. Thismayseemlikealotofcodetosimplyreproducethe\nbasicregressionabove,andinasense,itis. Butwecanimmediatelyuseavarietyofkernels,\nscalable inference techniques, and approximate inference, by only changing a few lines of\ncode from below, instead of writing potentially thousands of lines of new code.\n# First let's convert our data into tensors for use with PyTorch\ntrain_x =torch .tensor(train_x)\ntrain_y =torch .tensor(train_y)\ntest_y =torch .tensor(test_y)\n# We are using exact GP inference with a zero mean and RBF kernel\nclass ExactGPModel (gpytorch .models .ExactGP):\ndef __init__ (self , train_x, train_y, likelihood):\nsuper (ExactGPModel, self ).__init__ (train_x, train_y, likelihood)\nself .mean_module =gpytorch .means .ZeroMean()\nself .covar_module =gpytorch .kernels .ScaleKernel(\ngpytorch .kernels .RBFKernel())\ndef forward (self , x):\nmean_x =self .mean_module(x)\ncovar_x =self .covar_module(x)\nreturn gpytorch .distributions .MultivariateNormal(mean_x, covar_x)\nThis code block puts the data in the right format for GPyTorch, and specifies that we are\nusing exact inference, as well the mean function (zero) and kernel function (RBF) that\nwe want to use. We can use any other kernel very easily, by calling, for instance, gpy-\ntorch.kernels.matern_kernel(), or gpyotrch.kernels.spectral_mixture_kernel(). So far, we\nhave only discussed exact inference, where it is possible to infer a predictive distribution\nwithout making any approximations. For Gaussian processes, we can only perform exact\ninferencewhenwehaveaGaussianlikelihood; morespecifically, whenweassumethatour\nobservationsaregeneratedasanoise-freefunctionrepresentedbyaGaussianprocess,plus\nGaussiannoise. Infuturenotebooks, wewillconsiderothersettings, suchasclassification,\nwhere we cannot make these assumptions.\n# Initialize Gaussian likelihood\nlikelihood =gpytorch .likelihoods .GaussianLikelihood()\nmodel =ExactGPModel(train_x, train_y, likelihood)\ntraining_iter =50\n# Find optimal model hyperparameters\n(continues on next page)\n824 Gaussian Processes\n(continued from previous page)\nmodel .train()\nlikelihood .train()\n# Use the adam optimizer, includes GaussianLikelihood parameters\noptimizer =torch .optim .Adam(model .parameters(), lr =0.1)\n# Set our loss as the negative log GP marginal likelihood\nmll =gpytorch .mlls .ExactMarginalLogLikelihood(likelihood, model)\nHere, we explicitly specify the likelihood we want to use (Gaussian), the objective we will\nuse for training kernel hyperparameters (here, the marginal likelihood), and the procedure\nwe we want to use for optimizing that objective (in this case, Adam). We note that while\nwe are using Adam, which is a \u201cstochastic\u201d optimizer, in this case, it is full-batch Adam.\nBecause the marginal likelihood does not factorize over data instances, we cannot use an\noptimizer over \u201cmini-batches\u201d of data and be guaranteed convergence. Other optimizers,\nsuchasL-BFGS,arealsosupportedbyGPyTorch. Unlikeinstandarddeeplearning, doing\na good job of optimizing the marginal likelihood corresponds strongly with good general-\nization, which often inclines us towards powerful optimizers like L-BFGS, assuming they\nare not prohibitively expensive.", "mimetype": "text/plain", "start_char_idx": 1730678, "end_char_idx": 1734209, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c503baab-8e2d-433b-980c-37079534d9fe": {"__data__": {"id_": "c503baab-8e2d-433b-980c-37079534d9fe", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0e2bee3e-830a-4f39-a9c9-0e43a3ea562e", "node_type": "1", "metadata": {}, "hash": "e70dc6e9a78b6b9ce81a3116dbeba320a203d57d93f662063a3b84daff23f7ca", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2944fa4d-855d-4953-9eef-5c38053be67e", "node_type": "1", "metadata": {}, "hash": "2568b2ad88f077d6930351112ecf16d61626b313ff86c0ca8b02860f246c3c29", "class_name": "RelatedNodeInfo"}}, "text": "We note that while\nwe are using Adam, which is a \u201cstochastic\u201d optimizer, in this case, it is full-batch Adam.\nBecause the marginal likelihood does not factorize over data instances, we cannot use an\noptimizer over \u201cmini-batches\u201d of data and be guaranteed convergence. Other optimizers,\nsuchasL-BFGS,arealsosupportedbyGPyTorch. Unlikeinstandarddeeplearning, doing\na good job of optimizing the marginal likelihood corresponds strongly with good general-\nization, which often inclines us towards powerful optimizers like L-BFGS, assuming they\nare not prohibitively expensive.\nfor iinrange (training_iter):\n# Zero gradients from previous iteration\noptimizer .zero_grad()\n# Output from model\noutput =model(train_x)\n# Calc loss and backprop gradients\nloss =-mll(output, train_y)\nloss .backward()\nifi%10==0:\nprint (f'Iter {i+1:d}/{training_iter :d}- Loss: {loss .item() :.3f}'\nf'squared lengthscale: '\nf'{model .covar_module .base_kernel .lengthscale .item() :.3f}'\nf'noise variance: {model .likelihood .noise .item() :.3f}')\noptimizer .step()\nIter 1/50-Loss: 1.000 squared lengthscale: 0.693 noise variance: 0.693\nIter 11/50-Loss: 0.711 squared lengthscale: 0.490 noise variance: 0.312\nIter 21/50-Loss: 0.451 squared lengthscale: 0.506 noise variance: 0.127\nIter 31/50-Loss: 0.330 squared lengthscale: 0.485 noise variance: 0.055\nIter 41/50-Loss: 0.344 squared lengthscale: 0.472 noise variance: 0.038\nHere we actually run the optimization procedure, outputting the values of the loss every 10\niterations.\n# Get into evaluation (predictive posterior) mode\ntest_x =torch .tensor(test_x)\nmodel .eval()\nlikelihood .eval()\nobserved_pred =likelihood(model(test_x))\nThe above codeblock enables us to make predictions on our test inputs.\n825 Gaussian Process Inference\nwith torch .no_grad():\n# Initialize plot\nf, ax =d2l.plt.subplots( 1,1, figsize =(4,3))\n# Get upper and lower bounds for 95\\% credible set (in this case, in\n# observation space)\nlower, upper =observed_pred .confidence_region()\nax.scatter(train_x .numpy(), train_y .numpy())\nax.plot(test_x .numpy(), test_y .numpy(), linewidth =2.)\nax.plot(test_x .numpy(), observed_pred .mean .numpy(), linewidth =2.)\nax.fill_between(test_x .numpy(), lower .numpy(), upper .numpy(), alpha =0.25 )\nax.set_ylim([ -1.5,1.5])\nax.legend([ 'True Function ','Predictive Mean ','Observed Data ',\n'95%Credible Set '])\nFinally, we plot the fit.\nWe see the fits are virtually identical. A few things to note: GPyTorch is working with\nsquared length-scales and observation noise. For example, our learned noise standard de-\nviation in the for scratch code is about 0.283. The noise variance found by GPyTorch is\n0.81\u00190.2832. In the GPyTorch plot, we also show the credible set in the observation\nspacerather than the latent function space, to demonstrate that they indeed cover the ob-\nserved datapoints.\n18.3.6Summary\nWe can combine a Gaussian process prior with data to form a posterior, which we use to\nmake predictions. We can also form a marginal likelihood, which is useful for automatic\nlearningofkernelhyperparameters,whichcontrolpropertiessuchastherateofvariationof\ntheGaussianprocess. Themechanicsofformingtheposteriorandlearningkernelhyperpa-\nrameters for regression are simple, involving about a dozen lines of code. This notebook is\nagoodreferenceforanyreaderwantingtoquicklyget\u201cupandrunning\u201dwithGaussianpro-\ncesses. We also introduced the GPyTorch library. Although the GPyTorch code for basic\nregression is relatively long, it can be trivially modified for other kernel functions, or more\nadvanced functionality we will discuss in future notebooks, such as scalable inference, or\nnon-Gaussian likelihoods for classification.\n18.3.7Exercises\n826 Gaussian Processes\n1.We have emphasized the importance of learning kernel hyperparameters, and the effect\nof hyperparameters and kernels on the generalization properties of Gaussian processes.", "mimetype": "text/plain", "start_char_idx": 1733637, "end_char_idx": 1737515, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2944fa4d-855d-4953-9eef-5c38053be67e": {"__data__": {"id_": "2944fa4d-855d-4953-9eef-5c38053be67e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c503baab-8e2d-433b-980c-37079534d9fe", "node_type": "1", "metadata": {}, "hash": "69225d1c9ac11aab44ff66bf6ee7bb9d8b4c5495e5b1d05f332f60375c0a0c62", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0d801766-8ee2-4561-ba6a-241ece43bc84", "node_type": "1", "metadata": {}, "hash": "77334db99b161d8b5ac4a1d3fe77e2f146b386531bc932d41fe0690146096159", "class_name": "RelatedNodeInfo"}}, "text": "Themechanicsofformingtheposteriorandlearningkernelhyperpa-\nrameters for regression are simple, involving about a dozen lines of code. This notebook is\nagoodreferenceforanyreaderwantingtoquicklyget\u201cupandrunning\u201dwithGaussianpro-\ncesses. We also introduced the GPyTorch library. Although the GPyTorch code for basic\nregression is relatively long, it can be trivially modified for other kernel functions, or more\nadvanced functionality we will discuss in future notebooks, such as scalable inference, or\nnon-Gaussian likelihoods for classification.\n18.3.7Exercises\n826 Gaussian Processes\n1.We have emphasized the importance of learning kernel hyperparameters, and the effect\nof hyperparameters and kernels on the generalization properties of Gaussian processes.\nTryskippingthestepwherewelearnhypers,andinsteadguessavarietyoflength-scales\nand noise variances, and check their effect on predictions. What happens when you use\na large length-scale? A small length-scale? A large noise variance? A small noise\nvariance?\n2.We have said that the marginal likelihood is not a convex objective, but that hyperpa-\nrameterslikelength-scaleandnoisevariancecanbereliablyestimatedinGPregression.\nThisisgenerallytrue\u2014infact,themarginallikelihoodis muchbetteratlearninglength-\nscale hyperparameters than conventional approaches in spatial statistics, which involve\nfittingempiricalautocorrelationfunctions(\u201ccovariograms\u201d). Arguably,thebiggestcon-\ntributionfrommachinelearningtoGaussianprocessresearch,atleastbeforerecentwork\nonscalableinference,wastheintroductionofthemarginallkelihoodforhyperparameter\nlearning.\nHowever , different pairings of even these parameters provide interpretably different plau-\nsible explanations for many datasets, leading to local optima in our objective. If we use a\nlarge length-scale, then we assume the true underlying function is slowly varying. If the\nobserved data arevarying significantly, then the only we can plausibly have a large length-\nscaleiswithalargenoise-variance. Ifweuseasmalllength-scale,ontheotherhand,ourfit\nwill be very sensitive to the variations in the data, leaving little room to explain variations\nwith noise (aleatoric uncertainty).\nTry seeing if you can find these local optima: initialize with very large length-scale with\nlarge noise, and small length-scales with small noise. Do you converge to different solu-\ntions?\n3.We have said that a fundamental advantage of Bayesian methods is in naturally repre-\nsentingepistemic uncertainty. In the above example, we cannot fully see the effects of\nepistemic uncertainty. Try instead to predict with test_x = np.linspace(0, 10,\n1000). What happens to the 95% credible set as your predictions move beyond the\ndata? Does it cover the true function in that interval? What happens if you only visual-\nize aleatoric uncertainty in that region?\n4.Try running the above example, but instead with 10,000, 20,000 and 40,000 training\npoints,andmeasuretheruntimes. Howdoesthetrainingtimescale? Alternatively,how\ndo the runtimes scale with the number of test points? Is it different for the predictive\nmean and the predictive variance? Answer this question both by theoretically working\nout the training and testing time complexities, and by running the code above with a\ndifferent number of points.\n5.Try running the GPyTorch example with different covariance functions, such as the\nMatern kernel. How do the results change? How about the spectral mixture kernel,\nfound in the GPyTorch library? Are some easier to train the marginal likelihood than\nothers? Are some more valuable for long-range versus short-range predictions?\n6.In our GPyTorch example, we plotted the predictive distribution including observation\n827 Gaussian Process Inference\n264noise, while in our \u201cfrom scratch\u201d example, we only included epistemic uncertainty.\nRe-do the GPyTorch example, but this time only plotting epistemic uncertainty, and\ncomparetothefrom-scratchresults. Dothepredictivedistributionsnowlookthesame?\n(They should.)\nDiscussions264.\n19 Hyperparameter Optimization\nAaron Klein (Amazon),Matthias Seeger (Amazon), andCedric Archambeau (Ama-\nzon)\nThe performance of every machine learning model depends on its hyperparameters. They\ncontrolthelearningalgorithmorthestructureoftheunderlyingstatisticalmodel. However,\nthere is no general way to choose hyperparameters in practice.", "mimetype": "text/plain", "start_char_idx": 1736758, "end_char_idx": 1741098, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0d801766-8ee2-4561-ba6a-241ece43bc84": {"__data__": {"id_": "0d801766-8ee2-4561-ba6a-241ece43bc84", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2944fa4d-855d-4953-9eef-5c38053be67e", "node_type": "1", "metadata": {}, "hash": "2568b2ad88f077d6930351112ecf16d61626b313ff86c0ca8b02860f246c3c29", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e11ba821-b3bf-4744-a088-c7a79d6032e2", "node_type": "1", "metadata": {}, "hash": "966d433a53ff5bcad03057b925d6bd77931bc5ec4763e1ce1420e9a83b42743e", "class_name": "RelatedNodeInfo"}}, "text": "Are some easier to train the marginal likelihood than\nothers? Are some more valuable for long-range versus short-range predictions?\n6.In our GPyTorch example, we plotted the predictive distribution including observation\n827 Gaussian Process Inference\n264noise, while in our \u201cfrom scratch\u201d example, we only included epistemic uncertainty.\nRe-do the GPyTorch example, but this time only plotting epistemic uncertainty, and\ncomparetothefrom-scratchresults. Dothepredictivedistributionsnowlookthesame?\n(They should.)\nDiscussions264.\n19 Hyperparameter Optimization\nAaron Klein (Amazon),Matthias Seeger (Amazon), andCedric Archambeau (Ama-\nzon)\nThe performance of every machine learning model depends on its hyperparameters. They\ncontrolthelearningalgorithmorthestructureoftheunderlyingstatisticalmodel. However,\nthere is no general way to choose hyperparameters in practice. Instead, hyperparameters\nare often set in a trial-and-error manner or sometimes left to their default values by practi-\ntioners, leading to suboptimal generalization.\nHyperparameter optimization provides a systematic approach to this problem, by casting\nit as an optimization problem: a good set of hyperparameters should (at least) minimize a\nvalidation error. Compared to most other optimization problems arising in machine learn-\ning,hyperparameteroptimizationisanestedone,whereeachiterationrequirestrainingand\nvalidating a machine learning model.\nIn this chapter, we will first introduce the basics of hyperparameter optimization. We will\nalsopresentsomerecentadvancementsthatimprovetheoverallefficiencyofhyperparame-\nter optimization by exploiting cheap-to-evaluate proxies of the original objective function.\nAt the end of this chapter, you should be able to apply state-of-the-art hyperparameter\noptimization techniques to optimize the hyperparameter of your own machine learning al-\ngorithm.\n19.1What Is HyperparameterOptimization?\nAs we have seen in the previous chapters, deep neural networks come with a large number\nofparametersorweightsthatarelearnedduringtraining. Ontopofthese,everyneuralnet-\nwork has additional hyperparameters that need to be configured by the user. For example,\nto ensure that stochastic gradient descent converges to a local optimum of the training loss\n(seeChapter 12 ), we have to adjust the learning rate and batch size. To avoid overfitting on\ntrainingdatasets,wemighthavetosetregularizationparameters,suchasweightdecay(see\nSection 3.7 ) or dropout (see Section 5.6 ). We can define the capacity and inductive bias of\nthe model by setting the number of layers and number of units or filters per layer (i.e., the\neffective number of weights).\n828\n829 What Is Hyperparameter Optimization?\nUnfortunately, we cannot simply adjust these hyperparameters by minimizing the training\nloss, because this would lead to overfitting on the training data. For example, setting reg-\nularization parameters, such as dropout or weight decay to zero leads to a small training\nloss, but might hurt the generalization performance.\nSet Hyperparameters\nTrain\nEvaluate DeployLoop until validation\nperformance is maximised\ntFig. 19.1.1 Typical work\ufb02ow in machine learning that consists of training the model multiple times\nwith different hyperparameters.\nWithouta different form of automation, hyperparameters haveto be setmanuallyin a trial-\nand-errorfashion,inwhatamountstoatime-consuminganddifficultpartofmachinelearn-\ning workflows. For example, consider training a ResNet (see Section 8.6 ) on CIFAR-10,\nwhich requires more than 2 hours on an Amazon Elastic Cloud Compute (EC2) g4dn.\nxlarge instance. Even just trying ten hyperparameter configurations in sequence, this\nwould already take us roughly one day. To make matters worse, hyperparameters are usu-\nallynotdirectlytransferableacrossarchitecturesanddatasets( Bardenet etal.,2013,Feurer\net al., 2022,Wistubaet al., 2018), and need to be re-optimized for every new task. Also,\nfor most hyperparameters, there are no rule-of-thumbs, and expert knowledge is required\nto find sensible values.\nHyperparameter optimization (HPO) algorithms are designed to tackle this problem in a\nprincipled and automated fashion ( Feurer and Hutter, 2018 ), by framing it as a global op-\ntimization problem. The default objective is the error on a hold-out validation dataset, but\ncould in principle be any other business metric. It can be combined with or constrained by\nsecondary objectives, such as training time, inference time, or model complexity.", "mimetype": "text/plain", "start_char_idx": 1740229, "end_char_idx": 1744708, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e11ba821-b3bf-4744-a088-c7a79d6032e2": {"__data__": {"id_": "e11ba821-b3bf-4744-a088-c7a79d6032e2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0d801766-8ee2-4561-ba6a-241ece43bc84", "node_type": "1", "metadata": {}, "hash": "77334db99b161d8b5ac4a1d3fe77e2f146b386531bc932d41fe0690146096159", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "aa904af0-41f2-4d28-9e10-1a0a286a90e5", "node_type": "1", "metadata": {}, "hash": "ff3746354ee44684e7da909935c72a472b90b73f52d7b152225ff42c6cbdc725", "class_name": "RelatedNodeInfo"}}, "text": "To make matters worse, hyperparameters are usu-\nallynotdirectlytransferableacrossarchitecturesanddatasets( Bardenet etal.,2013,Feurer\net al., 2022,Wistubaet al., 2018), and need to be re-optimized for every new task. Also,\nfor most hyperparameters, there are no rule-of-thumbs, and expert knowledge is required\nto find sensible values.\nHyperparameter optimization (HPO) algorithms are designed to tackle this problem in a\nprincipled and automated fashion ( Feurer and Hutter, 2018 ), by framing it as a global op-\ntimization problem. The default objective is the error on a hold-out validation dataset, but\ncould in principle be any other business metric. It can be combined with or constrained by\nsecondary objectives, such as training time, inference time, or model complexity.\nRecently, hyperparameter optimization has been extended to neural architecture search\n(NAS)(Elskenet al., 2018,Wistubaet al., 2019), where the goal is to find entirely new\nneural network architectures. Compared to classical HPO, NAS is even more expensive in\nterms of computation and requires additional efforts to remain feasible in practice. Both,\nHPOandNAScanbeconsideredassub-fieldsofAutoML( Hutteretal.,2019),whichaims\nto automate the entire ML pipeline.\nIn this section we will introduce HPO and show how we can automatically find the best\nhyperparameters of the logistic regression example introduced in Section 4.5 .\n19.1.1TheOptimizationProblem\nWe will start with a simple toy problem: searching for the learning rate of the multi-class\nlogisticregressionmodel SoftmaxRegression fromSection4.5 tominimizethevalidation\n830 Hyperparameter Optimization\nerror on the Fashion MNIST dataset. While other hyperparameters like batch size or num-\nber of epochs are also worth tuning, we focus on learning rate alone for simplicity.\nimport numpy asnp\nimport torch\nfrom scipy import stats\nfrom torch import nn\nfrom d2l import torch asd2l\nBefore we can run HPO, we first need to define two ingredients: the objective function and\nthe configuration space.\nTheObjectiveFunction\nThe performance of a learning algorithm can be seen as a function \ud835\udc53:X! Rthat maps\nfrom the hyperparameter space x2Xto the validation loss. For every evaluation of \ud835\udc53\u00b9x\u00ba,\nwe have to train and validate our machine learning model, which can be time and compute\nintensive in the case of deep neural networks trained on large datasets. Given our criterion\n\ud835\udc53\u00b9x\u00baour goal is to find x\u26052argminx2X\ud835\udc53\u00b9x\u00ba.\nThereisnosimplewaytocomputegradientsof \ud835\udc53withrespectto x,becauseitwouldrequire\nto propagate the gradient through the entire training process. While there is recent work\n(Franceschi etal.,2017,Maclaurin etal.,2015)todriveHPObyapproximate\u201chypergradi-\nents\u201d, none of the existing approaches are competitive with the state-of-the-art yet, and we\nwillnotdiscussthemhere. Furthermore,thecomputationalburdenofevaluating \ud835\udc53requires\nHPO algorithms to approach the global optimum with as few samples as possible.\nThe training of neural networks is stochastic (e.g., weights are randomly initialized, mini-\nbatchesarerandomlysampled),sothatourobservationswillbenoisy: \ud835\udc66\u0018\ud835\udc53\u00b9x\u00ba\u00b8\ud835\udf16,where\nwe usually assume that the \ud835\udf16\u0018\ud835\udc41\u00b90,\ud835\udf0e\u00baobservation noise is Gaussian distributed.\nFaced with all these challenges, we usually try to identify a small set of well performing\nhyperparameter configurations quickly, instead of hitting the global optima exactly. How-\never, due to large computational demands of most neural networks models, even this can\ntake days or weeks of compute. We will explore in Section 19.4 how we can speed-up the\noptimization process by either distributing the search or using cheaper-to-evaluate approx-\nimations of the objective function.\nWe begin with a method for computing the validation error of a model.\nclass HPOTrainer (d2l .Trainer): #@save\ndef validation_error (self ):\nself .model .eval()\naccuracy =0\nval_batch_idx =0\nfor batch inself .val_dataloader:\nwith torch .no_grad():\nx, y =self .prepare_batch(batch)\ny_hat =self .model(x)\n(continues on next page)\n831 What Is Hyperparameter Optimization?", "mimetype": "text/plain", "start_char_idx": 1743929, "end_char_idx": 1747971, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "aa904af0-41f2-4d28-9e10-1a0a286a90e5": {"__data__": {"id_": "aa904af0-41f2-4d28-9e10-1a0a286a90e5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e11ba821-b3bf-4744-a088-c7a79d6032e2", "node_type": "1", "metadata": {}, "hash": "966d433a53ff5bcad03057b925d6bd77931bc5ec4763e1ce1420e9a83b42743e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c88d4d0b-79cd-4c30-a93e-d74aec5d7810", "node_type": "1", "metadata": {}, "hash": "218092d25d27d7bf819d39563f87da21d47ef326ef674d6f98693357b18f99b8", "class_name": "RelatedNodeInfo"}}, "text": "Faced with all these challenges, we usually try to identify a small set of well performing\nhyperparameter configurations quickly, instead of hitting the global optima exactly. How-\never, due to large computational demands of most neural networks models, even this can\ntake days or weeks of compute. We will explore in Section 19.4 how we can speed-up the\noptimization process by either distributing the search or using cheaper-to-evaluate approx-\nimations of the objective function.\nWe begin with a method for computing the validation error of a model.\nclass HPOTrainer (d2l .Trainer): #@save\ndef validation_error (self ):\nself .model .eval()\naccuracy =0\nval_batch_idx =0\nfor batch inself .val_dataloader:\nwith torch .no_grad():\nx, y =self .prepare_batch(batch)\ny_hat =self .model(x)\n(continues on next page)\n831 What Is Hyperparameter Optimization?\n(continued from previous page)\naccuracy +=self .model .accuracy(y_hat, y)\nval_batch_idx +=1\nreturn 1-accuracy /val_batch_idx\nWe optimize validation error with respect to the hyperparameter configuration config,\nconsistingofthe learning_rate . Foreachevaluation,wetrainourmodelfor max_epochs\nepochs, then compute and return its validation error:\ndef hpo_objective_softmax_classification (config, max_epochs =8):\nlearning_rate =config[ \"learning_rate \"]\ntrainer =d2l.HPOTrainer(max_epochs =max_epochs)\ndata =d2l.FashionMNIST(batch_size =16)\nmodel =d2l.SoftmaxRegression(num_outputs =10, lr =learning_rate)\ntrainer .fit(model =model, data =data)\nreturn trainer .validation_error() .detach() .numpy()\nTheConfiguration Space\nAlong with the objective function \ud835\udc53\u00b9x\u00ba, we also need to define the feasible set x2Xto\noptimize over, known as configuration space orsearch space . For our logistic regression\nexample, we will use:\nconfig_space ={\"learning_rate \": stats .loguniform( 1e-4 ,1)}\nHere we use the use the loguniform object from SciPy, which represents a uniform distri-\nbution between -4 and -1 in the logarithmic space. This object allows us to sample random\nvariables from this distribution.\nEachhyperparameterhasadatatype,suchas floatforlearning_rate ,aswellasaclosed\nbounded range (i.e., lower and upper bounds). We usually assign a prior distribution (e.g,\nuniformorlog-uniform)toeachhyperparametertosamplefrom. Somepositiveparameters,\nsuch as learning_rate , are best represented on a logarithmic scale as optimal values can\ndiffer by several orders of magnitude, while others, such as momentum, come with linear\nscale.\nBelow we show a simple example of a configuration space consisting of typical hyperpa-\nrameters of a multi-layer perceptron including their type and standard ranges.\n: Example configuration space of multi-layer perceptron\nTable 19.1.1: label: tab_example_configspace\n832 Hyperparameter Optimization\nName Type Hyperparameter\nRangeslog-scale\nlearning rate float :math:\u2018 [10^{-\n6},10^{-1}]\u2018yes\nbatch size integer \u00bb8,256\u00bc yes\nmomentum float \u00bb0,0.99\u00bc no\nactivation function categorical :mat\nh:{textrm{tanh}\n, textrm{relu}}\u000f\nnumber of units integer \u00bb32,1024\u00bc yes\nnumber of layers integer \u00bb1,6\u00bc no\nIn general, the structure of the configuration space Xcan be complex and it can be quite\ndifferent from R\ud835\udc51. In practice, some hyperparameters may depend on the value of others.\nFor example, assume we try to tune the number of layers for a multi-layer perceptron, and\nfor each layer the number of units. The number of units of the \ud835\udc59-th layer is relevant only if\nthe network has at least \ud835\udc59\u00b81layers. These advanced HPO problems are beyond the scope\nof this chapter. We refer the interested reader to ( Baptista and Poloczek, 2018 ,Hutteret\nal., 2011,Jenattonetal., 2017).\nThe configuration space plays an important role for hyperparameter optimization, since\nno algorithms can find something that is not included in the configuration space. On the\nother hand, if the ranges are too large, the computation budget to find well performing\nconfigurations might become infeasible.\n19.1.2RandomSearch\nRandom search is the first hyperparameter optimization algorithm we will consider.", "mimetype": "text/plain", "start_char_idx": 1747122, "end_char_idx": 1751161, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c88d4d0b-79cd-4c30-a93e-d74aec5d7810": {"__data__": {"id_": "c88d4d0b-79cd-4c30-a93e-d74aec5d7810", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "aa904af0-41f2-4d28-9e10-1a0a286a90e5", "node_type": "1", "metadata": {}, "hash": "ff3746354ee44684e7da909935c72a472b90b73f52d7b152225ff42c6cbdc725", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "05af1732-21c9-4b11-810f-17f8b32c4509", "node_type": "1", "metadata": {}, "hash": "603fafa7631dac18e1b4dec5f6eeabb89e8097bc7bfc428d5a386003463bf7ce", "class_name": "RelatedNodeInfo"}}, "text": "For example, assume we try to tune the number of layers for a multi-layer perceptron, and\nfor each layer the number of units. The number of units of the \ud835\udc59-th layer is relevant only if\nthe network has at least \ud835\udc59\u00b81layers. These advanced HPO problems are beyond the scope\nof this chapter. We refer the interested reader to ( Baptista and Poloczek, 2018 ,Hutteret\nal., 2011,Jenattonetal., 2017).\nThe configuration space plays an important role for hyperparameter optimization, since\nno algorithms can find something that is not included in the configuration space. On the\nother hand, if the ranges are too large, the computation budget to find well performing\nconfigurations might become infeasible.\n19.1.2RandomSearch\nRandom search is the first hyperparameter optimization algorithm we will consider. The\nmain idea of random search is to independently sample from the configuration space until\na predefined budget (e.g maximum number of iterations) is exhausted, and to return the\nbestobservedconfiguration. Allevaluationscanbeexecutedindependentlyinparallel(see\nSection 19.3 ), but here we use a sequential loop for simplicity.\nerrors, values =[], []\nnum_iterations =5\nfor iinrange (num_iterations):\nlearning_rate =config_space[ \"learning_rate \"].rvs()\nprint (f\"Trial {i}: learning_rate = {learning_rate }\")\ny=hpo_objective_softmax_classification({ \"learning_rate \": learning_rate})\nprint (f\" validation_error = {y}\")\nvalues .append(learning_rate)\nerrors .append(y)\nvalidation_error =0.17070001363754272\nThe best learning rate is then simply the one with the lowest validation error.\n833 19.1 What Is Hyperparameter Optimization?\n\n834 Hyperparameter Optimization\nbest_idx =np.argmin(errors)\nprint (f\"optimal learning rate = {values[best_idx] }\")\noptimal learning rate =0.09844872561810249\nDuetoitssimplicityandgenerality, randomsearchisoneofthemostfrequentlyusedHPO\nalgorithms. It does not require any sophisticated implementation and can be applied to\nany configuration space as long as we can define some probability distribution for each\nhyperparameter.\nUnfortunately random search also comes with a few shortcomings. First, it does not adapt\nthe sampling distribution based on the previous observations it collected so far. Hence,\nit is equally likely to sample a poorly performing configuration than a better performing\nconfiguration. Second, the same amount of resources are spent for all configurations, even\nthoughsomemayshowpoorinitialperformanceandarelesslikelytooutperformpreviously\nseen configurations.\nIn the next sections we will look at more sample efficient hyperparameter optimization\nalgorithms that overcome the shortcomings of random search by using a model to guide\nthe search. We will also look at algorithms that automatically stop the evaluation process\nof poorly performing configurations to speed up the optimization process.\n19.1.3Summary\nIn this section we introduced hyperparameter optimization (HPO) and how we can phrase\nit as a global optimization by defining a configuration space and an objective function.\nWe also implemented our first HPO algorithm, random search, and applied it on a simple\nsoftmax classification problem.\nWhilerandomsearchisverysimple, itisthebetteralternativetogridsearch, whichsimply\nevaluates a fixed set of hyperparameters. Random search somewhat mitigates the curse\nof dimensionality ( Bellman, 1966 ), and can be far more efficient than grid search if the\ncriterion most strongly depends on a small subset of the hyperparameters.\n19.1.4Exercises\n835 What Is Hyperparameter Optimization?\n2651.In this chapter, we optimize the validation error of a model after training on a disjoint\ntraining set. For simplicity, our code uses Trainer.val_dataloader , which maps to a\nloader around FashionMNIST.val .\n1.Convince yourself (by looking at the code) that this means we use the original Fash-\nionMNISTtrainingset(60000examples)fortraining,andtheoriginal testset(10000\nexamples) for validation.\n2.Whycouldthispracticebeproblematic? Hint: Re-read Section3.6 ,especiallyabout\nmodel selection .\n3.What should we have done instead?\n2.Westatedabovethathyperparameteroptimizationbygradientdescentisveryhardtodo.\nConsiderasmallproblem,suchastrainingatwo-layerperceptronontheFashionMNIST\ndataset ( Section 5.2 ) with a batch size of 256. We would like to tune the learning rate\nof SGD in order to minimize a validation metric after one epoch of training.\n1.Why cannot we use validation errorfor this purpose?", "mimetype": "text/plain", "start_char_idx": 1750364, "end_char_idx": 1754816, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "05af1732-21c9-4b11-810f-17f8b32c4509": {"__data__": {"id_": "05af1732-21c9-4b11-810f-17f8b32c4509", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c88d4d0b-79cd-4c30-a93e-d74aec5d7810", "node_type": "1", "metadata": {}, "hash": "218092d25d27d7bf819d39563f87da21d47ef326ef674d6f98693357b18f99b8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a4129773-b553-450a-b270-48acb3e0e609", "node_type": "1", "metadata": {}, "hash": "206546f9b560fbfbc1b437c30b93a2e8502a490032efb0798c73c25b7a2f224c", "class_name": "RelatedNodeInfo"}}, "text": "1.Convince yourself (by looking at the code) that this means we use the original Fash-\nionMNISTtrainingset(60000examples)fortraining,andtheoriginal testset(10000\nexamples) for validation.\n2.Whycouldthispracticebeproblematic? Hint: Re-read Section3.6 ,especiallyabout\nmodel selection .\n3.What should we have done instead?\n2.Westatedabovethathyperparameteroptimizationbygradientdescentisveryhardtodo.\nConsiderasmallproblem,suchastrainingatwo-layerperceptronontheFashionMNIST\ndataset ( Section 5.2 ) with a batch size of 256. We would like to tune the learning rate\nof SGD in order to minimize a validation metric after one epoch of training.\n1.Why cannot we use validation errorfor this purpose? What metric on the validation\nset would you use?\n2.Sketch (roughly) the computational graph of the validation metric after training for\noneepoch. Youmayassumethatinitialweightsandhyperparameters(suchaslearn-\ning rate) are input nodes to this graph. Hint: Re-read about computational graphs in\nSection 5.3 .\n3.Givearoughestimateofthenumberoffloatingpointvaluesyouneedtostoreduring\na forward pass on this graph. Hint: FashionMNIST has 60000 cases. Assume the\nrequired memory is dominated by the activations after each layer, and look up the\nlayer widths in Section 5.2 .\n4.Apart from the sheer amount of compute and storage required, what other issues\nwould gradient-based hyperparameter optimization run into? Hint: Re-read about\nvanishing and exploding gradients in Section 5.4 .\n5.Advanced : Read (Maclaurin et al., 2015) for an elegant (yet still somewhat unprac-\ntical) approach to gradient-based HPO.\n3.Grid search is another HPO baseline, where we define an equi-spaced grid for each hy-\nperparameter,theniterateoverthe(combinatorial)Cartesianproductinordertosuggest\nconfigurations.\n1.We stated above that random search can be much more efficient than grid search for\nHPOonasizablenumberofhyperparameters, ifthecriterionmoststronglydepends\non a small subset of the hyperparameters. Why is this? Hint: Read ( Bergstraet al.,\n2011).\nDiscussions265.\n836 Hyperparameter Optimization\n19.2HyperparameterOptimizationAPI\nBefore we dive into the methodology, we will first discuss a basic code structure that al-\nlows us to efficiently implement various HPO algorithms. In general, all HPO algorithms\nconsideredhereneedtoimplementtwodecisionmakingprimitives, searching andschedul-\ning. First, they need to sample new hyperparameter configurations, which often involves\nsome kind of search over the configuration space. Second, for each configuration, an HPO\nalgorithm needs to schedule its evaluation and decide how many resources to allocate for\nit. Once we start to evaluate a configuration, we will refer to it as a trial. We map these\ndecisionstotwoclasses, HPOSearcher andHPOScheduler . Ontopofthat,wealsoprovide\naHPOTuner class that executes the optimization process.\nThis concept of scheduler and searcher is also implemented in popular HPO libraries, such\nas Syne Tune ( Salinaset al., 2022), Ray Tune ( Liawet al., 2018) or Optuna ( Akibaet al.,\n2019).\nimport time\nfrom scipy import stats\nfrom d2l import torch asd2l\n19.2.1Searcher\nBelow we define a base class for searchers, which provides a new candidate configuration\nthrough the sample_configuration function. A simple way to implement this function\nwould be to sample configurations uniformly at random, as we did for random search in\nSection 19.1 . More sophisticated algorithms, such as Bayesian optimization, will make\nthese decisions based on the performance of previous trials. As a result, these algorithms\nare able to sample more promising candidates over time. We add the updatefunction in\norder to update the history of previous trials, which can then be exploited to improve our\nsampling distribution.\nclass HPOSearcher (d2l .HyperParameters): #@save\ndef sample_configuration ()->dict :\nraise NotImplementedError\ndef update (self , config: dict , error: float , additional_info =None ):\npass\nThe following code shows how to implement our random search optimizer from the pre-\nvious section in this API. As a slight extension, we allow the user to prescribe the first\nconfiguration to be evaluated via initial_config , while subsequent ones are drawn at\nrandom.", "mimetype": "text/plain", "start_char_idx": 1754123, "end_char_idx": 1758347, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a4129773-b553-450a-b270-48acb3e0e609": {"__data__": {"id_": "a4129773-b553-450a-b270-48acb3e0e609", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "05af1732-21c9-4b11-810f-17f8b32c4509", "node_type": "1", "metadata": {}, "hash": "603fafa7631dac18e1b4dec5f6eeabb89e8097bc7bfc428d5a386003463bf7ce", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ef08a95c-ec0c-4f73-88d5-243a16ceb8bc", "node_type": "1", "metadata": {}, "hash": "5a8f226163d67056005cb2d23f8d8f1251bfe5a329986ee2804b9ada692fa229", "class_name": "RelatedNodeInfo"}}, "text": "A simple way to implement this function\nwould be to sample configurations uniformly at random, as we did for random search in\nSection 19.1 . More sophisticated algorithms, such as Bayesian optimization, will make\nthese decisions based on the performance of previous trials. As a result, these algorithms\nare able to sample more promising candidates over time. We add the updatefunction in\norder to update the history of previous trials, which can then be exploited to improve our\nsampling distribution.\nclass HPOSearcher (d2l .HyperParameters): #@save\ndef sample_configuration ()->dict :\nraise NotImplementedError\ndef update (self , config: dict , error: float , additional_info =None ):\npass\nThe following code shows how to implement our random search optimizer from the pre-\nvious section in this API. As a slight extension, we allow the user to prescribe the first\nconfiguration to be evaluated via initial_config , while subsequent ones are drawn at\nrandom.\nclass RandomSearcher (HPOSearcher): #@save\n(continues on next page)\n837 Hyperparameter Optimization API\n(continued from previous page)\ndef __init__ (self , config_space: dict , initial_config =None ):\nself .save_hyperparameters()\ndef sample_configuration (self )->dict :\nifself .initial_config isnot None :\nresult =self .initial_config\nself .initial_config =None\nelse :\nresult ={\nname: domain .rvs()\nfor name, domain inself .config_space .items()\n}\nreturn result\n19.2.2Scheduler\nBeyond sampling configurations for new trials, we also need to decide when and for how\nlong to run a trial. In practice, all these decisions are done by the HPOScheduler , which\ndelegates the choice of new configurations to a HPOSearcher . The suggest method is\ncalled whenever some resource for training becomes available. Apart from invoking sam-\nple_configuration of a searcher, it may also decide upon parameters like max_epochs\n(i.e.,howlongtotrainthemodelfor). The updatemethodiscalledwheneveratrialreturns\na new observation.\nclass HPOScheduler (d2l .HyperParameters): #@save\ndef suggest (self )->dict :\nraise NotImplementedError\ndef update (self , config: dict , error: float , info =None ):\nraise NotImplementedError\nTo implement random search, but also other HPO algorithms, we only need a basic sched-\nulerthatschedulesanewconfigurationeverytimenewresourcesbecomeavailable.\nclass BasicScheduler (HPOScheduler): #@save\ndef __init__ (self , searcher: HPOSearcher):\nself .save_hyperparameters()\ndef suggest (self )->dict :\nreturn self .searcher .sample_configuration()\ndef update (self , config: dict , error: float , info =None ):\nself .searcher .update(config, error, additional_info =info)\n19.2.3Tuner\nFinally,weneedacomponentthatrunsthescheduler/searcheranddoessomebook-keeping\noftheresults. ThefollowingcodeimplementsasequentialexecutionoftheHPOtrialsthat\n838 Hyperparameter Optimization\nevaluates one training job after the next and will serve as a basic example. We will later\nuseSyne Tune for more scalable distributed HPO cases.\nclass HPOTuner (d2l .HyperParameters): #@save\ndef __init__ (self , scheduler: HPOScheduler, objective: callable ):\nself .save_hyperparameters()\n# Bookeeping results for plotting\nself .incumbent =None\nself .incumbent_error =None\nself .incumbent_trajectory =[]\nself .cumulative_runtime =[]\nself .current_runtime =0\nself .records =[]\ndef run(self , number_of_trials):\nfor iinrange (number_of_trials):\nstart_time =time .time()\nconfig =self .scheduler .suggest()\nprint (f\"Trial {i}: config = {config }\")\nerror =self .objective( **config)\nerror =float (error .cpu() .detach() .numpy())\nself .scheduler .update(config, error)\nruntime =time .time() -start_time\nself .bookkeeping(config, error, runtime)\nprint (f\" error = {error }, runtime = {runtime }\")\n19.2.4Bookkeepingthe Performanceof HPO Algorithms\nWith any HPO algorithm, we are mostly interested in the best performing configuration\n(calledincumbent ) and its validation error after a given wall-clock time. This is why we\ntrack runtime per iteration, which includes both the time to run an evaluation (call of\nobjective ) and the time to make a decision (call of scheduler.suggest ).", "mimetype": "text/plain", "start_char_idx": 1757386, "end_char_idx": 1761505, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ef08a95c-ec0c-4f73-88d5-243a16ceb8bc": {"__data__": {"id_": "ef08a95c-ec0c-4f73-88d5-243a16ceb8bc", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a4129773-b553-450a-b270-48acb3e0e609", "node_type": "1", "metadata": {}, "hash": "206546f9b560fbfbc1b437c30b93a2e8502a490032efb0798c73c25b7a2f224c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d7b73331-45b9-42f0-b0cb-99336330ea1d", "node_type": "1", "metadata": {}, "hash": "1ca5f85bb3b7d342b5489434c2e4206ee73062c4da43baf10851ff612067f596", "class_name": "RelatedNodeInfo"}}, "text": "This is why we\ntrack runtime per iteration, which includes both the time to run an evaluation (call of\nobjective ) and the time to make a decision (call of scheduler.suggest ). In the se-\nquel, wewill plot cumulative_runtime against incumbent_trajectory in order to visu-\nalize theany-timeperformance of the HPO algorithm defined in terms of scheduler (and\nsearcher ). This allows us to quantify not only how well the configuration found by an\noptimizer works, but also how quickly an optimizer is able to find it.\n@d2l .add_to_class(HPOTuner) #@save\ndef bookkeeping (self , config: dict , error: float , runtime: float ):\nself .records .append({ \"config \": config, \"error \": error, \"runtime \": runtime})\n# Check if the last hyperparameter configuration performs better\n# than the incumbent\nifself .incumbent isNone orself .incumbent_error >error:\nself .incumbent =config\nself .incumbent_error =error\n# Add current best observed performance to the optimization trajectory\nself .incumbent_trajectory .append( self .incumbent_error)\n# Update runtime\nself .current_runtime +=runtime\nself .cumulative_runtime .append( self .current_runtime)\n839 Hyperparameter Optimization API\n19.2.5Example: Optimizingthe Hyperparametersof a Convolutional\nNeuralNetwork\nWe now use our new implementation of random search to optimize the batch size and\nlearning rate of the LeNetconvolutional neural network from Section 7.6 . We being by\ndefining the objective function, which will once more be validation error.\ndef hpo_objective_lenet (learning_rate, batch_size, max_epochs =10): #@save\nmodel =d2l.LeNet(lr =learning_rate, num_classes =10)\ntrainer =d2l.HPOTrainer(max_epochs =max_epochs, num_gpus =1)\ndata =d2l.FashionMNIST(batch_size =batch_size)\nmodel .apply_init([ next (iter (data .get_dataloader( True )))[ 0]], d2l .init_cnn)\ntrainer .fit(model =model, data =data)\nvalidation_error =trainer .validation_error()\nreturn validation_error\nWe also need to define the configuration space. Moreover, the first configuration to be\nevaluated is the default setting used in Section 7.6 .\nconfig_space ={\n\"learning_rate \": stats .loguniform( 1e-2 ,1),\n\"batch_size \": stats .randint( 32,256),\n}\ninitial_config ={\n\"learning_rate \":0.1,\n\"batch_size \":128,\n}\nNow we can start our random search:\nsearcher =RandomSearcher(config_space, initial_config =initial_config)\nscheduler =BasicScheduler(searcher =searcher)\ntuner =HPOTuner(scheduler =scheduler, objective =hpo_objective_lenet)\ntuner .run(number_of_trials =5)\nerror =0.9000097513198853 , runtime =62.85189199447632\nBelowweplottheoptimizationtrajectoryoftheincumbenttogettheany-timeperformance\nof random search:\n840 Hyperparameter Optimization\n\n841 Hyperparameter Optimization API\nboard =d2l.ProgressBoard(xlabel =\"time \", ylabel =\"error \")\nfor time_stamp, error inzip(\ntuner .cumulative_runtime, tuner .incumbent_trajectory\n):\nboard .draw(time_stamp, error, \"random search \", every_n =1)\n19.2.6ComparingHPO Algorithms\nJust as with training algorithms or model architectures, it is important to understand how\nto best compare different HPO algorithms. Each HPO run depends on two major sources\nof randomness: the random effects of the training process, such as random weight initial-\nization or mini-batch ordering, and the intrinsic randomness of the HPO algorithm itself,\nsuch as the random sampling of random search. Hence, when comparing different algo-\nrithms, it is crucial to run each experiment several times and report statistics, such as mean\nor median, across a population of multiple repetitions of an algorithm based on different\nseeds of the random number generator.\nTo illustrate this, we compare random search (see Section 19.1.2 ) and Bayesian optimiza-\ntion (Snoeket al., 2012) on tuning the hyperparameters of a feed-forward neural network.\nEach algorithm was evaluated 50times with a different random seed. The solid line indi-\ncates the average performance of the incumbent across these 50repetitions and the dashed\nline the standard deviation. We can see that random search and Bayesian optimization per-\nform roughly the same up to ~1000 seconds, but Bayesian optimization can make use of\nthe past observation to identify better configurations and thus quickly outperforms random\nsearch afterwards.", "mimetype": "text/plain", "start_char_idx": 1761329, "end_char_idx": 1765576, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d7b73331-45b9-42f0-b0cb-99336330ea1d": {"__data__": {"id_": "d7b73331-45b9-42f0-b0cb-99336330ea1d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ef08a95c-ec0c-4f73-88d5-243a16ceb8bc", "node_type": "1", "metadata": {}, "hash": "5a8f226163d67056005cb2d23f8d8f1251bfe5a329986ee2804b9ada692fa229", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2cdab69f-f41b-4253-b20e-3befb4a6bda7", "node_type": "1", "metadata": {}, "hash": "6185db19e3799dc7a604c1ca1df699c02cef028da2b075a77a87971542b600e9", "class_name": "RelatedNodeInfo"}}, "text": "Hence, when comparing different algo-\nrithms, it is crucial to run each experiment several times and report statistics, such as mean\nor median, across a population of multiple repetitions of an algorithm based on different\nseeds of the random number generator.\nTo illustrate this, we compare random search (see Section 19.1.2 ) and Bayesian optimiza-\ntion (Snoeket al., 2012) on tuning the hyperparameters of a feed-forward neural network.\nEach algorithm was evaluated 50times with a different random seed. The solid line indi-\ncates the average performance of the incumbent across these 50repetitions and the dashed\nline the standard deviation. We can see that random search and Bayesian optimization per-\nform roughly the same up to ~1000 seconds, but Bayesian optimization can make use of\nthe past observation to identify better configurations and thus quickly outperforms random\nsearch afterwards.\ntFig. 19.2.1 Example any-time performance plot to compare two algorithms A and B.\n842 Hyperparameter Optimization\n26619.2.7Summary\nThis section laid out a simple, yet flexible interface to implement various HPO algorithms\nthat we will look at in this chapter. Similar interfaces can be found in popular open-source\nHPO frameworks. We also looked at how we can compare HPO algorithms, and potential\npitfall one needs to be aware.\n19.2.8Exercises\n1.The goal of this exercise is to implement the objective function for a slightly more chal-\nlengingHPOproblem,andtorunmorerealisticexperiments. Wewillusethetwohidden\nlayer MLP DropoutMLP implemented in Section 5.6 .\n1.Code up the objective function, which should depend on all hyperparameters of the\nmodeland batch_size . Use max_epochs=50 . GPUsdonothelphere,so num_gpus=0 .\nHint: Modify hpo_objective_lenet .\n2.Chooseasensiblesearchspace,where num_hiddens_1 ,num_hiddens_2 areintegers\nin\u00bb8,1024\u00bc,anddropoutvaluesliein \u00bb0,0.95\u00bc,while batch_size liesin\u00bb16,384\u00bc.\nProvide code for config_space , using sensible distributions from scipy.stats .\n3.Run random search on this example with number_of_trials=20 and plot the re-\nsults. Make sure to first evaluate the default configuration of Section 5.6 , which\nisinitial_config = {'num_hiddens_1': 256, 'num_hiddens_2': 256,\n'dropout_1': 0.5, 'dropout_2': 0.5, 'lr': 0.1, 'batch_size': 256} .\n2.In this exercise, you will implement a new searcher (subclass of HPOSearcher ) which\nmakesdecisionsbasedonpastdata. Itdependsonparameters probab_local ,num_init_random .\nItssample_configuration method works as follows. For the first num_init_random\ncalls,dothesameas RandomSearcher.sample_configuration . Otherwise,withprob-\nability 1 - probab_local ,dothesameas RandomSearcher.sample_configuration .\nOtherwise, pick the configuration which attained the smallest validation error so far,\nselect one of its hyperparameters at random, and sample its value randomly like in\nRandomSearcher.sample_configuration , but leave all other values the same. Re-\nturn this configuration, which is identical to the best configuration so far, except in this\none hyperparameter.\n1.Code up this new LocalSearcher . Hint: Your searcher requires config_space as\nargument at construction. Feel free to use a member of type RandomSearcher . You\nwill also have to implement the updatemethod.\n2.Re-run the experiment from the previous exercise, but using your new searcher in-\nstead of RandomSearcher . Experiment with different values for probab_local ,\nnum_init_random . However, note that a proper comparison between different HPO\nmethods requires repeating experiments several times, and ideally considering a\nnumber of benchmark tasks.\nDiscussions266.\n843 Asynchronous Random Search\n19.3AsynchronousRandom Search\nAswehaveseenintheprevious Section19.2 , wemighthavetowaithoursorevendaysbe-\nfore random search returns a good hyperparameter configuration, because of the expensive\nevaluation of hyperparameter configurations. In practice, we have often access to a pool of\nresources such as multiple GPUs on the same machine or multiple machines with a single\nGPU. This begs the question: Howdo wee\ufb00iciently distributerandomsearch?\nIngeneral,wedistinguishbetweensynchronousandasynchronousparallelhyperparameter\noptimization (see Fig. 19.3.1 ).", "mimetype": "text/plain", "start_char_idx": 1764675, "end_char_idx": 1768883, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2cdab69f-f41b-4253-b20e-3befb4a6bda7": {"__data__": {"id_": "2cdab69f-f41b-4253-b20e-3befb4a6bda7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d7b73331-45b9-42f0-b0cb-99336330ea1d", "node_type": "1", "metadata": {}, "hash": "1ca5f85bb3b7d342b5489434c2e4206ee73062c4da43baf10851ff612067f596", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7908bb46-3f91-4f90-a6e7-49a2221d2055", "node_type": "1", "metadata": {}, "hash": "578f9ab12e08d050ccb3d7ba03c8be7e40c51969233ae8f38d145a6620146d68", "class_name": "RelatedNodeInfo"}}, "text": "Experiment with different values for probab_local ,\nnum_init_random . However, note that a proper comparison between different HPO\nmethods requires repeating experiments several times, and ideally considering a\nnumber of benchmark tasks.\nDiscussions266.\n843 Asynchronous Random Search\n19.3AsynchronousRandom Search\nAswehaveseenintheprevious Section19.2 , wemighthavetowaithoursorevendaysbe-\nfore random search returns a good hyperparameter configuration, because of the expensive\nevaluation of hyperparameter configurations. In practice, we have often access to a pool of\nresources such as multiple GPUs on the same machine or multiple machines with a single\nGPU. This begs the question: Howdo wee\ufb00iciently distributerandomsearch?\nIngeneral,wedistinguishbetweensynchronousandasynchronousparallelhyperparameter\noptimization (see Fig. 19.3.1 ). In the synchronous setting, we wait for all concurrently\nrunning trials to finish, before we start the next batch. Consider configuration spaces that\ncontain hyperparameters such as the number of filters or number of layers of a deep neural\nnetwork. Hyperparameter configurations that contain a larger number of layers of filters\nwillnaturallytakemoretimetofinish,andallothertrialsinthesamebatchwillhavetowait\natsynchronisationpoints(greyareain Fig.19.3.1 )beforewecancontinuetheoptimization\nprocess.\nIn the asynchronous setting we immediately schedule a new trial as soon as resources be-\ncome available. This will optimally exploit our resources, since we can avoid any synchro-\nnisation overhead. For random search, each new hyperparameter configuration is chosen\nindependentlyofallothers,andinparticularwithoutexploitingobservationsfromanyprior\nevaluation. This means we can trivially parallelize random search asynchronously. This is\nnot straight-forward with more sophisticated methods that make decision based on previ-\nous observations (see Section 19.5 ). While we need access to more resources than in the\nsequential setting, asynchronousrandom searchexhibits a linear speed-up, in that a certain\nperformance is reached \ud835\udc3etimes faster if \ud835\udc3etrials can be run in parallel.\nSequential Trial-0 Trial-1 Trial-2 Trial-3 Trial-4\nSynchronous\nAsynchronousTrial-0 Trial-2\nTrial-3\nTrial-0\nTimeTrial-5\nTrial-1\nTrial-1Trial-4\nTrial-5\nTrial-3\nTrial-2Trial-4\nTrial-5\ntFig. 19.3.1 Distributing the hyperparameter optimization process either synchronously or\nasynchronously. Compared to the sequential setting, we can reduce the overall wall-clock\ntime while keep the total compute constant. Synchronous scheduling might lead to idling\nworkers in the case of stragglers.\nIn this notebook, we will look at asynchronous random search that, where trials are exe-\ncuted in multiple python processes on the same machine. Distributed job scheduling and\nexecution is difficult to implement from scratch. We will use Syne Tune (Salinaset al.,\n2022), which provides us with a simple interface for asynchronous HPO. Syne Tune is de-\n844 Hyperparameter Optimization\nsigned to be run with different execution back-ends, and the interested reader is invited to\nstudy its simple APIs in order to learn more about distributed HPO.", "mimetype": "text/plain", "start_char_idx": 1768041, "end_char_idx": 1771190, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7908bb46-3f91-4f90-a6e7-49a2221d2055": {"__data__": {"id_": "7908bb46-3f91-4f90-a6e7-49a2221d2055", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2cdab69f-f41b-4253-b20e-3befb4a6bda7", "node_type": "1", "metadata": {}, "hash": "6185db19e3799dc7a604c1ca1df699c02cef028da2b075a77a87971542b600e9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "363fcfb7-4786-4de2-b2ab-89a98620a6b2", "node_type": "1", "metadata": {}, "hash": "5b207660ff14d588452105b96d6e074747b823ee63473c98cd81501bfb8157c6", "class_name": "RelatedNodeInfo"}}, "text": "19.3.1 Distributing the hyperparameter optimization process either synchronously or\nasynchronously. Compared to the sequential setting, we can reduce the overall wall-clock\ntime while keep the total compute constant. Synchronous scheduling might lead to idling\nworkers in the case of stragglers.\nIn this notebook, we will look at asynchronous random search that, where trials are exe-\ncuted in multiple python processes on the same machine. Distributed job scheduling and\nexecution is difficult to implement from scratch. We will use Syne Tune (Salinaset al.,\n2022), which provides us with a simple interface for asynchronous HPO. Syne Tune is de-\n844 Hyperparameter Optimization\nsigned to be run with different execution back-ends, and the interested reader is invited to\nstudy its simple APIs in order to learn more about distributed HPO.\nimport logging\nfrom d2l import torch asd2l\nlogging .basicConfig(level =logging .INFO)\nfrom syne_tune import StoppingCriterion, Tuner\nfrom syne_tune .backend .python_backend import PythonBackend\nfrom syne_tune .config_space import loguniform, randint\nfrom syne_tune .experiments import load_experiment\nfrom syne_tune .optimizer .baselines import RandomSearch\nINFO:root:SageMakerBackend isnot imported since dependencies are missing .You\u2423\n\u21a9!can install them with\npip install 'syne-tune[extra] '\nAWS dependencies are not imported since dependencies are missing .You can \u2423\n\u21a9!install them with\npip install 'syne-tune[aws] '\nor(for everything)\npip install 'syne-tune[extra] '\nAWS dependencies are not imported since dependencies are missing .You can \u2423\n\u21a9!install them with\npip install 'syne-tune[aws] '\nor(for everything)\npip install 'syne-tune[extra] '\nINFO:root:Ray Tune schedulers and searchers are not imported since \u2423\n\u21a9!dependencies are missing .You can install them with\npip install 'syne-tune[raytune] '\nor(for everything)\npip install 'syne-tune[extra] '\n19.3.1ObjectiveFunction\nFirst, we have to define a new objective function such that it now returns the performance\nback to Syne Tune via the reportcallback.\ndef hpo_objective_lenet_synetune (learning_rate, batch_size, max_epochs):\nfrom syne_tune import Reporter\nfrom d2l import torch asd2l\nmodel =d2l.LeNet(lr =learning_rate, num_classes =10)\ntrainer =d2l.HPOTrainer(max_epochs =1, num_gpus =1)\ndata =d2l.FashionMNIST(batch_size =batch_size)\nmodel .apply_init([ next (iter (data .get_dataloader( True )))[ 0]], d2l .init_cnn)\nreport =Reporter()\nfor epoch inrange (1, max_epochs +1):\nifepoch ==1:\n# Initialize the state of Trainer\ntrainer .fit(model =model, data =data)\nelse :\ntrainer .fit_epoch()\n(continues on next page)\n845 Asynchronous Random Search\n(continued from previous page)\nvalidation_error =trainer .validation_error() .cpu() .detach() .numpy()\nreport(epoch =epoch, validation_error =float (validation_error))\nNote that the PythonBackend of Syne Tune requires dependencies to be imported inside\nthe function definition.\n19.3.2AsynchronousScheduler\nFirst, we define the number of workers that evaluate trials concurrently. We also need to\nspecify how long we want to run random search, by defining an upper limit on the total\nwall-clock time.\nn_workers =2# Needs to be <= the number of available GPUs\nmax_wallclock_time =12*60 # 12 minutes\nNext, we state which metric we want to optimize and whether we want to minimize or\nmaximize this metric. Namely, metricneeds to correspond to the argument name passed\nto the reportcallback.\nmode =\"min\"\nmetric =\"validation_error \"\nWe use the configuration space from our previous example. In Syne Tune, this dictionary\ncan also be used to pass constant attributes to the training script. We make use of this\nfeature in order to pass max_epochs . Moreover, we specify the first configuration to be\nevaluated in initial_config .\nconfig_space ={\n\"learning_rate \": loguniform( 1e-2 ,1),\n\"batch_size \": randint( 32,256),\n\"max_epochs \":10,\n}\ninitial_config ={\n\"learning_rate \":0.1,\n\"batch_size \":128,\n}\nNext, we need to specify the back-end for job executions.", "mimetype": "text/plain", "start_char_idx": 1770350, "end_char_idx": 1774349, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "363fcfb7-4786-4de2-b2ab-89a98620a6b2": {"__data__": {"id_": "363fcfb7-4786-4de2-b2ab-89a98620a6b2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7908bb46-3f91-4f90-a6e7-49a2221d2055", "node_type": "1", "metadata": {}, "hash": "578f9ab12e08d050ccb3d7ba03c8be7e40c51969233ae8f38d145a6620146d68", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f57a25b1-d70a-4107-ba24-a04b31ed45f7", "node_type": "1", "metadata": {}, "hash": "dc7656f32eb34af820113e0ddcb21350f4d4247e495fadb96b06f5933fb08dc0", "class_name": "RelatedNodeInfo"}}, "text": "Namely, metricneeds to correspond to the argument name passed\nto the reportcallback.\nmode =\"min\"\nmetric =\"validation_error \"\nWe use the configuration space from our previous example. In Syne Tune, this dictionary\ncan also be used to pass constant attributes to the training script. We make use of this\nfeature in order to pass max_epochs . Moreover, we specify the first configuration to be\nevaluated in initial_config .\nconfig_space ={\n\"learning_rate \": loguniform( 1e-2 ,1),\n\"batch_size \": randint( 32,256),\n\"max_epochs \":10,\n}\ninitial_config ={\n\"learning_rate \":0.1,\n\"batch_size \":128,\n}\nNext, we need to specify the back-end for job executions. Here we just consider the distri-\nbution on a local machine where parallel jobs are executed as sub-processes. However, for\nlarge scale HPO, we could run this also on a cluster or cloud environment, where each trial\nconsumes a full instance.\ntrial_backend =PythonBackend(\ntune_function =hpo_objective_lenet_synetune,\nconfig_space =config_space,\n)\n846 Hyperparameter Optimization\nWe can now create the scheduler for asynchronous random search, which is similar in be-\nhaviour to our BasicScheduler fromSection 19.2 .\nscheduler =RandomSearch(\nconfig_space,\nmetric =metric,\nmode =mode,\npoints_to_evaluate =[initial_config],\n)\nINFO:syne_tune .optimizer .schedulers .fifo:max_resource_level =10,asinferred \u2423\n\u21a9!from config_space\nINFO:syne_tune .optimizer .schedulers .fifo:Master random_seed =2737092907\nSyne Tune also features a Tuner, where the main experiment loop and bookkeeping is\ncentralized, and interactions between scheduler and back-end are mediated.\nstop_criterion =StoppingCriterion(max_wallclock_time =max_wallclock_time)\ntuner =Tuner(\ntrial_backend =trial_backend,\nscheduler =scheduler,\nstop_criterion =stop_criterion,\nn_workers =n_workers,\nprint_update_interval =int(max_wallclock_time *0.6),\n)\nLetusrunourdistributedHPOexperiment. Accordingtoourstoppingcriterion,itwillrun\nfor about 12 minutes.\ntuner .run()\nINFO:syne_tune .tuner:results of trials will be saved on /home /ci/syne -tune /\n\u21a9!python -entrypoint -2023 -08-18-19-45-39-958\nINFO:root:Detected 4GPUs\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.1 --batch_size 128 --max_epochs 10--tune_function_root \u2423\n\u21a9!/home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-958/tune_function --\n\u21a9!tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_checkpoint_dir /\n\u21a9!home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-958/0/checkpoints\nINFO:syne_tune .tuner:(trial 0)-scheduled config { 'learning_rate ':0.1,\n\u21a9!'batch_size ':128,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.1702844732454753 --batch_size 114 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-\n\u21a9!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-958/\n\u21a9!1/checkpoints\nINFO:syne_tune .tuner:(trial 1)-scheduled config { 'learning_rate ':0.", "mimetype": "text/plain", "start_char_idx": 1773701, "end_char_idx": 1776999, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f57a25b1-d70a-4107-ba24-a04b31ed45f7": {"__data__": {"id_": "f57a25b1-d70a-4107-ba24-a04b31ed45f7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "363fcfb7-4786-4de2-b2ab-89a98620a6b2", "node_type": "1", "metadata": {}, "hash": "5b207660ff14d588452105b96d6e074747b823ee63473c98cd81501bfb8157c6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "826e1233-b776-4ded-87fd-851c0552ab1d", "node_type": "1", "metadata": {}, "hash": "1ddda2b505baac2a1b13f354e7cd543a0668b77d3a2aa62124929e1b9439b9d1", "class_name": "RelatedNodeInfo"}}, "text": "\u21a9!py--learning_rate 0.1702844732454753 --batch_size 114 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-\n\u21a9!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-958/\n\u21a9!1/checkpoints\nINFO:syne_tune .tuner:(trial 1)-scheduled config { 'learning_rate ':0.\n(continues on next page)\n847 Asynchronous Random Search\n(continued from previous page)\n\u21a9!1702844732454753 ,'batch_size ':114,'max_epochs ':10}\nINFO:syne_tune .tuner:Trial trial_id 0completed .\nINFO:syne_tune .tuner:Trial trial_id 1completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.34019846567238493 --batch_size 221 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-\n\u21a9!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-958/\n\u21a9!2/checkpoints\nINFO:syne_tune .tuner:(trial 2)-scheduled config { 'learning_rate ':0.\n\u21a9!34019846567238493 ,'batch_size ':221,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.014628124155727769 --batch_size 88--max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-\n\u21a9!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-958/\n\u21a9!3/checkpoints\nINFO:syne_tune .tuner:(trial 3)-scheduled config { 'learning_rate ':0.\n\u21a9!014628124155727769 ,'batch_size ':88,'max_epochs ':10}\nINFO:syne_tune .tuner:Trial trial_id 2completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.1114831485450576 --batch_size 142 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-\n\u21a9!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-958/\n\u21a9!4/checkpoints\nINFO:syne_tune .tuner:(trial 4)-scheduled config { 'learning_rate ':0.\n\u21a9!1114831485450576 ,'batch_size ':142,'max_epochs ':10}\nINFO:syne_tune .tuner:Trial trial_id 3completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .", "mimetype": "text/plain", "start_char_idx": 1776589, "end_char_idx": 1779414, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "826e1233-b776-4ded-87fd-851c0552ab1d": {"__data__": {"id_": "826e1233-b776-4ded-87fd-851c0552ab1d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f57a25b1-d70a-4107-ba24-a04b31ed45f7", "node_type": "1", "metadata": {}, "hash": "dc7656f32eb34af820113e0ddcb21350f4d4247e495fadb96b06f5933fb08dc0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "418f078d-d7f6-461c-9b9a-f67cf581cebe", "node_type": "1", "metadata": {}, "hash": "8554299dffca76586878517e8a8d1395bcbfcdfc9a6d8c675df8153940d71611", "class_name": "RelatedNodeInfo"}}, "text": "\u21a9!1114831485450576 ,'batch_size ':142,'max_epochs ':10}\nINFO:syne_tune .tuner:Trial trial_id 3completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.014076038679980779 --batch_size 223 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-\n\u21a9!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-958/\n\u21a9!5/checkpoints\nINFO:syne_tune .tuner:(trial 5)-scheduled config { 'learning_rate ':0.\n\u21a9!014076038679980779 ,'batch_size ':223,'max_epochs ':10}\nINFO:syne_tune .tuner:Trial trial_id 4completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.02558173674804846 --batch_size 62--max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-\n\u21a9!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-958/\n\u21a9!6/checkpoints\nINFO:syne_tune .tuner:(trial 6)-scheduled config { 'learning_rate ':0.\n\u21a9!02558173674804846 ,'batch_size ':62,'max_epochs ':10}\nINFO:syne_tune .tuner:Trial trial_id 5completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.026035979388614055 --batch_size 139 --max_epochs 10--\n(continues on next page)\n848 Hyperparameter Optimization\n(continued from previous page)\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-\n\u21a9!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-958/\n\u21a9!7/checkpoints\nINFO:syne_tune .tuner:(trial 7)-scheduled config { 'learning_rate ':0.\n\u21a9!026035979388614055 ,'batch_size ':139,'max_epochs ':10}\nINFO:syne_tune .tuner:Trial trial_id 6completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.24202494130424274 --batch_size 231 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-\n\u21a9!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-958/\n\u21a9!8/checkpoints\nINFO:syne_tune .tuner:(trial 8)-scheduled config { 'learning_rate ':0.", "mimetype": "text/plain", "start_char_idx": 1779142, "end_char_idx": 1781973, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "418f078d-d7f6-461c-9b9a-f67cf581cebe": {"__data__": {"id_": "418f078d-d7f6-461c-9b9a-f67cf581cebe", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "826e1233-b776-4ded-87fd-851c0552ab1d", "node_type": "1", "metadata": {}, "hash": "1ddda2b505baac2a1b13f354e7cd543a0668b77d3a2aa62124929e1b9439b9d1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8a70e728-d913-4271-867a-3ba32ba5f3bd", "node_type": "1", "metadata": {}, "hash": "78b68caca20e7b8353529510bc1d504e32a45df5ff1e42726aa1043a98218fcc", "class_name": "RelatedNodeInfo"}}, "text": "\u21a9!py--learning_rate 0.24202494130424274 --batch_size 231 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-\n\u21a9!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-958/\n\u21a9!8/checkpoints\nINFO:syne_tune .tuner:(trial 8)-scheduled config { 'learning_rate ':0.\n\u21a9!24202494130424274 ,'batch_size ':231,'max_epochs ':10}\nINFO:syne_tune .tuner:Trial trial_id 7completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.10483132064775551 --batch_size 145 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-\n\u21a9!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-958/\n\u21a9!9/checkpoints\nINFO:syne_tune .tuner:(trial 9)-scheduled config { 'learning_rate ':0.\n\u21a9!10483132064775551 ,'batch_size ':145,'max_epochs ':10}\nINFO:syne_tune .tuner:Trial trial_id 8completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.017898854850751864 --batch_size 51--max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-\n\u21a9!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-958/\n\u21a9!10/checkpoints\nINFO:syne_tune .tuner:(trial 10)-scheduled config { 'learning_rate ':0.\n\u21a9!017898854850751864 ,'batch_size ':51,'max_epochs ':10}\nINFO:syne_tune .tuner:Trial trial_id 9completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.9645419978270817 --batch_size 200 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-\n\u21a9!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-958/\n\u21a9!11/checkpoints\nINFO:syne_tune .tuner:(trial 11)-scheduled config { 'learning_rate ':0.\n\u21a9!9645419978270817 ,'batch_size ':200,'max_epochs ':10}\nINFO:syne_tune .tuner:Trial trial_id 11completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .", "mimetype": "text/plain", "start_char_idx": 1781562, "end_char_idx": 1784307, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8a70e728-d913-4271-867a-3ba32ba5f3bd": {"__data__": {"id_": "8a70e728-d913-4271-867a-3ba32ba5f3bd", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "418f078d-d7f6-461c-9b9a-f67cf581cebe", "node_type": "1", "metadata": {}, "hash": "8554299dffca76586878517e8a8d1395bcbfcdfc9a6d8c675df8153940d71611", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0a3378e0-8042-4a79-8c32-9fcd4a609d7f", "node_type": "1", "metadata": {}, "hash": "5d533423a3313dd587a0d7358805c070cb0b4a106cb48c0e142eb76e0d54818f", "class_name": "RelatedNodeInfo"}}, "text": "\u21a9!9645419978270817 ,'batch_size ':200,'max_epochs ':10}\nINFO:syne_tune .tuner:Trial trial_id 11completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.10559888854748693 --batch_size 40--max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-\n\u21a9!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-958/\n\u21a9!12/checkpoints\nINFO:syne_tune .tuner:(trial 12)-scheduled config { 'learning_rate ':0.\n(continues on next page)\n849 Asynchronous Random Search\n(continued from previous page)\n\u21a9!10559888854748693 ,'batch_size ':40,'max_epochs ':10}\nINFO:syne_tune .tuner:tuning status (last metric isreported)\ntrial_id status iter learning_rate batch_size max_epochs epoch \u2423\n\u21a9!validation_error worker -time\n0Completed 10 0.100000 128 10 10.0 \u2423\n\u21a9! 0.277195 64.928907\n1Completed 10 0.170284 114 10 10.0 \u2423\n\u21a9! 0.286225 65.434195\n2Completed 10 0.340198 221 10 10.0 \u2423\n\u21a9! 0.218990 59.729758\n3Completed 10 0.014628 88 10 10.0 \u2423\n\u21a9! 0.899920 81.001636\n4Completed 10 0.111483 142 10 10.0 \u2423\n\u21a9! 0.268684 64.427400\n5Completed 10 0.014076 223 10 10.0 \u2423\n\u21a9! 0.899922 61.264475\n6Completed 10 0.025582 62 10 10.0 \u2423\n\u21a9! 0.399520 75.966186\n7Completed 10 0.026036 139 10 10.0 \u2423\n\u21a9! 0.899988 62.261541\n8Completed 10 0.242025 231 10 10.0 \u2423\n\u21a9! 0.257636 58.186485\n9Completed 10 0.104831 145 10 10.0 \u2423\n\u21a9! 0.273898 59.771699\n10InProgress 8 0.017899 51 10 8.0 \u2423\n\u21a9! 0.496118 66.999746\n11 Completed 10 0.964542 200 10 10.0 \u2423\n\u21a9! 0.181600 59.159662\n12InProgress 0 0.105599 40 10 - \u2423\n\u21a9! - -\n2trials running, 11finished ( 11until the end), 436.60 s wallclock -time\nINFO:syne_tune .tuner:Trial trial_id 10completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .", "mimetype": "text/plain", "start_char_idx": 1784034, "end_char_idx": 1786059, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0a3378e0-8042-4a79-8c32-9fcd4a609d7f": {"__data__": {"id_": "0a3378e0-8042-4a79-8c32-9fcd4a609d7f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8a70e728-d913-4271-867a-3ba32ba5f3bd", "node_type": "1", "metadata": {}, "hash": "78b68caca20e7b8353529510bc1d504e32a45df5ff1e42726aa1043a98218fcc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0585fee7-2d2c-4630-a9ae-be6659344b91", "node_type": "1", "metadata": {}, "hash": "bc6007c5c62e320c7a3164d415c03a777c54ea5652976e789d394ee483af7e02", "class_name": "RelatedNodeInfo"}}, "text": "0.273898 59.771699\n10InProgress 8 0.017899 51 10 8.0 \u2423\n\u21a9! 0.496118 66.999746\n11 Completed 10 0.964542 200 10 10.0 \u2423\n\u21a9! 0.181600 59.159662\n12InProgress 0 0.105599 40 10 - \u2423\n\u21a9! - -\n2trials running, 11finished ( 11until the end), 436.60 s wallclock -time\nINFO:syne_tune .tuner:Trial trial_id 10completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.5846051207380589 --batch_size 35--max_epochs 10--tune_\n\u21a9!function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-958/\n\u21a9!tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-958/\n\u21a9!13/checkpoints\nINFO:syne_tune .tuner:(trial 13)-scheduled config { 'learning_rate ':0.\n\u21a9!5846051207380589 ,'batch_size ':35,'max_epochs ':10}\nINFO:syne_tune .tuner:Trial trial_id 12completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.2468891379769198 --batch_size 146 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-\n\u21a9!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-958/\n\u21a9!14/checkpoints\nINFO:syne_tune .tuner:(trial 14)-scheduled config { 'learning_rate ':0.\n\u21a9!2468891379769198 ,'batch_size ':146,'max_epochs ':10}\nINFO:syne_tune .tuner:Trial trial_id 13completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n(continues on next page)\n850 Hyperparameter Optimization\n(continued from previous page)\n\u21a9!py--learning_rate 0.12956867470224812 --batch_size 218 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-\n\u21a9!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-958/\n\u21a9!15/checkpoints\nINFO:syne_tune .tuner:(trial 15)-scheduled config { 'learning_rate ':0.\n\u21a9!12956867470224812 ,'batch_size ':218,'max_epochs ':10}\nINFO:syne_tune .tuner:Trial trial_id 14completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .", "mimetype": "text/plain", "start_char_idx": 1785590, "end_char_idx": 1788207, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0585fee7-2d2c-4630-a9ae-be6659344b91": {"__data__": {"id_": "0585fee7-2d2c-4630-a9ae-be6659344b91", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0a3378e0-8042-4a79-8c32-9fcd4a609d7f", "node_type": "1", "metadata": {}, "hash": "5d533423a3313dd587a0d7358805c070cb0b4a106cb48c0e142eb76e0d54818f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b8674ab9-13b1-4abe-b2a8-c99fe6f4ea73", "node_type": "1", "metadata": {}, "hash": "4396c64a9035194e1a9c6c25835d0f127eacf86eb0ff7286672e9da25fe3a6de", "class_name": "RelatedNodeInfo"}}, "text": "\u21a9!12956867470224812 ,'batch_size ':218,'max_epochs ':10}\nINFO:syne_tune .tuner:Trial trial_id 14completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.24900745354561854 --batch_size 103 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-\n\u21a9!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-958/\n\u21a9!16/checkpoints\nINFO:syne_tune .tuner:(trial 16)-scheduled config { 'learning_rate ':0.\n\u21a9!24900745354561854 ,'batch_size ':103,'max_epochs ':10}\nINFO:syne_tune .tuner:Trial trial_id 15completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.03903577426988046 --batch_size 80--max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-\n\u21a9!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-958/\n\u21a9!17/checkpoints\nINFO:syne_tune .tuner:(trial 17)-scheduled config { 'learning_rate ':0.\n\u21a9!03903577426988046 ,'batch_size ':80,'max_epochs ':10}\nINFO:syne_tune .tuner:Trial trial_id 16completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.01846559300690354 --batch_size 183 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-\n\u21a9!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-958/\n\u21a9!18/checkpoints\nINFO:syne_tune .tuner:(trial 18)-scheduled config { 'learning_rate ':0.\n\u21a9!01846559300690354 ,'batch_size ':183,'max_epochs ':10}\nINFO:syne_tune .stopping_criterion:reaching max wallclock time ( 720), stopping \u2423\n\u21a9!there .\nINFO:syne_tune .tuner:Stopping trials that may still be running .\nINFO:syne_tune .tuner:Tuning finished, results of trials can be found on /home /\n\u21a9!ci/syne -tune /python -entrypoint -2023 -08-18-19-45-39-958\n--------------------\nResource summary (last result isreported):\ntrial_id status iter learning_rate batch_size max_epochs epoch \u2423\n\u21a9!validation_error worker -time\n0Completed 10 0.100000 128 10 10 \u2423\n\u21a9! 0.277195 64.928907\n1Completed 10 0.170284 114 10 10 \u2423\n\u21a9! 0.286225 65.434195\n2Completed 10 0.340198 221 10 10 \u2423\n\u21a9! 0.218990 59.729758\n3Completed 10 0.014628 88 10 10 \u2423\n\u21a9!", "mimetype": "text/plain", "start_char_idx": 1787933, "end_char_idx": 1790723, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b8674ab9-13b1-4abe-b2a8-c99fe6f4ea73": {"__data__": {"id_": "b8674ab9-13b1-4abe-b2a8-c99fe6f4ea73", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0585fee7-2d2c-4630-a9ae-be6659344b91", "node_type": "1", "metadata": {}, "hash": "bc6007c5c62e320c7a3164d415c03a777c54ea5652976e789d394ee483af7e02", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "87279993-ca14-4b2b-8e7a-a013724a1b94", "node_type": "1", "metadata": {}, "hash": "8b5acbcdb62201a21dc17ee4e5ec78b794cc1bd6e7e81be00f449d316f904175", "class_name": "RelatedNodeInfo"}}, "text": "0.277195 64.928907\n1Completed 10 0.170284 114 10 10 \u2423\n\u21a9! 0.286225 65.434195\n2Completed 10 0.340198 221 10 10 \u2423\n\u21a9! 0.218990 59.729758\n3Completed 10 0.014628 88 10 10 \u2423\n\u21a9! 0.899920 81.001636\n4Completed 10 0.111483 142 10 10 \u2423\n(continues on next page)\n851 Asynchronous Random Search\n(continued from previous page)\n\u21a9! 0.268684 64.427400\n5Completed 10 0.014076 223 10 10 \u2423\n\u21a9! 0.899922 61.264475\n6Completed 10 0.025582 62 10 10 \u2423\n\u21a9! 0.399520 75.966186\n7Completed 10 0.026036 139 10 10 \u2423\n\u21a9! 0.899988 62.261541\n8Completed 10 0.242025 231 10 10 \u2423\n\u21a9! 0.257636 58.186485\n9Completed 10 0.104831 145 10 10 \u2423\n\u21a9! 0.273898 59.771699\n10 Completed 10 0.017899 51 10 10 \u2423\n\u21a9! 0.405545 83.778503\n11 Completed 10 0.964542 200 10 10 \u2423\n\u21a9! 0.181600 59.159662\n12 Completed 10 0.105599 40 10 10 \u2423\n\u21a9! 0.182500 94.734384\n13 Completed 10 0.584605 35 10 10 \u2423\n\u21a9! 0.153846 110.965637\n14 Completed 10 0.246889 146 10 10 \u2423\n\u21a9! 0.215050 65.142847\n15 Completed 10 0.129569 218 10 10 \u2423\n\u21a9! 0.313873 61.310455\n16 Completed 10 0.249007 103 10 10 \u2423\n\u21a9! 0.196101 72.519127\n17InProgress 9 0.039036 80 10 9 \u2423\n\u21a9! 0.369000 73.403000\n18InProgress 5 0.018466 183 10 5 \u2423\n\u21a9! 0.900263 34.714568\n2trials running, 17finished ( 17until the end), 722.84 s wallclock -time\nvalidation_error: best 0.14451533555984497 for trial -id13\n--------------------\nThe logs of all evaluated hyperparameter configurations are stored for further analysis. At\nany time during the tuning job, we can easily get the results obtained so far and plot the\nincumbent trajectory.\nd2l.set_figsize()\ntuning_experiment =load_experiment(tuner .name)\ntuning_experiment .plot()\nWARNING:matplotlib .legend:No artists with labels found to put inlegend .Note \u2423\n\u21a9!that artists whose label start with an underscore are ignored when legend() \u2423\n\u21a9!iscalled with no argument .\n19.3.3Visualizethe AsynchronousOptimization Process\nBelow we visualize how the learning curves of every trial (each color in the plot represents\na trial) evolve during the asynchronous optimization process. At any point in time, there\nare as many trials running concurrently as we have workers. Once a trial finishes, we\n852 Hyperparameter Optimization\nimmediately start the next trial, without waiting for the other trials to finish. Idle time\nof workers is reduced to a minimum with asynchronous scheduling.", "mimetype": "text/plain", "start_char_idx": 1790554, "end_char_idx": 1792844, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "87279993-ca14-4b2b-8e7a-a013724a1b94": {"__data__": {"id_": "87279993-ca14-4b2b-8e7a-a013724a1b94", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b8674ab9-13b1-4abe-b2a8-c99fe6f4ea73", "node_type": "1", "metadata": {}, "hash": "4396c64a9035194e1a9c6c25835d0f127eacf86eb0ff7286672e9da25fe3a6de", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d1441a6e-252b-4a41-b843-50e0f3bd062f", "node_type": "1", "metadata": {}, "hash": "e544b97b420a23f27ab9d0d932d89ed7323c5525599746914e3dfa51422eaedc", "class_name": "RelatedNodeInfo"}}, "text": "d2l.set_figsize()\ntuning_experiment =load_experiment(tuner .name)\ntuning_experiment .plot()\nWARNING:matplotlib .legend:No artists with labels found to put inlegend .Note \u2423\n\u21a9!that artists whose label start with an underscore are ignored when legend() \u2423\n\u21a9!iscalled with no argument .\n19.3.3Visualizethe AsynchronousOptimization Process\nBelow we visualize how the learning curves of every trial (each color in the plot represents\na trial) evolve during the asynchronous optimization process. At any point in time, there\nare as many trials running concurrently as we have workers. Once a trial finishes, we\n852 Hyperparameter Optimization\nimmediately start the next trial, without waiting for the other trials to finish. Idle time\nof workers is reduced to a minimum with asynchronous scheduling.\nd2l.set_figsize([ 6,2.5])\nresults =tuning_experiment .results\nfor trial_id inresults .trial_id .unique():\ndf=results[results[ \"trial_id \"]==trial_id]\nd2l.plt.plot(\ndf[\"st_tuner_time \"],\ndf[\"validation_error \"],\nmarker =\"o\"\n)\nd2l.plt.xlabel( \"wall-clock time \")\nd2l.plt.ylabel( \"objective function \")\nText( 0,0.5,'objective function ')\n19.3.4Summary\nWecanreducethewaitingtimeforrandomsearchsubstantiallybydistributiontrialsacross\nparallel resources. In general, we distinguish between synchronous scheduling and asyn-\nchronous scheduling. Synchronous scheduling means that we sample a new batch of hy-\nperparameter configurations once the previous batch finished. If we have a stragglers -\ntrials that takes more time to finish than other trials - our workers need to wait at synchro-\nnization points. Asynchronous scheduling evaluates a new hyperparameter configurations\n853 Multi-Fidelity Hyperparameter Optimization\n267\n268\n269\n270\n271as soon as resources become available, and, hence, ensures that all workers are busy at\nany point in time. While random search is easy to distribute asynchronously and does not\nrequire any change of the actual algorithm, other methods require some additional modifi-\ncations.\n19.3.5Exercises\n1.Consider the DropoutMLP model implemented in Section 5.6 , and used in Exercise 1 of\nSection 19.2 .\n1.Implementanobjectivefunction hpo_objective_dropoutmlp_synetune tobeused\nwithSyneTune. Makesurethatyourfunctionreportsthevalidationerrorafterevery\nepoch.\n2.Using the setup of Exercise 1 in Section 19.2 , compare random search to Bayesian\noptimization. If you use SageMaker, feel free to use Syne Tune\u2019s benchmarking\nfacilities in order to run experiments in parallel. Hint: Bayesian optimization is\nprovided as syne_tune.optimizer.baselines.BayesianOptimization .\n3.For this exercise, you need to run on an instance with at least 4 CPU cores. For one\nofthemethodsusedabove(randomsearch,Bayesianoptimization),runexperiments\nwith n_workers=1 ,n_workers=2 ,n_workers=4 , and compare results (incumbent\ntrajectories). At least for random search, you should observe linear scaling with\nrespect to the number of workers. Hint: For robust results, you may have to average\nover several repetitions each.\n2.Advanced . The goal of this exercise is to implement a new scheduler in Syne Tune.\n1.Create a virtual environment containing both the d2lbook267andsyne-tune268\nsources.\n2.Implement the LocalSearcher from Exercise2 in Section 19.2 as a new searcher in\nSyne Tune. Hint: Read this tutorial269. Alternatively, you may follow this example\n270.\n3.Compare your new LocalSearcher with RandomSearch on the DropoutMLP bench-\nmark.\nDiscussions271.\n19.4Multi-Fidelity HyperparameterOptimization\nTraining neural networks can be expensive even on moderate size datasets. Depending\non the configuration space ( Section 19.1.1 ), hyperparameter optimization requires tens to\nhundreds of function evaluations to find a well-performing hyperparameter configuration.\nAswehaveseenin Section19.3 ,wecansignificantlyspeeduptheoverallwall-clocktimeof\n854 Hyperparameter Optimization\nHPObyexploitingparallelresources, butthis does not reducethe total amount ofcompute\nrequired.\nIn this section, we will show how the evaluation of hyperparameter configurations can be\nsped up. Methods such as random search allocate the same amount of resources (e.g.,\nnumber of epochs, training data points) to each hyperparameter evaluation. Fig.", "mimetype": "text/plain", "start_char_idx": 1792053, "end_char_idx": 1796281, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d1441a6e-252b-4a41-b843-50e0f3bd062f": {"__data__": {"id_": "d1441a6e-252b-4a41-b843-50e0f3bd062f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "87279993-ca14-4b2b-8e7a-a013724a1b94", "node_type": "1", "metadata": {}, "hash": "8b5acbcdb62201a21dc17ee4e5ec78b794cc1bd6e7e81be00f449d316f904175", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "052affed-9bad-4a95-9d16-e0320f67c43d", "node_type": "1", "metadata": {}, "hash": "1cd22cb53d0a7602e3b5eb28e05b7a6c7d462444e6ea56df0bd97a049da59686", "class_name": "RelatedNodeInfo"}}, "text": "3.Compare your new LocalSearcher with RandomSearch on the DropoutMLP bench-\nmark.\nDiscussions271.\n19.4Multi-Fidelity HyperparameterOptimization\nTraining neural networks can be expensive even on moderate size datasets. Depending\non the configuration space ( Section 19.1.1 ), hyperparameter optimization requires tens to\nhundreds of function evaluations to find a well-performing hyperparameter configuration.\nAswehaveseenin Section19.3 ,wecansignificantlyspeeduptheoverallwall-clocktimeof\n854 Hyperparameter Optimization\nHPObyexploitingparallelresources, butthis does not reducethe total amount ofcompute\nrequired.\nIn this section, we will show how the evaluation of hyperparameter configurations can be\nsped up. Methods such as random search allocate the same amount of resources (e.g.,\nnumber of epochs, training data points) to each hyperparameter evaluation. Fig. 19.4.1\ndepicts learning curves of a set of neural networks trained with different hyperparameter\nconfigurations. Afterafewepochswearealreadyabletovisuallydistinguishbetweenwell-\nperformingandsuboptimalconfigurations. However, thelearningcurvesarenoisy, andwe\nmightstillrequirethefullamountof100epochstoidentifythebestperformingone.\ntFig. 19.4.1 Learning curves of random hyperparameter con\ufb01gurations\nMulti-fidelityhyperparameteroptimizationallocatesmoreresourcestopromisingconfigu-\nrations and stop evaluations of poorly performing ones early. This speeds up the optimiza-\ntion process, since we can try a larger number of configurations for the same total amount\nof resources.\nMoreformally, weexpandourdefinitionin Section19.1.1 , suchthatourobjectivefunction\n\ud835\udc53\u00b9x,\ud835\udc5f\u00bagets an additional input \ud835\udc5f2\u00bb\ud835\udc5fmin,\ud835\udc5f\ud835\udc5a\ud835\udc4e\ud835\udc65\u00bc, specifying the amount of resources that\nwe are willing to spend for the evaluation of configuration x. We assume that the error\n\ud835\udc53\u00b9x,\ud835\udc5f\u00badecreases with \ud835\udc5f, whereas the computational cost \ud835\udc50\u00b9x,\ud835\udc5f\u00baincreases. Typically, \ud835\udc5f\nrepresents the number of epochs for training the neural network, but it could also be the\ntraining subset size or the number of cross-validation folds.\nfrom collections import defaultdict\nimport numpy asnp\nfrom scipy import stats\nfrom d2l import torch asd2l\n(continues on next page)\n855 Multi-Fidelity Hyperparameter Optimization\n(continued from previous page)\nd2l.set_figsize()\n19.4.1SuccessiveHalving\nOne of the simplest ways to adapt random search to the multi-fidelity setting is successive\nhalving(JamiesonandTalwalkar, 2016 ,Karninetal., 2013). Thebasicideaistostartwith\n\ud835\udc41configurations,forexamplerandomlysampledfromtheconfigurationspace,andtotrain\neachofthemfor \ud835\udc5fminepochsonly. Wethendiscardafractionoftheworstperformingtrials\nand train the remaining ones for longer. Iterating this process, fewer trials run for longer,\nuntil at least one trial reaches \ud835\udc5f\ud835\udc5a\ud835\udc4e\ud835\udc65epochs.\nMore formally, consider a minimum budget \ud835\udc5fmin(for example 1 epoch), a maximum bud-\nget\ud835\udc5f\ud835\udc5a\ud835\udc4e\ud835\udc65, for example max_epochs in our previous example, and a halving constant \ud835\udf022\nf2,3,...g. For simplicity, assume that \ud835\udc5f\ud835\udc5a\ud835\udc4e\ud835\udc65=\ud835\udc5fmin\ud835\udf02\ud835\udc3e, with\ud835\udc3e2I. The number of initial\nconfigurationsisthen \ud835\udc41=\ud835\udf02\ud835\udc3e. Letusdefinethesetofrungs R=f\ud835\udc5fmin,\ud835\udc5fmin\ud835\udf02,\ud835\udc5f min\ud835\udf022,...,\ud835\udc5f\ud835\udc5a\ud835\udc4e\ud835\udc65g.\nOne round of successive halving proceeds as follows. We start with running \ud835\udc41trials un-\ntil the first rung \ud835\udc5fmin. Sorting the validation errors, we keep the top 1\u009d\ud835\udf02fraction (which\namounts to\ud835\udf02\ud835\udc3e\u00001configurations) and discard all the rest. The surviving trials are trained\nforthenextrung( \ud835\udc5fmin\ud835\udf02epochs),andtheprocessisrepeated.", "mimetype": "text/plain", "start_char_idx": 1795414, "end_char_idx": 1798829, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "052affed-9bad-4a95-9d16-e0320f67c43d": {"__data__": {"id_": "052affed-9bad-4a95-9d16-e0320f67c43d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d1441a6e-252b-4a41-b843-50e0f3bd062f", "node_type": "1", "metadata": {}, "hash": "e544b97b420a23f27ab9d0d932d89ed7323c5525599746914e3dfa51422eaedc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "814d44f0-c7d7-46de-8c0d-0cc3f3d7cc3e", "node_type": "1", "metadata": {}, "hash": "87fe78d0817c9d206ab3bb7e7a0228d0376b9f3e6b20529c04f25277f60b578b", "class_name": "RelatedNodeInfo"}}, "text": "The number of initial\nconfigurationsisthen \ud835\udc41=\ud835\udf02\ud835\udc3e. Letusdefinethesetofrungs R=f\ud835\udc5fmin,\ud835\udc5fmin\ud835\udf02,\ud835\udc5f min\ud835\udf022,...,\ud835\udc5f\ud835\udc5a\ud835\udc4e\ud835\udc65g.\nOne round of successive halving proceeds as follows. We start with running \ud835\udc41trials un-\ntil the first rung \ud835\udc5fmin. Sorting the validation errors, we keep the top 1\u009d\ud835\udf02fraction (which\namounts to\ud835\udf02\ud835\udc3e\u00001configurations) and discard all the rest. The surviving trials are trained\nforthenextrung( \ud835\udc5fmin\ud835\udf02epochs),andtheprocessisrepeated. Ateachrung,a 1\u009d\ud835\udf02fractionof\ntrialssurvivesandtheirtrainingcontinueswitha \ud835\udf02timeslargerbudget. Withthisparticular\nchoice of\ud835\udc41, only a single trial will be trained to the full budget \ud835\udc5f\ud835\udc5a\ud835\udc4e\ud835\udc65. Once such a round\nof successive halving is done, we start the next one with a new set of initial configurations,\niterating until the total budget is spent.\ntFig. 19.4.2 Learning curves of random hyperparameter con\ufb01gurations.\n856 Hyperparameter Optimization\nWesubclassthe HPOScheduler baseclassfrom Section19.2 inordertoimplementsucces-\nsive halving, allowing for a generic HPOSearcher object to sample configurations (which,\nin our example below, will be a RandomSearcher ). Additionally, the user has to pass the\nminimum resource \ud835\udc5fmin, the maximum resource \ud835\udc5f\ud835\udc5a\ud835\udc4e\ud835\udc65and\ud835\udf02as input. Inside our scheduler,\nwemaintainaqueueofconfigurationsthatstillneedtobeevaluatedforthecurrentrung \ud835\udc5f\ud835\udc56.\nWe update the queue every time we jump to the next rung.\nclass SuccessiveHalvingScheduler (d2l .HPOScheduler): #@save\ndef __init__ (self , searcher, eta, r_min, r_max, prefact =1):\nself .save_hyperparameters()\n# Compute K, which is later used to determine the number of \u2423\n\u21a9!configurations\nself .K=int(np.log(r_max /r_min) /np.log(eta))\n# Define the rungs\nself .rung_levels =[r_min *eta **kfor kinrange (self .K+1)]\nifr_max not inself .rung_levels:\n# The final rung should be r_max\nself .rung_levels .append(r_max)\nself .K+=1\n# Bookkeeping\nself .observed_error_at_rungs =defaultdict( list )\nself .all_observed_error_at_rungs =defaultdict( list )\n# Our processing queue\nself .queue =[]\nIn the beginning our queue is empty, and we fill it with \ud835\udc5b=prefact\u0001\ud835\udf02\ud835\udc3econfigurations,\nwhich are first evaluated on the smallest rung \ud835\udc5fmin. Here, prefact allows us to reuse our\ncode in a different context. For the purpose of this section, we fix prefact =1. Every time\nresources become available and the HPOTuner object queries the suggest function, we\nreturn an element from the queue. Once we finish one round of successive halving, which\nmeansthatweevaluatedallsurvivingconfigurationsonthehighestresourcelevel \ud835\udc5f\ud835\udc5a\ud835\udc4e\ud835\udc65and\nour queue is empty, we start the entire process again with a new, randomly sampled set of\nconfigurations.\n@d2l .add_to_class(SuccessiveHalvingScheduler) #@save\ndef suggest (self ):\niflen(self .queue) ==0:\n# Start a new round of successive halving\n# Number of configurations for the first rung:\nn0=int(self .prefact *self .eta **self .K)\nfor _inrange (n0):\nconfig =self .searcher .sample_configuration()\nconfig[ \"max_epochs \"]=self .r_min # Set r = r_min\nself .queue .append(config)\n# Return an element from the queue\nreturn self .queue .pop()\nWhen we collected a new data point, we first update the searcher module. Afterwards we\ncheck if we already collect all data points on the current rung. If so, we sort all configura-\ntions and push the top1\n\ud835\udf02configurations into the queue.", "mimetype": "text/plain", "start_char_idx": 1798402, "end_char_idx": 1801675, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "814d44f0-c7d7-46de-8c0d-0cc3f3d7cc3e": {"__data__": {"id_": "814d44f0-c7d7-46de-8c0d-0cc3f3d7cc3e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "052affed-9bad-4a95-9d16-e0320f67c43d", "node_type": "1", "metadata": {}, "hash": "1cd22cb53d0a7602e3b5eb28e05b7a6c7d462444e6ea56df0bd97a049da59686", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "edde0b2f-02da-4b61-b3a1-d348823cf101", "node_type": "1", "metadata": {}, "hash": "e8043a58a1fef0dd733488403a3fb2365bbb4efbb31ed46ac2d881b58d0baa46", "class_name": "RelatedNodeInfo"}}, "text": "@d2l .add_to_class(SuccessiveHalvingScheduler) #@save\ndef suggest (self ):\niflen(self .queue) ==0:\n# Start a new round of successive halving\n# Number of configurations for the first rung:\nn0=int(self .prefact *self .eta **self .K)\nfor _inrange (n0):\nconfig =self .searcher .sample_configuration()\nconfig[ \"max_epochs \"]=self .r_min # Set r = r_min\nself .queue .append(config)\n# Return an element from the queue\nreturn self .queue .pop()\nWhen we collected a new data point, we first update the searcher module. Afterwards we\ncheck if we already collect all data points on the current rung. If so, we sort all configura-\ntions and push the top1\n\ud835\udf02configurations into the queue.\n857 Multi-Fidelity Hyperparameter Optimization\n@d2l .add_to_class(SuccessiveHalvingScheduler) #@save\ndef update (self , config: dict , error: float , info =None ):\nri=int(config[ \"max_epochs \"]) # Rung r_i\n# Update our searcher, e.g if we use Bayesian optimization later\nself .searcher .update(config, error, additional_info =info)\nself .all_observed_error_at_rungs[ri] .append((config, error))\nifri<self .r_max:\n# Bookkeeping\nself .observed_error_at_rungs[ri] .append((config, error))\n# Determine how many configurations should be evaluated on this rung\nki=self .K-self .rung_levels .index(ri)\nni=int(self .prefact *self .eta **ki)\n# If we observed all configuration on this rung r_i, we estimate the\n# top 1 / eta configuration, add them to queue and promote them for\n# the next rung r_{i+1}\niflen(self .observed_error_at_rungs[ri]) >=ni:\nkiplus1 =ki-1\nniplus1 =int(self .prefact *self .eta **kiplus1)\nbest_performing_configurations =self .get_top_n_configurations(\nrung_level =ri, n =niplus1\n)\nriplus1 =self .rung_levels[ self .K-kiplus1] # r_{i+1}\n# Queue may not be empty: insert new entries at the beginning\nself .queue =[\ndict (config, max_epochs =riplus1)\nfor config inbest_performing_configurations\n]+self .queue\nself .observed_error_at_rungs[ri] =[] # Reset\nConfigurationsaresortedbasedontheirobservedperformanceonthecurrentrung.\n@d2l .add_to_class(SuccessiveHalvingScheduler) #@save\ndef get_top_n_configurations (self , rung_level, n):\nrung =self .observed_error_at_rungs[rung_level]\nifnot rung:\nreturn []\nsorted_rung =sorted (rung, key =lambda x: x[ 1])\nreturn [x[0]for xinsorted_rung[:n]]\nLet us see how successive halving is doing on our neural network example. We will use\n\ud835\udc5fmin=2,\ud835\udf02=2,\ud835\udc5f\ud835\udc5a\ud835\udc4e\ud835\udc65=10, so that rung levels are 2,4,8,10.\nmin_number_of_epochs =2\nmax_number_of_epochs =10\neta =2\nnum_gpus =1\nconfig_space ={\n\"learning_rate \": stats .loguniform( 1e-2 ,1),\n\"batch_size \": stats .randint( 32,256),\n}\ninitial_config ={\n\"learning_rate \":0.1,\n(continues on next page)\n858 Hyperparameter Optimization\n(continued from previous page)\n\"batch_size \":128,\n}\nWe just replace the scheduler with our new SuccessiveHalvingScheduler .\nsearcher =d2l.RandomSearcher(config_space, initial_config =initial_config)\nscheduler =SuccessiveHalvingScheduler(\nsearcher =searcher,\neta=eta,\nr_min =min_number_of_epochs,\nr_max =max_number_of_epochs,\n)\ntuner =d2l.HPOTuner(\nscheduler =scheduler,\nobjective =d2l.hpo_objective_lenet,\n)\ntuner .run(number_of_trials =30)\nerror =0.17762434482574463 , runtime =53.576584339141846\nWe can visualize the learning curves of all configurations that we evaluated. Most of the\nconfigurationsarestoppedearlyandonlythebetterperformingconfigurationssurviveuntil\n\ud835\udc5f\ud835\udc5a\ud835\udc4e\ud835\udc65.", "mimetype": "text/plain", "start_char_idx": 1801001, "end_char_idx": 1804363, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "edde0b2f-02da-4b61-b3a1-d348823cf101": {"__data__": {"id_": "edde0b2f-02da-4b61-b3a1-d348823cf101", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "814d44f0-c7d7-46de-8c0d-0cc3f3d7cc3e", "node_type": "1", "metadata": {}, "hash": "87fe78d0817c9d206ab3bb7e7a0228d0376b9f3e6b20529c04f25277f60b578b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "179d8a33-a284-4718-be66-78d7af07c644", "node_type": "1", "metadata": {}, "hash": "40f423fb9ec596440b57fcbcdf37d4d97b528189c6cbc711998254f00bcf10bf", "class_name": "RelatedNodeInfo"}}, "text": "searcher =d2l.RandomSearcher(config_space, initial_config =initial_config)\nscheduler =SuccessiveHalvingScheduler(\nsearcher =searcher,\neta=eta,\nr_min =min_number_of_epochs,\nr_max =max_number_of_epochs,\n)\ntuner =d2l.HPOTuner(\nscheduler =scheduler,\nobjective =d2l.hpo_objective_lenet,\n)\ntuner .run(number_of_trials =30)\nerror =0.17762434482574463 , runtime =53.576584339141846\nWe can visualize the learning curves of all configurations that we evaluated. Most of the\nconfigurationsarestoppedearlyandonlythebetterperformingconfigurationssurviveuntil\n\ud835\udc5f\ud835\udc5a\ud835\udc4e\ud835\udc65. Compare this to vanilla random search, which would allocate \ud835\udc5f\ud835\udc5a\ud835\udc4e\ud835\udc65to every config-\nuration.\n859 19.4 Multi-Fidelity Hyperparameter Optimization\n\n860 Hyperparameter Optimization\n\n861 19.4 Multi-Fidelity Hyperparameter Optimization\n\n862 Hyperparameter Optimization\n\n863 19.4 Multi-Fidelity Hyperparameter Optimization\n\n864 Hyperparameter Optimization\n\n865 19.4 Multi-Fidelity Hyperparameter Optimization\n\n866 Hyperparameter Optimization\n272for rung_index, rung inscheduler .all_observed_error_at_rungs .items():\nerrors =[xi[ 1]for xiinrung]\nd2l.plt.scatter([rung_index] *len(errors), errors)\nd2l.plt.xlim(min_number_of_epochs -0.5, max_number_of_epochs +0.5)\nd2l.plt.xticks(\nnp.arange(min_number_of_epochs, max_number_of_epochs +1),\nnp.arange(min_number_of_epochs, max_number_of_epochs +1)\n)\nd2l.plt.ylabel( \"validation error \")\nd2l.plt.xlabel( \"epochs \")\nText( 0.5,0,'epochs ')\nFinally,notesomeslightcomplexityinourimplementationof SuccessiveHalvingSched-\nuler. Say that a worker is free to run a job, and suggest is called when the current rung\nhasalmostbeencompletelyfilled,butanotherworkerisstillbusywithanevaluation. Since\nwelackthemetricvaluefromthisworker,wecannotdeterminethetop 1\u009d\ud835\udf02fractiontoopen\nup the next rung. On the other hand, we want to assign a job to our free worker, so it does\nnot remain idle. Our solution is to start a new round of successive halving and assign our\nworker to the first trial there. However, once a rung is completed in update, we make sure\nto insert new configurations at the beginning of the queue, so they take precedence over\nconfigurations from the next round.\n19.4.2Summary\nIn this section, we introduced the concept of multi-fidelity hyperparameter optimization,\nwhereweassumetohaveaccesstocheap-to-evaluateapproximationsoftheobjectivefunc-\ntion, such as validation error after a certain number of epochs of training as proxy to val-\nidation error after the full number of epochs. Multi-fidelity hyperparameter optimization\nallowstoreducetheoverallcomputationoftheHPOinsteadofjustreducingthewall-clock\ntime.\nWeimplementedandevaluatedsuccessivehalving,asimpleyetefficientmulti-fidelityHPO\nalgorithm.\nDiscussions272.\n867 Asynchronous Successive Halving\n19.5AsynchronousSuccessiveHalving\nAs we have seen in Section 19.3 , we can accelerate HPO by distributing the evaluation of\nhyperparameter configurations across either multiple instances or multiples CPUs / GPUs\non a single instance. However, compared to random search, it is not straightforward to\nrun successive halving (SH) asynchronously in a distributed setting. Before we can decide\nwhich configuration to run next, we first have to collect all observations at the current rung\nlevel. This requires to synchronize workers at each rung level. For example, for the lowest\nrung level\ud835\udc5fmin, we first have to evaluate all \ud835\udc41=\ud835\udf02\ud835\udc3econfigurations, before we can promote\nthe1\n\ud835\udf02of them to the next rung level.\nIn any distributed system, synchronization typically implies idle time for workers. First,\nwe often observe high variations in training time across hyperparameter configurations.\nFor example, assuming the number of filters per layer is a hyperparameter, then networks\nwith less filters finish training faster than networks with more filters, which implies idle\nworker time due to stragglers. Moreover, the number of slots in a rung level is not always a\nmultiple of the number of workers, in which case some workers may even sit idle for a full\nbatch.\nFigureFig.", "mimetype": "text/plain", "start_char_idx": 1803812, "end_char_idx": 1807820, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "179d8a33-a284-4718-be66-78d7af07c644": {"__data__": {"id_": "179d8a33-a284-4718-be66-78d7af07c644", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "edde0b2f-02da-4b61-b3a1-d348823cf101", "node_type": "1", "metadata": {}, "hash": "e8043a58a1fef0dd733488403a3fb2365bbb4efbb31ed46ac2d881b58d0baa46", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bbebbddc-2ed2-45d0-99a7-0640874e85a2", "node_type": "1", "metadata": {}, "hash": "8b82e5b7e8b2cd0d2e059a32d8e3fb47f273d191a793d82acae26cfa7cc4cf52", "class_name": "RelatedNodeInfo"}}, "text": "This requires to synchronize workers at each rung level. For example, for the lowest\nrung level\ud835\udc5fmin, we first have to evaluate all \ud835\udc41=\ud835\udf02\ud835\udc3econfigurations, before we can promote\nthe1\n\ud835\udf02of them to the next rung level.\nIn any distributed system, synchronization typically implies idle time for workers. First,\nwe often observe high variations in training time across hyperparameter configurations.\nFor example, assuming the number of filters per layer is a hyperparameter, then networks\nwith less filters finish training faster than networks with more filters, which implies idle\nworker time due to stragglers. Moreover, the number of slots in a rung level is not always a\nmultiple of the number of workers, in which case some workers may even sit idle for a full\nbatch.\nFigureFig. 19.5.1 shows the scheduling of synchronous SH with \ud835\udf02=2for four different\ntrials with two workers. We start with evaluating Trial-0 and Trial-1 for one epoch and\nimmediately continue with the next two trials once they are finished. We first have to wait\nuntil Trial-2 finishes, which takes substantially more time than the other trials, before we\ncan promote the best two trials, i.e., Trial-0 and Trial-3 to the next rung level. This causes\nidle time for Worker-1. Then, we continue with Rung 1. Also, here Trial-3 takes longer\nthanTrial-0,whichleadstoanadditionalidelingtimeofWorker-0. Once,wereachRung-2,\nonlythebesttrial,Trial-0,remainswhichoccupiesonlyoneworker. ToavoidthatWorker-1\nidles during that time, most implementaitons of SH continue already with the next round,\nand start evaluating new trials (e.g Trial-4) on the first rung.\nTrial-0\nTrial-1Trial-2\nTrial-3Trial-0\nTrial-3Synchronous Successive Halving\nWorker-0\nWorker-1\nRung 0Trial-0\nRung 1 Rung 2Trial-4\ntFig. 19.5.1 Synchronous successive halving with two workers.\nAsynchronous successive halving (ASHA) ( Lietal., 2018) adapts SH to the asynchronous\nparallel scenario. The main idea of ASHA is to promote configurations to the next rung\nlevelassoonaswecollectedatleast \ud835\udf02observationsonthecurrentrunglevel. Thisdecision\nrule may lead to suboptimal promotions: configurations can be promoted to the next rung\nlevel, which in hindsight do not compare favourably against most others at the same rung\n868 Hyperparameter Optimization\nlevel. Ontheotherhand, wegetridofallsynchronizationpointsthisway. Inpractice,such\nsuboptimalinitialpromotionshaveonlyamodestimpactonperformance,notonlybecause\nthe ranking of hyperparameter configurations is often fairly consistent across rung levels,\nbut also because rungs grow over time and reflect the distribution of metric values at this\nlevel better and better. If a worker is free, but no configuration can be promoted, we start a\nnew configuration with \ud835\udc5f=\ud835\udc5fmin, i.e the first rung level.\nFig. 19.5.2 shows the scheduling of the same configurations for ASHA. Once Trial-1 fin-\nishes, we collect the results of two trials (i.e Trial-0 and Trial-1) and immediately promote\nthe better of them (Trial-0) to the next rung level. After Trial-0 finishes on rung 1, there\nare too few trials there in order to support a further promotion. Hence, we continue with\nrung 0 and evaluate Trial-3. Once Trial-3 finishes, Trial-2 is still pending. At this point we\nhave 3 trials evaluated on rung 0 and one trial evaluated already on rung 1. Since Trial-3\nperforms worse than Trial-0 at rung 0, and \ud835\udf02=2, we cannot promote any new trial yet, and\nWorker-1 starts Trial-4 from scratch instead. However, once Trial-2 finishes and scores\nworse than Trial-3, the latter is promoted towards rung 1. Afterwards, we collected 2 eval-\nuations on rung 1, which means we can now promote Trial-0 towards rung 2. At the same\ntime, Worker-1 continues with evaluating new trials (i.e., Trial-5) on rung 0.", "mimetype": "text/plain", "start_char_idx": 1807047, "end_char_idx": 1810795, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bbebbddc-2ed2-45d0-99a7-0640874e85a2": {"__data__": {"id_": "bbebbddc-2ed2-45d0-99a7-0640874e85a2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "179d8a33-a284-4718-be66-78d7af07c644", "node_type": "1", "metadata": {}, "hash": "40f423fb9ec596440b57fcbcdf37d4d97b528189c6cbc711998254f00bcf10bf", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ac2bffca-da33-49d4-91b7-92596e979138", "node_type": "1", "metadata": {}, "hash": "5d661fadcb3cbe316625d6b128699dde3be0e4c3ab393f86260cb10213dd4d38", "class_name": "RelatedNodeInfo"}}, "text": "Hence, we continue with\nrung 0 and evaluate Trial-3. Once Trial-3 finishes, Trial-2 is still pending. At this point we\nhave 3 trials evaluated on rung 0 and one trial evaluated already on rung 1. Since Trial-3\nperforms worse than Trial-0 at rung 0, and \ud835\udf02=2, we cannot promote any new trial yet, and\nWorker-1 starts Trial-4 from scratch instead. However, once Trial-2 finishes and scores\nworse than Trial-3, the latter is promoted towards rung 1. Afterwards, we collected 2 eval-\nuations on rung 1, which means we can now promote Trial-0 towards rung 2. At the same\ntime, Worker-1 continues with evaluating new trials (i.e., Trial-5) on rung 0.\nTrial-0\nTrial-1Trial-2\nTrial-0 Trial-3Asynchronous Successive Halving\nWorker-0\nWorker-1Trial-3\nTrial-4Trial-0\nPromotion to Rung 1Promotion to Rung 1\nStart new trial on Rung 0Promotion to Rung 2\nTrial-5\nStart new trial on Rung 0\ntFig. 19.5.2 Asynchronous successive halving (ASHA) with two workers.\nimport logging\nfrom d2l import torch asd2l\nlogging .basicConfig(level =logging .INFO)\nimport matplotlib .pyplot asplt\nfrom syne_tune import StoppingCriterion, Tuner\nfrom syne_tune .backend .python_backend import PythonBackend\nfrom syne_tune .config_space import loguniform, randint\nfrom syne_tune .experiments import load_experiment\nfrom syne_tune .optimizer .baselines import ASHA\nINFO:root:SageMakerBackend isnot imported since dependencies are missing .You\u2423\n\u21a9!can install them with\npip install 'syne-tune[extra] '\nAWS dependencies are not imported since dependencies are missing .You can \u2423\n\u21a9!install them with\npip install 'syne-tune[aws] '\nor(for everything)\npip install 'syne-tune[extra] '\n(continues on next page)\n869 Asynchronous Successive Halving\n(continued from previous page)\nAWS dependencies are not imported since dependencies are missing .You can \u2423\n\u21a9!install them with\npip install 'syne-tune[aws] '\nor(for everything)\npip install 'syne-tune[extra] '\nINFO:root:Ray Tune schedulers and searchers are not imported since \u2423\n\u21a9!dependencies are missing .You can install them with\npip install 'syne-tune[raytune] '\nor(for everything)\npip install 'syne-tune[extra] '\n19.5.1ObjectiveFunction\nWe will use Syne Tune with the same objective function as in Section 19.3 .\ndef hpo_objective_lenet_synetune (learning_rate, batch_size, max_epochs):\nfrom syne_tune import Reporter\nfrom d2l import torch asd2l\nmodel =d2l.LeNet(lr =learning_rate, num_classes =10)\ntrainer =d2l.HPOTrainer(max_epochs =1, num_gpus =1)\ndata =d2l.FashionMNIST(batch_size =batch_size)\nmodel .apply_init([ next (iter (data .get_dataloader( True )))[ 0]], d2l .init_cnn)\nreport =Reporter()\nfor epoch inrange (1, max_epochs +1):\nifepoch ==1:\n# Initialize the state of Trainer\ntrainer .fit(model =model, data =data)\nelse :\ntrainer .fit_epoch()\nvalidation_error =trainer .validation_error() .cpu() .detach() .numpy()\nreport(epoch =epoch, validation_error =float (validation_error))\nWe will also use the same configuration space as before:\nmin_number_of_epochs =2\nmax_number_of_epochs =10\neta =2\nconfig_space ={\n\"learning_rate \": loguniform( 1e-2 ,1),\n\"batch_size \": randint( 32,256),\n\"max_epochs \": max_number_of_epochs,\n}\ninitial_config ={\n\"learning_rate \":0.1,\n\"batch_size \":128,\n}\n19.5.2AsynchronousScheduler\n870 Hyperparameter Optimization\nFirst, we define the number of workers that evaluate trials concurrently. We also need to\nspecify how long we want to run random search, by defining an upper limit on the total\nwall-clock time.", "mimetype": "text/plain", "start_char_idx": 1810152, "end_char_idx": 1813597, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ac2bffca-da33-49d4-91b7-92596e979138": {"__data__": {"id_": "ac2bffca-da33-49d4-91b7-92596e979138", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bbebbddc-2ed2-45d0-99a7-0640874e85a2", "node_type": "1", "metadata": {}, "hash": "8b82e5b7e8b2cd0d2e059a32d8e3fb47f273d191a793d82acae26cfa7cc4cf52", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "55754304-bcbe-4e76-9cf2-940fcd16f611", "node_type": "1", "metadata": {}, "hash": "5c8f5b13de04ad0592b616655c32c2b465d1fc43fdd9470c90204d1d31b60579", "class_name": "RelatedNodeInfo"}}, "text": "We also need to\nspecify how long we want to run random search, by defining an upper limit on the total\nwall-clock time.\nn_workers =2# Needs to be <= the number of available GPUs\nmax_wallclock_time =12*60 # 12 minutes\nThecodeforrunningASHAisasimplevariationofwhatwedidforasynchronousrandom\nsearch.\nmode =\"min\"\nmetric =\"validation_error \"\nresource_attr =\"epoch \"\nscheduler =ASHA(\nconfig_space,\nmetric =metric,\nmode =mode,\npoints_to_evaluate =[initial_config],\nmax_resource_attr =\"max_epochs \",\nresource_attr =resource_attr,\ngrace_period =min_number_of_epochs,\nreduction_factor =eta,\n)\nINFO:syne_tune .optimizer .schedulers .fifo:max_resource_level =10,asinferred \u2423\n\u21a9!from config_space\nINFO:syne_tune .optimizer .schedulers .fifo:Master random_seed =3140976097\nHere, metricandresource_attr specify the key names used with the reportcallback,\nandmax_resource_attr denoteswhichinputtotheobjectivefunctioncorrespondsto \ud835\udc5fmax.\nMoreover, grace_period provides\ud835\udc5fmin, and reduction_factor is\ud835\udf02. We can run Syne\nTune as before (this will take about 12 minutes):\ntrial_backend =PythonBackend(\ntune_function =hpo_objective_lenet_synetune,\nconfig_space =config_space,\n)\nstop_criterion =StoppingCriterion(max_wallclock_time =max_wallclock_time)\ntuner =Tuner(\ntrial_backend =trial_backend,\nscheduler =scheduler,\nstop_criterion =stop_criterion,\nn_workers =n_workers,\nprint_update_interval =int(max_wallclock_time *0.6),\n)\ntuner .run()\n871 Asynchronous Successive Halving\nINFO:syne_tune .tuner:results of trials will be saved on /home /ci/syne -tune /\n\u21a9!python -entrypoint -2023 -08-18-20-01-52-046\nINFO:root:Detected 4GPUs\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.1 --batch_size 128 --max_epochs 10--tune_function_root \u2423\n\u21a9!/home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/tune_function --\n\u21a9!tune_function_hash e03d187e043d2a17cae636d6af164015 --st_checkpoint_dir /\n\u21a9!home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/0/checkpoints\nINFO:syne_tune .tuner:(trial 0)-scheduled config { 'learning_rate ':0.1,\n\u21a9!'batch_size ':128,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.44639554136672527 --batch_size 196 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!1/checkpoints\nINFO:syne_tune .tuner:(trial 1)-scheduled config { 'learning_rate ':0.\n\u21a9!44639554136672527 ,'batch_size ':196,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .", "mimetype": "text/plain", "start_char_idx": 1813478, "end_char_idx": 1816484, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "55754304-bcbe-4e76-9cf2-940fcd16f611": {"__data__": {"id_": "55754304-bcbe-4e76-9cf2-940fcd16f611", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ac2bffca-da33-49d4-91b7-92596e979138", "node_type": "1", "metadata": {}, "hash": "5d661fadcb3cbe316625d6b128699dde3be0e4c3ab393f86260cb10213dd4d38", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "116d199e-4d69-4bb0-a0e1-e638c84e0e16", "node_type": "1", "metadata": {}, "hash": "5b75fad08f0e3600c4fe0f7066036be3206eff540e5e7db71f5ed910ef3c319e", "class_name": "RelatedNodeInfo"}}, "text": "\u21a9!44639554136672527 ,'batch_size ':196,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.011548051321691994 --batch_size 254 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!2/checkpoints\nINFO:syne_tune .tuner:(trial 2)-scheduled config { 'learning_rate ':0.\n\u21a9!011548051321691994 ,'batch_size ':254,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.14942487313193167 --batch_size 132 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!3/checkpoints\nINFO:syne_tune .tuner:(trial 3)-scheduled config { 'learning_rate ':0.\n\u21a9!14942487313193167 ,'batch_size ':132,'max_epochs ':10}\nINFO:syne_tune .tuner:Trial trial_id 1completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.06317157191455719 --batch_size 242 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!4/checkpoints\nINFO:syne_tune .tuner:(trial 4)-scheduled config { 'learning_rate ':0.\n\u21a9!06317157191455719 ,'batch_size ':242,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.48801815412811467 --batch_size 41--max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!5/checkpoints\nINFO:syne_tune .tuner:(trial 5)-scheduled config { 'learning_rate ':0.\n(continues on next page)\n872 Hyperparameter Optimization\n(continued from previous page)\n\u21a9!48801815412811467 ,'batch_size ':41,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .", "mimetype": "text/plain", "start_char_idx": 1816261, "end_char_idx": 1819165, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "116d199e-4d69-4bb0-a0e1-e638c84e0e16": {"__data__": {"id_": "116d199e-4d69-4bb0-a0e1-e638c84e0e16", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "55754304-bcbe-4e76-9cf2-940fcd16f611", "node_type": "1", "metadata": {}, "hash": "5c8f5b13de04ad0592b616655c32c2b465d1fc43fdd9470c90204d1d31b60579", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5e3d7301-bc24-414b-a172-8bb1c98ba632", "node_type": "1", "metadata": {}, "hash": "117d9f0e6206ac0da05617eba6350b82ff58e199b5f638b7c35707aff65e76b7", "class_name": "RelatedNodeInfo"}}, "text": "(continues on next page)\n872 Hyperparameter Optimization\n(continued from previous page)\n\u21a9!48801815412811467 ,'batch_size ':41,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.5904067586747807 --batch_size 244 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!6/checkpoints\nINFO:syne_tune .tuner:(trial 6)-scheduled config { 'learning_rate ':0.\n\u21a9!5904067586747807 ,'batch_size ':244,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.08812857364095393 --batch_size 148 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!7/checkpoints\nINFO:syne_tune .tuner:(trial 7)-scheduled config { 'learning_rate ':0.\n\u21a9!08812857364095393 ,'batch_size ':148,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.012271314788363914 --batch_size 235 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!8/checkpoints\nINFO:syne_tune .tuner:(trial 8)-scheduled config { 'learning_rate ':0.\n\u21a9!012271314788363914 ,'batch_size ':235,'max_epochs ':10}\nINFO:syne_tune .tuner:Trial trial_id 5completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.08845692598296777 --batch_size 236 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!9/checkpoints\nINFO:syne_tune .tuner:(trial 9)-scheduled config { 'learning_rate ':0.\n\u21a9!08845692598296777 ,'batch_size ':236,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .", "mimetype": "text/plain", "start_char_idx": 1818855, "end_char_idx": 1821759, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5e3d7301-bc24-414b-a172-8bb1c98ba632": {"__data__": {"id_": "5e3d7301-bc24-414b-a172-8bb1c98ba632", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "116d199e-4d69-4bb0-a0e1-e638c84e0e16", "node_type": "1", "metadata": {}, "hash": "5b75fad08f0e3600c4fe0f7066036be3206eff540e5e7db71f5ed910ef3c319e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ea06dfe6-3024-47a9-b42c-5ffa407255c6", "node_type": "1", "metadata": {}, "hash": "a1d02a37b6939fc11746fddfb2097018952a8a5c2b9eb2c8f4962691e315f61d", "class_name": "RelatedNodeInfo"}}, "text": "\u21a9!08845692598296777 ,'batch_size ':236,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.0825770880068151 --batch_size 75--max_epochs 10--tune_\n\u21a9!function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!10/checkpoints\nINFO:syne_tune .tuner:(trial 10)-scheduled config { 'learning_rate ':0.\n\u21a9!0825770880068151 ,'batch_size ':75,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.20235201406823256 --batch_size 65--max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!11/checkpoints\nINFO:syne_tune .tuner:(trial 11)-scheduled config { 'learning_rate ':0.\n(continues on next page)\n873 Asynchronous Successive Halving\n(continued from previous page)\n\u21a9!20235201406823256 ,'batch_size ':65,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.3359885631737537 --batch_size 58--max_epochs 10--tune_\n\u21a9!function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!12/checkpoints\nINFO:syne_tune .tuner:(trial 12)-scheduled config { 'learning_rate ':0.\n\u21a9!3359885631737537 ,'batch_size ':58,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.7892434579795236 --batch_size 89--max_epochs 10--tune_\n\u21a9!function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!13/checkpoints\nINFO:syne_tune .tuner:(trial 13)-scheduled config { 'learning_rate ':0.\n\u21a9!7892434579795236 ,'batch_size ':89,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .", "mimetype": "text/plain", "start_char_idx": 1821536, "end_char_idx": 1824385, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ea06dfe6-3024-47a9-b42c-5ffa407255c6": {"__data__": {"id_": "ea06dfe6-3024-47a9-b42c-5ffa407255c6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5e3d7301-bc24-414b-a172-8bb1c98ba632", "node_type": "1", "metadata": {}, "hash": "117d9f0e6206ac0da05617eba6350b82ff58e199b5f638b7c35707aff65e76b7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1e06d94e-ea09-4ae9-ba40-4d8dabe22721", "node_type": "1", "metadata": {}, "hash": "47d787f01c1e3f6183aa21c8337ab8689800c0b5c289bcbf7a8ef74a50a8401a", "class_name": "RelatedNodeInfo"}}, "text": "\u21a9!7892434579795236 ,'batch_size ':89,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.1233786579597858 --batch_size 176 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!14/checkpoints\nINFO:syne_tune .tuner:(trial 14)-scheduled config { 'learning_rate ':0.\n\u21a9!1233786579597858 ,'batch_size ':176,'max_epochs ':10}\nINFO:syne_tune .tuner:Trial trial_id 13completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.13707981127012328 --batch_size 141 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!15/checkpoints\nINFO:syne_tune .tuner:(trial 15)-scheduled config { 'learning_rate ':0.\n\u21a9!13707981127012328 ,'batch_size ':141,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.02913976299993913 --batch_size 116 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!16/checkpoints\nINFO:syne_tune .tuner:(trial 16)-scheduled config { 'learning_rate ':0.\n\u21a9!02913976299993913 ,'batch_size ':116,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.033362897489792855 --batch_size 154 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!17/checkpoints\nINFO:syne_tune .tuner:(trial 17)-scheduled config { 'learning_rate ':0.\n(continues on next page)\n874 Hyperparameter Optimization\n(continued from previous page)\n\u21a9!033362897489792855 ,'batch_size ':154,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .", "mimetype": "text/plain", "start_char_idx": 1824164, "end_char_idx": 1827076, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1e06d94e-ea09-4ae9-ba40-4d8dabe22721": {"__data__": {"id_": "1e06d94e-ea09-4ae9-ba40-4d8dabe22721", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ea06dfe6-3024-47a9-b42c-5ffa407255c6", "node_type": "1", "metadata": {}, "hash": "a1d02a37b6939fc11746fddfb2097018952a8a5c2b9eb2c8f4962691e315f61d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a4634d29-0704-4b39-b474-82c80c9f1869", "node_type": "1", "metadata": {}, "hash": "dfd0319f5286dedf404abf42f929f373cf0efbc1e07d07a3043a1d739df8c390", "class_name": "RelatedNodeInfo"}}, "text": "(continues on next page)\n874 Hyperparameter Optimization\n(continued from previous page)\n\u21a9!033362897489792855 ,'batch_size ':154,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.29442952580755816 --batch_size 210 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!18/checkpoints\nINFO:syne_tune .tuner:(trial 18)-scheduled config { 'learning_rate ':0.\n\u21a9!29442952580755816 ,'batch_size ':210,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.10214259921521483 --batch_size 239 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!19/checkpoints\nINFO:syne_tune .tuner:(trial 19)-scheduled config { 'learning_rate ':0.\n\u21a9!10214259921521483 ,'batch_size ':239,'max_epochs ':10}\nINFO:syne_tune .tuner:tuning status (last metric isreported)\ntrial_id status iter learning_rate batch_size max_epochs epoch \u2423\n\u21a9!validation_error worker -time\n0 Stopped 4 0.100000 128 10 4.0 \u2423\n\u21a9! 0.430578 29.093798\n1Completed 10 0.446396 196 10 10.0 \u2423\n\u21a9! 0.205652 72.747496\n2 Stopped 2 0.011548 254 10 2.0 \u2423\n\u21a9! 0.900570 13.729115\n3 Stopped 8 0.149425 132 10 8.0 \u2423\n\u21a9! 0.259171 58.980305\n4 Stopped 4 0.063172 242 10 4.0 \u2423\n\u21a9! 0.900579 27.773950\n5Completed 10 0.488018 41 10 10.0 \u2423\n\u21a9! 0.140488 113.171314\n6 Stopped 10 0.590407 244 10 10.0 \u2423\n\u21a9! 0.193776 70.364757\n7 Stopped 2 0.088129 148 10 2.0 \u2423\n\u21a9! 0.899955 14.169738\n8 Stopped 2 0.012271 235 10 2.0 \u2423\n\u21a9! 0.899840 13.434274\n9 Stopped 2 0.088457 236 10 2.0 \u2423\n\u21a9! 0.899801 13.034437\n10 Stopped 4 0.082577 75 10 4.0 \u2423\n\u21a9! 0.385970 35.426524\n11 Stopped 4 0.202352 65 10 4.0 \u2423\n\u21a9! 0.543102 34.653495\n12 Stopped 10 0.335989 58 10 10.0 \u2423\n\u21a9! 0.149558 90.924182\n13 Completed 10 0.789243 89 10 10.0 \u2423\n\u21a9!", "mimetype": "text/plain", "start_char_idx": 1826764, "end_char_idx": 1829122, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a4634d29-0704-4b39-b474-82c80c9f1869": {"__data__": {"id_": "a4634d29-0704-4b39-b474-82c80c9f1869", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1e06d94e-ea09-4ae9-ba40-4d8dabe22721", "node_type": "1", "metadata": {}, "hash": "47d787f01c1e3f6183aa21c8337ab8689800c0b5c289bcbf7a8ef74a50a8401a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "19a53f73-b11e-46ea-9841-6045e4686021", "node_type": "1", "metadata": {}, "hash": "ea777518a99dc9d75d5d026bbe604a0387e103ca6e105ac7e7090eaf7f62d2d7", "class_name": "RelatedNodeInfo"}}, "text": "0.899840 13.434274\n9 Stopped 2 0.088457 236 10 2.0 \u2423\n\u21a9! 0.899801 13.034437\n10 Stopped 4 0.082577 75 10 4.0 \u2423\n\u21a9! 0.385970 35.426524\n11 Stopped 4 0.202352 65 10 4.0 \u2423\n\u21a9! 0.543102 34.653495\n12 Stopped 10 0.335989 58 10 10.0 \u2423\n\u21a9! 0.149558 90.924182\n13 Completed 10 0.789243 89 10 10.0 \u2423\n\u21a9! 0.144887 77.365970\n14 Stopped 2 0.123379 176 10 2.0 \u2423\n\u21a9! 0.899987 12.422906\n15 Stopped 2 0.137080 141 10 2.0 \u2423\n\u21a9! 0.899983 13.395153\n16 Stopped 4 0.029140 116 10 4.0 \u2423\n(continues on next page)\n875 Asynchronous Successive Halving\n(continued from previous page)\n\u21a9! 0.900532 27.834111\n17 Stopped 2 0.033363 154 10 2.0 \u2423\n\u21a9! 0.899996 13.407285\n18InProgress 1 0.294430 210 10 1.0 \u2423\n\u21a9! 0.899878 6.126259\n19InProgress 0 0.102143 239 10 - \u2423\n\u21a9! - -\n2trials running, 18finished ( 3until the end), 437.07 s wallclock -time\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.02846298236356246 --batch_size 115 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!20/checkpoints\nINFO:syne_tune .tuner:(trial 20)-scheduled config { 'learning_rate ':0.\n\u21a9!02846298236356246 ,'batch_size ':115,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.037703019195187606 --batch_size 91--max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!21/checkpoints\nINFO:syne_tune .tuner:(trial 21)-scheduled config { 'learning_rate ':0.\n\u21a9!037703019195187606 ,'batch_size ':91,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .", "mimetype": "text/plain", "start_char_idx": 1828837, "end_char_idx": 1831075, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "19a53f73-b11e-46ea-9841-6045e4686021": {"__data__": {"id_": "19a53f73-b11e-46ea-9841-6045e4686021", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a4634d29-0704-4b39-b474-82c80c9f1869", "node_type": "1", "metadata": {}, "hash": "dfd0319f5286dedf404abf42f929f373cf0efbc1e07d07a3043a1d739df8c390", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3ee8d4fd-0d8d-4d18-b0dc-5c7bc9409e39", "node_type": "1", "metadata": {}, "hash": "ce173d622d93e2636e57e1f9b63e3dfd4515c6a3e6a3b6e9be5acab980837b56", "class_name": "RelatedNodeInfo"}}, "text": "\u21a9!037703019195187606 ,'batch_size ':91,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.0741039859356903 --batch_size 192 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!22/checkpoints\nINFO:syne_tune .tuner:(trial 22)-scheduled config { 'learning_rate ':0.\n\u21a9!0741039859356903 ,'batch_size ':192,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.3032613031191755 --batch_size 252 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!23/checkpoints\nINFO:syne_tune .tuner:(trial 23)-scheduled config { 'learning_rate ':0.\n\u21a9!3032613031191755 ,'batch_size ':252,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.019823425532533637 --batch_size 252 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!24/checkpoints\nINFO:syne_tune .tuner:(trial 24)-scheduled config { 'learning_rate ':0.\n\u21a9!019823425532533637 ,'batch_size ':252,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n(continues on next page)\n876 Hyperparameter Optimization\n(continued from previous page)\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.8203370335228594 --batch_size 77--max_epochs 10--tune_\n\u21a9!function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!25/checkpoints\nINFO:syne_tune .tuner:(trial 25)-scheduled config { 'learning_rate ':0.\n\u21a9!8203370335228594 ,'batch_size ':77,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .", "mimetype": "text/plain", "start_char_idx": 1830852, "end_char_idx": 1833708, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3ee8d4fd-0d8d-4d18-b0dc-5c7bc9409e39": {"__data__": {"id_": "3ee8d4fd-0d8d-4d18-b0dc-5c7bc9409e39", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "19a53f73-b11e-46ea-9841-6045e4686021", "node_type": "1", "metadata": {}, "hash": "ea777518a99dc9d75d5d026bbe604a0387e103ca6e105ac7e7090eaf7f62d2d7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0031de93-b481-40f7-b3b9-7ab1d6b9b19d", "node_type": "1", "metadata": {}, "hash": "4801141dde0a7cf2486740cf3ebeb639f6cccdaafb6566a951baecb7dece4d6f", "class_name": "RelatedNodeInfo"}}, "text": "\u21a9!8203370335228594 ,'batch_size ':77,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.2960420911378594 --batch_size 104 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!26/checkpoints\nINFO:syne_tune .tuner:(trial 26)-scheduled config { 'learning_rate ':0.\n\u21a9!2960420911378594 ,'batch_size ':104,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.2993874715754653 --batch_size 192 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!27/checkpoints\nINFO:syne_tune .tuner:(trial 27)-scheduled config { 'learning_rate ':0.\n\u21a9!2993874715754653 ,'batch_size ':192,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.08056711961080017 --batch_size 36--max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!28/checkpoints\nINFO:syne_tune .tuner:(trial 28)-scheduled config { 'learning_rate ':0.\n\u21a9!08056711961080017 ,'batch_size ':36,'max_epochs ':10}\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.26868380288030347 --batch_size 151 --max_epochs 10--\n\u21a9!tune_function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-\n\u21a9!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!29/checkpoints\nINFO:syne_tune .tuner:(trial 29)-scheduled config { 'learning_rate ':0.\n\u21a9!26868380288030347 ,'batch_size ':151,'max_epochs ':10}\nINFO:syne_tune .tuner:Trial trial_id 29completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .", "mimetype": "text/plain", "start_char_idx": 1833487, "end_char_idx": 1836304, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0031de93-b481-40f7-b3b9-7ab1d6b9b19d": {"__data__": {"id_": "0031de93-b481-40f7-b3b9-7ab1d6b9b19d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3ee8d4fd-0d8d-4d18-b0dc-5c7bc9409e39", "node_type": "1", "metadata": {}, "hash": "ce173d622d93e2636e57e1f9b63e3dfd4515c6a3e6a3b6e9be5acab980837b56", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1f9cdd27-0a10-4503-bc43-02dd47723cad", "node_type": "1", "metadata": {}, "hash": "88427ecb527eeeffbb312c8edac64bb052610ecc414d3d735ca08a65971b3446", "class_name": "RelatedNodeInfo"}}, "text": "\u21a9!26868380288030347 ,'batch_size ':151,'max_epochs ':10}\nINFO:syne_tune .tuner:Trial trial_id 29completed .\nINFO:root:running subprocess with command: /usr/bin/python /home /ci/.local /lib/\n\u21a9!python3 .8/site -packages /syne_tune /backend /python_backend /python_entrypoint .\n\u21a9!py--learning_rate 0.9197404791177789 --batch_size 66--max_epochs 10--tune_\n\u21a9!function_root /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_\n\u21a9!checkpoint_dir /home /ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046/\n\u21a9!30/checkpoints\nINFO:syne_tune .tuner:(trial 30)-scheduled config { 'learning_rate ':0.\n\u21a9!9197404791177789 ,'batch_size ':66,'max_epochs ':10}\nINFO:syne_tune .stopping_criterion:reaching max wallclock time ( 720), stopping \u2423\n(continues on next page)\n877 Asynchronous Successive Halving\n(continued from previous page)\n\u21a9!there .\nINFO:syne_tune .tuner:Stopping trials that may still be running .\nINFO:syne_tune .tuner:Tuning finished, results of trials can be found on /home /\n\u21a9!ci/syne -tune /python -entrypoint -2023 -08-18-20-01-52-046\n--------------------\nResource summary (last result isreported):\ntrial_id status iter learning_rate batch_size max_epochs epoch \u2423\n\u21a9!validation_error worker -time\n0 Stopped 4 0.100000 128 10 4 \u2423\n\u21a9! 0.430578 29.093798\n1Completed 10 0.446396 196 10 10 \u2423\n\u21a9! 0.205652 72.747496\n2 Stopped 2 0.011548 254 10 2 \u2423\n\u21a9! 0.900570 13.729115\n3 Stopped 8 0.149425 132 10 8 \u2423\n\u21a9! 0.259171 58.980305\n4 Stopped 4 0.063172 242 10 4 \u2423\n\u21a9! 0.900579 27.773950\n5Completed 10 0.488018 41 10 10 \u2423\n\u21a9! 0.140488 113.171314\n6 Stopped 10 0.590407 244 10 10 \u2423\n\u21a9! 0.193776 70.364757\n7 Stopped 2 0.088129 148 10 2 \u2423\n\u21a9! 0.899955 14.169738\n8 Stopped 2 0.012271 235 10 2 \u2423\n\u21a9! 0.899840 13.434274\n9 Stopped 2 0.088457 236 10 2 \u2423\n\u21a9! 0.899801 13.034437\n10 Stopped 4 0.082577 75 10 4 \u2423\n\u21a9! 0.385970 35.426524\n11 Stopped 4 0.202352 65 10 4 \u2423\n\u21a9! 0.543102 34.653495\n12 Stopped 10 0.335989 58 10 10 \u2423\n\u21a9! 0.149558 90.924182\n13 Completed 10 0.789243 89 10 10 \u2423\n\u21a9! 0.144887 77.365970\n14 Stopped 2 0.123379 176 10 2 \u2423\n\u21a9! 0.899987 12.422906\n15 Stopped 2 0.137080 141 10 2 \u2423\n\u21a9! 0.899983 13.395153\n16 Stopped 4 0.029140 116 10 4 \u2423\n\u21a9! 0.900532 27.834111\n17 Stopped 2 0.033363 154 10 2 \u2423\n\u21a9!", "mimetype": "text/plain", "start_char_idx": 1836030, "end_char_idx": 1838295, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1f9cdd27-0a10-4503-bc43-02dd47723cad": {"__data__": {"id_": "1f9cdd27-0a10-4503-bc43-02dd47723cad", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0031de93-b481-40f7-b3b9-7ab1d6b9b19d", "node_type": "1", "metadata": {}, "hash": "4801141dde0a7cf2486740cf3ebeb639f6cccdaafb6566a951baecb7dece4d6f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "738c3606-b3fd-41d1-b6b2-22bd25b1dcc4", "node_type": "1", "metadata": {}, "hash": "7c9fa0d29e569913b5fe6b146e443b00b5125b4f9fe0288ee94f7ce4058b5e6e", "class_name": "RelatedNodeInfo"}}, "text": "0.149558 90.924182\n13 Completed 10 0.789243 89 10 10 \u2423\n\u21a9! 0.144887 77.365970\n14 Stopped 2 0.123379 176 10 2 \u2423\n\u21a9! 0.899987 12.422906\n15 Stopped 2 0.137080 141 10 2 \u2423\n\u21a9! 0.899983 13.395153\n16 Stopped 4 0.029140 116 10 4 \u2423\n\u21a9! 0.900532 27.834111\n17 Stopped 2 0.033363 154 10 2 \u2423\n\u21a9! 0.899996 13.407285\n18 Stopped 8 0.294430 210 10 8 \u2423\n\u21a9! 0.241193 52.089688\n19 Stopped 2 0.102143 239 10 2 \u2423\n\u21a9! 0.900002 12.487762\n20 Stopped 2 0.028463 115 10 2 \u2423\n\u21a9! 0.899995 14.100359\n21 Stopped 2 0.037703 91 10 2 \u2423\n\u21a9! 0.900026 14.664848\n22 Stopped 2 0.074104 192 10 2 \u2423\n\u21a9! 0.901730 13.312770\n23 Stopped 2 0.303261 252 10 2 \u2423\n(continues on next page)\n878 Hyperparameter Optimization\n(continued from previous page)\n\u21a9! 0.900009 12.725821\n24 Stopped 2 0.019823 252 10 2 \u2423\n\u21a9! 0.899917 12.533380\n25 Stopped 10 0.820337 77 10 10 \u2423\n\u21a9! 0.196842 81.816103\n26 Stopped 10 0.296042 104 10 10 \u2423\n\u21a9! 0.198453 81.121330\n27 Stopped 4 0.299387 192 10 4 \u2423\n\u21a9! 0.336183 24.610689\n28InProgress 9 0.080567 36 10 9 \u2423\n\u21a9! 0.203052 104.303746\n29 Completed 10 0.268684 151 10 10 \u2423\n\u21a9! 0.222814 68.217289\n30InProgress 1 0.919740 66 10 1 \u2423\n\u21a9! 0.900037 10.070776\n2trials running, 29finished ( 4until the end), 723.70 s wallclock -time\nvalidation_error: best 0.1404876708984375 for trial -id5\n--------------------\nNote that we are running a variant of ASHA where underperforming trials are stopped\nearly. This is different to our implementation in Section 19.4.1 , where each training job is\nstarted with a fixed max_epochs . In the latter case, a well-performing trial which reaches\nthe full 10 epochs, first needs to train 1, then 2, then 4, then 8 epochs, each time starting\nfromscratch. Thistypeofpause-and-resumeschedulingcanbeimplementedefficientlyby\ncheckpointing the training state after each epoch, but we avoid this extra complexity here.\nAfter the experiment has finished, we can retrieve and plot results.\nd2l.set_figsize()\ne=load_experiment(tuner .name)\ne.plot()\nWARNING:matplotlib .legend:No artists with labels found to put inlegend .Note \u2423\n\u21a9!that artists whose label start with an underscore are ignored when legend() \u2423\n\u21a9!iscalled with no argument .\n19.5.3Visualizethe Optimization Process\n879 Asynchronous Successive Halving\n273Oncemore,wevisualizethelearningcurvesofeverytrial(eachcolorintheplotrepresents\na trial). Compare this to asynchronous random search in Section 19.3 . As we have seen\nfor successive halving in Section 19.4 , most of the trials are stopped at 1 or 2 epochs ( \ud835\udc5fmin\nor\ud835\udf02\u0003\ud835\udc5fmin). However, trials do not stop at the same point, because they require different\namount of time per epoch.", "mimetype": "text/plain", "start_char_idx": 1838018, "end_char_idx": 1840584, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "738c3606-b3fd-41d1-b6b2-22bd25b1dcc4": {"__data__": {"id_": "738c3606-b3fd-41d1-b6b2-22bd25b1dcc4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1f9cdd27-0a10-4503-bc43-02dd47723cad", "node_type": "1", "metadata": {}, "hash": "88427ecb527eeeffbb312c8edac64bb052610ecc414d3d735ca08a65971b3446", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "31cd402e-372b-489e-80aa-160a07fc3d1a", "node_type": "1", "metadata": {}, "hash": "f8b258542d3965b4ef7a4483f182f09ff0702900e2509fe57a01028f14c28ef8", "class_name": "RelatedNodeInfo"}}, "text": "d2l.set_figsize()\ne=load_experiment(tuner .name)\ne.plot()\nWARNING:matplotlib .legend:No artists with labels found to put inlegend .Note \u2423\n\u21a9!that artists whose label start with an underscore are ignored when legend() \u2423\n\u21a9!iscalled with no argument .\n19.5.3Visualizethe Optimization Process\n879 Asynchronous Successive Halving\n273Oncemore,wevisualizethelearningcurvesofeverytrial(eachcolorintheplotrepresents\na trial). Compare this to asynchronous random search in Section 19.3 . As we have seen\nfor successive halving in Section 19.4 , most of the trials are stopped at 1 or 2 epochs ( \ud835\udc5fmin\nor\ud835\udf02\u0003\ud835\udc5fmin). However, trials do not stop at the same point, because they require different\namount of time per epoch. If we ran standard successive halving instead of ASHA, we\nwould need to synchronize our workers, before we can promote configurations to the next\nrung level.\nd2l.set_figsize([ 6,2.5])\nresults =e.results\nfor trial_id inresults .trial_id .unique():\ndf=results[results[ \"trial_id \"]==trial_id]\nd2l.plt.plot(\ndf[\"st_tuner_time \"],\ndf[\"validation_error \"],\nmarker =\"o\"\n)\nd2l.plt.xlabel( \"wall-clock time \")\nd2l.plt.ylabel( \"objective function \")\nText( 0,0.5,'objective function ')\n19.5.4Summary\nCompared to random search, successive halving is not quite as trivial to run in an asyn-\nchronous distributed setting. To avoid synchronisation points, we promote configurations\nas quickly as possible to the next rung level, even if this means promoting some wrong\nones. In practice, this usually does not hurt much, and the gains of asynchronous versus\nsynchronous scheduling are usually much higher than the loss of the suboptimal decision\nmaking.\nDiscussions273.\n20 Generative Adversarial Networks\n20.1GenerativeAdversarialNetworks\nThroughout most of this book, we have talked about how to make predictions. In some\nform or another, we used deep neural networks to learn mappings from data examples to\nlabels. This kind of learning is called discriminative learning, as in, we\u2019d like to be able\nto discriminate between photos of cats and photos of dogs. Classifiers and regressors are\nboth examples of discriminative learning. And neural networks trained by backpropaga-\ntion have upended everything we thought we knew about discriminative learning on large\ncomplicated datasets. Classification accuracies on high-res images have gone from useless\ntohuman-level(withsomecaveats)injust5-6years. Wewillspareyouanotherspielabout\nalltheotherdiscriminativetaskswheredeepneuralnetworksdoastoundinglywell.\nBut there is more to machine learning than just solving discriminative tasks. For example,\ngiven a large dataset, without any labels, we might want to learn a model that concisely\ncaptures the characteristics of this data. Given such a model, we could sample synthetic\ndataexamplesthatresemblethedistributionofthetrainingdata. Forexample,givenalarge\ncorpus of photographs of faces, we might want to be able to generate a new photorealistic\nimage that looks like it might plausibly have come from the same dataset. This kind of\nlearning is called generative modeling.\nUntilrecently,wehadnomethodthatcouldsynthesizenovelphotorealisticimages. Butthe\nsuccess of deep neural networks for discriminative learning opened up new possibilities.\nOne big trend over the last three years has been the application of discriminative deep\nnets to overcome challenges in problems that we do not generally think of as supervised\nlearningproblems. Therecurrentneuralnetworklanguagemodelsareoneexampleofusing\na discriminative network (trained to predict the next character) that once trained can act as\na generative model.\nIn2014,abreakthroughpaperintroducedGenerativeadversarialnetworks(GANs)( Good-\nfellowetal., 2014), a clever new way to leverage the power of discriminative models to get\ngoodgenerativemodels. Attheirheart, GANsrelyontheideathatadatageneratorisgood\nif we cannot tell fake data apart from real data.", "mimetype": "text/plain", "start_char_idx": 1839881, "end_char_idx": 1843777, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "31cd402e-372b-489e-80aa-160a07fc3d1a": {"__data__": {"id_": "31cd402e-372b-489e-80aa-160a07fc3d1a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "738c3606-b3fd-41d1-b6b2-22bd25b1dcc4", "node_type": "1", "metadata": {}, "hash": "7c9fa0d29e569913b5fe6b146e443b00b5125b4f9fe0288ee94f7ce4058b5e6e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2f918556-7c48-438d-b25e-ab9fc4ccd98e", "node_type": "1", "metadata": {}, "hash": "5a9455a9289d375d94c047a5148ef28c6b74b6ba13847d75f94ba2e6ac0cada0", "class_name": "RelatedNodeInfo"}}, "text": "Untilrecently,wehadnomethodthatcouldsynthesizenovelphotorealisticimages. Butthe\nsuccess of deep neural networks for discriminative learning opened up new possibilities.\nOne big trend over the last three years has been the application of discriminative deep\nnets to overcome challenges in problems that we do not generally think of as supervised\nlearningproblems. Therecurrentneuralnetworklanguagemodelsareoneexampleofusing\na discriminative network (trained to predict the next character) that once trained can act as\na generative model.\nIn2014,abreakthroughpaperintroducedGenerativeadversarialnetworks(GANs)( Good-\nfellowetal., 2014), a clever new way to leverage the power of discriminative models to get\ngoodgenerativemodels. Attheirheart, GANsrelyontheideathatadatageneratorisgood\nif we cannot tell fake data apart from real data. In statistics, this is called a two-sample test\n- a test to answer the question whether datasets \ud835\udc4b=f\ud835\udc651,...,\ud835\udc65\ud835\udc5bgand\ud835\udc4b0=f\ud835\udc650\n1,...,\ud835\udc650\n\ud835\udc5bg\nweredrawnfromthesamedistribution. Themaindifferencebetweenmoststatisticspapers\n880\n881 Generative Adversarial Networks\n274and GANs is that the latter use this idea in a constructive way. In other words, rather than\njust training a model to say \u201chey, these two datasets do not look like they came from the\nsame distribution\u201d, they use the two-sample test274to provide training signals to a gener-\native model. This allows us to improve the data generator until it generates something that\nresembles the real data. At the very least, it needs to fool the classifier even if our classifier\nis a state of the art deep neural network.\ntFig. 20.1.1 Generative Adversarial Networks\nThe GAN architecture is illustrated in Fig. 20.1.1 . As you can see, there are two pieces\nin GAN architecture - first off, we need a device (say, a deep network but it really could\nbe anything, such as a game rendering engine) that might potentially be able to generate\ndata that looks just like the real thing. If we are dealing with images, this needs to generate\nimages. If we are dealing with speech, it needs to generate audio sequences, and so on.\nWe call this the generator network. The second component is the discriminator network. It\nattemptstodistinguishfakeandrealdatafromeachother. Bothnetworksareincompetition\nwith each other. The generator network attempts to fool the discriminator network. At that\npoint, the discriminator network adapts to the new fake data. This information, in turn is\nused to improve the generator network, and so on.\nThediscriminatorisabinaryclassifiertodistinguishiftheinput \ud835\udc65isreal(fromrealdata)or\nfake(fromthegenerator). Typically,thediscriminatoroutputsascalarprediction \ud835\udc5c2Rfor\ninputx, such as using a fully connected layer with hidden size 1, and then applies sigmoid\nfunction to obtain the predicted probability \ud835\udc37\u00b9x\u00ba=1\u009d\u00b91\u00b8\ud835\udc52\u0000\ud835\udc5c\u00ba. Assume the label \ud835\udc66\nfor the true data is 1and 0for the fake data. We train the discriminator to minimize the\ncross-entropy loss, i.e.,\nmin\n\ud835\udc37f\u0000\ud835\udc66log\ud835\udc37\u00b9x\u00ba\u0000\u00b9 1\u0000\ud835\udc66\u00balog\u00b91\u0000\ud835\udc37\u00b9x\u00ba\u00bag, (20.1.1)\nFor the generator, it first draws some parameter z2R\ud835\udc51from a source of randomness, e.g.,\na normal distribution z\u0018N\u00b9 0,1\u00ba. We often call zas the latent variable. It then applies\na function to generate x0=\ud835\udc3a\u00b9z\u00ba. The goal of the generator is to fool the discriminator\nto classify x0=\ud835\udc3a\u00b9z\u00baas true data, i.e., we want\ud835\udc37\u00b9\ud835\udc3a\u00b9z\u00ba\u00ba \u0019 1. In other words, for a\ngivendiscriminator \ud835\udc37,weupdatetheparametersofthegenerator \ud835\udc3atomaximizethecross-\nentropy loss when \ud835\udc66=0,i.e.,\nmax\n\ud835\udc3af\u0000\u00b91\u0000\ud835\udc66\u00balog\u00b91\u0000\ud835\udc37\u00b9\ud835\udc3a\u00b9z\u00ba\u00ba\u00bag=max\n\ud835\udc3af\u0000log\u00b91\u0000\ud835\udc37\u00b9\ud835\udc3a\u00b9z\u00ba\u00ba\u00bag.", "mimetype": "text/plain", "start_char_idx": 1842944, "end_char_idx": 1846438, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2f918556-7c48-438d-b25e-ab9fc4ccd98e": {"__data__": {"id_": "2f918556-7c48-438d-b25e-ab9fc4ccd98e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "31cd402e-372b-489e-80aa-160a07fc3d1a", "node_type": "1", "metadata": {}, "hash": "f8b258542d3965b4ef7a4483f182f09ff0702900e2509fe57a01028f14c28ef8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a7b99c9c-8ebd-43e1-877a-df3dd25fd951", "node_type": "1", "metadata": {}, "hash": "a498041f8db40faf6f6f8ddd47fb2af28446fa3122c94d9d815327010b6f3fa9", "class_name": "RelatedNodeInfo"}}, "text": "We often call zas the latent variable. It then applies\na function to generate x0=\ud835\udc3a\u00b9z\u00ba. The goal of the generator is to fool the discriminator\nto classify x0=\ud835\udc3a\u00b9z\u00baas true data, i.e., we want\ud835\udc37\u00b9\ud835\udc3a\u00b9z\u00ba\u00ba \u0019 1. In other words, for a\ngivendiscriminator \ud835\udc37,weupdatetheparametersofthegenerator \ud835\udc3atomaximizethecross-\nentropy loss when \ud835\udc66=0,i.e.,\nmax\n\ud835\udc3af\u0000\u00b91\u0000\ud835\udc66\u00balog\u00b91\u0000\ud835\udc37\u00b9\ud835\udc3a\u00b9z\u00ba\u00ba\u00bag=max\n\ud835\udc3af\u0000log\u00b91\u0000\ud835\udc37\u00b9\ud835\udc3a\u00b9z\u00ba\u00ba\u00bag. (20.1.2)\nIf the generator does a perfect job, then \ud835\udc37\u00b9x0\u00ba \u0019 1, so the above loss is near 0, which\n882 Generative Adversarial Networks\nresults in the gradients that are too small to make good progress for the discriminator. So\ncommonly, we minimize the following loss:\nmin\n\ud835\udc3af\u0000\ud835\udc66log\u00b9\ud835\udc37\u00b9\ud835\udc3a\u00b9z\u00ba\u00ba\u00bag=min\n\ud835\udc3af\u0000log\u00b9\ud835\udc37\u00b9\ud835\udc3a\u00b9z\u00ba\u00ba\u00bag, (20.1.3)\nwhich is just feeding x0=\ud835\udc3a\u00b9z\u00bainto the discriminator but giving label \ud835\udc66=1.\nTo sum up, \ud835\udc37and\ud835\udc3aare playing a \u201cminimax\u201d game with the comprehensive objective\nfunction:\nmin\n\ud835\udc37max\n\ud835\udc3af\u0000\ud835\udc38\ud835\udc65\u0018Datalog\ud835\udc37\u00b9x\u00ba\u0000\ud835\udc38\ud835\udc67\u0018Noise log\u00b91\u0000\ud835\udc37\u00b9\ud835\udc3a\u00b9z\u00ba\u00ba\u00bag. (20.1.4)\nMany of the GANs applications are in the context of images. As a demonstration purpose,\nwe are going to content ourselves with fitting a much simpler distribution first. We will\nillustrate what happens if we use GANs to build the world\u2019s most inefficient estimator of\nparameters for a Gaussian. Let\u2019s get started.\n%matplotlib inline\nimport torch\nfrom torch import nn\nfrom d2l import torch asd2l\n20.1.1GenerateSome \u201cReal\u201dData\nSince this is going to be the world\u2019s lamest example, we simply generate data drawn from\na Gaussian.\nX=torch .normal( 0.0,1, (1000 ,2))\nA=torch .tensor([[ 1,2], [ -0.1,0.5]])\nb=torch .tensor([ 1,2])\ndata =torch .matmul(X, A) +b\nLet\u2019s see what we got. This should be a Gaussian shifted in some rather arbitrary way with\nmean\ud835\udc4fand covariance matrix \ud835\udc34\ud835\udc47\ud835\udc34.\nd2l.set_figsize()\nd2l.plt.scatter(data[: 100, (0)].detach() .numpy(), data[: 100, (1)].detach() .\n\u21a9!numpy());\nprint (f'The covariance matrix is \\n{torch .matmul(A .T,A)}')\nThe covariance matrix is\ntensor([[ 1.0100 ,1.9500 ],\n[1.9500 ,4.2500 ]])\nbatch_size =8\ndata_iter =d2l.load_array((data,), batch_size)\n883 Generative Adversarial Networks\n20.1.2Generator\nOur generator network will be the simplest network possible - a single layer linear model.\nThis is since we will be driving that linear network with a Gaussian data generator. Hence,\nit literally only needs to learn the parameters to fake things perfectly.\nnet_G =nn.Sequential(nn .Linear( 2,2))\n20.1.3Discriminator\nFor the discriminator we will be a bit more discriminating: we will use an MLP with 3\nlayers to make things a bit more interesting.\nnet_D =nn.Sequential(\nnn.Linear( 2,5), nn .Tanh(),\nnn.Linear( 5,3), nn .Tanh(),\nnn.Linear( 3,1))\n20.1.4Training\nFirst we define a function to update the discriminator.\n#@save\ndef update_D (X, Z, net_D, net_G, loss, trainer_D):\n\"\"\"Update discriminator.\"\"\"", "mimetype": "text/plain", "start_char_idx": 1846058, "end_char_idx": 1848819, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a7b99c9c-8ebd-43e1-877a-df3dd25fd951": {"__data__": {"id_": "a7b99c9c-8ebd-43e1-877a-df3dd25fd951", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2f918556-7c48-438d-b25e-ab9fc4ccd98e", "node_type": "1", "metadata": {}, "hash": "5a9455a9289d375d94c047a5148ef28c6b74b6ba13847d75f94ba2e6ac0cada0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cfe051f1-a6a6-45b6-93f0-3d19bd8bf0f7", "node_type": "1", "metadata": {}, "hash": "38e67cc4789bc75c2935dd4978de9c3b4d65ca3ba8a3f948951d6061e8ab860e", "class_name": "RelatedNodeInfo"}}, "text": "This is since we will be driving that linear network with a Gaussian data generator. Hence,\nit literally only needs to learn the parameters to fake things perfectly.\nnet_G =nn.Sequential(nn .Linear( 2,2))\n20.1.3Discriminator\nFor the discriminator we will be a bit more discriminating: we will use an MLP with 3\nlayers to make things a bit more interesting.\nnet_D =nn.Sequential(\nnn.Linear( 2,5), nn .Tanh(),\nnn.Linear( 5,3), nn .Tanh(),\nnn.Linear( 3,1))\n20.1.4Training\nFirst we define a function to update the discriminator.\n#@save\ndef update_D (X, Z, net_D, net_G, loss, trainer_D):\n\"\"\"Update discriminator.\"\"\"\nbatch_size =X.shape[ 0]\nones =torch .ones((batch_size,), device =X.device)\nzeros =torch .zeros((batch_size,), device =X.device)\ntrainer_D .zero_grad()\nreal_Y =net_D(X)\nfake_X =net_G(Z)\n# Do not need to compute gradient for `net_G`, detach it from\n# computing gradients.\nfake_Y =net_D(fake_X .detach())\nloss_D =(loss(real_Y, ones .reshape(real_Y .shape)) +\nloss(fake_Y, zeros .reshape(fake_Y .shape))) /2\nloss_D .backward()\ntrainer_D .step()\nreturn loss_D\n884 Generative Adversarial Networks\nThe generator is updated similarly. Here we reuse the cross-entropy loss but change the\nlabel of the fake data from 0to1.\n#@save\ndef update_G (Z, net_D, net_G, loss, trainer_G):\n\"\"\"Update generator.\"\"\"\nbatch_size =Z.shape[ 0]\nones =torch .ones((batch_size,), device =Z.device)\ntrainer_G .zero_grad()\n# We could reuse `fake_X` from `update_D` to save computation\nfake_X =net_G(Z)\n# Recomputing `fake_Y` is needed since `net_D` is changed\nfake_Y =net_D(fake_X)\nloss_G =loss(fake_Y, ones .reshape(fake_Y .shape))\nloss_G .backward()\ntrainer_G .step()\nreturn loss_G\nBoth the discriminator and the generator performs a binary logistic regression with the\ncross-entropy loss. We use Adam to smooth the training process. In each iteration, we first\nupdate the discriminator and then the generator. We visualize both losses and generated\nexamples.", "mimetype": "text/plain", "start_char_idx": 1848208, "end_char_idx": 1850149, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cfe051f1-a6a6-45b6-93f0-3d19bd8bf0f7": {"__data__": {"id_": "cfe051f1-a6a6-45b6-93f0-3d19bd8bf0f7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a7b99c9c-8ebd-43e1-877a-df3dd25fd951", "node_type": "1", "metadata": {}, "hash": "a498041f8db40faf6f6f8ddd47fb2af28446fa3122c94d9d815327010b6f3fa9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8f4933db-2e33-4ec0-bafd-6f16126e2e66", "node_type": "1", "metadata": {}, "hash": "56e6d4afee3353f38b49cdc8097a1b80e0962bd6ad23b04f3730e56937a737ec", "class_name": "RelatedNodeInfo"}}, "text": "#@save\ndef update_G (Z, net_D, net_G, loss, trainer_G):\n\"\"\"Update generator.\"\"\"\nbatch_size =Z.shape[ 0]\nones =torch .ones((batch_size,), device =Z.device)\ntrainer_G .zero_grad()\n# We could reuse `fake_X` from `update_D` to save computation\nfake_X =net_G(Z)\n# Recomputing `fake_Y` is needed since `net_D` is changed\nfake_Y =net_D(fake_X)\nloss_G =loss(fake_Y, ones .reshape(fake_Y .shape))\nloss_G .backward()\ntrainer_G .step()\nreturn loss_G\nBoth the discriminator and the generator performs a binary logistic regression with the\ncross-entropy loss. We use Adam to smooth the training process. In each iteration, we first\nupdate the discriminator and then the generator. We visualize both losses and generated\nexamples.\ndef train (net_D, net_G, data_iter, num_epochs, lr_D, lr_G, latent_dim, data):\nloss =nn.BCEWithLogitsLoss(reduction ='sum')\nfor winnet_D .parameters():\nnn.init .normal_(w, 0,0.02 )\nfor winnet_G .parameters():\nnn.init .normal_(w, 0,0.02 )\ntrainer_D =torch .optim .Adam(net_D .parameters(), lr =lr_D)\ntrainer_G =torch .optim .Adam(net_G .parameters(), lr =lr_G)\nanimator =d2l.Animator(xlabel ='epoch ', ylabel ='loss ',\nxlim =[1, num_epochs], nrows =2, figsize =(5,5),\nlegend =['discriminator ','generator '])\nanimator .fig.subplots_adjust(hspace =0.3)\nfor epoch inrange (num_epochs):\n# Train one epoch\ntimer =d2l.Timer()\nmetric =d2l.Accumulator( 3)# loss_D, loss_G, num_examples\nfor (X,) indata_iter:\nbatch_size =X.shape[ 0]\nZ=torch .normal( 0,1, size =(batch_size, latent_dim))\nmetric .add(update_D(X, Z, net_D, net_G, loss, trainer_D),\nupdate_G(Z, net_D, net_G, loss, trainer_G),\nbatch_size)\n# Visualize generated examples\nZ=torch .normal( 0,1, size =(100, latent_dim))\nfake_X =net_G(Z) .detach() .numpy()\nanimator .axes[ 1].cla()\nanimator .axes[ 1].scatter(data[:, 0], data[:, 1])\nanimator .axes[ 1].scatter(fake_X[:, 0], fake_X[:, 1])\nanimator .axes[ 1].legend([ 'real ','generated '])\n# Show the losses\nloss_D, loss_G =metric[ 0]/metric[ 2], metric[ 1]/metric[ 2]\n(continues on next page)\n885 Generative Adversarial Networks\n275(continued from previous page)\nanimator .add(epoch +1, (loss_D, loss_G))\nprint (f'loss_D {loss_D :.3f}, loss_G {loss_G :.3f},'\nf'{metric[ 2]/timer .stop() :.1f}examples/sec ')\nNow we specify the hyperparameters to fit the Gaussian distribution.\nlr_D, lr_G, latent_dim, num_epochs =0.05 ,0.005 ,2,20\ntrain(net_D, net_G, data_iter, num_epochs, lr_D, lr_G,\nlatent_dim, data[: 100].detach() .numpy())\nloss_D 0.693 , loss_G 0.693 ,1020.0 examples /sec\n20.1.5Summary\n\u000fGenerative adversarial networks (GANs) composes of two deep networks, the generator\nand the discriminator.\n\u000fThe generator generates the image as much closer to the true image as possible to fool\nthe discriminator, via maximizing the cross-entropy loss, i.e.,max log\u00b9\ud835\udc37\u00b9x0\u00ba\u00ba.\n\u000fThe discriminator tries to distinguish the generated images from the true images, via\nminimizing the cross-entropy loss, i.e.,min\u0000\ud835\udc66log\ud835\udc37\u00b9x\u00ba\u0000\u00b9 1\u0000\ud835\udc66\u00balog\u00b91\u0000\ud835\udc37\u00b9x\u00ba\u00ba.\n20.1.6Exercises\n\u000fDoesanequilibriumexistwherethegeneratorwins, i.e.thediscriminatorendsupunable\nto distinguish the two distributions on finite samples?\nDiscussions275.\n886 Generative Adversarial Networks\n27620.2DeepConvolutionalGenerativeAdversarial\nNetworks\nInSection 20.1 , we introduced the basic ideas behind how GANs work.", "mimetype": "text/plain", "start_char_idx": 1849433, "end_char_idx": 1852703, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8f4933db-2e33-4ec0-bafd-6f16126e2e66": {"__data__": {"id_": "8f4933db-2e33-4ec0-bafd-6f16126e2e66", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cfe051f1-a6a6-45b6-93f0-3d19bd8bf0f7", "node_type": "1", "metadata": {}, "hash": "38e67cc4789bc75c2935dd4978de9c3b4d65ca3ba8a3f948951d6061e8ab860e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "29155992-b3da-4b80-9b9b-ce9b61a402e7", "node_type": "1", "metadata": {}, "hash": "dda07aedc052a3a7d0e9a5893ef891a03215135e61169f59035d66061aa01efe", "class_name": "RelatedNodeInfo"}}, "text": "\u000fThe generator generates the image as much closer to the true image as possible to fool\nthe discriminator, via maximizing the cross-entropy loss, i.e.,max log\u00b9\ud835\udc37\u00b9x0\u00ba\u00ba.\n\u000fThe discriminator tries to distinguish the generated images from the true images, via\nminimizing the cross-entropy loss, i.e.,min\u0000\ud835\udc66log\ud835\udc37\u00b9x\u00ba\u0000\u00b9 1\u0000\ud835\udc66\u00balog\u00b91\u0000\ud835\udc37\u00b9x\u00ba\u00ba.\n20.1.6Exercises\n\u000fDoesanequilibriumexistwherethegeneratorwins, i.e.thediscriminatorendsupunable\nto distinguish the two distributions on finite samples?\nDiscussions275.\n886 Generative Adversarial Networks\n27620.2DeepConvolutionalGenerativeAdversarial\nNetworks\nInSection 20.1 , we introduced the basic ideas behind how GANs work. We showed that\nthey can draw samples from some simple, easy-to-sample distribution, like a uniform or\nnormal distribution, and transform them into samples that appear to match the distribution\nof some dataset. And while our example of matching a 2D Gaussian distribution got the\npoint across, it is not especially exciting.\nIn this section, we will demonstrate how you can use GANs to generate photorealistic im-\nages. WewillbebasingourmodelsonthedeepconvolutionalGANs(DCGAN)introduced\nin Radford et al.(2015). We will borrow the convolutional architecture that have proven\nso successful for discriminative computer vision problems and show how via GANs, they\ncan be leveraged to generate photorealistic images.\nimport warnings\nimport torch\nimport torchvision\nfrom torch import nn\nfrom d2l import torch asd2l\n20.2.1The PokemonDataset\nThe dataset we will use is a collection of Pokemon sprites obtained from pokemondb276.\nFirst download, extract and load this dataset.\n#@save\nd2l.DATA_HUB[ 'pokemon ']=(d2l .DATA_URL +'pokemon.zip ',\n'c065c0e2593b8b161a2d7873e42418bf6a21106c ')\ndata_dir =d2l.download_extract( 'pokemon ')\npokemon =torchvision .datasets .ImageFolder(data_dir)\nDownloading ../data /pokemon .zip from http ://d2l-data .s3-accelerate .amazonaws .\n\u21a9!com/pokemon .zip...\nWe resize each image into 64\u000264. The ToTensor transformation will project the pixel\nvalueinto\u00bb0,1\u00bc,whileourgeneratorwillusethetanhfunctiontoobtainoutputsin \u00bb\u00001,1\u00bc.\nTherefore we normalize the data with 0.5mean and 0.5standard deviation to match the\nvalue range.\nbatch_size =256\ntransformer =torchvision .transforms .Compose([\ntorchvision .transforms .Resize(( 64,64)),\n(continues on next page)\n887 Deep Convolutional Generative Adversarial Networks\n(continued from previous page)\ntorchvision .transforms .ToTensor(),\ntorchvision .transforms .Normalize( 0.5,0.5)\n])\npokemon .transform =transformer\ndata_iter =torch .utils .data .DataLoader(\npokemon, batch_size =batch_size,\nshuffle =True , num_workers =d2l.get_dataloader_workers())\nLet\u2019s visualize the first 20 images.\nwarnings .filterwarnings( 'ignore ')\nd2l.set_figsize(( 4,4))\nfor X, y indata_iter:\nimgs =X[:20,:,:,:] .permute( 0,2,3,1)/2+0.5\nd2l.show_images(imgs, num_rows =4, num_cols =5)\nbreak\n20.2.2The Generator\nThe generator needs to map the noise variable z2R\ud835\udc51, a length-\ud835\udc51vector, to a RGB image\nwithwidthandheighttobe 64\u000264. InSection14.11 weintroducedthefullyconvolutional\nnetworkthatusestransposedconvolutionlayer(referto Section14.10 )toenlargeinputsize.\nThe basic block of the generator contains a transposed convolution layer followed by the\nbatch normalization and ReLU activation.", "mimetype": "text/plain", "start_char_idx": 1852051, "end_char_idx": 1855332, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "29155992-b3da-4b80-9b9b-ce9b61a402e7": {"__data__": {"id_": "29155992-b3da-4b80-9b9b-ce9b61a402e7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8f4933db-2e33-4ec0-bafd-6f16126e2e66", "node_type": "1", "metadata": {}, "hash": "56e6d4afee3353f38b49cdc8097a1b80e0962bd6ad23b04f3730e56937a737ec", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a57ef517-064e-4ce7-aeb6-0c8b2a5e0239", "node_type": "1", "metadata": {}, "hash": "e19fa9005f0d427198dc8697735f100a320c58f192e06e3a55368972cb9ae5bd", "class_name": "RelatedNodeInfo"}}, "text": "warnings .filterwarnings( 'ignore ')\nd2l.set_figsize(( 4,4))\nfor X, y indata_iter:\nimgs =X[:20,:,:,:] .permute( 0,2,3,1)/2+0.5\nd2l.show_images(imgs, num_rows =4, num_cols =5)\nbreak\n20.2.2The Generator\nThe generator needs to map the noise variable z2R\ud835\udc51, a length-\ud835\udc51vector, to a RGB image\nwithwidthandheighttobe 64\u000264. InSection14.11 weintroducedthefullyconvolutional\nnetworkthatusestransposedconvolutionlayer(referto Section14.10 )toenlargeinputsize.\nThe basic block of the generator contains a transposed convolution layer followed by the\nbatch normalization and ReLU activation.\nclass G_block (nn.Module):\ndef __init__ (self , out_channels, in_channels =3, kernel_size =4, strides =2,\npadding =1,**kwargs):\n(continues on next page)\n888 Generative Adversarial Networks\n(continued from previous page)\nsuper (G_block, self ).__init__ (**kwargs)\nself .conv2d_trans =nn.ConvTranspose2d(in_channels, out_channels,\nkernel_size, strides, padding, bias =False )\nself .batch_norm =nn.BatchNorm2d(out_channels)\nself .activation =nn.ReLU()\ndef forward (self , X):\nreturn self .activation( self .batch_norm( self .conv2d_trans(X)))\nIn default, the transposed convolution layer uses a \ud835\udc58\u210e=\ud835\udc58\ud835\udc64=4kernel, a\ud835\udc60\u210e=\ud835\udc60\ud835\udc64=2\nstrides,anda \ud835\udc5d\u210e=\ud835\udc5d\ud835\udc64=1padding. Withainputshapeof \ud835\udc5b0\n\u210e\u0002\ud835\udc5b0\n\ud835\udc64=16\u000216,thegenerator\nblock will double input\u2019s width and height.\n\ud835\udc5b0\n\u210e\u0002\ud835\udc5b0\n\ud835\udc64=\u00bb\u00b9\ud835\udc5b\u210e\ud835\udc58\u210e\u0000\u00b9\ud835\udc5b\u210e\u00001\u00ba\u00b9\ud835\udc58\u210e\u0000\ud835\udc60\u210e\u00ba\u00002\ud835\udc5d\u210e\u00bc\u0002\u00bb\u00b9\ud835\udc5b\ud835\udc64\ud835\udc58\ud835\udc64\u0000\u00b9\ud835\udc5b\ud835\udc64\u00001\u00ba\u00b9\ud835\udc58\ud835\udc64\u0000\ud835\udc60\ud835\udc64\u00ba\u00002\ud835\udc5d\ud835\udc64\u00bc\n=\u00bb\u00b9\ud835\udc58\u210e\u00b8\ud835\udc60\u210e\u00b9\ud835\udc5b\u210e\u00001\u00ba\u00002\ud835\udc5d\u210e\u00bc\u0002\u00bb\u00b9\ud835\udc58\ud835\udc64\u00b8\ud835\udc60\ud835\udc64\u00b9\ud835\udc5b\ud835\udc64\u00001\u00ba\u00002\ud835\udc5d\ud835\udc64\u00bc\n=\u00bb\u00b94\u00b82\u0002\u00b916\u00001\u00ba\u00002\u00021\u00bc\u0002\u00bb\u00b9 4\u00b82\u0002\u00b916\u00001\u00ba\u00002\u00021\u00bc\n=32\u000232.\n(20.2.1)\nx=torch .zeros(( 2,3,16,16))\ng_blk =G_block( 20)\ng_blk(x) .shape\ntorch .Size([ 2,20,32,32])\nIfchangingthetransposedconvolutionlayertoa 4\u00024kernel, 1\u00021stridesandzeropadding.\nWith a input size of 1\u00021, the output will have its width and height increased by 3 respec-\ntively.\nx=torch .zeros(( 2,3,1,1))\ng_blk =G_block( 20, strides =1, padding =0)\ng_blk(x) .shape\ntorch .Size([ 2,20,4,4])\nThegeneratorconsistsoffourbasicblocksthatincreaseinput\u2019sbothwidthandheightfrom\n1 to 32. At the same time, it first projects the latent variable into 64\u00028channels, and then\nhalve the channels each time. At last, a transposed convolution layer is used to generate\nthe output. It further doubles the width and height to match the desired 64\u000264shape,\nand reduces the channel size to 3. The tanh activation function is applied to project output\nvalues into the\u00b9\u00001,1\u00barange.", "mimetype": "text/plain", "start_char_idx": 1854754, "end_char_idx": 1857075, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a57ef517-064e-4ce7-aeb6-0c8b2a5e0239": {"__data__": {"id_": "a57ef517-064e-4ce7-aeb6-0c8b2a5e0239", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "29155992-b3da-4b80-9b9b-ce9b61a402e7", "node_type": "1", "metadata": {}, "hash": "dda07aedc052a3a7d0e9a5893ef891a03215135e61169f59035d66061aa01efe", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4a357617-06d5-4c3c-83df-ee4980264dc1", "node_type": "1", "metadata": {}, "hash": "2eda3bdaf40d18a225d501c88676a5168211b4e2b5a7014e2e15e385fe634fe7", "class_name": "RelatedNodeInfo"}}, "text": "With a input size of 1\u00021, the output will have its width and height increased by 3 respec-\ntively.\nx=torch .zeros(( 2,3,1,1))\ng_blk =G_block( 20, strides =1, padding =0)\ng_blk(x) .shape\ntorch .Size([ 2,20,4,4])\nThegeneratorconsistsoffourbasicblocksthatincreaseinput\u2019sbothwidthandheightfrom\n1 to 32. At the same time, it first projects the latent variable into 64\u00028channels, and then\nhalve the channels each time. At last, a transposed convolution layer is used to generate\nthe output. It further doubles the width and height to match the desired 64\u000264shape,\nand reduces the channel size to 3. The tanh activation function is applied to project output\nvalues into the\u00b9\u00001,1\u00barange.\nn_G =64\nnet_G =nn.Sequential(\n(continues on next page)\n889 Deep Convolutional Generative Adversarial Networks\n(continued from previous page)\nG_block(in_channels =100, out_channels =n_G*8,\nstrides =1, padding =0), # Output: (64 * 8, 4, 4)\nG_block(in_channels =n_G*8, out_channels =n_G*4),# Output: (64 * 4, 8, 8)\nG_block(in_channels =n_G*4, out_channels =n_G*2),# Output: (64 * 2, 16, 16)\nG_block(in_channels =n_G*2, out_channels =n_G), # Output: (64, 32, 32)\nnn.ConvTranspose2d(in_channels =n_G, out_channels =3,\nkernel_size =4, stride =2, padding =1, bias =False ),\nnn.Tanh()) # Output: (3, 64, 64)\nGenerate a 100 dimensional latent variable to verify the generator\u2019s output shape.\nx=torch .zeros(( 1,100,1,1))\nnet_G(x) .shape\ntorch .Size([ 1,3,64,64])\n20.2.3Discriminator\nThe discriminator is a normal convolutional network network except that it uses a leaky\nReLU as its activation function. Given \ud835\udefc2\u00bb0,1\u00bc, its definition is\nleaky ReLU\u00b9\ud835\udc65\u00ba=(\n\ud835\udc65if\ud835\udc65 >0\n\ud835\udefc\ud835\udc65otherwise. (20.2.2)\nAs it can be seen, it is normal ReLU if \ud835\udefc=0, and an identity function if \ud835\udefc=1. For\n\ud835\udefc2\u00b90,1\u00ba, leaky ReLU is a nonlinear function that give a non-zero output for a negative\ninput. Itaimstofixthe\u201cdyingReLU\u201dproblemthataneuronmightalwaysoutputanegative\nvalue and therefore cannot make any progress since the gradient of ReLU is 0.\nalphas =[0,.2,.4,.6,.8,1]\nx=torch .arange( -2,1,0.1)\nY=[nn.LeakyReLU(alpha)(x) .detach() .numpy() for alpha inalphas]\nd2l.plot(x .detach() .numpy(), Y, 'x','y', alphas)\nThebasicblockofthediscriminatorisaconvolutionlayerfollowedbyabatchnormalization\nlayerandaleakyReLUactivation. Thehyperparametersoftheconvolutionlayeraresimilar\nto the transpose convolution layer in the generator block.\n890 Generative Adversarial Networks\nclass D_block (nn.Module):\ndef __init__ (self , out_channels, in_channels =3, kernel_size =4, strides =2,\npadding =1, alpha =0.2,**kwargs):\nsuper (D_block, self ).__init__ (**kwargs)\nself .conv2d =nn.Conv2d(in_channels, out_channels, kernel_size,\nstrides, padding, bias =False )\nself .batch_norm =nn.BatchNorm2d(out_channels)\nself .activation =nn.LeakyReLU(alpha, inplace =True )\ndef forward (self , X):\nreturn self .activation( self .batch_norm( self .conv2d(X)))\nA basic block with default settings will halve the width and height of the inputs, as we\ndemonstratedin Section7.3 .", "mimetype": "text/plain", "start_char_idx": 1856397, "end_char_idx": 1859379, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4a357617-06d5-4c3c-83df-ee4980264dc1": {"__data__": {"id_": "4a357617-06d5-4c3c-83df-ee4980264dc1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a57ef517-064e-4ce7-aeb6-0c8b2a5e0239", "node_type": "1", "metadata": {}, "hash": "e19fa9005f0d427198dc8697735f100a320c58f192e06e3a55368972cb9ae5bd", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cb2e7194-1a33-4487-9872-5da78a79d5d1", "node_type": "1", "metadata": {}, "hash": "72724c3fedb94b598439b951ac7675f21e0e9a8ae8ee3760f92f1e063e1999f5", "class_name": "RelatedNodeInfo"}}, "text": "Thehyperparametersoftheconvolutionlayeraresimilar\nto the transpose convolution layer in the generator block.\n890 Generative Adversarial Networks\nclass D_block (nn.Module):\ndef __init__ (self , out_channels, in_channels =3, kernel_size =4, strides =2,\npadding =1, alpha =0.2,**kwargs):\nsuper (D_block, self ).__init__ (**kwargs)\nself .conv2d =nn.Conv2d(in_channels, out_channels, kernel_size,\nstrides, padding, bias =False )\nself .batch_norm =nn.BatchNorm2d(out_channels)\nself .activation =nn.LeakyReLU(alpha, inplace =True )\ndef forward (self , X):\nreturn self .activation( self .batch_norm( self .conv2d(X)))\nA basic block with default settings will halve the width and height of the inputs, as we\ndemonstratedin Section7.3 . Forexample,givenainputshape \ud835\udc5b\u210e=\ud835\udc5b\ud835\udc64=16,withakernel\nshape\ud835\udc58\u210e=\ud835\udc58\ud835\udc64=4, a stride shape \ud835\udc60\u210e=\ud835\udc60\ud835\udc64=2, and a padding shape \ud835\udc5d\u210e=\ud835\udc5d\ud835\udc64=1, the\noutput shape will be:\n\ud835\udc5b0\n\u210e\u0002\ud835\udc5b0\n\ud835\udc64=b\u00b9\ud835\udc5b\u210e\u0000\ud835\udc58\u210e\u00b82\ud835\udc5d\u210e\u00b8\ud835\udc60\u210e\u00ba\u009d\ud835\udc60\u210ec\u0002b\u00b9\ud835\udc5b\ud835\udc64\u0000\ud835\udc58\ud835\udc64\u00b82\ud835\udc5d\ud835\udc64\u00b8\ud835\udc60\ud835\udc64\u00ba\u009d\ud835\udc60\ud835\udc64c\n=b\u00b916\u00004\u00b82\u00021\u00b82\u00ba\u009d2c\u0002b\u00b9 16\u00004\u00b82\u00021\u00b82\u00ba\u009d2c\n=8\u00028.(20.2.3)\nx=torch .zeros(( 2,3,16,16))\nd_blk =D_block( 20)\nd_blk(x) .shape\ntorch .Size([ 2,20,8,8])\nThe discriminator is a mirror of the generator.\nn_D =64\nnet_D =nn.Sequential(\nD_block(n_D), # Output: (64, 32, 32)\nD_block(in_channels =n_D, out_channels =n_D*2), # Output: (64 * 2, 16, 16)\nD_block(in_channels =n_D*2, out_channels =n_D*4), # Output: (64 * 4, 8, 8)\nD_block(in_channels =n_D*4, out_channels =n_D*8), # Output: (64 * 8, 4, 4)\nnn.Conv2d(in_channels =n_D*8, out_channels =1,\nkernel_size =4, bias =False )) # Output: (1, 1, 1)\nItusesaconvolutionlayerwithoutputchannel 1asthelastlayertoobtainasingleprediction\nvalue.\nx=torch .zeros(( 1,3,64,64))\nnet_D(x) .shape\ntorch .Size([ 1,1,1,1])\n20.2.4Training\n891 Deep Convolutional Generative Adversarial Networks\nCompared to the basic GAN in Section 20.1 , we use the same learning rate for both gen-\nerator and discriminator since they are similar to each other. In addition, we change \ud835\udefd1in\nAdam (Section 12.10 ) from 0.9to0.5. It decreases the smoothness of the momentum, the\nexponentiallyweightedmovingaverageofpastgradients,totakecareoftherapidchanging\ngradients because the generator and the discriminator fight with each other. Besides, the\nrandom generated noise Z, is a 4-D tensor and we are using GPU to accelerate the compu-\ntation.", "mimetype": "text/plain", "start_char_idx": 1858653, "end_char_idx": 1860907, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cb2e7194-1a33-4487-9872-5da78a79d5d1": {"__data__": {"id_": "cb2e7194-1a33-4487-9872-5da78a79d5d1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4a357617-06d5-4c3c-83df-ee4980264dc1", "node_type": "1", "metadata": {}, "hash": "2eda3bdaf40d18a225d501c88676a5168211b4e2b5a7014e2e15e385fe634fe7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2184b767-f43e-47f1-a833-febe4e6bf134", "node_type": "1", "metadata": {}, "hash": "958102fae5df58c408917d74c4eb5ab415e0b164693640b839440fd0421ac74d", "class_name": "RelatedNodeInfo"}}, "text": "x=torch .zeros(( 1,3,64,64))\nnet_D(x) .shape\ntorch .Size([ 1,1,1,1])\n20.2.4Training\n891 Deep Convolutional Generative Adversarial Networks\nCompared to the basic GAN in Section 20.1 , we use the same learning rate for both gen-\nerator and discriminator since they are similar to each other. In addition, we change \ud835\udefd1in\nAdam (Section 12.10 ) from 0.9to0.5. It decreases the smoothness of the momentum, the\nexponentiallyweightedmovingaverageofpastgradients,totakecareoftherapidchanging\ngradients because the generator and the discriminator fight with each other. Besides, the\nrandom generated noise Z, is a 4-D tensor and we are using GPU to accelerate the compu-\ntation.\ndef train (net_D, net_G, data_iter, num_epochs, lr, latent_dim,\ndevice =d2l.try_gpu()):\nloss =nn.BCEWithLogitsLoss(reduction ='sum')\nfor winnet_D .parameters():\nnn.init .normal_(w, 0,0.02 )\nfor winnet_G .parameters():\nnn.init .normal_(w, 0,0.02 )\nnet_D, net_G =net_D .to(device), net_G .to(device)\ntrainer_hp ={'lr': lr, 'betas ': [0.5,0.999 ]}\ntrainer_D =torch .optim .Adam(net_D .parameters(), **trainer_hp)\ntrainer_G =torch .optim .Adam(net_G .parameters(), **trainer_hp)\nanimator =d2l.Animator(xlabel ='epoch ', ylabel ='loss ',\nxlim =[1, num_epochs], nrows =2, figsize =(5,5),\nlegend =['discriminator ','generator '])\nanimator .fig.subplots_adjust(hspace =0.3)\nfor epoch inrange (1, num_epochs +1):\n# Train one epoch\ntimer =d2l.Timer()\nmetric =d2l.Accumulator( 3)# loss_D, loss_G, num_examples\nfor X, _ indata_iter:\nbatch_size =X.shape[ 0]\nZ=torch .normal( 0,1, size =(batch_size, latent_dim, 1,1))\nX, Z =X.to(device), Z .to(device)\nmetric .add(d2l .update_D(X, Z, net_D, net_G, loss, trainer_D),\nd2l.update_G(Z, net_D, net_G, loss, trainer_G),\nbatch_size)\n# Show generated examples\nZ=torch .normal( 0,1, size =(21, latent_dim, 1,1), device =device)\n# Normalize the synthetic data to N(0, 1)\nfake_x =net_G(Z) .permute( 0,2,3,1)/2+0.5\nimgs =torch .cat(\n[torch .cat([\nfake_x[i *7+j].cpu() .detach() for jinrange (7)], dim =1)\nfor iinrange (len(fake_x) //7)], dim =0)\nanimator .axes[ 1].cla()\nanimator .axes[ 1].imshow(imgs)\n# Show the losses\nloss_D, loss_G =metric[ 0]/metric[ 2], metric[ 1]/metric[ 2]\nanimator .add(epoch, (loss_D, loss_G))\nprint (f'loss_D {loss_D :.3f}, loss_G {loss_G :.3f},'\nf'{metric[ 2]/timer .stop() :.1f}examples/sec on {str(device) }')\nWe train the model with a small number of epochs just for demonstration. For better per-\nformance, the variable num_epochs can be set to a larger number.\n892 Generative Adversarial Networks\n277latent_dim, lr, num_epochs =100,0.005 ,20\ntrain(net_D, net_G, data_iter, num_epochs, lr, latent_dim)\nloss_D 0.023 , loss_G 7.359 ,2292.7 examples /sec on cuda: 0\n20.2.5Summary\n\u000fDCGANarchitecturehasfourconvolutionallayersfortheDiscriminatorandfour\u201cfractionally-\nstrided\u201d convolutional layers for the Generator.\n\u000fThe Discriminator is a 4-layer strided convolutions with batch normalization (except its\ninput layer) and leaky ReLU activations.\n\u000fLeaky ReLU is a nonlinear function that give a non-zero output for a negative input. It\naims to fix the \u201cdying ReLU\u201d problem and helps the gradients flow easier through the\narchitecture.", "mimetype": "text/plain", "start_char_idx": 1860239, "end_char_idx": 1863394, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2184b767-f43e-47f1-a833-febe4e6bf134": {"__data__": {"id_": "2184b767-f43e-47f1-a833-febe4e6bf134", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cb2e7194-1a33-4487-9872-5da78a79d5d1", "node_type": "1", "metadata": {}, "hash": "72724c3fedb94b598439b951ac7675f21e0e9a8ae8ee3760f92f1e063e1999f5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8332ea64-2f88-481d-b28c-bb63331070c1", "node_type": "1", "metadata": {}, "hash": "693e0f01eb870b8aca47a7f3e4e4ebded814f04ab7d3adfcdda4d9624862e29b", "class_name": "RelatedNodeInfo"}}, "text": "For better per-\nformance, the variable num_epochs can be set to a larger number.\n892 Generative Adversarial Networks\n277latent_dim, lr, num_epochs =100,0.005 ,20\ntrain(net_D, net_G, data_iter, num_epochs, lr, latent_dim)\nloss_D 0.023 , loss_G 7.359 ,2292.7 examples /sec on cuda: 0\n20.2.5Summary\n\u000fDCGANarchitecturehasfourconvolutionallayersfortheDiscriminatorandfour\u201cfractionally-\nstrided\u201d convolutional layers for the Generator.\n\u000fThe Discriminator is a 4-layer strided convolutions with batch normalization (except its\ninput layer) and leaky ReLU activations.\n\u000fLeaky ReLU is a nonlinear function that give a non-zero output for a negative input. It\naims to fix the \u201cdying ReLU\u201d problem and helps the gradients flow easier through the\narchitecture.\n20.2.6Exercises\n1.What will happen if we use standard ReLU activation rather than leaky ReLU?\n2.ApplyDCGANonFashion-MNISTandseewhichcategoryworkswellandwhichdoes\nnot.\nDiscussions277.\n21 Recommender Systems\nShuaiZhang (Amazon),AstonZhang (Amazon), andYiTay(Google)\nRecommender systems are widely employed in industry and are ubiquitous in our daily\nlives. These systems are utilized in a number of areas such as online shopping sites (e.g.,\namazon.com), music/movie services site (e.g., Netflix and Spotify), mobile application\nstores (e.g., IOS app store and google play), online advertising, just to name a few.\nThe major goal of recommender systems is to help users discover relevant items such as\nmoviestowatch,texttoreadorproductstobuy,soastocreateadelightfuluserexperience.\nMoreover, recommender systems are among the most powerful machine learning systems\nthat online retailers implement in order to drive incremental revenue. Recommender sys-\ntems are replacements of search engines by reducing the efforts in proactive searches and\nsurprising users with offers they never searched for. Many companies managed to position\nthemselves ahead of their competitors with the help of more effective recommender sys-\ntems. As such, recommender systems are central to not only our everyday lives but also\nhighly indispensable in some industries.\nInthischapter,wewillcoverthefundamentalsandadvancementsofrecommendersystems,\nalongwithexploringsomecommonfundamentaltechniquesforbuildingrecommendersys-\ntemswith differentdata sources availableand theirimplementations. Specifically, youwill\nlearn how to predict the rating a user might give to a prospective item, how to generate a\nrecommendation list of items and how to predict the click-through rate from abundant fea-\ntures. These tasks are commonplace in real-world applications. By studying this chapter,\nyou will get hands-on experience pertaining to solving real world recommendation prob-\nlems with not only classical methods but the more advanced deep learning based models\nas well.\n21.1Overviewof RecommenderSystems\nIn the last decade, the Internet has evolved into a platform for large-scale online services,\nwhich profoundly changed the way we communicate, read news, buy products, and watch\nmovies. Inthemeanwhile,theunprecedentednumberofitems(weusetheterm itemtorefer\nto movies, news, books, and products.) offered online requires a system that can help us\ndiscoveritemsthatwepreferred. Recommendersystemsarethereforepowerfulinformation\n893\n894 Recommender Systems\nfiltering tools that can facilitate personalized services and provide tailored experience to\nindividual users. In short, recommender systems play a pivotal role in utilizing the wealth\nof data available to make choices manageable. Nowadays, recommender systems are at\nthe core of a number of online services providers such as Amazon, Netflix, and YouTube.\nRecall the example of Deep learning books recommended by Amazon in Fig. 1.3.3 . The\nbenefits of employing recommender systems are two-folds: On the one hand, it can largely\nreduce users\u2019 effort in finding items and alleviate the issue of information overload. On\nthe other hand, it can add business value to online service providers and is an important\nsource of revenue. This chapter will introduce the fundamental concepts, classic models\nand recent advanceswith deep learning in the field of recommender systems, togetherwith\nimplemented examples.\ntFig.", "mimetype": "text/plain", "start_char_idx": 1862646, "end_char_idx": 1866831, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8332ea64-2f88-481d-b28c-bb63331070c1": {"__data__": {"id_": "8332ea64-2f88-481d-b28c-bb63331070c1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2184b767-f43e-47f1-a833-febe4e6bf134", "node_type": "1", "metadata": {}, "hash": "958102fae5df58c408917d74c4eb5ab415e0b164693640b839440fd0421ac74d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b6441abf-d574-4d5e-9c3a-adc3042d5e65", "node_type": "1", "metadata": {}, "hash": "3726486133fae6db6179c8cf3f7fc2a775c1f3d7724cd8a627bb64858838a52c", "class_name": "RelatedNodeInfo"}}, "text": "In short, recommender systems play a pivotal role in utilizing the wealth\nof data available to make choices manageable. Nowadays, recommender systems are at\nthe core of a number of online services providers such as Amazon, Netflix, and YouTube.\nRecall the example of Deep learning books recommended by Amazon in Fig. 1.3.3 . The\nbenefits of employing recommender systems are two-folds: On the one hand, it can largely\nreduce users\u2019 effort in finding items and alleviate the issue of information overload. On\nthe other hand, it can add business value to online service providers and is an important\nsource of revenue. This chapter will introduce the fundamental concepts, classic models\nand recent advanceswith deep learning in the field of recommender systems, togetherwith\nimplemented examples.\ntFig. 21.1.1 Illustration of the Recommendation Process\n21.1.1CollaborativeFiltering\nWe start the journey with the important concept in recommender systems\u2014collaborative\nfiltering (CF), which was first coined by the Tapestry system ( Goldberg et al., 1992), re-\nferring to \u201cpeople collaborate to help one another perform the filtering process in order to\nhandlethelargeamountsofemailandmessagespostedtonewsgroups\u201d. Thistermhasbeen\nenriched with more senses. In a broad sense, it is the process of filtering for information or\npatterns using techniques involving collaboration among multiple users, agents, and data\nsources. CF has many forms and numerous CF methods proposed since its advent.\nOverall, CF techniques can be categorized into: memory-based CF, model-based CF, and\ntheir hybrid ( Su and Khoshgoftaar, 2009 ). Representative memory-based CF techniques\nare nearest neighbor-based CF such as user-based CF and item-based CF ( Sarwaret al.,\n2001). Latent factor models such as matrix factorization are examples of model-based CF.\nMemory-based CF has limitations in dealing with sparse and large-scale data since it com-\nputes the similarity values based on common items. Model-based methods become more\npopular with its better capability in dealing with sparsity and scalability. Many model-\nbased CF approaches can be extended with neural networks, leading to more flexible and\nscalable models with the computation acceleration in deep learning ( Zhanget al., 2019).\nIn general, CF only uses the user-item interaction data to make predictions and recom-\nmendations. Besides CF, content-based and context-based recommender systems are also\nuseful in incorporating the content descriptions of items/users and contextual signals such\n895 Overview of Recommender Systems\n278as timestamps and locations. Obviously, we may need to adjust the model types/structures\nwhen different input data is available.\n21.1.2ExplicitFeedbackand ImplicitFeedback\nTolearnthepreferenceofusers,thesystemshallcollectfeedbackfromthem. Thefeedback\ncan be either explicit or implicit ( Huet al., 2008). For example, IMDb278collects star\nratings ranging from one to ten stars for movies. YouTube provides the thumbs-up and\nthumbs-down buttons for users to show their preferences. It is apparent that gathering\nexplicitfeedbackrequiresusersto indicate theirinterestsproactively. Nonetheless, explicit\nfeedback is not always readily available as many users may be reluctant to rate products.\nRelativelyspeaking,implicitfeedbackisoftenreadilyavailablesinceitismainlyconcerned\nwith modeling implicit behavior such as user clicks. As such, many recommender systems\narecenteredonimplicitfeedbackwhichindirectlyreflectsuser\u2019sopinionthroughobserving\nuser behavior. There are diverse forms of implicit feedback including purchase history,\nbrowsing history, watches and even mouse movements. For example, a user that purchased\nmany books by the same author probably likes that author. Note that implicit feedback is\ninherently noisy. We can only guesstheir preferences and true motives. A user watched a\nmovie does not necessarily indicate a positive view of that movie.\n21.1.3RecommendationTasks\nA number of recommendation tasks have been investigated in the past decades. Based\non the domain of applications, there are movies recommendation, news recommendations,\npoint-of-interest recommendation ( Yeet al., 2011) and so forth. It is also possible to dif-\nferentiate the tasks based on the types of feedback and input data, for example, the rating\nprediction task aims to predict the explicit ratings. Top- \ud835\udc5brecommendation (item ranking)\nranksallitemsforeachuserpersonallybasedontheimplicitfeedback. Iftime-stampinfor-\nmation is also included, we can build sequence-aware recommendation ( Quadrana et al.,\n2018).", "mimetype": "text/plain", "start_char_idx": 1866030, "end_char_idx": 1870612, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b6441abf-d574-4d5e-9c3a-adc3042d5e65": {"__data__": {"id_": "b6441abf-d574-4d5e-9c3a-adc3042d5e65", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8332ea64-2f88-481d-b28c-bb63331070c1", "node_type": "1", "metadata": {}, "hash": "693e0f01eb870b8aca47a7f3e4e4ebded814f04ab7d3adfcdda4d9624862e29b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "dfb4e10a-4700-4940-ba7c-ba2be17b0770", "node_type": "1", "metadata": {}, "hash": "194ea0783f77b29462d7620febc2a92d8e2967cf1e8318aa8913afcf2c332e16", "class_name": "RelatedNodeInfo"}}, "text": "Note that implicit feedback is\ninherently noisy. We can only guesstheir preferences and true motives. A user watched a\nmovie does not necessarily indicate a positive view of that movie.\n21.1.3RecommendationTasks\nA number of recommendation tasks have been investigated in the past decades. Based\non the domain of applications, there are movies recommendation, news recommendations,\npoint-of-interest recommendation ( Yeet al., 2011) and so forth. It is also possible to dif-\nferentiate the tasks based on the types of feedback and input data, for example, the rating\nprediction task aims to predict the explicit ratings. Top- \ud835\udc5brecommendation (item ranking)\nranksallitemsforeachuserpersonallybasedontheimplicitfeedback. Iftime-stampinfor-\nmation is also included, we can build sequence-aware recommendation ( Quadrana et al.,\n2018). Another popular task is called click-through rate prediction, which is also based on\nimplicit feedback, but various categorical features can be utilized. Recommending for new\nusers and recommending new items to existing users are called cold-start recommendation\n(Scheinetal., 2002).\n21.1.4Summary\n\u000fRecommender systems are important for individual users and industries. Collaborative\nfiltering is a key concept in recommendation.\n\u000fThere are two types of feedbacks: implicit feedback and explicit feedback. A number of\nrecommendation tasks have been explored during the last decade.\n21.1.5Exercises\n1.Can you explain how recommender systems influence your daily life?\n2.What interesting recommendation tasks do you think can be investigated?\n896 Recommender Systems\n279Discussions279.\nAMathematics for Deep\nLearning\nBrentWerness (Amazon),RachelHu (Amazon), and authors of this book\nOne of the wonderful parts of modern deep learning is the fact that much of it can be\nunderstood and used without a full understanding of the mathematics below it. This is a\nsign that the field is maturing. Just as most software developers no longer need to worry\nabout the theory of computable functions, neither should deep learning practitioners need\nto worry about the theoretical foundations of maximum likelihood learning.\nBut, we are not quite there yet.\nIn practice, you will sometimes need to understand how architectural choices influence\ngradientflow,ortheimplicitassumptionsyoumakebytrainingwithacertainlossfunction.\nYou might need to know what in the world entropy measures, and how it can help you\nunderstand exactly what bits-per-character means in your model. These all require deeper\nmathematical understanding.\nThis appendix aims to provide you the mathematical background you need to understand\nthe core theory of modern deep learning, but it is not exhaustive. We will begin with\nexamininglinearalgebraingreaterdepth. Wedevelopageometricunderstandingofallthe\ncommon linear algebraic objects and operations that will enable us to visualize the effects\nof various transformations on our data. A key element is the development of the basics of\neigen-decompositions.\nWenextdevelopthetheoryofdifferentialcalculustothepointthatwecanfullyunderstand\nwhy the gradient is the direction of steepest descent, and why back-propagation takes the\nform it does. Integral calculus is then discussed to the degree needed to support our next\ntopic, probability theory.\nProblemsencounteredinpracticefrequentlyarenotcertain,andthusweneedalanguageto\nspeakaboutuncertainthings. Wereviewthetheoryofrandomvariablesandthemostcom-\nmonlyencountereddistributionssowemaydiscussmodelsprobabilistically. Thisprovides\nthefoundationforthenaiveBayesclassifier,aprobabilisticclassificationtechnique.\nClosely related to probability theory is the study of statistics. While statistics is far too\nlargeafield todo justiceina shortsection, wewillintroduce fundamentalconcepts thatall\nmachinelearningpractitionersshouldbeawareof,inparticular: evaluatingandcomparing\nestimators, conducting hypothesis tests, and constructing confidence intervals.\nLast, we turn to the topic of information theory, which is the mathematical study of infor-\n897\n898 Mathematics for Deep Learning\nmationstorageandtransmission. Thisprovidesthecorelanguagebywhichwemaydiscuss\nquantitatively how much information a model holds on a domain of discourse.\nTakentogether,theseformthecoreofthemathematicalconceptsneededtobegindownthe\npath towards a deep understanding of deep learning.\nA.1Geometryand Linear AlgebraicOperations\nInSection 2.3 , we encountered the basics of linear algebra and saw how it could be used\nto express common operations for transforming our data.", "mimetype": "text/plain", "start_char_idx": 1869782, "end_char_idx": 1874316, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dfb4e10a-4700-4940-ba7c-ba2be17b0770": {"__data__": {"id_": "dfb4e10a-4700-4940-ba7c-ba2be17b0770", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b6441abf-d574-4d5e-9c3a-adc3042d5e65", "node_type": "1", "metadata": {}, "hash": "3726486133fae6db6179c8cf3f7fc2a775c1f3d7724cd8a627bb64858838a52c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ff30c03e-8e04-4adb-b67a-152e29242a6c", "node_type": "1", "metadata": {}, "hash": "ff612911efea21c2c54fd51c45229ab0245185602e114d3292228b226ccbbe02", "class_name": "RelatedNodeInfo"}}, "text": "While statistics is far too\nlargeafield todo justiceina shortsection, wewillintroduce fundamentalconcepts thatall\nmachinelearningpractitionersshouldbeawareof,inparticular: evaluatingandcomparing\nestimators, conducting hypothesis tests, and constructing confidence intervals.\nLast, we turn to the topic of information theory, which is the mathematical study of infor-\n897\n898 Mathematics for Deep Learning\nmationstorageandtransmission. Thisprovidesthecorelanguagebywhichwemaydiscuss\nquantitatively how much information a model holds on a domain of discourse.\nTakentogether,theseformthecoreofthemathematicalconceptsneededtobegindownthe\npath towards a deep understanding of deep learning.\nA.1Geometryand Linear AlgebraicOperations\nInSection 2.3 , we encountered the basics of linear algebra and saw how it could be used\nto express common operations for transforming our data. Linear algebra is one of the key\nmathematical pillars underlying much of the work that we do in deep learning and in ma-\nchine learning more broadly. While Section 2.3 contained enough machinery to commu-\nnicate the mechanics of modern deep learning models, there is a lot more to the subject.\nIn this section, we will go deeper, highlighting some geometric interpretations of linear\nalgebra operations, and introducing a few fundamental concepts, including of eigenvalues\nand eigenvectors.\nA.1.1Geometryof Vectors\nFirst, we need to discuss the two common geometric interpretations of vectors, as either\npoints or directions in space. Fundamentally, a vector is a list of numbers such as the\nPython list below.\nv=[1,7,0,1]\nMathematiciansmostoftenwritethisaseithera columnorrowvector,whichistosayeither\nas\nx=266666641\n7\n0\n137777775, (A.1)\nor\nx>=\u0002\n1 7 0 1\u0003\n. (A.2)\nThese often have different interpretations, where data examples are column vectors and\nweights used to form weighted sums are row vectors. However, it can be beneficial to be\nflexible. Aswehavedescribedin Section2.3 ,thoughasinglevector\u2019sdefaultorientationis\na column vector, for any matrix representing a tabular dataset, treating each data example\nas a row vector in the matrix is more conventional.\nGiven a vector, the first interpretation that we should give it is as a point in space. In two\nor three dimensions, we can visualize these points by using the components of the vectors\n899 Geometry and Linear Algebraic Operations\nto define the location of the points in space compared to a fixed reference called the origin.\nThis can be seen in Fig. A.1.\ntFig. A.1 An illustration of visualizing vectors as points in the plane. The \ufb01rst component of the\nvector gives the x-coordinate, the second component gives the y-coordinate. Higher\ndimensions are analogous, although much harder to visualize.\nThisgeometricpointofviewallowsustoconsidertheproblemonamoreabstractlevel. No\nlongerfacedwithsomeinsurmountableseemingproblemlikeclassifyingpicturesaseither\ncats or dogs, we can start considering tasks abstractly as collections of points in space and\npicturing the task as discovering how to separate two distinct clusters of points.\nIn parallel, there is a second point of view that people often take of vectors: as directions\nin space. Not onlycan we think of the vector v=\u00bb3,2\u00bc>as the location 3units to the right\nand2units up from the origin, we can also think of it as the direction itself to take 3steps\nto the right and 2steps up. In this way, we consider all the vectors in figure Fig. A.2 the\nsame.\ntFig. A.2 Any vector can be visualized as an arrow in the plane. In this case, every vector drawn is a\nrepresentation of the vector \u00b93,2\u00ba>.\nOneofthebenefitsofthisshiftisthatwecanmakevisualsenseoftheactofvectoraddition.\nIn particular, we follow the directions given by one vector, and then follow the directions\ngiven by the other, as is seen in Fig. A.3.\nVector subtraction has a similar interpretation. By considering the identity that u=v\u00b8\n\u00b9u\u0000v\u00ba, we see that the vector u\u0000vis the direction that takes us from the point vto the\npointu.\nA.1.2DotProductsand Angles\n900 Mathematics for Deep Learning\ntFig. A.3 We can visualize vector addition by \ufb01rst following one vector, and then another.", "mimetype": "text/plain", "start_char_idx": 1873444, "end_char_idx": 1877575, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ff30c03e-8e04-4adb-b67a-152e29242a6c": {"__data__": {"id_": "ff30c03e-8e04-4adb-b67a-152e29242a6c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "dfb4e10a-4700-4940-ba7c-ba2be17b0770", "node_type": "1", "metadata": {}, "hash": "194ea0783f77b29462d7620febc2a92d8e2967cf1e8318aa8913afcf2c332e16", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6fd9564b-551c-4d8f-952c-d1d4fd208214", "node_type": "1", "metadata": {}, "hash": "2c6fc41186e74f0195f2bc6178a710c37e617430b8c52024a068de3b80b2121d", "class_name": "RelatedNodeInfo"}}, "text": "A.2 the\nsame.\ntFig. A.2 Any vector can be visualized as an arrow in the plane. In this case, every vector drawn is a\nrepresentation of the vector \u00b93,2\u00ba>.\nOneofthebenefitsofthisshiftisthatwecanmakevisualsenseoftheactofvectoraddition.\nIn particular, we follow the directions given by one vector, and then follow the directions\ngiven by the other, as is seen in Fig. A.3.\nVector subtraction has a similar interpretation. By considering the identity that u=v\u00b8\n\u00b9u\u0000v\u00ba, we see that the vector u\u0000vis the direction that takes us from the point vto the\npointu.\nA.1.2DotProductsand Angles\n900 Mathematics for Deep Learning\ntFig. A.3 We can visualize vector addition by \ufb01rst following one vector, and then another.\nAs we saw in Section 2.3 , if we take two column vectors uandv, we can form their dot\nproduct by computing:\nu>v=\u00d5\n\ud835\udc56\ud835\udc62\ud835\udc56\u0001\ud835\udc63\ud835\udc56.(A.3)\nBecause (A.3)is symmetric, we will mirror the notation of classical multiplication and\nwrite\nu\u0001v=u>v=v>u, (A.4)\ntohighlightthefactthatexchangingtheorderofthevectorswillyieldthesameanswer.\nThe dot product (A.3)also admits a geometric interpretation: it is closely related to the\nangle between two vectors. Consider the angle shown in Fig. A.4.\ntFig. A.4 Between any two vectors in the plane there is a well de\ufb01ned angle \ud835\udf03. We will see this\nangle is intimately tied to the dot product.\nTo start, let\u2019s consider two specific vectors:\nv=\u00b9\ud835\udc5f,0\u00baandw=\u00b9\ud835\udc60cos\u00b9\ud835\udf03\u00ba,\ud835\udc60sin\u00b9\ud835\udf03\u00ba\u00ba. (A.5)\nThe vector vis length\ud835\udc5fand runs parallel to the \ud835\udc65-axis, and the vector wis of length \ud835\udc60\nand at angle \ud835\udf03with the\ud835\udc65-axis. If we compute the dot product of these two vectors, we see\nthat\nv\u0001w=\ud835\udc5f\ud835\udc60cos\u00b9\ud835\udf03\u00ba=kvkkwkcos\u00b9\ud835\udf03\u00ba. (A.6)\nWith some simple algebraic manipulation, we can rearrange terms to obtain\n\ud835\udf03=arccos\u0012v\u0001w\nkvkkwk\u0013\n. (A.7)\n901 Geometry and Linear Algebraic Operations\nIn short, for these two specific vectors, the dot product combined with the norms tell us\nthe angle between the two vectors. This same fact is true in general. We will not derive\nthe expression here, however, if we consider writing kv\u0000wk2in two ways: one with\nthe dot product, and the other geometrically using the law of cosines, we can obtain the\nfull relationship. Indeed, for any two vectors vandw, the angle between the two vectors\nis\n\ud835\udf03=arccos\u0012v\u0001w\nkvkkwk\u0013\n. (A.8)\nThis is a nice result since nothing in the computation references two-dimensions. Indeed,\nwe can use this in three or three million dimensions without issue.\nAs a simple example, let\u2019s see how to compute the angle between a pair of vectors:\n%matplotlib inline\nimport torch\nimport torchvision\nfrom IPython import display\nfrom torchvision import transforms\nfrom d2l import torch asd2l\ndef angle (v, w):\nreturn torch .acos(v .dot(w) /(torch .norm(v) *torch .norm(w)))\nangle(torch .tensor([ 0,1,2], dtype =torch .float32), torch .tensor([ 2.0,3,4]))\ntensor( 0.4190 )\nWe will not use it right now, but it is useful to know that we will refer to vectors for which\nthe angle is \ud835\udf0b\u009d2(or equivalently 90\u000e) as being orthogonal . By examining the equation\nabove, we see that this happens when \ud835\udf03=\ud835\udf0b\u009d2, which is the same thing as cos\u00b9\ud835\udf03\u00ba=0. The\nonly way this can happen is if the dot product itself is zero, and two vectors are orthogonal\nifandonlyif v\u0001w=0. Thiswillprovetobeahelpfulformulawhenunderstandingobjects\ngeometrically.\nIt is reasonable to ask: why is computing the angle useful? The answer comes in the kind\nof invariance we expect data to have.", "mimetype": "text/plain", "start_char_idx": 1876873, "end_char_idx": 1880241, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6fd9564b-551c-4d8f-952c-d1d4fd208214": {"__data__": {"id_": "6fd9564b-551c-4d8f-952c-d1d4fd208214", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ff30c03e-8e04-4adb-b67a-152e29242a6c", "node_type": "1", "metadata": {}, "hash": "ff612911efea21c2c54fd51c45229ab0245185602e114d3292228b226ccbbe02", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "06bcccdc-bb7d-4f35-ad87-e46d77d8eba0", "node_type": "1", "metadata": {}, "hash": "6191da0b6ab0dcaeb27ff476a3c333bf6ca55a302b64d2c3ce62e341f46282a3", "class_name": "RelatedNodeInfo"}}, "text": "By examining the equation\nabove, we see that this happens when \ud835\udf03=\ud835\udf0b\u009d2, which is the same thing as cos\u00b9\ud835\udf03\u00ba=0. The\nonly way this can happen is if the dot product itself is zero, and two vectors are orthogonal\nifandonlyif v\u0001w=0. Thiswillprovetobeahelpfulformulawhenunderstandingobjects\ngeometrically.\nIt is reasonable to ask: why is computing the angle useful? The answer comes in the kind\nof invariance we expect data to have. Consider an image, and a duplicate image, where\nevery pixel value is the same but 10%the brightness. The values of the individual pixels\nare in general far from the original values. Thus, if one computed the distance between\nthe original image and the darker one, the distance can be large. However, for most ML\napplications,the contentisthesame\u2014itisstillanimageofacatasfarasacat/dogclassifier\nis concerned. However, if we consider the angle, it is not hard to see that for any vector v,\nthe angle between vand0.1\u0001vis zero. This corresponds to the fact that scaling vectors\nkeepsthesamedirectionandjustchangesthelength. Theangleconsidersthedarkerimage\nidentical.\nExamples like this are everywhere. In text, we might want the topic being discussed to\nnot change if we write twice as long of document that says the same thing. For some\n902 Mathematics for Deep Learning\nencoding (such as counting the number of occurrences of words in some vocabulary), this\ncorresponds to a doubling of the vector encoding the document, so again we can use the\nangle.\nCosine Similarity\nIn ML contextswhere the angle is employed to measure the closeness of twovectors, prac-\ntitioners adopt the term cosinesimilarity to refer to the portion\ncos\u00b9\ud835\udf03\u00ba=v\u0001w\nkvkkwk. (A.9)\nThe cosine takes a maximum value of 1when the two vectors point in the same direction,\na minimum value of \u00001when they point in opposite directions, and a value of 0when the\ntwo vectors are orthogonal. Note that if the components of high-dimensional vectors are\nsampled randomly with mean 0, their cosine will nearly always be close to 0.\nA.1.3Hyperplanes\nIn addition to working with vectors, another key object that you must understand to go far\nin linear algebra is the hyperplane , a generalization to higher dimensions of a line (two di-\nmensions)orofaplane(threedimensions). Inan \ud835\udc51-dimensionalvectorspace,ahyperplane\nhas\ud835\udc51\u00001dimensions and divides the space into two half-spaces.\nLet\u2019s start with an example. Suppose that we have a column vector w=\u00bb2,1\u00bc>. We want\nto know, \u201cwhat are the points vwithw\u0001v=1?\u201d By recalling the connection between dot\nproducts and angles above (A.8), we can see that this is equivalent to\nkvkkwkcos\u00b9\ud835\udf03\u00ba=1() k vkcos\u00b9\ud835\udf03\u00ba=1\nkwk=1p\n5. (A.10)\ntFig. A.5 Recalling trigonometry, we see the formula kvkcos\u00b9\ud835\udf03\u00bais the length of the projection of\nthe vector vonto the direction of w\nIf we consider the geometric meaning of this expression, we see that this is equivalent to\nsaying that the length of the projection of vonto the direction of wis exactly 1\u009dkwk, as\nis shown in Fig. A.5. The set of all points where this is true is a line at right angles to the\nvectorw. If we wanted, we could find the equation for this line and see that it is 2\ud835\udc65\u00b8\ud835\udc66=1\nor equivalently \ud835\udc66=1\u00002\ud835\udc65.\n903 Geometry and Linear Algebraic Operations\nIf we now look at what happens when we ask about the set of points with w\u0001v>1or\nw\u0001v<1, we can see that these are cases where the projections are longer or shorter than\n1\u009dkwk, respectively. Thus, thosetwoinequalitiesdefineeithersideoftheline. Inthisway,\nwe have found a way to cut our space into two halves, where all the points on one side have\ndot product below a threshold, and the other side above as we see in Fig. A.6.\ntFig.", "mimetype": "text/plain", "start_char_idx": 1879819, "end_char_idx": 1883453, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "06bcccdc-bb7d-4f35-ad87-e46d77d8eba0": {"__data__": {"id_": "06bcccdc-bb7d-4f35-ad87-e46d77d8eba0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6fd9564b-551c-4d8f-952c-d1d4fd208214", "node_type": "1", "metadata": {}, "hash": "2c6fc41186e74f0195f2bc6178a710c37e617430b8c52024a068de3b80b2121d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "eb31aadb-e3da-4c00-8eb3-fa3591317426", "node_type": "1", "metadata": {}, "hash": "96bf390896002d7186927c9333e0db47085a23d75c6878864aea6f3b1426cf3d", "class_name": "RelatedNodeInfo"}}, "text": "The set of all points where this is true is a line at right angles to the\nvectorw. If we wanted, we could find the equation for this line and see that it is 2\ud835\udc65\u00b8\ud835\udc66=1\nor equivalently \ud835\udc66=1\u00002\ud835\udc65.\n903 Geometry and Linear Algebraic Operations\nIf we now look at what happens when we ask about the set of points with w\u0001v>1or\nw\u0001v<1, we can see that these are cases where the projections are longer or shorter than\n1\u009dkwk, respectively. Thus, thosetwoinequalitiesdefineeithersideoftheline. Inthisway,\nwe have found a way to cut our space into two halves, where all the points on one side have\ndot product below a threshold, and the other side above as we see in Fig. A.6.\ntFig. A.6 If we now consider the inequality version of the expression, we see that our hyperplane (in\nthis case: just a line) separates the space into two halves.\nThe story in higher dimension is much the same. If we now take w=\u00bb1,2,3\u00bc>and ask\naboutthepointsinthreedimensionswith w\u0001v=1, weobtainaplane atrightanglestothe\ngiven vector w. The two inequalities again define the two sides of the plane as is shown in\nFig. A.7.\ntFig. A.7 Hyperplanes in any dimension separate the space into two halves.\nWhile our ability to visualize runs out at this point, nothing stops us from doing this in\ntens, hundreds, or billions of dimensions. This occurs often when thinking about machine\nlearned models. For instance, we can understand linear classification models like those\nfromSection 4.1 , as methods to find hyperplanes that separate the different target classes.\nIn this context, such hyperplanes are often referred to as decision planes . The majority of\ndeep learned classification models end with a linear layer fed into a softmax, so one can\ninterpret the role of the deep neural network to be to find a non-linear embedding such that\nthe target classes can be separated cleanly by hyperplanes.\nTo give a hand-built example, notice that we can produce a reasonable model to classify\ntiny images of t-shirts and trousers from the Fashion-MNIST dataset (seen in Section 4.2 )\nby just taking the vector between their means to define the decision plane and eyeball a\ncrude threshold. First we will load the data and compute the averages.\n# Load in the dataset\ntrans =[]\n(continues on next page)\n904 Mathematics for Deep Learning\n(continued from previous page)\ntrans .append(transforms .ToTensor())\ntrans =transforms .Compose(trans)\ntrain =torchvision .datasets .FashionMNIST(root =\"../data \", transform =trans,\ntrain =True , download =True )\ntest =torchvision .datasets .FashionMNIST(root =\"../data \", transform =trans,\ntrain =False , download =True )\nX_train_0 =torch .stack(\n[x[0]*256 for xintrain ifx[1]==0]).type(torch .float32)\nX_train_1 =torch .stack(\n[x[0]*256 for xintrain ifx[1]==1]).type(torch .float32)\nX_test =torch .stack(\n[x[0]*256 for xintest ifx[1]==0orx[1]==1]).type(torch .float32)\ny_test =torch .stack([torch .tensor(x[ 1])for xintest\nifx[1]==0orx[1]==1]).type(torch .float32)\n# Compute averages\nave_0 =torch .mean(X_train_0, axis =0)\nave_1 =torch .mean(X_train_1, axis =0)\nIt can be informative to examine these averages in detail, so let\u2019s plot what they look like.\nIn this case, we see that the average indeed resembles a blurry image of a t-shirt.\n# Plot average t-shirt\nd2l.set_figsize()\nd2l.plt.imshow(ave_0 .reshape( 28,28).tolist(), cmap ='Greys ')\nd2l.plt.show()\nInthesecondcase,weagainseethattheaverageresemblesablurryimageoftrousers.\n# Plot average trousers\nd2l.plt.imshow(ave_1 .reshape( 28,28).tolist(), cmap ='Greys ')\nd2l.plt.show()\nIn a fully machine learned solution, we would learn the threshold from the dataset. In this\ncase, I simply eyeballed a threshold that looked good on the training data by hand.", "mimetype": "text/plain", "start_char_idx": 1882791, "end_char_idx": 1886486, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "eb31aadb-e3da-4c00-8eb3-fa3591317426": {"__data__": {"id_": "eb31aadb-e3da-4c00-8eb3-fa3591317426", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "06bcccdc-bb7d-4f35-ad87-e46d77d8eba0", "node_type": "1", "metadata": {}, "hash": "6191da0b6ab0dcaeb27ff476a3c333bf6ca55a302b64d2c3ce62e341f46282a3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "582f2e27-ae44-45a7-8546-e2a0a15d5d8b", "node_type": "1", "metadata": {}, "hash": "4ec43a10a373212ac345fef72cb2de93d35c483429b40a1195da6aea5925f4f6", "class_name": "RelatedNodeInfo"}}, "text": "In this case, we see that the average indeed resembles a blurry image of a t-shirt.\n# Plot average t-shirt\nd2l.set_figsize()\nd2l.plt.imshow(ave_0 .reshape( 28,28).tolist(), cmap ='Greys ')\nd2l.plt.show()\nInthesecondcase,weagainseethattheaverageresemblesablurryimageoftrousers.\n# Plot average trousers\nd2l.plt.imshow(ave_1 .reshape( 28,28).tolist(), cmap ='Greys ')\nd2l.plt.show()\nIn a fully machine learned solution, we would learn the threshold from the dataset. In this\ncase, I simply eyeballed a threshold that looked good on the training data by hand.\n# Print test set accuracy with eyeballed threshold\nw=(ave_1 -ave_0) .T\n(continues on next page)\n905 Geometry and Linear Algebraic Operations\n(continued from previous page)\n# '@' is Matrix Multiplication operator in pytorch.\npredictions =X_test .reshape( 2000 ,-1)@(w.flatten()) >-1500000\n# Accuracy\ntorch .mean((predictions .type(y_test .dtype) ==y_test) .float(), dtype =torch .\n\u21a9!float64)\ntensor( 0.7870 , dtype =torch .float64)\nA.1.4Geometryof Linear Transformations\nThrough Section2.3 andtheabovediscussions,wehaveasolidunderstandingofthegeom-\netryofvectors,lengths,andangles. However,thereisoneimportantobjectwehaveomitted\ndiscussing, and that is a geometric understanding of linear transformations represented by\nmatrices. Fully internalizing what matrices can do to transform data between two poten-\ntially different high dimensional spaces takes significant practice, and is beyond the scope\nof this appendix. However, we can start building up intuition in two dimensions.\nSuppose that we have some matrix:\nA=\u0014\ud835\udc4e \ud835\udc4f\n\ud835\udc50 \ud835\udc51\u0015\n. (A.11)\nIf we want to apply this to an arbitrary vector v=\u00bb\ud835\udc65,\ud835\udc66\u00bc>, we multiply and see that\nAv=\u0014\ud835\udc4e \ud835\udc4f\n\ud835\udc50 \ud835\udc51\u0015 \u0014\ud835\udc65\n\ud835\udc66\u0015\n=\u0014\ud835\udc4e\ud835\udc65\u00b8\ud835\udc4f\ud835\udc66\n\ud835\udc50\ud835\udc65\u00b8\ud835\udc51\ud835\udc66\u0015\n=\ud835\udc65\u0014\ud835\udc4e\n\ud835\udc50\u0015\n\u00b8\ud835\udc66\u0014\ud835\udc4f\n\ud835\udc51\u0015\n=\ud835\udc65\u001a\nA\u00141\n0\u0015\u001b\n\u00b8\ud835\udc66\u001a\nA\u00140\n1\u0015\u001b\n.(A.12)\nThis may seem like an odd computation, where something clear became somewhat impen-\netrable. However, it tells us that we can write the way that a matrix transforms anyvector\n906 Mathematics for Deep Learning\nin terms of how it transforms two specific vectors :\u00bb1,0\u00bc>and\u00bb0,1\u00bc>. This is worth con-\nsidering for a moment. We have essentially reduced an infinite problem (what happens to\nany pair of real numbers) to a finite one (what happens to these specific vectors). These\nvectors are an example a basis, where we can write any vector in our space as a weighted\nsum of these basis vectors .\nLet\u2019s draw what happens when we use the specific matrix\nA=\u00141 2\n\u00001 3\u0015\n. (A.13)\nIf we look at the specific vector v=\u00bb2,\u00001\u00bc>, we see this is 2\u0001\u00bb1,0\u00bc>\u00b8\u00001\u0001\u00bb0,1\u00bc>, and\nthusweknowthatthematrix \ud835\udc34willsendthisto 2\u00b9A\u00bb1,0\u00bc>\u00ba\u00b8\u00001\u00b9A\u00bb0,1\u00bc\u00ba>=2\u00bb1,\u00001\u00bc>\u0000\n\u00bb2,3\u00bc>=\u00bb0,\u00005\u00bc>. If we follow this logic through carefully, say by considering the grid\nof all integer pairs of points, we see that what happens is that the matrix multiplication\ncan skew, rotate, and scale the grid, but the grid structure must remain as you see in Fig.\nA.8.\ntFig. A.8 The matrix Aacting on the given basis vectors. Notice how the entire grid is transported\nalong with it.\nThis is the most important intuitive point to internalize about linear transformations rep-\nresented by matrices. Matrices are incapable of distorting some parts of space differently\nthan others. All they can do is take the original coordinates on our space and skew, rotate,\nand scale them.\nSome distortions can be severe.", "mimetype": "text/plain", "start_char_idx": 1885931, "end_char_idx": 1889228, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "582f2e27-ae44-45a7-8546-e2a0a15d5d8b": {"__data__": {"id_": "582f2e27-ae44-45a7-8546-e2a0a15d5d8b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "eb31aadb-e3da-4c00-8eb3-fa3591317426", "node_type": "1", "metadata": {}, "hash": "96bf390896002d7186927c9333e0db47085a23d75c6878864aea6f3b1426cf3d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3f2dde09-9003-4df4-aee2-156d94662d33", "node_type": "1", "metadata": {}, "hash": "24fa0856fc8849e0afa6caa19867f28382051530493ffa756d1af6ae1177422d", "class_name": "RelatedNodeInfo"}}, "text": "If we follow this logic through carefully, say by considering the grid\nof all integer pairs of points, we see that what happens is that the matrix multiplication\ncan skew, rotate, and scale the grid, but the grid structure must remain as you see in Fig.\nA.8.\ntFig. A.8 The matrix Aacting on the given basis vectors. Notice how the entire grid is transported\nalong with it.\nThis is the most important intuitive point to internalize about linear transformations rep-\nresented by matrices. Matrices are incapable of distorting some parts of space differently\nthan others. All they can do is take the original coordinates on our space and skew, rotate,\nand scale them.\nSome distortions can be severe. For instance the matrix\nB=\u00142\u00001\n4\u00002\u0015\n, (A.14)\ncompressestheentiretwo-dimensionalplanedowntoasingleline. Identifyingandworking\nwith such transformations are the topic of a later section, but geometrically we can see\nthat this is fundamentally different from the types of transformations we saw above. For\ninstance, theresultfrommatrix Acanbe\u201cbentback\u201dtotheoriginalgrid. Theresultsfrom\nmatrix Bcannot because we will never know where the vector \u00bb1,2\u00bc>came from\u2014was it\n\u00bb1,1\u00bc>or\u00bb0,\u00001\u00bc>?\nWhilethispicturewasfora 2\u00022matrix,nothingpreventsusfromtakingthelessonslearned\nintohigherdimensions. Ifwetakesimilarbasisvectorslike \u00bb1,0,..., 0\u00bcandseewhereour\nmatrix sends them, we can start to get a feeling for how the matrix multiplication distorts\nthe entire space in whatever dimension space we are dealing with.\n907 Geometry and Linear Algebraic Operations\nA.1.5LinearDependence\nConsider again the matrix\nB=\u00142\u00001\n4\u00002\u0015\n. (A.15)\nThis compresses the entire plane down to live on the single line \ud835\udc66=2\ud835\udc65. The question now\narises: is there some way we can detect this just looking at the matrix itself? The answer is\nthat indeed we can. Let\u2019s take b1=\u00bb2,4\u00bc>andb2=\u00bb\u00001,\u00002\u00bc>be the two columns of B.\nRemember that we can write everything transformed bythe matrix Bas a weighted sum of\nthe columns of the matrix: like \ud835\udc4e1b1\u00b8\ud835\udc4e2b2. We call this a linear combination . The fact\nthatb1=\u00002\u0001b2means that we can write any linear combination of those two columns\nentirely in terms of say b2since\n\ud835\udc4e1b1\u00b8\ud835\udc4e2b2=\u00002\ud835\udc4e1b2\u00b8\ud835\udc4e2b2=\u00b9\ud835\udc4e2\u00002\ud835\udc4e1\u00bab2. (A.16)\nThis means that one of the columns is, in a sense, redundant because it does not define a\nunique direction in space. This should not surprise us too much since we already saw that\nthis matrix collapses the entire plane down into a single line. Moreover, we see that the\nlinear dependence b1=\u00002\u0001b2captures this. To make this more symmetrical between the\ntwo vectors, we will write this as\nb1\u00b82\u0001b2=0. (A.17)\nIngeneral,wewillsaythatacollectionofvectors v1,...,v\ud835\udc58arelinearlydependent ifthere\nexist coefficients \ud835\udc4e1,...,\ud835\udc4e\ud835\udc58notall equaltozero so that\n\ud835\udc58\u00d5\n\ud835\udc56=1\ud835\udc4e\ud835\udc56vi=0. (A.18)\nInthiscase, wecansolveforoneofthevectorsintermsofsomecombinationoftheothers,\nand effectively render it redundant. Thus, a linear dependence in the columns of a matrix\nis a witness to the fact that our matrix is compressing the space down to some lower di-\nmension. If there is no linear dependence we say the vectors are linearly independent . If\nthe columns of a matrix are linearly independent, no compression occurs and the operation\ncan be undone.\nA.1.6Rank\nIf we have a general \ud835\udc5b\u0002\ud835\udc5amatrix, it is reasonable to ask what dimension space the matrix\nmaps into. A concept known as the rankwill be our answer.", "mimetype": "text/plain", "start_char_idx": 1888532, "end_char_idx": 1891902, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3f2dde09-9003-4df4-aee2-156d94662d33": {"__data__": {"id_": "3f2dde09-9003-4df4-aee2-156d94662d33", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "582f2e27-ae44-45a7-8546-e2a0a15d5d8b", "node_type": "1", "metadata": {}, "hash": "4ec43a10a373212ac345fef72cb2de93d35c483429b40a1195da6aea5925f4f6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "42f2cd88-9c2c-4f03-aac4-547373275ce9", "node_type": "1", "metadata": {}, "hash": "613e6ac28753121c4170c2467808ca7db9b52078fa482541ba794d07a9f26708", "class_name": "RelatedNodeInfo"}}, "text": "(A.18)\nInthiscase, wecansolveforoneofthevectorsintermsofsomecombinationoftheothers,\nand effectively render it redundant. Thus, a linear dependence in the columns of a matrix\nis a witness to the fact that our matrix is compressing the space down to some lower di-\nmension. If there is no linear dependence we say the vectors are linearly independent . If\nthe columns of a matrix are linearly independent, no compression occurs and the operation\ncan be undone.\nA.1.6Rank\nIf we have a general \ud835\udc5b\u0002\ud835\udc5amatrix, it is reasonable to ask what dimension space the matrix\nmaps into. A concept known as the rankwill be our answer. In the previous section, we\nnotedthatalineardependencebearswitnesstocompressionofspaceintoalowerdimension\nand so we will be able to use this to define the notion of rank. In particular, the rank of\na matrix Ais the largest number of linearly independent columns amongst all subsets of\ncolumns. For example, the matrix\nB=\u00142 4\n\u00001\u00002\u0015\n, (A.19)\n908 Mathematics for Deep Learning\nhas rank\u00b9\ud835\udc35\u00ba=1, since the two columns are linearly dependent, but either column by itself\nis not linearly dependent. For a more challenging example, we can consider\nC=266666641 3 0\u00001 0\n\u00001 0 1 1\u00001\n0 3 1 0\u00001\n2 3\u00001\u00002 137777775, (A.20)\nand show that Chas rank two since, for instance, the first two columns are linearly inde-\npendent, however any of the four collections of three columns are dependent.\nThis procedure, as described, is very inefficient. It requires looking at every subset of the\ncolumnsofourgivenmatrix, andthusispotentiallyexponentialinthenumberofcolumns.\nLater we will see a more computationally efficient way to compute the rank of a matrix,\nbut for now, this is sufficient to see that the concept is well defined and understand the\nmeaning.\nA.1.7Invertibility\nWehaveseenabovethatmultiplicationbyamatrixwithlinearlydependentcolumnscannot\nbe undone, i.e., there is no inverse operation that can always recover the input. However,\nmultiplication by a full-rank matrix (i.e., some Athat is\ud835\udc5b\u0002\ud835\udc5bmatrix with rank \ud835\udc5b), we\nshould always be able to undo it. Consider the matrix\nI=2666666641 0\u0001\u0001\u0001 0\n0 1\u0001\u0001\u0001 0\n............\n0 0\u0001\u0001\u0001 1377777775. (A.21)\nwhich is the matrix with ones along the diagonal, and zeros elsewhere. We call this the\nidentitymatrix. It is the matrix which leaves our data unchanged when applied. To find\na matrix which undoes what our matrix Ahas done, we want to find a matrix A\u00001such\nthat\nA\u00001A=AA\u00001=I. (A.22)\nIf we look at this as a system, we have \ud835\udc5b\u0002\ud835\udc5bunknowns (the entries of A\u00001) and\ud835\udc5b\u0002\ud835\udc5b\nequations (the equality that needs to hold between every entry of the product A\u00001Aand\nevery entry of I) so we should generically expect a solution to exist. Indeed, in the next\nsectionwewillseeaquantitycalledthe determinant ,whichhasthepropertythataslongas\nthe determinant is not zero, we can find a solution. We call such a matrix A\u00001theinverse\nmatrix. As an example, if Ais the general 2\u00022matrix\nA=\u0014\ud835\udc4e \ud835\udc4f\n\ud835\udc50 \ud835\udc51\u0015\n, (A.23)\nthen we can see that the inverse is\n1\n\ud835\udc4e\ud835\udc51\u0000\ud835\udc4f\ud835\udc50\u0014\ud835\udc51\u0000\ud835\udc4f\n\u0000\ud835\udc50 \ud835\udc4e\u0015\n. (A.24)\n909 Geometry and Linear Algebraic Operations\nWe can test to see this by seeing that multiplying by the inverse given by the formula above\nworks in practice.\nM=torch .tensor([[ 1,2], [ 1,4]], dtype =torch .float32)\nM_inv =torch .tensor([[ 2,-1], [ -0.5,0.5]])\nM_inv @M\ntensor([[ 1.,0.],\n[0.,1.]])", "mimetype": "text/plain", "start_char_idx": 1891288, "end_char_idx": 1894567, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "42f2cd88-9c2c-4f03-aac4-547373275ce9": {"__data__": {"id_": "42f2cd88-9c2c-4f03-aac4-547373275ce9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3f2dde09-9003-4df4-aee2-156d94662d33", "node_type": "1", "metadata": {}, "hash": "24fa0856fc8849e0afa6caa19867f28382051530493ffa756d1af6ae1177422d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8aa42ac4-0f80-4350-a0f0-2258a3de4a7f", "node_type": "1", "metadata": {}, "hash": "87b9603f3096c4877a7d878c7aa380ba948f9b2750a0ecb1886b024e27afc36f", "class_name": "RelatedNodeInfo"}}, "text": "We call such a matrix A\u00001theinverse\nmatrix. As an example, if Ais the general 2\u00022matrix\nA=\u0014\ud835\udc4e \ud835\udc4f\n\ud835\udc50 \ud835\udc51\u0015\n, (A.23)\nthen we can see that the inverse is\n1\n\ud835\udc4e\ud835\udc51\u0000\ud835\udc4f\ud835\udc50\u0014\ud835\udc51\u0000\ud835\udc4f\n\u0000\ud835\udc50 \ud835\udc4e\u0015\n. (A.24)\n909 Geometry and Linear Algebraic Operations\nWe can test to see this by seeing that multiplying by the inverse given by the formula above\nworks in practice.\nM=torch .tensor([[ 1,2], [ 1,4]], dtype =torch .float32)\nM_inv =torch .tensor([[ 2,-1], [ -0.5,0.5]])\nM_inv @M\ntensor([[ 1.,0.],\n[0.,1.]])\nNumericalIssues\nWhile the inverse of a matrix is useful in theory, we must say that most of the time we do\nnot wish to usethe matrix inverse to solve a problem in practice. In general, there are far\nmore numerically stable algorithms for solving linear equations like\nAx=b, (A.25)\nthan computing the inverse and multiplying to get\nx=A\u00001b. (A.26)\nJust as division by a small number can lead to numerical instability, so can inversion of a\nmatrix which is close to having low rank.\nMoreover, it is common that the matrix Aissparse, which is to say that it contains only a\nsmall number of non-zero values. If we were to explore examples, we would see that this\ndoesnotmeantheinverseissparse. Evenif Awasa 1millionby 1millionmatrixwithonly\n5million non-zero entries (and thus we need only store those 5million), the inverse will\ntypically have almost every entry non-negative, requiring us to store all 1M2entries\u2014that\nis1trillion entries!\nWhile we do not have time to dive all the way into the thorny numerical issues frequently\nencounteredwhenworkingwithlinearalgebra,wewanttoprovideyouwithsomeintuition\nabout when to proceed with caution, and generally avoiding inversion in practice is a good\nrule of thumb.\nA.1.8Determinant\nThe geometric view of linear algebra gives an intuitive way to interpret a fundamental\nquantity known as the determinant . Consider the grid image from before, but now with a\nhighlighted region ( Fig. A.9).\nLook at the highlighted square. This is a square with edges given by \u00b90,1\u00baand\u00b91,0\u00baand\nthusithasareaone. After Atransformsthissquare,weseethatitbecomesaparallelogram.\nThere is no reason this parallelogram should have the same area that we started with, and\n910 Mathematics for Deep Learning\ntFig. A.9 The matrix Aagain distorting the grid. This time, I want to draw particular attention to\nwhat happens to the highlighted square.\nindeed in the specific case shown here of\nA=\u00141 2\n\u00001 3\u0015\n, (A.27)\nitisanexerciseincoordinategeometrytocomputetheareaofthisparallelogramandobtain\nthat the area is 5.\nIn general, if we have a matrix\nA=\u0014\ud835\udc4e \ud835\udc4f\n\ud835\udc50 \ud835\udc51\u0015\n, (A.28)\nwe can see with some computation that the area of the resulting parallelogram is \ud835\udc4e\ud835\udc51\u0000\ud835\udc4f\ud835\udc50.\nThis area is referred to as the determinant .\nLet\u2019s check this quickly with some example code.\ntorch .det(torch .tensor([[ 1,-1], [ 2,3]], dtype =torch .float32))\ntensor( 5.)\nThe eagle-eyed amongst us will notice that this expression can be zero or even negative.\nFor the negative term, this is a matter of convention taken generally in mathematics: if the\nmatrix flips the figure, we say the area is negated. Let\u2019s see now that when the determinant\nis zero, we learn more.\nLet\u2019s consider\nB=\u00142 4\n\u00001\u00002\u0015\n. (A.29)\nIf we compute the determinant of this matrix, we get 2\u0001\u00b9\u00002\u00ba\u00004\u0001\u00b9\u00001\u00ba=0. Given our\nunderstanding above, this makes sense. Bcompresses the square from the original image\ndown to a line segment, which has zero area. And indeed, being compressed into a lower\ndimensional space is the only way to have zero area after the transformation.", "mimetype": "text/plain", "start_char_idx": 1894100, "end_char_idx": 1897574, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8aa42ac4-0f80-4350-a0f0-2258a3de4a7f": {"__data__": {"id_": "8aa42ac4-0f80-4350-a0f0-2258a3de4a7f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "42f2cd88-9c2c-4f03-aac4-547373275ce9", "node_type": "1", "metadata": {}, "hash": "613e6ac28753121c4170c2467808ca7db9b52078fa482541ba794d07a9f26708", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2c40f651-abe8-415e-84a2-33daf2d4143c", "node_type": "1", "metadata": {}, "hash": "abf420fc9fc565f2eeb3191c09fd1b845ef27b2d30c6f802d64458c1f7b4a4d4", "class_name": "RelatedNodeInfo"}}, "text": "The eagle-eyed amongst us will notice that this expression can be zero or even negative.\nFor the negative term, this is a matter of convention taken generally in mathematics: if the\nmatrix flips the figure, we say the area is negated. Let\u2019s see now that when the determinant\nis zero, we learn more.\nLet\u2019s consider\nB=\u00142 4\n\u00001\u00002\u0015\n. (A.29)\nIf we compute the determinant of this matrix, we get 2\u0001\u00b9\u00002\u00ba\u00004\u0001\u00b9\u00001\u00ba=0. Given our\nunderstanding above, this makes sense. Bcompresses the square from the original image\ndown to a line segment, which has zero area. And indeed, being compressed into a lower\ndimensional space is the only way to have zero area after the transformation. Thus we see\nthe following result is true: a matrix \ud835\udc34is invertible if and only if the determinant is not\nequal to zero.\n911 Geometry and Linear Algebraic Operations\nAs a final comment, imagine that we have any figure drawn on the plane. Thinking like\ncomputer scientists, we can decompose that figure into a collection of little squares so that\nthe area of the figure is in essence just the number of squares in the decomposition. If we\nnowtransformthatfigurebyamatrix,wesendeachofthesesquarestoparallelograms,each\noneofwhichhasareagivenbythedeterminant. Weseethatforanyfigure,thedeterminant\ngives the (signed) number that a matrix scales the area of any figure.\nComputing determinants for larger matrices can be laborious, but the intuition is the same.\nThedeterminantremainsthefactorthat \ud835\udc5b\u0002\ud835\udc5bmatricesscale \ud835\udc5b-dimensionalvolumes.\nA.1.9Tensorsand Common Linear AlgebraOperations\nInSection 2.3 the concept of tensors was introduced. In this section, we will dive more\ndeeply into tensor contractions (the tensor equivalent of matrix multiplication), and see\nhow it can provide a unified view on a number of matrix and vector operations.\nWith matrices and vectors we knew how to multiply them to transform data. We need\nto have a similar definition for tensors if they are to be useful to us. Think about matrix\nmultiplication:\nC=AB, (A.30)\nor equivalently\n\ud835\udc50\ud835\udc56,\ud835\udc57=\u00d5\n\ud835\udc58\ud835\udc4e\ud835\udc56,\ud835\udc58\ud835\udc4f\ud835\udc58,\ud835\udc57.(A.31)\nThis pattern is one we can repeat for tensors. For tensors, there is no one case of what to\nsum over that can be universally chosen, so we need specify exactly which indices we want\nto sum over. For instance we could consider\n\ud835\udc66\ud835\udc56\ud835\udc59=\u00d5\n\ud835\udc57\ud835\udc58\ud835\udc65\ud835\udc56\ud835\udc57\ud835\udc58\ud835\udc59\ud835\udc4e\ud835\udc57\ud835\udc58.(A.32)\nSuch a transformation is called a tensor contraction . It can represent a far more flexible\nfamily of transformations that matrix multiplication alone.\nAs a often-used notational simplification, we can notice that the sum is over exactly those\nindices that occur more than once in the expression, thus people often work with Einstein\nnotation, where the summation is implicitly taken over all repeated indices. This gives the\ncompact expression:\n\ud835\udc66\ud835\udc56\ud835\udc59=\ud835\udc65\ud835\udc56\ud835\udc57\ud835\udc58\ud835\udc59\ud835\udc4e\ud835\udc57\ud835\udc58. (A.33)\nCommon ExamplesfromLinear Algebra\nLet\u2019sseehowmanyofthelinearalgebraicdefinitionswehaveseenbeforecanbeexpressed\nin this compressed tensor notation:\n\u000fv\u0001w=\u00cd\n\ud835\udc56\ud835\udc63\ud835\udc56\ud835\udc64\ud835\udc56\n\u000fkvk2\n2=\u00cd\n\ud835\udc56\ud835\udc63\ud835\udc56\ud835\udc63\ud835\udc56\n912 Mathematics for Deep Learning\n\u000f\u00b9Av\u00ba\ud835\udc56=\u00cd\n\ud835\udc57\ud835\udc4e\ud835\udc56\ud835\udc57\ud835\udc63\ud835\udc57\n\u000f\u00b9AB\u00ba\ud835\udc56\ud835\udc58=\u00cd\n\ud835\udc57\ud835\udc4e\ud835\udc56\ud835\udc57\ud835\udc4f\ud835\udc57\ud835\udc58\n\u000ftr\u00b9A\u00ba=\u00cd\n\ud835\udc56\ud835\udc4e\ud835\udc56\ud835\udc56\nIn this way, we can replace a myriad of specialized notations with short tensor expres-\nsions.\nExpressingin Code\nTensors may flexibly be operated on in code as well. As seen in Section 2.3 , we can create\ntensors as is shown below.", "mimetype": "text/plain", "start_char_idx": 1896908, "end_char_idx": 1900157, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2c40f651-abe8-415e-84a2-33daf2d4143c": {"__data__": {"id_": "2c40f651-abe8-415e-84a2-33daf2d4143c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8aa42ac4-0f80-4350-a0f0-2258a3de4a7f", "node_type": "1", "metadata": {}, "hash": "87b9603f3096c4877a7d878c7aa380ba948f9b2750a0ecb1886b024e27afc36f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "80d30081-2dcc-4dfd-8e12-4adb36a7c2b1", "node_type": "1", "metadata": {}, "hash": "bbd54eeae10482f698c1f703c0b869ce64f11d59eb32c92e6608903e769d8328", "class_name": "RelatedNodeInfo"}}, "text": "Expressingin Code\nTensors may flexibly be operated on in code as well. As seen in Section 2.3 , we can create\ntensors as is shown below.\n# Define tensors\nB=torch .tensor([[[ 1,2,3], [ 4,5,6]], [[ 7,8,9], [ 10,11,12]]])\nA=torch .tensor([[ 1,2], [ 3,4]])\nv=torch .tensor([ 1,2])\n# Print out the shapes\nA.shape, B .shape, v .shape\n(torch .Size([ 2,2]), torch .Size([ 2,2,3]), torch .Size([ 2]))\nEinstein summation has been implemented directly. The indices that occurs in the Einstein\nsummationcanbepassedasastring,followedbythetensorsthatarebeingactedupon. For\ninstance,toimplementmatrixmultiplication,wecanconsidertheEinsteinsummationseen\nabove( Av=\ud835\udc4e\ud835\udc56\ud835\udc57\ud835\udc63\ud835\udc57)andstripouttheindicesthemselvestogettheimplementation:\n# Reimplement matrix multiplication\ntorch .einsum( \"ij, j -> i \", A, v), A @v\n(tensor([ 5,11]), tensor([ 5,11]))\nThis is a highly flexible notation. For instance if we want to compute what would be tradi-\ntionally written as\n\ud835\udc50\ud835\udc58\ud835\udc59=\u00d5\n\ud835\udc56\ud835\udc57b\ud835\udc56\ud835\udc57\ud835\udc58a\ud835\udc56\ud835\udc59\ud835\udc63\ud835\udc57.(A.34)\nit can be implemented via Einstein summation as:\ntorch .einsum( \"ijk, il, j -> kl \", B, A, v)\ntensor([[ 90,126],\n[102,144],\n[114,162]])\n913 Geometry and Linear Algebraic Operations\nThisnotationisreadableandefficientforhumans,howeverbulkyifforwhateverreasonwe\nneed to generate a tensor contraction programmatically. For this reason, einsumprovides\nan alternative notation by providing integer indices for each tensor. For example, the same\ntensor contraction can also be written as:\n# PyTorch does not support this type of notation.\nEither notation allows for concise and efficient representation of tensor contractions in\ncode.\nA.1.10Summary\n\u000fVectors can be interpreted geometrically as either points or directions in space.\n\u000fDot products define the notion of angle to arbitrarily high-dimensional spaces.\n\u000fHyperplanesarehigh-dimensionalgeneralizationsoflinesandplanes. Theycanbeused\nto define decision planes that are often used as the last step in a classification task.\n\u000fMatrix multiplication can be geometrically interpreted as uniform distortions of the un-\nderlying coordinates. They represent a very restricted, but mathematically clean, way\nto transform vectors.\n\u000fLineardependenceisawaytotellwhenacollectionofvectorsareinalowerdimensional\nspace than we would expect (say you have 3vectors living in a 2-dimensional space).\nThe rank of a matrix is the size of the largest subset of its columns that are linearly\nindependent.\n\u000fWhenamatrix\u2019sinverseisdefined,matrixinversionallowsustofindanothermatrixthat\nundoes the action of the first. Matrix inversion is useful in theory, but requires care in\npractice owing to numerical instability.\n\u000fDeterminants allow us to measure how much a matrix expands or contracts a space. A\nnonzero determinant implies an invertible (non-singular) matrix and a zero-valued\ndeterminant means that the matrix is non-invertible (singular).\n\u000fTensor contractions and Einstein summation provide for a neat and clean notation for\nexpressing many of the computations that are seen in machine learning.\nA.1.11Exercises\n1.What is the angle between\n\u00ae\ud835\udc631=266666641\n0\n\u00001\n237777775,\u00ae\ud835\udc632=266666643\n1\n0\n137777775? (A.35)\n2.True or false:\u00141 2\n0 1\u0015\nand\u00141\u00002\n0 1\u0015\nare inverses of one another?\n914 Mathematics for Deep Learning\n2803.Suppose that we draw a shape in the plane with area 100m2. What is the area after\ntransforming the figure by the matrix\n\u00142 3\n1 2\u0015\n. (A.36)\n4.Which of the following sets of vectors are linearly independent?", "mimetype": "text/plain", "start_char_idx": 1900021, "end_char_idx": 1903430, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "80d30081-2dcc-4dfd-8e12-4adb36a7c2b1": {"__data__": {"id_": "80d30081-2dcc-4dfd-8e12-4adb36a7c2b1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2c40f651-abe8-415e-84a2-33daf2d4143c", "node_type": "1", "metadata": {}, "hash": "abf420fc9fc565f2eeb3191c09fd1b845ef27b2d30c6f802d64458c1f7b4a4d4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c95c8429-7190-480a-96cc-5b2ef8a196c0", "node_type": "1", "metadata": {}, "hash": "05d5d64d0d88ef4dd962a8885ea2e180204410837a1990e908f318fce53ac4be", "class_name": "RelatedNodeInfo"}}, "text": "\u000fTensor contractions and Einstein summation provide for a neat and clean notation for\nexpressing many of the computations that are seen in machine learning.\nA.1.11Exercises\n1.What is the angle between\n\u00ae\ud835\udc631=266666641\n0\n\u00001\n237777775,\u00ae\ud835\udc632=266666643\n1\n0\n137777775? (A.35)\n2.True or false:\u00141 2\n0 1\u0015\nand\u00141\u00002\n0 1\u0015\nare inverses of one another?\n914 Mathematics for Deep Learning\n2803.Suppose that we draw a shape in the plane with area 100m2. What is the area after\ntransforming the figure by the matrix\n\u00142 3\n1 2\u0015\n. (A.36)\n4.Which of the following sets of vectors are linearly independent?\n\u000f8>>> <\n>>>:\u00a9\u00ad\u00ad\n\u00ab1\n0\n\u00001\u00aa\u00ae\u00ae\n\u00ac,\u00a9\u00ad\u00ad\n\u00ab2\n1\n\u00001\u00aa\u00ae\u00ae\n\u00ac,\u00a9\u00ad\u00ad\n\u00ab3\n1\n1\u00aa\u00ae\u00ae\n\u00ac9>>> =\n>>>;\n\u000f8>>> <\n>>>:\u00a9\u00ad\u00ad\n\u00ab3\n1\n1\u00aa\u00ae\u00ae\n\u00ac,\u00a9\u00ad\u00ad\n\u00ab1\n1\n1\u00aa\u00ae\u00ae\n\u00ac,\u00a9\u00ad\u00ad\n\u00ab0\n0\n0\u00aa\u00ae\u00ae\n\u00ac9>>> =\n>>>;\n\u000f8>>> <\n>>>:\u00a9\u00ad\u00ad\n\u00ab1\n1\n0\u00aa\u00ae\u00ae\n\u00ac,\u00a9\u00ad\u00ad\n\u00ab0\n1\n\u00001\u00aa\u00ae\u00ae\n\u00ac,\u00a9\u00ad\u00ad\n\u00ab1\n0\n1\u00aa\u00ae\u00ae\n\u00ac9>>> =\n>>>;\n5.Suppose that you have a matrix written as \ud835\udc34=\u0014\ud835\udc50\n\ud835\udc51\u0015\n\u0001\u0002\n\ud835\udc4e \ud835\udc4f\u0003\nfor some choice of values\n\ud835\udc4e,\ud835\udc4f,\ud835\udc50, and\ud835\udc51. True or false: the determinant of such a matrix is always 0?\n6.The vectors\ud835\udc521=\u00141\n0\u0015\nand\ud835\udc522=\u00140\n1\u0015\nare orthogonal. What is the condition on a matrix \ud835\udc34\nso that\ud835\udc34\ud835\udc521and\ud835\udc34\ud835\udc522are orthogonal?\n7.How can you write tr \u00b9A4\u00bain Einstein notation for an arbitrary matrix \ud835\udc34?\nDiscussions280.\nA.2Eigendecompositions\nEigenvaluesareoftenoneofthemostusefulnotionswewillencounterwhenstudyinglinear\nalgebra,however,asabeginner,itiseasytooverlooktheirimportance. Below,weintroduce\neigendecomposition and try to convey some sense of just why it is so important.\nSuppose that we have a matrix \ud835\udc34with the following entries:\nA=\u00142 0\n0\u00001\u0015\n. (A.1)\nIf we apply\ud835\udc34to any vector v=\u00bb\ud835\udc65,\ud835\udc66\u00bc>, we obtain a vector Av=\u00bb2\ud835\udc65,\u0000\ud835\udc66\u00bc>. This has an\nintuitive interpretation: stretch the vector to be twice as wide in the \ud835\udc65-direction, and then\nflip it in the\ud835\udc66-direction.\n915 Eigendecompositions\nHowever, there are somevectors for which something remains unchanged. Namely \u00bb1,0\u00bc>\ngets sent to\u00bb2,0\u00bc>and\u00bb0,1\u00bc>gets sent to\u00bb0,\u00001\u00bc>. These vectors are still in the same\nline, and the only modification is that the matrix stretches them by a factor of 2and\u00001\nrespectively. We call such vectors eigenvectors and the factor they are stretched by eigen-\nvalues.\nIn general, if we can find a number \ud835\udf06and a vector vsuch that\nAv=\ud835\udf06v. (A.2)\nWe say that vis an eigenvector for \ud835\udc34and\ud835\udf06is an eigenvalue.\nA.2.1Finding Eigenvalues\nLet\u2019s figure out how to find them. By subtracting off the \ud835\udf06vfrom both sides, and then\nfactoring out the vector, we see the above is equivalent to:\n\u00b9A\u0000\ud835\udf06I\u00bav=0. (A.3)\nFor(A.3)to happen, we see that \u00b9A\u0000\ud835\udf06I\u00bamust compress some direction down to zero,\nhenceitisnotinvertible,andthusthedeterminantiszero. Thus,wecanfindthe eigenvalues\nby finding for what \ud835\udf06isdet\u00b9A\u0000\ud835\udf06I\u00ba=0.", "mimetype": "text/plain", "start_char_idx": 1902852, "end_char_idx": 1905456, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c95c8429-7190-480a-96cc-5b2ef8a196c0": {"__data__": {"id_": "c95c8429-7190-480a-96cc-5b2ef8a196c0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "80d30081-2dcc-4dfd-8e12-4adb36a7c2b1", "node_type": "1", "metadata": {}, "hash": "bbd54eeae10482f698c1f703c0b869ce64f11d59eb32c92e6608903e769d8328", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "be90c87c-7f20-424e-90fc-376920aeb72c", "node_type": "1", "metadata": {}, "hash": "8822a83534b551ba17d1f2ad4265ba481900d349b58ff702118bb9f39439658c", "class_name": "RelatedNodeInfo"}}, "text": "In general, if we can find a number \ud835\udf06and a vector vsuch that\nAv=\ud835\udf06v. (A.2)\nWe say that vis an eigenvector for \ud835\udc34and\ud835\udf06is an eigenvalue.\nA.2.1Finding Eigenvalues\nLet\u2019s figure out how to find them. By subtracting off the \ud835\udf06vfrom both sides, and then\nfactoring out the vector, we see the above is equivalent to:\n\u00b9A\u0000\ud835\udf06I\u00bav=0. (A.3)\nFor(A.3)to happen, we see that \u00b9A\u0000\ud835\udf06I\u00bamust compress some direction down to zero,\nhenceitisnotinvertible,andthusthedeterminantiszero. Thus,wecanfindthe eigenvalues\nby finding for what \ud835\udf06isdet\u00b9A\u0000\ud835\udf06I\u00ba=0. Once we find the eigenvalues, we can solve\nAv=\ud835\udf06vto find the associated eigenvector(s) .\nAnExample\nLet\u2019s see this with a more challenging matrix\nA=\u00142 1\n2 3\u0015\n. (A.4)\nIf we consider det\u00b9A\u0000\ud835\udf06I\u00ba=0, we see this is equivalent to the polynomial equation\n0=\u00b92\u0000\ud835\udf06\u00ba\u00b93\u0000\ud835\udf06\u00ba\u00002=\u00b94\u0000\ud835\udf06\u00ba\u00b91\u0000\ud835\udf06\u00ba. Thus, two eigenvalues are 4and1. To find the\nassociated vectors, we then need to solve\n\u00142 1\n2 3\u0015 \u0014\ud835\udc65\n\ud835\udc66\u0015\n=\u0014\ud835\udc65\n\ud835\udc66\u0015\nand\u00142 1\n2 3\u0015 \u0014\ud835\udc65\n\ud835\udc66\u0015\n=\u00144\ud835\udc65\n4\ud835\udc66\u0015\n. (A.5)\nWe can solve this with the vectors \u00bb1,\u00001\u00bc>and\u00bb1,2\u00bc>respectively.\nWe can check this in code using the built-in numpy.linalg.eig routine.\n%matplotlib inline\nimport torch\nfrom IPython import display\nfrom d2l import torch asd2l\ntorch .linalg .eig(torch .tensor([[ 2,1], [ 2,3]], dtype =torch .float64))\n916 Mathematics for Deep Learning\ntorch .return_types .linalg_eig(\neigenvalues =tensor([ 1.+0.j,4.+0.j], dtype =torch .complex128),\neigenvectors =tensor([[ -0.7071 +0.j,-0.4472 +0.j],\n[0.7071 +0.j,-0.8944 +0.j]], dtype =torch .complex128))\nNote that numpynormalizes the eigenvectors to be of length one, whereas we took ours to\nbe of arbitrary length. Additionally, the choice of sign is arbitrary. However, the vectors\ncomputed are parallel to the ones we found by hand with the same eigenvalues.\nA.2.2DecomposingMatrices\nLet\u2019s continue the previous example one step further. Let\nW=\u00141 1\n\u00001 2\u0015\n, (A.6)\nbe the matrix where the columns are the eigenvectors of the matrix A. Let\n\ud835\udeba=\u00141 0\n0 4\u0015\n, (A.7)\nbethematrixwiththeassociatedeigenvaluesonthediagonal. Thenthedefinitionofeigen-\nvalues and eigenvectors tells us that\nAW=W\ud835\udeba. (A.8)\nThe matrix\ud835\udc4ais invertible, so we may multiply both sides by \ud835\udc4a\u00001on the right, we see that\nwe may write\nA=W\ud835\udebaW\u00001. (A.9)\nIn the next section we will see some nice consequences of this, but for now we need only\nknowthatsuchadecompositionwillexistaslongaswecanfindafullcollectionoflinearly\nindependent eigenvectors (so that \ud835\udc4ais invertible).\nA.2.3Operationson Eigendecompositions\nOne nice thing about eigendecompositions (A.9)is that we can write many operations we\nusually encounter cleanly in terms of the eigendecomposition. As a first example, con-\nsider:\nA\ud835\udc5b=\ud835\udc5btimesz   }|   {\nA\u0001\u0001\u0001A=\ud835\udc5btimesz                              }|                              {\n\u00b9W\ud835\udebaW\u00001\u00ba\u0001\u0001\u0001\u00b9W\ud835\udebaW\u00001\u00ba=W\ud835\udc5btimesz  }|  {\n\ud835\udeba\u0001\u0001\u0001\ud835\udebaW\u00001=W\ud835\udeba\ud835\udc5bW\u00001.", "mimetype": "text/plain", "start_char_idx": 1904938, "end_char_idx": 1907700, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "be90c87c-7f20-424e-90fc-376920aeb72c": {"__data__": {"id_": "be90c87c-7f20-424e-90fc-376920aeb72c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c95c8429-7190-480a-96cc-5b2ef8a196c0", "node_type": "1", "metadata": {}, "hash": "05d5d64d0d88ef4dd962a8885ea2e180204410837a1990e908f318fce53ac4be", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "00a98829-b011-4567-8ce2-ad6343d89dbf", "node_type": "1", "metadata": {}, "hash": "b679fe8e9025096d57c9cce6712306bac7f89b3f032218cb2f3498da5ec12b22", "class_name": "RelatedNodeInfo"}}, "text": "A.2.3Operationson Eigendecompositions\nOne nice thing about eigendecompositions (A.9)is that we can write many operations we\nusually encounter cleanly in terms of the eigendecomposition. As a first example, con-\nsider:\nA\ud835\udc5b=\ud835\udc5btimesz   }|   {\nA\u0001\u0001\u0001A=\ud835\udc5btimesz                              }|                              {\n\u00b9W\ud835\udebaW\u00001\u00ba\u0001\u0001\u0001\u00b9W\ud835\udebaW\u00001\u00ba=W\ud835\udc5btimesz  }|  {\n\ud835\udeba\u0001\u0001\u0001\ud835\udebaW\u00001=W\ud835\udeba\ud835\udc5bW\u00001.(A.10)\nThis tells us that for any positive power of a matrix, the eigendecomposition is obtained by\njustraisingtheeigenvaluestothesamepower. Thesamecanbeshownfornegativepowers,\nso if we want to invert a matrix we need only consider\nA\u00001=W\ud835\udeba\u00001W\u00001, (A.11)\n917 Eigendecompositions\nor in other words, just invert each eigenvalue. This will work as long as each eigenvalue is\nnon-zero, so we see that invertible is the same as having no zero eigenvalues.\nIndeed, additional work can show that if \ud835\udf061,...,\ud835\udf06\ud835\udc5bare the eigenvalues of a matrix, then\nthe determinant of that matrix is\ndet\u00b9A\u00ba=\ud835\udf061\u0001\u0001\u0001\ud835\udf06\ud835\udc5b, (A.12)\northeproductofalltheeigenvalues. Thismakessenseintuitivelybecausewhateverstretch-\ningWdoes,\ud835\udc4a\u00001undoes it, so in the end the only stretching that happens is by multipli-\ncation by the diagonal matrix \ud835\udeba, which stretches volumes by the product of the diagonal\nelements.\nFinally, recall that the rank was the maximum number of linearly independent columns of\nyour matrix. By examining the eigendecomposition closely, we can see that the rank is the\nsame as the number of non-zero eigenvalues of A.\nThe examples could continue, but hopefully the point is clear: eigendecomposition can\nsimplify many linear-algebraic computations and is a fundamental operation underlying\nmany numerical algorithms and much of the analysis that we do in linear algebra.\nA.2.4Eigendecompositionsof SymmetricMatrices\nIt is not always possible to find enough linearly independent eigenvectors for the above\nprocess to work. For instance the matrix\nA=\u00141 1\n0 1\u0015\n, (A.13)\nhas only a single eigenvector, namely \u00b91,0\u00ba>. To handle such matrices, we require more\nadvancedtechniquesthanwecancover(suchastheJordanNormalForm,orSingularValue\nDecomposition). We will often need to restrict our attention to those matrices where we\ncan guarantee the existence of a full set of eigenvectors.\nThe most commonly encountered family are the symmetric matrices , which are those ma-\ntrices where A=A>. In this case, we may take \ud835\udc4ato be anorthogonal matrix \u2014a matrix\nwhose columns are all length one vectors that are at right angles to one another, where\nW>=W\u00001\u2014and all the eigenvalues will be real. Thus, in this special case, we can write\n(A.9)as\nA=W\ud835\udebaW>. (A.14)\nA.2.5GershgorinCircleTheorem\nEigenvalues are often difficult to reason with intuitively. If presented an arbitrary matrix,\nthereislittlethatcanbesaidaboutwhattheeigenvaluesarewithoutcomputingthem. There\nis, however, one theorem that can make it easy to approximate well if the largest values are\non the diagonal.\nLetA=\u00b9\ud835\udc4e\ud835\udc56\ud835\udc57\u00babe any square matrix ( \ud835\udc5b\u0002\ud835\udc5b). We will define \ud835\udc5f\ud835\udc56=\u00cd\n\ud835\udc57\u2260\ud835\udc56j\ud835\udc4e\ud835\udc56\ud835\udc57j. LetD\ud835\udc56\n918 Mathematics for Deep Learning\nrepresent the disc in the complex plane with center \ud835\udc4e\ud835\udc56\ud835\udc56radius\ud835\udc5f\ud835\udc56. Then, every eigenvalue of\nAis contained in one of the D\ud835\udc56.\nThis can be a bit to unpack, so let\u2019s look at an example.", "mimetype": "text/plain", "start_char_idx": 1907335, "end_char_idx": 1910511, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "00a98829-b011-4567-8ce2-ad6343d89dbf": {"__data__": {"id_": "00a98829-b011-4567-8ce2-ad6343d89dbf", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "be90c87c-7f20-424e-90fc-376920aeb72c", "node_type": "1", "metadata": {}, "hash": "8822a83534b551ba17d1f2ad4265ba481900d349b58ff702118bb9f39439658c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fe5c83f0-d7ae-46c0-8331-c20472872894", "node_type": "1", "metadata": {}, "hash": "8199043aeb7a26ee7e7043f646596b5e0aee20a8a564f12ac6ec66b6734d4e36", "class_name": "RelatedNodeInfo"}}, "text": "If presented an arbitrary matrix,\nthereislittlethatcanbesaidaboutwhattheeigenvaluesarewithoutcomputingthem. There\nis, however, one theorem that can make it easy to approximate well if the largest values are\non the diagonal.\nLetA=\u00b9\ud835\udc4e\ud835\udc56\ud835\udc57\u00babe any square matrix ( \ud835\udc5b\u0002\ud835\udc5b). We will define \ud835\udc5f\ud835\udc56=\u00cd\n\ud835\udc57\u2260\ud835\udc56j\ud835\udc4e\ud835\udc56\ud835\udc57j. LetD\ud835\udc56\n918 Mathematics for Deep Learning\nrepresent the disc in the complex plane with center \ud835\udc4e\ud835\udc56\ud835\udc56radius\ud835\udc5f\ud835\udc56. Then, every eigenvalue of\nAis contained in one of the D\ud835\udc56.\nThis can be a bit to unpack, so let\u2019s look at an example. Consider the matrix:\nA=266666641.0 0.1 0.1 0.1\n0.1 3.0 0.2 0.3\n0.1 0.2 5.0 0.5\n0.1 0.3 0.5 9.037777775. (A.15)\nWe have\ud835\udc5f1=0.3,\ud835\udc5f2=0.6,\ud835\udc5f3=0.8and\ud835\udc5f4=0.9. The matrix is symmetric, so all\neigenvalues are real. This means that all of our eigenvalues will be in one of the ranges\nof\n\u00bb\ud835\udc4e11\u0000\ud835\udc5f1,\ud835\udc4e11\u00b8\ud835\udc5f1\u00bc=\u00bb0.7,1.3\u00bc, (A.16)\n\u00bb\ud835\udc4e22\u0000\ud835\udc5f2,\ud835\udc4e22\u00b8\ud835\udc5f2\u00bc=\u00bb2.4,3.6\u00bc, (A.17)\n\u00bb\ud835\udc4e33\u0000\ud835\udc5f3,\ud835\udc4e33\u00b8\ud835\udc5f3\u00bc=\u00bb4.2,5.8\u00bc, (A.18)\n\u00bb\ud835\udc4e44\u0000\ud835\udc5f4,\ud835\udc4e44\u00b8\ud835\udc5f4\u00bc=\u00bb8.1,9.9\u00bc. (A.19)\nPerforming the numerical computation shows that the eigenvalues are approximately 0.99,\n2.97,4.95,9.08, all comfortably inside the ranges provided.\nA=torch .tensor([[ 1.0,0.1,0.1,0.1],\n[0.1,3.0,0.2,0.3],\n[0.1,0.2,5.0,0.5],\n[0.1,0.3,0.5,9.0]])\nv, _ =torch .linalg .eig(A)\nv\ntensor([ 0.9923 +0.j,9.0803 +0.j,4.9539 +0.j,2.9734 +0.j])\nInthisway,eigenvaluescanbeapproximated,andtheapproximationswillbefairlyaccurate\nin the case that the diagonal is significantly larger than all the other elements.\nIt is a small thing, but with a complex and subtle topic like eigendecomposition, it is good\nto get any intuitive grasp we can.\nA.2.6AUseful Application: The Growthof Iterated Maps\nNow that we understand what eigenvectors are in principle, let\u2019s see how they can be used\nto provide a deep understanding of a problem central to neural network behavior: proper\nweight initialization.\n919 Eigendecompositions\nEigenvectorsas Long TermBehavior\nThe full mathematical investigation of the initialization of deep neural networks is beyond\nthe scope of the text, but we can see a toy version here to understand how eigenvalues can\nhelp us see how these models work. As we know, neural networks operate by interspersing\nlayers of linear transformations with non-linear operations. For simplicity here, we will\nassumethatthereisnonon-linearity,andthatthetransformationisasinglerepeatedmatrix\noperation\ud835\udc34, so that the output of our model is\nv\ud835\udc5c\ud835\udc62\ud835\udc61=A\u0001A\u0001\u0001\u0001Av\ud835\udc56\ud835\udc5b=A\ud835\udc41v\ud835\udc56\ud835\udc5b. (A.20)\nWhen these models are initialized, \ud835\udc34is taken to be a random matrix with Gaussian entries,\nsolet\u2019smakeoneofthose. Tobeconcrete,westartwithameanzero,varianceoneGaussian\ndistributed 5\u00025matrix.", "mimetype": "text/plain", "start_char_idx": 1909998, "end_char_idx": 1912564, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fe5c83f0-d7ae-46c0-8331-c20472872894": {"__data__": {"id_": "fe5c83f0-d7ae-46c0-8331-c20472872894", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "00a98829-b011-4567-8ce2-ad6343d89dbf", "node_type": "1", "metadata": {}, "hash": "b679fe8e9025096d57c9cce6712306bac7f89b3f032218cb2f3498da5ec12b22", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "96b22698-fad4-44ac-857b-96b268f674b5", "node_type": "1", "metadata": {}, "hash": "2cda572fad13623f2ad1fa0b98b28978e60dfdba32c79bee6b82c9d72439a047", "class_name": "RelatedNodeInfo"}}, "text": "As we know, neural networks operate by interspersing\nlayers of linear transformations with non-linear operations. For simplicity here, we will\nassumethatthereisnonon-linearity,andthatthetransformationisasinglerepeatedmatrix\noperation\ud835\udc34, so that the output of our model is\nv\ud835\udc5c\ud835\udc62\ud835\udc61=A\u0001A\u0001\u0001\u0001Av\ud835\udc56\ud835\udc5b=A\ud835\udc41v\ud835\udc56\ud835\udc5b. (A.20)\nWhen these models are initialized, \ud835\udc34is taken to be a random matrix with Gaussian entries,\nsolet\u2019smakeoneofthose. Tobeconcrete,westartwithameanzero,varianceoneGaussian\ndistributed 5\u00025matrix.\ntorch .manual_seed( 42)\nk=5\nA=torch .randn(k, k, dtype =torch .float64)\nA\ntensor([[ 0.2996 ,0.2424 ,0.2832 ,-0.2329 ,0.6712 ],\n[0.7818 ,-1.7903 ,-1.7484 ,0.1735 ,-0.1182 ],\n[-1.7446 ,-0.4695 ,0.4573 ,0.5177 ,-0.2771 ],\n[-0.6641 ,0.6551 ,0.2616 ,-1.5265 ,-0.3311 ],\n[-0.6378 ,0.1072 ,0.7096 ,0.3009 ,-0.2869 ]], dtype =torch .float64)\nBehavioron Random Data\nFor simplicity in our toy model, we will assume that the data vector we feed in v\ud835\udc56\ud835\udc5bis a\nrandom five dimensional Gaussian vector. Let\u2019s think about what we want to have happen.\nForcontext,letsthinkofagenericMLproblem,wherewearetryingtoturninputdata,like\nan image, into a prediction, like the probability the image is a picture of a cat. If repeated\napplication of Astretches a random vector out to be very long, then small changes in input\nwillbeamplifiedintolargechangesinoutput\u2014tinymodificationsoftheinputimagewould\nlead to vastly different predictions. This does not seem right!\nOntheflipside,if Ashrinksrandomvectorstobeshorter,thenafterrunningthroughmany\nlayers, the vector will essentially shrink to nothing, and the output will not depend on the\ninput. This is also clearly not right either!\nWe need to walk the narrow line between growth and decay to make sure that our output\nchanges depending on our input, but not much!\nLet\u2019s see what happens when we repeatedly multiply our matrix Aagainst a random input\nvector, and keep track of the norm.\n920 Mathematics for Deep Learning\n# Calculate the sequence of norms after repeatedly applying `A`\nv_in =torch .randn(k, 1, dtype =torch .float64)\nnorm_list =[torch .norm(v_in) .item()]\nfor iinrange (1,100):\nv_in =A@v_in\nnorm_list .append(torch .norm(v_in) .item())\nd2l.plot(torch .arange( 0,100), norm_list, 'Iteration ','Value ')\nThe norm is growing uncontrollably! Indeed if we take the list of quotients, we will see a\npattern.\n# Compute the scaling factor of the norms\nnorm_ratio_list =[]\nfor iinrange (1,100):\nnorm_ratio_list .append(norm_list[i] /norm_list[i -1])\nd2l.plot(torch .arange( 1,100), norm_ratio_list, 'Iteration ','Ratio ')\nIf we look at the last portion of the above computation, we see that the random vector is\nstretched by a factor of 1.974459321485[...] , where the portion at the end shifts a little,\nbut the stretching factor is stable.\n921 Eigendecompositions\nRelatingBackto Eigenvectors\nWe have seen that eigenvectors and eigenvalues correspond to the amount something is\nstretched, but that was for specific vectors, and specific stretches. Let\u2019s take a look at what\nthey are for A. A bit of a caveat here: it turns out that to see them all, we will need to go\nto complex numbers. You can think of these as stretches and rotations. By taking the norm\nof the complex number (square root of the sums of squares of real and imaginary parts) we\ncan measure that stretching factor. Let\u2019s also sort them.", "mimetype": "text/plain", "start_char_idx": 1912074, "end_char_idx": 1915400, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "96b22698-fad4-44ac-857b-96b268f674b5": {"__data__": {"id_": "96b22698-fad4-44ac-857b-96b268f674b5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fe5c83f0-d7ae-46c0-8331-c20472872894", "node_type": "1", "metadata": {}, "hash": "8199043aeb7a26ee7e7043f646596b5e0aee20a8a564f12ac6ec66b6734d4e36", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "409ac874-db56-4595-8e2b-3b30bd458cda", "node_type": "1", "metadata": {}, "hash": "1171eb0b2a782fae7fb82a97fffc466885fbc287809688387500dd7fc86af036", "class_name": "RelatedNodeInfo"}}, "text": "921 Eigendecompositions\nRelatingBackto Eigenvectors\nWe have seen that eigenvectors and eigenvalues correspond to the amount something is\nstretched, but that was for specific vectors, and specific stretches. Let\u2019s take a look at what\nthey are for A. A bit of a caveat here: it turns out that to see them all, we will need to go\nto complex numbers. You can think of these as stretches and rotations. By taking the norm\nof the complex number (square root of the sums of squares of real and imaginary parts) we\ncan measure that stretching factor. Let\u2019s also sort them.\n# Compute the eigenvalues\neigs =torch .linalg .eig(A) .eigenvalues .tolist()\nnorm_eigs =[torch .abs(torch .tensor(x)) for xineigs]\nnorm_eigs .sort()\nprint (f'norms of eigenvalues: {norm_eigs }')\nnorms of eigenvalues: [tensor( 0.3490 ), tensor( 1.1296 ), tensor( 1.1296 ),\u2423\n\u21a9!tensor( 1.1828 ), tensor( 2.4532 )]\nAnObservation\nWeseesomethingabitunexpectedhappeninghere: thatnumberweidentifiedbeforeforthe\nlongtermstretchingofourmatrix Aappliedtoarandomvectoris exactly(accuratetothir-\nteendecimalplaces!) thelargesteigenvalueof A. Thisisclearlynotacoincidence!\nBut,ifwenowthinkaboutwhatishappeninggeometrically,thisstartstomakesense. Con-\nsiderarandomvector. Thisrandomvectorpointsalittleineverydirection,soinparticular,\nit points at least a little bit in the same direction as the eigenvector of Aassociated with\nthe largest eigenvalue. This is so important that it is called the principle eigenvalue and\nprinciple eigenvector . After applying A, our random vector gets stretched in every possi-\nble direction, as is associated with every possible eigenvector, but it is stretched most of\nall in the direction associated with this principle eigenvector. What this means is that after\napply in\ud835\udc34, our random vector is longer, and points in a direction closer to being aligned\nwith the principle eigenvector. After applying the matrix many times, the alignment with\nthe principle eigenvector becomes closer and closer until, for all practical purposes, our\nrandom vector has been transformed into the principle eigenvector! Indeed this algorithm\nis the basis for what is known as the power iteration for finding the largest eigenvalue and\neigenvector of a matrix. For details see, for example, ( Golub and Van Loan, 1996 ).\nFixing the Normalization\nNow, from above discussions, we concluded that we do not want a random vector to be\nstretched or squished at all, we would like random vectors to stay about the same size\nthroughout the entire process. To do so, we now rescale our matrix by this principle eigen-\nvalue so that the largest eigenvalue is instead now just one. Let\u2019s see what happens in this\ncase.\n922 Mathematics for Deep Learning\n# Rescale the matrix `A`\nA/=norm_eigs[ -1]\n# Do the same experiment again\nv_in =torch .randn(k, 1, dtype =torch .float64)\nnorm_list =[torch .norm(v_in) .item()]\nfor iinrange (1,100):\nv_in =A@v_in\nnorm_list .append(torch .norm(v_in) .item())\nd2l.plot(torch .arange( 0,100), norm_list, 'Iteration ','Value ')\nWe can also plot the ratio between consecutive norms as before and see that indeed it sta-\nbilizes.\n# Also plot the ratio\nnorm_ratio_list =[]\nfor iinrange (1,100):\nnorm_ratio_list .append(norm_list[i] /norm_list[i -1])\nd2l.plot(torch .arange( 1,100), norm_ratio_list, 'Iteration ','Ratio ')\nA.2.7Discussion\nWe now see exactly what we hoped for! After normalizing the matrices by the principal\neigenvalue, we see that the random data does not explode as before, but rather eventually\nequilibrates to a specific value.", "mimetype": "text/plain", "start_char_idx": 1914836, "end_char_idx": 1918365, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "409ac874-db56-4595-8e2b-3b30bd458cda": {"__data__": {"id_": "409ac874-db56-4595-8e2b-3b30bd458cda", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "96b22698-fad4-44ac-857b-96b268f674b5", "node_type": "1", "metadata": {}, "hash": "2cda572fad13623f2ad1fa0b98b28978e60dfdba32c79bee6b82c9d72439a047", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6e0c28b6-a032-4435-b6f1-a6bd8d31aa58", "node_type": "1", "metadata": {}, "hash": "cf88a8581d5eb394fe4c80f6b995318a76cf55e361f83fc4059c5b6f3041d67d", "class_name": "RelatedNodeInfo"}}, "text": "# Also plot the ratio\nnorm_ratio_list =[]\nfor iinrange (1,100):\nnorm_ratio_list .append(norm_list[i] /norm_list[i -1])\nd2l.plot(torch .arange( 1,100), norm_ratio_list, 'Iteration ','Ratio ')\nA.2.7Discussion\nWe now see exactly what we hoped for! After normalizing the matrices by the principal\neigenvalue, we see that the random data does not explode as before, but rather eventually\nequilibrates to a specific value. It would be nice to be able to do these things from first\n923 Eigendecompositions\n281principles, and it turns out that if we look deeply at the mathematics of it, we can see that\nthe largest eigenvalue of a large random matrix with independent mean zero, variance one\nGaussian entries is on average aboutp\ud835\udc5b, or in our casep\n5\u00192.2, due to a fascinating fact\nknown as the circularlaw (Ginibre, 1965 ). The relationship between the eigenvalues (and\na related object called singular values) of random matrices has been shown to have deep\nconnections to proper initialization of neural networks as was discussed in Pennington et\nal.(2017) and subsequent works.\nA.2.8Summary\n\u000fEigenvectors are vectors which are stretched by a matrix without changing direction.\n\u000fEigenvalues are the amount that the eigenvectors are stretched by the application of the\nmatrix.\n\u000fThe eigendecomposition of a matrix can allow for many operations to be reduced to\noperations on the eigenvalues.\n\u000fThe Gershgorin Circle Theorem can provide approximate values for the eigenvalues of\na matrix.\n\u000fThebehaviorofiteratedmatrixpowersdependsprimarilyonthesizeofthelargesteigen-\nvalue. This understanding has many applications in the theory of neural network ini-\ntialization.\nA.2.9Exercises\n1.What are the eigenvalues and eigenvectors of\nA=\u00142 1\n1 2\u0015\n? (A.21)\n2.What are the eigenvalues and eigenvectors of the following matrix, and what is strange\nabout this example compared to the previous one?\nA=\u00142 1\n0 2\u0015\n. (A.22)\n3.Without computing the eigenvalues, is it possible that the smallest eigenvalue of the\nfollowing matrix is less that 0.5?Note: this problem can be done in your head.\nA=266666643.0 0.1 0.3 1.0\n0.1 1.0 0.1 0.2\n0.3 0.1 5.0 0.0\n1.0 0.2 0.0 1.837777775. (A.23)\nDiscussions281.\n924 Mathematics for Deep Learning\nA.3SingleVariableCalculus\nInSection 2.4 , we saw the basic elements of differential calculus. This section takes a\ndeeper dive into the fundamentals of calculus and how we can understand and apply it in\nthe context of machine learning.\nA.3.1DifferentialCalculus\nDifferentialcalculusisfundamentallythestudyofhowfunctionsbehaveundersmallchanges.\nTo see why this is so core to deep learning, let\u2019s consider an example.\nSuppose that we have a deep neural network where the weights are, for convenience, con-\ncatenated into a single vector w=\u00b9\ud835\udc641,...,\ud835\udc64\ud835\udc5b\u00ba. Given a training dataset, we consider the\nloss of our neural network on this dataset, which we will write as L\u00b9w\u00ba.\nThis function is extraordinarily complex, encoding the performance of all possible models\nofthegivenarchitectureonthisdataset,soitisnearlyimpossibletotellwhatsetofweights\nwwill minimize the loss. Thus, in practice, we often start by initializing our weights ran-\ndomly, and then iteratively take small steps in the direction which makes the loss decrease\nas rapidly as possible.\nThe question then becomes something that on the surface is no easier: how do we find\nthe direction which makes the weights decrease as quickly as possible? To dig into this,\nlet\u2019s first examine the case with only a single weight: \ud835\udc3f\u00b9w\u00ba=\ud835\udc3f\u00b9\ud835\udc65\u00bafor a single real value\n\ud835\udc65.\nLet\u2019s take\ud835\udc65and try to understand what happens when we change it by a small amount to\n\ud835\udc65\u00b8\ud835\udf16. If you wish to be concrete, think a number like \ud835\udf16=0.0000001 .", "mimetype": "text/plain", "start_char_idx": 1917949, "end_char_idx": 1921614, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6e0c28b6-a032-4435-b6f1-a6bd8d31aa58": {"__data__": {"id_": "6e0c28b6-a032-4435-b6f1-a6bd8d31aa58", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "409ac874-db56-4595-8e2b-3b30bd458cda", "node_type": "1", "metadata": {}, "hash": "1171eb0b2a782fae7fb82a97fffc466885fbc287809688387500dd7fc86af036", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c4245eef-9049-4d32-8165-c2b9470186b4", "node_type": "1", "metadata": {}, "hash": "04dd1ffde3bf68ad7b4c144450f69f88ca7413d609f3e6f499744a9d58656898", "class_name": "RelatedNodeInfo"}}, "text": "Thus, in practice, we often start by initializing our weights ran-\ndomly, and then iteratively take small steps in the direction which makes the loss decrease\nas rapidly as possible.\nThe question then becomes something that on the surface is no easier: how do we find\nthe direction which makes the weights decrease as quickly as possible? To dig into this,\nlet\u2019s first examine the case with only a single weight: \ud835\udc3f\u00b9w\u00ba=\ud835\udc3f\u00b9\ud835\udc65\u00bafor a single real value\n\ud835\udc65.\nLet\u2019s take\ud835\udc65and try to understand what happens when we change it by a small amount to\n\ud835\udc65\u00b8\ud835\udf16. If you wish to be concrete, think a number like \ud835\udf16=0.0000001 . To help us visualize\nwhat happens, let\u2019s graph an example function, \ud835\udc53\u00b9\ud835\udc65\u00ba=sin\u00b9\ud835\udc65\ud835\udc65\u00ba, over the\u00bb0,3\u00bc.\n%matplotlib inline\nimport torch\nfrom IPython import display\nfrom d2l import torch asd2l\ntorch .pi=torch .acos(torch .zeros( 1)).item() *2# Define pi in torch\n# Plot a function in a normal range\nx_big =torch .arange( 0.01 ,3.01 ,0.01 )\nys=torch .sin(x_big **x_big)\nd2l.plot(x_big, ys, 'x','f(x) ')\nAtthislargescale,thefunction\u2019sbehaviorisnotsimple. However,ifwereduceourrangeto\nsomething smaller like \u00bb1.75,2.25\u00bc, we see that the graph becomes much simpler.\n# Plot a the same function in a tiny range\nx_med =torch .arange( 1.75 ,2.25 ,0.001 )\n(continues on next page)\n925 Single Variable Calculus\n(continued from previous page)\nys=torch .sin(x_med **x_med)\nd2l.plot(x_med, ys, 'x','f(x) ')\nTakingthistoanextreme,ifwezoomintoatinysegment,thebehaviorbecomesfarsimpler:\nit is just a straight line.\n# Plot a the same function in a tiny range\nx_small =torch .arange( 2.0,2.01 ,0.0001 )\nys=torch .sin(x_small **x_small)\nd2l.plot(x_small, ys, 'x','f(x) ')\nThis is the key observation of single variable calculus: the behavior of familiar functions\ncan be modeled by a line in a small enough range. This means that for most functions, it\nis reasonable to expect that as we shift the \ud835\udc65value of the function by a little bit, the output\n\ud835\udc53\u00b9\ud835\udc65\u00bawillalsobeshiftedbyalittlebit. Theonlyquestionweneedtoansweris, \u201cHowlarge\n926 Mathematics for Deep Learning\nis the change in the output compared to the change in the input? Is it half as large? Twice\nas large?\u201d\nThus, we can consider the ratio of the change in the output of a function for a small change\nin the input of the function. We can write this formally as\n\ud835\udc3f\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\u0000\ud835\udc3f\u00b9\ud835\udc65\u00ba\n\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\u0000\ud835\udc65=\ud835\udc3f\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\u0000\ud835\udc3f\u00b9\ud835\udc65\u00ba\n\ud835\udf16. (A.1)\nThis is already enough to start to play around with in code. For instance, suppose that we\nknow that\ud835\udc3f\u00b9\ud835\udc65\u00ba=\ud835\udc652\u00b81701\u00b9\ud835\udc65\u00004\u00ba3, then we can see how large this value is at the point\n\ud835\udc65=4as follows.\n# Define our function\ndef L(x):\nreturn x**2+1701 *(x-4)**3\n# Print the difference divided by epsilon for several epsilon\nfor epsilon in[0.1,0.001 ,0.0001 ,0.00001 ]:\nprint (f'epsilon = {epsilon :.5f}->{(L(4+epsilon) -L(4))/epsilon :.5f}')\nepsilon =0.10000 ->25.11000\nepsilon =0.00100 ->8.00270\nepsilon =0.00010 ->8.00012\nepsilon =0.00001 ->8.00001\nNow,ifweareobservant,wewillnoticethattheoutputofthisnumberissuspiciouslyclose\nto8. Indeed,ifwedecrease \ud835\udf16,wewillseevaluebecomesprogressivelycloserto 8.", "mimetype": "text/plain", "start_char_idx": 1921014, "end_char_idx": 1924032, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c4245eef-9049-4d32-8165-c2b9470186b4": {"__data__": {"id_": "c4245eef-9049-4d32-8165-c2b9470186b4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6e0c28b6-a032-4435-b6f1-a6bd8d31aa58", "node_type": "1", "metadata": {}, "hash": "cf88a8581d5eb394fe4c80f6b995318a76cf55e361f83fc4059c5b6f3041d67d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9d0f09ce-7f75-4b77-8bba-45919deb553b", "node_type": "1", "metadata": {}, "hash": "70fc432b69d715cf741530c20df9b72800b23d7ded3bdb2dcdd7ef6f7c6f6f0e", "class_name": "RelatedNodeInfo"}}, "text": "# Define our function\ndef L(x):\nreturn x**2+1701 *(x-4)**3\n# Print the difference divided by epsilon for several epsilon\nfor epsilon in[0.1,0.001 ,0.0001 ,0.00001 ]:\nprint (f'epsilon = {epsilon :.5f}->{(L(4+epsilon) -L(4))/epsilon :.5f}')\nepsilon =0.10000 ->25.11000\nepsilon =0.00100 ->8.00270\nepsilon =0.00010 ->8.00012\nepsilon =0.00001 ->8.00001\nNow,ifweareobservant,wewillnoticethattheoutputofthisnumberissuspiciouslyclose\nto8. Indeed,ifwedecrease \ud835\udf16,wewillseevaluebecomesprogressivelycloserto 8. Thuswe\nmay conclude, correctly, that the value we seek (the degree a change in the input changes\nthe output) should be 8at the point\ud835\udc65=4. The way that a mathematician encodes this fact\nis\nlim\n\ud835\udf16!0\ud835\udc3f\u00b94\u00b8\ud835\udf16\u00ba\u0000\ud835\udc3f\u00b94\u00ba\n\ud835\udf16=8. (A.2)\nAs a bit of a historical digression: in the first few decades of neural network research, sci-\nentists used this algorithm (the methodoffinitedifferences ) to evaluate how a loss function\nchanged under small perturbation: just change the weights and see how the loss changed.\nThisiscomputationallyinefficient,requiringtwoevaluationsofthelossfunctiontoseehow\na single change of one variable influenced the loss. If we tried to do this with even a pal-\ntry few thousand parameters, it would require several thousand evaluations of the network\nover the entire dataset! It was not solved until 1986 that the backpropagation algorithm\nintroduced in Rumelhart et al.(1988) provided a way to calculate how anychange of the\nweightstogetherwouldchangethelossinthesamecomputationtimeasasingleprediction\nof the network over the dataset.\nBack in our example, this value 8is different for different values of \ud835\udc65, so it makes sense to\ndefine it as a function of \ud835\udc65. More formally, this value dependent rate of change is referred\nto as thederivative which is written as\n\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba=lim\n\ud835\udf16!0\ud835\udc53\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\u0000\ud835\udc53\u00b9\ud835\udc65\u00ba\n\ud835\udf16. (A.3)\n927 Single Variable Calculus\nDifferent texts will use different notations for the derivative. For instance, all of the below\nnotations indicate the same thing:\n\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65=\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc53=\ud835\udc530=r\ud835\udc65\ud835\udc53=\ud835\udc37\ud835\udc65\ud835\udc53=\ud835\udc53\ud835\udc65. (A.4)\nMost authors will pick a single notation and stick with it, however even that is not guaran-\nteed. It is best to be familiar with all of these. We will use the notation\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65throughout this\ntext, unless we want to take the derivative of a complex expression, in which case we will\nuse\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc53to write expressions like\n\ud835\udc51\n\ud835\udc51\ud835\udc65\u0014\n\ud835\udc654\u00b8cos\u0012\ud835\udc652\u00b81\n2\ud835\udc65\u00001\u0013\u0015\n.", "mimetype": "text/plain", "start_char_idx": 1923534, "end_char_idx": 1925873, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9d0f09ce-7f75-4b77-8bba-45919deb553b": {"__data__": {"id_": "9d0f09ce-7f75-4b77-8bba-45919deb553b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c4245eef-9049-4d32-8165-c2b9470186b4", "node_type": "1", "metadata": {}, "hash": "04dd1ffde3bf68ad7b4c144450f69f88ca7413d609f3e6f499744a9d58656898", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6a66994f-4d49-405c-a29c-a9d5f871913c", "node_type": "1", "metadata": {}, "hash": "91c231a3bac343794249bdeefc8547f3a51ebc574e3440e03cb863b4d87722e5", "class_name": "RelatedNodeInfo"}}, "text": "(A.4)\nMost authors will pick a single notation and stick with it, however even that is not guaran-\nteed. It is best to be familiar with all of these. We will use the notation\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65throughout this\ntext, unless we want to take the derivative of a complex expression, in which case we will\nuse\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc53to write expressions like\n\ud835\udc51\n\ud835\udc51\ud835\udc65\u0014\n\ud835\udc654\u00b8cos\u0012\ud835\udc652\u00b81\n2\ud835\udc65\u00001\u0013\u0015\n. (A.5)\nOftentimes, it is intuitively useful to unravel the definition of derivative (A.3)again to see\nhow a function changes when we make a small change of \ud835\udc65:\n\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba=lim\n\ud835\udf16!0\ud835\udc53\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\u0000\ud835\udc53\u00b9\ud835\udc65\u00ba\n\ud835\udf16=)\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u0019\ud835\udc53\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\u0000\ud835\udc53\u00b9\ud835\udc65\u00ba\n\ud835\udf16\n=)\ud835\udf16\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u0019\ud835\udc53\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\u0000\ud835\udc53\u00b9\ud835\udc65\u00ba\n=)\ud835\udc53\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\u0019\ud835\udc53\u00b9\ud835\udc65\u00ba\u00b8\ud835\udf16\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba.(A.6)\nThe last equation is worth explicitly calling out. It tells us that if you take any function and\nchange the input by a small amount, the output would change by that small amount scaled\nby the derivative.\nIn this way, we can understand the derivative as the scaling factor that tells us how large of\nchange we get in the output from a change in the input.\nA.3.2Rulesof Calculus\nWe now turn to the task of understanding how to compute the derivative of an explicit\nfunction. A full formal treatment of calculus would derive everything from first principles.\nWe will not indulge in this temptation here, but rather provide an understanding of the\ncommon rules encountered.\nCommon Derivatives\nAs was seen in Section 2.4 , when computing derivatives one can oftentimes use a series of\nrules to reduce the computation to a few core functions. We repeat them here for ease of\nreference.\n\u000fDerivativeof constants.\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc50=0.\n\u000fDerivativeof linear functions.\ud835\udc51\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc4e\ud835\udc65\u00ba=\ud835\udc4e.\n\u000fPowerrule.\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc65\ud835\udc5b=\ud835\udc5b\ud835\udc65\ud835\udc5b\u00001.\n\u000fDerivativeof exponentials.\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc52\ud835\udc65=\ud835\udc52\ud835\udc65.\n\u000fDerivativeof the logarithm.\ud835\udc51\n\ud835\udc51\ud835\udc65log\u00b9\ud835\udc65\u00ba=1\n\ud835\udc65.\n928 Mathematics for Deep Learning\nDerivativeRules\nIf every derivative needed to be separately computed and stored in a table, differential cal-\nculus would be near impossible. It is a gift of mathematics that we can generalize the\nabove derivatives and compute more complex derivatives like finding the derivative of\n\ud835\udc53\u00b9\ud835\udc65\u00ba=log\u00001\u00b8\u00b9\ud835\udc65\u00001\u00ba10\u0001. As was mentioned in Section 2.4 , the key to doing so is to\ncodify what happens when we take functions and combine them in various ways, most\nimportantly: sums, products, and compositions.\n\u000fSum rule.\ud835\udc51\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc54\u00b9\ud835\udc65\u00ba\u00b8\u210e\u00b9\ud835\udc65\u00ba\u00ba=\ud835\udc51\ud835\udc54\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u00b8\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba.\n\u000fProductrule.\ud835\udc51\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc54\u00b9\ud835\udc65\u00ba\u0001\u210e\u00b9\ud835\udc65\u00ba\u00ba=\ud835\udc54\u00b9\ud835\udc65\u00ba\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u00b8\ud835\udc51\ud835\udc54\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u210e\u00b9\ud835\udc65\u00ba.", "mimetype": "text/plain", "start_char_idx": 1925527, "end_char_idx": 1927830, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6a66994f-4d49-405c-a29c-a9d5f871913c": {"__data__": {"id_": "6a66994f-4d49-405c-a29c-a9d5f871913c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9d0f09ce-7f75-4b77-8bba-45919deb553b", "node_type": "1", "metadata": {}, "hash": "70fc432b69d715cf741530c20df9b72800b23d7ded3bdb2dcdd7ef6f7c6f6f0e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "38624caa-3343-41bb-9b59-1701438b4e39", "node_type": "1", "metadata": {}, "hash": "c10291031fae8931b08407452f9ec80e763022fd8870c97c143c34f315b2350e", "class_name": "RelatedNodeInfo"}}, "text": "\u000fSum rule.\ud835\udc51\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc54\u00b9\ud835\udc65\u00ba\u00b8\u210e\u00b9\ud835\udc65\u00ba\u00ba=\ud835\udc51\ud835\udc54\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u00b8\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba.\n\u000fProductrule.\ud835\udc51\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc54\u00b9\ud835\udc65\u00ba\u0001\u210e\u00b9\ud835\udc65\u00ba\u00ba=\ud835\udc54\u00b9\ud835\udc65\u00ba\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u00b8\ud835\udc51\ud835\udc54\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u210e\u00b9\ud835\udc65\u00ba.\n\u000fChain rule.\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc54\u00b9\u210e\u00b9\ud835\udc65\u00ba\u00ba=\ud835\udc51\ud835\udc54\n\ud835\udc51\u210e\u00b9\u210e\u00b9\ud835\udc65\u00ba\u00ba\u0001\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba.\nLet\u2019s see how we may use (A.6)to understand these rules. For the sum rule, consider\nfollowing chain of reasoning:\n\ud835\udc53\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba=\ud835\udc54\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\u00b8\u210e\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\n\u0019\ud835\udc54\u00b9\ud835\udc65\u00ba\u00b8\ud835\udf16\ud835\udc51\ud835\udc54\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u00b8\u210e\u00b9\ud835\udc65\u00ba\u00b8\ud835\udf16\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\n=\ud835\udc54\u00b9\ud835\udc65\u00ba\u00b8\u210e\u00b9\ud835\udc65\u00ba\u00b8\ud835\udf16\u0012\ud835\udc51\ud835\udc54\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u00b8\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u0013\n=\ud835\udc53\u00b9\ud835\udc65\u00ba\u00b8\ud835\udf16\u0012\ud835\udc51\ud835\udc54\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u00b8\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u0013\n.(A.7)\nBy comparing this result with the fact that \ud835\udc53\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\u0019\ud835\udc53\u00b9\ud835\udc65\u00ba\u00b8\ud835\udf16\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba, we see that\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba=\n\ud835\udc51\ud835\udc54\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u00b8\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00baasdesired. Theintuitionhereis: whenwechangetheinput \ud835\udc65,\ud835\udc54and\u210ejointly\ncontribute to the change of the output by\ud835\udc51\ud835\udc54\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00baand\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba.\nThe product is more subtle, and will require a new observation about how to work with\nthese expressions.", "mimetype": "text/plain", "start_char_idx": 1927730, "end_char_idx": 1928447, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "38624caa-3343-41bb-9b59-1701438b4e39": {"__data__": {"id_": "38624caa-3343-41bb-9b59-1701438b4e39", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6a66994f-4d49-405c-a29c-a9d5f871913c", "node_type": "1", "metadata": {}, "hash": "91c231a3bac343794249bdeefc8547f3a51ebc574e3440e03cb863b4d87722e5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e5c01dda-7094-44b3-9da5-abe2ec0aa7f2", "node_type": "1", "metadata": {}, "hash": "4fad0c0a0b2cf5366977a4e1d7a86913ee9be4dead26f74ea3ac1acb40682dce", "class_name": "RelatedNodeInfo"}}, "text": "Theintuitionhereis: whenwechangetheinput \ud835\udc65,\ud835\udc54and\u210ejointly\ncontribute to the change of the output by\ud835\udc51\ud835\udc54\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00baand\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba.\nThe product is more subtle, and will require a new observation about how to work with\nthese expressions. We will begin as before using (A.6):\n\ud835\udc53\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba=\ud835\udc54\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\u0001\u210e\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\n\u0019\u0012\n\ud835\udc54\u00b9\ud835\udc65\u00ba\u00b8\ud835\udf16\ud835\udc51\ud835\udc54\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u0013\n\u0001\u0012\n\u210e\u00b9\ud835\udc65\u00ba\u00b8\ud835\udf16\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u0013\n=\ud835\udc54\u00b9\ud835\udc65\u00ba\u0001\u210e\u00b9\ud835\udc65\u00ba\u00b8\ud835\udf16\u0012\n\ud835\udc54\u00b9\ud835\udc65\u00ba\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u00b8\ud835\udc51\ud835\udc54\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u210e\u00b9\ud835\udc65\u00ba\u0013\n\u00b8\ud835\udf162\ud835\udc51\ud835\udc54\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\n=\ud835\udc53\u00b9\ud835\udc65\u00ba\u00b8\ud835\udf16\u0012\n\ud835\udc54\u00b9\ud835\udc65\u00ba\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u00b8\ud835\udc51\ud835\udc54\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u210e\u00b9\ud835\udc65\u00ba\u0013\n\u00b8\ud835\udf162\ud835\udc51\ud835\udc54\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba.(A.8)\nThis resembles the computation done above, and indeed we see our answer (\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba=\n\ud835\udc54\u00b9\ud835\udc65\u00ba\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u00b8\ud835\udc51\ud835\udc54\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u210e\u00b9\ud835\udc65\u00ba) sitting next to \ud835\udf16, but there is the issue of that term of size \ud835\udf162.\nWe will refer to this as a higher-orderterm , since the power of \ud835\udf162is higher than the power\nof\ud835\udf161. We will see in a later section that we will sometimes want to keep track of these,\nhowever for now observe that if \ud835\udf16=0.0000001 , then\ud835\udf162=0.0000000000001 , which is\nvastly smaller. As we send \ud835\udf16!0, we may safely ignore the higher order terms. As a\ngeneral convention in this appendix, we will use \u201c \u0019\u201d to denote that the two terms are equal\n929 Single Variable Calculus\nup to higher order terms. However, if we wish to be more formal we may examine the\ndifference quotient\n\ud835\udc53\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\u0000\ud835\udc53\u00b9\ud835\udc65\u00ba\n\ud835\udf16=\ud835\udc54\u00b9\ud835\udc65\u00ba\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u00b8\ud835\udc51\ud835\udc54\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u210e\u00b9\ud835\udc65\u00ba\u00b8\ud835\udf16\ud835\udc51\ud835\udc54\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba, (A.9)\nand see that as we send \ud835\udf16!0, the right hand term goes to zero as well.", "mimetype": "text/plain", "start_char_idx": 1928225, "end_char_idx": 1929547, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e5c01dda-7094-44b3-9da5-abe2ec0aa7f2": {"__data__": {"id_": "e5c01dda-7094-44b3-9da5-abe2ec0aa7f2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "38624caa-3343-41bb-9b59-1701438b4e39", "node_type": "1", "metadata": {}, "hash": "c10291031fae8931b08407452f9ec80e763022fd8870c97c143c34f315b2350e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e15971d5-d03f-44cf-9bb7-77e06e78fd61", "node_type": "1", "metadata": {}, "hash": "04db4bc61878b6758c587e96ff7b07894f097711f3c085e734b8df16d757be57", "class_name": "RelatedNodeInfo"}}, "text": "However, if we wish to be more formal we may examine the\ndifference quotient\n\ud835\udc53\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\u0000\ud835\udc53\u00b9\ud835\udc65\u00ba\n\ud835\udf16=\ud835\udc54\u00b9\ud835\udc65\u00ba\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u00b8\ud835\udc51\ud835\udc54\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u210e\u00b9\ud835\udc65\u00ba\u00b8\ud835\udf16\ud835\udc51\ud835\udc54\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba, (A.9)\nand see that as we send \ud835\udf16!0, the right hand term goes to zero as well.\nFinally,withthechainrule,wecanagainprogressasbeforeusing (A.6)andseethat\n\ud835\udc53\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba=\ud835\udc54\u00b9\u210e\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\u00ba\n\u0019\ud835\udc54\u0012\n\u210e\u00b9\ud835\udc65\u00ba\u00b8\ud835\udf16\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\u0013\n\u0019\ud835\udc54\u00b9\u210e\u00b9\ud835\udc65\u00ba\u00ba\u00b8\ud835\udf16\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\ud835\udc51\ud835\udc54\n\ud835\udc51\u210e\u00b9\u210e\u00b9\ud835\udc65\u00ba\u00ba\n=\ud835\udc53\u00b9\ud835\udc65\u00ba\u00b8\ud835\udf16\ud835\udc51\ud835\udc54\n\ud835\udc51\u210e\u00b9\u210e\u00b9\ud835\udc65\u00ba\u00ba\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba,(A.10)\nwhere in the second line we view the function \ud835\udc54as having its input ( \u210e\u00b9\ud835\udc65\u00ba) shifted by the\ntiny quantity \ud835\udf16\ud835\udc51\u210e\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba.\nThese rule provide us with a flexible set of tools to compute essentially any expression\ndesired. For instance,\n\ud835\udc51\n\ud835\udc51\ud835\udc65h\nlog\u0010\n1\u00b8\u00b9\ud835\udc65\u00001\u00ba10\u0011i\n=\u0010\n1\u00b8\u00b9\ud835\udc65\u00001\u00ba10\u0011\u00001\ud835\udc51\n\ud835\udc51\ud835\udc65\u0002\n1\u00b8\u00b9\ud835\udc65\u00001\u00ba10\u0003\n=\u0010\n1\u00b8\u00b9\ud835\udc65\u00001\u00ba10\u0011\u00001\u0012\ud835\udc51\n\ud835\udc51\ud835\udc65\u00bb1\u00bc\u00b8\ud835\udc51\n\ud835\udc51\ud835\udc65\u00bb\u00b9\ud835\udc65\u00001\u00ba10\u00bc\u0013\n=\u0010\n1\u00b8\u00b9\ud835\udc65\u00001\u00ba10\u0011\u00001\u0012\n0\u00b810\u00b9\ud835\udc65\u00001\u00ba9\ud835\udc51\n\ud835\udc51\ud835\udc65\u00bb\ud835\udc65\u00001\u00bc\u0013\n=10\u0010\n1\u00b8\u00b9\ud835\udc65\u00001\u00ba10\u0011\u00001\n\u00b9\ud835\udc65\u00001\u00ba9\n=10\u00b9\ud835\udc65\u00001\u00ba9\n1\u00b8\u00b9\ud835\udc65\u00001\u00ba10.(A.11)\nWhere each line has used the following rules:\n1.The chain rule and derivative of logarithm.\n2.The sum rule.\n3.The derivative of constants, chain rule, and power rule.\n4.The sum rule, derivative of linear functions, derivative of constants.\nTwo things should be clear after doing this example:\n1.Anyfunctionwecanwritedownusingsums,products,constants,powers,exponentials,\nand logarithms can have its derivate computed mechanically by following these rules.\n2.Having a human follow these rules can be tedious and error prone!\nThankfully, these two facts together hint towards a way forward: this is a perfect candidate\n930 Mathematics for Deep Learning\nfor mechanization! Indeed backpropagation, which we will revisit later in this section, is\nexactly that.\nLinear Approximation\nWhenworkingwithderivatives, itis oftenusefultogeometricallyinterprettheapproxima-\ntion used above. In particular, note that the equation\n\ud835\udc53\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\u0019\ud835\udc53\u00b9\ud835\udc65\u00ba\u00b8\ud835\udf16\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba, (A.12)\napproximates the value of \ud835\udc53by a line which passes through the point \u00b9\ud835\udc65, \ud835\udc53\u00b9\ud835\udc65\u00ba\u00baand has\nslope\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba.", "mimetype": "text/plain", "start_char_idx": 1929335, "end_char_idx": 1931175, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e15971d5-d03f-44cf-9bb7-77e06e78fd61": {"__data__": {"id_": "e15971d5-d03f-44cf-9bb7-77e06e78fd61", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e5c01dda-7094-44b3-9da5-abe2ec0aa7f2", "node_type": "1", "metadata": {}, "hash": "4fad0c0a0b2cf5366977a4e1d7a86913ee9be4dead26f74ea3ac1acb40682dce", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "301868e2-73d9-4ebd-95d2-ab13bd73be75", "node_type": "1", "metadata": {}, "hash": "ba4c70ff137592b2fdec9f7e8ed5918f29ecc9a7dedb268c8f0b8b27ab1c3aba", "class_name": "RelatedNodeInfo"}}, "text": "Thankfully, these two facts together hint towards a way forward: this is a perfect candidate\n930 Mathematics for Deep Learning\nfor mechanization! Indeed backpropagation, which we will revisit later in this section, is\nexactly that.\nLinear Approximation\nWhenworkingwithderivatives, itis oftenusefultogeometricallyinterprettheapproxima-\ntion used above. In particular, note that the equation\n\ud835\udc53\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\u0019\ud835\udc53\u00b9\ud835\udc65\u00ba\u00b8\ud835\udf16\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba, (A.12)\napproximates the value of \ud835\udc53by a line which passes through the point \u00b9\ud835\udc65, \ud835\udc53\u00b9\ud835\udc65\u00ba\u00baand has\nslope\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba. In this way we say that the derivative gives a linear approximation to the\nfunction\ud835\udc53, as illustrated below:\n# Compute sin\nxs=torch .arange( -torch .pi, torch .pi, 0.01 )\nplots =[torch .sin(xs)]\n# Compute some linear approximations. Use d(sin(x))/dx = cos(x)\nfor x0in[-1.5,0.0,2.0]:\nplots .append(torch .sin(torch .tensor(x0)) +(xs -x0) *\ntorch .cos(torch .tensor(x0)))\nd2l.plot(xs, plots, 'x','f(x) ', ylim =[-1.5,1.5])\nHigherOrderDerivatives\nLet\u2019s now do something that may on the surface seem strange. Take a function \ud835\udc53and\ncompute the derivative\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65. This gives us the rate of change of \ud835\udc53at any point.\nHowever, the derivative,\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65, can be viewed as a function itself, so nothing stops us from\ncomputing the derivative of\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65to get\ud835\udc512\ud835\udc53\n\ud835\udc51\ud835\udc652=\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65\u0010\n\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65\u0011\n. We will call this the second deriva-\ntive of\ud835\udc53. This function is the rate of change of the rate of change of \ud835\udc53, or in other words,\nhow the rate of change is changing. We may apply the derivative any number of times to\nobtain what is called the \ud835\udc5b-th derivative. To keep the notation clean, we will denote the\n931 Single Variable Calculus\n\ud835\udc5b-th derivative as\n\ud835\udc53\u00b9\ud835\udc5b\u00ba\u00b9\ud835\udc65\u00ba=\ud835\udc51\ud835\udc5b\ud835\udc53\n\ud835\udc51\ud835\udc65\ud835\udc5b=\u0012\ud835\udc51\n\ud835\udc51\ud835\udc65\u0013\ud835\udc5b\n\ud835\udc53. (A.13)\nLet\u2019s try to understand whythis is a useful notion. Below, we visualize \ud835\udc53\u00b92\u00ba\u00b9\ud835\udc65\u00ba,\ud835\udc53\u00b91\u00ba\u00b9\ud835\udc65\u00ba,\nand\ud835\udc53\u00b9\ud835\udc65\u00ba.\nFirst,considerthecasethatthesecondderivative \ud835\udc53\u00b92\u00ba\u00b9\ud835\udc65\u00baisapositiveconstant. Thismeans\nthat the slope of the first derivative is positive. As a result, the first derivative \ud835\udc53\u00b91\u00ba\u00b9\ud835\udc65\u00bamay\nstart out negative, becomes zero at a point, and then becomes positive in the end. This tells\nustheslopeofouroriginalfunction \ud835\udc53andtherefore,thefunction \ud835\udc53itselfdecreases,flattens\nout, then increases. In other words, the function \ud835\udc53curves up, and has a single minimum as\nis shown in Fig. A.1.\ntFig. A.1 If we assume the second derivative is a positive constant, then the \ufb01st derivative in\nincreasing, which implies the function itself has a minimum.\nSecond, if the second derivative is a negative constant, that means that the first derivative\nis decreasing. This implies the first derivative may start out positive, becomes zero at a\npoint, and then becomes negative. Hence, the function \ud835\udc53itself increases, flattens out, then\ndecreases. In other words, the function \ud835\udc53curves down, and has a single maximum as is\nshown in Fig. A.2.\ntFig.", "mimetype": "text/plain", "start_char_idx": 1930656, "end_char_idx": 1933435, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "301868e2-73d9-4ebd-95d2-ab13bd73be75": {"__data__": {"id_": "301868e2-73d9-4ebd-95d2-ab13bd73be75", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e15971d5-d03f-44cf-9bb7-77e06e78fd61", "node_type": "1", "metadata": {}, "hash": "04db4bc61878b6758c587e96ff7b07894f097711f3c085e734b8df16d757be57", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ea876c21-1193-4daf-b17c-d5ec43f481ae", "node_type": "1", "metadata": {}, "hash": "10e3e0382370723aeff195e1c8380d657863c8e4c3443c1f75ecbe40051ff397", "class_name": "RelatedNodeInfo"}}, "text": "In other words, the function \ud835\udc53curves up, and has a single minimum as\nis shown in Fig. A.1.\ntFig. A.1 If we assume the second derivative is a positive constant, then the \ufb01st derivative in\nincreasing, which implies the function itself has a minimum.\nSecond, if the second derivative is a negative constant, that means that the first derivative\nis decreasing. This implies the first derivative may start out positive, becomes zero at a\npoint, and then becomes negative. Hence, the function \ud835\udc53itself increases, flattens out, then\ndecreases. In other words, the function \ud835\udc53curves down, and has a single maximum as is\nshown in Fig. A.2.\ntFig. A.2 If we assume the second derivative is a negative constant, then the \ufb01st derivative in\ndecreasing, which implies the function itself has a maximum.\nThird,ifthesecondderivativeisaalwayszero,thenthefirstderivativewillneverchange\u2014\nit is constant! This means that \ud835\udc53increases (or decreases) at a fixed rate, and \ud835\udc53is itself a\nstraight line as is shown in Fig. A.3.\nTosummarize,thesecondderivativecanbeinterpretedasdescribingthewaythatthefunc-\ntion\ud835\udc53curves. A positive second derivative leads to a upwards curve, while a negative sec-\nond derivative means that \ud835\udc53curves downwards, and a zero second derivative means that \ud835\udc53\ndoes not curve at all.\n932 Mathematics for Deep Learning\ntFig. A.3 If we assume the second derivative is zero, then the \ufb01st derivative is constant, which\nimplies the function itself is a straight line.\nLet\u2019s take this one step further. Consider the function \ud835\udc54\u00b9\ud835\udc65\u00ba=\ud835\udc4e\ud835\udc652\u00b8\ud835\udc4f\ud835\udc65\u00b8\ud835\udc50. We can then\ncompute that\n\ud835\udc51\ud835\udc54\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba=2\ud835\udc4e\ud835\udc65\u00b8\ud835\udc4f\n\ud835\udc512\ud835\udc54\n\ud835\udc51\ud835\udc652\u00b9\ud835\udc65\u00ba=2\ud835\udc4e.(A.14)\nIf we have some original function \ud835\udc53\u00b9\ud835\udc65\u00bain mind, we may compute the first two derivatives\nand find the values for \ud835\udc4e,\ud835\udc4f, and\ud835\udc50that make them match this computation. Similarly to\nthe previous section where we saw that the first derivative gave the best approximation\nwith a straight line, this construction provides the best approximation by a quadratic. Let\u2019s\nvisualize this for \ud835\udc53\u00b9\ud835\udc65\u00ba=sin\u00b9\ud835\udc65\u00ba.\n# Compute sin\nxs=torch .arange( -torch .pi, torch .pi, 0.01 )\nplots =[torch .sin(xs)]\n# Compute some quadratic approximations. Use d(sin(x)) / dx = cos(x)\nfor x0in[-1.5,0.0,2.0]:\nplots .append(torch .sin(torch .tensor(x0)) +(xs -x0) *\ntorch .cos(torch .tensor(x0)) -(xs -x0)**2*\ntorch .sin(torch .tensor(x0)) /2)\nd2l.plot(xs, plots, 'x','f(x) ', ylim =[-1.5,1.5])\nWe will extend this idea to the idea of a Taylorseries in the next section.\n933 Single Variable Calculus\nTaylorSeries\nTheTaylorseries providesamethodtoapproximatethefunction \ud835\udc53\u00b9\ud835\udc65\u00baifwearegivenvalues\nfor the first\ud835\udc5bderivatives at a point \ud835\udc650, i.e.,\b\n\ud835\udc53\u00b9\ud835\udc650\u00ba, \ud835\udc53\u00b91\u00ba\u00b9\ud835\udc650\u00ba, \ud835\udc53\u00b92\u00ba\u00b9\ud835\udc650\u00ba,..., \ud835\udc53\u00b9\ud835\udc5b\u00ba\u00b9\ud835\udc650\u00ba\t\n. The\nideawillbetofindadegree \ud835\udc5bpolynomialthatmatchesallthegivenderivativesat \ud835\udc650.\nWe saw the case of \ud835\udc5b=2in the previous section and a little algebra shows this is\n\ud835\udc53\u00b9\ud835\udc65\u00ba\u00191\n2\ud835\udc512\ud835\udc53\n\ud835\udc51\ud835\udc652\u00b9\ud835\udc650\u00ba\u00b9\ud835\udc65\u0000\ud835\udc650\u00ba2\u00b8\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc650\u00ba\u00b9\ud835\udc65\u0000\ud835\udc650\u00ba\u00b8\ud835\udc53\u00b9\ud835\udc650\u00ba.", "mimetype": "text/plain", "start_char_idx": 1932801, "end_char_idx": 1935635, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ea876c21-1193-4daf-b17c-d5ec43f481ae": {"__data__": {"id_": "ea876c21-1193-4daf-b17c-d5ec43f481ae", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "301868e2-73d9-4ebd-95d2-ab13bd73be75", "node_type": "1", "metadata": {}, "hash": "ba4c70ff137592b2fdec9f7e8ed5918f29ecc9a7dedb268c8f0b8b27ab1c3aba", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "87adc65f-05b4-4387-83df-33ad9c68108e", "node_type": "1", "metadata": {}, "hash": "2cef81e8bf8961f599b9ef9bb0215f2cf7c1bb14350466006a39ca3b888c378e", "class_name": "RelatedNodeInfo"}}, "text": "The\nideawillbetofindadegree \ud835\udc5bpolynomialthatmatchesallthegivenderivativesat \ud835\udc650.\nWe saw the case of \ud835\udc5b=2in the previous section and a little algebra shows this is\n\ud835\udc53\u00b9\ud835\udc65\u00ba\u00191\n2\ud835\udc512\ud835\udc53\n\ud835\udc51\ud835\udc652\u00b9\ud835\udc650\u00ba\u00b9\ud835\udc65\u0000\ud835\udc650\u00ba2\u00b8\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc650\u00ba\u00b9\ud835\udc65\u0000\ud835\udc650\u00ba\u00b8\ud835\udc53\u00b9\ud835\udc650\u00ba. (A.15)\nAs we can see above, the denominator of 2is there to cancel out the 2we get when we take\ntwo derivatives of \ud835\udc652, while the other terms are all zero. Same logic applies for the first\nderivative and the value itself.\nIf we push the logic further to \ud835\udc5b=3, we will conclude that\n\ud835\udc53\u00b9\ud835\udc65\u00ba\u0019\ud835\udc513\ud835\udc53\n\ud835\udc51\ud835\udc653\u00b9\ud835\udc650\u00ba\n6\u00b9\ud835\udc65\u0000\ud835\udc650\u00ba3\u00b8\ud835\udc512\ud835\udc53\n\ud835\udc51\ud835\udc652\u00b9\ud835\udc650\u00ba\n2\u00b9\ud835\udc65\u0000\ud835\udc650\u00ba2\u00b8\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc650\u00ba\u00b9\ud835\udc65\u0000\ud835\udc650\u00ba\u00b8\ud835\udc53\u00b9\ud835\udc650\u00ba.(A.16)\nwherethe 6=3\u00022=3!comesfromtheconstantwegetinfrontifwetakethreederivatives\nof\ud835\udc653.\nFurthermore, we can get a degree \ud835\udc5bpolynomial by\n\ud835\udc43\ud835\udc5b\u00b9\ud835\udc65\u00ba=\ud835\udc5b\u00d5\n\ud835\udc56=0\ud835\udc53\u00b9\ud835\udc56\u00ba\u00b9\ud835\udc650\u00ba\n\ud835\udc56!\u00b9\ud835\udc65\u0000\ud835\udc650\u00ba\ud835\udc56. (A.17)\nwhere the notation\n\ud835\udc53\u00b9\ud835\udc5b\u00ba\u00b9\ud835\udc65\u00ba=\ud835\udc51\ud835\udc5b\ud835\udc53\n\ud835\udc51\ud835\udc65\ud835\udc5b=\u0012\ud835\udc51\n\ud835\udc51\ud835\udc65\u0013\ud835\udc5b\n\ud835\udc53. (A.18)\nIndeed,\ud835\udc43\ud835\udc5b\u00b9\ud835\udc65\u00bacanbeviewedasthebest \ud835\udc5b-thdegreepolynomialapproximationtoourfunc-\ntion\ud835\udc53\u00b9\ud835\udc65\u00ba.\nWhile we are not going to dive all the way into the error of the above approximations, it\nis worth mentioning the infinite limit. In this case, for well behaved functions (known as\nrealanalyticfunctions)like cos\u00b9\ud835\udc65\u00baor\ud835\udc52\ud835\udc65, wecanwriteouttheinfinitenumberoftermsand\napproximate the exactly same function\n\ud835\udc53\u00b9\ud835\udc65\u00ba=1\u00d5\n\ud835\udc5b=0\ud835\udc53\u00b9\ud835\udc5b\u00ba\u00b9\ud835\udc650\u00ba\n\ud835\udc5b!\u00b9\ud835\udc65\u0000\ud835\udc650\u00ba\ud835\udc5b. (A.19)\nTake\ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc52\ud835\udc65as am example. Since \ud835\udc52\ud835\udc65is its own derivative, we know that \ud835\udc53\u00b9\ud835\udc5b\u00ba\u00b9\ud835\udc65\u00ba=\ud835\udc52\ud835\udc65.\nTherefore,\ud835\udc52\ud835\udc65can be reconstructed by taking the Taylor series at \ud835\udc650=0, i.e.,\n\ud835\udc52\ud835\udc65=1\u00d5\n\ud835\udc5b=0\ud835\udc65\ud835\udc5b\n\ud835\udc5b!=1\u00b8\ud835\udc65\u00b8\ud835\udc652\n2\u00b8\ud835\udc653\n6\u00b8\u0001\u0001\u0001. (A.20)\nLet\u2019s see how this works in code and observe how increasing the degree of the Taylor\napproximation brings us closer to the desired function \ud835\udc52\ud835\udc65.", "mimetype": "text/plain", "start_char_idx": 1935426, "end_char_idx": 1936978, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "87adc65f-05b4-4387-83df-33ad9c68108e": {"__data__": {"id_": "87adc65f-05b4-4387-83df-33ad9c68108e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ea876c21-1193-4daf-b17c-d5ec43f481ae", "node_type": "1", "metadata": {}, "hash": "10e3e0382370723aeff195e1c8380d657863c8e4c3443c1f75ecbe40051ff397", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c8a4ae60-4e1c-474f-b2d9-dfdce19e50c7", "node_type": "1", "metadata": {}, "hash": "d4a2f3173a5d4cac7d83180f42e2b8a1fc68272e200a23a9fc09d248329ac56b", "class_name": "RelatedNodeInfo"}}, "text": "(A.19)\nTake\ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc52\ud835\udc65as am example. Since \ud835\udc52\ud835\udc65is its own derivative, we know that \ud835\udc53\u00b9\ud835\udc5b\u00ba\u00b9\ud835\udc65\u00ba=\ud835\udc52\ud835\udc65.\nTherefore,\ud835\udc52\ud835\udc65can be reconstructed by taking the Taylor series at \ud835\udc650=0, i.e.,\n\ud835\udc52\ud835\udc65=1\u00d5\n\ud835\udc5b=0\ud835\udc65\ud835\udc5b\n\ud835\udc5b!=1\u00b8\ud835\udc65\u00b8\ud835\udc652\n2\u00b8\ud835\udc653\n6\u00b8\u0001\u0001\u0001. (A.20)\nLet\u2019s see how this works in code and observe how increasing the degree of the Taylor\napproximation brings us closer to the desired function \ud835\udc52\ud835\udc65.\n934 Mathematics for Deep Learning\n# Compute the exponential function\nxs=torch .arange( 0,3,0.01 )\nys=torch .exp(xs)\n# Compute a few Taylor series approximations\nP1=1+xs\nP2=1+xs+xs**2/2\nP5=1+xs+xs**2/2+xs**3/6+xs**4/24+xs**5/120\nd2l.plot(xs, [ys, P1, P2, P5], 'x','f(x) ', legend =[\n\"Exponential \",\"Degree 1 Taylor Series \",\"Degree 2 Taylor Series \",\n\"Degree 5 Taylor Series \"])\nTaylor series have two primary applications:\n1.Theoretical applications : Often when we try to understand a too complex function,\nusingTaylorseriesenablesustoturnitintoapolynomialthatwecanworkwithdirectly.\n2.Numerical applications : Some functions like \ud835\udc52\ud835\udc65orcos\u00b9\ud835\udc65\u00baare difficult for machines to\ncompute. Theycanstoretablesofvaluesatafixedprecision(andthisisoftendone),but\nit still leaves open questions like \u201cWhat is the 1000-th digit of cos\u00b91\u00ba?\u201d Taylor series\nare often helpful to answer such questions.\nA.3.3Summary\n\u000fDerivatives can be used to express how functions change when we change the input by a\nsmall amount.\n\u000fElementaryderivativescanbecombinedusingderivativerulestocreatearbitrarilycom-\nplex derivatives.\n\u000fDerivatives can be iterated to get second or higher order derivatives. Each increase in\norder provides more fine grained information on the behavior of the function.\n\u000fUsing information in the derivatives of a single data example, we can approximate well\nbehaved functions by polynomials obtained from the Taylor series.\nA.3.4Exercises\n1.What is the derivative of \ud835\udc653\u00004\ud835\udc65\u00b81?\n935 Multivariable Calculus\n2822.What is the derivative of log\u00b91\n\ud835\udc65\u00ba?\n3.True or False: If \ud835\udc530\u00b9\ud835\udc65\u00ba=0then\ud835\udc53has a maximum or minimum at \ud835\udc65?\n4.Where is the minimum of \ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc65log\u00b9\ud835\udc65\u00bafor\ud835\udc65\u00150(where we assume that \ud835\udc53takes the\nlimiting value of 0at\ud835\udc53\u00b90\u00ba)?\nDiscussions282.\nA.4MultivariableCalculus\nNow that we have a fairly strong understanding of derivatives of a function of a single\nvariable, let\u2019s return to our original question where we were considering a loss function of\npotentially billions of weights.\nA.4.1Higher-DimensionalDifferentiation\nWhatSection A.3 tells us is that if we change a single one of these billions of weights\nleaving every other one fixed, we know what will happen! This is nothing more than a\nfunction of a single variable, so we can write\n\ud835\udc3f\u00b9\ud835\udc641\u00b8\ud835\udf161,\ud835\udc642,...,\ud835\udc64\ud835\udc41\u00ba\u0019\ud835\udc3f\u00b9\ud835\udc641,\ud835\udc642,...,\ud835\udc64\ud835\udc41\u00ba\u00b8\ud835\udf161\ud835\udc51\n\ud835\udc51\ud835\udc64 1\ud835\udc3f\u00b9\ud835\udc641,\ud835\udc642,...,\ud835\udc64\ud835\udc41\u00ba.(A.1)\nWewillcallthederivativeinonevariablewhilefixingtheothervariablesthe partialderiva-\ntive, and we will use the notation\ud835\udf15\n\ud835\udf15\ud835\udc64 1for the derivative in (A.1).", "mimetype": "text/plain", "start_char_idx": 1936629, "end_char_idx": 1939410, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c8a4ae60-4e1c-474f-b2d9-dfdce19e50c7": {"__data__": {"id_": "c8a4ae60-4e1c-474f-b2d9-dfdce19e50c7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "87adc65f-05b4-4387-83df-33ad9c68108e", "node_type": "1", "metadata": {}, "hash": "2cef81e8bf8961f599b9ef9bb0215f2cf7c1bb14350466006a39ca3b888c378e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6c2e8c1a-3510-416a-aa59-abfd57c1fc9f", "node_type": "1", "metadata": {}, "hash": "fe510788435b10011adba4a6f85a4485d00b3ac5b6e2e1e141c0b22f9c6ceebf", "class_name": "RelatedNodeInfo"}}, "text": "This is nothing more than a\nfunction of a single variable, so we can write\n\ud835\udc3f\u00b9\ud835\udc641\u00b8\ud835\udf161,\ud835\udc642,...,\ud835\udc64\ud835\udc41\u00ba\u0019\ud835\udc3f\u00b9\ud835\udc641,\ud835\udc642,...,\ud835\udc64\ud835\udc41\u00ba\u00b8\ud835\udf161\ud835\udc51\n\ud835\udc51\ud835\udc64 1\ud835\udc3f\u00b9\ud835\udc641,\ud835\udc642,...,\ud835\udc64\ud835\udc41\u00ba.(A.1)\nWewillcallthederivativeinonevariablewhilefixingtheothervariablesthe partialderiva-\ntive, and we will use the notation\ud835\udf15\n\ud835\udf15\ud835\udc64 1for the derivative in (A.1).\nNow, let\u2019s take this and change \ud835\udc642a little bit to \ud835\udc642\u00b8\ud835\udf162:\n\ud835\udc3f\u00b9\ud835\udc641\u00b8\ud835\udf161,\ud835\udc642\u00b8\ud835\udf162,...,\ud835\udc64\ud835\udc41\u00ba\u0019\ud835\udc3f\u00b9\ud835\udc641,\ud835\udc642\u00b8\ud835\udf162,...,\ud835\udc64\ud835\udc41\u00ba\u00b8\ud835\udf161\ud835\udf15\n\ud835\udf15\ud835\udc64 1\ud835\udc3f\u00b9\ud835\udc641,\ud835\udc642\u00b8\ud835\udf162,...,\ud835\udc64\ud835\udc41\u00b8\ud835\udf16\ud835\udc41\u00ba\n\u0019\ud835\udc3f\u00b9\ud835\udc641,\ud835\udc642,...,\ud835\udc64\ud835\udc41\u00ba\n\u00b8\ud835\udf162\ud835\udf15\n\ud835\udf15\ud835\udc64 2\ud835\udc3f\u00b9\ud835\udc641,\ud835\udc642,...,\ud835\udc64\ud835\udc41\u00ba\n\u00b8\ud835\udf161\ud835\udf15\n\ud835\udf15\ud835\udc64 1\ud835\udc3f\u00b9\ud835\udc641,\ud835\udc642,...,\ud835\udc64\ud835\udc41\u00ba\n\u00b8\ud835\udf161\ud835\udf162\ud835\udf15\n\ud835\udf15\ud835\udc64 2\ud835\udf15\n\ud835\udf15\ud835\udc64 1\ud835\udc3f\u00b9\ud835\udc641,\ud835\udc642,...,\ud835\udc64\ud835\udc41\u00ba\n\u0019\ud835\udc3f\u00b9\ud835\udc641,\ud835\udc642,...,\ud835\udc64\ud835\udc41\u00ba\n\u00b8\ud835\udf162\ud835\udf15\n\ud835\udf15\ud835\udc64 2\ud835\udc3f\u00b9\ud835\udc641,\ud835\udc642,...,\ud835\udc64\ud835\udc41\u00ba\n\u00b8\ud835\udf161\ud835\udf15\n\ud835\udf15\ud835\udc64 1\ud835\udc3f\u00b9\ud835\udc641,\ud835\udc642,...,\ud835\udc64\ud835\udc41\u00ba.\n(A.2)\nWehaveagainusedtheideathat \ud835\udf161\ud835\udf162isahigherordertermthatwecandiscardinthesame\n936 Mathematics for Deep Learning\nway we could discard \ud835\udf162in the previous section, along with what we saw in (A.1). By\ncontinuing in this manner, we may write that\n\ud835\udc3f\u00b9\ud835\udc641\u00b8\ud835\udf161,\ud835\udc642\u00b8\ud835\udf162,...,\ud835\udc64\ud835\udc41\u00b8\ud835\udf16\ud835\udc41\u00ba\u0019\ud835\udc3f\u00b9\ud835\udc641,\ud835\udc642,...,\ud835\udc64\ud835\udc41\u00ba\u00b8\u00d5\n\ud835\udc56\ud835\udf16\ud835\udc56\ud835\udf15\n\ud835\udf15\ud835\udc64\ud835\udc56\ud835\udc3f\u00b9\ud835\udc641,\ud835\udc642,...,\ud835\udc64\ud835\udc41\u00ba.\n(A.3)\nThis may look like a mess, but we can make this more familiar by noting that the sum on\nthe right looks exactly like a dot product, so if we let\n\ud835\udf50=\u00bb\ud835\udf161,...,\ud835\udf16\ud835\udc41\u00bc>andrx\ud835\udc3f=\u0014\ud835\udf15\ud835\udc3f\n\ud835\udf15\ud835\udc651,...,\ud835\udf15\ud835\udc3f\n\ud835\udf15\ud835\udc65\ud835\udc41\u0015>\n, (A.4)\nthen\n\ud835\udc3f\u00b9w\u00b8\ud835\udf50\u00ba\u0019\ud835\udc3f\u00b9w\u00ba\u00b8\ud835\udf50\u0001rw\ud835\udc3f\u00b9w\u00ba. (A.5)\nWe will call the vector rw\ud835\udc3fthegradient of\ud835\udc3f.\nEquation (A.5)isworthponderingforamoment. Ithasexactlytheformatthatweencoun-\ntered in one dimension, just we have converted everything to vectors and dot products.\nIt allows us to tell approximately how the function \ud835\udc3fwill change given any perturbation\nto the input.", "mimetype": "text/plain", "start_char_idx": 1939119, "end_char_idx": 1940562, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6c2e8c1a-3510-416a-aa59-abfd57c1fc9f": {"__data__": {"id_": "6c2e8c1a-3510-416a-aa59-abfd57c1fc9f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c8a4ae60-4e1c-474f-b2d9-dfdce19e50c7", "node_type": "1", "metadata": {}, "hash": "d4a2f3173a5d4cac7d83180f42e2b8a1fc68272e200a23a9fc09d248329ac56b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e58ea5b0-30f0-4ae6-863f-d7b0c9bfc306", "node_type": "1", "metadata": {}, "hash": "ba2ce99a367b62fd6e0f176654335c5f5912296206eb2cc8998b245f38c66a1e", "class_name": "RelatedNodeInfo"}}, "text": "(A.5)\nWe will call the vector rw\ud835\udc3fthegradient of\ud835\udc3f.\nEquation (A.5)isworthponderingforamoment. Ithasexactlytheformatthatweencoun-\ntered in one dimension, just we have converted everything to vectors and dot products.\nIt allows us to tell approximately how the function \ud835\udc3fwill change given any perturbation\nto the input. As we will see in the next section, this will provide us with an important\ntool in understanding geometrically how we can learn using information contained in the\ngradient.\nButfirst,let\u2019sseethisapproximationatworkwithanexample. Supposethatweareworking\nwith the function\n\ud835\udc53\u00b9\ud835\udc65,\ud835\udc66\u00ba=log\u00b9\ud835\udc52\ud835\udc65\u00b8\ud835\udc52\ud835\udc66\u00bawith gradientr\ud835\udc53\u00b9\ud835\udc65,\ud835\udc66\u00ba=\u0014\ud835\udc52\ud835\udc65\n\ud835\udc52\ud835\udc65\u00b8\ud835\udc52\ud835\udc66,\ud835\udc52\ud835\udc66\n\ud835\udc52\ud835\udc65\u00b8\ud835\udc52\ud835\udc66\u0015\n. (A.6)\nIf we look at a point like \u00b90,log\u00b92\u00ba\u00ba, we see that\n\ud835\udc53\u00b9\ud835\udc65,\ud835\udc66\u00ba=log\u00b93\u00bawith gradientr\ud835\udc53\u00b9\ud835\udc65,\ud835\udc66\u00ba=\u00141\n3,2\n3\u0015\n. (A.7)\nThus, if we want to approximate \ud835\udc53at\u00b9\ud835\udf161,log\u00b92\u00ba\u00b8\ud835\udf162\u00ba, we see that we should have the\nspecific instance of (A.5):\n\ud835\udc53\u00b9\ud835\udf161,log\u00b92\u00ba\u00b8\ud835\udf162\u00ba\u0019log\u00b93\u00ba\u00b81\n3\ud835\udf161\u00b82\n3\ud835\udf162. (A.8)\nWe can test this in code to see how good the approximation is.\n%matplotlib inline\nimport numpy asnp\nimport torch\nfrom IPython import display\nfrom mpl_toolkits import mplot3d\nfrom d2l import torch asd2l\ndef f(x, y):\n(continues on next page)\n937 Multivariable Calculus\n(continued from previous page)\nreturn torch .log(torch .exp(x) +torch .exp(y))\ndef grad_f (x, y):\nreturn torch .tensor([torch .exp(x) /(torch .exp(x) +torch .exp(y)),\ntorch .exp(y) /(torch .exp(x) +torch .exp(y))])\nepsilon =torch .tensor([ 0.01 ,-0.03 ])\ngrad_approx =f(torch .tensor([ 0.]), torch .log(\ntorch .tensor([ 2.]))) +epsilon .dot(\ngrad_f(torch .tensor([ 0.]), torch .log(torch .tensor( 2.))))\ntrue_value =f(torch .tensor([ 0.])+epsilon[ 0], torch .log(\ntorch .tensor([ 2.])) +epsilon[ 1])\nf'approximation: {grad_approx }, true Value: {true_value }'\n'approximation: tensor([1.0819]), true Value: tensor([1.0821]) '\nA.4.2Geometryof Gradients and Gradient Descent\nConsider the expression from (A.5)again:\n\ud835\udc3f\u00b9w\u00b8\ud835\udf50\u00ba\u0019\ud835\udc3f\u00b9w\u00ba\u00b8\ud835\udf50\u0001rw\ud835\udc3f\u00b9w\u00ba. (A.9)\nLet\u2019s suppose that I want to use this to help minimize our loss \ud835\udc3f. Let\u2019s understand geomet-\nrically the algorithm of gradient descent first described in Section 2.5 . What we will do is\nthe following:\n1.Start with a random choice for the initial parameters w.\n2.Find the direction vthat makes\ud835\udc3fdecrease the most rapidly at w.\n3.Take a small step in that direction: w!w\u00b8\ud835\udf16v.\n4.Repeat.\nThe only thing we do not know exactly how to do is to compute the vector vin the second\nstep. We will call such a direction the direction of steepest descent . Using the geometric\nunderstandingofdotproductsfrom SectionA.1 ,weseethatwecanrewrite (A.5)as\n\ud835\udc3f\u00b9w\u00b8v\u00ba\u0019\ud835\udc3f\u00b9w\u00ba\u00b8v\u0001rw\ud835\udc3f\u00b9w\u00ba=\ud835\udc3f\u00b9w\u00ba\u00b8kr w\ud835\udc3f\u00b9w\u00bakcos\u00b9\ud835\udf03\u00ba. (A.10)\nNote that we have taken our direction to have length one for convenience, and used \ud835\udf03for\nthe angle between vandrw\ud835\udc3f\u00b9w\u00ba.", "mimetype": "text/plain", "start_char_idx": 1940247, "end_char_idx": 1942964, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e58ea5b0-30f0-4ae6-863f-d7b0c9bfc306": {"__data__": {"id_": "e58ea5b0-30f0-4ae6-863f-d7b0c9bfc306", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6c2e8c1a-3510-416a-aa59-abfd57c1fc9f", "node_type": "1", "metadata": {}, "hash": "fe510788435b10011adba4a6f85a4485d00b3ac5b6e2e1e141c0b22f9c6ceebf", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "30b46570-c0ab-48cd-a15b-8f18a3023c6e", "node_type": "1", "metadata": {}, "hash": "9007c0caf82917893a176d01e9a68c3e52ec38dc3c3133bef0b9b59cf9c9b61c", "class_name": "RelatedNodeInfo"}}, "text": "3.Take a small step in that direction: w!w\u00b8\ud835\udf16v.\n4.Repeat.\nThe only thing we do not know exactly how to do is to compute the vector vin the second\nstep. We will call such a direction the direction of steepest descent . Using the geometric\nunderstandingofdotproductsfrom SectionA.1 ,weseethatwecanrewrite (A.5)as\n\ud835\udc3f\u00b9w\u00b8v\u00ba\u0019\ud835\udc3f\u00b9w\u00ba\u00b8v\u0001rw\ud835\udc3f\u00b9w\u00ba=\ud835\udc3f\u00b9w\u00ba\u00b8kr w\ud835\udc3f\u00b9w\u00bakcos\u00b9\ud835\udf03\u00ba. (A.10)\nNote that we have taken our direction to have length one for convenience, and used \ud835\udf03for\nthe angle between vandrw\ud835\udc3f\u00b9w\u00ba. If we want to find the direction that decreases \ud835\udc3fas\nrapidly as possible, we want to make this expression as negative as possible. The only way\nthe direction we pick enters into this equation is through cos\u00b9\ud835\udf03\u00ba, and thus we wish to make\nthis cosine as negative as possible. Now, recalling the shape of cosine, we can make this as\nnegative as possible by making cos\u00b9\ud835\udf03\u00ba=\u00001or equivalently making the angle between the\ngradient and our chosen direction to be \ud835\udf0bradians, or equivalently 180degrees. The only\nway to achieve this is to head in the exact opposite direction: pick vto point in the exact\nopposite direction to rw\ud835\udc3f\u00b9w\u00ba!\nThis brings us to one of the most important mathematical concepts in machine learning:\n938 Mathematics for Deep Learning\nthe direction of steepest decent points in the direction of \u0000rw\ud835\udc3f\u00b9w\u00ba. Thus our informal\nalgorithm can be rewritten as follows.\n1.Start with a random choice for the initial parameters w.\n2.Computerw\ud835\udc3f\u00b9w\u00ba.\n3.Take a small step in the opposite of that direction: w w\u0000\ud835\udf16rw\ud835\udc3f\u00b9w\u00ba.\n4.Repeat.\nThis basic algorithm has been modified and adapted many ways by many researchers, but\nthecore conceptremains the samein allof them. Use thegradient tofind the directionthat\ndecreases the loss as rapidly as possible, and update the parameters to take a step in that\ndirection.\nA.4.3A Noteon Mathematical Optimization\nThroughoutthisbook,wefocussquarelyonnumericaloptimizationtechniquesfortheprac-\ntical reason that all functions we encounter in the deep learning setting are too complex to\nminimize explicitly.\nHowever, it is a useful exercise to consider what the geometric understanding we obtained\nabove tells us about optimizing functions directly.\nSuppose that we wish to find the value of x0which minimizes some function \ud835\udc3f\u00b9x\u00ba. Let\u2019s\nsuppose that moreover someone gives us a value and tells us that it is the value that mini-\nmizes\ud835\udc3f. Is there anything we can check to see if their answer is even plausible?\nAgain consider (A.5):\n\ud835\udc3f\u00b9x0\u00b8\ud835\udf50\u00ba\u0019\ud835\udc3f\u00b9x0\u00ba\u00b8\ud835\udf50\u0001rx\ud835\udc3f\u00b9x0\u00ba. (A.11)\nIf the gradient is not zero, we know that we can take a step in the direction \u0000\ud835\udf16rx\ud835\udc3f\u00b9x0\u00bato\nfind a value of \ud835\udc3fthat is smaller. Thus, if we truly are at a minimum, this cannot be the\ncase! We can conclude that if x0is a minimum, then rx\ud835\udc3f\u00b9x0\u00ba=0. We call points with\nrx\ud835\udc3f\u00b9x0\u00ba=0critical points .\nThis is nice, because in some rare settings, we canexplicitly find all the points where the\ngradient is zero, and find the one with the smallest value.\nFor a concrete example, consider the function\n\ud835\udc53\u00b9\ud835\udc65\u00ba=3\ud835\udc654\u00004\ud835\udc653\u000012\ud835\udc652. (A.12)\nThis function has derivative\n\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65=12\ud835\udc653\u000012\ud835\udc652\u000024\ud835\udc65=12\ud835\udc65\u00b9\ud835\udc65\u00002\u00ba\u00b9\ud835\udc65\u00b81\u00ba. (A.13)\nThe only possible location of minima are at \ud835\udc65=\u00001,0,2, where the function takes the\nvalues\u00005,0,\u000032respectively, and thus we can conclude that we minimize our function\nwhen\ud835\udc65=2. A quick plot confirms this.", "mimetype": "text/plain", "start_char_idx": 1942487, "end_char_idx": 1945737, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "30b46570-c0ab-48cd-a15b-8f18a3023c6e": {"__data__": {"id_": "30b46570-c0ab-48cd-a15b-8f18a3023c6e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e58ea5b0-30f0-4ae6-863f-d7b0c9bfc306", "node_type": "1", "metadata": {}, "hash": "ba2ce99a367b62fd6e0f176654335c5f5912296206eb2cc8998b245f38c66a1e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0c6c2b56-2b1b-4023-a2e2-4e60bc1ead9e", "node_type": "1", "metadata": {}, "hash": "df365f754194691938861b7238675f38a5f5b2d89b54923becb35964a819c757", "class_name": "RelatedNodeInfo"}}, "text": "This is nice, because in some rare settings, we canexplicitly find all the points where the\ngradient is zero, and find the one with the smallest value.\nFor a concrete example, consider the function\n\ud835\udc53\u00b9\ud835\udc65\u00ba=3\ud835\udc654\u00004\ud835\udc653\u000012\ud835\udc652. (A.12)\nThis function has derivative\n\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65=12\ud835\udc653\u000012\ud835\udc652\u000024\ud835\udc65=12\ud835\udc65\u00b9\ud835\udc65\u00002\u00ba\u00b9\ud835\udc65\u00b81\u00ba. (A.13)\nThe only possible location of minima are at \ud835\udc65=\u00001,0,2, where the function takes the\nvalues\u00005,0,\u000032respectively, and thus we can conclude that we minimize our function\nwhen\ud835\udc65=2. A quick plot confirms this.\n939 Multivariable Calculus\nx=torch .arange( -2,3,0.01 )\nf=(3*x**4)-(4*x**3)-(12*x**2)\nd2l.plot(x, f, 'x','f(x) ')\nThishighlightsanimportantfacttoknowwhenworkingeithertheoreticallyornumerically:\ntheonlypossiblepointswherewecanminimize(ormaximize)afunctionwillhavegradient\nequal to zero, however, not every point with gradient zero is the true globalminimum (or\nmaximum).\nA.4.4MultivariateChain Rule\nLet\u2019s suppose that we have a function of four variables ( \ud835\udc64,\ud835\udc65,\ud835\udc66, and\ud835\udc67) which we can make\nby composing many terms:\n\ud835\udc53\u00b9\ud835\udc62,\ud835\udc63\u00ba=\u00b9\ud835\udc62\u00b8\ud835\udc63\u00ba2\n\ud835\udc62\u00b9\ud835\udc4e,\ud835\udc4f\u00ba=\u00b9\ud835\udc4e\u00b8\ud835\udc4f\u00ba2, \ud835\udc63\u00b9\ud835\udc4e,\ud835\udc4f\u00ba=\u00b9\ud835\udc4e\u0000\ud835\udc4f\u00ba2,\n\ud835\udc4e\u00b9\ud835\udc64,\ud835\udc65,\ud835\udc66,\ud835\udc67\u00ba=\u00b9\ud835\udc64\u00b8\ud835\udc65\u00b8\ud835\udc66\u00b8\ud835\udc67\u00ba2, \ud835\udc4f\u00b9\ud835\udc64,\ud835\udc65,\ud835\udc66,\ud835\udc67\u00ba=\u00b9\ud835\udc64\u00b8\ud835\udc65\u0000\ud835\udc66\u0000\ud835\udc67\u00ba2.(A.14)\nSuch chains of equations are common when working with neural networks, so trying to\nunderstand how to compute gradients of such functions is key. We can start to see visual\nhints of this connection in Fig. A.1 if we take a look at what variables directly relate to one\nanother.\ntFig. A.1 The function relations above where nodes represent values and edges show functional\ndependence.\nNothing stops us from just composing everything from (A.14 )and writing out that\n\ud835\udc53\u00b9\ud835\udc64,\ud835\udc65,\ud835\udc66,\ud835\udc67\u00ba=\u0012\u0010\n\u00b9\ud835\udc64\u00b8\ud835\udc65\u00b8\ud835\udc66\u00b8\ud835\udc67\u00ba2\u00b8\u00b9\ud835\udc64\u00b8\ud835\udc65\u0000\ud835\udc66\u0000\ud835\udc67\u00ba2\u00112\n\u00b8\u0010\n\u00b9\ud835\udc64\u00b8\ud835\udc65\u00b8\ud835\udc66\u00b8\ud835\udc67\u00ba2\u0000\u00b9\ud835\udc64\u00b8\ud835\udc65\u0000\ud835\udc66\u0000\ud835\udc67\u00ba2\u00112\u00132\n.\n(A.15)\n940 Mathematics for Deep Learning\nWe may then take the derivative by just using single variable derivatives, but if we did that\nwe would quickly find ourself swamped with terms, many of which are repeats!", "mimetype": "text/plain", "start_char_idx": 1945240, "end_char_idx": 1947091, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0c6c2b56-2b1b-4023-a2e2-4e60bc1ead9e": {"__data__": {"id_": "0c6c2b56-2b1b-4023-a2e2-4e60bc1ead9e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "30b46570-c0ab-48cd-a15b-8f18a3023c6e", "node_type": "1", "metadata": {}, "hash": "9007c0caf82917893a176d01e9a68c3e52ec38dc3c3133bef0b9b59cf9c9b61c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6161a539-ad9c-4ee2-8740-d6602bb43990", "node_type": "1", "metadata": {}, "hash": "4e9fa352099e463fd6692f346d006a9c46d34a65b555ab4dc7bb249c44a39555", "class_name": "RelatedNodeInfo"}}, "text": "Nothing stops us from just composing everything from (A.14 )and writing out that\n\ud835\udc53\u00b9\ud835\udc64,\ud835\udc65,\ud835\udc66,\ud835\udc67\u00ba=\u0012\u0010\n\u00b9\ud835\udc64\u00b8\ud835\udc65\u00b8\ud835\udc66\u00b8\ud835\udc67\u00ba2\u00b8\u00b9\ud835\udc64\u00b8\ud835\udc65\u0000\ud835\udc66\u0000\ud835\udc67\u00ba2\u00112\n\u00b8\u0010\n\u00b9\ud835\udc64\u00b8\ud835\udc65\u00b8\ud835\udc66\u00b8\ud835\udc67\u00ba2\u0000\u00b9\ud835\udc64\u00b8\ud835\udc65\u0000\ud835\udc66\u0000\ud835\udc67\u00ba2\u00112\u00132\n.\n(A.15)\n940 Mathematics for Deep Learning\nWe may then take the derivative by just using single variable derivatives, but if we did that\nwe would quickly find ourself swamped with terms, many of which are repeats! Indeed,\none can see that, for instance:\n\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc64=2\u0010\n2\u00b92\u00b9\ud835\udc64\u00b8\ud835\udc65\u00b8\ud835\udc66\u00b8\ud835\udc67\u00ba\u00002\u00b9\ud835\udc64\u00b8\ud835\udc65\u0000\ud835\udc66\u0000\ud835\udc67\u00ba\u00ba\u0010\n\u00b9\ud835\udc64\u00b8\ud835\udc65\u00b8\ud835\udc66\u00b8\ud835\udc67\u00ba2\u0000\u00b9\ud835\udc64\u00b8\ud835\udc65\u0000\ud835\udc66\u0000\ud835\udc67\u00ba2\u0011\n\u00b8\n2\u00b92\u00b9\ud835\udc64\u00b8\ud835\udc65\u0000\ud835\udc66\u0000\ud835\udc67\u00ba\u00b82\u00b9\ud835\udc64\u00b8\ud835\udc65\u00b8\ud835\udc66\u00b8\ud835\udc67\u00ba\u00ba\u0010\n\u00b9\ud835\udc64\u00b8\ud835\udc65\u0000\ud835\udc66\u0000\ud835\udc67\u00ba2\u00b8\u00b9\ud835\udc64\u00b8\ud835\udc65\u00b8\ud835\udc66\u00b8\ud835\udc67\u00ba2\u0011\u0011\n\u0002\n\u0012\u0010\n\u00b9\ud835\udc64\u00b8\ud835\udc65\u00b8\ud835\udc66\u00b8\ud835\udc67\u00ba2\u0000\u00b9\ud835\udc64\u00b8\ud835\udc65\u0000\ud835\udc66\u0000\ud835\udc67\u00ba2\u00112\n\u00b8\u0010\n\u00b9\ud835\udc64\u00b8\ud835\udc65\u0000\ud835\udc66\u0000\ud835\udc67\u00ba2\u00b8\u00b9\ud835\udc64\u00b8\ud835\udc65\u00b8\ud835\udc66\u00b8\ud835\udc67\u00ba2\u00112\u0013\n.\n(A.16)\nIf we then also wanted to compute\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc65, we would end up with a similar equation again with\nmany repeated terms, and many sharedrepeated terms between the two derivatives. This\nrepresentsamassivequantityofwastedwork, andifweneededtocomputederivativesthis\nway, the whole deep learning revolution would have stalled out before it began!\nLet\u2019s break up the problem. We will start by trying to understand how \ud835\udc53changes when we\nchange\ud835\udc4e, essentially assuming that \ud835\udc64,\ud835\udc65,\ud835\udc66, and\ud835\udc67all do not exist. We will reason as we\ndid back when we worked with the gradient for the first time. Let\u2019s take \ud835\udc4eand add a small\namount\ud835\udf16to it.\n\ud835\udc53\u00b9\ud835\udc62\u00b9\ud835\udc4e\u00b8\ud835\udf16,\ud835\udc4f\u00ba,\ud835\udc63\u00b9\ud835\udc4e\u00b8\ud835\udf16,\ud835\udc4f\u00ba\u00ba\n\u0019\ud835\udc53\u0012\n\ud835\udc62\u00b9\ud835\udc4e,\ud835\udc4f\u00ba\u00b8\ud835\udf16\ud835\udf15\ud835\udc62\n\ud835\udf15\ud835\udc4e\u00b9\ud835\udc4e,\ud835\udc4f\u00ba,\ud835\udc63\u00b9\ud835\udc4e,\ud835\udc4f\u00ba\u00b8\ud835\udf16\ud835\udf15\ud835\udc63\n\ud835\udf15\ud835\udc4e\u00b9\ud835\udc4e,\ud835\udc4f\u00ba\u0013\n\u0019\ud835\udc53\u00b9\ud835\udc62\u00b9\ud835\udc4e,\ud835\udc4f\u00ba,\ud835\udc63\u00b9\ud835\udc4e,\ud835\udc4f\u00ba\u00ba\u00b8\ud835\udf16\u0014\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc62\u00b9\ud835\udc62\u00b9\ud835\udc4e,\ud835\udc4f\u00ba,\ud835\udc63\u00b9\ud835\udc4e,\ud835\udc4f\u00ba\u00ba\ud835\udf15\ud835\udc62\n\ud835\udf15\ud835\udc4e\u00b9\ud835\udc4e,\ud835\udc4f\u00ba\u00b8\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc63\u00b9\ud835\udc62\u00b9\ud835\udc4e,\ud835\udc4f\u00ba,\ud835\udc63\u00b9\ud835\udc4e,\ud835\udc4f\u00ba\u00ba\ud835\udf15\ud835\udc63\n\ud835\udf15\ud835\udc4e\u00b9\ud835\udc4e,\ud835\udc4f\u00ba\u0015\n.\n(A.17)\nThe first line follows from the definition of partial derivative, and the second follows from\nthe definition of gradient.", "mimetype": "text/plain", "start_char_idx": 1946730, "end_char_idx": 1948195, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6161a539-ad9c-4ee2-8740-d6602bb43990": {"__data__": {"id_": "6161a539-ad9c-4ee2-8740-d6602bb43990", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0c6c2b56-2b1b-4023-a2e2-4e60bc1ead9e", "node_type": "1", "metadata": {}, "hash": "df365f754194691938861b7238675f38a5f5b2d89b54923becb35964a819c757", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e31e278c-d1d2-4198-97fe-74ddc7835c9d", "node_type": "1", "metadata": {}, "hash": "9b4e9c57f9770f13ff0f330b83697af7391dd4e58727b085fa0c18dcdf87e503", "class_name": "RelatedNodeInfo"}}, "text": "(A.17)\nThe first line follows from the definition of partial derivative, and the second follows from\nthe definition of gradient. It is notationally burdensome to track exactly where we evaluate\nevery derivative, as in the expression\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc62\u00b9\ud835\udc62\u00b9\ud835\udc4e,\ud835\udc4f\u00ba,\ud835\udc63\u00b9\ud835\udc4e,\ud835\udc4f\u00ba\u00ba, so we often abbreviate this to\nthe much more memorable\n\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc4e=\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc62\ud835\udf15\ud835\udc62\n\ud835\udf15\ud835\udc4e\u00b8\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc63\ud835\udf15\ud835\udc63\n\ud835\udf15\ud835\udc4e. (A.18)\nIt is useful to think about the meaning of the process. We are trying to understand how\na function of the form \ud835\udc53\u00b9\ud835\udc62\u00b9\ud835\udc4e,\ud835\udc4f\u00ba,\ud835\udc63\u00b9\ud835\udc4e,\ud835\udc4f\u00ba\u00bachanges its value with a change in \ud835\udc4e. There\nare two pathways this can occur: there is the pathway where \ud835\udc4e!\ud835\udc62!\ud835\udc53and where\n\ud835\udc4e!\ud835\udc63!\ud835\udc53. We can compute both of these contributions via the chain rule:\ud835\udf15\ud835\udc64\n\ud835\udf15\ud835\udc62\u0001\ud835\udf15\ud835\udc62\n\ud835\udf15\ud835\udc65and\n\ud835\udf15\ud835\udc64\n\ud835\udf15\ud835\udc63\u0001\ud835\udf15\ud835\udc63\n\ud835\udf15\ud835\udc65respectively, and added up.\nImagine we have a different network of functions where the functions on the right depend\non those that are connected to on the left as is shown in Fig. A.2.\ntFig. A.2 Another more subtle example of the chain rule.\n941 Multivariable Calculus\nTo compute something like\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc66, we need to sum over all (in this case 3) paths from \ud835\udc66to\ud835\udc53\ngiving\n\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc66=\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc4e\ud835\udf15\ud835\udc4e\n\ud835\udf15\ud835\udc62\ud835\udf15\ud835\udc62\n\ud835\udf15\ud835\udc66\u00b8\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc62\ud835\udf15\ud835\udc62\n\ud835\udf15\ud835\udc66\u00b8\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc4f\ud835\udf15\ud835\udc4f\n\ud835\udf15\ud835\udc63\ud835\udf15\ud835\udc63\n\ud835\udf15\ud835\udc66. (A.19)\nUnderstandingthechainruleinthiswaywillpaygreatdividendswhentryingtounderstand\nhow gradients flow through networks, and why various architectural choices like those in\nLSTMs ( Section 10.1 ) or residual layers ( Section 8.6 ) can help shape the learning process\nby controlling gradient flow.\nA.4.5TheBackpropagationAlgorithm\nLet\u2019s return to the example of (A.14 )the previous section where\n\ud835\udc53\u00b9\ud835\udc62,\ud835\udc63\u00ba=\u00b9\ud835\udc62\u00b8\ud835\udc63\u00ba2\n\ud835\udc62\u00b9\ud835\udc4e,\ud835\udc4f\u00ba=\u00b9\ud835\udc4e\u00b8\ud835\udc4f\u00ba2, \ud835\udc63\u00b9\ud835\udc4e,\ud835\udc4f\u00ba=\u00b9\ud835\udc4e\u0000\ud835\udc4f\u00ba2,\n\ud835\udc4e\u00b9\ud835\udc64,\ud835\udc65,\ud835\udc66,\ud835\udc67\u00ba=\u00b9\ud835\udc64\u00b8\ud835\udc65\u00b8\ud835\udc66\u00b8\ud835\udc67\u00ba2, \ud835\udc4f\u00b9\ud835\udc64,\ud835\udc65,\ud835\udc66,\ud835\udc67\u00ba=\u00b9\ud835\udc64\u00b8\ud835\udc65\u0000\ud835\udc66\u0000\ud835\udc67\u00ba2.", "mimetype": "text/plain", "start_char_idx": 1948067, "end_char_idx": 1949653, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e31e278c-d1d2-4198-97fe-74ddc7835c9d": {"__data__": {"id_": "e31e278c-d1d2-4198-97fe-74ddc7835c9d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6161a539-ad9c-4ee2-8740-d6602bb43990", "node_type": "1", "metadata": {}, "hash": "4e9fa352099e463fd6692f346d006a9c46d34a65b555ab4dc7bb249c44a39555", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b666e30d-dbf0-46aa-bdd8-26d5defda016", "node_type": "1", "metadata": {}, "hash": "f17b7aee7092a1338c256d98950a96c695a1acaa3ef4e2fa76f02410ced10682", "class_name": "RelatedNodeInfo"}}, "text": "A.4.5TheBackpropagationAlgorithm\nLet\u2019s return to the example of (A.14 )the previous section where\n\ud835\udc53\u00b9\ud835\udc62,\ud835\udc63\u00ba=\u00b9\ud835\udc62\u00b8\ud835\udc63\u00ba2\n\ud835\udc62\u00b9\ud835\udc4e,\ud835\udc4f\u00ba=\u00b9\ud835\udc4e\u00b8\ud835\udc4f\u00ba2, \ud835\udc63\u00b9\ud835\udc4e,\ud835\udc4f\u00ba=\u00b9\ud835\udc4e\u0000\ud835\udc4f\u00ba2,\n\ud835\udc4e\u00b9\ud835\udc64,\ud835\udc65,\ud835\udc66,\ud835\udc67\u00ba=\u00b9\ud835\udc64\u00b8\ud835\udc65\u00b8\ud835\udc66\u00b8\ud835\udc67\u00ba2, \ud835\udc4f\u00b9\ud835\udc64,\ud835\udc65,\ud835\udc66,\ud835\udc67\u00ba=\u00b9\ud835\udc64\u00b8\ud835\udc65\u0000\ud835\udc66\u0000\ud835\udc67\u00ba2.(A.20)\nIf we want to compute say\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc64we may apply the multi-variate chain rule to see:\n\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc64=\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc62\ud835\udf15\ud835\udc62\n\ud835\udf15\ud835\udc64\u00b8\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc63\ud835\udf15\ud835\udc63\n\ud835\udf15\ud835\udc64,\n\ud835\udf15\ud835\udc62\n\ud835\udf15\ud835\udc64=\ud835\udf15\ud835\udc62\n\ud835\udf15\ud835\udc4e\ud835\udf15\ud835\udc4e\n\ud835\udf15\ud835\udc64\u00b8\ud835\udf15\ud835\udc62\n\ud835\udf15\ud835\udc4f\ud835\udf15\ud835\udc4f\n\ud835\udf15\ud835\udc64,\n\ud835\udf15\ud835\udc63\n\ud835\udf15\ud835\udc64=\ud835\udf15\ud835\udc63\n\ud835\udf15\ud835\udc4e\ud835\udf15\ud835\udc4e\n\ud835\udf15\ud835\udc64\u00b8\ud835\udf15\ud835\udc63\n\ud835\udf15\ud835\udc4f\ud835\udf15\ud835\udc4f\n\ud835\udf15\ud835\udc64.(A.21)\nLet\u2019s try using this decomposition to compute\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc64. Notice that all we need here are the\nvarious single step partials:\n\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc62=2\u00b9\ud835\udc62\u00b8\ud835\udc63\u00ba,\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc63=2\u00b9\ud835\udc62\u00b8\ud835\udc63\u00ba,\n\ud835\udf15\ud835\udc62\n\ud835\udf15\ud835\udc4e=2\u00b9\ud835\udc4e\u00b8\ud835\udc4f\u00ba,\ud835\udf15\ud835\udc62\n\ud835\udf15\ud835\udc4f=2\u00b9\ud835\udc4e\u00b8\ud835\udc4f\u00ba,\n\ud835\udf15\ud835\udc63\n\ud835\udf15\ud835\udc4e=2\u00b9\ud835\udc4e\u0000\ud835\udc4f\u00ba,\ud835\udf15\ud835\udc63\n\ud835\udf15\ud835\udc4f=\u00002\u00b9\ud835\udc4e\u0000\ud835\udc4f\u00ba,\n\ud835\udf15\ud835\udc4e\n\ud835\udf15\ud835\udc64=2\u00b9\ud835\udc64\u00b8\ud835\udc65\u00b8\ud835\udc66\u00b8\ud835\udc67\u00ba,\ud835\udf15\ud835\udc4f\n\ud835\udf15\ud835\udc64=2\u00b9\ud835\udc64\u00b8\ud835\udc65\u0000\ud835\udc66\u0000\ud835\udc67\u00ba.(A.22)\nIf we write this out into code this becomes a fairly manageable expression.", "mimetype": "text/plain", "start_char_idx": 1949466, "end_char_idx": 1950150, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b666e30d-dbf0-46aa-bdd8-26d5defda016": {"__data__": {"id_": "b666e30d-dbf0-46aa-bdd8-26d5defda016", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e31e278c-d1d2-4198-97fe-74ddc7835c9d", "node_type": "1", "metadata": {}, "hash": "9b4e9c57f9770f13ff0f330b83697af7391dd4e58727b085fa0c18dcdf87e503", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "de91eca8-1f38-4e8e-8123-00f4dffb6e6b", "node_type": "1", "metadata": {}, "hash": "bce268023ba4b4ae0be4d8d7456bb45657718004776d8b8133f0921b06108a53", "class_name": "RelatedNodeInfo"}}, "text": "(A.22)\nIf we write this out into code this becomes a fairly manageable expression.\n# Compute the value of the function from inputs to outputs\nw, x, y, z =-1,0,-2,1\na, b =(w+x+y+z)**2, (w +x-y-z)**2\nu, v =(a+b)**2, (a -b)**2\nf=(u+v)**2\nprint (f' f at {w},{x},{y},{z}is{f}')\n# Compute the single step partials\ndf_du, df_dv =2*(u+v), 2*(u+v)\n(continues on next page)\n942 Mathematics for Deep Learning\n(continued from previous page)\ndu_da, du_db, dv_da, dv_db =2*(a+b), 2*(a+b), 2*(a-b), -2*(a-b)\nda_dw, db_dw =2*(w+x+y+z), 2*(w+x-y-z)\n# Compute the final result from inputs to outputs\ndu_dw, dv_dw =du_da *da_dw +du_db *db_dw, dv_da *da_dw +dv_db *db_dw\ndf_dw =df_du *du_dw +df_dv *dv_dw\nprint (f'df/dw at {w},{x},{y},{z}is{df_dw }')\nf at -1,0,-2,1is1024\ndf/dw at -1,0,-2,1is-4096\nHowever, note that this still does not make it easy to compute something like\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc65. The\nreasonforthatisthe waywechosetoapplythechainrule. Ifwelookatwhatwedidabove,\nwe always kept \ud835\udf15\ud835\udc64in the denominator when we could. In this way, we chose to apply the\nchainruleseeinghow \ud835\udc64changedeveryothervariable. Ifthatiswhatwewanted,thiswould\nbe a good idea. However, think back to our motivation from deep learning: we want to see\nhow every parameter changes the loss. In essence, we want to apply the chain rule keeping\n\ud835\udf15\ud835\udc53in the numerator whenever we can!\nTo be more explicit, note that we can write\n\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc64=\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc4e\ud835\udf15\ud835\udc4e\n\ud835\udf15\ud835\udc64\u00b8\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc4f\ud835\udf15\ud835\udc4f\n\ud835\udf15\ud835\udc64,\n\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc4e=\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc62\ud835\udf15\ud835\udc62\n\ud835\udf15\ud835\udc4e\u00b8\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc63\ud835\udf15\ud835\udc63\n\ud835\udf15\ud835\udc4e,\n\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc4f=\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc62\ud835\udf15\ud835\udc62\n\ud835\udf15\ud835\udc4f\u00b8\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc63\ud835\udf15\ud835\udc63\n\ud835\udf15\ud835\udc4f.(A.23)\nNotethatthisapplicationofthechainrulehasusexplicitlycompute\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc62,\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc63,\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc4e,\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc4f,and\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc64.\nNothing stops us from also including the equations:\n\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc65=\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc4e\ud835\udf15\ud835\udc4e\n\ud835\udf15\ud835\udc65\u00b8\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc4f\ud835\udf15\ud835\udc4f\n\ud835\udf15\ud835\udc65,\n\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc66=\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc4e\ud835\udf15\ud835\udc4e\n\ud835\udf15\ud835\udc66\u00b8\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc4f\ud835\udf15\ud835\udc4f\n\ud835\udf15\ud835\udc66,\n\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc67=\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc4e\ud835\udf15\ud835\udc4e\n\ud835\udf15\ud835\udc67\u00b8\ud835\udf15\ud835\udc53\n\ud835\udf15\ud835\udc4f\ud835\udf15\ud835\udc4f\n\ud835\udf15\ud835\udc67.", "mimetype": "text/plain", "start_char_idx": 1950068, "end_char_idx": 1951757, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "de91eca8-1f38-4e8e-8123-00f4dffb6e6b": {"__data__": {"id_": "de91eca8-1f38-4e8e-8123-00f4dffb6e6b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b666e30d-dbf0-46aa-bdd8-26d5defda016", "node_type": "1", "metadata": {}, "hash": "f17b7aee7092a1338c256d98950a96c695a1acaa3ef4e2fa76f02410ced10682", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "716d466a-d6d8-4d2d-abb5-ed754f4de062", "node_type": "1", "metadata": {}, "hash": "4a89cb66970fa87fc2c73bd15aa9ac11f69b7e1e142c9814852efb13ba30e67b", "class_name": "RelatedNodeInfo"}}, "text": "(A.24)\nand then keeping track of how \ud835\udc53changes when we change anynode in the entire network.\nLet\u2019s implement it.\n# Compute the value of the function from inputs to outputs\nw, x, y, z =-1,0,-2,1\na, b =(w+x+y+z)**2, (w +x-y-z)**2\nu, v =(a+b)**2, (a -b)**2\nf=(u+v)**2\nprint (f'f at {w},{x},{y},{z}is{f}')\n# Compute the derivative using the decomposition above\n(continues on next page)\n943 Multivariable Calculus\n(continued from previous page)\n# First compute the single step partials\ndf_du, df_dv =2*(u+v), 2*(u+v)\ndu_da, du_db, dv_da, dv_db =2*(a+b), 2*(a+b), 2*(a-b), -2*(a-b)\nda_dw, db_dw =2*(w+x+y+z), 2*(w+x-y-z)\nda_dx, db_dx =2*(w+x+y+z), 2*(w+x-y-z)\nda_dy, db_dy =2*(w+x+y+z), -2*(w+x-y-z)\nda_dz, db_dz =2*(w+x+y+z), -2*(w+x-y-z)\n# Now compute how f changes when we change any value from output to input\ndf_da, df_db =df_du *du_da +df_dv *dv_da, df_du *du_db +df_dv *dv_db\ndf_dw, df_dx =df_da *da_dw +df_db *db_dw, df_da *da_dx +df_db *db_dx\ndf_dy, df_dz =df_da *da_dy +df_db *db_dy, df_da *da_dz +df_db *db_dz\nprint (f'df/dw at {w},{x},{y},{z}is{df_dw }')\nprint (f'df/dx at {w},{x},{y},{z}is{df_dx }')\nprint (f'df/dy at {w},{x},{y},{z}is{df_dy }')\nprint (f'df/dz at {w},{x},{y},{z}is{df_dz }')\nf at -1,0,-2,1is1024\ndf/dw at -1,0,-2,1is-4096\ndf/dx at -1,0,-2,1is-4096\ndf/dy at -1,0,-2,1is-4096\ndf/dz at -1,0,-2,1is-4096\nThe fact that we compute derivatives from \ud835\udc53back towards the inputs rather than from the\ninputs forward to the outputs (as we did in the first code snippet above) is what gives this\nalgorithm its name: backpropagation . Note that there are two steps: 1. Compute the value\nof the function, and the single step partials from front to back. While not done above, this\ncan be combined into a single forward pass . 2. Compute the gradient of \ud835\udc53from back to\nfront. We call this the backwardspass .\nThis is precisely what every deep learning algorithm implements to allow the computation\nof the gradient of the loss with respect to every weight in the network at one pass. It is an\nastonishing fact that we have such a decomposition.\nTo see how to encapsulated this, let\u2019s take a quick look at this example.\n# Initialize as ndarrays, then attach gradients\nw=torch .tensor([ -1.], requires_grad =True )\nx=torch .tensor([ 0.], requires_grad =True )\ny=torch .tensor([ -2.], requires_grad =True )\nz=torch .tensor([ 1.", "mimetype": "text/plain", "start_char_idx": 1951757, "end_char_idx": 1954084, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "716d466a-d6d8-4d2d-abb5-ed754f4de062": {"__data__": {"id_": "716d466a-d6d8-4d2d-abb5-ed754f4de062", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "de91eca8-1f38-4e8e-8123-00f4dffb6e6b", "node_type": "1", "metadata": {}, "hash": "bce268023ba4b4ae0be4d8d7456bb45657718004776d8b8133f0921b06108a53", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e0fe5a01-0595-4b25-bcf6-8fd87515d906", "node_type": "1", "metadata": {}, "hash": "d61e1f0f5be0d8a310d137bf4966293646d376db5f192ca5b9c08cf4e3b73bb9", "class_name": "RelatedNodeInfo"}}, "text": "Note that there are two steps: 1. Compute the value\nof the function, and the single step partials from front to back. While not done above, this\ncan be combined into a single forward pass . 2. Compute the gradient of \ud835\udc53from back to\nfront. We call this the backwardspass .\nThis is precisely what every deep learning algorithm implements to allow the computation\nof the gradient of the loss with respect to every weight in the network at one pass. It is an\nastonishing fact that we have such a decomposition.\nTo see how to encapsulated this, let\u2019s take a quick look at this example.\n# Initialize as ndarrays, then attach gradients\nw=torch .tensor([ -1.], requires_grad =True )\nx=torch .tensor([ 0.], requires_grad =True )\ny=torch .tensor([ -2.], requires_grad =True )\nz=torch .tensor([ 1.], requires_grad =True )\n# Do the computation like usual, tracking gradients\na, b =(w+x+y+z)**2, (w +x-y-z)**2\nu, v =(a+b)**2, (a -b)**2\nf=(u+v)**2\n# Execute backward pass\nf.backward()\nprint (f'df/dw at {w.data .item() },{x.data .item() },{y.data .item() },'\n(continues on next page)\n944 Mathematics for Deep Learning\n(continued from previous page)\nf'{z.data .item() }is{w.grad .data .item() }')\nprint (f'df/dx at {w.data .item() },{x.data .item() },{y.data .item() },'\nf'{z.data .item() }is{x.grad .data .item() }')\nprint (f'df/dy at {w.data .item() },{x.data .item() },{y.data .item() },'\nf'{z.data .item() }is{y.grad .data .item() }')\nprint (f'df/dz at {w.data .item() },{x.data .item() },{y.data .item() },'\nf'{z.data .item() }is{z.grad .data .item() }')\ndf/dw at -1.0,0.0,-2.0,1.0 is-4096.0\ndf/dx at -1.0,0.0,-2.0,1.0 is-4096.0\ndf/dy at -1.0,0.0,-2.0,1.0 is-4096.0\ndf/dz at -1.0,0.0,-2.0,1.0 is-4096.0\nAll of what we did above can be done automatically by calling f.backwards() .\nA.4.6Hessians\nAs with single variable calculus, it is useful to consider higher-order derivatives in order\nto get a handle on how we can obtain a better approximation to a function than using the\ngradient alone.\nThere is one immediate problem one encounters when working with higher order deriva-\ntives of functions of several variables, and that is there are a large number of them. If we\nhave a function \ud835\udc53\u00b9\ud835\udc651,...,\ud835\udc65\ud835\udc5b\u00baof\ud835\udc5bvariables, then we can take \ud835\udc5b2many second derivatives,\nnamely for any choice of \ud835\udc56and\ud835\udc57:\n\ud835\udc512\ud835\udc53\n\ud835\udc51\ud835\udc65\ud835\udc56\ud835\udc51\ud835\udc65\ud835\udc57=\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc56\u0012\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc57\ud835\udc53\u0013\n. (A.25)\nThis is traditionally assembled into a matrix called the Hessian:\nH\ud835\udc53=26666664\ud835\udc512\ud835\udc53\n\ud835\udc51\ud835\udc651\ud835\udc51\ud835\udc651\u0001\u0001\u0001\ud835\udc512\ud835\udc53\n\ud835\udc51\ud835\udc651\ud835\udc51\ud835\udc65\ud835\udc5b.........\n\ud835\udc512\ud835\udc53\n\ud835\udc51\ud835\udc65\ud835\udc5b\ud835\udc51\ud835\udc651\u0001\u0001\u0001\ud835\udc512\ud835\udc53\n\ud835\udc51\ud835\udc65\ud835\udc5b\ud835\udc51\ud835\udc65\ud835\udc5b37777775. (A.26)\nNot every entry of this matrix is independent.", "mimetype": "text/plain", "start_char_idx": 1953299, "end_char_idx": 1955807, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e0fe5a01-0595-4b25-bcf6-8fd87515d906": {"__data__": {"id_": "e0fe5a01-0595-4b25-bcf6-8fd87515d906", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "716d466a-d6d8-4d2d-abb5-ed754f4de062", "node_type": "1", "metadata": {}, "hash": "4a89cb66970fa87fc2c73bd15aa9ac11f69b7e1e142c9814852efb13ba30e67b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "610baafe-749c-4f5b-a6aa-66a8ca91c7d9", "node_type": "1", "metadata": {}, "hash": "c5c0309416ad439bcd9c2d996fc29cff2a199a86de465ef6eb1a73847c80f9a8", "class_name": "RelatedNodeInfo"}}, "text": "(A.25)\nThis is traditionally assembled into a matrix called the Hessian:\nH\ud835\udc53=26666664\ud835\udc512\ud835\udc53\n\ud835\udc51\ud835\udc651\ud835\udc51\ud835\udc651\u0001\u0001\u0001\ud835\udc512\ud835\udc53\n\ud835\udc51\ud835\udc651\ud835\udc51\ud835\udc65\ud835\udc5b.........\n\ud835\udc512\ud835\udc53\n\ud835\udc51\ud835\udc65\ud835\udc5b\ud835\udc51\ud835\udc651\u0001\u0001\u0001\ud835\udc512\ud835\udc53\n\ud835\udc51\ud835\udc65\ud835\udc5b\ud835\udc51\ud835\udc65\ud835\udc5b37777775. (A.26)\nNot every entry of this matrix is independent. Indeed, we can show that as long as both\nmixed partials (partial derivatives with respect to more than one variable) exist and are\ncontinuous, we can say that for any \ud835\udc56, and\ud835\udc57,\n\ud835\udc512\ud835\udc53\n\ud835\udc51\ud835\udc65\ud835\udc56\ud835\udc51\ud835\udc65\ud835\udc57=\ud835\udc512\ud835\udc53\n\ud835\udc51\ud835\udc65\ud835\udc57\ud835\udc51\ud835\udc65\ud835\udc56. (A.27)\nThis follows by considering first perturbing a function in the direction of \ud835\udc65\ud835\udc56, and then per-\nturbing it in\ud835\udc65\ud835\udc57and then comparing the result of that with what happens if we perturb first\n\ud835\udc65\ud835\udc57and then\ud835\udc65\ud835\udc56, with the knowledge that both of these orders lead to the same final change\nin the output of \ud835\udc53.\nAs with single variables, we can use these derivatives to get a far better idea of how the\n945 Multivariable Calculus\nfunction behaves near a point. In particular, we can use it to find the best fitting quadratic\nnear a point x0, as we saw in a single variable.\nLet\u2019s see an example. Suppose that \ud835\udc53\u00b9\ud835\udc651,\ud835\udc652\u00ba=\ud835\udc4e\u00b8\ud835\udc4f1\ud835\udc651\u00b8\ud835\udc4f2\ud835\udc652\u00b8\ud835\udc5011\ud835\udc652\n1\u00b8\ud835\udc5012\ud835\udc651\ud835\udc652\u00b8\ud835\udc5022\ud835\udc652\n2.\nThis is the general form for a quadratic in two variables. If we look at the value of the\nfunction, its gradient, and its Hessian (A.26 ), all at the point zero:\n\ud835\udc53\u00b90,0\u00ba=\ud835\udc4e,\nr\ud835\udc53\u00b90,0\u00ba=\u0014\ud835\udc4f1\n\ud835\udc4f2\u0015\n,\nH\ud835\udc53\u00b90,0\u00ba=\u00142\ud835\udc5011\ud835\udc5012\n\ud835\udc5012 2\ud835\udc5022\u0015\n,(A.28)\nwe can get our original polynomial back by saying\n\ud835\udc53\u00b9x\u00ba=\ud835\udc53\u00b90\u00ba\u00b8r\ud835\udc53\u00b90\u00ba\u0001x\u00b81\n2x>H\ud835\udc53\u00b90\u00bax. (A.29)\nIn general, if we computed this expansion any point x0, we see that\n\ud835\udc53\u00b9x\u00ba=\ud835\udc53\u00b9x0\u00ba\u00b8r\ud835\udc53\u00b9x0\u00ba\u0001\u00b9x\u0000x0\u00ba\u00b81\n2\u00b9x\u0000x0\u00ba>H\ud835\udc53\u00b9x0\u00ba\u00b9x\u0000x0\u00ba. (A.30)\nThisworksforanydimensionalinput,andprovidesthebestapproximatingquadratictoany\nfunction at a point. To give an example, let\u2019s plot the function\n\ud835\udc53\u00b9\ud835\udc65,\ud835\udc66\u00ba=\ud835\udc65\ud835\udc52\u0000\ud835\udc652\u0000\ud835\udc662. (A.31)\nOne can compute that the gradient and Hessian are\nr\ud835\udc53\u00b9\ud835\udc65,\ud835\udc66\u00ba=\ud835\udc52\u0000\ud835\udc652\u0000\ud835\udc662\u00121\u00002\ud835\udc652\n\u00002\ud835\udc65\ud835\udc66\u0013\nandH\ud835\udc53\u00b9\ud835\udc65,\ud835\udc66\u00ba=\ud835\udc52\u0000\ud835\udc652\u0000\ud835\udc662\u00124\ud835\udc653\u00006\ud835\udc65 4\ud835\udc652\ud835\udc66\u00002\ud835\udc66\n4\ud835\udc652\ud835\udc66\u00002\ud835\udc664\ud835\udc65\ud835\udc662\u00002\ud835\udc65\u0013\n.\n(A.32)\nAnd thus, with a little algebra, see that the approximating quadratic at \u00bb\u00001,0\u00bc>is\n\ud835\udc53\u00b9\ud835\udc65,\ud835\udc66\u00ba\u0019\ud835\udc52\u00001\u0010\n\u00001\u0000\u00b9\ud835\udc65\u00b81\u00ba\u00b8\u00b9\ud835\udc65\u00b81\u00ba2\u00b8\ud835\udc662\u0011\n.", "mimetype": "text/plain", "start_char_idx": 1955604, "end_char_idx": 1957508, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "610baafe-749c-4f5b-a6aa-66a8ca91c7d9": {"__data__": {"id_": "610baafe-749c-4f5b-a6aa-66a8ca91c7d9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e0fe5a01-0595-4b25-bcf6-8fd87515d906", "node_type": "1", "metadata": {}, "hash": "d61e1f0f5be0d8a310d137bf4966293646d376db5f192ca5b9c08cf4e3b73bb9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0e6a003c-c742-4e00-a6be-c4801b3bdcc5", "node_type": "1", "metadata": {}, "hash": "5f23cf2d1f8363cdb41510c8afa694303ccb425a4053d8bd76cece5e2f980462", "class_name": "RelatedNodeInfo"}}, "text": "(A.32)\nAnd thus, with a little algebra, see that the approximating quadratic at \u00bb\u00001,0\u00bc>is\n\ud835\udc53\u00b9\ud835\udc65,\ud835\udc66\u00ba\u0019\ud835\udc52\u00001\u0010\n\u00001\u0000\u00b9\ud835\udc65\u00b81\u00ba\u00b8\u00b9\ud835\udc65\u00b81\u00ba2\u00b8\ud835\udc662\u0011\n. (A.33)\n# Construct grid and compute function\nx, y =torch .meshgrid(torch .linspace( -2,2,101),\ntorch .linspace( -2,2,101))\nz=x*torch .exp( -x**2-y**2)\n# Compute approximating quadratic with gradient and Hessian at (1, 0)\nw=torch .exp(torch .tensor([ -1.]))*(-1-(x+1)+2*(x+1)**2+2*y**2)\n# Plot function\nax=d2l.plt.figure() .add_subplot( 111, projection ='3d')\nax.plot_wireframe(x .numpy(), y .numpy(), z .numpy(),\n**{'rstride ':10,'cstride ':10})\nax.plot_wireframe(x .numpy(), y .numpy(), w .numpy(),\n**{'rstride ':10,'cstride ':10}, color ='purple ')\n(continues on next page)\n946 Mathematics for Deep Learning\n(continued from previous page)\nd2l.plt.xlabel( 'x')\nd2l.plt.ylabel( 'y')\nd2l.set_figsize()\nax.set_xlim( -2,2)\nax.set_ylim( -2,2)\nax.set_zlim( -1,1)\nax.dist =12\nThis forms the basis for Newton\u2019s Algorithm discussed in Section 12.3 , where we perform\nnumerical optimization iteratively finding the best fitting quadratic, and then exactly mini-\nmizing that quadratic.\nA.4.7ALittle Matrix Calculus\nDerivatives of functions involving matrices turn out to be particularly nice. This section\ncanbecomenotationallyheavy,somaybeskippedinafirstreading,butitisusefultoknow\nhow derivatives of functions involving common matrix operations are often much cleaner\nthan one might initially anticipate, particularly given how central matrix operations are to\ndeep learning applications.\nLet\u2019s begin with an example. Suppose that we have some fixed column vector \ud835\udf37, and we\nwanttotaketheproductfunction \ud835\udc53\u00b9x\u00ba=\ud835\udf37>x,andunderstandhowthedotproductchanges\nwhen we change x.\nA bit of notation that will be useful when working with matrix derivatives in ML is called\nthedenominator layout matrix derivative where we assemble our partial derivatives into\nthe shape of whatever vector, matrix, or tensor is in the denominator of the differential. In\nthis case, we will write\n\ud835\udc51\ud835\udc53\n\ud835\udc51x=26666664\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc651...\n\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65\ud835\udc5b37777775, (A.34)\nwhere we matched the shape of the column vector x.\nIf we write out our function into components this is\n\ud835\udc53\u00b9x\u00ba=\ud835\udc5b\u00d5\n\ud835\udc56=1\ud835\udefd\ud835\udc56\ud835\udc65\ud835\udc56=\ud835\udefd1\ud835\udc651\u00b8\u0001\u0001\u0001\u00b8\ud835\udefd\ud835\udc5b\ud835\udc65\ud835\udc5b. (A.35)\n947 Multivariable Calculus\nIf we now take the partial derivative with respect to say \ud835\udefd1, note that everything is zero but\nthe first term, which is just \ud835\udc651multiplied by \ud835\udefd1, so we obtain that\n\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc651=\ud835\udefd1, (A.36)\nor more generally that\n\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65\ud835\udc56=\ud835\udefd\ud835\udc56. (A.37)\nWe can now reassemble this into a matrix to see\n\ud835\udc51\ud835\udc53\n\ud835\udc51x=26666664\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc651...\n\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65\ud835\udc5b37777775=2666664\ud835\udefd1\n...\n\ud835\udefd\ud835\udc5b3777775=\ud835\udf37. (A.38)\nThis illustrates a few factors about matrix calculus that we will often counter throughout\nthis section:\n\u000fFirst, The computations will get rather involved.\n\u000fSecond, The final results are much cleaner than the intermediate process, and will al-\nways look similar to the single variable case.", "mimetype": "text/plain", "start_char_idx": 1957385, "end_char_idx": 1960214, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0e6a003c-c742-4e00-a6be-c4801b3bdcc5": {"__data__": {"id_": "0e6a003c-c742-4e00-a6be-c4801b3bdcc5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "610baafe-749c-4f5b-a6aa-66a8ca91c7d9", "node_type": "1", "metadata": {}, "hash": "c5c0309416ad439bcd9c2d996fc29cff2a199a86de465ef6eb1a73847c80f9a8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bda6cfaf-92ba-44cd-9f23-88e29eeda142", "node_type": "1", "metadata": {}, "hash": "598ff6e889fac0d136790bd40b81e91390afe24f0e2a9ac8ce1053a256ac14e7", "class_name": "RelatedNodeInfo"}}, "text": "(A.37)\nWe can now reassemble this into a matrix to see\n\ud835\udc51\ud835\udc53\n\ud835\udc51x=26666664\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc651...\n\ud835\udc51\ud835\udc53\n\ud835\udc51\ud835\udc65\ud835\udc5b37777775=2666664\ud835\udefd1\n...\n\ud835\udefd\ud835\udc5b3777775=\ud835\udf37. (A.38)\nThis illustrates a few factors about matrix calculus that we will often counter throughout\nthis section:\n\u000fFirst, The computations will get rather involved.\n\u000fSecond, The final results are much cleaner than the intermediate process, and will al-\nways look similar to the single variable case. In this case, note that\ud835\udc51\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc4f\ud835\udc65\u00ba=\ud835\udc4fand\n\ud835\udc51\n\ud835\udc51x\u00b9\ud835\udf37>x\u00ba=\ud835\udf37are both similar.\n\u000fThird, transposes can often appear seemingly from nowhere. The core reason for this is\nthe convention that we match the shape of the denominator, thus when we multiply\nmatrices, we will need to take transposes to match back to the shape of the original\nterm.\nTo keep building intuition, let\u2019s try a computation that is a little harder. Suppose that we\nhave a column vector x, and a square matrix \ud835\udc34and we want to compute\n\ud835\udc51\n\ud835\udc51x\u00b9x>\ud835\udc34x\u00ba. (A.39)\nTo drive towards easier to manipulate notation, let\u2019s consider this problem using Einstein\nnotation. In this case we can write the function as\nx>\ud835\udc34x=\ud835\udc65\ud835\udc56\ud835\udc4e\ud835\udc56\ud835\udc57\ud835\udc65\ud835\udc57. (A.40)\nTo compute our derivative, we need to understand for every \ud835\udc58, what is the value of\n\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc58\u00b9x>\ud835\udc34x\u00ba=\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc58\ud835\udc65\ud835\udc56\ud835\udc4e\ud835\udc56\ud835\udc57\ud835\udc65\ud835\udc57. (A.41)\nBy the product rule, this is\n\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc58\ud835\udc65\ud835\udc56\ud835\udc4e\ud835\udc56\ud835\udc57\ud835\udc65\ud835\udc57=\ud835\udc51\ud835\udc65\ud835\udc56\n\ud835\udc51\ud835\udc65\ud835\udc58\ud835\udc4e\ud835\udc56\ud835\udc57\ud835\udc65\ud835\udc57\u00b8\ud835\udc65\ud835\udc56\ud835\udc4e\ud835\udc56\ud835\udc57\ud835\udc51\ud835\udc65\ud835\udc57\n\ud835\udc51\ud835\udc65\ud835\udc58. (A.42)\nFor a term like\ud835\udc51\ud835\udc65\ud835\udc56\n\ud835\udc51\ud835\udc65\ud835\udc58, it is not hard to see that this is one when \ud835\udc56=\ud835\udc58and zero otherwise.\nThis means that every term where \ud835\udc56and\ud835\udc58are different vanish from this sum, so the only\n948 Mathematics for Deep Learning\nterms that remain in that first sum are the ones where \ud835\udc56=\ud835\udc58. The same reasoning holds for\nthe second term where we need \ud835\udc57=\ud835\udc58. This gives\n\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc58\ud835\udc65\ud835\udc56\ud835\udc4e\ud835\udc56\ud835\udc57\ud835\udc65\ud835\udc57=\ud835\udc4e\ud835\udc58\ud835\udc57\ud835\udc65\ud835\udc57\u00b8\ud835\udc65\ud835\udc56\ud835\udc4e\ud835\udc56\ud835\udc58. (A.43)\nNow, the names of the indices in Einstein notation are arbitrary\u2014the fact that \ud835\udc56and\ud835\udc57are\ndifferentisimmaterialtothiscomputationatthispoint,sowecanre-indexsothattheyboth\nuse\ud835\udc56to see that\n\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc58\ud835\udc65\ud835\udc56\ud835\udc4e\ud835\udc56\ud835\udc57\ud835\udc65\ud835\udc57=\ud835\udc4e\ud835\udc58\ud835\udc56\ud835\udc65\ud835\udc56\u00b8\ud835\udc65\ud835\udc56\ud835\udc4e\ud835\udc56\ud835\udc58=\u00b9\ud835\udc4e\ud835\udc58\ud835\udc56\u00b8\ud835\udc4e\ud835\udc56\ud835\udc58\u00ba\ud835\udc65\ud835\udc56. (A.44)\nNow, here is where we start to need some practice to go further. Let\u2019s try and identify this\noutcome in terms of matrix operations. \ud835\udc4e\ud835\udc58\ud835\udc56\u00b8\ud835\udc4e\ud835\udc56\ud835\udc58is the\ud835\udc58,\ud835\udc56-th component of A\u00b8A>.", "mimetype": "text/plain", "start_char_idx": 1959796, "end_char_idx": 1961855, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bda6cfaf-92ba-44cd-9f23-88e29eeda142": {"__data__": {"id_": "bda6cfaf-92ba-44cd-9f23-88e29eeda142", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0e6a003c-c742-4e00-a6be-c4801b3bdcc5", "node_type": "1", "metadata": {}, "hash": "5f23cf2d1f8363cdb41510c8afa694303ccb425a4053d8bd76cece5e2f980462", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6602c357-9540-41f8-9795-01c5ca99552d", "node_type": "1", "metadata": {}, "hash": "e6c8bc7307237a26d40118df611094db27f02f90b6c53936dbdf961406bbeb86", "class_name": "RelatedNodeInfo"}}, "text": "(A.44)\nNow, here is where we start to need some practice to go further. Let\u2019s try and identify this\noutcome in terms of matrix operations. \ud835\udc4e\ud835\udc58\ud835\udc56\u00b8\ud835\udc4e\ud835\udc56\ud835\udc58is the\ud835\udc58,\ud835\udc56-th component of A\u00b8A>. This\ngives\n\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc58\ud835\udc65\ud835\udc56\ud835\udc4e\ud835\udc56\ud835\udc57\ud835\udc65\ud835\udc57=\u00bbA\u00b8A>\u00bc\ud835\udc58\ud835\udc56\ud835\udc65\ud835\udc56. (A.45)\nSimilarly, this term is now the product of the matrix A\u00b8A>by the vector x, so we see\nthat\u0014\ud835\udc51\n\ud835\udc51x\u00b9x>\ud835\udc34x\u00ba\u0015\n\ud835\udc58=\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc58\ud835\udc65\ud835\udc56\ud835\udc4e\ud835\udc56\ud835\udc57\ud835\udc65\ud835\udc57=\u00bb\u00b9A\u00b8A>\u00bax\u00bc\ud835\udc58. (A.46)\nThus, we see that the \ud835\udc58-th entry of the desired derivative from (A.39 )is just the\ud835\udc58-th entry\nof the vector on the right, and thus the two are the same. Thus yields\n\ud835\udc51\n\ud835\udc51x\u00b9x>\ud835\udc34x\u00ba=\u00b9A\u00b8A>\u00bax. (A.47)\nThis required significantly more work than our last one, but the final result is small. More\nthanthat,considerthefollowingcomputationfortraditionalsinglevariablederivatives:\n\ud835\udc51\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\ud835\udc4e\ud835\udc65\u00ba=\ud835\udc51\ud835\udc65\n\ud835\udc51\ud835\udc65\ud835\udc4e\ud835\udc65\u00b8\ud835\udc65\ud835\udc4e\ud835\udc51\ud835\udc65\n\ud835\udc51\ud835\udc65=\u00b9\ud835\udc4e\u00b8\ud835\udc4e\u00ba\ud835\udc65. (A.48)\nEquivalently\ud835\udc51\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc4e\ud835\udc652\u00ba=2\ud835\udc4e\ud835\udc65=\u00b9\ud835\udc4e\u00b8\ud835\udc4e\u00ba\ud835\udc65. Again, we get a result that looks rather like the\nsingle variable result but with a transpose tossed in.\nAt this point, the pattern should be looking rather suspicious, so let\u2019s try to figure out\nwhy. When we take matrix derivatives like this, let\u2019s first assume that the expression we\nget will be another matrix expression: an expression we can write it in terms of products\nand sums of matrices and their transposes. If such an expression exists, it will need to be\ntrue for all matrices. In particular, it will need to be true of 1\u00021matrices, in which case\nthe matrix product is just the product of the numbers, the matrix sum is just the sum, and\nthe transpose does nothing at all! In other words, whatever expression we get mustmatch\nthe single variable expression. This means that, with some practice, one can often guess\nmatrixderivativesjustbyknowingwhattheassociatedsinglevariableexpressionmustlook\nlike!\nLet\u2019s try this out. Suppose that Xis a\ud835\udc5b\u0002\ud835\udc5amatrix, Uis an\ud835\udc5b\u0002\ud835\udc5fandVis an\ud835\udc5f\u0002\ud835\udc5a. Let\u2019s\ntry to compute\n\ud835\udc51\n\ud835\udc51VkX\u0000UVk2\n2=? (A.49)\n949 Multivariable Calculus\nThis computation is important in an area called matrix factorization. For us, however, it is\njust a derivative to compute. Let\u2019s try to imagine what this would be for 1\u00021matrices. In\nthat case, we get the expression\n\ud835\udc51\n\ud835\udc51\ud835\udc63\u00b9\ud835\udc65\u0000\ud835\udc62\ud835\udc63\u00ba2=\u00002\u00b9\ud835\udc65\u0000\ud835\udc62\ud835\udc63\u00ba\ud835\udc62, (A.50)\nwhere, the derivative is rather standard. If we try to convert this back into a matrix expres-\nsion we get\n\ud835\udc51\n\ud835\udc51VkX\u0000UVk2\n2=\u00002\u00b9X\u0000UV\u00baU. (A.51)\nHowever, if we look at this it does not quite work. Recall that Xis\ud835\udc5b\u0002\ud835\udc5a, as isUV, so the\nmatrix 2\u00b9X\u0000UV\u00bais\ud835\udc5b\u0002\ud835\udc5a.", "mimetype": "text/plain", "start_char_idx": 1961678, "end_char_idx": 1964025, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6602c357-9540-41f8-9795-01c5ca99552d": {"__data__": {"id_": "6602c357-9540-41f8-9795-01c5ca99552d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bda6cfaf-92ba-44cd-9f23-88e29eeda142", "node_type": "1", "metadata": {}, "hash": "598ff6e889fac0d136790bd40b81e91390afe24f0e2a9ac8ce1053a256ac14e7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "92498833-a69e-4641-a86b-ab83b59056b6", "node_type": "1", "metadata": {}, "hash": "1cb03402f4c26685aab84f7df62dbb9621a2c2764b023be8b4c257c3975ee056", "class_name": "RelatedNodeInfo"}}, "text": "For us, however, it is\njust a derivative to compute. Let\u2019s try to imagine what this would be for 1\u00021matrices. In\nthat case, we get the expression\n\ud835\udc51\n\ud835\udc51\ud835\udc63\u00b9\ud835\udc65\u0000\ud835\udc62\ud835\udc63\u00ba2=\u00002\u00b9\ud835\udc65\u0000\ud835\udc62\ud835\udc63\u00ba\ud835\udc62, (A.50)\nwhere, the derivative is rather standard. If we try to convert this back into a matrix expres-\nsion we get\n\ud835\udc51\n\ud835\udc51VkX\u0000UVk2\n2=\u00002\u00b9X\u0000UV\u00baU. (A.51)\nHowever, if we look at this it does not quite work. Recall that Xis\ud835\udc5b\u0002\ud835\udc5a, as isUV, so the\nmatrix 2\u00b9X\u0000UV\u00bais\ud835\udc5b\u0002\ud835\udc5a. On the other hand Uis\ud835\udc5b\u0002\ud835\udc5f, and we cannot multiply a \ud835\udc5b\u0002\ud835\udc5a\nand a\ud835\udc5b\u0002\ud835\udc5fmatrix since the dimensions do not match!\nWe want to get\ud835\udc51\n\ud835\udc51V, which is the same shape as V, which is\ud835\udc5f\u0002\ud835\udc5a. So somehow we need\nto take a\ud835\udc5b\u0002\ud835\udc5amatrix and a \ud835\udc5b\u0002\ud835\udc5fmatrix, multiply them together (perhaps with some\ntransposes) to get a \ud835\udc5f\u0002\ud835\udc5a. We can do this by multiplying \ud835\udc48>by\u00b9X\u0000UV\u00ba. Thus, we can\nguess the solution to (A.49 )is\n\ud835\udc51\n\ud835\udc51VkX\u0000UVk2\n2=\u00002U>\u00b9X\u0000UV\u00ba. (A.52)\nTo show that this works, we would be remiss to not provide a detailed computation. If\nwe already believe that this rule-of-thumb works, feel free to skip past this derivation. To\ncompute\n\ud835\udc51\n\ud835\udc51VkX\u0000UVk2\n2, (A.53)\nwe must find for every \ud835\udc4e, and\ud835\udc4f\n\ud835\udc51\n\ud835\udc51\ud835\udc63\ud835\udc4e\ud835\udc4fkX\u0000UVk2\n2=\ud835\udc51\n\ud835\udc51\ud835\udc63\ud835\udc4e\ud835\udc4f\u00d5\n\ud835\udc56,\ud835\udc57 \n\ud835\udc65\ud835\udc56\ud835\udc57\u0000\u00d5\n\ud835\udc58\ud835\udc62\ud835\udc56\ud835\udc58\ud835\udc63\ud835\udc58\ud835\udc57!2\n. (A.54)\nRecalling that all entries of XandUare constants as far as\ud835\udc51\n\ud835\udc51\ud835\udc63\ud835\udc4e\ud835\udc4fis concerned, we may\npush the derivative inside the sum, and apply the chain rule to the square to get\n\ud835\udc51\n\ud835\udc51\ud835\udc63\ud835\udc4e\ud835\udc4fkX\u0000UVk2\n2=\u00d5\n\ud835\udc56,\ud835\udc572 \n\ud835\udc65\ud835\udc56\ud835\udc57\u0000\u00d5\n\ud835\udc58\ud835\udc62\ud835\udc56\ud835\udc58\ud835\udc63\ud835\udc58\ud835\udc57!  \n\u0000\u00d5\n\ud835\udc58\ud835\udc62\ud835\udc56\ud835\udc58\ud835\udc51\ud835\udc63\ud835\udc58\ud835\udc57\n\ud835\udc51\ud835\udc63\ud835\udc4e\ud835\udc4f!\n. (A.55)\nAs in the previous derivation, we may note that\ud835\udc51\ud835\udc63\ud835\udc58 \ud835\udc57\n\ud835\udc51\ud835\udc63\ud835\udc4e\ud835\udc4fis only non-zero if the \ud835\udc58=\ud835\udc4eand\n\ud835\udc57=\ud835\udc4f. If either of those conditions do not hold, the term in the sum is zero, and we may\nfreely discard it. We see that\n\ud835\udc51\n\ud835\udc51\ud835\udc63\ud835\udc4e\ud835\udc4fkX\u0000UVk2\n2=\u00002\u00d5\n\ud835\udc56 \n\ud835\udc65\ud835\udc56\ud835\udc4f\u0000\u00d5\n\ud835\udc58\ud835\udc62\ud835\udc56\ud835\udc58\ud835\udc63\ud835\udc58\ud835\udc4f!\n\ud835\udc62\ud835\udc56\ud835\udc4e. (A.56)\nAn important subtlety here is that the requirement that \ud835\udc58=\ud835\udc4edoes not occur inside the\n950 Mathematics for Deep Learning\ninner sum since that \ud835\udc58is a dummy variable which we are summing over inside the inner\nterm. For a notationally cleaner example, consider why\n\ud835\udc51\n\ud835\udc51\ud835\udc651 \u00d5\n\ud835\udc56\ud835\udc65\ud835\udc56!2\n=2 \u00d5\n\ud835\udc56\ud835\udc65\ud835\udc56!\n.", "mimetype": "text/plain", "start_char_idx": 1963602, "end_char_idx": 1965507, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "92498833-a69e-4641-a86b-ab83b59056b6": {"__data__": {"id_": "92498833-a69e-4641-a86b-ab83b59056b6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6602c357-9540-41f8-9795-01c5ca99552d", "node_type": "1", "metadata": {}, "hash": "e6c8bc7307237a26d40118df611094db27f02f90b6c53936dbdf961406bbeb86", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "699dd142-9901-4c19-bd5b-b35aac5e1531", "node_type": "1", "metadata": {}, "hash": "d848bbe458b71b24f4636e9e942cb5807ed55641179c8285ff849dcf1b05e136", "class_name": "RelatedNodeInfo"}}, "text": "We see that\n\ud835\udc51\n\ud835\udc51\ud835\udc63\ud835\udc4e\ud835\udc4fkX\u0000UVk2\n2=\u00002\u00d5\n\ud835\udc56 \n\ud835\udc65\ud835\udc56\ud835\udc4f\u0000\u00d5\n\ud835\udc58\ud835\udc62\ud835\udc56\ud835\udc58\ud835\udc63\ud835\udc58\ud835\udc4f!\n\ud835\udc62\ud835\udc56\ud835\udc4e. (A.56)\nAn important subtlety here is that the requirement that \ud835\udc58=\ud835\udc4edoes not occur inside the\n950 Mathematics for Deep Learning\ninner sum since that \ud835\udc58is a dummy variable which we are summing over inside the inner\nterm. For a notationally cleaner example, consider why\n\ud835\udc51\n\ud835\udc51\ud835\udc651 \u00d5\n\ud835\udc56\ud835\udc65\ud835\udc56!2\n=2 \u00d5\n\ud835\udc56\ud835\udc65\ud835\udc56!\n. (A.57)\nFrom this point, we may start identifying components of the sum. First,\n\u00d5\n\ud835\udc58\ud835\udc62\ud835\udc56\ud835\udc58\ud835\udc63\ud835\udc58\ud835\udc4f=\u00bbUV\u00bc\ud835\udc56\ud835\udc4f.(A.58)\nSo the entire expression in the inside of the sum is\n\ud835\udc65\ud835\udc56\ud835\udc4f\u0000\u00d5\n\ud835\udc58\ud835\udc62\ud835\udc56\ud835\udc58\ud835\udc63\ud835\udc58\ud835\udc4f=\u00bbX\u0000UV\u00bc\ud835\udc56\ud835\udc4f.(A.59)\nThis means we may now write our derivative as\n\ud835\udc51\n\ud835\udc51\ud835\udc63\ud835\udc4e\ud835\udc4fkX\u0000UVk2\n2=\u00002\u00d5\n\ud835\udc56\u00bbX\u0000UV\u00bc\ud835\udc56\ud835\udc4f\ud835\udc62\ud835\udc56\ud835\udc4e. (A.60)\nWe want this to look like the \ud835\udc4e,\ud835\udc4felement of a matrix so we can use the technique as in the\nprevious example to arrive at a matrix expression, which means that we need to exchange\nthe order of the indices on \ud835\udc62\ud835\udc56\ud835\udc4e. If we notice that \ud835\udc62\ud835\udc56\ud835\udc4e=\u00bbU>\u00bc\ud835\udc4e\ud835\udc56, we can then write\n\ud835\udc51\n\ud835\udc51\ud835\udc63\ud835\udc4e\ud835\udc4fkX\u0000UVk2\n2=\u00002\u00d5\n\ud835\udc56\u00bbU>\u00bc\ud835\udc4e\ud835\udc56\u00bbX\u0000UV\u00bc\ud835\udc56\ud835\udc4f. (A.61)\nThis is a matrix product, and thus we can conclude that\n\ud835\udc51\n\ud835\udc51\ud835\udc63\ud835\udc4e\ud835\udc4fkX\u0000UVk2\n2=\u00002\u00bbU>\u00b9X\u0000UV\u00ba\u00bc\ud835\udc4e\ud835\udc4f. (A.62)\nand thus we may write the solution to (A.49 )\n\ud835\udc51\n\ud835\udc51VkX\u0000UVk2\n2=\u00002U>\u00b9X\u0000UV\u00ba. (A.63)\nThis matches the solution we guessed above!\nIt is reasonable to ask at this point, \u201cWhy can I not just write down matrix versions of\nall the calculus rules I have learned? It is clear this is still mechanical. Why do we not\njust get it over with!\u201d And indeed there are such rules and ( Petersen and Pedersen, 2008 )\nprovides an excellent summary. However, due to the plethora of ways matrix operations\ncan be combined compared to single values, there are many more matrix derivative rules\nthansinglevariableones. Itisoftenthecasethatitisbesttoworkwiththeindices,orleave\nit up to automatic differentiation when appropriate.\nA.4.8Summary\n\u000fIn higher dimensions, we can define gradients which serve the same purpose as deriva-\ntives in one dimension. These allow us to see how a multi-variable function changes\nwhen we make an arbitrary small change to the inputs.\n951 Integral Calculus\n283\u000fThe backpropagation algorithm can be seen to be a method of organizing the multi-\nvariable chain rule to allow for the efficient computation of many partial derivatives.\n\u000fMatrix calculus allows us to write the derivatives of matrix expressions in concise ways.\nA.4.9Exercises\n1.Givenacolumnvector \ud835\udf37,computethederivativesofboth \ud835\udc53\u00b9x\u00ba=\ud835\udf37>xand\ud835\udc54\u00b9x\u00ba=x>\ud835\udf37.\nWhy do you get the same answer?\n2.Letvbe an\ud835\udc5bdimension vector. What is\ud835\udf15\n\ud835\udf15vkvk2?\n3.Let\ud835\udc3f\u00b9\ud835\udc65,\ud835\udc66\u00ba=log\u00b9\ud835\udc52\ud835\udc65\u00b8\ud835\udc52\ud835\udc66\u00ba. Compute the gradient.", "mimetype": "text/plain", "start_char_idx": 1965161, "end_char_idx": 1967618, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "699dd142-9901-4c19-bd5b-b35aac5e1531": {"__data__": {"id_": "699dd142-9901-4c19-bd5b-b35aac5e1531", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "92498833-a69e-4641-a86b-ab83b59056b6", "node_type": "1", "metadata": {}, "hash": "1cb03402f4c26685aab84f7df62dbb9621a2c2764b023be8b4c257c3975ee056", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4ce97d59-9318-4c6d-aef8-5f84a22fb1a4", "node_type": "1", "metadata": {}, "hash": "4b33117926e9ce030d46b5e171721a9e1c65d1d5c093c6f1bd42dd6ada2e82f2", "class_name": "RelatedNodeInfo"}}, "text": "These allow us to see how a multi-variable function changes\nwhen we make an arbitrary small change to the inputs.\n951 Integral Calculus\n283\u000fThe backpropagation algorithm can be seen to be a method of organizing the multi-\nvariable chain rule to allow for the efficient computation of many partial derivatives.\n\u000fMatrix calculus allows us to write the derivatives of matrix expressions in concise ways.\nA.4.9Exercises\n1.Givenacolumnvector \ud835\udf37,computethederivativesofboth \ud835\udc53\u00b9x\u00ba=\ud835\udf37>xand\ud835\udc54\u00b9x\u00ba=x>\ud835\udf37.\nWhy do you get the same answer?\n2.Letvbe an\ud835\udc5bdimension vector. What is\ud835\udf15\n\ud835\udf15vkvk2?\n3.Let\ud835\udc3f\u00b9\ud835\udc65,\ud835\udc66\u00ba=log\u00b9\ud835\udc52\ud835\udc65\u00b8\ud835\udc52\ud835\udc66\u00ba. Compute the gradient. What is the sum of the components\nof the gradient?\n4.Let\ud835\udc53\u00b9\ud835\udc65,\ud835\udc66\u00ba=\ud835\udc652\ud835\udc66\u00b8\ud835\udc65\ud835\udc662. Show that the only critical point is \u00b90,0\u00ba. By considering\n\ud835\udc53\u00b9\ud835\udc65,\ud835\udc65\u00ba, determine if\u00b90,0\u00bais a maximum, minimum, or neither.\n5.Suppose that we are minimizing a function \ud835\udc53\u00b9x\u00ba=\ud835\udc54\u00b9x\u00ba\u00b8\u210e\u00b9x\u00ba. How can we geomet-\nrically interpret the condition of r\ud835\udc53=0in terms of\ud835\udc54and\u210e?\nDiscussions283.\nA.5IntegralCalculus\nDifferentiation only makes up half of the content of a traditional calculus education. The\nother pillar, integration, starts out seeming a rather disjoint question, \u201cWhat is the area\nunderneath this curve?\u201d While seemingly unrelated, integration is tightly intertwined with\nthe differentiation via what is known as the fundamentaltheoremof calculus .\nAtthelevelofmachinelearningwediscussinthisbook,wewillnotneedadeepunderstand-\ning of integration. However, we will provide a brief introduction to lay the groundwork for\nany further applications we will encounter later on.\nA.5.1GeometricInterpretation\nSupposethatwehaveafunction \ud835\udc53\u00b9\ud835\udc65\u00ba. Forsimplicity,let\u2019sassumethat \ud835\udc53\u00b9\ud835\udc65\u00baisnon-negative\n(never takes a value less than zero). What we want to try and understand is: what is the\narea contained between \ud835\udc53\u00b9\ud835\udc65\u00baand the\ud835\udc65-axis?\n%matplotlib inline\nimport torch\nfrom IPython import display\nfrom mpl_toolkits import mplot3d\nfrom d2l import torch asd2l\n(continues on next page)\n952 Mathematics for Deep Learning\n(continued from previous page)\nx=torch .arange( -2,2,0.01 )\nf=torch .exp( -x**2)\nd2l.set_figsize()\nd2l.plt.plot(x, f, color ='black ')\nd2l.plt.fill_between(x .tolist(), f .tolist())\nd2l.plt.show()\nIn most cases, this area will be infinite or undefined (consider the area under \ud835\udc53\u00b9\ud835\udc65\u00ba=\ud835\udc652),\nso people will often talk about the area between a pair of ends, say \ud835\udc4eand\ud835\udc4f.\nx=torch .arange( -2,2,0.01 )\nf=torch .exp( -x**2)\nd2l.set_figsize()\nd2l.plt.plot(x, f, color ='black ')\nd2l.plt.fill_between(x .tolist()[ 50:250], f .tolist()[ 50:250])\nd2l.plt.show()\nWe will denote this area by the integral symbol below:\nArea\u00b9A\u00ba=\u00b9\ud835\udc4f\n\ud835\udc4e\ud835\udc53\u00b9\ud835\udc65\u00ba\ud835\udc51\ud835\udc65. (A.1)\nThe inner variable is a dummy variable, much like the index of a sum in a\u00cd, and so this\ncan be equivalently written with any inner value we like:\n\u00b9\ud835\udc4f\n\ud835\udc4e\ud835\udc53\u00b9\ud835\udc65\u00ba\ud835\udc51\ud835\udc65=\u00b9\ud835\udc4f\n\ud835\udc4e\ud835\udc53\u00b9\ud835\udc67\u00ba\ud835\udc51\ud835\udc67. (A.2)\n953 Integral Calculus\nThere is a traditional way to try and understand how we might try to approximate such\nintegrals: we can imagine taking the region in-between \ud835\udc4eand\ud835\udc4fand chopping it into \ud835\udc41\nvertical slices.", "mimetype": "text/plain", "start_char_idx": 1967006, "end_char_idx": 1969987, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4ce97d59-9318-4c6d-aef8-5f84a22fb1a4": {"__data__": {"id_": "4ce97d59-9318-4c6d-aef8-5f84a22fb1a4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "699dd142-9901-4c19-bd5b-b35aac5e1531", "node_type": "1", "metadata": {}, "hash": "d848bbe458b71b24f4636e9e942cb5807ed55641179c8285ff849dcf1b05e136", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c4272f47-f0cc-48fa-b821-a7dfc044a0a9", "node_type": "1", "metadata": {}, "hash": "40e1db2b6c7242e87329ef111ad199d795e81aa381076f934b6c6c509a21b6ce", "class_name": "RelatedNodeInfo"}}, "text": "(A.1)\nThe inner variable is a dummy variable, much like the index of a sum in a\u00cd, and so this\ncan be equivalently written with any inner value we like:\n\u00b9\ud835\udc4f\n\ud835\udc4e\ud835\udc53\u00b9\ud835\udc65\u00ba\ud835\udc51\ud835\udc65=\u00b9\ud835\udc4f\n\ud835\udc4e\ud835\udc53\u00b9\ud835\udc67\u00ba\ud835\udc51\ud835\udc67. (A.2)\n953 Integral Calculus\nThere is a traditional way to try and understand how we might try to approximate such\nintegrals: we can imagine taking the region in-between \ud835\udc4eand\ud835\udc4fand chopping it into \ud835\udc41\nvertical slices. If \ud835\udc41is large, we can approximate the area of each slice by a rectangle, and\nthen add up the areas to get the total area under the curve. Let\u2019s take a look at an example\ndoing this in code. We will see how to get the true value in a later section.\nepsilon =0.05\na=0\nb=2\nx=torch .arange(a, b, epsilon)\nf=x/(1+x**2)\napprox =torch .sum(epsilon *f)\ntrue =torch .log(torch .tensor([ 5.])) /2\nd2l.set_figsize()\nd2l.plt.bar(x, f, width =epsilon, align ='edge ')\nd2l.plt.plot(x, f, color ='black ')\nd2l.plt.ylim([ 0,1])\nd2l.plt.show()\nf'approximation: {approx }, truth: {true }'\n'approximation: 0.7944855690002441, truth: tensor([0.8047]) '\nThe issue is that while it can be done numerically, we can do this approach analytically for\nonly the simplest functions like\n\u00b9\ud835\udc4f\n\ud835\udc4e\ud835\udc65 \ud835\udc51\ud835\udc65. (A.3)\nAnything somewhat more complex like our example from the code above\n\u00b9\ud835\udc4f\n\ud835\udc4e\ud835\udc65\n1\u00b8\ud835\udc652\ud835\udc51\ud835\udc65. (A.4)\nis beyond what we can solve with such a direct method.\nWe will instead take a different approach. We will work intuitively with the notion of the\narea,andlearnthemaincomputationaltoolusedtofindintegrals: the fundamentaltheorem\nofcalculus . This will be the basis for our study of integration.\n954 Mathematics for Deep Learning\nA.5.2The Fundamental Theoremof Calculus\nTo dive deeper into the theory of integration, let\u2019s introduce a function\n\ud835\udc39\u00b9\ud835\udc65\u00ba=\u00b9\ud835\udc65\n0\ud835\udc53\u00b9\ud835\udc66\u00ba\ud835\udc51\ud835\udc66. (A.5)\nThis function measures the area between 0and\ud835\udc65depending on how we change \ud835\udc65. Notice\nthat this is everything we need since\n\u00b9\ud835\udc4f\n\ud835\udc4e\ud835\udc53\u00b9\ud835\udc65\u00ba\ud835\udc51\ud835\udc65=\ud835\udc39\u00b9\ud835\udc4f\u00ba\u0000\ud835\udc39\u00b9\ud835\udc4e\u00ba. (A.6)\nThis is a mathematical encoding of the fact that we can measure the area out to the far end-\npoint and then subtract off the area to the near end point as indicated in Fig. A.1.\ntFig. A.1 Visualizing why we may reduce the problem of computing the area under a curve between\ntwo points to computing the area to the left of a point.\nThus, we can figure out what the integral over any interval is by figuring out what \ud835\udc39\u00b9\ud835\udc65\u00ba\nis.\nTo do so, let\u2019s consider an experiment. As we often do in calculus, let\u2019s imagine what hap-\npens when we shift the value by a tiny bit. From the comment above, we know that\n\ud835\udc39\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\u0000\ud835\udc39\u00b9\ud835\udc65\u00ba=\u00b9\ud835\udc65\u00b8\ud835\udf16\n\ud835\udc65\ud835\udc53\u00b9\ud835\udc66\u00ba\ud835\udc51\ud835\udc66. (A.7)\nThis tells us that the function changes by the area under a tiny sliver of a function.\nThisis the point at whichwemakean approximation. If welookat a tinysliverofarea like\nthis, it looks like this area is close to the rectangular area with height the value of \ud835\udc53\u00b9\ud835\udc65\u00baand\nthe base width \ud835\udf16. Indeed, one can show that as \ud835\udf16!0this approximation becomes better\nand better. Thus we can conclude:\n\ud835\udc39\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\u0000\ud835\udc39\u00b9\ud835\udc65\u00ba\u0019\ud835\udf16\ud835\udc53\u00b9\ud835\udc65\u00ba.", "mimetype": "text/plain", "start_char_idx": 1969599, "end_char_idx": 1972495, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c4272f47-f0cc-48fa-b821-a7dfc044a0a9": {"__data__": {"id_": "c4272f47-f0cc-48fa-b821-a7dfc044a0a9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4ce97d59-9318-4c6d-aef8-5f84a22fb1a4", "node_type": "1", "metadata": {}, "hash": "4b33117926e9ce030d46b5e171721a9e1c65d1d5c093c6f1bd42dd6ada2e82f2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "99f4b3e1-a4f4-4143-bad9-d1d808fa7175", "node_type": "1", "metadata": {}, "hash": "13962a32247f225899a45cf3ddac7678de5e5a230bbfd48399662fd2abb49be8", "class_name": "RelatedNodeInfo"}}, "text": "(A.7)\nThis tells us that the function changes by the area under a tiny sliver of a function.\nThisis the point at whichwemakean approximation. If welookat a tinysliverofarea like\nthis, it looks like this area is close to the rectangular area with height the value of \ud835\udc53\u00b9\ud835\udc65\u00baand\nthe base width \ud835\udf16. Indeed, one can show that as \ud835\udf16!0this approximation becomes better\nand better. Thus we can conclude:\n\ud835\udc39\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\u0000\ud835\udc39\u00b9\ud835\udc65\u00ba\u0019\ud835\udf16\ud835\udc53\u00b9\ud835\udc65\u00ba. (A.8)\nHowever, we can now notice: this is exactly the pattern we expect if we were computing\nthe derivative of \ud835\udc39! Thus we see the following rather surprising fact:\n\ud835\udc51\ud835\udc39\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba=\ud835\udc53\u00b9\ud835\udc65\u00ba. (A.9)\nThis is the fundamentaltheoremof calculus . We may write it in expanded form as\n\ud835\udc51\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\n0\ud835\udc53\u00b9\ud835\udc66\u00ba\ud835\udc51\ud835\udc66=\ud835\udc53\u00b9\ud835\udc65\u00ba. (A.10)\nIt takes the concept of finding areas ( a priori rather hard), and reduces it to a statement\nderivatives (something much more completely understood). One last comment that we\n955 Integral Calculus\nmust make is that this does not tell us exactly what \ud835\udc39\u00b9\ud835\udc65\u00bais. Indeed\ud835\udc39\u00b9\ud835\udc65\u00ba\u00b8\ud835\udc36for any\ud835\udc36has\nthe same derivative. This is a fact-of-life in the theory of integration. Thankfully, notice\nthat when working with definite integrals, the constants drop out, and thus are irrelevant to\nthe outcome.\n\u00b9\ud835\udc4f\n\ud835\udc4e\ud835\udc53\u00b9\ud835\udc65\u00ba\ud835\udc51\ud835\udc65=\u00b9\ud835\udc39\u00b9\ud835\udc4f\u00ba\u00b8\ud835\udc36\u00ba\u0000\u00b9\ud835\udc39\u00b9\ud835\udc4e\u00ba\u00b8\ud835\udc36\u00ba=\ud835\udc39\u00b9\ud835\udc4f\u00ba\u0000\ud835\udc39\u00b9\ud835\udc4e\u00ba. (A.11)\nThismayseemlikeabstractnon-sense,butlet\u2019stakeamomenttoappreciatethatithasgiven\nus a whole new perspective on computing integrals. Our goal is no-longer to do some sort\nof chop-and-sum process to try and recover the area, rather we need only find a function\nwhose derivative is the function we have! This is incredible since we can now list many\nrather difficult integrals by just reversing the table from Section A.3.2 . For instance, we\nknow that the derivative of \ud835\udc65\ud835\udc5bis\ud835\udc5b\ud835\udc65\ud835\udc5b\u00001. Thus, we can say using the fundamental theorem\n(A.10 )that\n\u00b9\ud835\udc65\n0\ud835\udc5b\ud835\udc66\ud835\udc5b\u00001\ud835\udc51\ud835\udc66=\ud835\udc65\ud835\udc5b\u00000\ud835\udc5b=\ud835\udc65\ud835\udc5b. (A.12)\nSimilarly, we know that the derivative of \ud835\udc52\ud835\udc65is itself, so that means\n\u00b9\ud835\udc65\n0\ud835\udc52\ud835\udc65\ud835\udc51\ud835\udc65=\ud835\udc52\ud835\udc65\u0000\ud835\udc520=\ud835\udc52\ud835\udc65\u00001. (A.13)\nInthisway,wecandeveloptheentiretheoryofintegrationleveragingideasfromdifferential\ncalculus freely. Every integration rule derives from this one fact.\nA.5.3Changeof Variables\nJust as with differentiation, there are a number of rules which make the computation of\nintegrals more tractable. In fact, every rule of differential calculus (like the product rule,\nsumrule,andchainrule)hasacorrespondingruleforintegralcalculus(integrationbyparts,\nlinearity of integration, and the change of variables formula respectively). In this section,\nwe will dive into what is arguably the most important from the list: the change of variables\nformula.\nFirst, suppose that we have a function which is itself an integral:\n\ud835\udc39\u00b9\ud835\udc65\u00ba=\u00b9\ud835\udc65\n0\ud835\udc53\u00b9\ud835\udc66\u00ba\ud835\udc51\ud835\udc66. (A.14)\nLet\u2019s suppose that we want to know how this function looks when we compose it with\nanother to obtain \ud835\udc39\u00b9\ud835\udc62\u00b9\ud835\udc65\u00ba\u00ba.", "mimetype": "text/plain", "start_char_idx": 1972085, "end_char_idx": 1974816, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "99f4b3e1-a4f4-4143-bad9-d1d808fa7175": {"__data__": {"id_": "99f4b3e1-a4f4-4143-bad9-d1d808fa7175", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c4272f47-f0cc-48fa-b821-a7dfc044a0a9", "node_type": "1", "metadata": {}, "hash": "40e1db2b6c7242e87329ef111ad199d795e81aa381076f934b6c6c509a21b6ce", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4f32ca98-23a4-4377-8530-b48a9339975b", "node_type": "1", "metadata": {}, "hash": "30f9a91b73f402f7d7d88c5c33ad0a757c49118f91e165749463f21e5e102997", "class_name": "RelatedNodeInfo"}}, "text": "A.5.3Changeof Variables\nJust as with differentiation, there are a number of rules which make the computation of\nintegrals more tractable. In fact, every rule of differential calculus (like the product rule,\nsumrule,andchainrule)hasacorrespondingruleforintegralcalculus(integrationbyparts,\nlinearity of integration, and the change of variables formula respectively). In this section,\nwe will dive into what is arguably the most important from the list: the change of variables\nformula.\nFirst, suppose that we have a function which is itself an integral:\n\ud835\udc39\u00b9\ud835\udc65\u00ba=\u00b9\ud835\udc65\n0\ud835\udc53\u00b9\ud835\udc66\u00ba\ud835\udc51\ud835\udc66. (A.14)\nLet\u2019s suppose that we want to know how this function looks when we compose it with\nanother to obtain \ud835\udc39\u00b9\ud835\udc62\u00b9\ud835\udc65\u00ba\u00ba. By the chain rule, we know\n\ud835\udc51\n\ud835\udc51\ud835\udc65\ud835\udc39\u00b9\ud835\udc62\u00b9\ud835\udc65\u00ba\u00ba=\ud835\udc51\ud835\udc39\n\ud835\udc51\ud835\udc62\u00b9\ud835\udc62\u00b9\ud835\udc65\u00ba\u00ba\u0001\ud835\udc51\ud835\udc62\n\ud835\udc51\ud835\udc65. (A.15)\nWe can turn this into a statement about integration by using the fundamental theorem\n(A.10 )as above. This gives\n\ud835\udc39\u00b9\ud835\udc62\u00b9\ud835\udc65\u00ba\u00ba\u0000\ud835\udc39\u00b9\ud835\udc62\u00b90\u00ba\u00ba=\u00b9\ud835\udc65\n0\ud835\udc51\ud835\udc39\n\ud835\udc51\ud835\udc62\u00b9\ud835\udc62\u00b9\ud835\udc66\u00ba\u00ba\u0001\ud835\udc51\ud835\udc62\n\ud835\udc51\ud835\udc66\ud835\udc51\ud835\udc66. (A.16)\n956 Mathematics for Deep Learning\nRecalling that \ud835\udc39is itself an integral gives that the left hand side may be rewritten to\nbe\n\u00b9\ud835\udc62\u00b9\ud835\udc65\u00ba\n\ud835\udc62\u00b90\u00ba\ud835\udc53\u00b9\ud835\udc66\u00ba\ud835\udc51\ud835\udc66=\u00b9\ud835\udc65\n0\ud835\udc51\ud835\udc39\n\ud835\udc51\ud835\udc62\u00b9\ud835\udc62\u00b9\ud835\udc66\u00ba\u00ba\u0001\ud835\udc51\ud835\udc62\n\ud835\udc51\ud835\udc66\ud835\udc51\ud835\udc66. (A.17)\nSimilarly, recalling that \ud835\udc39is an integral allows us to recognize that\ud835\udc51\ud835\udc39\n\ud835\udc51\ud835\udc65=\ud835\udc53using the\nfundamental theorem (A.10 ), and thus we may conclude\n\u00b9\ud835\udc62\u00b9\ud835\udc65\u00ba\n\ud835\udc62\u00b90\u00ba\ud835\udc53\u00b9\ud835\udc66\u00ba\ud835\udc51\ud835\udc66=\u00b9\ud835\udc65\n0\ud835\udc53\u00b9\ud835\udc62\u00b9\ud835\udc66\u00ba\u00ba\u0001\ud835\udc51\ud835\udc62\n\ud835\udc51\ud835\udc66\ud835\udc51\ud835\udc66. (A.18)\nThis is the changeof variables formula.\nForamoreintuitivederivation,considerwhathappenswhenwetakeanintegralof \ud835\udc53\u00b9\ud835\udc62\u00b9\ud835\udc65\u00ba\u00ba\nbetween\ud835\udc65and\ud835\udc65\u00b8\ud835\udf16. For a small \ud835\udf16, this integral is approximately \ud835\udf16\ud835\udc53\u00b9\ud835\udc62\u00b9\ud835\udc65\u00ba\u00ba, the area of\nthe associated rectangle. Now, let\u2019s compare this with the integral of \ud835\udc53\u00b9\ud835\udc66\u00bafrom\ud835\udc62\u00b9\ud835\udc65\u00bato\n\ud835\udc62\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba. We know that \ud835\udc62\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\u0019\ud835\udc62\u00b9\ud835\udc65\u00ba\u00b8\ud835\udf16\ud835\udc51\ud835\udc62\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba, so the area of this rectangle is approx-\nimately\ud835\udf16\ud835\udc51\ud835\udc62\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba\ud835\udc53\u00b9\ud835\udc62\u00b9\ud835\udc65\u00ba\u00ba. Thus, to make the area of these two rectangles to agree, we need\nto multiply the first one by\ud835\udc51\ud835\udc62\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00baas is illustrated in Fig. A.2.\ntFig. A.2 Visualizing the transformation of a single thin rectangle under the change of variables.\nThis tells us that\n\u00b9\ud835\udc65\u00b8\ud835\udf16\n\ud835\udc65\ud835\udc53\u00b9\ud835\udc62\u00b9\ud835\udc66\u00ba\u00ba\ud835\udc51\ud835\udc62\n\ud835\udc51\ud835\udc66\u00b9\ud835\udc66\u00ba\ud835\udc51\ud835\udc66=\u00b9\ud835\udc62\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\n\ud835\udc62\u00b9\ud835\udc65\u00ba\ud835\udc53\u00b9\ud835\udc66\u00ba\ud835\udc51\ud835\udc66.", "mimetype": "text/plain", "start_char_idx": 1974130, "end_char_idx": 1976093, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4f32ca98-23a4-4377-8530-b48a9339975b": {"__data__": {"id_": "4f32ca98-23a4-4377-8530-b48a9339975b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "99f4b3e1-a4f4-4143-bad9-d1d808fa7175", "node_type": "1", "metadata": {}, "hash": "13962a32247f225899a45cf3ddac7678de5e5a230bbfd48399662fd2abb49be8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "704c5ee7-4817-491e-ac00-1af9edb0e4aa", "node_type": "1", "metadata": {}, "hash": "362e3459b84b6fa688f65f3ed3fbc536c2a9f1a1573d5c1939031767c17393ad", "class_name": "RelatedNodeInfo"}}, "text": "Thus, to make the area of these two rectangles to agree, we need\nto multiply the first one by\ud835\udc51\ud835\udc62\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00baas is illustrated in Fig. A.2.\ntFig. A.2 Visualizing the transformation of a single thin rectangle under the change of variables.\nThis tells us that\n\u00b9\ud835\udc65\u00b8\ud835\udf16\n\ud835\udc65\ud835\udc53\u00b9\ud835\udc62\u00b9\ud835\udc66\u00ba\u00ba\ud835\udc51\ud835\udc62\n\ud835\udc51\ud835\udc66\u00b9\ud835\udc66\u00ba\ud835\udc51\ud835\udc66=\u00b9\ud835\udc62\u00b9\ud835\udc65\u00b8\ud835\udf16\u00ba\n\ud835\udc62\u00b9\ud835\udc65\u00ba\ud835\udc53\u00b9\ud835\udc66\u00ba\ud835\udc51\ud835\udc66. (A.19)\nThis is the change of variables formula expressed for a single small rectangle.\nIf\ud835\udc62\u00b9\ud835\udc65\u00baand\ud835\udc53\u00b9\ud835\udc65\u00baare properly chosen, this can allow for the computation of incredibly\ncomplex integrals. For instance, if we even chose \ud835\udc53\u00b9\ud835\udc66\u00ba=1and\ud835\udc62\u00b9\ud835\udc65\u00ba=\ud835\udc52\u0000\ud835\udc652(which means\n\ud835\udc51\ud835\udc62\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00ba=\u00002\ud835\udc65\ud835\udc52\u0000\ud835\udc652), this can show for instance that\n\ud835\udc52\u00001\u00001=\u00b9\ud835\udc52\u00001\n\ud835\udc52\u000001\ud835\udc51\ud835\udc66=\u00002\u00b91\n0\ud835\udc66\ud835\udc52\u0000\ud835\udc662\ud835\udc51\ud835\udc66, (A.20)\nand thus by rearranging that\n\u00b91\n0\ud835\udc66\ud835\udc52\u0000\ud835\udc662\ud835\udc51\ud835\udc66=1\u0000\ud835\udc52\u00001\n2. (A.21)\nA.5.4A Comment on Sign Conventions\n957 Integral Calculus\nKeen-eyed readers will observe something strange about the computations above. Namely,\ncomputations like\n\u00b9\ud835\udc52\u00001\n\ud835\udc52\u000001\ud835\udc51\ud835\udc66=\ud835\udc52\u00001\u00001<0, (A.22)\ncan produce negative numbers. When thinking about areas, it can be strange to see a neg-\native value, and so it is worth digging into what the convention is.\nMathematicians take the notion of signed areas. This manifests itself in two ways. First, if\nwe consider a function \ud835\udc53\u00b9\ud835\udc65\u00bawhich is sometimes less than zero, then the area will also be\nnegative. So for instance\n\u00b91\n0\u00b9\u00001\u00ba\ud835\udc51\ud835\udc65=\u00001. (A.23)\nSimilarly, integrals which progress from right to left, rather than left to right are also taken\nto be negative areas\n\u00b9\u00001\n01\ud835\udc51\ud835\udc65=\u00001. (A.24)\nThe standard area (from left to right of a positive function) is always positive. Anything\nobtained by flipping it (say flipping over the \ud835\udc65-axis to get the integral of a negative number,\nor flipping over the \ud835\udc66-axis to get an integral in the wrong order) will produce a negative\narea. And indeed, flipping twice will give a pair of negative signs that cancel out to have\npositive area\n\u00b9\u00001\n0\u00b9\u00001\u00ba\ud835\udc51\ud835\udc65=1. (A.25)\nIf this discussion sounds familiar, it is! In Section A.1 we discussed how the determinant\nrepresented the signed area in much the same way.\nA.5.5MultipleIntegrals\nIn some cases, we will need to work in higher dimensions. For instance, suppose that we\nhave a function of two variables, like \ud835\udc53\u00b9\ud835\udc65,\ud835\udc66\u00baand we want to know the volume under \ud835\udc53\nwhen\ud835\udc65ranges over\u00bb\ud835\udc4e,\ud835\udc4f\u00bcand\ud835\udc66ranges over\u00bb\ud835\udc50,\ud835\udc51\u00bc.", "mimetype": "text/plain", "start_char_idx": 1975800, "end_char_idx": 1977993, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "704c5ee7-4817-491e-ac00-1af9edb0e4aa": {"__data__": {"id_": "704c5ee7-4817-491e-ac00-1af9edb0e4aa", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4f32ca98-23a4-4377-8530-b48a9339975b", "node_type": "1", "metadata": {}, "hash": "30f9a91b73f402f7d7d88c5c33ad0a757c49118f91e165749463f21e5e102997", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fb215f6d-b4b7-47c6-80f7-fa7606a75733", "node_type": "1", "metadata": {}, "hash": "d45eed5d41907fb7e91cc5e2d6853dbe2d746c5a15fbd3d363875894008c3439", "class_name": "RelatedNodeInfo"}}, "text": "And indeed, flipping twice will give a pair of negative signs that cancel out to have\npositive area\n\u00b9\u00001\n0\u00b9\u00001\u00ba\ud835\udc51\ud835\udc65=1. (A.25)\nIf this discussion sounds familiar, it is! In Section A.1 we discussed how the determinant\nrepresented the signed area in much the same way.\nA.5.5MultipleIntegrals\nIn some cases, we will need to work in higher dimensions. For instance, suppose that we\nhave a function of two variables, like \ud835\udc53\u00b9\ud835\udc65,\ud835\udc66\u00baand we want to know the volume under \ud835\udc53\nwhen\ud835\udc65ranges over\u00bb\ud835\udc4e,\ud835\udc4f\u00bcand\ud835\udc66ranges over\u00bb\ud835\udc50,\ud835\udc51\u00bc.\n# Construct grid and compute function\nx, y =torch .meshgrid(torch .linspace( -2,2,101), torch .linspace( -2,2,101))\nz=torch .exp( -x**2-y**2)\n# Plot function\nax=d2l.plt.figure() .add_subplot( 111, projection ='3d')\nax.plot_wireframe(x, y, z)\nd2l.plt.xlabel( 'x')\nd2l.plt.ylabel( 'y')\nd2l.plt.xticks([ -2,-1,0,1,2])\nd2l.plt.yticks([ -2,-1,0,1,2])\nd2l.set_figsize()\n(continues on next page)\n958 Mathematics for Deep Learning\n(continued from previous page)\nax.set_xlim( -2,2)\nax.set_ylim( -2,2)\nax.set_zlim( 0,1)\nax.dist =12\nWe write this as\u00b9\n\u00bb\ud835\udc4e,\ud835\udc4f\u00bc\u0002\u00bb\ud835\udc50,\ud835\udc51\u00bc\ud835\udc53\u00b9\ud835\udc65,\ud835\udc66\u00ba\ud835\udc51\ud835\udc65 \ud835\udc51\ud835\udc66. (A.26)\nSupposethatwewishtocomputethisintegral. Myclaimisthatwecandothisbyiteratively\ncomputing first the integral in \ud835\udc65and then shifting to the integral in \ud835\udc66, that is to say\n\u00b9\n\u00bb\ud835\udc4e,\ud835\udc4f\u00bc\u0002\u00bb\ud835\udc50,\ud835\udc51\u00bc\ud835\udc53\u00b9\ud835\udc65,\ud835\udc66\u00ba\ud835\udc51\ud835\udc65 \ud835\udc51\ud835\udc66 =\u00b9\ud835\udc51\n\ud835\udc50\u0012\u00b9\ud835\udc4f\n\ud835\udc4e\ud835\udc53\u00b9\ud835\udc65,\ud835\udc66\u00ba\ud835\udc51\ud835\udc65\u0013\n\ud835\udc51\ud835\udc66. (A.27)\nLet\u2019s see why this is.\nConsiderthefigureabovewherewehavesplitthefunctioninto \ud835\udf16\u0002\ud835\udf16squareswhichwewill\nindex with integer coordinates \ud835\udc56,\ud835\udc57. In this case, our integral is approximately\n\u00d5\n\ud835\udc56,\ud835\udc57\ud835\udf162\ud835\udc53\u00b9\ud835\udf16\ud835\udc56,\ud835\udf16\ud835\udc57\u00ba.(A.28)\nOnce we discretize the problem, we may add up the values on these squares in whatever\norder we like, and not worry about changing the values. This is illustrated in Fig. A.3. In\nparticular, we can say that\n\u00d5\n\ud835\udc57\ud835\udf16 \u00d5\n\ud835\udc56\ud835\udf16\ud835\udc53\u00b9\ud835\udf16\ud835\udc56,\ud835\udf16\ud835\udc57\u00ba!\n. (A.29)\ntFig. A.3 Illustrating how to decompose a sum over many squares as a sum over \ufb01rst the columns\n(1), then adding the column sums together (2).\n959 Integral Calculus\nThe sum on the inside is precisely the discretization of the integral\n\ud835\udc3a\u00b9\ud835\udf16\ud835\udc57\u00ba=\u00b9\ud835\udc4f\n\ud835\udc4e\ud835\udc53\u00b9\ud835\udc65,\ud835\udf16\ud835\udc57\u00ba\ud835\udc51\ud835\udc65. (A.30)\nFinally, notice that if we combine these two expressions we get\n\u00d5\n\ud835\udc57\ud835\udf16\ud835\udc3a\u00b9\ud835\udf16\ud835\udc57\u00ba\u0019\u00b9\ud835\udc51\n\ud835\udc50\ud835\udc3a\u00b9\ud835\udc66\u00ba\ud835\udc51\ud835\udc66=\u00b9\n\u00bb\ud835\udc4e,\ud835\udc4f\u00bc\u0002\u00bb\ud835\udc50,\ud835\udc51\u00bc\ud835\udc53\u00b9\ud835\udc65,\ud835\udc66\u00ba\ud835\udc51\ud835\udc65 \ud835\udc51\ud835\udc66.", "mimetype": "text/plain", "start_char_idx": 1977493, "end_char_idx": 1979595, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fb215f6d-b4b7-47c6-80f7-fa7606a75733": {"__data__": {"id_": "fb215f6d-b4b7-47c6-80f7-fa7606a75733", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "704c5ee7-4817-491e-ac00-1af9edb0e4aa", "node_type": "1", "metadata": {}, "hash": "362e3459b84b6fa688f65f3ed3fbc536c2a9f1a1573d5c1939031767c17393ad", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9eeba003-de7d-4c29-b4f2-25528ad56275", "node_type": "1", "metadata": {}, "hash": "a15d525bdbde8fb7616dfec13b46ddfb9f56fd6a73bf7c7e67314ea9138ee83f", "class_name": "RelatedNodeInfo"}}, "text": "959 Integral Calculus\nThe sum on the inside is precisely the discretization of the integral\n\ud835\udc3a\u00b9\ud835\udf16\ud835\udc57\u00ba=\u00b9\ud835\udc4f\n\ud835\udc4e\ud835\udc53\u00b9\ud835\udc65,\ud835\udf16\ud835\udc57\u00ba\ud835\udc51\ud835\udc65. (A.30)\nFinally, notice that if we combine these two expressions we get\n\u00d5\n\ud835\udc57\ud835\udf16\ud835\udc3a\u00b9\ud835\udf16\ud835\udc57\u00ba\u0019\u00b9\ud835\udc51\n\ud835\udc50\ud835\udc3a\u00b9\ud835\udc66\u00ba\ud835\udc51\ud835\udc66=\u00b9\n\u00bb\ud835\udc4e,\ud835\udc4f\u00bc\u0002\u00bb\ud835\udc50,\ud835\udc51\u00bc\ud835\udc53\u00b9\ud835\udc65,\ud835\udc66\u00ba\ud835\udc51\ud835\udc65 \ud835\udc51\ud835\udc66. (A.31)\nThus putting it all together, we have that\n\u00b9\n\u00bb\ud835\udc4e,\ud835\udc4f\u00bc\u0002\u00bb\ud835\udc50,\ud835\udc51\u00bc\ud835\udc53\u00b9\ud835\udc65,\ud835\udc66\u00ba\ud835\udc51\ud835\udc65 \ud835\udc51\ud835\udc66 =\u00b9\ud835\udc51\n\ud835\udc50\u0012\u00b9\ud835\udc4f\n\ud835\udc4e\ud835\udc53\u00b9\ud835\udc65,\ud835\udc66\u00ba\ud835\udc51\ud835\udc65\u0013\n\ud835\udc51\ud835\udc66. (A.32)\nNotice that, once discretized, all we did was rearrange the order in which we added a list\nof numbers. This may make it seem like it is nothing, however this result (called Fubini\u2019s\nTheorem ) is not always true! For the type of mathematics encountered when doing ma-\nchine learning (continuous functions), there is no concern, however it is possible to create\nexampleswhereitfails(forexamplethefunction \ud835\udc53\u00b9\ud835\udc65,\ud835\udc66\u00ba=\ud835\udc65\ud835\udc66\u00b9\ud835\udc652\u0000\ud835\udc662\u00ba\u009d\u00b9\ud835\udc652\u00b8\ud835\udc662\u00ba3overthe\nrectangle\u00bb0,2\u00bc\u0002\u00bb 0,1\u00bc).\nNotethatthechoicetodotheintegralin \ud835\udc65first, andthentheintegralin \ud835\udc66wasarbitrary. We\ncould have equally well chosen to do \ud835\udc66first and then \ud835\udc65to see\n\u00b9\n\u00bb\ud835\udc4e,\ud835\udc4f\u00bc\u0002\u00bb\ud835\udc50,\ud835\udc51\u00bc\ud835\udc53\u00b9\ud835\udc65,\ud835\udc66\u00ba\ud835\udc51\ud835\udc65 \ud835\udc51\ud835\udc66 =\u00b9\ud835\udc4f\n\ud835\udc4e\u0012\u00b9\ud835\udc51\n\ud835\udc50\ud835\udc53\u00b9\ud835\udc65,\ud835\udc66\u00ba\ud835\udc51\ud835\udc66\u0013\n\ud835\udc51\ud835\udc65. (A.33)\nOften times, we will condense down to vector notation, and say that for \ud835\udc48=\u00bb\ud835\udc4e,\ud835\udc4f\u00bc\u0002\u00bb\ud835\udc50,\ud835\udc51\u00bc\nthis is\u00b9\n\ud835\udc48\ud835\udc53\u00b9x\u00ba\ud835\udc51x. (A.34)\nA.5.6Changeof Variablesin Multiple Integrals\nAs with single variables in (A.18 ), the ability to change variables inside a higher dimen-\nsional integral is a key tool. Let\u2019s summarize the result without derivation.\nWe need a function that reparametrizes our domain of integration. We can take this to be\n\ud835\udf19:R\ud835\udc5b!R\ud835\udc5b, that is any function which takes in \ud835\udc5breal variables and returns another \ud835\udc5b. To\nkeep the expressions clean, we will assume that \ud835\udf19isinjective which is to say it never folds\nover itself (\ud835\udf19\u00b9x\u00ba=\ud835\udf19\u00b9y\u00ba=)x=y).\nIn this case, we can say that\n\u00b9\n\ud835\udf19\u00b9\ud835\udc48\u00ba\ud835\udc53\u00b9x\u00ba\ud835\udc51x=\u00b9\n\ud835\udc48\ud835\udc53\u00b9\ud835\udf19\u00b9x\u00ba\u00bajdet\u00b9\ud835\udc37\ud835\udf19\u00b9x\u00ba\u00baj\ud835\udc51x. (A.35)\nwhere\ud835\udc37\ud835\udf19istheJacobian of\ud835\udf19,whichisthematrixofpartialderivativesof \ud835\udf53=\u00b9\ud835\udf191\u00b9\ud835\udc651,...,\ud835\udc65\ud835\udc5b\u00ba,...,\ud835\udf19\ud835\udc5b\u00b9\ud835\udc651,...,\ud835\udc65\ud835\udc5b\u00ba\u00ba,\n\ud835\udc37\ud835\udf53=26666664\ud835\udf15\ud835\udf19 1\n\ud835\udf15\ud835\udc651\u0001\u0001\u0001\ud835\udf15\ud835\udf19 1\n\ud835\udf15\ud835\udc65\ud835\udc5b.........\n\ud835\udf15\ud835\udf19\ud835\udc5b\n\ud835\udf15\ud835\udc651\u0001\u0001\u0001\ud835\udf15\ud835\udf19\ud835\udc5b\n\ud835\udf15\ud835\udc65\ud835\udc5b37777775.", "mimetype": "text/plain", "start_char_idx": 1979365, "end_char_idx": 1981228, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9eeba003-de7d-4c29-b4f2-25528ad56275": {"__data__": {"id_": "9eeba003-de7d-4c29-b4f2-25528ad56275", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fb215f6d-b4b7-47c6-80f7-fa7606a75733", "node_type": "1", "metadata": {}, "hash": "d45eed5d41907fb7e91cc5e2d6853dbe2d746c5a15fbd3d363875894008c3439", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "23a834ad-1264-4b70-a59a-6eb9fd92b097", "node_type": "1", "metadata": {}, "hash": "26574a72cfa043058db4c9076b3460a9cab64fa7c8c74e0378f79d430677f5e4", "class_name": "RelatedNodeInfo"}}, "text": "(A.35)\nwhere\ud835\udc37\ud835\udf19istheJacobian of\ud835\udf19,whichisthematrixofpartialderivativesof \ud835\udf53=\u00b9\ud835\udf191\u00b9\ud835\udc651,...,\ud835\udc65\ud835\udc5b\u00ba,...,\ud835\udf19\ud835\udc5b\u00b9\ud835\udc651,...,\ud835\udc65\ud835\udc5b\u00ba\u00ba,\n\ud835\udc37\ud835\udf53=26666664\ud835\udf15\ud835\udf19 1\n\ud835\udf15\ud835\udc651\u0001\u0001\u0001\ud835\udf15\ud835\udf19 1\n\ud835\udf15\ud835\udc65\ud835\udc5b.........\n\ud835\udf15\ud835\udf19\ud835\udc5b\n\ud835\udf15\ud835\udc651\u0001\u0001\u0001\ud835\udf15\ud835\udf19\ud835\udc5b\n\ud835\udf15\ud835\udc65\ud835\udc5b37777775. (A.36)\n960 Mathematics for Deep Learning\nLooking closely, we see that this is similar to the single variable chain rule (A.18 ), except\nwe have replaced the term\ud835\udc51\ud835\udc62\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00bawithjdet\u00b9\ud835\udc37\ud835\udf19\u00b9x\u00ba\u00baj. Let\u2019s see how we can to interpret\nthis term. Recall that the\ud835\udc51\ud835\udc62\n\ud835\udc51\ud835\udc65\u00b9\ud835\udc65\u00baterm existed to say how much we stretched our \ud835\udc65-axis by\napplying\ud835\udc62. The same process in higher dimensions is to determine how much we stretch\nthearea(orvolume,orhyper-volume)ofalittlesquare(orlittle hyper-cube )byapplying \ud835\udf53.\nIf\ud835\udf53was the multiplication by a matrix, then we know how the determinant already gives\nthe answer.\nWith some work, one can show that the Jacobian provides the best approximation to a\nmultivariable function \ud835\udf53at a point by a matrix in the same way we could approximate by\nlinesorplaneswithderivativesandgradients. ThusthedeterminantoftheJacobianexactly\nmirrors the scaling factor we identified in one dimension.\nIt takes some work to fill in the details to this, so do not worry if they are not clear now.\nLet\u2019s see at least one example we will make use of later on. Consider the integral\n\u00b91\n\u00001\u00b91\n\u00001\ud835\udc52\u0000\ud835\udc652\u0000\ud835\udc662\ud835\udc51\ud835\udc65 \ud835\udc51\ud835\udc66. (A.37)\nPlaying with this integral directly will get us no-where, but if we change variables, we can\nmake significant progress. If we let \ud835\udf53\u00b9\ud835\udc5f,\ud835\udf03\u00ba=\u00b9\ud835\udc5fcos\u00b9\ud835\udf03\u00ba,\ud835\udc5fsin\u00b9\ud835\udf03\u00ba\u00ba(which is to say that\n\ud835\udc65=\ud835\udc5fcos\u00b9\ud835\udf03\u00ba,\ud835\udc66=\ud835\udc5fsin\u00b9\ud835\udf03\u00ba), then we can apply the change of variable formula to see that\nthis is the same thing as\n\u00b91\n0\u00b92\ud835\udf0b\n0\ud835\udc52\u0000\ud835\udc5f2jdet\u00b9\ud835\udc37\u0152\u00b9x\u00ba\u00baj\ud835\udc51\ud835\udf03 \ud835\udc51\ud835\udc5f, (A.38)\nwhere\njdet\u00b9\ud835\udc37\u0152\u00b9x\u00ba\u00baj=\f\f\f\fdet\u0014cos\u00b9\ud835\udf03\u00ba \u0000\ud835\udc5fsin\u00b9\ud835\udf03\u00ba\nsin\u00b9\ud835\udf03\u00ba\ud835\udc5fcos\u00b9\ud835\udf03\u00ba\u0015\f\f\f\f=\ud835\udc5f\u00b9cos2\u00b9\ud835\udf03\u00ba\u00b8sin2\u00b9\ud835\udf03\u00ba\u00ba=\ud835\udc5f. (A.39)\nThus, the integral is\n\u00b91\n0\u00b92\ud835\udf0b\n0\ud835\udc5f\ud835\udc52\u0000\ud835\udc5f2\ud835\udc51\ud835\udf03 \ud835\udc51\ud835\udc5f =2\ud835\udf0b\u00b91\n0\ud835\udc5f\ud835\udc52\u0000\ud835\udc5f2\ud835\udc51\ud835\udc5f=\ud835\udf0b, (A.40)\nwhere the final equality follows by the same computation that we used in section Section\nA.5.3.\nWe will meet this integral again when we study continuous random variables in Section\nA.6.\nA.5.7Summary\n\u000fThe theory of integration allows us to answer questions about areas or volumes.\n\u000fThe fundamental theorem of calculus allows us to leverage knowledge about derivatives\nto compute areas via the observation that the derivative of the area up to some point\nis given by the value of the function being integrated.\n\u000fIntegrals in higher dimensions can be computed by iterating single variable integrals.\n961 Random Variables\n284A.5.8Exercises\n1.What is\u00af2\n11\n\ud835\udc65\ud835\udc51\ud835\udc65?", "mimetype": "text/plain", "start_char_idx": 1981054, "end_char_idx": 1983463, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "23a834ad-1264-4b70-a59a-6eb9fd92b097": {"__data__": {"id_": "23a834ad-1264-4b70-a59a-6eb9fd92b097", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9eeba003-de7d-4c29-b4f2-25528ad56275", "node_type": "1", "metadata": {}, "hash": "a15d525bdbde8fb7616dfec13b46ddfb9f56fd6a73bf7c7e67314ea9138ee83f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "39935019-4023-4996-8ba6-1c8a8deec6d3", "node_type": "1", "metadata": {}, "hash": "82a3266d34e7826000b691196c627fce5134c4ca8408fa55eb8bc3f89c5522a8", "class_name": "RelatedNodeInfo"}}, "text": "We will meet this integral again when we study continuous random variables in Section\nA.6.\nA.5.7Summary\n\u000fThe theory of integration allows us to answer questions about areas or volumes.\n\u000fThe fundamental theorem of calculus allows us to leverage knowledge about derivatives\nto compute areas via the observation that the derivative of the area up to some point\nis given by the value of the function being integrated.\n\u000fIntegrals in higher dimensions can be computed by iterating single variable integrals.\n961 Random Variables\n284A.5.8Exercises\n1.What is\u00af2\n11\n\ud835\udc65\ud835\udc51\ud835\udc65?\n2.Use the change of variables formula to integrate\u00afp\ud835\udf0b\n0\ud835\udc65sin\u00b9\ud835\udc652\u00ba\ud835\udc51\ud835\udc65.\n3.What is\u00af\n\u00bb0,1\u00bc2\ud835\udc65\ud835\udc66 \ud835\udc51\ud835\udc65 \ud835\udc51\ud835\udc66 ?\n4.Use the change of variables formula to compute\u00af2\n0\u00af1\n0\ud835\udc65\ud835\udc66\u00b9\ud835\udc652\u0000\ud835\udc662\u00ba\u009d\u00b9\ud835\udc652\u00b8\ud835\udc662\u00ba3\ud835\udc51\ud835\udc66 \ud835\udc51\ud835\udc65\nand\u00af1\n0\u00af2\n0\ud835\udc53\u00b9\ud835\udc65,\ud835\udc66\u00ba=\ud835\udc65\ud835\udc66\u00b9\ud835\udc652\u0000\ud835\udc662\u00ba\u009d\u00b9\ud835\udc652\u00b8\ud835\udc662\u00ba3\ud835\udc51\ud835\udc65 \ud835\udc51\ud835\udc66to see they are different.\nDiscussions284.\nA.6Random Variables\nInSection 2.6 we saw the basics of how to work with discrete random variables, which in\nour case refer to those random variables which take either a finite set of possible values, or\nthe integers. In this section, we develop the theory of continuousrandomvariables , which\nare random variables which can take on any real value.\nA.6.1Continuous Random Variables\nContinuous random variables are a significantly more subtle topic than discrete random\nvariables. A fair analogy to make is that the technical jump is comparable to the jump\nbetween adding lists of numbers and integrating functions. As such, we will need to take\nsome time to develop the theory.\nFromDiscreteto Continuous\nTo understand the additional technical challenges encountered when working with contin-\nuous random variables, let\u2019s perform a thought experiment. Suppose that we are throwing\na dart at the dart board, and we want to know the probability that it hits exactly 2cm from\nthe center of the board.\nTo start with, we imagine measuring a single digit of accuracy, that is to say with bins for\n0cm,1cm,2cm, and so on. We throw say 100darts at the dart board, and if 20of them fall\ninto the bin for 2cm we conclude that 20%of the darts we throw hit the board 2cm away\nfrom the center.\nHowever,whenwelookcloser,thisdoesnotmatchourquestion! Wewantedexactequality,\nwhereas these bins hold all that fell between say 1.5cm and 2.5cm.\nUndeterred, we continue further. We measure even more precisely, say 1.9cm, 2.0cm,\n2.1cm, and now see that perhaps 3of the 100darts hit the board in the 2.0cm bucket. Thus\nwe conclude the probability is 3%.\n962 Mathematics for Deep Learning\nHowever,thisdoesnotsolveanything! Wehavejustpushedtheissuedownonedigitfurther.\nLet\u2019s abstract a bit. Imagine we know the probability that the first \ud835\udc58digits match with\n2.00000...and we want to know the probability it matches for the first \ud835\udc58\u00b81digits. It is\nfairly reasonable to assume that the \ud835\udc58\u00b81thdigit is essentially a random choice from the\nsetf0,1,2,..., 9g. At least, we cannot conceive of a physically meaningful process which\nwould force the number of micrometers away form the center to prefer to end in a 7vs a\n3.\nWhat this means is that in essence each additional digit of accuracy we require should\ndecrease probability of matching by a factor of 10. Or put another way, we would expect\nthat\n\ud835\udc43\u00b9distance is 2.00...,to\ud835\udc58digits\u00ba\u0019\ud835\udc5d\u000110\u0000\ud835\udc58. (A.1)\nThevalue\ud835\udc5dessentiallyencodeswhathappenswiththefirstfewdigits,andthe 10\u0000\ud835\udc58handles\nthe rest.", "mimetype": "text/plain", "start_char_idx": 1982903, "end_char_idx": 1986224, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "39935019-4023-4996-8ba6-1c8a8deec6d3": {"__data__": {"id_": "39935019-4023-4996-8ba6-1c8a8deec6d3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "23a834ad-1264-4b70-a59a-6eb9fd92b097", "node_type": "1", "metadata": {}, "hash": "26574a72cfa043058db4c9076b3460a9cab64fa7c8c74e0378f79d430677f5e4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "33254742-f72c-4234-81e2-91cc47b223d7", "node_type": "1", "metadata": {}, "hash": "0f2532be4a722d7828961f1024cee68a63e2016d4e7bf87a84f597ed349fab3e", "class_name": "RelatedNodeInfo"}}, "text": "It is\nfairly reasonable to assume that the \ud835\udc58\u00b81thdigit is essentially a random choice from the\nsetf0,1,2,..., 9g. At least, we cannot conceive of a physically meaningful process which\nwould force the number of micrometers away form the center to prefer to end in a 7vs a\n3.\nWhat this means is that in essence each additional digit of accuracy we require should\ndecrease probability of matching by a factor of 10. Or put another way, we would expect\nthat\n\ud835\udc43\u00b9distance is 2.00...,to\ud835\udc58digits\u00ba\u0019\ud835\udc5d\u000110\u0000\ud835\udc58. (A.1)\nThevalue\ud835\udc5dessentiallyencodeswhathappenswiththefirstfewdigits,andthe 10\u0000\ud835\udc58handles\nthe rest.\nNotice that if we know the position accurate to \ud835\udc58=4digits after the decimal, that means\nwe know the value falls within the interval say \u00bb1.99995,2.00005\u00bcwhich is an interval of\nlength 2.00005\u00001.99995 =10\u00004. Thus, if we call the length of this interval \ud835\udf16, we can\nsay\n\ud835\udc43\u00b9distance is in an \ud835\udf16-sized interval around 2\u00ba\u0019\ud835\udf16\u0001\ud835\udc5d. (A.2)\nLet\u2019s take this one final step further. We have been thinking about the point 2the entire\ntime, but never thinking about other points. Nothing is different there fundamentally, but\nit is the case that the value \ud835\udc5dwill likely be different. We would at least hope that a dart\nthrower was more likely to hit a point near the center, like 2cm rather than 20cm. Thus, the\nvalue\ud835\udc5dis not fixed, but rather should depend on the point \ud835\udc65. This tells us that we should\nexpect\n\ud835\udc43\u00b9distance is in an \ud835\udf16-sized interval around \ud835\udc65\u00ba\u0019\ud835\udf16\u0001\ud835\udc5d\u00b9\ud835\udc65\u00ba. (A.3)\nIndeed, (A.3)preciselydefinesthe probabilitydensityfunction . Itisafunction \ud835\udc5d\u00b9\ud835\udc65\u00bawhich\nencodes the relative probability of hitting near one point vs. another. Let\u2019s visualize what\nsuch a function might look like.\n%matplotlib inline\nimport torch\nfrom IPython import display\nfrom d2l import torch asd2l\ntorch .pi=torch .acos(torch .zeros( 1)).item() *2# Define pi in torch\n# Plot the probability density function for some random variable\nx=torch .arange( -5,5,0.01 )\np=0.2*torch .exp( -(x-3)**2/2)/torch .sqrt( 2*torch .tensor(torch .pi)) +\\\n0.8*torch .exp( -(x+1)**2/2)/torch .sqrt( 2*torch .tensor(torch .pi))\nd2l.plot(x, p, 'x','Density ')\n963 Random Variables\nThe locations where the function value is large indicates regions where we are more likely\nto find the random value. The low portions are areas where we are unlikely to find the\nrandom value.\nProbabilityDensity Functions\nLet\u2019snowinvestigatethisfurther. Wehavealreadyseenwhataprobabilitydensityfunction\nis intuitively for a random variable \ud835\udc4b, namely the density function is a function \ud835\udc5d\u00b9\ud835\udc65\u00baso\nthat\n\ud835\udc43\u00b9\ud835\udc4bis in an\ud835\udf16-sized interval around \ud835\udc65\u00ba\u0019\ud835\udf16\u0001\ud835\udc5d\u00b9\ud835\udc65\u00ba. (A.4)\nBut what does this imply for the properties of \ud835\udc5d\u00b9\ud835\udc65\u00ba?\nFirst, probabilities are never negative, thus we should expect that \ud835\udc5d\u00b9\ud835\udc65\u00ba\u00150as well.\nSecond, let\u2019s imagine that we slice up the Rinto an infinite number of slices which are \ud835\udf16\nwide,saywithslices \u00b9\ud835\udf16\u0001\ud835\udc56,\ud835\udf16\u0001\u00b9\ud835\udc56\u00b81\u00ba\u00bc. Foreachofthese,weknowfrom (A.4)theprobability\nis approximately\n\ud835\udc43\u00b9\ud835\udc4bis in an\ud835\udf16-sized interval around \ud835\udc65\u00ba\u0019\ud835\udf16\u0001\ud835\udc5d\u00b9\ud835\udf16\u0001\ud835\udc56\u00ba, (A.5)\nso summed over all of them it should be\n\ud835\udc43\u00b9\ud835\udc4b2R\u00ba\u0019\u00d5\n\ud835\udc56\ud835\udf16\u0001\ud835\udc5d\u00b9\ud835\udf16\u0001\ud835\udc56\u00ba.", "mimetype": "text/plain", "start_char_idx": 1985636, "end_char_idx": 1988618, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "33254742-f72c-4234-81e2-91cc47b223d7": {"__data__": {"id_": "33254742-f72c-4234-81e2-91cc47b223d7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "39935019-4023-4996-8ba6-1c8a8deec6d3", "node_type": "1", "metadata": {}, "hash": "82a3266d34e7826000b691196c627fce5134c4ca8408fa55eb8bc3f89c5522a8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d57f150c-2208-4866-ae1b-14305e248f65", "node_type": "1", "metadata": {}, "hash": "1cf3aeabefae9410bea90b94d898cd572ac8eb761790b85fa36a6d0f2ab1efdf", "class_name": "RelatedNodeInfo"}}, "text": "First, probabilities are never negative, thus we should expect that \ud835\udc5d\u00b9\ud835\udc65\u00ba\u00150as well.\nSecond, let\u2019s imagine that we slice up the Rinto an infinite number of slices which are \ud835\udf16\nwide,saywithslices \u00b9\ud835\udf16\u0001\ud835\udc56,\ud835\udf16\u0001\u00b9\ud835\udc56\u00b81\u00ba\u00bc. Foreachofthese,weknowfrom (A.4)theprobability\nis approximately\n\ud835\udc43\u00b9\ud835\udc4bis in an\ud835\udf16-sized interval around \ud835\udc65\u00ba\u0019\ud835\udf16\u0001\ud835\udc5d\u00b9\ud835\udf16\u0001\ud835\udc56\u00ba, (A.5)\nso summed over all of them it should be\n\ud835\udc43\u00b9\ud835\udc4b2R\u00ba\u0019\u00d5\n\ud835\udc56\ud835\udf16\u0001\ud835\udc5d\u00b9\ud835\udf16\u0001\ud835\udc56\u00ba.(A.6)\nThis is nothing more than the approximation of an integral discussed in Section A.5 , thus\nwe can say that\n\ud835\udc43\u00b9\ud835\udc4b2R\u00ba=\u00b91\n\u00001\ud835\udc5d\u00b9\ud835\udc65\u00ba\ud835\udc51\ud835\udc65. (A.7)\nWe know that \ud835\udc43\u00b9\ud835\udc4b2R\u00ba=1, since the random variable must take on somenumber, we\ncan conclude that for any density\n\u00b91\n\u00001\ud835\udc5d\u00b9\ud835\udc65\u00ba\ud835\udc51\ud835\udc65=1. (A.8)\nIndeed, digging into this further shows that for any \ud835\udc4e, and\ud835\udc4f, we see that\n\ud835\udc43\u00b9\ud835\udc4b2\u00b9\ud835\udc4e,\ud835\udc4f\u00bc\u00ba=\u00b9\ud835\udc4f\n\ud835\udc4e\ud835\udc5d\u00b9\ud835\udc65\u00ba\ud835\udc51\ud835\udc65. (A.9)\n964 Mathematics for Deep Learning\nWe may approximate this in code by using the same discrete approximation methods as\nbefore. Inthiscasewecanapproximatetheprobabilityoffallingintheblueregion.\n# Approximate probability using numerical integration\nepsilon =0.01\nx=torch .arange( -5,5,0.01 )\np=0.2*torch .exp( -(x-3)**2/2)/torch .sqrt( 2*torch .tensor(torch .pi)) +\\\n0.8*torch .exp( -(x+1)**2/2)/torch .sqrt( 2*torch .tensor(torch .pi))\nd2l.set_figsize()\nd2l.plt.plot(x, p, color ='black ')\nd2l.plt.fill_between(x .tolist()[ 300:800], p .tolist()[ 300:800])\nd2l.plt.show()\nf'approximate Probability: {torch .sum(epsilon *p[300:800])}'\n'approximate Probability: 0.773617148399353 '\nIt turns out that these two properties describe exactly the space of possible probability\ndensity functions (or p.d.f.\u2019s for the commonly encountered abbreviation). They are non-\nnegative functions \ud835\udc5d\u00b9\ud835\udc65\u00ba\u00150such that\n\u00b91\n\u00001\ud835\udc5d\u00b9\ud835\udc65\u00ba\ud835\udc51\ud835\udc65=1. (A.10)\nWeinterpretthisfunctionbyusingintegrationtoobtaintheprobabilityourrandomvariable\nis in a specific interval:\n\ud835\udc43\u00b9\ud835\udc4b2\u00b9\ud835\udc4e,\ud835\udc4f\u00bc\u00ba=\u00b9\ud835\udc4f\n\ud835\udc4e\ud835\udc5d\u00b9\ud835\udc65\u00ba\ud835\udc51\ud835\udc65. (A.11)\nInSection A.8 we will see a number of common distributions, but let\u2019s continue working\nin the abstract.\nCumulativeDistribution Functions\nIn the previous section, we saw the notion of the p.d.f. In practice, this is a commonly en-\ncounteredmethodtodiscusscontinuousrandomvariables,butithasonesignificantpitfall:\nthat the values of the p.d.f. are not themselves probabilities, but rather a function that we\nmust integrate to yield probabilities. There is nothing wrong with a density being larger\n965 Random Variables\nthan 10, as long as it is not larger than 10for more than an interval of length 1\u009d10. This\ncan be counter-intuitive, so people often also think in terms of the cumulative distribution\nfunction, or c.d.f., which isa probability.\nIn particular, by using (A.11 ), we define the c.d.f. for a random variable \ud835\udc4bwith density\n\ud835\udc5d\u00b9\ud835\udc65\u00baby\n\ud835\udc39\u00b9\ud835\udc65\u00ba=\u00b9\ud835\udc65\n\u00001\ud835\udc5d\u00b9\ud835\udc65\u00ba\ud835\udc51\ud835\udc65=\ud835\udc43\u00b9\ud835\udc4b\u0014\ud835\udc65\u00ba. (A.12)\nLet\u2019s observe a few properties.", "mimetype": "text/plain", "start_char_idx": 1988235, "end_char_idx": 1990948, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d57f150c-2208-4866-ae1b-14305e248f65": {"__data__": {"id_": "d57f150c-2208-4866-ae1b-14305e248f65", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "33254742-f72c-4234-81e2-91cc47b223d7", "node_type": "1", "metadata": {}, "hash": "0f2532be4a722d7828961f1024cee68a63e2016d4e7bf87a84f597ed349fab3e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e8241460-99c3-47e9-9f64-59c4cdd5832e", "node_type": "1", "metadata": {}, "hash": "371f5b3baf2a561b635f3db64eba248d3a89a0fa7a12242812da05bf68a10fdb", "class_name": "RelatedNodeInfo"}}, "text": "are not themselves probabilities, but rather a function that we\nmust integrate to yield probabilities. There is nothing wrong with a density being larger\n965 Random Variables\nthan 10, as long as it is not larger than 10for more than an interval of length 1\u009d10. This\ncan be counter-intuitive, so people often also think in terms of the cumulative distribution\nfunction, or c.d.f., which isa probability.\nIn particular, by using (A.11 ), we define the c.d.f. for a random variable \ud835\udc4bwith density\n\ud835\udc5d\u00b9\ud835\udc65\u00baby\n\ud835\udc39\u00b9\ud835\udc65\u00ba=\u00b9\ud835\udc65\n\u00001\ud835\udc5d\u00b9\ud835\udc65\u00ba\ud835\udc51\ud835\udc65=\ud835\udc43\u00b9\ud835\udc4b\u0014\ud835\udc65\u00ba. (A.12)\nLet\u2019s observe a few properties.\n\u000f\ud835\udc39\u00b9\ud835\udc65\u00ba! 0as\ud835\udc65!\u00001.\n\u000f\ud835\udc39\u00b9\ud835\udc65\u00ba! 1as\ud835\udc65!1.\n\u000f\ud835\udc39\u00b9\ud835\udc65\u00bais non-decreasing ( \ud835\udc66 >\ud835\udc65 =)\ud835\udc39\u00b9\ud835\udc66\u00ba\u0015\ud835\udc39\u00b9\ud835\udc65\u00ba).\n\u000f\ud835\udc39\u00b9\ud835\udc65\u00bais continuous (has no jumps) if \ud835\udc4bis a continuous random variable.\nWith the fourth bullet point, note that this would not be true if \ud835\udc4bwere discrete, say taking\nthe values 0and1both with probability 1\u009d2. In that case\n\ud835\udc39\u00b9\ud835\udc65\u00ba=8>>> <\n>>>:0\ud835\udc65 <0,\n1\n2\ud835\udc65 <1,\n1\ud835\udc65\u00151.(A.13)\nIn this example, we see one of the benefits of working with the c.d.f., the ability to deal\nwith continuous or discrete random variables in the same framework, or indeed mixtures\nof the two (flip a coin: if heads return the roll of a die, if tails return the distance of a dart\nthrow from the center of a dart board).\nMeans\nSuppose that we are dealing with a random variables \ud835\udc4b. The distribution itself can be hard\nto interpret. It is often useful to be able to summarize the behavior of a random variable\nconcisely. Numbers that help us capture the behavior of a random variable are called sum-\nmarystatistics . The most commonly encountered ones are the mean, thevariance , and the\nstandarddeviation .\nThemeanencodes the average value of a random variable. If we have a discrete random\nvariable\ud835\udc4b, which takes the values \ud835\udc65\ud835\udc56with probabilities \ud835\udc5d\ud835\udc56, then the mean is given by the\nweighted average: sum the values times the probability that the random variable takes on\nthat value:\n\ud835\udf07\ud835\udc4b=\ud835\udc38\u00bb\ud835\udc4b\u00bc=\u00d5\n\ud835\udc56\ud835\udc65\ud835\udc56\ud835\udc5d\ud835\udc56.(A.14)\nThe way we should interpret the mean (albeit with caution) is that it tells us essentially\nwhere the random variable tends to be located.\nAs a minimalistic example that we will examine throughout this section, let\u2019s take \ud835\udc4bto be\n966 Mathematics for Deep Learning\ntherandomvariablewhichtakesthevalue \ud835\udc4e\u00002withprobability \ud835\udc5d,\ud835\udc4e\u00b82withprobability \ud835\udc5d\nand\ud835\udc4ewith probability 1\u00002\ud835\udc5d. We can compute using (A.14 )that, for any possible choice\nof\ud835\udc4eand\ud835\udc5d, the mean is\n\ud835\udf07\ud835\udc4b=\ud835\udc38\u00bb\ud835\udc4b\u00bc=\u00d5\n\ud835\udc56\ud835\udc65\ud835\udc56\ud835\udc5d\ud835\udc56=\u00b9\ud835\udc4e\u00002\u00ba\ud835\udc5d\u00b8\ud835\udc4e\u00b91\u00002\ud835\udc5d\u00ba\u00b8\u00b9\ud835\udc4e\u00b82\u00ba\ud835\udc5d=\ud835\udc4e.(A.15)\nThus we see that the mean is \ud835\udc4e. This matches the intuition since \ud835\udc4eis the location around\nwhich we centered our random variable.\nBecause they are helpful, let\u2019s summarize a few properties.\n\u000fFor any random variable \ud835\udc4band numbers \ud835\udc4eand\ud835\udc4f, we have that \ud835\udf07\ud835\udc4e\ud835\udc4b\u00b8\ud835\udc4f=\ud835\udc4e\ud835\udf07\ud835\udc4b\u00b8\ud835\udc4f.\n\u000fIf we have two random variables \ud835\udc4band\ud835\udc4c, we have\ud835\udf07\ud835\udc4b\u00b8\ud835\udc4c=\ud835\udf07\ud835\udc4b\u00b8\ud835\udf07\ud835\udc4c.", "mimetype": "text/plain", "start_char_idx": 1990385, "end_char_idx": 1993099, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e8241460-99c3-47e9-9f64-59c4cdd5832e": {"__data__": {"id_": "e8241460-99c3-47e9-9f64-59c4cdd5832e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d57f150c-2208-4866-ae1b-14305e248f65", "node_type": "1", "metadata": {}, "hash": "1cf3aeabefae9410bea90b94d898cd572ac8eb761790b85fa36a6d0f2ab1efdf", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "318c3cde-77a5-46b3-bedd-faa580a33da4", "node_type": "1", "metadata": {}, "hash": "d0508f279e2f5e50e14d61cf1b85d23ddb75f12e0be81622b3e98bb56ca109b1", "class_name": "RelatedNodeInfo"}}, "text": "(A.15)\nThus we see that the mean is \ud835\udc4e. This matches the intuition since \ud835\udc4eis the location around\nwhich we centered our random variable.\nBecause they are helpful, let\u2019s summarize a few properties.\n\u000fFor any random variable \ud835\udc4band numbers \ud835\udc4eand\ud835\udc4f, we have that \ud835\udf07\ud835\udc4e\ud835\udc4b\u00b8\ud835\udc4f=\ud835\udc4e\ud835\udf07\ud835\udc4b\u00b8\ud835\udc4f.\n\u000fIf we have two random variables \ud835\udc4band\ud835\udc4c, we have\ud835\udf07\ud835\udc4b\u00b8\ud835\udc4c=\ud835\udf07\ud835\udc4b\u00b8\ud835\udf07\ud835\udc4c.\nMeansareusefulforunderstandingtheaveragebehaviorofarandomvariable,howeverthe\nmeanisnotsufficienttoevenhaveafullintuitiveunderstanding. Makingaprofitof $10\u0006$1\nper sale is very different from making $10\u0006$15per sale despite having the same average\nvalue. The second one has a much larger degree of fluctuation, and thus represents a much\nlargerrisk. Thus,tounderstandthebehaviorofarandomvariable,wewillneedatminimum\none more measure: some measure of how widely a random variable fluctuates.\nVariances\nThis leads us to consider the variance of a random variable. This is a quantitative measure\nof how far a random variable deviates from the mean. Consider the expression \ud835\udc4b\u0000\ud835\udf07\ud835\udc4b.\nThis is the deviation of the random variable from its mean. This value can be positive\nor negative, so we need to do something to make it positive so that we are measuring the\nmagnitude of the deviation.\nA reasonable thing to try is to look at j\ud835\udc4b\u0000\ud835\udf07\ud835\udc4bj, and indeed this leads to a useful quan-\ntity called the mean absolute deviation , however due to connections with other areas of\nmathematics and statistics, people often use a different solution.\nInparticular,theylookat \u00b9\ud835\udc4b\u0000\ud835\udf07\ud835\udc4b\u00ba2.Ifwelookatthetypicalsizeofthisquantitybytaking\nthe mean, we arrive at the variance\n\ud835\udf0e2\n\ud835\udc4b=Var\u00b9\ud835\udc4b\u00ba=\ud835\udc38\u0002\n\u00b9\ud835\udc4b\u0000\ud835\udf07\ud835\udc4b\u00ba2\u0003\n=\ud835\udc38\u00bb\ud835\udc4b2\u00bc\u0000\ud835\udf072\n\ud835\udc4b. (A.16)\nThelastequalityin (A.16 )holdsbyexpandingoutthedefinitioninthemiddle,andapplying\nthe properties of expectation.\nLet\u2019s look at our example where \ud835\udc4bis the random variable which takes the value \ud835\udc4e\u00002with\nprobability\ud835\udc5d,\ud835\udc4e\u00b82with probability \ud835\udc5dand\ud835\udc4ewith probability 1\u00002\ud835\udc5d. In this case \ud835\udf07\ud835\udc4b=\ud835\udc4e,\nso all we need to compute is \ud835\udc38\u0002\n\ud835\udc4b2\u0003\n. This can readily be done:\n\ud835\udc38\u0002\n\ud835\udc4b2\u0003\n=\u00b9\ud835\udc4e\u00002\u00ba2\ud835\udc5d\u00b8\ud835\udc4e2\u00b91\u00002\ud835\udc5d\u00ba\u00b8\u00b9\ud835\udc4e\u00b82\u00ba2\ud835\udc5d=\ud835\udc4e2\u00b88\ud835\udc5d. (A.17)\nThus, we see that by (A.16 )our variance is\n\ud835\udf0e2\n\ud835\udc4b=Var\u00b9\ud835\udc4b\u00ba=\ud835\udc38\u00bb\ud835\udc4b2\u00bc\u0000\ud835\udf072\n\ud835\udc4b=\ud835\udc4e2\u00b88\ud835\udc5d\u0000\ud835\udc4e2=8\ud835\udc5d. (A.18)\n967 Random Variables\nThis result again makes sense. The largest \ud835\udc5dcan be is 1\u009d2which corresponds to picking\n\ud835\udc4e\u00002or\ud835\udc4e\u00b82with a coin flip. The variance of this being 4corresponds to the fact that\nboth\ud835\udc4e\u00002and\ud835\udc4e\u00b82are2units away from the mean, and 22=4. On the other end of the\nspectrum, if \ud835\udc5d=0, this random variable always takes the value 0and so it has no variance\nat all.\nWe will list a few properties of variance below:\n\u000fFor any random variable \ud835\udc4b, Var\u00b9\ud835\udc4b\u00ba\u00150, with Var\u00b9\ud835\udc4b\u00ba=0if and only if \ud835\udc4bis a constant.\n\u000fForanyrandomvariable \ud835\udc4bandnumbers \ud835\udc4eand\ud835\udc4f,wehavethatVar\u00b9\ud835\udc4e\ud835\udc4b\u00b8\ud835\udc4f\u00ba=\ud835\udc4e2Var\u00b9\ud835\udc4b\u00ba.", "mimetype": "text/plain", "start_char_idx": 1992775, "end_char_idx": 1995420, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "318c3cde-77a5-46b3-bedd-faa580a33da4": {"__data__": {"id_": "318c3cde-77a5-46b3-bedd-faa580a33da4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e8241460-99c3-47e9-9f64-59c4cdd5832e", "node_type": "1", "metadata": {}, "hash": "371f5b3baf2a561b635f3db64eba248d3a89a0fa7a12242812da05bf68a10fdb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b5bd7d32-8f7f-4f09-8b49-fceebd38c860", "node_type": "1", "metadata": {}, "hash": "8e5c0430e96a1968ef9296c4c5d0c0212a877acd948e3d8f5cd0e271be2d8d4d", "class_name": "RelatedNodeInfo"}}, "text": "The variance of this being 4corresponds to the fact that\nboth\ud835\udc4e\u00002and\ud835\udc4e\u00b82are2units away from the mean, and 22=4. On the other end of the\nspectrum, if \ud835\udc5d=0, this random variable always takes the value 0and so it has no variance\nat all.\nWe will list a few properties of variance below:\n\u000fFor any random variable \ud835\udc4b, Var\u00b9\ud835\udc4b\u00ba\u00150, with Var\u00b9\ud835\udc4b\u00ba=0if and only if \ud835\udc4bis a constant.\n\u000fForanyrandomvariable \ud835\udc4bandnumbers \ud835\udc4eand\ud835\udc4f,wehavethatVar\u00b9\ud835\udc4e\ud835\udc4b\u00b8\ud835\udc4f\u00ba=\ud835\udc4e2Var\u00b9\ud835\udc4b\u00ba.\n\u000fIf we have two independent random variables \ud835\udc4band\ud835\udc4c, we have Var\u00b9\ud835\udc4b\u00b8\ud835\udc4c\u00ba=Var\u00b9\ud835\udc4b\u00ba\u00b8\nVar\u00b9\ud835\udc4c\u00ba.\nWhen interpreting these values, there can be a bit of a hiccup. In particular, let\u2019s try imag-\niningwhathappensifwekeeptrackofunitsthroughthiscomputation. Supposethatweare\nworkingwiththestarratingassignedtoaproductonthewebpage. Then \ud835\udc4e,\ud835\udc4e\u00002, and\ud835\udc4e\u00b82\nare all measured in units of stars. Similarly, the mean \ud835\udf07\ud835\udc4bis then also measured in stars\n(being a weighted average). However, if we get to the variance, we immediately encounter\nan issue, which is we want to look at \u00b9\ud835\udc4b\u0000\ud835\udf07\ud835\udc4b\u00ba2, which is in units of squared stars . This\nmeans that the variance itself is not comparable to the original measurements. To make it\ninterpretable, we will need to return to our original units.\nStandardDeviations\nThissummarystatisticscanalwaysbededucedfromthevariancebytakingthesquareroot!\nThus we define the standarddeviation to be\n\ud835\udf0e\ud835\udc4b=p\nVar\u00b9\ud835\udc4b\u00ba. (A.19)\nIn our example, this means we now have the standard deviation is \ud835\udf0e\ud835\udc4b=2p\n2\ud835\udc5d. If we are\ndealing with units of stars for our review example, \ud835\udf0e\ud835\udc4bis again in units of stars.\nThe properties we had for the variance can be restated for the standard deviation.\n\u000fFor any random variable \ud835\udc4b,\ud835\udf0e\ud835\udc4b\u00150.\n\u000fFor any random variable \ud835\udc4band numbers \ud835\udc4eand\ud835\udc4f, we have that \ud835\udf0e\ud835\udc4e\ud835\udc4b\u00b8\ud835\udc4f=j\ud835\udc4ej\ud835\udf0e\ud835\udc4b\n\u000fIf we have two independent random variables \ud835\udc4band\ud835\udc4c, we have\ud835\udf0e\ud835\udc4b\u00b8\ud835\udc4c=q\n\ud835\udf0e2\n\ud835\udc4b\u00b8\ud835\udf0e2\n\ud835\udc4c.\nIt is natural at this moment to ask, \u201cIf the standard deviation is in the units of our original\nrandom variable, does it represent something we can draw with regards to that random\nvariable?\u201d The answer is a resounding yes! Indeed much like the mean told us the typical\nlocation of our random variable, the standard deviation gives the typical range of variation\nof that random variable. We can make this rigorous with what is known as Chebyshev\u2019s\ninequality:\n\ud835\udc43\u00b9\ud835\udc4b\u2209\u00bb\ud835\udf07\ud835\udc4b\u0000\ud835\udefc\ud835\udf0e\ud835\udc4b,\ud835\udf07\ud835\udc4b\u00b8\ud835\udefc\ud835\udf0e\ud835\udc4b\u00bc\u00ba\u00141\n\ud835\udefc2. (A.20)\n968 Mathematics for Deep Learning\nOr to state it verbally in the case of \ud835\udefc=10,99%of the samples from any random variable\nfall within 10standard deviations of the mean. This gives an immediate interpretation to\nour standard summary statistics.\nTo see how this statement is rather subtle, let\u2019s take a look at our running example again\nwhere\ud835\udc4bis the random variable which takes the value \ud835\udc4e\u00002with probability \ud835\udc5d,\ud835\udc4e\u00b82with\nprobability\ud835\udc5dand\ud835\udc4ewith probability 1\u00002\ud835\udc5d. We saw that the mean was \ud835\udc4eand the standard\ndeviation was 2p\n2\ud835\udc5d.", "mimetype": "text/plain", "start_char_idx": 1994989, "end_char_idx": 1997771, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b5bd7d32-8f7f-4f09-8b49-fceebd38c860": {"__data__": {"id_": "b5bd7d32-8f7f-4f09-8b49-fceebd38c860", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "318c3cde-77a5-46b3-bedd-faa580a33da4", "node_type": "1", "metadata": {}, "hash": "d0508f279e2f5e50e14d61cf1b85d23ddb75f12e0be81622b3e98bb56ca109b1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1b1a3d3d-5c52-40ae-a4f9-b489a54ddf4e", "node_type": "1", "metadata": {}, "hash": "a588fac9839609008c8ebc1c8ca25a5d09dd8aa0c2e76af0a2372a24a3673e63", "class_name": "RelatedNodeInfo"}}, "text": "(A.20)\n968 Mathematics for Deep Learning\nOr to state it verbally in the case of \ud835\udefc=10,99%of the samples from any random variable\nfall within 10standard deviations of the mean. This gives an immediate interpretation to\nour standard summary statistics.\nTo see how this statement is rather subtle, let\u2019s take a look at our running example again\nwhere\ud835\udc4bis the random variable which takes the value \ud835\udc4e\u00002with probability \ud835\udc5d,\ud835\udc4e\u00b82with\nprobability\ud835\udc5dand\ud835\udc4ewith probability 1\u00002\ud835\udc5d. We saw that the mean was \ud835\udc4eand the standard\ndeviation was 2p\n2\ud835\udc5d. This means, if we take Chebyshev\u2019s inequality (A.20 )with\ud835\udefc=2,\nwe see that the expression is\n\ud835\udc43\u0010\n\ud835\udc4b\u2209\u00bb\ud835\udc4e\u00004p\n2\ud835\udc5d,\ud835\udc4e\u00b84p\n2\ud835\udc5d\u00bc\u0011\n\u00141\n4. (A.21)\nThis means that 75%of the time, this random variable will fall within this interval for any\nvalue of\ud835\udc5d. Now, notice that as \ud835\udc5d!0, this interval also converges to the single point \ud835\udc4e.\nButweknowthatourrandomvariabletakesthevalues \ud835\udc4e\u00002,\ud835\udc4e,and\ud835\udc4e\u00b82onlysoeventually\nwe can be certain \ud835\udc4e\u00002and\ud835\udc4e\u00b82will fall outside the interval! The question is, at what \ud835\udc5d\ndoes that happen. So we want to solve: for what \ud835\udc5ddoes\ud835\udc4e\u00b84p\n2\ud835\udc5d=\ud835\udc4e\u00b82, which is solved\nwhen\ud835\udc5d=1\u009d8,whichis exactlythefirst\ud835\udc5dwhereitcouldpossiblyhappenwithoutviolating\nour claim that no more than 1\u009d4of samples from the distribution would fall outside the\ninterval ( 1\u009d8to the left, and 1\u009d8to the right).\nLet\u2019svisualizethis. Wewillshowtheprobabilityofgettingthethreevaluesasthreevertical\nbars with height proportional to the probability. The interval will be drawn as a horizontal\nline in the middle. The first plot shows what happens for \ud835\udc5d > 1\u009d8where the interval safely\ncontains all points.\n# Define a helper to plot these figures\ndef plot_chebyshev (a, p):\nd2l.set_figsize()\nd2l.plt.stem([a -2, a, a +2], [p, 1-2*p, p], use_line_collection =True )\nd2l.plt.xlim([ -4,4])\nd2l.plt.xlabel( 'x')\nd2l.plt.ylabel( 'p.m.f. ')\nd2l.plt.hlines( 0.5, a -4*torch .sqrt( 2*p),\na+4*torch .sqrt( 2*p), 'black ', lw =4)\nd2l.plt.vlines(a -4*torch .sqrt( 2*p), 0.53 ,0.47 ,'black ', lw =1)\nd2l.plt.vlines(a +4*torch .sqrt( 2*p), 0.53 ,0.47 ,'black ', lw =1)\nd2l.plt.title( f'p = {p:.3f}')\nd2l.plt.show()\n# Plot interval when p > 1/8\nplot_chebyshev( 0.0, torch .tensor( 0.2))\nThe second shows that at \ud835\udc5d=1\u009d8, the interval exactly touches the two points. This shows\nthat the inequality is sharp, since no smaller interval could be taken while keeping the\ninequality true.\n969 Random Variables\n# Plot interval when p = 1/8\nplot_chebyshev( 0.0, torch .tensor( 0.125 ))\nThethirdshowsthatfor \ud835\udc5d < 1\u009d8theintervalonlycontainsthecenter. Thisdoesnotinvali-\ndate the inequality since we only needed to ensure that no more than 1\u009d4of the probability\nfalls outside the interval, which means that once \ud835\udc5d < 1\u009d8, the two points at \ud835\udc4e\u00002and\ud835\udc4e\u00b82\ncan be discarded.", "mimetype": "text/plain", "start_char_idx": 1997247, "end_char_idx": 1999955, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1b1a3d3d-5c52-40ae-a4f9-b489a54ddf4e": {"__data__": {"id_": "1b1a3d3d-5c52-40ae-a4f9-b489a54ddf4e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b5bd7d32-8f7f-4f09-8b49-fceebd38c860", "node_type": "1", "metadata": {}, "hash": "8e5c0430e96a1968ef9296c4c5d0c0212a877acd948e3d8f5cd0e271be2d8d4d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "18ebeeb0-c2c1-4f2e-84ef-8e0b4304213e", "node_type": "1", "metadata": {}, "hash": "13738c61a832236ce94c4eb4b10a4f58abc4598f6c2123c4040b5e8ddc5b0a28", "class_name": "RelatedNodeInfo"}}, "text": "This shows\nthat the inequality is sharp, since no smaller interval could be taken while keeping the\ninequality true.\n969 Random Variables\n# Plot interval when p = 1/8\nplot_chebyshev( 0.0, torch .tensor( 0.125 ))\nThethirdshowsthatfor \ud835\udc5d < 1\u009d8theintervalonlycontainsthecenter. Thisdoesnotinvali-\ndate the inequality since we only needed to ensure that no more than 1\u009d4of the probability\nfalls outside the interval, which means that once \ud835\udc5d < 1\u009d8, the two points at \ud835\udc4e\u00002and\ud835\udc4e\u00b82\ncan be discarded.\n# Plot interval when p < 1/8\nplot_chebyshev( 0.0, torch .tensor( 0.05 ))\n\n970 Mathematics for Deep Learning\nMeans and Variancesin the Continuum\nThis has all been in terms of discrete random variables, but the case of continuous random\nvariables is similar. To intuitively understand how this works, imagine that we split the\nreal number line into intervals of length \ud835\udf16given by\u00b9\ud835\udf16\ud835\udc56,\ud835\udf16\u00b9\ud835\udc56\u00b81\u00ba\u00bc. Once we do this, our\ncontinuousrandomvariablehasbeenmadediscreteandwecanuse (A.14 )saythat\n\ud835\udf07\ud835\udc4b\u0019\u00d5\n\ud835\udc56\u00b9\ud835\udf16\ud835\udc56\u00ba\ud835\udc43\u00b9\ud835\udc4b2\u00b9\ud835\udf16\ud835\udc56,\ud835\udf16\u00b9\ud835\udc56\u00b81\u00ba\u00bc\u00ba\n\u0019\u00d5\n\ud835\udc56\u00b9\ud835\udf16\ud835\udc56\u00ba\ud835\udc5d\ud835\udc4b\u00b9\ud835\udf16\ud835\udc56\u00ba\ud835\udf16,(A.22)\nwhere\ud835\udc5d\ud835\udc4bis the density of \ud835\udc4b. This is an approximation to the integral of \ud835\udc65\ud835\udc5d\ud835\udc4b\u00b9\ud835\udc65\u00ba, so we\ncan conclude that\n\ud835\udf07\ud835\udc4b=\u00b91\n\u00001\ud835\udc65\ud835\udc5d\ud835\udc4b\u00b9\ud835\udc65\u00ba\ud835\udc51\ud835\udc65. (A.23)\nSimilarly, using (A.16 )the variance can be written as\n\ud835\udf0e2\n\ud835\udc4b=\ud835\udc38\u00bb\ud835\udc4b2\u00bc\u0000\ud835\udf072\n\ud835\udc4b=\u00b91\n\u00001\ud835\udc652\ud835\udc5d\ud835\udc4b\u00b9\ud835\udc65\u00ba\ud835\udc51\ud835\udc65\u0000\u0012\u00b91\n\u00001\ud835\udc65\ud835\udc5d\ud835\udc4b\u00b9\ud835\udc65\u00ba\ud835\udc51\ud835\udc65\u00132\n. (A.24)\nEverything stated above about the mean, the variance, and the standard deviation still ap-\nplies in this case. For instance, if we consider the random variable with density\n\ud835\udc5d\u00b9\ud835\udc65\u00ba=(\n1\ud835\udc652\u00bb0,1\u00bc,\n0otherwise.(A.25)\nwe can compute\n\ud835\udf07\ud835\udc4b=\u00b91\n\u00001\ud835\udc65\ud835\udc5d\u00b9\ud835\udc65\u00ba\ud835\udc51\ud835\udc65=\u00b91\n0\ud835\udc65 \ud835\udc51\ud835\udc65=1\n2. (A.26)\nand\n\ud835\udf0e2\n\ud835\udc4b=\u00b91\n\u00001\ud835\udc652\ud835\udc5d\u00b9\ud835\udc65\u00ba\ud835\udc51\ud835\udc65\u0000\u00121\n2\u00132\n=1\n3\u00001\n4=1\n12. (A.27)\nAs a warning, let\u2019s examine one more example, known as the Cauchy distribution . This is\nthe distribution with p.d.f. given by\n\ud835\udc5d\u00b9\ud835\udc65\u00ba=1\n1\u00b8\ud835\udc652. (A.28)\n# Plot the Cauchy distribution p.d.f.\nx=torch .arange( -5,5,0.01 )\np=1/(1+x**2)\nd2l.plot(x, p, 'x','p.d.f. ')\nThis function looks innocent, and indeed consulting a table of integrals will show it has\narea one under it, and thus it defines a continuous random variable.\n971 Random Variables\nTo see what goes astray, let\u2019s try to compute the variance of this. This would involve using\n(A.16 )computing\n\u00b91\n\u00001\ud835\udc652\n1\u00b8\ud835\udc652\ud835\udc51\ud835\udc65.", "mimetype": "text/plain", "start_char_idx": 1999467, "end_char_idx": 2001601, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "18ebeeb0-c2c1-4f2e-84ef-8e0b4304213e": {"__data__": {"id_": "18ebeeb0-c2c1-4f2e-84ef-8e0b4304213e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1b1a3d3d-5c52-40ae-a4f9-b489a54ddf4e", "node_type": "1", "metadata": {}, "hash": "a588fac9839609008c8ebc1c8ca25a5d09dd8aa0c2e76af0a2372a24a3673e63", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "62461ea1-aa58-4ead-bf7e-38c3a99fbb97", "node_type": "1", "metadata": {}, "hash": "c2794ee7b4e3867565fcee147ab94d96a4c4d655e59b0fadf8f62a72547fd6bd", "class_name": "RelatedNodeInfo"}}, "text": "This is\nthe distribution with p.d.f. given by\n\ud835\udc5d\u00b9\ud835\udc65\u00ba=1\n1\u00b8\ud835\udc652. (A.28)\n# Plot the Cauchy distribution p.d.f.\nx=torch .arange( -5,5,0.01 )\np=1/(1+x**2)\nd2l.plot(x, p, 'x','p.d.f. ')\nThis function looks innocent, and indeed consulting a table of integrals will show it has\narea one under it, and thus it defines a continuous random variable.\n971 Random Variables\nTo see what goes astray, let\u2019s try to compute the variance of this. This would involve using\n(A.16 )computing\n\u00b91\n\u00001\ud835\udc652\n1\u00b8\ud835\udc652\ud835\udc51\ud835\udc65. (A.29)\nThe function on the inside looks like this:\n# Plot the integrand needed to compute the variance\nx=torch .arange( -20,20,0.01 )\np=x**2/(1+x**2)\nd2l.plot(x, p, 'x','integrand ')\nThis function clearly has infinite area under it since it is essentially the constant one with a\nsmall dip near zero, and indeed we could show that\n\u00b91\n\u00001\ud835\udc652\n1\u00b8\ud835\udc652\ud835\udc51\ud835\udc65=1. (A.30)\nThis means it does not have a well-defined finite variance.\nHowever, looking deeper shows an even more disturbing result. Let\u2019s try to compute the\nmean using (A.14 ). Using the change of variables formula, we see\n\ud835\udf07\ud835\udc4b=\u00b91\n\u00001\ud835\udc65\n1\u00b8\ud835\udc652\ud835\udc51\ud835\udc65=1\n2\u00b91\n11\n\ud835\udc62\ud835\udc51\ud835\udc62. (A.31)\nThe integral inside is the definition of the logarithm, so this is in essence log\u00b91\u00ba=1, so\nthere is no well-defined average value either!\n972 Mathematics for Deep Learning\nMachine learning scientists define their models so that we most often do not need to deal\nwith these issues, and will in the vast majority of cases deal with random variables with\nwell-defined means and variances. However, every so often random variables with heavy\ntails(thatisthoserandomvariableswheretheprobabilitiesofgettinglargevaluesarelarge\nenoughtomakethingslikethemeanorvarianceundefined)arehelpfulinmodelingphysical\nsystems, thus it is worth knowing that they exist.\nJoint Density Functions\nTheaboveworkallassumesweareworkingwithasinglerealvaluedrandomvariable. But\nwhat if we are dealing with two or more potentially highly correlated random variables?\nThis circumstance is the norm in machine learning: imagine random variables like \ud835\udc45\ud835\udc56,\ud835\udc57\nwhich encode the red value of the pixel at the \u00b9\ud835\udc56,\ud835\udc57\u00bacoordinate in an image, or \ud835\udc43\ud835\udc61which is\narandomvariablegivenbyastockpriceattime \ud835\udc61. Nearbypixelstendtohavesimilarcolor,\nand nearby times tend to have similar prices. We cannot treat them as separate random\nvariables, and expect to create a successful model (we will see in Section A.9 a model that\nunder-performsduetosuchanassumption). Weneedtodevelopthemathematicallanguage\nto handle these correlated continuous random variables.\nThankfully, with the multiple integrals in Section A.5 we can develop such a language.\nSuppose that we have, for simplicity, two random variables \ud835\udc4b,\ud835\udc4cwhich can be correlated.\nThen, similar to the case of a single variable, we can ask the question:\n\ud835\udc43\u00b9\ud835\udc4bis in an\ud835\udf16-sized interval around \ud835\udc65and\ud835\udc4cis in an\ud835\udf16-sized interval around \ud835\udc66\u00ba.(A.32)\nSimilarreasoningtothesinglevariablecaseshowsthatthisshouldbeapproximately\n\ud835\udc43\u00b9\ud835\udc4bis in an\ud835\udf16-sized interval around \ud835\udc65and\ud835\udc4cis in an\ud835\udf16-sized interval around \ud835\udc66\u00ba\u0019\ud835\udf162\ud835\udc5d\u00b9\ud835\udc65,\ud835\udc66\u00ba,\n(A.33)\nfor some function \ud835\udc5d\u00b9\ud835\udc65,\ud835\udc66\u00ba. This is referred to as the joint density of \ud835\udc4band\ud835\udc4c. Similar\nproperties are true for this as we saw in the single variable case.", "mimetype": "text/plain", "start_char_idx": 2001120, "end_char_idx": 2004258, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "62461ea1-aa58-4ead-bf7e-38c3a99fbb97": {"__data__": {"id_": "62461ea1-aa58-4ead-bf7e-38c3a99fbb97", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "18ebeeb0-c2c1-4f2e-84ef-8e0b4304213e", "node_type": "1", "metadata": {}, "hash": "13738c61a832236ce94c4eb4b10a4f58abc4598f6c2123c4040b5e8ddc5b0a28", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2c0f4fc8-10f1-4944-800b-dc624cef2c9f", "node_type": "1", "metadata": {}, "hash": "ab008555775274c66c898f553696bbe8aa8929c1954ab663668ce389e9b430e3", "class_name": "RelatedNodeInfo"}}, "text": "Then, similar to the case of a single variable, we can ask the question:\n\ud835\udc43\u00b9\ud835\udc4bis in an\ud835\udf16-sized interval around \ud835\udc65and\ud835\udc4cis in an\ud835\udf16-sized interval around \ud835\udc66\u00ba.(A.32)\nSimilarreasoningtothesinglevariablecaseshowsthatthisshouldbeapproximately\n\ud835\udc43\u00b9\ud835\udc4bis in an\ud835\udf16-sized interval around \ud835\udc65and\ud835\udc4cis in an\ud835\udf16-sized interval around \ud835\udc66\u00ba\u0019\ud835\udf162\ud835\udc5d\u00b9\ud835\udc65,\ud835\udc66\u00ba,\n(A.33)\nfor some function \ud835\udc5d\u00b9\ud835\udc65,\ud835\udc66\u00ba. This is referred to as the joint density of \ud835\udc4band\ud835\udc4c. Similar\nproperties are true for this as we saw in the single variable case. Namely:\n\u000f\ud835\udc5d\u00b9\ud835\udc65,\ud835\udc66\u00ba\u00150;\n\u000f\u00af\nR2\ud835\udc5d\u00b9\ud835\udc65,\ud835\udc66\u00ba\ud835\udc51\ud835\udc65 \ud835\udc51\ud835\udc66 =1;\n\u000f\ud835\udc43\u00b9\u00b9\ud835\udc4b,\ud835\udc4c\u00ba2D\u00ba =\u00af\nD\ud835\udc5d\u00b9\ud835\udc65,\ud835\udc66\u00ba\ud835\udc51\ud835\udc65 \ud835\udc51\ud835\udc66.\nIn this way, we can deal with multiple, potentially correlated random variables. If we wish\nto work with more than two random variables, we can extend the multivariate density to as\nmany coordinates as desired by considering \ud835\udc5d\u00b9x\u00ba=\ud835\udc5d\u00b9\ud835\udc651,...,\ud835\udc65\ud835\udc5b\u00ba. The same properties of\nbeing non-negative, and having total integral of one still hold.\nMarginal Distributions\nWhen dealing with multiple variables, we oftentimes want to be able to ignore the rela-\ntionships and ask, \u201chow is this one variable distributed?\u201d Such a distribution is called a\nmarginaldistribution .\n973 Random Variables\nTo be concrete, let\u2019s suppose that we have two random variables \ud835\udc4b,\ud835\udc4cwith joint density\ngiven by\ud835\udc5d\ud835\udc4b,\ud835\udc4c\u00b9\ud835\udc65,\ud835\udc66\u00ba. We will be using the subscript to indicate what random variables the\ndensity is for. The question of finding the marginal distribution is taking this function, and\nusing it to find \ud835\udc5d\ud835\udc4b\u00b9\ud835\udc65\u00ba.\nAs with most things, it is best to return to the intuitive picture to figure out what should be\ntrue. Recall that the density is the function \ud835\udc5d\ud835\udc4bso that\n\ud835\udc43\u00b9\ud835\udc4b2\u00bb\ud835\udc65,\ud835\udc65\u00b8\ud835\udf16\u00bc\u00ba\u0019\ud835\udf16\u0001\ud835\udc5d\ud835\udc4b\u00b9\ud835\udc65\u00ba. (A.34)\nThere is no mention of \ud835\udc4c, but if all we are given is \ud835\udc5d\ud835\udc4b,\ud835\udc4c, we need to include \ud835\udc4csomehow.\nWe can first observe that this is the same as\n\ud835\udc43\u00b9\ud835\udc4b2\u00bb\ud835\udc65,\ud835\udc65\u00b8\ud835\udf16\u00bc, and\ud835\udc4c2R\u00ba\u0019\ud835\udf16\u0001\ud835\udc5d\ud835\udc4b\u00b9\ud835\udc65\u00ba. (A.35)\nOur density does not directly tell us about what happens in this case, we need to split into\nsmall intervals in \ud835\udc66as well, so we can write this as\n\ud835\udf16\u0001\ud835\udc5d\ud835\udc4b\u00b9\ud835\udc65\u00ba\u0019\u00d5\n\ud835\udc56\ud835\udc43\u00b9\ud835\udc4b2\u00bb\ud835\udc65,\ud835\udc65\u00b8\ud835\udf16\u00bc, and\ud835\udc4c2\u00bb\ud835\udf16\u0001\ud835\udc56,\ud835\udf16\u0001\u00b9\ud835\udc56\u00b81\u00ba\u00bc\u00ba\n\u0019\u00d5\n\ud835\udc56\ud835\udf162\ud835\udc5d\ud835\udc4b,\ud835\udc4c\u00b9\ud835\udc65,\ud835\udf16\u0001\ud835\udc56\u00ba.(A.36)\ntFig. A.1 By summing along the columns of our array of probabilities, we are able to obtain the\nmarginal distribution for just the random variable represented along the x-axis.\nThistellsustoaddupthevalueofthedensityalongaseriesofsquaresinalineasisshown\ninFig. A.1.", "mimetype": "text/plain", "start_char_idx": 2003785, "end_char_idx": 2006030, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2c0f4fc8-10f1-4944-800b-dc624cef2c9f": {"__data__": {"id_": "2c0f4fc8-10f1-4944-800b-dc624cef2c9f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "62461ea1-aa58-4ead-bf7e-38c3a99fbb97", "node_type": "1", "metadata": {}, "hash": "c2794ee7b4e3867565fcee147ab94d96a4c4d655e59b0fadf8f62a72547fd6bd", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c09c3d44-1be5-484c-9259-896c3446fdc6", "node_type": "1", "metadata": {}, "hash": "d074c83790d5ede76e9dff60137cd8b933e61c2837aba2240117bc62621b3e78", "class_name": "RelatedNodeInfo"}}, "text": "(A.36)\ntFig. A.1 By summing along the columns of our array of probabilities, we are able to obtain the\nmarginal distribution for just the random variable represented along the x-axis.\nThistellsustoaddupthevalueofthedensityalongaseriesofsquaresinalineasisshown\ninFig. A.1. Indeed, after canceling one factor of epsilon from both sides, and recognizing\nthe sum on the right is the integral over \ud835\udc66, we can conclude that\n\ud835\udc5d\ud835\udc4b\u00b9\ud835\udc65\u00ba\u0019\u00d5\n\ud835\udc56\ud835\udf16\ud835\udc5d\ud835\udc4b,\ud835\udc4c\u00b9\ud835\udc65,\ud835\udf16\u0001\ud835\udc56\u00ba\n\u0019\u00b91\n\u00001\ud835\udc5d\ud835\udc4b,\ud835\udc4c\u00b9\ud835\udc65,\ud835\udc66\u00ba\ud835\udc51\ud835\udc66.(A.37)\nThus we see\n\ud835\udc5d\ud835\udc4b\u00b9\ud835\udc65\u00ba=\u00b91\n\u00001\ud835\udc5d\ud835\udc4b,\ud835\udc4c\u00b9\ud835\udc65,\ud835\udc66\u00ba\ud835\udc51\ud835\udc66. (A.38)\nThis tells us that to get a marginal distribution, we integrate over the variables we do not\n974 Mathematics for Deep Learning\ncare about. This process is often referred to as integrating out ormarginalized out the\nunneeded variables.\nCovariance\nWhen dealing with multiple random variables, there is one additional summary statistic\nwhich is helpful to know: the covariance . This measures the degree that two random vari-\nable fluctuate together.\nSuppose that we have two random variables \ud835\udc4band\ud835\udc4c, to begin with, let\u2019s suppose they\nare discrete, taking on values \u00b9\ud835\udc65\ud835\udc56,\ud835\udc66\ud835\udc57\u00bawith probability \ud835\udc5d\ud835\udc56\ud835\udc57. In this case, the covariance is\ndefined as\n\ud835\udf0e\ud835\udc4b\ud835\udc4c=Cov\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=\u00d5\n\ud835\udc56,\ud835\udc57\u00b9\ud835\udc65\ud835\udc56\u0000\ud835\udf07\ud835\udc4b\u00ba\u00b9\ud835\udc66\ud835\udc57\u0000\ud835\udf07\ud835\udc4c\u00ba\ud835\udc5d\ud835\udc56\ud835\udc57.=\ud835\udc38\u00bb\ud835\udc4b\ud835\udc4c\u00bc\u0000\ud835\udc38\u00bb\ud835\udc4b\u00bc\ud835\udc38\u00bb\ud835\udc4c\u00bc.(A.39)\nTo think about this intuitively: consider the following pair of random variables. Suppose\nthat\ud835\udc4btakes the values 1and3, and\ud835\udc4ctakes the values\u00001and3. Suppose that we have the\nfollowing probabilities\n\ud835\udc43\u00b9\ud835\udc4b=1and\ud835\udc4c=\u00001\u00ba=\ud835\udc5d\n2,\n\ud835\udc43\u00b9\ud835\udc4b=1and\ud835\udc4c=3\u00ba=1\u0000\ud835\udc5d\n2,\n\ud835\udc43\u00b9\ud835\udc4b=3and\ud835\udc4c=\u00001\u00ba=1\u0000\ud835\udc5d\n2,\n\ud835\udc43\u00b9\ud835\udc4b=3and\ud835\udc4c=3\u00ba=\ud835\udc5d\n2,(A.40)\nwhere\ud835\udc5disaparameterin\u00bb0,1\u00bcwegettopick. Noticethatif \ud835\udc5d=1thentheyarebothalways\ntheirminimumormaximumvaluessimultaneously,andif \ud835\udc5d=0theyareguaranteedtotake\ntheir flipped values simultaneously (one is large when the other is small and vice versa).\nIf\ud835\udc5d=1\u009d2, then the four possibilities are all equally likely, and neither should be related.\nLet\u2019s compute the covariance. First, note \ud835\udf07\ud835\udc4b=2and\ud835\udf07\ud835\udc4c=1, so we may compute using\n(A.39 ):\nCov\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=\u00d5\n\ud835\udc56,\ud835\udc57\u00b9\ud835\udc65\ud835\udc56\u0000\ud835\udf07\ud835\udc4b\u00ba\u00b9\ud835\udc66\ud835\udc57\u0000\ud835\udf07\ud835\udc4c\u00ba\ud835\udc5d\ud835\udc56\ud835\udc57\n=\u00b91\u00002\u00ba\u00b9\u00001\u00001\u00ba\ud835\udc5d\n2\u00b8\u00b91\u00002\u00ba\u00b93\u00001\u00ba1\u0000\ud835\udc5d\n2\u00b8\u00b93\u00002\u00ba\u00b9\u00001\u00001\u00ba1\u0000\ud835\udc5d\n2\u00b8\u00b93\u00002\u00ba\u00b93\u00001\u00ba\ud835\udc5d\n2\n=4\ud835\udc5d\u00002.\n(A.41)\nWhen\ud835\udc5d=1(thecasewheretheyarebothmaximallypositiveornegativeatthesametime)\nhas a covariance of 2. When\ud835\udc5d=0(the case where they are flipped) the covariance is \u00002.", "mimetype": "text/plain", "start_char_idx": 2005759, "end_char_idx": 2007928, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c09c3d44-1be5-484c-9259-896c3446fdc6": {"__data__": {"id_": "c09c3d44-1be5-484c-9259-896c3446fdc6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2c0f4fc8-10f1-4944-800b-dc624cef2c9f", "node_type": "1", "metadata": {}, "hash": "ab008555775274c66c898f553696bbe8aa8929c1954ab663668ce389e9b430e3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "301fd21b-2537-4c8c-bacd-8ffbac02c176", "node_type": "1", "metadata": {}, "hash": "0973d0f83f213b2990c664df1afe34fe79aac7235f714381fe7185cf5ca105df", "class_name": "RelatedNodeInfo"}}, "text": "(A.41)\nWhen\ud835\udc5d=1(thecasewheretheyarebothmaximallypositiveornegativeatthesametime)\nhas a covariance of 2. When\ud835\udc5d=0(the case where they are flipped) the covariance is \u00002.\nFinally, when \ud835\udc5d=1\u009d2(the case where they are unrelated), the covariance is 0. Thus we\nsee that the covariance measures how these two random variables are related.\nA quick note on the covariance is that it only measures these linear relationships. More\ncomplex relationships like \ud835\udc4b=\ud835\udc4c2where\ud835\udc4cis randomly chosen from f\u00002,\u00001,0,1,2gwith\n975 Random Variables\nequalprobabilitycanbemissed. Indeedaquickcomputationshowsthattheserandomvari-\nables have covariance zero, despite one being a deterministic function of the other.\nFor continuous random variables, much the same story holds. At this point, we are pretty\ncomfortable with doing the transition between discrete and continuous, so we will provide\nthe continuous analogue of (A.39 )without any derivation.\n\ud835\udf0e\ud835\udc4b\ud835\udc4c=\u00b9\nR2\u00b9\ud835\udc65\u0000\ud835\udf07\ud835\udc4b\u00ba\u00b9\ud835\udc66\u0000\ud835\udf07\ud835\udc4c\u00ba\ud835\udc5d\u00b9\ud835\udc65,\ud835\udc66\u00ba\ud835\udc51\ud835\udc65 \ud835\udc51\ud835\udc66. (A.42)\nFor visualization, let\u2019s take a look at a collection of random variables with tunable covari-\nance.\n# Plot a few random variables adjustable covariance\ncovs =[-0.9,0.0,1.2]\nd2l.plt.figure(figsize =(12,3))\nfor iinrange (3):\nX=torch .randn( 500)\nY=covs[i] *X+torch .randn( 500)\nd2l.plt.subplot( 1,4, i+1)\nd2l.plt.scatter(X .numpy(), Y .numpy())\nd2l.plt.xlabel( 'X')\nd2l.plt.ylabel( 'Y')\nd2l.plt.title( f'cov = {covs[i] }')\nd2l.plt.show()\nLet\u2019s see some properties of covariances:\n\u000fFor any random variable \ud835\udc4b, Cov\u00b9\ud835\udc4b,\ud835\udc4b\u00ba=Var\u00b9\ud835\udc4b\u00ba.\n\u000fForanyrandomvariables \ud835\udc4b,\ud835\udc4candnumbers \ud835\udc4eand\ud835\udc4f,Cov\u00b9\ud835\udc4e\ud835\udc4b\u00b8\ud835\udc4f,\ud835\udc4c\u00ba=Cov\u00b9\ud835\udc4b,\ud835\udc4e\ud835\udc4c\u00b8\ud835\udc4f\u00ba=\n\ud835\udc4eCov\u00b9\ud835\udc4b,\ud835\udc4c\u00ba.\n\u000fIf\ud835\udc4band\ud835\udc4care independent then Cov \u00b9\ud835\udc4b,\ud835\udc4c\u00ba=0.\nIn addition, we can use the covariance to expand a relationship we saw before. Recall that\nis\ud835\udc4band\ud835\udc4care two independent random variables then\nVar\u00b9\ud835\udc4b\u00b8\ud835\udc4c\u00ba=Var\u00b9\ud835\udc4b\u00ba\u00b8Var\u00b9\ud835\udc4c\u00ba. (A.43)\n976 Mathematics for Deep Learning\nWithknowledgeofcovariances,wecanexpandthisrelationship. Indeed,somealgebracan\nshow that in general,\nVar\u00b9\ud835\udc4b\u00b8\ud835\udc4c\u00ba=Var\u00b9\ud835\udc4b\u00ba\u00b8Var\u00b9\ud835\udc4c\u00ba\u00b82Cov\u00b9\ud835\udc4b,\ud835\udc4c\u00ba. (A.44)\nThisallowsustogeneralizethevariancesummationruleforcorrelatedrandomvariables.\nCorrelation\nAs we did in the case of means and variances, let\u2019s now consider units. If \ud835\udc4bis measured in\noneunit(sayinches),and \ud835\udc4cismeasuredinanother(saydollars),thecovarianceismeasured\nintheproductofthesetwounitsinches \u0002dollars. Theseunitscanbehardtointerpret. What\nwe will often want in this case is a unit-less measurement of relatedness. Indeed, often we\ndo not care about exact quantitative correlation, but rather ask if the correlation is in the\nsame direction, and how strong the relationship is.\nTo see what makes sense, let\u2019s perform a thought experiment. Suppose that we convert\nour random variables in inches and dollars to be in inches and cents. In this case the ran-\ndom variable \ud835\udc4cis multiplied by 100. If we work through the definition, this means that\nCov\u00b9\ud835\udc4b,\ud835\udc4c\u00bawillbemultipliedby 100.", "mimetype": "text/plain", "start_char_idx": 2007763, "end_char_idx": 2010585, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "301fd21b-2537-4c8c-bacd-8ffbac02c176": {"__data__": {"id_": "301fd21b-2537-4c8c-bacd-8ffbac02c176", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c09c3d44-1be5-484c-9259-896c3446fdc6", "node_type": "1", "metadata": {}, "hash": "d074c83790d5ede76e9dff60137cd8b933e61c2837aba2240117bc62621b3e78", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3b94e476-ea17-4c7d-b7be-3cf188c9f020", "node_type": "1", "metadata": {}, "hash": "e7c5c2258dc279fd6213a9544908ea682dd7709bdabbeee49922718659804386", "class_name": "RelatedNodeInfo"}}, "text": "If \ud835\udc4bis measured in\noneunit(sayinches),and \ud835\udc4cismeasuredinanother(saydollars),thecovarianceismeasured\nintheproductofthesetwounitsinches \u0002dollars. Theseunitscanbehardtointerpret. What\nwe will often want in this case is a unit-less measurement of relatedness. Indeed, often we\ndo not care about exact quantitative correlation, but rather ask if the correlation is in the\nsame direction, and how strong the relationship is.\nTo see what makes sense, let\u2019s perform a thought experiment. Suppose that we convert\nour random variables in inches and dollars to be in inches and cents. In this case the ran-\ndom variable \ud835\udc4cis multiplied by 100. If we work through the definition, this means that\nCov\u00b9\ud835\udc4b,\ud835\udc4c\u00bawillbemultipliedby 100. Thusweseethatinthiscaseachangeofunitschange\nthe covariance by a factor of 100. Thus, to find our unit-invariant measure of correlation,\nwe will need to divide by something else that also gets scaled by 100. Indeed we have a\nclear candidate, the standard deviation! Indeed if we define the correlation coe\ufb00icient to\nbe\n\ud835\udf0c\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=Cov\u00b9\ud835\udc4b,\ud835\udc4c\u00ba\n\ud835\udf0e\ud835\udc4b\ud835\udf0e\ud835\udc4c, (A.45)\nwe see that this is a unit-less value. A little mathematics can show that this number is\nbetween\u00001and 1with 1meaning maximally positively correlated, whereas \u00001means\nmaximally negatively correlated.\nReturning to our explicit discrete example above, we can see that \ud835\udf0e\ud835\udc4b=1and\ud835\udf0e\ud835\udc4c=2,\nso we can compute the correlation between the two random variables using (A.45 )to see\nthat\n\ud835\udf0c\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=4\ud835\udc5d\u00002\n1\u00012=2\ud835\udc5d\u00001. (A.46)\nThisnowrangesbetween \u00001and1withtheexpectedbehaviorof 1meaningmostcorrelated,\nand\u00001meaning minimally correlated.\nAs another example, consider \ud835\udc4bas any random variable, and \ud835\udc4c=\ud835\udc4e\ud835\udc4b\u00b8\ud835\udc4fas any linear\ndeterministic function of \ud835\udc4b. Then, one can compute that\n\ud835\udf0e\ud835\udc4c=\ud835\udf0e\ud835\udc4e\ud835\udc4b\u00b8\ud835\udc4f=j\ud835\udc4ej\ud835\udf0e\ud835\udc4b, (A.47)\nCov\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=Cov\u00b9\ud835\udc4b,\ud835\udc4e\ud835\udc4b\u00b8\ud835\udc4f\u00ba=\ud835\udc4eCov\u00b9\ud835\udc4b,\ud835\udc4b\u00ba=\ud835\udc4eVar\u00b9\ud835\udc4b\u00ba, (A.48)\nand thus by (A.45 )that\n\ud835\udf0c\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=\ud835\udc4eVar\u00b9\ud835\udc4b\u00ba\nj\ud835\udc4ej\ud835\udf0e2\n\ud835\udc4b=\ud835\udc4e\nj\ud835\udc4ej=sign\u00b9\ud835\udc4e\u00ba. (A.49)\n977 Random Variables\nThus we see that the correlation is \u00b81for any\ud835\udc4e > 0, and\u00001for any\ud835\udc4e < 0illustrating that\ncorrelation measures the degree and directionality the two random variables are related,\nnot the scale that the variation takes.\nLet\u2019s again plot a collection of random variables with tunable correlation.\n# Plot a few random variables adjustable correlations\ncors =[-0.9,0.0,1.0]\nd2l.plt.figure(figsize =(12,3))\nfor iinrange (3):\nX=torch .randn( 500)\nY=cors[i] *X+torch .sqrt(torch .tensor( 1)-\ncors[i] **2)*torch .randn( 500)\nd2l.plt.subplot( 1,4, i +1)\nd2l.plt.scatter(X .numpy(), Y .numpy())\nd2l.plt.xlabel( 'X')\nd2l.plt.ylabel( 'Y')\nd2l.plt.title( f'cor = {cors[i] }')\nd2l.plt.show()\nLet\u2019s list a few properties of the correlation below.\n\u000fFor any random variable \ud835\udc4b,\ud835\udf0c\u00b9\ud835\udc4b,\ud835\udc4b\u00ba=1.", "mimetype": "text/plain", "start_char_idx": 2009872, "end_char_idx": 2012503, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3b94e476-ea17-4c7d-b7be-3cf188c9f020": {"__data__": {"id_": "3b94e476-ea17-4c7d-b7be-3cf188c9f020", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "301fd21b-2537-4c8c-bacd-8ffbac02c176", "node_type": "1", "metadata": {}, "hash": "0973d0f83f213b2990c664df1afe34fe79aac7235f714381fe7185cf5ca105df", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "db6a2667-cd4b-4de2-9c73-f827241a1433", "node_type": "1", "metadata": {}, "hash": "0260c8146dc1ef7f22ec2513aed104f9917896ca8a5625bb49b12ed269c6b70e", "class_name": "RelatedNodeInfo"}}, "text": "# Plot a few random variables adjustable correlations\ncors =[-0.9,0.0,1.0]\nd2l.plt.figure(figsize =(12,3))\nfor iinrange (3):\nX=torch .randn( 500)\nY=cors[i] *X+torch .sqrt(torch .tensor( 1)-\ncors[i] **2)*torch .randn( 500)\nd2l.plt.subplot( 1,4, i +1)\nd2l.plt.scatter(X .numpy(), Y .numpy())\nd2l.plt.xlabel( 'X')\nd2l.plt.ylabel( 'Y')\nd2l.plt.title( f'cor = {cors[i] }')\nd2l.plt.show()\nLet\u2019s list a few properties of the correlation below.\n\u000fFor any random variable \ud835\udc4b,\ud835\udf0c\u00b9\ud835\udc4b,\ud835\udc4b\u00ba=1.\n\u000fFor any random variables \ud835\udc4b,\ud835\udc4cand numbers \ud835\udc4eand\ud835\udc4f,\ud835\udf0c\u00b9\ud835\udc4e\ud835\udc4b\u00b8\ud835\udc4f,\ud835\udc4c\u00ba=\ud835\udf0c\u00b9\ud835\udc4b,\ud835\udc4e\ud835\udc4c\u00b8\ud835\udc4f\u00ba=\n\ud835\udf0c\u00b9\ud835\udc4b,\ud835\udc4c\u00ba.\n\u000fIf\ud835\udc4band\ud835\udc4care independent with non-zero variance then \ud835\udf0c\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=0.\nAsafinalnote, youmayfeellikesomeoftheseformulaearefamiliar. Indeed, ifweexpand\neverything out assuming that \ud835\udf07\ud835\udc4b=\ud835\udf07\ud835\udc4c=0, we see that this is\n\ud835\udf0c\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=\u00cd\n\ud835\udc56,\ud835\udc57\ud835\udc65\ud835\udc56\ud835\udc66\ud835\udc56\ud835\udc5d\ud835\udc56\ud835\udc57q\u00cd\n\ud835\udc56,\ud835\udc57\ud835\udc652\n\ud835\udc56\ud835\udc5d\ud835\udc56\ud835\udc57q\u00cd\n\ud835\udc56,\ud835\udc57\ud835\udc662\n\ud835\udc57\ud835\udc5d\ud835\udc56\ud835\udc57.(A.50)\nThis looks like a sum of a product of terms divided by the square root of sums of terms.\nThis is exactly the formula for the cosine of the angle between two vectors v,wwith the\n978 Mathematics for Deep Learning\ndifferent coordinates weighted by \ud835\udc5d\ud835\udc56\ud835\udc57:\ncos\u00b9\ud835\udf03\u00ba=v\u0001w\nkvkkwk=\u00cd\n\ud835\udc56\ud835\udc63\ud835\udc56\ud835\udc64\ud835\udc56q\u00cd\n\ud835\udc56\ud835\udc632\n\ud835\udc56q\u00cd\n\ud835\udc56\ud835\udc642\n\ud835\udc56.(A.51)\nIndeed if we think of norms as being related to standard deviations, and correlations as\nbeing cosines of angles, much of the intuition we have from geometry can be applied to\nthinking about random variables.\nA.6.2Summary\n\u000fContinuous random variables are random variables that can take on a continuum of val-\nues. They have some technical difficulties that make them more challenging to work\nwith compared to discrete random variables.\n\u000fThe probability density function allows us to work with continuous random variables by\ngivingafunctionwheretheareaunderthecurveonsomeintervalgivestheprobability\nof finding a sample point in that interval.\n\u000fThecumulativedistributionfunctionistheprobabilityofobservingtherandomvariable\nto be less than a given threshold. It can provide a useful alternate viewpoint which\nunifies discrete and continuous variables.\n\u000fThe mean is the average value of a random variable.\n\u000fThe variance is the expected square of the difference between the random variable and\nits mean.\n\u000fThe standard deviation is the square root of the variance. It can be thought of as mea-\nsuring the range of values the random variable may take.\n\u000fChebyshev\u2019s inequality allows us to make this intuition rigorous by giving an explicit\ninterval that contains the random variable most of the time.\n\u000fJoint densities allow us to work with correlated random variables. We may marginalize\njoint densities by integrating over unwanted random variables to get the distribution\nof the desired random variable.\n\u000fThe covariance and correlation coefficient provide a way to measure any linear relation-\nship between two correlated random variables.\nA.6.3Exercises\n1.Suppose that we have the random variable with density given by \ud835\udc5d\u00b9\ud835\udc65\u00ba=1\n\ud835\udc652for\ud835\udc65\u00151\nand\ud835\udc5d\u00b9\ud835\udc65\u00ba=0otherwise. What is \ud835\udc43\u00b9\ud835\udc4b > 2\u00ba?\n2.The Laplace distribution is a random variable whose density is given by \ud835\udc5d\u00b9\ud835\udc65=1\n2\ud835\udc52\u0000j\ud835\udc65j.", "mimetype": "text/plain", "start_char_idx": 2012030, "end_char_idx": 2014987, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "db6a2667-cd4b-4de2-9c73-f827241a1433": {"__data__": {"id_": "db6a2667-cd4b-4de2-9c73-f827241a1433", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3b94e476-ea17-4c7d-b7be-3cf188c9f020", "node_type": "1", "metadata": {}, "hash": "e7c5c2258dc279fd6213a9544908ea682dd7709bdabbeee49922718659804386", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7b6f05a9-b267-4aef-915f-e4e46339863a", "node_type": "1", "metadata": {}, "hash": "791e58f13942fd565e18a85f67ff660aa8f03c0aa7e1291c41b1259de5777ff1", "class_name": "RelatedNodeInfo"}}, "text": "\u000fChebyshev\u2019s inequality allows us to make this intuition rigorous by giving an explicit\ninterval that contains the random variable most of the time.\n\u000fJoint densities allow us to work with correlated random variables. We may marginalize\njoint densities by integrating over unwanted random variables to get the distribution\nof the desired random variable.\n\u000fThe covariance and correlation coefficient provide a way to measure any linear relation-\nship between two correlated random variables.\nA.6.3Exercises\n1.Suppose that we have the random variable with density given by \ud835\udc5d\u00b9\ud835\udc65\u00ba=1\n\ud835\udc652for\ud835\udc65\u00151\nand\ud835\udc5d\u00b9\ud835\udc65\u00ba=0otherwise. What is \ud835\udc43\u00b9\ud835\udc4b > 2\u00ba?\n2.The Laplace distribution is a random variable whose density is given by \ud835\udc5d\u00b9\ud835\udc65=1\n2\ud835\udc52\u0000j\ud835\udc65j.\nWhatisthemeanandthestandarddeviationofthisfunction? Asahint,\u00af1\n0\ud835\udc65\ud835\udc52\u0000\ud835\udc65\ud835\udc51\ud835\udc65=1\nand\u00af1\n0\ud835\udc652\ud835\udc52\u0000\ud835\udc65\ud835\udc51\ud835\udc65=2.\n979 Maximum Likelihood\n2853.I walk up to you on the street and say \u201cI have a random variable with mean 1, standard\ndeviation 2, and I observed 25%of my samples taking a value larger than 9.\u201d Do you\nbelieve me? Why or why not?\n4.Supposethatyouhavetworandomvariables \ud835\udc4b,\ud835\udc4c,withjointdensitygivenby \ud835\udc5d\ud835\udc4b\ud835\udc4c\u00b9\ud835\udc65,\ud835\udc66\u00ba=\n4\ud835\udc65\ud835\udc66for\ud835\udc65,\ud835\udc662\u00bb0,1\u00bcand\ud835\udc5d\ud835\udc4b\ud835\udc4c\u00b9\ud835\udc65,\ud835\udc66\u00ba=0otherwise. What is the covariance of \ud835\udc4band\ud835\udc4c?\nDiscussions285.\nA.7Maximum Likelihood\nOne of the most commonly encountered way of thinking in machine learning is the maxi-\nmum likelihood point of view. This is the concept that when working with a probabilistic\nmodel with unknown parameters, the parameters which make the data have the highest\nprobability are the most likely ones.\nA.7.1The Maximum LikelihoodPrinciple\nThis has a Bayesian interpretation which can be helpful to think about. Suppose that we\nhave a model with parameters \ud835\udf3dand a collection of data examples \ud835\udc4b. For concreteness, we\ncanimaginethat \ud835\udf3disasinglevaluerepresentingtheprobabilitythatacoincomesupheads\nwhen flipped, and \ud835\udc4bis a sequence of independent coin flips. We will look at this example\nin depth later.\nIf we want to find the most likely value for the parameters of our model, that means we\nwant to find\nargmax\ud835\udc43\u00b9\ud835\udf3dj\ud835\udc4b\u00ba. (A.1)\nBy Bayes\u2019 rule, this is the same thing as\nargmax\ud835\udc43\u00b9\ud835\udc4bj\ud835\udf3d\u00ba\ud835\udc43\u00b9\ud835\udf3d\u00ba\n\ud835\udc43\u00b9\ud835\udc4b\u00ba. (A.2)\nThe expression \ud835\udc43\u00b9\ud835\udc4b\u00ba, a parameter agnostic probability of generating the data, does not\ndepend on \ud835\udf3dat all, and so can be dropped without changing the best choice of \ud835\udf3d. Similarly,\nwe may now posit that we have no prior assumption on which set of parameters are better\nthan any others, so we may declare that \ud835\udc43\u00b9\ud835\udf3d\u00badoes not depend on theta either! This, for\ninstance,makessenseinourcoinflippingexamplewheretheprobabilityitcomesupheads\ncould be any value in \u00bb0,1\u00bcwithout any prior belief it is fair or not (often referred to as an\nuninformative prior ). Thus we see that our application of Bayes\u2019 rule shows that our best\nchoice of \ud835\udf3dis the maximum likelihood estimate for \ud835\udf3d:\n\u02c6\ud835\udf3d=argmax\n\ud835\udf3d\ud835\udc43\u00b9\ud835\udc4bj\ud835\udf3d\u00ba. (A.3)\nAsamatterofcommonterminology,theprobabilityofthedatagiventheparameters( \ud835\udc43\u00b9\ud835\udc4bj\n\ud835\udf3d\u00ba) is referred to as the likelihood .\n980 Mathematics for Deep Learning\nA ConcreteExample\nLet\u2019s see how this works in a concrete example. Suppose that we have a single parameter \ud835\udf03\nrepresenting the probability that a coin flip is heads.", "mimetype": "text/plain", "start_char_idx": 2014276, "end_char_idx": 2017383, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7b6f05a9-b267-4aef-915f-e4e46339863a": {"__data__": {"id_": "7b6f05a9-b267-4aef-915f-e4e46339863a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "db6a2667-cd4b-4de2-9c73-f827241a1433", "node_type": "1", "metadata": {}, "hash": "0260c8146dc1ef7f22ec2513aed104f9917896ca8a5625bb49b12ed269c6b70e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ecd926ac-f872-41fa-943e-baf9d6ffa683", "node_type": "1", "metadata": {}, "hash": "6af605a162bfa0c8e891eb932d3c03481452078a1d05f8093038117d89bcc00f", "class_name": "RelatedNodeInfo"}}, "text": "Thus we see that our application of Bayes\u2019 rule shows that our best\nchoice of \ud835\udf3dis the maximum likelihood estimate for \ud835\udf3d:\n\u02c6\ud835\udf3d=argmax\n\ud835\udf3d\ud835\udc43\u00b9\ud835\udc4bj\ud835\udf3d\u00ba. (A.3)\nAsamatterofcommonterminology,theprobabilityofthedatagiventheparameters( \ud835\udc43\u00b9\ud835\udc4bj\n\ud835\udf3d\u00ba) is referred to as the likelihood .\n980 Mathematics for Deep Learning\nA ConcreteExample\nLet\u2019s see how this works in a concrete example. Suppose that we have a single parameter \ud835\udf03\nrepresenting the probability that a coin flip is heads. Then the probability of getting a tails\nis1\u0000\ud835\udf03, and so if our observed data \ud835\udc4bis a sequence with \ud835\udc5b\ud835\udc3bheads and\ud835\udc5b\ud835\udc47tails, we can\nuse the fact that independent probabilities multiply to see that\n\ud835\udc43\u00b9\ud835\udc4bj\ud835\udf03\u00ba=\ud835\udf03\ud835\udc5b\ud835\udc3b\u00b91\u0000\ud835\udf03\u00ba\ud835\udc5b\ud835\udc47. (A.4)\nIf we flip 13coins and get the sequence \u201cHHHTHTTHHHHHT\u201d, which has \ud835\udc5b\ud835\udc3b=9and\n\ud835\udc5b\ud835\udc47=4, we see that this is\n\ud835\udc43\u00b9\ud835\udc4bj\ud835\udf03\u00ba=\ud835\udf039\u00b91\u0000\ud835\udf03\u00ba4. (A.5)\nOne nice thing about this example will be that we know the answer going in. Indeed, if\nwe said verbally, \u201cI flipped 13 coins, and 9 came up heads, what is our best guess for the\nprobabilitythatthecoincomesusheads?,\u201deveryonewouldcorrectlyguess 9\u009d13. Whatthis\nmaximum likelihood method will give us is a way to get that number from first principals\nin a way that will generalize to vastly more complex situations.\nFor our example, the plot of \ud835\udc43\u00b9\ud835\udc4bj\ud835\udf03\u00bais as follows:\n%matplotlib inline\nimport torch\nfrom d2l import torch asd2l\ntheta =torch .arange( 0,1,0.001 )\np=theta **9*(1-theta) **4.\nd2l.plot(theta, p, 'theta ','likelihood ')\nThis has its maximum value somewhere near our expected 9\u009d13\u00190.7.... To see if it\nis exactly there, we can turn to calculus. Notice that at the maximum, the gradient of the\nfunction is flat. Thus, we could find the maximum likelihood estimate (A.1)by finding\nthe values of \ud835\udf03where the derivative is zero, and finding the one that gives the highest\n981 Maximum Likelihood\nprobability. We compute:\n0=\ud835\udc51\n\ud835\udc51\ud835\udf03\ud835\udc43\u00b9\ud835\udc4bj\ud835\udf03\u00ba\n=\ud835\udc51\n\ud835\udc51\ud835\udf03\ud835\udf039\u00b91\u0000\ud835\udf03\u00ba4\n=9\ud835\udf038\u00b91\u0000\ud835\udf03\u00ba4\u00004\ud835\udf039\u00b91\u0000\ud835\udf03\u00ba3\n=\ud835\udf038\u00b91\u0000\ud835\udf03\u00ba3\u00b99\u000013\ud835\udf03\u00ba.(A.6)\nThis has three solutions: 0,1and9\u009d13. The first two are clearly minima, not maxima as\nthey assign probability 0to our sequence. The final value does notassign zero probability\nto our sequence, and thus must be the maximum likelihood estimate \u02c6\ud835\udf03=9\u009d13.\nA.7.2NumericalOptimizationand the NegativeLog-Likelihood\nThe previous example is nice, but what if we have billions of parameters and data exam-\nples?\nFirst, notice that if we make the assumption that all the data examples are independent, we\ncan no longer practically consider the likelihood itself as it is a product of many probabili-\nties. Indeed,eachprobabilityisin \u00bb0,1\u00bc,saytypicallyofvalueabout 1\u009d2,andtheproductof\n\u00b91\u009d2\u00ba1000000000is far below machine precision. We cannot work with that directly.\nHowever, recall that the logarithm turns products to sums, in which case\nlog\u00b9\u00b91\u009d2\u00ba1000000000\u00ba=1000000000\u0001log\u00b91\u009d2\u00ba\u0019\u0000 301029995.6... (A.7)\nThis number fits perfectly within even a single precision 32-bit float. Thus, we should\nconsider the log-likelihood , which is\nlog\u00b9\ud835\udc43\u00b9\ud835\udc4bj\ud835\udf3d\u00ba\u00ba.", "mimetype": "text/plain", "start_char_idx": 2016924, "end_char_idx": 2019842, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ecd926ac-f872-41fa-943e-baf9d6ffa683": {"__data__": {"id_": "ecd926ac-f872-41fa-943e-baf9d6ffa683", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7b6f05a9-b267-4aef-915f-e4e46339863a", "node_type": "1", "metadata": {}, "hash": "791e58f13942fd565e18a85f67ff660aa8f03c0aa7e1291c41b1259de5777ff1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "343413bd-0f8e-402c-83c4-c7a61d6f5022", "node_type": "1", "metadata": {}, "hash": "6611eeb5f647c16a5efb5cd0479ed864e9991926d48043d5ef714d62bc351078", "class_name": "RelatedNodeInfo"}}, "text": "First, notice that if we make the assumption that all the data examples are independent, we\ncan no longer practically consider the likelihood itself as it is a product of many probabili-\nties. Indeed,eachprobabilityisin \u00bb0,1\u00bc,saytypicallyofvalueabout 1\u009d2,andtheproductof\n\u00b91\u009d2\u00ba1000000000is far below machine precision. We cannot work with that directly.\nHowever, recall that the logarithm turns products to sums, in which case\nlog\u00b9\u00b91\u009d2\u00ba1000000000\u00ba=1000000000\u0001log\u00b91\u009d2\u00ba\u0019\u0000 301029995.6... (A.7)\nThis number fits perfectly within even a single precision 32-bit float. Thus, we should\nconsider the log-likelihood , which is\nlog\u00b9\ud835\udc43\u00b9\ud835\udc4bj\ud835\udf3d\u00ba\u00ba. (A.8)\nSince the function \ud835\udc657!log\u00b9\ud835\udc65\u00bais increasing, maximizing the likelihood is the same thing\nasmaximizingthelog-likelihood. Indeedin SectionA.9 wewillseethisreasoningapplied\nwhen working with the specific example of the naive Bayes classifier.\nWe often work with loss functions, where we wish to minimize the loss. We may turn\nmaximum likelihood into the minimization of a loss by taking \u0000log\u00b9\ud835\udc43\u00b9\ud835\udc4bj\ud835\udf3d\u00ba\u00ba, which is\nthenegativelog-likelihood .\nTo illustrate this, consider the coin flipping problem from before, and pretend that we do\nnot know the closed form solution. We may compute that\n\u0000log\u00b9\ud835\udc43\u00b9\ud835\udc4bj\ud835\udf3d\u00ba\u00ba=\u0000log\u00b9\ud835\udf03\ud835\udc5b\ud835\udc3b\u00b91\u0000\ud835\udf03\u00ba\ud835\udc5b\ud835\udc47\u00ba=\u0000\u00b9\ud835\udc5b\ud835\udc3blog\u00b9\ud835\udf03\u00ba\u00b8\ud835\udc5b\ud835\udc47log\u00b91\u0000\ud835\udf03\u00ba\u00ba. (A.9)\nThis can be written into code, and freely optimized even for billions of coin flips.\n# Set up our data\nn_H =8675309\nn_T =256245\n(continues on next page)\n982 Mathematics for Deep Learning\n(continued from previous page)\n# Initialize our paramteres\ntheta =torch .tensor( 0.5, requires_grad =True )\n# Perform gradient descent\nlr=1e-9\nfor iter inrange (100):\nloss =-(n_H *torch .log(theta) +n_T *torch .log( 1-theta))\nloss .backward()\nwith torch .no_grad():\ntheta -=lr*theta .grad\ntheta .grad .zero_()\n# Check output\ntheta, n_H /(n_H +n_T)\n(tensor( 0.9713 , requires_grad =True ),0.9713101437890875 )\nNumericalconvenienceisnottheonlyreasonwhypeopleliketousenegativelog-likelihoods.\nThere are several other reasons why it is preferable.\nThe second reason we consider the log-likelihood is the simplified application of calcu-\nlus rules. As discussed above, due to independence assumptions, most probabilities we\nencounter in machine learning are products of individual probabilities.\n\ud835\udc43\u00b9\ud835\udc4bj\ud835\udf3d\u00ba=\ud835\udc5d\u00b9\ud835\udc651j\ud835\udf3d\u00ba\u0001\ud835\udc5d\u00b9\ud835\udc652j\ud835\udf3d\u00ba\u0001\u0001\u0001\ud835\udc5d\u00b9\ud835\udc65\ud835\udc5bj\ud835\udf3d\u00ba. (A.10)\nThismeansthatifwedirectlyapplytheproductruletocomputeaderivativeweget\n\ud835\udf15\n\ud835\udf15\ud835\udf3d\ud835\udc43\u00b9\ud835\udc4bj\ud835\udf3d\u00ba=\u0012\ud835\udf15\n\ud835\udf15\ud835\udf3d\ud835\udc43\u00b9\ud835\udc651j\ud835\udf3d\u00ba\u0013\n\u0001\ud835\udc43\u00b9\ud835\udc652j\ud835\udf3d\u00ba\u0001\u0001\u0001\ud835\udc43\u00b9\ud835\udc65\ud835\udc5bj\ud835\udf3d\u00ba\n\u00b8\ud835\udc43\u00b9\ud835\udc651j\ud835\udf3d\u00ba\u0001\u0012\ud835\udf15\n\ud835\udf15\ud835\udf3d\ud835\udc43\u00b9\ud835\udc652j\ud835\udf3d\u00ba\u0013\n\u0001\u0001\u0001\ud835\udc43\u00b9\ud835\udc65\ud835\udc5bj\ud835\udf3d\u00ba\n...\n\u00b8\ud835\udc43\u00b9\ud835\udc651j\ud835\udf3d\u00ba\u0001\ud835\udc43\u00b9\ud835\udc652j\ud835\udf3d\u00ba\u0001\u0001\u0001\u0012\ud835\udf15\n\ud835\udf15\ud835\udf3d\ud835\udc43\u00b9\ud835\udc65\ud835\udc5bj\ud835\udf3d\u00ba\u0013\n.", "mimetype": "text/plain", "start_char_idx": 2019213, "end_char_idx": 2021693, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "343413bd-0f8e-402c-83c4-c7a61d6f5022": {"__data__": {"id_": "343413bd-0f8e-402c-83c4-c7a61d6f5022", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ecd926ac-f872-41fa-943e-baf9d6ffa683", "node_type": "1", "metadata": {}, "hash": "6af605a162bfa0c8e891eb932d3c03481452078a1d05f8093038117d89bcc00f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e662e19a-b809-472e-83d9-fadf8eb23e22", "node_type": "1", "metadata": {}, "hash": "be75027361442447762adc4425c67f530025d9bf8696e12e529e602516c95c97", "class_name": "RelatedNodeInfo"}}, "text": "(A.11)\nThis requires \ud835\udc5b\u00b9\ud835\udc5b\u00001\u00bamultiplications, along with \u00b9\ud835\udc5b\u00001\u00baadditions, so it is proportional\nto quadratic time in the inputs! Sufficient cleverness in grouping terms will reduce this\nto linear time, but it requires some thought. For the negative log-likelihood we have in-\nstead\n\u0000log\u00b9\ud835\udc43\u00b9\ud835\udc4bj\ud835\udf3d\u00ba\u00ba=\u0000log\u00b9\ud835\udc43\u00b9\ud835\udc651j\ud835\udf3d\u00ba\u00ba\u0000 log\u00b9\ud835\udc43\u00b9\ud835\udc652j\ud835\udf3d\u00ba\u00ba\u0001\u0001\u0001\u0000 log\u00b9\ud835\udc43\u00b9\ud835\udc65\ud835\udc5bj\ud835\udf3d\u00ba\u00ba,(A.12)\nwhich then gives\n\u0000\ud835\udf15\n\ud835\udf15\ud835\udf3dlog\u00b9\ud835\udc43\u00b9\ud835\udc4bj\ud835\udf3d\u00ba\u00ba=1\n\ud835\udc43\u00b9\ud835\udc651j\ud835\udf3d\u00ba\u0012\ud835\udf15\n\ud835\udf15\ud835\udf3d\ud835\udc43\u00b9\ud835\udc651j\ud835\udf3d\u00ba\u0013\n\u00b8\u0001\u0001\u0001\u00b81\n\ud835\udc43\u00b9\ud835\udc65\ud835\udc5bj\ud835\udf3d\u00ba\u0012\ud835\udf15\n\ud835\udf15\ud835\udf3d\ud835\udc43\u00b9\ud835\udc65\ud835\udc5bj\ud835\udf3d\u00ba\u0013\n.\n(A.13)\n983 Maximum Likelihood\nThis requires only \ud835\udc5bdivides and\ud835\udc5b\u00001sums, and thus is linear time in the inputs.\nThe third and final reason to consider the negative log-likelihood is the relationship to\ninformation theory, which we will discuss in detail in Section A.11 . This is a rigorous\nmathematicaltheorywhichgivesawaytomeasurethedegreeofinformationorrandomness\nin a random variable. The key object of study in that field is the entropy which is\n\ud835\udc3b\u00b9\ud835\udc5d\u00ba=\u0000\u00d5\n\ud835\udc56\ud835\udc5d\ud835\udc56log2\u00b9\ud835\udc5d\ud835\udc56\u00ba,(A.14)\nwhich measures the randomness of a source. Notice that this is nothing more than the av-\nerage\u0000logprobability, and thus if we take our negative log-likelihood and divide by the\nnumberofdataexamples,wegetarelativeofentropyknownascross-entropy. Thistheoret-\nicalinterpretationalonewouldbesufficientlycompellingtomotivatereportingtheaverage\nnegative log-likelihood over the dataset as a way of measuring model performance.\nA.7.3MaximumLikelihoodforContinuous Variables\nEverything that we have done so far assumes we are working with discrete random vari-\nables, but what if we want to work with continuous ones?\nThe short summary is that nothing at all changes, except we replace all the instances of the\nprobability with the probability density. Recalling that we write densities with lower case\n\ud835\udc5d, this means that for example we now say\n\u0000log\u00b9\ud835\udc5d\u00b9\ud835\udc4bj\ud835\udf3d\u00ba\u00ba=\u0000log\u00b9\ud835\udc5d\u00b9\ud835\udc651j\ud835\udf3d\u00ba\u00ba\u0000 log\u00b9\ud835\udc5d\u00b9\ud835\udc652j\ud835\udf3d\u00ba\u00ba\u0001\u0001\u0001\u0000 log\u00b9\ud835\udc5d\u00b9\ud835\udc65\ud835\udc5bj\ud835\udf3d\u00ba\u00ba=\u0000\u00d5\n\ud835\udc56log\u00b9\ud835\udc5d\u00b9\ud835\udc65\ud835\udc56j\ud835\udf03\u00ba\u00ba.\n(A.15)\nThequestionbecomes,\u201cWhyisthisOK?\u201dAfterall,thereasonweintroduceddensitieswas\nbecause probabilities of getting specific outcomes themselves was zero, and thus is not the\nprobability of generating our data for any set of parameters zero?\nIndeed, this is the case, and understanding why we can shift to densities is an exercise in\ntracing what happens to the epsilons.\nLet\u2019s first re-define our goal. Suppose that for continuous random variables we no longer\nwant to compute the probability of getting exactly the right value, but instead matching to\nwithinsomerange \ud835\udf16. Forsimplicity,weassumeourdataisrepeatedobservations \ud835\udc651,...,\ud835\udc65\ud835\udc41\nof identically distributed random variables \ud835\udc4b1,...,\ud835\udc4b\ud835\udc41.", "mimetype": "text/plain", "start_char_idx": 2021693, "end_char_idx": 2024200, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e662e19a-b809-472e-83d9-fadf8eb23e22": {"__data__": {"id_": "e662e19a-b809-472e-83d9-fadf8eb23e22", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "343413bd-0f8e-402c-83c4-c7a61d6f5022", "node_type": "1", "metadata": {}, "hash": "6611eeb5f647c16a5efb5cd0479ed864e9991926d48043d5ef714d62bc351078", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ddd0533f-4d6f-4b40-8c8e-06aad0b26729", "node_type": "1", "metadata": {}, "hash": "8da3b67f645b81398897fea688fc9d889674db674c7366e0de3f6787b8cd663e", "class_name": "RelatedNodeInfo"}}, "text": "(A.15)\nThequestionbecomes,\u201cWhyisthisOK?\u201dAfterall,thereasonweintroduceddensitieswas\nbecause probabilities of getting specific outcomes themselves was zero, and thus is not the\nprobability of generating our data for any set of parameters zero?\nIndeed, this is the case, and understanding why we can shift to densities is an exercise in\ntracing what happens to the epsilons.\nLet\u2019s first re-define our goal. Suppose that for continuous random variables we no longer\nwant to compute the probability of getting exactly the right value, but instead matching to\nwithinsomerange \ud835\udf16. Forsimplicity,weassumeourdataisrepeatedobservations \ud835\udc651,...,\ud835\udc65\ud835\udc41\nof identically distributed random variables \ud835\udc4b1,...,\ud835\udc4b\ud835\udc41. As we have seen previously, this\ncan be written as\n\ud835\udc43\u00b9\ud835\udc4b12\u00bb\ud835\udc651,\ud835\udc651\u00b8\ud835\udf16\u00bc,\ud835\udc4b22\u00bb\ud835\udc652,\ud835\udc652\u00b8\ud835\udf16\u00bc,...,\ud835\udc4b\ud835\udc412\u00bb\ud835\udc65\ud835\udc41,\ud835\udc65\ud835\udc41\u00b8\ud835\udf16\u00bcj\ud835\udf3d\u00ba\n\u0019\ud835\udf16\ud835\udc41\ud835\udc5d\u00b9\ud835\udc651j\ud835\udf3d\u00ba\u0001\ud835\udc5d\u00b9\ud835\udc652j\ud835\udf3d\u00ba\u0001\u0001\u0001\ud835\udc5d\u00b9\ud835\udc65\ud835\udc5bj\ud835\udf3d\u00ba.(A.16)\nThus, if we take negative logarithms of this we obtain\n\u0000log\u00b9\ud835\udc43\u00b9\ud835\udc4b12\u00bb\ud835\udc651,\ud835\udc651\u00b8\ud835\udf16\u00bc,\ud835\udc4b22\u00bb\ud835\udc652,\ud835\udc652\u00b8\ud835\udf16\u00bc,...,\ud835\udc4b\ud835\udc412\u00bb\ud835\udc65\ud835\udc41,\ud835\udc65\ud835\udc41\u00b8\ud835\udf16\u00bcj\ud835\udf3d\u00ba\u00ba\n\u0019\u0000\ud835\udc41log\u00b9\ud835\udf16\u00ba\u0000\u00d5\n\ud835\udc56log\u00b9\ud835\udc5d\u00b9\ud835\udc65\ud835\udc56j\ud835\udf3d\u00ba\u00ba.(A.17)\nIf we examine this expression, the only place that the \ud835\udf16occurs is in the additive constant\n984 Mathematics for Deep Learning\n286\u0000\ud835\udc41log\u00b9\ud835\udf16\u00ba. Thisdoesnotdependontheparameters \ud835\udf3datall,sotheoptimalchoiceof \ud835\udf3ddoes\nnot depend on our choice of \ud835\udf16! If we demand four digits or four-hundred, the best choice\nof\ud835\udf3dremains the same, thus we may freely drop the epsilon to see that what we want to\noptimize is\n\u0000\u00d5\n\ud835\udc56log\u00b9\ud835\udc5d\u00b9\ud835\udc65\ud835\udc56j\ud835\udf3d\u00ba\u00ba.(A.18)\nThus, we see that the maximum likelihood point of view can operate with continuous ran-\ndomvariablesaseasilyaswithdiscreteonesbyreplacingtheprobabilitieswithprobability\ndensities.\nA.7.4Summary\n\u000fThe maximum likelihood principle tells us that the best fit model for a given dataset is\nthe one that generates the data with the highest probability.\n\u000fOften people work with the negative log-likelihood instead for a variety of reasons: nu-\nmerical stability, conversion of products to sums (and the resulting simplification of\ngradient computations), and theoretical ties to information theory.\n\u000fWhile simplest to motivate in the discrete setting, it may be freely generalized to the\ncontinuous setting as well by maximizing the probability density assigned to the dat-\napoints.\nA.7.5Exercises\n1.Supposethatyouknowthatanon-negativerandomvariablehasdensity \ud835\udefc\ud835\udc52\u0000\ud835\udefc\ud835\udc65forsome\nvalue\ud835\udefc > 0. You obtain a single observation from the random variable which is the\nnumber 3. What is the maximum likelihood estimate for \ud835\udefc?\n2.Supposethatyouhaveadatasetofsamples f\ud835\udc65\ud835\udc56g\ud835\udc41\n\ud835\udc56=1drawnfromaGaussianwithunknown\nmean, but variance 1. What is the maximum likelihood estimate for the mean?\nDiscussions286.\nA.8Distributions\nNowthat wehavelearned howto workwith probability in both the discrete and the contin-\nuous setting, let\u2019s get to know some of the common distributions encountered. Depending\non the area of machine learning, we may need to be familiar with vastly more of these, or\nfor some areas of deep learning potentially none at all. This is, however, a good basic list\nto be familiar with. Let\u2019s first import some common libraries.", "mimetype": "text/plain", "start_char_idx": 2023511, "end_char_idx": 2026501, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ddd0533f-4d6f-4b40-8c8e-06aad0b26729": {"__data__": {"id_": "ddd0533f-4d6f-4b40-8c8e-06aad0b26729", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e662e19a-b809-472e-83d9-fadf8eb23e22", "node_type": "1", "metadata": {}, "hash": "be75027361442447762adc4425c67f530025d9bf8696e12e529e602516c95c97", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9da7d8dd-a5c2-41e7-91fd-c45ff98c7b56", "node_type": "1", "metadata": {}, "hash": "f52370c201085d0d25436082e32c38aff1eef63e122cae74a3d5a58b142d7f22", "class_name": "RelatedNodeInfo"}}, "text": "You obtain a single observation from the random variable which is the\nnumber 3. What is the maximum likelihood estimate for \ud835\udefc?\n2.Supposethatyouhaveadatasetofsamples f\ud835\udc65\ud835\udc56g\ud835\udc41\n\ud835\udc56=1drawnfromaGaussianwithunknown\nmean, but variance 1. What is the maximum likelihood estimate for the mean?\nDiscussions286.\nA.8Distributions\nNowthat wehavelearned howto workwith probability in both the discrete and the contin-\nuous setting, let\u2019s get to know some of the common distributions encountered. Depending\non the area of machine learning, we may need to be familiar with vastly more of these, or\nfor some areas of deep learning potentially none at all. This is, however, a good basic list\nto be familiar with. Let\u2019s first import some common libraries.\n985 Distributions\n%matplotlib inline\nfrom math import erf, factorial\nimport torch\nfrom IPython import display\nfrom d2l import torch asd2l\ntorch .pi=torch .acos(torch .zeros( 1))*2# Define pi in torch\nA.8.1Bernoulli\nThis is the simplest random variable usually encountered. This random variable encodes a\ncoin flip which comes up 1with probability \ud835\udc5dand0with probability 1\u0000\ud835\udc5d. If we have a\nrandom variable \ud835\udc4bwith this distribution, we will write\n\ud835\udc4b\u0018Bernoulli\u00b9\ud835\udc5d\u00ba. (A.1)\nThe cumulative distribution function is\n\ud835\udc39\u00b9\ud835\udc65\u00ba=8>>> <\n>>>:0\ud835\udc65 <0,\n1\u0000\ud835\udc5d0\u0014\ud835\udc65 <1,\n1\ud835\udc65 >=1.(A.2)\nThe probability mass function is plotted below.\np=0.3\nd2l.set_figsize()\nd2l.plt.stem([ 0,1], [ 1-p, p], use_line_collection =True )\nd2l.plt.xlabel( 'x')\nd2l.plt.ylabel( 'p.m.f. ')\nd2l.plt.show()\nNow, let\u2019s plot the cumulative distribution function (A.2).\nx=torch .arange( -1,2,0.01 )\ndef F(x):\nreturn 0ifx<0else 1ifx>1else 1-p\n(continues on next page)\n986 Mathematics for Deep Learning\n(continued from previous page)\nd2l.plot(x, torch .tensor([F(y) for yinx]), 'x','c.d.f. ')\nIf\ud835\udc4b\u0018Bernoulli\u00b9\ud835\udc5d\u00ba, then:\n\u000f\ud835\udf07\ud835\udc4b=\ud835\udc5d,\n\u000f\ud835\udf0e2\n\ud835\udc4b=\ud835\udc5d\u00b91\u0000\ud835\udc5d\u00ba.\nWecansampleanarrayofarbitraryshapefromaBernoullirandomvariableasfollows.\n1*(torch .rand( 10,10)<p)\ntensor([[ 0,1,0,0,1,0,0,0,0,0],\n[0,1,0,0,0,0,1,0,0,0],\n[0,1,0,0,1,0,0,0,0,1],\n[1,0,0,0,0,0,0,0,0,0],\n[0,0,0,1,0,0,1,0,0,1],\n[0,0,0,0,0,0,1,1,0,0],\n[1,1,0,0,1,1,1,1,1,0],\n[1,0,0,0,1,0,1,1,0,0],\n[0,0,0,0,1,0,0,0,0,0],\n[1,0,1,1,1,1,0,1,0,0]])\nA.8.2DiscreteUniform\nThenextcommonlyencounteredrandomvariableisadiscreteuniform. Forourdiscussion\nhere, we will assume that it is supported on the integers f1,2,...,\ud835\udc5bg, however any other\nset of values can be freely chosen. The meaning of the word uniform in this context is that\nevery possible value is equally likely. The probability for each value \ud835\udc562f1,2,3,...,\ud835\udc5bgis\n\ud835\udc5d\ud835\udc56=1\n\ud835\udc5b. We will denote a random variable \ud835\udc4bwith this distribution as\n\ud835\udc4b\u0018\ud835\udc48\u00b9\ud835\udc5b\u00ba.", "mimetype": "text/plain", "start_char_idx": 2025769, "end_char_idx": 2028356, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9da7d8dd-a5c2-41e7-91fd-c45ff98c7b56": {"__data__": {"id_": "9da7d8dd-a5c2-41e7-91fd-c45ff98c7b56", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ddd0533f-4d6f-4b40-8c8e-06aad0b26729", "node_type": "1", "metadata": {}, "hash": "8da3b67f645b81398897fea688fc9d889674db674c7366e0de3f6787b8cd663e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bb37f5af-3a6a-49fe-8ba2-c2cb54a9b40d", "node_type": "1", "metadata": {}, "hash": "1bfa1f27a7c247497a7d3ad262f8ead507b90164e1bf8559ac42d4f0d1ae6c16", "class_name": "RelatedNodeInfo"}}, "text": "Forourdiscussion\nhere, we will assume that it is supported on the integers f1,2,...,\ud835\udc5bg, however any other\nset of values can be freely chosen. The meaning of the word uniform in this context is that\nevery possible value is equally likely. The probability for each value \ud835\udc562f1,2,3,...,\ud835\udc5bgis\n\ud835\udc5d\ud835\udc56=1\n\ud835\udc5b. We will denote a random variable \ud835\udc4bwith this distribution as\n\ud835\udc4b\u0018\ud835\udc48\u00b9\ud835\udc5b\u00ba. (A.3)\n987 Distributions\nThe cumulative distribution function is\n\ud835\udc39\u00b9\ud835\udc65\u00ba=8>>> <\n>>>:0\ud835\udc65 <1,\n\ud835\udc58\n\ud835\udc5b\ud835\udc58\u0014\ud835\udc65 < \ud835\udc58\u00b81with 1\u0014\ud835\udc58 <\ud835\udc5b,\n1\ud835\udc65 >=\ud835\udc5b.(A.4)\nLet\u2019s first plot the probability mass function.\nn=5\nd2l.plt.stem([i +1for iinrange (n)], n *[1/n], use_line_collection =True )\nd2l.plt.xlabel( 'x')\nd2l.plt.ylabel( 'p.m.f. ')\nd2l.plt.show()\nNow, let\u2019s plot the cumulative distribution function (A.4).\nx=torch .arange( -1,6,0.01 )\ndef F(x):\nreturn 0ifx<1else 1ifx>nelse torch .floor(x) /n\nd2l.plot(x, torch .tensor([F(y) for yinx]), 'x','c.d.f. ')\nIf\ud835\udc4b\u0018\ud835\udc48\u00b9\ud835\udc5b\u00ba, then:\n\u000f\ud835\udf07\ud835\udc4b=1\u00b8\ud835\udc5b\n2,\n\u000f\ud835\udf0e2\n\ud835\udc4b=\ud835\udc5b2\u00001\n12.\n988 Mathematics for Deep Learning\nWe can sample an array of arbitrary shape from a discrete uniform random variable as\nfollows.\ntorch .randint( 1, n, size =(10,10))\ntensor([[ 1,4,3,2,1,1,3,1,1,4],\n[4,1,1,4,4,1,4,3,2,4],\n[2,4,4,1,4,2,4,3,2,1],\n[1,2,3,1,1,4,2,4,1,3],\n[1,2,4,1,4,3,3,2,2,1],\n[1,2,2,4,1,3,2,4,2,3],\n[1,2,3,4,1,3,4,1,4,3],\n[3,1,1,4,4,1,3,1,1,2],\n[2,2,4,3,4,2,3,4,2,4],\n[1,4,3,3,2,3,3,4,1,3]])\nA.8.3Continuous Uniform\nNext, let\u2019s discuss the continuous uniform distribution. The idea behind this random vari-\nable is that if we increase the \ud835\udc5bin the discrete uniform distribution, and then scale it to fit\nwithin the interval \u00bb\ud835\udc4e,\ud835\udc4f\u00bc, we will approach a continuous random variable that just picks\nan arbitrary value in \u00bb\ud835\udc4e,\ud835\udc4f\u00bcall with equal probability. We will denote this distribution\nas\n\ud835\udc4b\u0018\ud835\udc48\u00b9\ud835\udc4e,\ud835\udc4f\u00ba. (A.5)\nThe probability density function is\n\ud835\udc5d\u00b9\ud835\udc65\u00ba=(\n1\n\ud835\udc4f\u0000\ud835\udc4e\ud835\udc652\u00bb\ud835\udc4e,\ud835\udc4f\u00bc,\n0\ud835\udc65\u2209\u00bb\ud835\udc4e,\ud835\udc4f\u00bc.(A.6)\nThe cumulative distribution function is\n\ud835\udc39\u00b9\ud835\udc65\u00ba=8>>> <\n>>>:0\ud835\udc65 <\ud835\udc4e,\n\ud835\udc65\u0000\ud835\udc4e\n\ud835\udc4f\u0000\ud835\udc4e\ud835\udc652\u00bb\ud835\udc4e,\ud835\udc4f\u00bc,\n1\ud835\udc65 >=\ud835\udc4f.(A.7)\nLet\u2019s first plot the probability density function (A.6).\na, b =1,3\nx=torch .arange( 0,4,0.01 )\np=(x>a).type(torch .float32) *(x<b).type(torch .float32) /(b-a)\nd2l.plot(x, p, 'x','p.d.f. ')\nNow, let\u2019s plot the cumulative distribution function (A.7).", "mimetype": "text/plain", "start_char_idx": 2027994, "end_char_idx": 2030144, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bb37f5af-3a6a-49fe-8ba2-c2cb54a9b40d": {"__data__": {"id_": "bb37f5af-3a6a-49fe-8ba2-c2cb54a9b40d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9da7d8dd-a5c2-41e7-91fd-c45ff98c7b56", "node_type": "1", "metadata": {}, "hash": "f52370c201085d0d25436082e32c38aff1eef63e122cae74a3d5a58b142d7f22", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ec7edc44-8306-437c-9761-22cb6d782ced", "node_type": "1", "metadata": {}, "hash": "22bc0e13c972e463c571a0d573168fc89198f860626c8c072b731a4c29c0b6b0", "class_name": "RelatedNodeInfo"}}, "text": "(A.6)\nThe cumulative distribution function is\n\ud835\udc39\u00b9\ud835\udc65\u00ba=8>>> <\n>>>:0\ud835\udc65 <\ud835\udc4e,\n\ud835\udc65\u0000\ud835\udc4e\n\ud835\udc4f\u0000\ud835\udc4e\ud835\udc652\u00bb\ud835\udc4e,\ud835\udc4f\u00bc,\n1\ud835\udc65 >=\ud835\udc4f.(A.7)\nLet\u2019s first plot the probability density function (A.6).\na, b =1,3\nx=torch .arange( 0,4,0.01 )\np=(x>a).type(torch .float32) *(x<b).type(torch .float32) /(b-a)\nd2l.plot(x, p, 'x','p.d.f. ')\nNow, let\u2019s plot the cumulative distribution function (A.7).\n989 Distributions\ndef F(x):\nreturn 0ifx<aelse 1ifx>belse (x-a)/(b-a)\nd2l.plot(x, torch .tensor([F(y) for yinx]), 'x','c.d.f. ')\nIf\ud835\udc4b\u0018\ud835\udc48\u00b9\ud835\udc4e,\ud835\udc4f\u00ba, then:\n\u000f\ud835\udf07\ud835\udc4b=\ud835\udc4e\u00b8\ud835\udc4f\n2,\n\u000f\ud835\udf0e2\n\ud835\udc4b=\u00b9\ud835\udc4f\u0000\ud835\udc4e\u00ba2\n12.\nWecansampleanarrayofarbitraryshapefromauniformrandomvariableasfollows. Note\nthat it by default samples from a \ud835\udc48\u00b90,1\u00ba, so if we want a different range we need to scale\nit.\n(b-a)*torch .rand( 10,10)+a\ntensor([[ 2.4857 ,2.2461 ,1.6809 ,2.7434 ,2.7072 ,2.6190 ,1.4883 ,1.2517 ,1.\n\u21a9!3454 ,\n2.4754 ],\n[1.0974 ,1.5680 ,1.8788 ,2.8231 ,2.1695 ,2.6461 ,1.4914 ,1.4887 ,1.\n\u21a9!3860 ,\n1.9090 ],\n[1.3746 ,1.7773 ,1.2412 ,1.1950 ,2.7281 ,2.8356 ,1.2266 ,2.4724 ,2.\n\u21a9!4641 ,\n2.8991 ],\n[2.4018 ,2.6727 ,1.0308 ,1.1951 ,1.9390 ,1.6486 ,2.8314 ,1.1025 ,1.\n(continues on next page)\n990 Mathematics for Deep Learning\n(continued from previous page)\n\u21a9!3354 ,\n1.0130 ],\n[1.1281 ,1.8000 ,2.3788 ,2.6580 ,1.6750 ,2.2081 ,1.2705 ,1.0757 ,2.\n\u21a9!3311 ,\n2.6557 ],\n[2.9912 ,1.2263 ,1.8115 ,1.5940 ,1.9321 ,1.6469 ,2.2990 ,2.1473 ,1.\n\u21a9!8165 ,\n1.2806 ],\n[1.1672 ,1.1536 ,1.9649 ,2.1655 ,1.7170 ,1.0284 ,1.3305 ,2.1904 ,1.\n\u21a9!4036 ,\n2.1958 ],\n[2.5891 ,2.5840 ,2.2679 ,2.0687 ,2.9249 ,1.6741 ,1.2238 ,2.4463 ,2.\n\u21a9!2235 ,\n2.7038 ],\n[1.8697 ,2.4965 ,1.5785 ,2.7890 ,2.3319 ,2.1434 ,2.3333 ,1.0286 ,1.\n\u21a9!9245 ,\n1.7640 ],\n[1.2504 ,1.7558 ,1.4322 ,1.5226 ,1.3380 ,1.1388 ,1.8707 ,2.2330 ,2.\n\u21a9!3818 ,\n2.2087 ]])\nA.8.4Binomial\nLet\u2019s make things a little more complex and examine the binomial random variable. This\nrandomvariableoriginatesfromperformingasequenceof \ud835\udc5bindependentexperiments,each\nof which has probability \ud835\udc5dof succeeding, and asking how many successes we expect to\nsee.\nLet\u2019s express this mathematically. Each experiment is an independent random variable \ud835\udc4b\ud835\udc56\nwherewewilluse 1toencodesuccess,and 0toencodefailure.", "mimetype": "text/plain", "start_char_idx": 2029798, "end_char_idx": 2031898, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ec7edc44-8306-437c-9761-22cb6d782ced": {"__data__": {"id_": "ec7edc44-8306-437c-9761-22cb6d782ced", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bb37f5af-3a6a-49fe-8ba2-c2cb54a9b40d", "node_type": "1", "metadata": {}, "hash": "1bfa1f27a7c247497a7d3ad262f8ead507b90164e1bf8559ac42d4f0d1ae6c16", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "69d531e3-c4bd-47e5-a5e4-45ce031b5a52", "node_type": "1", "metadata": {}, "hash": "397887058030b1a33035bad93cb75b15b941e5bea13fea575471f3cb62511f3b", "class_name": "RelatedNodeInfo"}}, "text": "\u21a9!9245 ,\n1.7640 ],\n[1.2504 ,1.7558 ,1.4322 ,1.5226 ,1.3380 ,1.1388 ,1.8707 ,2.2330 ,2.\n\u21a9!3818 ,\n2.2087 ]])\nA.8.4Binomial\nLet\u2019s make things a little more complex and examine the binomial random variable. This\nrandomvariableoriginatesfromperformingasequenceof \ud835\udc5bindependentexperiments,each\nof which has probability \ud835\udc5dof succeeding, and asking how many successes we expect to\nsee.\nLet\u2019s express this mathematically. Each experiment is an independent random variable \ud835\udc4b\ud835\udc56\nwherewewilluse 1toencodesuccess,and 0toencodefailure. Sinceeachisanindependent\ncoin flip which is successful with probability \ud835\udc5d, we can say that \ud835\udc4b\ud835\udc56\u0018Bernoulli\u00b9\ud835\udc5d\u00ba. Then,\nthe binomial random variable is\n\ud835\udc4b=\ud835\udc5b\u00d5\n\ud835\udc56=1\ud835\udc4b\ud835\udc56. (A.8)\nIn this case, we will write\n\ud835\udc4b\u0018Binomial\u00b9\ud835\udc5b,\ud835\udc5d\u00ba. (A.9)\nTo get the cumulative distribution function, we need to notice that getting exactly \ud835\udc58suc-\ncesses can occur in\u0000\ud835\udc5b\n\ud835\udc58\u0001=\ud835\udc5b!\n\ud835\udc58!\u00b9\ud835\udc5b\u0000\ud835\udc58\u00ba!ways each of which has a probability of \ud835\udc5d\ud835\udc58\u00b91\u0000\ud835\udc5d\u00ba\ud835\udc5b\u0000\ud835\udc58\nof occurring. Thus the cumulative distribution function is\n\ud835\udc39\u00b9\ud835\udc65\u00ba=8>>> <\n>>>:0 \ud835\udc65 <0,\n\u00cd\n\ud835\udc5a\u0014\ud835\udc58\u0000\ud835\udc5b\n\ud835\udc5a\u0001\ud835\udc5d\ud835\udc5a\u00b91\u0000\ud835\udc5d\u00ba\ud835\udc5b\u0000\ud835\udc5a\ud835\udc58\u0014\ud835\udc65 < \ud835\udc58\u00b81with 0\u0014\ud835\udc58 <\ud835\udc5b,\n1 \ud835\udc65 >=\ud835\udc5b.(A.10)\nLet\u2019s first plot the probability mass function.\n991 Distributions\nn, p =10,0.2\n# Compute binomial coefficient\ndef binom (n, k):\ncomb =1\nfor iinrange (min(k, n -k)):\ncomb =comb *(n-i)//(i+1)\nreturn comb\npmf =torch .tensor([p **i*(1-p)**(n-i)*binom(n, i) for iinrange (n+1)])\nd2l.plt.stem([i for iinrange (n+1)], pmf, use_line_collection =True )\nd2l.plt.xlabel( 'x')\nd2l.plt.ylabel( 'p.m.f. ')\nd2l.plt.show()\nNow, let\u2019s plot the cumulative distribution function (A.10 ).\nx=torch .arange( -1,11,0.01 )\ncmf =torch .cumsum(pmf, dim =0)\ndef F(x):\nreturn 0ifx<0else 1ifx>nelse cmf[ int(x)]\nd2l.plot(x, torch .tensor([F(y) for yinx.tolist()]), 'x','c.d.f. ')\nIf\ud835\udc4b\u0018Binomial\u00b9\ud835\udc5b,\ud835\udc5d\u00ba, then:\n\u000f\ud835\udf07\ud835\udc4b=\ud835\udc5b\ud835\udc5d,\n992 Mathematics for Deep Learning\n\u000f\ud835\udf0e2\n\ud835\udc4b=\ud835\udc5b\ud835\udc5d\u00b91\u0000\ud835\udc5d\u00ba.\nThis follows from the linearity of expected value over the sum of \ud835\udc5bBernoulli random vari-\nables, and the fact that the variance of the sum of independent random variables is the sum\nof the variances. This can be sampled as follows.\nm=torch .distributions .binomial .Binomial(n, p)\nm.sample(sample_shape =(10,10))\ntensor([[ 6.,3.,4.,3.,3.,1.,3.,3.,3.,3.],\n[3.,1.,2.,2.,3.,2.,1.,3.,1.,4.],\n[6.,1.,0.,3.,0.,3.,1.,0.,1.,1.],\n[1.,2.,3.,1.,2.,2.,2.,2.,3.,2.],\n[2.,2.,5.,4.,1.,3.,4.,3.,2.,0.],\n[2.,0.,2.,2.,3.,1.,1.,4.,3.,1.],\n[1.,1.,3.,2.,4.,2.,2.,2.,1.,0.", "mimetype": "text/plain", "start_char_idx": 2031381, "end_char_idx": 2033714, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "69d531e3-c4bd-47e5-a5e4-45ce031b5a52": {"__data__": {"id_": "69d531e3-c4bd-47e5-a5e4-45ce031b5a52", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ec7edc44-8306-437c-9761-22cb6d782ced", "node_type": "1", "metadata": {}, "hash": "22bc0e13c972e463c571a0d573168fc89198f860626c8c072b731a4c29c0b6b0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b491f6ec-c51c-48dd-bf90-c4285ad5bb24", "node_type": "1", "metadata": {}, "hash": "a5308da9a0e7104c6a52050b049f261107d5226cc03018461dd6c6c892d425f5", "class_name": "RelatedNodeInfo"}}, "text": "This can be sampled as follows.\nm=torch .distributions .binomial .Binomial(n, p)\nm.sample(sample_shape =(10,10))\ntensor([[ 6.,3.,4.,3.,3.,1.,3.,3.,3.,3.],\n[3.,1.,2.,2.,3.,2.,1.,3.,1.,4.],\n[6.,1.,0.,3.,0.,3.,1.,0.,1.,1.],\n[1.,2.,3.,1.,2.,2.,2.,2.,3.,2.],\n[2.,2.,5.,4.,1.,3.,4.,3.,2.,0.],\n[2.,0.,2.,2.,3.,1.,1.,4.,3.,1.],\n[1.,1.,3.,2.,4.,2.,2.,2.,1.,0.],\n[0.,3.,2.,1.,1.,3.,2.,1.,1.,3.],\n[2.,3.,2.,3.,4.,3.,1.,2.,1.,2.],\n[1.,2.,1.,1.,3.,2.,4.,3.,3.,2.]])\nA.8.5Poisson\nLet\u2019s now perform a thought experiment. We are standing at a bus stop and we want to\nknow how many buses will arrive in the next minute. Let\u2019s start by considering \ud835\udc4b\u00b91\u00ba\u0018\nBernoulli\u00b9\ud835\udc5d\u00bawhich is simply the probability that a bus arrives in the one minute window.\nForbusstopsfarfromanurbancenter, thismightbeaprettygoodapproximation. Wemay\nnever see more than one bus in a minute.\nHowever, if we are in a busy area, it is possible or even likely that two buses will arrive.\nWe can model this by splitting our random variable into two parts for the first 30 seconds,\nor the second 30 seconds. In this case we can write\n\ud835\udc4b\u00b92\u00ba\u0018\ud835\udc4b\u00b92\u00ba\n1\u00b8\ud835\udc4b\u00b92\u00ba\n2, (A.11)\nwhere\ud835\udc4b\u00b92\u00bais the total sum, and \ud835\udc4b\u00b92\u00ba\n\ud835\udc56\u0018Bernoulli\u00b9\ud835\udc5d\u009d2\u00ba. The total distribution is then\n\ud835\udc4b\u00b92\u00ba\u0018Binomial\u00b92,\ud835\udc5d\u009d2\u00ba.\nWhy stop here? Let\u2019s continue to split that minute into \ud835\udc5bparts. By the same reasoning as\nabove, we see that\n\ud835\udc4b\u00b9\ud835\udc5b\u00ba\u0018Binomial\u00b9\ud835\udc5b,\ud835\udc5d\u009d\ud835\udc5b\u00ba. (A.12)\nConsider these random variables. By the previous section, we know that (A.12 )has mean\n\ud835\udf07\ud835\udc4b\u00b9\ud835\udc5b\u00ba=\ud835\udc5b\u00b9\ud835\udc5d\u009d\ud835\udc5b\u00ba=\ud835\udc5d, and variance \ud835\udf0e2\n\ud835\udc4b\u00b9\ud835\udc5b\u00ba=\ud835\udc5b\u00b9\ud835\udc5d\u009d\ud835\udc5b\u00ba\u00b91\u0000\u00b9\ud835\udc5d\u009d\ud835\udc5b\u00ba\u00ba=\ud835\udc5d\u00b91\u0000\ud835\udc5d\u009d\ud835\udc5b\u00ba. If we take\n\ud835\udc5b!1,wecanseethatthesenumbersstabilizeto \ud835\udf07\ud835\udc4b\u00b91\u00ba=\ud835\udc5d,andvariance \ud835\udf0e2\n\ud835\udc4b\u00b91\u00ba=\ud835\udc5d. This\nindicatesthatthere couldbe somerandomvariablewecandefineinthisinfinitesubdivision\nlimit.\nThis should not come as too much of a surprise, since in the real world we can just count\n993 Distributions\nthe number of bus arrivals, however it is nice to see that our mathematical model is well\ndefined. This discussion can be made formal as the lawof rareevents .\nFollowing through this reasoning carefully, we can arrive at the following model. We will\nsay that\ud835\udc4b\u0018Poisson\u00b9\ud835\udf06\u00baif it is a random variable which takes the values f0,1,2,...gwith\nprobability\n\ud835\udc5d\ud835\udc58=\ud835\udf06\ud835\udc58\ud835\udc52\u0000\ud835\udf06\n\ud835\udc58!. (A.13)\nThe value\ud835\udf06 > 0is known as the rate(or theshapeparameter), and denotes the average\nnumber of arrivals we expect in one unit of time.\nWemaysumthisprobabilitymassfunctiontogetthecumulativedistributionfunction.", "mimetype": "text/plain", "start_char_idx": 2033364, "end_char_idx": 2035722, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b491f6ec-c51c-48dd-bf90-c4285ad5bb24": {"__data__": {"id_": "b491f6ec-c51c-48dd-bf90-c4285ad5bb24", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "69d531e3-c4bd-47e5-a5e4-45ce031b5a52", "node_type": "1", "metadata": {}, "hash": "397887058030b1a33035bad93cb75b15b941e5bea13fea575471f3cb62511f3b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8c830307-442a-4d3f-8518-19e377dcaabf", "node_type": "1", "metadata": {}, "hash": "6b2d451393f047dc316e611e3d59551e2fa388f86ad9c68105fed99cb8839877", "class_name": "RelatedNodeInfo"}}, "text": "This should not come as too much of a surprise, since in the real world we can just count\n993 Distributions\nthe number of bus arrivals, however it is nice to see that our mathematical model is well\ndefined. This discussion can be made formal as the lawof rareevents .\nFollowing through this reasoning carefully, we can arrive at the following model. We will\nsay that\ud835\udc4b\u0018Poisson\u00b9\ud835\udf06\u00baif it is a random variable which takes the values f0,1,2,...gwith\nprobability\n\ud835\udc5d\ud835\udc58=\ud835\udf06\ud835\udc58\ud835\udc52\u0000\ud835\udf06\n\ud835\udc58!. (A.13)\nThe value\ud835\udf06 > 0is known as the rate(or theshapeparameter), and denotes the average\nnumber of arrivals we expect in one unit of time.\nWemaysumthisprobabilitymassfunctiontogetthecumulativedistributionfunction.\n\ud835\udc39\u00b9\ud835\udc65\u00ba=(\n0 \ud835\udc65 <0,\n\ud835\udc52\u0000\ud835\udf06\u00cd\ud835\udc58\n\ud835\udc5a=0\ud835\udf06\ud835\udc5a\n\ud835\udc5a!\ud835\udc58\u0014\ud835\udc65 < \ud835\udc58\u00b81with 0\u0014\ud835\udc58.(A.14)\nLet\u2019s first plot the probability mass function (A.13 ).\nlam =5.0\nxs=[ifor iinrange (20)]\npmf =torch .tensor([torch .exp(torch .tensor( -lam)) *lam**k\n/factorial(k) for kinxs])\nd2l.plt.stem(xs, pmf, use_line_collection =True )\nd2l.plt.xlabel( 'x')\nd2l.plt.ylabel( 'p.m.f. ')\nd2l.plt.show()\nNow, let\u2019s plot the cumulative distribution function (A.14 ).\nx=torch .arange( -1,21,0.01 )\ncmf =torch .cumsum(pmf, dim =0)\ndef F(x):\nreturn 0ifx<0else 1ifx>nelse cmf[ int(x)]\nd2l.plot(x, torch .tensor([F(y) for yinx.tolist()]), 'x','c.d.f. ')\nAs we saw above, the means and variances are particularly concise. If \ud835\udc4b\u0018Poisson\u00b9\ud835\udf06\u00ba,\nthen:\n994 Mathematics for Deep Learning\n\u000f\ud835\udf07\ud835\udc4b=\ud835\udf06,\n\u000f\ud835\udf0e2\n\ud835\udc4b=\ud835\udf06.\nThis can be sampled as follows.\nm=torch .distributions .poisson .Poisson(lam)\nm.sample(( 10,10))\ntensor([[ 1.,4.,6.,8.,4.,4.,4.,7.,6.,4.],\n[3.,6.,7.,7.,5.,7.,7.,3.,5.,4.],\n[4.,1.,3.,3.,10.,5.,5.,3.,7.,5.],\n[4.,3.,4.,10.,8.,6.,4.,6.,5.,5.],\n[5.,11.,1.,5.,7.,5.,2.,4.,3.,5.],\n[6.,6.,4.,4.,3.,1.,5.,8.,4.,5.],\n[2.,9.,7.,2.,6.,5.,2.,8.,6.,10.],\n[1.,4.,3.,7.,3.,1.,7.,5.,3.,6.],\n[5.,4.,6.,4.,9.,8.,3.,3.,1.,8.],\n[3.,12.,9.,13.,2.,14.,3.,2.,0.,3.]])\nA.8.6Gaussian\nNow Let\u2019s try a different, but related experiment. Let\u2019s say we again are performing \ud835\udc5b\nindependentBernoulli \u00b9\ud835\udc5d\u00bameasurements \ud835\udc4b\ud835\udc56. Thedistributionofthesumoftheseis \ud835\udc4b\u00b9\ud835\udc5b\u00ba\u0018\nBinomial\u00b9\ud835\udc5b,\ud835\udc5d\u00ba. Rather than taking a limit as \ud835\udc5bincreases and \ud835\udc5ddecreases, Let\u2019s fix \ud835\udc5d, and\nthen send\ud835\udc5b!1. In this case \ud835\udf07\ud835\udc4b\u00b9\ud835\udc5b\u00ba=\ud835\udc5b\ud835\udc5d!1and\ud835\udf0e2\n\ud835\udc4b\u00b9\ud835\udc5b\u00ba=\ud835\udc5b\ud835\udc5d\u00b91\u0000\ud835\udc5d\u00ba!1, so there is\nno reason to think this limit should be well defined.\nHowever, not all hope is lost!", "mimetype": "text/plain", "start_char_idx": 2035040, "end_char_idx": 2037319, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8c830307-442a-4d3f-8518-19e377dcaabf": {"__data__": {"id_": "8c830307-442a-4d3f-8518-19e377dcaabf", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b491f6ec-c51c-48dd-bf90-c4285ad5bb24", "node_type": "1", "metadata": {}, "hash": "a5308da9a0e7104c6a52050b049f261107d5226cc03018461dd6c6c892d425f5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "03c5ef62-ab3c-4f85-b9bf-0c7215985ac1", "node_type": "1", "metadata": {}, "hash": "48bd25e71d49374a4b5c624327aa1008281bd647975260eddda3f4d3d890dc50", "class_name": "RelatedNodeInfo"}}, "text": "A.8.6Gaussian\nNow Let\u2019s try a different, but related experiment. Let\u2019s say we again are performing \ud835\udc5b\nindependentBernoulli \u00b9\ud835\udc5d\u00bameasurements \ud835\udc4b\ud835\udc56. Thedistributionofthesumoftheseis \ud835\udc4b\u00b9\ud835\udc5b\u00ba\u0018\nBinomial\u00b9\ud835\udc5b,\ud835\udc5d\u00ba. Rather than taking a limit as \ud835\udc5bincreases and \ud835\udc5ddecreases, Let\u2019s fix \ud835\udc5d, and\nthen send\ud835\udc5b!1. In this case \ud835\udf07\ud835\udc4b\u00b9\ud835\udc5b\u00ba=\ud835\udc5b\ud835\udc5d!1and\ud835\udf0e2\n\ud835\udc4b\u00b9\ud835\udc5b\u00ba=\ud835\udc5b\ud835\udc5d\u00b91\u0000\ud835\udc5d\u00ba!1, so there is\nno reason to think this limit should be well defined.\nHowever, not all hope is lost! Let\u2019s just make the mean and variance be well behaved by\ndefining\n\ud835\udc4c\u00b9\ud835\udc5b\u00ba=\ud835\udc4b\u00b9\ud835\udc5b\u00ba\u0000\ud835\udf07\ud835\udc4b\u00b9\ud835\udc5b\u00ba\n\ud835\udf0e\ud835\udc4b\u00b9\ud835\udc5b\u00ba. (A.15)\nThis can be seen to have mean zero and variance one, and so it is plausible to believe that\nit will converge to some limiting distribution. If we plot what these distributions look like,\nwe will become even more convinced that it will work.\n995 Distributions\np=0.2\nns=[1,10,100,1000 ]\nd2l.plt.figure(figsize =(10,3))\nfor iinrange (4):\nn=ns[i]\npmf =torch .tensor([p **i*(1-p)**(n-i)*binom(n, i)\nfor iinrange (n+1)])\nd2l.plt.subplot( 1,4, i +1)\nd2l.plt.stem([(i -n*p)/torch .sqrt(torch .tensor(n *p*(1-p)))\nfor iinrange (n+1)], pmf,\nuse_line_collection =True )\nd2l.plt.xlim([ -4,4])\nd2l.plt.xlabel( 'x')\nd2l.plt.ylabel( 'p.m.f. ')\nd2l.plt.title( \"n = {}\".format(n))\nd2l.plt.show()\nOne thing to note: compared to the Poisson case, we are now dividing by the standard de-\nviation which means that we are squeezing the possible outcomes into smaller and smaller\nareas. This is an indication that our limit will no longer be discrete, but rather continu-\nous.\nA derivation of what occurs is beyond the scope of this document, but the central limit\ntheorem states that as \ud835\udc5b!1, this will yield the Gaussian Distribution (or sometimes\nnormal distribution). More explicitly, for any \ud835\udc4e,\ud835\udc4f:\nlim\n\ud835\udc5b!1\ud835\udc43\u00b9\ud835\udc4c\u00b9\ud835\udc5b\u00ba2\u00bb\ud835\udc4e,\ud835\udc4f\u00bc\u00ba=\ud835\udc43\u00b9N\u00b90,1\u00ba2\u00bb\ud835\udc4e,\ud835\udc4f\u00bc\u00ba, (A.16)\nwhere we say a random variable is normally distributed with given mean \ud835\udf07and variance\n\ud835\udf0e2, written\ud835\udc4b\u0018N\u00b9\ud835\udf07,\ud835\udf0e2\u00baif\ud835\udc4bhas density\n\ud835\udc5d\ud835\udc4b\u00b9\ud835\udc65\u00ba=1p\n2\ud835\udf0b\ud835\udf0e2\ud835\udc52\u0000\u00b9\ud835\udc65\u0000\ud835\udf07\u00ba2\n2\ud835\udf0e2. (A.17)\nLet\u2019s first plot the probability density function (A.17 ).\nmu, sigma =0,1\n(continues on next page)\n996 Mathematics for Deep Learning\n(continued from previous page)\nx=torch .arange( -3,3,0.01 )\np=1/torch .sqrt( 2*torch .pi*sigma **2)*torch .exp(\n-(x-mu)**2/(2*sigma **2))\nd2l.plot(x, p, 'x','p.d.f. ')\nNow, let\u2019s plot the cumulative distribution function. It is beyond the scope of this ap-\npendix, but the Gaussian c.d.f. does not have a closed-form formula in terms of more\nelementary functions. We will use erfwhich provides a way to compute this integral nu-\nmerically.\ndef phi(x):\nreturn (1.0 +erf((x -mu) /(sigma *torch .sqrt(torch .tensor( 2.))))) /2.0\nd2l.plot(x, torch .tensor([phi(y) for yinx.tolist()]), 'x','c.d.f. ')\nKeen-eyedreaderswillrecognizesomeoftheseterms.", "mimetype": "text/plain", "start_char_idx": 2036894, "end_char_idx": 2039568, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "03c5ef62-ab3c-4f85-b9bf-0c7215985ac1": {"__data__": {"id_": "03c5ef62-ab3c-4f85-b9bf-0c7215985ac1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8c830307-442a-4d3f-8518-19e377dcaabf", "node_type": "1", "metadata": {}, "hash": "6b2d451393f047dc316e611e3d59551e2fa388f86ad9c68105fed99cb8839877", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7c5184c0-325c-4446-9858-838d5a636993", "node_type": "1", "metadata": {}, "hash": "ec942bd68dcd4dc89e8cea69fb6ed9dac938dc4eed2a3e071548893613b3d430", "class_name": "RelatedNodeInfo"}}, "text": "Now, let\u2019s plot the cumulative distribution function. It is beyond the scope of this ap-\npendix, but the Gaussian c.d.f. does not have a closed-form formula in terms of more\nelementary functions. We will use erfwhich provides a way to compute this integral nu-\nmerically.\ndef phi(x):\nreturn (1.0 +erf((x -mu) /(sigma *torch .sqrt(torch .tensor( 2.))))) /2.0\nd2l.plot(x, torch .tensor([phi(y) for yinx.tolist()]), 'x','c.d.f. ')\nKeen-eyedreaderswillrecognizesomeoftheseterms. Indeed,weencounteredthisintegral\ninSection A.5 . Indeed we need exactly that computation to see that this \ud835\udc5d\ud835\udc4b\u00b9\ud835\udc65\u00bahas total\narea one and is thus a valid density.\nOur choice of working with coin flips made computations shorter, but nothing about that\nchoice was fundamental. Indeed, if we take any collection of independent identically dis-\ntributed random variables \ud835\udc4b\ud835\udc56, and form\n\ud835\udc4b\u00b9\ud835\udc41\u00ba=\ud835\udc41\u00d5\n\ud835\udc56=1\ud835\udc4b\ud835\udc56. (A.18)\n997 Distributions\nThen\n\ud835\udc4b\u00b9\ud835\udc41\u00ba\u0000\ud835\udf07\ud835\udc4b\u00b9\ud835\udc41\u00ba\n\ud835\udf0e\ud835\udc4b\u00b9\ud835\udc41\u00ba(A.19)\nwillbeapproximatelyGaussian. Thereareadditionalrequirementsneededtomakeitwork,\nmost commonly \ud835\udc38\u00bb\ud835\udc4b4\u00bc<1, but the philosophy is clear.\nThe central limit theorem is the reason why the Gaussian is fundamental to probability,\nstatistics, and machine learning. Whenever we can say that something we measured is a\nsumofmanysmallindependentcontributions,wecanassumethatthethingbeingmeasured\nwill be close to Gaussian.\nTherearemanymorefascinatingpropertiesofGaussians,andwewouldliketodiscussone\nmore here. The Gaussian is what is known as a maximum entropy distribution . We will\nget into entropy more deeply in Section A.11 , however all we need to know at this point\nis that it is a measure of randomness. In a rigorous mathematical sense, we can think of\nthe Gaussian as the mostrandom choice of random variable with fixed mean and variance.\nThus, if we know that our random variable has some mean and variance, the Gaussian is in\na sense the most conservative choice of distribution we can make.\nTo close the section, let\u2019s recall that if \ud835\udc4b\u0018N\u00b9\ud835\udf07,\ud835\udf0e2\u00ba, then:\n\u000f\ud835\udf07\ud835\udc4b=\ud835\udf07,\n\u000f\ud835\udf0e2\n\ud835\udc4b=\ud835\udf0e2.\nWecansamplefromtheGaussian(orstandardnormal)distributionasshownbelow.\ntorch .normal(mu, sigma, size =(10,10))\ntensor([[ 1.3588 ,0.0473 ,-1.5805 ,-0.0108 ,0.4253 ,0.7924 ,-0.6547 ,0.\n\u21a9!7313 ,\n-0.3038 ,1.1935 ],\n[0.0089 ,0.8951 ,1.0055 ,0.0956 ,-1.1109 ,-0.6342 ,1.6772 ,1.\n\u21a9!0314 ,\n0.3819 ,-1.7822 ],\n[-0.0604 ,-1.0318 ,0.9113 ,1.3118 ,-1.8370 ,-0.9023 ,1.0365 ,0.\n\u21a9!9052 ,\n-0.6411 ,-0.8949 ],\n[-0.1713 ,-0.2347 ,0.0767 ,-0.6375 ,-0.4612 ,-1.6875 ,-0.1570 ,1.\n\u21a9!0591 ,\n0.8377 ,0.5097 ],\n[0.2762 ,-0.6213 ,-0.3422 ,0.9449 ,-0.7544 ,-0.2150 ,1.0240 ,1.\n\u21a9!0253 ,\n-0.9182 ,1.1536 ],\n[0.0614 ,0.2758 ,-0.3610 ,-1.0577 ,-0.5513 ,-0.9158 ,0.7539 ,0.\n\u21a9!9204 ,\n-0.5908 ,0.9113 ],\n[1.6190 ,-0.9213 ,-0.7944 ,-2.2621 ,0.5826 ,-1.8287 ,1.4097 ,-0.", "mimetype": "text/plain", "start_char_idx": 2039094, "end_char_idx": 2041813, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7c5184c0-325c-4446-9858-838d5a636993": {"__data__": {"id_": "7c5184c0-325c-4446-9858-838d5a636993", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "03c5ef62-ab3c-4f85-b9bf-0c7215985ac1", "node_type": "1", "metadata": {}, "hash": "48bd25e71d49374a4b5c624327aa1008281bd647975260eddda3f4d3d890dc50", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "945fa7e9-37ce-49d2-b044-2ec172bdbc64", "node_type": "1", "metadata": {}, "hash": "1d1b934870c4482a951f009987a53afd1354ad14c1ba87bc0417287cf11f4c35", "class_name": "RelatedNodeInfo"}}, "text": "\u21a9!0591 ,\n0.8377 ,0.5097 ],\n[0.2762 ,-0.6213 ,-0.3422 ,0.9449 ,-0.7544 ,-0.2150 ,1.0240 ,1.\n\u21a9!0253 ,\n-0.9182 ,1.1536 ],\n[0.0614 ,0.2758 ,-0.3610 ,-1.0577 ,-0.5513 ,-0.9158 ,0.7539 ,0.\n\u21a9!9204 ,\n-0.5908 ,0.9113 ],\n[1.6190 ,-0.9213 ,-0.7944 ,-2.2621 ,0.5826 ,-1.8287 ,1.4097 ,-0.\n\u21a9!5744 ,\n-0.0668 ,1.2074 ],\n[-0.0624 ,0.1928 ,1.3002 ,0.6756 ,1.1590 ,1.0144 ,1.1840 ,-0.\n(continues on next page)\n998 Mathematics for Deep Learning\n(continued from previous page)\n\u21a9!5010 ,\n0.6026 ,-0.7722 ],\n[-2.0148 ,0.6958 ,0.9940 ,0.8477 ,1.0957 ,-0.5253 ,0.2353 ,-0.\n\u21a9!2663 ,\n1.2275 ,0.5993 ],\n[0.4651 ,-0.8218 ,-0.5441 ,-2.0338 ,-0.6930 ,-0.0674 ,-0.4448 ,-0.\n\u21a9!8397 ,\n0.0360 ,-0.7089 ]])\nA.8.7ExponentialFamily\nOne shared property for all the distributions listed above is that they all belong to which\nis known as the exponential family . The exponential family is a set of distributions whose\ndensity can be expressed in the following form:\n\ud835\udc5d\u00b9xj\ud835\udf3c\u00ba=\u210e\u00b9x\u00ba\u0001exp\u0000\ud835\udf3c>\u0001\ud835\udc47\u00b9x\u00ba\u0000\ud835\udc34\u00b9\ud835\udf3c\u00ba\u0001(A.20)\nAs this definition can be a little subtle, let\u2019s examine it closely.\nFirst,\u210e\u00b9x\u00bais known as the underlying measure or thebase measure . This can be viewed\nas an original choice of measure we are modifying with our exponential weight.\nSecond, we have the vector \ud835\udf3c=\u00b9\ud835\udf021,\ud835\udf022,...,\ud835\udf02\ud835\udc59\u00ba 2R\ud835\udc59called the natural parameters or\ncanonical parameters . These define how the base measure will be modified. The natural\nparametersenterintothenewmeasurebytakingthedotproductoftheseparametersagainst\nsome function \ud835\udc47\u00b9\u0001\u00baofx=\u00b9\ud835\udc651,\ud835\udc652,...,\ud835\udc65\ud835\udc5b\u00ba 2R\ud835\udc5band exponentiated. The vector \ud835\udc47\u00b9x\u00ba=\n\u00b9\ud835\udc471\u00b9x\u00ba,\ud835\udc472\u00b9x\u00ba,...,\ud835\udc47\ud835\udc59\u00b9x\u00ba\u00bais called the su\ufb00icientstatistics for\ud835\udf3c. This name is used since the\ninformation represented by \ud835\udc47\u00b9x\u00bais sufficient to calculate the probability density and no\nother information from the sample x\u2019s are required.\nThird, we have \ud835\udc34\u00b9\ud835\udf3c\u00ba, which is referred to as the cumulantfunction , which ensures that the\nabove distribution (A.20 )integrates to one, i.e.,\n\ud835\udc34\u00b9\ud835\udf3c\u00ba=log\u0014\u00b9\n\u210e\u00b9x\u00ba\u0001exp\u0000\ud835\udf3c>\u0001\ud835\udc47\u00b9x\u00ba\u0001\ud835\udc51x\u0015\n. (A.21)\nTo be concrete, let\u2019s consider the Gaussian. Assuming that xis an univariate variable, we\nsaw that it had a density of\n\ud835\udc5d\u00b9\ud835\udc65j\ud835\udf07,\ud835\udf0e\u00ba=1p\n2\ud835\udf0b\ud835\udf0e2\u0001exp\u001a\u0000\u00b9\ud835\udc65\u0000\ud835\udf07\u00ba2\n2\ud835\udf0e2\u001b\n=1p\n2\ud835\udf0b\u0001exp\u001a\ud835\udf07\n\ud835\udf0e2\ud835\udc65\u00001\n2\ud835\udf0e2\ud835\udc652\u0000\u00121\n2\ud835\udf0e2\ud835\udf072\u00b8log\u00b9\ud835\udf0e\u00ba\u0013\u001b\n.", "mimetype": "text/plain", "start_char_idx": 2041538, "end_char_idx": 2043665, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "945fa7e9-37ce-49d2-b044-2ec172bdbc64": {"__data__": {"id_": "945fa7e9-37ce-49d2-b044-2ec172bdbc64", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7c5184c0-325c-4446-9858-838d5a636993", "node_type": "1", "metadata": {}, "hash": "ec942bd68dcd4dc89e8cea69fb6ed9dac938dc4eed2a3e071548893613b3d430", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ce85fb12-c6a2-495d-bdc7-90438d4e86ec", "node_type": "1", "metadata": {}, "hash": "bf9deec0d5ae9c9df1b79ff2a7af83be3fde77b8f09e751fc9e44ceb49e379ce", "class_name": "RelatedNodeInfo"}}, "text": "(A.21)\nTo be concrete, let\u2019s consider the Gaussian. Assuming that xis an univariate variable, we\nsaw that it had a density of\n\ud835\udc5d\u00b9\ud835\udc65j\ud835\udf07,\ud835\udf0e\u00ba=1p\n2\ud835\udf0b\ud835\udf0e2\u0001exp\u001a\u0000\u00b9\ud835\udc65\u0000\ud835\udf07\u00ba2\n2\ud835\udf0e2\u001b\n=1p\n2\ud835\udf0b\u0001exp\u001a\ud835\udf07\n\ud835\udf0e2\ud835\udc65\u00001\n2\ud835\udf0e2\ud835\udc652\u0000\u00121\n2\ud835\udf0e2\ud835\udf072\u00b8log\u00b9\ud835\udf0e\u00ba\u0013\u001b\n.(A.22)\nThis matches the definition of the exponential family with:\n\u000funderlyingmeasure :\u210e\u00b9\ud835\udc65\u00ba=1p\n2\ud835\udf0b,\n\u000fnaturalparameters :\ud835\udf3c=\u0014\ud835\udf021\n\ud835\udf022\u0015\n=\u0014\ud835\udf07\n\ud835\udf0e2\n1\n2\ud835\udf0e2\u0015\n,\n999 Naive Bayes\n287\u000fsu\ufb00icient statistics :\ud835\udc47\u00b9\ud835\udc65\u00ba=\u0014\ud835\udc65\n\u0000\ud835\udc652\u0015\n, and\n\u000fcumulant function :\ud835\udc34\u00b9\ud835\udf3c\u00ba=1\n2\ud835\udf0e2\ud835\udf072\u00b8log\u00b9\ud835\udf0e\u00ba=\ud835\udf022\n1\n4\ud835\udf022\u00001\n2log\u00b92\ud835\udf022\u00ba.\nItisworthnotingthattheexactchoiceofeachofabovetermsissomewhatarbitrary. Indeed,\ntheimportantfeatureisthatthedistributioncanbeexpressedinthisform,nottheexactform\nitself.\nAs we allude to in Section 4.1.2 , a widely used technique is to assume that the final output\nyfollows an exponential family distribution. The exponential family is a common and\npowerful family of distributions encountered frequently in machine learning.\nA.8.8Summary\n\u000fBernoulli random variables can be used to model events with a yes/no outcome.\n\u000fDiscrete uniform distributions model selects from a finite set of possibilities.\n\u000fContinuous uniform distributions select from an interval.\n\u000fBinomialdistributionsmodelaseriesofBernoullirandomvariables,andcountthenum-\nber of successes.\n\u000fPoisson random variables model the arrival of rare events.\n\u000fGaussian random variables model the result of adding a large number of independent\nrandom variables together.\n\u000fAll the above distributions belong to exponential family.\nA.8.9Exercises\n1.What is the standard deviation of a random variable that is the difference \ud835\udc4b\u0000\ud835\udc4cof two\nindependent binomial random variables \ud835\udc4b,\ud835\udc4c\u0018Binomial\u00b916,1\u009d2\u00ba.\n2.If we take a Poisson random variable \ud835\udc4b\u0018Poisson\u00b9\ud835\udf06\u00baand consider\u00b9\ud835\udc4b\u0000\ud835\udf06\u00ba\u009dp\n\ud835\udf06as\n\ud835\udf06!1, we can show that this becomes approximately Gaussian. Why does this make\nsense?\n3.Whatistheprobabilitymassfunctionforasumoftwodiscreteuniformrandomvariables\non\ud835\udc5belements?\nDiscussions287.\nA.9NaiveBayes\nThroughout the previous sections, we learned about the theory of probability and random\nvariables. To put this theory to work, let\u2019s introduce the naive Bayes classifier. This\n1000 Mathematics for Deep Learning\nuses nothing but probabilistic fundamentals to allow us to perform classification of dig-\nits.\nLearningisallaboutmakingassumptions. Ifwewanttoclassifyanewdataexamplethatwe\nhave never seen before we have to make some assumptions about which data examples are\nsimilartoeachother. ThenaiveBayesclassifier,apopularandremarkablyclearalgorithm,\nassumes all features are independent from each other to simplify the computation. In this\nsection, we will apply this model to recognize characters in images.\n%matplotlib inline\nimport math\nimport torch\nimport torchvision\nfrom d2l import torch asd2l\nd2l.use_svg_display()\nA.9.1OpticalCharacter Recognition\nMNIST ( LeCunet al., 1998) is one of widely used datasets. It contains 60,000 images for\ntraining and 10,000 images for validation. Each image contains a handwritten digit from 0\nto 9. The task is classifying each image into the corresponding digit.\nGluon provides a MNISTclass in the data.vision module to automatically retrieve the\ndatasetfromtheInternet. Subsequently,Gluonwillusethealready-downloadedlocalcopy.", "mimetype": "text/plain", "start_char_idx": 2043461, "end_char_idx": 2046627, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ce85fb12-c6a2-495d-bdc7-90438d4e86ec": {"__data__": {"id_": "ce85fb12-c6a2-495d-bdc7-90438d4e86ec", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "945fa7e9-37ce-49d2-b044-2ec172bdbc64", "node_type": "1", "metadata": {}, "hash": "1d1b934870c4482a951f009987a53afd1354ad14c1ba87bc0417287cf11f4c35", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ad360a28-2882-41e6-b363-7c06d8bc0e9a", "node_type": "1", "metadata": {}, "hash": "78ab5f4ebb13c1945a4763d84ea784f66a46f2cee65d4b4b1c352c3a130fd407", "class_name": "RelatedNodeInfo"}}, "text": "ThenaiveBayesclassifier,apopularandremarkablyclearalgorithm,\nassumes all features are independent from each other to simplify the computation. In this\nsection, we will apply this model to recognize characters in images.\n%matplotlib inline\nimport math\nimport torch\nimport torchvision\nfrom d2l import torch asd2l\nd2l.use_svg_display()\nA.9.1OpticalCharacter Recognition\nMNIST ( LeCunet al., 1998) is one of widely used datasets. It contains 60,000 images for\ntraining and 10,000 images for validation. Each image contains a handwritten digit from 0\nto 9. The task is classifying each image into the corresponding digit.\nGluon provides a MNISTclass in the data.vision module to automatically retrieve the\ndatasetfromtheInternet. Subsequently,Gluonwillusethealready-downloadedlocalcopy.\nWe specify whether we are requesting the training set or the test set by setting the value of\nthe parameter traintoTrueorFalse, respectively. Each image is a grayscale image with\nboth width and height of 28with shape ( 28,28,1). We use a customized transformation to\nremove the last channel dimension. In addition, the dataset represents each pixel by an un-\nsigned 8-bitinteger. Wequantizethemintobinaryfeaturestosimplifytheproblem.\ndata_transform =torchvision .transforms .Compose([\ntorchvision .transforms .ToTensor(),\nlambda x: torch .floor(x *255 /128).squeeze(dim =0)\n])\nmnist_train =torchvision .datasets .MNIST(\nroot ='./temp ', train =True , transform =data_transform, download =True )\nmnist_test =torchvision .datasets .MNIST(\nroot ='./temp ', train =False , transform =data_transform, download =True )\nDownloading http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz\nDownloading http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz to ./\n\u21a9!temp/MNIST/raw/train-images-idx3-ubyte.gz\n100%|\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff| 9912422/9912422 [00:00<00:00, 115752065.81it/s]\nExtracting ./temp/MNIST/raw/train-images-idx3-ubyte.gz to ./temp/MNIST/raw\nDownloading http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz\nDownloading http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz to ./\n(continues on next page)\n1001 Naive Bayes\n(continued from previous page)\n\u21a9!temp/MNIST/raw/train-labels-idx1-ubyte.gz\n100%|\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff| 28881/28881 [00:00<00:00, 5234904.66it/s]\nExtracting ./temp/MNIST/raw/train-labels-idx1-ubyte.gz to ./temp/MNIST/raw\nDownloading http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz\nDownloading http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz to ./\n\u21a9!temp/MNIST/raw/t10k-images-idx3-ubyte.gz\n100%|\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff| 1648877/1648877 [00:00<00:00, 43715298.68it/s]Extracting ./\n\u21a9!temp/MNIST/raw/t10k-images-idx3-ubyte.gz to ./temp/MNIST/raw\nDownloading http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz\nDownloading http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz to ./\n\u21a9!temp/MNIST/raw/t10k-labels-idx1-ubyte.gz\n100%|\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff\uffff| 4542/4542 [00:00<00:00, 21501725.47it/s]\nExtracting ./temp/MNIST/raw/t10k-labels-idx1-ubyte.gz to ./temp/MNIST/raw\nWe can access a particular example, which contains the image and the corresponding la-\nbel.", "mimetype": "text/plain", "start_char_idx": 2045846, "end_char_idx": 2048921, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ad360a28-2882-41e6-b363-7c06d8bc0e9a": {"__data__": {"id_": "ad360a28-2882-41e6-b363-7c06d8bc0e9a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ce85fb12-c6a2-495d-bdc7-90438d4e86ec", "node_type": "1", "metadata": {}, "hash": "bf9deec0d5ae9c9df1b79ff2a7af83be3fde77b8f09e751fc9e44ceb49e379ce", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c6a5dd39-9381-4829-857f-05a6ce2eff2c", "node_type": "1", "metadata": {}, "hash": "990b5c316d5a14233e3376acebd2cfe373e18e6cb298a5fe16a1476c09ddfd1d", "class_name": "RelatedNodeInfo"}}, "text": "image, label =mnist_train[ 2]\nimage .shape, label\n(torch .Size([ 28,28]), 4)\nOur example, stored here in the variable image, corresponds to an image with a height and\nwidth of 28pixels.\nimage .shape, image .dtype\n(torch .Size([ 28,28]), torch .float32)\nOur code stores the label of each image as a scalar. Its type is a 32-bit integer.\nlabel, type (label)\n(4,int)\nWe can also access multiple examples at the same time.\nimages =torch .stack([mnist_train[i][ 0]for iinrange (10,38)], dim =0)\nlabels =torch .tensor([mnist_train[i][ 1]for iinrange (10,38)])\nimages .shape, labels .shape\n1002 Mathematics for Deep Learning\n(torch .Size([ 28,28,28]), torch .Size([ 28]))\nLet\u2019s visualize these examples.\nd2l.show_images(images, 2,9);\nA.9.2TheProbabilisticModel forClassification\nIn a classification task, we map an example into a category. Here an example is a grayscale\n28\u000228image, and a category is a digit. (Refer to Section 4.1 for a more detailed expla-\nnation.) One natural way to express the classification task is via the probabilistic question:\nwhat is the most likely label given the features (i.e., image pixels)? Denote by x2R\ud835\udc51the\nfeatures of the example and \ud835\udc662Rthe label. Here features are image pixels, where we can\nreshape a 2-dimensional image to a vector so that \ud835\udc51=282=784, and labels are digits.\nThe probability of the label given the features is \ud835\udc5d\u00b9\ud835\udc66jx\u00ba. If we are able to compute these\nprobabilities, which are \ud835\udc5d\u00b9\ud835\udc66jx\u00bafor\ud835\udc66=0,..., 9in our example, then the classifier will\noutput the prediction \u02c6\ud835\udc66given by the expression:\n\u02c6\ud835\udc66=argmax\ud835\udc5d\u00b9\ud835\udc66jx\u00ba. (A.1)\nUnfortunately, this requires that we estimate \ud835\udc5d\u00b9\ud835\udc66jx\u00bafor every value of x=\ud835\udc651,...,\ud835\udc65\ud835\udc51.\nImaginethateachfeaturecouldtakeoneof 2values. Forexample,thefeature \ud835\udc651=1might\nsignify that the word apple appears in a given document and \ud835\udc651=0would signify that it\ndoes not. If we had 30such binary features, that would mean that we need to be prepared\nto classify any of 230(over 1 billion!) possible values of the input vector x.\nMoreover,whereisthelearning? Ifweneedtoseeeverysinglepossibleexampleinorderto\npredictthecorrespondinglabelthenwearenotreallylearningapatternbutjustmemorizing\nthe dataset.\nA.9.3The NaiveBayesClassifier\nFortunately, by making some assumptions about conditional independence, we can intro-\nduce some inductive bias and build a model capable of generalizing from a comparatively\nmodest selection of training examples. To begin, let\u2019s use Bayes theorem, to express the\nclassifier as\n\u02c6\ud835\udc66=argmax\ud835\udc66\ud835\udc5d\u00b9\ud835\udc66jx\u00ba=argmax\ud835\udc66\ud835\udc5d\u00b9xj\ud835\udc66\u00ba\ud835\udc5d\u00b9\ud835\udc66\u00ba\n\ud835\udc5d\u00b9x\u00ba. (A.2)\n1003 Naive Bayes\nNotethatthedenominatoristhenormalizingterm \ud835\udc5d\u00b9x\u00bawhichdoesnotdependonthevalue\nof the label\ud835\udc66. As a result, we only need to worry about comparing the numerator across\ndifferent values of \ud835\udc66. Even if calculating the denominator turned out to be intractable, we\ncould get away with ignoring it, so long as we could evaluate the numerator. Fortunately,\neven if we wanted to recover the normalizing constant, we could. We can always recover\nthe normalization term since\u00cd\n\ud835\udc66\ud835\udc5d\u00b9\ud835\udc66jx\u00ba=1.\nNow, let\u2019s focus on \ud835\udc5d\u00b9xj\ud835\udc66\u00ba.", "mimetype": "text/plain", "start_char_idx": 2048922, "end_char_idx": 2051934, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c6a5dd39-9381-4829-857f-05a6ce2eff2c": {"__data__": {"id_": "c6a5dd39-9381-4829-857f-05a6ce2eff2c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ad360a28-2882-41e6-b363-7c06d8bc0e9a", "node_type": "1", "metadata": {}, "hash": "78ab5f4ebb13c1945a4763d84ea784f66a46f2cee65d4b4b1c352c3a130fd407", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f4cb8c68-0c5e-45d7-b933-3a96b08c4f29", "node_type": "1", "metadata": {}, "hash": "06f5d09d41e2780b63dc440b9218f74b03378a5438311e95fe7f6690bd347b13", "class_name": "RelatedNodeInfo"}}, "text": "(A.2)\n1003 Naive Bayes\nNotethatthedenominatoristhenormalizingterm \ud835\udc5d\u00b9x\u00bawhichdoesnotdependonthevalue\nof the label\ud835\udc66. As a result, we only need to worry about comparing the numerator across\ndifferent values of \ud835\udc66. Even if calculating the denominator turned out to be intractable, we\ncould get away with ignoring it, so long as we could evaluate the numerator. Fortunately,\neven if we wanted to recover the normalizing constant, we could. We can always recover\nthe normalization term since\u00cd\n\ud835\udc66\ud835\udc5d\u00b9\ud835\udc66jx\u00ba=1.\nNow, let\u2019s focus on \ud835\udc5d\u00b9xj\ud835\udc66\u00ba. Using the chain rule of probability, we can express the term\n\ud835\udc5d\u00b9xj\ud835\udc66\u00baas\n\ud835\udc5d\u00b9\ud835\udc651j\ud835\udc66\u00ba\u0001\ud835\udc5d\u00b9\ud835\udc652j\ud835\udc651,\ud835\udc66\u00ba\u0001...\u0001\ud835\udc5d\u00b9\ud835\udc65\ud835\udc51j\ud835\udc651,...,\ud835\udc65\ud835\udc51\u00001,\ud835\udc66\u00ba. (A.3)\nBy itself, this expression does not get us any further. We still must estimate roughly 2\ud835\udc51\nparameters. However, if we assume that thefeaturesareconditionallyindependentofeach\nother,giventhelabel , then suddenly we are in much better shape, as this term simplifies to\u00ce\n\ud835\udc56\ud835\udc5d\u00b9\ud835\udc65\ud835\udc56j\ud835\udc66\u00ba, giving us the predictor\n\u02c6\ud835\udc66=argmax\ud835\udc66\ud835\udc51\u00d6\n\ud835\udc56=1\ud835\udc5d\u00b9\ud835\udc65\ud835\udc56j\ud835\udc66\u00ba\ud835\udc5d\u00b9\ud835\udc66\u00ba. (A.4)\nIf we can estimate \ud835\udc5d\u00b9\ud835\udc65\ud835\udc56=1j\ud835\udc66\u00bafor every\ud835\udc56and\ud835\udc66, and save its value in \ud835\udc43\ud835\udc65\ud835\udc66\u00bb\ud835\udc56,\ud835\udc66\u00bc, here\ud835\udc43\ud835\udc65\ud835\udc66\nis a\ud835\udc51\u0002\ud835\udc5bmatrix with\ud835\udc5bbeing the number of classes and \ud835\udc662f1,...,\ud835\udc5bg, then we can also\nuse this to estimate \ud835\udc5d\u00b9\ud835\udc65\ud835\udc56=0j\ud835\udc66\u00ba, i.e.,\n\ud835\udc5d\u00b9\ud835\udc65\ud835\udc56=\ud835\udc61\ud835\udc56j\ud835\udc66\u00ba=(\n\ud835\udc43\ud835\udc65\ud835\udc66\u00bb\ud835\udc56,\ud835\udc66\u00bcfor\ud835\udc61\ud835\udc56=1;\n1\u0000\ud835\udc43\ud835\udc65\ud835\udc66\u00bb\ud835\udc56,\ud835\udc66\u00bcfor\ud835\udc61\ud835\udc56=0.(A.5)\nIn addition, we estimate \ud835\udc5d\u00b9\ud835\udc66\u00bafor every\ud835\udc66and save it in \ud835\udc43\ud835\udc66\u00bb\ud835\udc66\u00bc, with\ud835\udc43\ud835\udc66a\ud835\udc5b-length vector.\nThen, for any new example t=\u00b9\ud835\udc611,\ud835\udc612,...,\ud835\udc61\ud835\udc51\u00ba, we could compute\n\u02c6\ud835\udc66=argmax\ud835\udc66\ud835\udc5d\u00b9\ud835\udc66\u00ba\ud835\udc51\u00d6\n\ud835\udc56=1\ud835\udc5d\u00b9\ud835\udc65\ud835\udc61=\ud835\udc61\ud835\udc56j\ud835\udc66\u00ba\n=argmax\ud835\udc66\ud835\udc43\ud835\udc66\u00bb\ud835\udc66\u00bc\ud835\udc51\u00d6\n\ud835\udc56=1\ud835\udc43\ud835\udc65\ud835\udc66\u00bb\ud835\udc56,\ud835\udc66\u00bc\ud835\udc61\ud835\udc56\u00001\u0000\ud835\udc43\ud835\udc65\ud835\udc66\u00bb\ud835\udc56,\ud835\udc66\u00bc\u00011\u0000\ud835\udc61\ud835\udc56(A.6)\nfor any\ud835\udc66. So our assumption of conditional independence has taken the complexity of\nour model from an exponential dependence on the number of features O\u00b92\ud835\udc51\ud835\udc5b\u00bato a linear\ndependence, which is O\u00b9\ud835\udc51\ud835\udc5b\u00ba.\nA.9.4Training\nThe problem now is that we do not know \ud835\udc43\ud835\udc65\ud835\udc66and\ud835\udc43\ud835\udc66. So we need to estimate their values\ngiven some training data first. This is training the model. Estimating \ud835\udc43\ud835\udc66is not too hard.", "mimetype": "text/plain", "start_char_idx": 2051411, "end_char_idx": 2053261, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f4cb8c68-0c5e-45d7-b933-3a96b08c4f29": {"__data__": {"id_": "f4cb8c68-0c5e-45d7-b933-3a96b08c4f29", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c6a5dd39-9381-4829-857f-05a6ce2eff2c", "node_type": "1", "metadata": {}, "hash": "990b5c316d5a14233e3376acebd2cfe373e18e6cb298a5fe16a1476c09ddfd1d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "dbccd467-cb3e-45fb-b8a1-62ccf849d933", "node_type": "1", "metadata": {}, "hash": "fbdbc6ed77ec9588b485f9dba7ca18ab681cf7db044fbe0a039a5ce5e3e5697f", "class_name": "RelatedNodeInfo"}}, "text": "So our assumption of conditional independence has taken the complexity of\nour model from an exponential dependence on the number of features O\u00b92\ud835\udc51\ud835\udc5b\u00bato a linear\ndependence, which is O\u00b9\ud835\udc51\ud835\udc5b\u00ba.\nA.9.4Training\nThe problem now is that we do not know \ud835\udc43\ud835\udc65\ud835\udc66and\ud835\udc43\ud835\udc66. So we need to estimate their values\ngiven some training data first. This is training the model. Estimating \ud835\udc43\ud835\udc66is not too hard.\nSince we are only dealing with 10classes, we may count the number of occurrences \ud835\udc5b\ud835\udc66for\neach of the digits and divide it by the total amount of data \ud835\udc5b. For instance, if digit 8 occurs\n\ud835\udc5b8=5,800times and we have a total of \ud835\udc5b=60,000images, the probability estimate is\n\ud835\udc5d\u00b9\ud835\udc66=8\u00ba=0.0967.\n1004 Mathematics for Deep Learning\nX=torch .stack([mnist_train[i][ 0]for iinrange (len(mnist_train))], dim =0)\nY=torch .tensor([mnist_train[i][ 1]for iinrange (len(mnist_train))])\nn_y =torch .zeros( 10)\nfor yinrange (10):\nn_y[y] =(Y==y).sum()\nP_y =n_y /n_y.sum()\nP_y\ntensor([ 0.0987 ,0.1124 ,0.0993 ,0.1022 ,0.0974 ,0.0904 ,0.0986 ,0.1044 ,0.0975 ,\n0.0992 ])\nNow on to slightly more difficult things \ud835\udc43\ud835\udc65\ud835\udc66. Since we picked black and white images,\n\ud835\udc5d\u00b9\ud835\udc65\ud835\udc56j\ud835\udc66\u00badenotes the probability that pixel \ud835\udc56is switched on for class \ud835\udc66. Just like before we\ncan go and count the number of times \ud835\udc5b\ud835\udc56\ud835\udc66such that an event occurs and divide it by the\ntotalnumberofoccurrencesof \ud835\udc66,i.e.,\ud835\udc5b\ud835\udc66. Butthereissomethingslightlytroubling: certain\npixels may never be black (e.g., for well cropped images the corner pixels might always be\nwhite). Aconvenientwayforstatisticianstodealwiththisproblemistoaddpseudocounts\nto all occurrences. Hence, rather than \ud835\udc5b\ud835\udc56\ud835\udc66we use\ud835\udc5b\ud835\udc56\ud835\udc66\u00b81and instead of \ud835\udc5b\ud835\udc66we use\ud835\udc5b\ud835\udc66\u00b82\n(since there are two possible values pixel \ud835\udc56can take - it can either be black or white). This\nis also called LaplaceSmoothing . It may seem ad-hoc, however it can be motivated from a\nBayesian point-of-view by a Beta-binomial model.\nn_x =torch .zeros(( 10,28,28))\nfor yinrange (10):\nn_x[y] =torch .tensor(X .numpy()[Y .numpy() ==y].sum(axis =0))\nP_xy =(n_x +1)/(n_y +2).reshape( 10,1,1)\nd2l.show_images(P_xy, 2,5);\nBy visualizing these 10\u000228\u000228probabilities (for each pixel for each class) we could get\nsome mean looking digits.\nNow we can use (A.6)to predict a new image. Given x, the following functions computes\n\ud835\udc5d\u00b9xj\ud835\udc66\u00ba\ud835\udc5d\u00b9\ud835\udc66\u00bafor every\ud835\udc66.\n1005 Naive Bayes\ndef bayes_pred (x):\nx=x.unsqueeze( 0)# (28, 28) -> (1, 28, 28)\np_xy =P_xy *x+(1-P_xy) *(1-x)\np_xy =p_xy .reshape( 10,-1).prod(dim =1)# p(x|y)\nreturn p_xy *P_y\nimage, label =mnist_test[ 0]\nbayes_pred(image)\ntensor([ 0.,0.,0.,0.,0.,0.,0.,0.,0.,0.])\nThis went horribly wrong! To find out why, let\u2019s look at the per pixel probabilities. They\nare typically numbers between 0.001and1. We are multiplying 784of them. At this point\nit is worth mentioning that we are calculating these numbers on a computer, hence with a\nfixedrangefortheexponent.", "mimetype": "text/plain", "start_char_idx": 2052886, "end_char_idx": 2055690, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dbccd467-cb3e-45fb-b8a1-62ccf849d933": {"__data__": {"id_": "dbccd467-cb3e-45fb-b8a1-62ccf849d933", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f4cb8c68-0c5e-45d7-b933-3a96b08c4f29", "node_type": "1", "metadata": {}, "hash": "06f5d09d41e2780b63dc440b9218f74b03378a5438311e95fe7f6690bd347b13", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "dd4c30fd-bab0-471d-b0b3-04b8ca553aa4", "node_type": "1", "metadata": {}, "hash": "2d9d0ca8b712d951732c79b48c3b3429408d3678efb0abec3bdf3f047a9cbb45", "class_name": "RelatedNodeInfo"}}, "text": "1005 Naive Bayes\ndef bayes_pred (x):\nx=x.unsqueeze( 0)# (28, 28) -> (1, 28, 28)\np_xy =P_xy *x+(1-P_xy) *(1-x)\np_xy =p_xy .reshape( 10,-1).prod(dim =1)# p(x|y)\nreturn p_xy *P_y\nimage, label =mnist_test[ 0]\nbayes_pred(image)\ntensor([ 0.,0.,0.,0.,0.,0.,0.,0.,0.,0.])\nThis went horribly wrong! To find out why, let\u2019s look at the per pixel probabilities. They\nare typically numbers between 0.001and1. We are multiplying 784of them. At this point\nit is worth mentioning that we are calculating these numbers on a computer, hence with a\nfixedrangefortheexponent. Whathappensisthatweexperience numericalunderflow ,i.e.,\nmultiplying all the small numbers leads to something even smaller until it is rounded down\nto zero. We discussed this as a theoretical issue in Section A.7 , but we see the phenomena\nclearly here in practice.\nAs discussed in that section, we fix this by use the fact that log\ud835\udc4e\ud835\udc4f=log\ud835\udc4e\u00b8log\ud835\udc4f, i.e.,\nwe switch to summing logarithms. Even if both \ud835\udc4eand\ud835\udc4fare small numbers, the logarithm\nvalues should be in a proper range.\na=0.1\nprint ('underflow: ', a**784)\nprint ('logarithm is normal: ',784*math .log(a))\nunderflow: 0.0\nlogarithm isnormal: -1805.2267129073316\nSince the logarithm is an increasing function, we can rewrite (A.6)as\n\u02c6\ud835\udc66=argmax\ud835\udc66log\ud835\udc43\ud835\udc66\u00bb\ud835\udc66\u00bc\u00b8\ud835\udc51\u00d5\n\ud835\udc56=1h\n\ud835\udc61\ud835\udc56log\ud835\udc43\ud835\udc65\ud835\udc66\u00bb\ud835\udc65\ud835\udc56,\ud835\udc66\u00bc\u00b8\u00b9 1\u0000\ud835\udc61\ud835\udc56\u00balog\u00b91\u0000\ud835\udc43\ud835\udc65\ud835\udc66\u00bb\ud835\udc65\ud835\udc56,\ud835\udc66\u00bc\u00bai\n.(A.7)\nWe can implement the following stable version:\nlog_P_xy =torch .log(P_xy)\nlog_P_xy_neg =torch .log( 1-P_xy)\nlog_P_y =torch .log(P_y)\ndef bayes_pred_stable (x):\nx=x.unsqueeze( 0)# (28, 28) -> (1, 28, 28)\np_xy =log_P_xy *x+log_P_xy_neg *(1-x)\np_xy =p_xy .reshape( 10,-1).sum(axis =1)# p(x|y)\nreturn p_xy +log_P_y\npy=bayes_pred_stable(image)\npy\n1006 Mathematics for Deep Learning\ntensor([ -268.9725 ,-301.7044 ,-245.1951 ,-218.8738 ,-193.4570 ,-206.0909 ,\n-292.5226 ,-114.6257 ,-220.3313 ,-163.1784 ])\nWe may now check if the prediction is correct.\npy.argmax(dim =0)==label\ntensor( True )\nIf we now predict a few validation examples, we can see the Bayes classifier works pretty\nwell.\ndef predict (X):\nreturn [bayes_pred_stable(x) .argmax(dim =0).type(torch .int32) .item()\nfor xinX]\nX=torch .stack([mnist_test[i][ 0]for iinrange (18)], dim =0)\ny=torch .tensor([mnist_test[i][ 1]for iinrange (18)])\npreds =predict(X)\nd2l.show_images(X, 2,9, titles =[str(d) for dinpreds]);\nFinally, let\u2019s compute the overall accuracy of the classifier.\nX=torch .stack([mnist_test[i][ 0]for iinrange (len(mnist_test))], dim =0)\ny=torch .tensor([mnist_test[i][ 1]for iinrange (len(mnist_test))])\npreds =torch .tensor(predict(X), dtype =torch .int32)\nfloat ((preds ==y).sum()) /len(y) # Validation accuracy\n0.8427\nModern deep networks achieve error rates of less than 0.01. The relatively poor perfor-\nmance is due to the incorrect statistical assumptions that we made in our model: we as-\nsumed that each and every pixel are independently generated, depending only on the label.", "mimetype": "text/plain", "start_char_idx": 2055135, "end_char_idx": 2058002, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dd4c30fd-bab0-471d-b0b3-04b8ca553aa4": {"__data__": {"id_": "dd4c30fd-bab0-471d-b0b3-04b8ca553aa4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "dbccd467-cb3e-45fb-b8a1-62ccf849d933", "node_type": "1", "metadata": {}, "hash": "fbdbc6ed77ec9588b485f9dba7ca18ab681cf7db044fbe0a039a5ce5e3e5697f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "89bb0b3f-288d-4843-890a-e3e65abaccd5", "node_type": "1", "metadata": {}, "hash": "cdf74c377751d7355dd448f39497cb6c44cf6d79478dd27418cdda2778930cbf", "class_name": "RelatedNodeInfo"}}, "text": "X=torch .stack([mnist_test[i][ 0]for iinrange (len(mnist_test))], dim =0)\ny=torch .tensor([mnist_test[i][ 1]for iinrange (len(mnist_test))])\npreds =torch .tensor(predict(X), dtype =torch .int32)\nfloat ((preds ==y).sum()) /len(y) # Validation accuracy\n0.8427\nModern deep networks achieve error rates of less than 0.01. The relatively poor perfor-\nmance is due to the incorrect statistical assumptions that we made in our model: we as-\nsumed that each and every pixel are independently generated, depending only on the label.\nThis is clearly not how humans write digits, and this wrong assumption led to the downfall\nof our overly naive (Bayes) classifier.\nA.9.5Summary\n1007 Statistics\n288\u000fUsing Bayes\u2019 rule, a classifier can be made by assuming all observed features are inde-\npendent.\n\u000fThis classifier can be trained on a dataset by counting the number of occurrences of\ncombinations of labels and pixel values.\n\u000fThis classifier was the gold standard for decades for tasks such as spam detection.\nA.9.6Exercises\n1.Consider the dataset \u00bb\u00bb0,0\u00bc,\u00bb0,1\u00bc,\u00bb1,0\u00bc,\u00bb1,1\u00bc\u00bcwith labels given by the XOR of the\ntwo elements\u00bb0,1,1,0\u00bc. What are the probabilities for a Naive Bayes classifier built\non this dataset. Does it successfully classify our points? If not, what assumptions are\nviolated?\n2.Suppose that we did not use Laplace smoothing when estimating probabilities and a\ndataexamplearrivedattestingtimewhichcontainedavalueneverobservedintraining.\nWhat would the model output?\n3.The naive Bayes classifier is a specific example of a Bayesian network, where the de-\npendenceofrandomvariablesareencodedwithagraphstructure. Whilethefulltheory\nis beyond the scope of this section (see Koller and Friedman ( 2009) for full details),\nexplain why allowing explicit dependence between the two input variables in the XOR\nmodel allows for the creation of a successful classifier.\nDiscussions288.\nA.10Statistics\nUndoubtedly, to be a top deep learning practitioner, the ability to train the state-of-the-art\nand high accurate models is crucial. However, it is often unclear when improvements are\nsignificant, or only the result of random fluctuations in the training process. To be able to\ndiscuss uncertainty in estimated values, we must learn some statistics.\nTheearliestreferenceof statistics canbetracedbacktoanArabscholarAl-Kindiinthe 9th-\ncentury, who gave a detailed description of how to use statistics and frequency analysis to\ndecipher encrypted messages. After 800 years, the modern statistics arose from Germany\nin 1700s, when the researchers focused on the demographic and economic data collection\nandanalysis. Today,statisticsisthesciencesubjectthatconcernsthecollection,processing,\nanalysis,interpretationandvisualizationofdata. Whatismore,thecoretheoryofstatistics\nhas been widely used in the research within academia, industry, and government.\nMorespecifically, statisticscan be divided to descriptivestatistics andstatisticalinference .\nThe former focus on summarizing and illustrating the features of a collection of observed\ndata, which is referred to as a sample. The sample is drawn from a population , denotes\n1008 Mathematics for Deep Learning\nthetotalsetofsimilarindividuals, items, oreventsofourexperimentinterests. Contraryto\ndescriptivestatistics, statisticalinference furtherdeducesthecharacteristicsofapopulation\nfromthegiven samples,basedontheassumptionsthatthesampledistributioncanreplicate\nthe population distribution at some degree.\nYou may wonder: \u201cWhat is the essential difference between machine learning and statis-\ntics?\u201d Fundamentally speaking, statistics focuses on the inference problem. This type of\nproblems includes modeling the relationship between the variables, such as causal infer-\nence, and testing the statistically significance of model parameters, such as A/B testing. In\ncontrast, machine learning emphasizes on making accurate predictions, without explicitly\nprogramming and understanding each parameter\u2019s functionality.\nInthissection,wewillintroducethreetypesofstatisticsinferencemethods: evaluatingand\ncomparing estimators, conducting hypothesis tests, and constructing confidence intervals.\nThese methods can help us infer the characteristics of a given population, i.e., the true\nparameter\ud835\udf03. For brevity, we assume that the true parameter \ud835\udf03of a given population is a\nscalar value.", "mimetype": "text/plain", "start_char_idx": 2057479, "end_char_idx": 2061798, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "89bb0b3f-288d-4843-890a-e3e65abaccd5": {"__data__": {"id_": "89bb0b3f-288d-4843-890a-e3e65abaccd5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "dd4c30fd-bab0-471d-b0b3-04b8ca553aa4", "node_type": "1", "metadata": {}, "hash": "2d9d0ca8b712d951732c79b48c3b3429408d3678efb0abec3bdf3f047a9cbb45", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "39ccdc42-9477-44a4-b4b8-d9cede84314d", "node_type": "1", "metadata": {}, "hash": "d0522ce2036e1f18647ba1ca527f8b8ccb3966c6bc38bd8d9a34eaefc5ee73b7", "class_name": "RelatedNodeInfo"}}, "text": "You may wonder: \u201cWhat is the essential difference between machine learning and statis-\ntics?\u201d Fundamentally speaking, statistics focuses on the inference problem. This type of\nproblems includes modeling the relationship between the variables, such as causal infer-\nence, and testing the statistically significance of model parameters, such as A/B testing. In\ncontrast, machine learning emphasizes on making accurate predictions, without explicitly\nprogramming and understanding each parameter\u2019s functionality.\nInthissection,wewillintroducethreetypesofstatisticsinferencemethods: evaluatingand\ncomparing estimators, conducting hypothesis tests, and constructing confidence intervals.\nThese methods can help us infer the characteristics of a given population, i.e., the true\nparameter\ud835\udf03. For brevity, we assume that the true parameter \ud835\udf03of a given population is a\nscalar value. It is straightforward to extend to the case where \ud835\udf03is a vector or a tensor, thus\nwe omit it in our discussion.\nA.10.1Evaluatingand ComparingEstimators\nInstatistics, an estimator isafunctionofgivensamplesusedtoestimatethetrueparameter\n\ud835\udf03. We will write \u02c6\ud835\udf03\ud835\udc5b=\u02c6\ud835\udc53\u00b9\ud835\udc651,...,\ud835\udc65\ud835\udc5b\u00bafor the estimate of \ud835\udf03after observing the samples\n{\ud835\udc651,\ud835\udc652,...,\ud835\udc65\ud835\udc5b}.\nWe have seen simple examples of estimators before in section Section A.7 . If you have a\nnumber of samples from a Bernoulli random variable, then the maximum likelihood esti-\nmatefortheprobabilitytherandomvariableisonecanbeobtainedbycountingthenumber\nof ones observed and dividing by the total number of samples. Similarly, an exercise asked\nyouto showthat the maximum likelihoodestimateof the mean of a Gaussian givena num-\nberofsamplesisgivenbytheaveragevalueofallthesamples. Theseestimatorswillalmost\nnever give the true value of the parameter, but ideally for a large number of samples the\nestimate will be close.\nAs an example, we show below the true density of a Gaussian random variable with mean\nzeroandvarianceone,alongwithacollectionsamplesfromthatGaussian. Weconstructed\nthe\ud835\udc66coordinate so every point is visible and the relationship to the original density is\nclearer.\nimport torch\nfrom d2l import torch asd2l\ntorch .pi=torch .acos(torch .zeros( 1))*2#define pi in torch\n# Sample datapoints and create y coordinate\nepsilon =0.1\ntorch .manual_seed( 8675309 )\nxs=torch .randn(size =(300,))\n(continues on next page)\n1009 Statistics\n(continued from previous page)\nys=torch .tensor(\n[torch .sum(torch .exp( -(xs[:i] -xs[i]) **2/(2*epsilon **2))\\\n/torch .sqrt( 2*torch .pi*epsilon **2))/len(xs)\\\nfor iinrange (len(xs))])\n# Compute true density\nxd=torch .arange(torch .min(xs), torch .max(xs), 0.01 )\nyd=torch .exp( -xd**2/2)/torch .sqrt( 2*torch .pi)\n# Plot the results\nd2l.plot(xd, yd, 'x','density ')\nd2l.plt.scatter(xs, ys)\nd2l.plt.axvline(x =0)\nd2l.plt.axvline(x =torch .mean(xs), linestyle ='--', color ='purple ')\nd2l.plt.title( f'sample mean: {float (torch .mean(xs) .item()) :.2f}')\nd2l.plt.show()\nThere can be many ways to compute an estimator of a parameter \u02c6\ud835\udf03\ud835\udc5b. In this section, we\nintroduce three common methods to evaluate and compare estimators: the mean squared\nerror, the standard deviation, and statistical bias.\nMean SquaredError\nPerhaps the simplest metric used to evaluate estimators is the mean squared error (MSE)\n(or\ud835\udc592loss) estimator which can be defined as\nMSE\u00b9\u02c6\ud835\udf03\ud835\udc5b,\ud835\udf03\u00ba=\ud835\udc38\u00bb\u00b9\u02c6\ud835\udf03\ud835\udc5b\u0000\ud835\udf03\u00ba2\u00bc. (A.1)\nThisallowsustoquantifytheaveragesquareddeviationfromthetruevalue. MSEisalways\nnon-negative. Ifyouhaveread Section3.1 ,youwillrecognizeitasthemostcommonlyused\nregressionlossfunction.", "mimetype": "text/plain", "start_char_idx": 2060925, "end_char_idx": 2064429, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "39ccdc42-9477-44a4-b4b8-d9cede84314d": {"__data__": {"id_": "39ccdc42-9477-44a4-b4b8-d9cede84314d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "89bb0b3f-288d-4843-890a-e3e65abaccd5", "node_type": "1", "metadata": {}, "hash": "cdf74c377751d7355dd448f39497cb6c44cf6d79478dd27418cdda2778930cbf", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cd5e87ef-855d-4dd2-baaf-f466a5c8f6ec", "node_type": "1", "metadata": {}, "hash": "f8d8456bb09e017eeddfee90ed2861c1746ebb08f2cf3b3bea27d7b3bba88572", "class_name": "RelatedNodeInfo"}}, "text": "In this section, we\nintroduce three common methods to evaluate and compare estimators: the mean squared\nerror, the standard deviation, and statistical bias.\nMean SquaredError\nPerhaps the simplest metric used to evaluate estimators is the mean squared error (MSE)\n(or\ud835\udc592loss) estimator which can be defined as\nMSE\u00b9\u02c6\ud835\udf03\ud835\udc5b,\ud835\udf03\u00ba=\ud835\udc38\u00bb\u00b9\u02c6\ud835\udf03\ud835\udc5b\u0000\ud835\udf03\u00ba2\u00bc. (A.1)\nThisallowsustoquantifytheaveragesquareddeviationfromthetruevalue. MSEisalways\nnon-negative. Ifyouhaveread Section3.1 ,youwillrecognizeitasthemostcommonlyused\nregressionlossfunction. Asameasuretoevaluateanestimator, thecloseritsvaluetozero,\nthe closer the estimator is close to the true parameter \ud835\udf03.\nStatistical Bias\nThe MSE provides a natural metric, but we can easily imagine multiple different phenom-\nena that might make it large. Two fundamentally important are fluctuation in the estimator\n1010 Mathematics for Deep Learning\nduetorandomnessinthedataset,andsystematicerrorintheestimatorduetotheestimation\nprocedure.\nFirst, let\u2019s measure the systematic error. For an estimator \u02c6\ud835\udf03\ud835\udc5b, the mathematical illustration\nofstatisticalbias can be defined as\nbias\u00b9\u02c6\ud835\udf03\ud835\udc5b\u00ba=\ud835\udc38\u00b9\u02c6\ud835\udf03\ud835\udc5b\u0000\ud835\udf03\u00ba=\ud835\udc38\u00b9\u02c6\ud835\udf03\ud835\udc5b\u00ba\u0000\ud835\udf03. (A.2)\nNote that when bias \u00b9\u02c6\ud835\udf03\ud835\udc5b\u00ba=0, the expectation of the estimator \u02c6\ud835\udf03\ud835\udc5bis equal to the true value\nof parameter. In this case, we say \u02c6\ud835\udf03\ud835\udc5bis an unbiased estimator. In general, an unbiased\nestimator is better than a biased estimator since its expectation is the same as the true pa-\nrameter.\nIt is worth being aware, however, that biased estimators are frequently used in practice.\nThere are cases where unbiased estimators do not exist without further assumptions, or\nare intractable to compute. This may seem like a significant flaw in an estimator, however\nthe majority of estimators encountered in practice are at least asymptotically unbiased in\nthe sense that the bias tends to zero as the number of available samples tends to infinity:\nlim\ud835\udc5b!1bias\u00b9\u02c6\ud835\udf03\ud835\udc5b\u00ba=0.\nVarianceand StandardDeviation\nSecond, let\u2019s measure the randomness in the estimator. Recall from Section A.6 , thestan-\ndard deviation (orstandard error ) is defined as the squared root of the variance. We may\nmeasure the degree of fluctuation of an estimator by measuring the standard deviation or\nvariance of that estimator.\n\ud835\udf0e\u02c6\ud835\udf03\ud835\udc5b=q\nVar\u00b9\u02c6\ud835\udf03\ud835\udc5b\u00ba=q\n\ud835\udc38\u00bb\u00b9\u02c6\ud835\udf03\ud835\udc5b\u0000\ud835\udc38\u00b9\u02c6\ud835\udf03\ud835\udc5b\u00ba\u00ba2\u00bc. (A.3)\nIt is important to compare (A.3)to(A.1). In this equation we do not compare to the true\npopulation value \ud835\udf03, but instead to \ud835\udc38\u00b9\u02c6\ud835\udf03\ud835\udc5b\u00ba, the expected sample mean. Thus we are not\nmeasuring how far the estimator tends to be from the true value, but instead we measuring\nthe fluctuation of the estimator itself.\nTheBias-VarianceTrade-off\nIt is intuitively clear that these two main components contribute to the mean squared error.\nWhat is somewhat shocking is that we can show that this is actually a decomposition of\nthe mean squared error into these two contributions plus a third one. That is to say that we\ncan write the mean squared error as the sum of the square of the bias, the variance and the\n1011 Statistics\nirreducible error.", "mimetype": "text/plain", "start_char_idx": 2063910, "end_char_idx": 2066885, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cd5e87ef-855d-4dd2-baaf-f466a5c8f6ec": {"__data__": {"id_": "cd5e87ef-855d-4dd2-baaf-f466a5c8f6ec", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "39ccdc42-9477-44a4-b4b8-d9cede84314d", "node_type": "1", "metadata": {}, "hash": "d0522ce2036e1f18647ba1ca527f8b8ccb3966c6bc38bd8d9a34eaefc5ee73b7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "22eaea98-2ef8-4385-b893-7ffa4582c19d", "node_type": "1", "metadata": {}, "hash": "41a320acc13f652e7cb511410d6ce455aaf563bd211b7727526d9c3d37a121c9", "class_name": "RelatedNodeInfo"}}, "text": "(A.3)\nIt is important to compare (A.3)to(A.1). In this equation we do not compare to the true\npopulation value \ud835\udf03, but instead to \ud835\udc38\u00b9\u02c6\ud835\udf03\ud835\udc5b\u00ba, the expected sample mean. Thus we are not\nmeasuring how far the estimator tends to be from the true value, but instead we measuring\nthe fluctuation of the estimator itself.\nTheBias-VarianceTrade-off\nIt is intuitively clear that these two main components contribute to the mean squared error.\nWhat is somewhat shocking is that we can show that this is actually a decomposition of\nthe mean squared error into these two contributions plus a third one. That is to say that we\ncan write the mean squared error as the sum of the square of the bias, the variance and the\n1011 Statistics\nirreducible error.\nMSE\u00b9\u02c6\ud835\udf03\ud835\udc5b,\ud835\udf03\u00ba=\ud835\udc38\u00bb\u00b9\u02c6\ud835\udf03\ud835\udc5b\u0000\ud835\udf03\u00ba2\u00bc\n=\ud835\udc38\u00bb\u00b9\u02c6\ud835\udf03\ud835\udc5b\u00ba2\u00bc\u00b8\ud835\udc38\u00bb\ud835\udf032\u00bc\u00002\ud835\udc38\u00bb\u02c6\ud835\udf03\ud835\udc5b\ud835\udf03\u00bc\n=Var\u00bb\u02c6\ud835\udf03\ud835\udc5b\u00bc\u00b8\ud835\udc38\u00bb\u02c6\ud835\udf03\ud835\udc5b\u00bc2\u00b8Var\u00bb\ud835\udf03\u00bc\u00b8\ud835\udc38\u00bb\ud835\udf03\u00bc2\u00002\ud835\udc38\u00bb\u02c6\ud835\udf03\ud835\udc5b\u00bc\ud835\udc38\u00bb\ud835\udf03\u00bc\n=\u00b9\ud835\udc38\u00bb\u02c6\ud835\udf03\ud835\udc5b\u00bc\u0000\ud835\udc38\u00bb\ud835\udf03\u00bc\u00ba2\u00b8Var\u00bb\u02c6\ud835\udf03\ud835\udc5b\u00bc\u00b8Var\u00bb\ud835\udf03\u00bc\n=\u00b9\ud835\udc38\u00bb\u02c6\ud835\udf03\ud835\udc5b\u0000\ud835\udf03\u00bc\u00ba2\u00b8Var\u00bb\u02c6\ud835\udf03\ud835\udc5b\u00bc\u00b8Var\u00bb\ud835\udf03\u00bc\n=\u00b9bias\u00bb\u02c6\ud835\udf03\ud835\udc5b\u00bc\u00ba2\u00b8Var\u00b9\u02c6\ud835\udf03\ud835\udc5b\u00ba\u00b8Var\u00bb\ud835\udf03\u00bc.(A.4)\nWe refer the above formula as bias-variance trade-off . The mean squared error can be di-\nvidedintothreesourcesoferror: theerrorfromhighbias,theerrorfromhighvarianceand\nthe irreducible error. The bias error is commonly seen in a simple model (such as a linear\nregression model), which cannot extract high dimensional relations between the features\nand the outputs. If a model suffers from high bias error, we often say it is underfitting or\nlack offlexibilty as introduced in ( Section 3.6 ). The high variance usually results from a\ntoo complex model, which overfits the training data. As a result, an overfitting model is\nsensitive to small fluctuations in the data. If a model suffers from high variance, we often\nsayitisoverfitting andlackof generalization asintroducedin( Section3.6 ). Theirreducible\nerror is the result from noise in the \ud835\udf03itself.\nEvaluatingEstimators in Code\nSince the standard deviation of an estimator has been implementing by simply calling a.\nstd()foratensor a,wewillskipitbutimplementthestatisticalbiasandthemeansquared\nerror.\n# Statistical bias\ndef stat_bias (true_theta, est_theta):\nreturn (torch .mean(est_theta) -true_theta)\n# Mean squared error\ndef mse(data, true_theta):\nreturn (torch .mean(torch .square(data -true_theta)))\nToillustratetheequationofthebias-variancetrade-off,let\u2019ssimulateofnormaldistribution\nN\u00b9\ud835\udf03,\ud835\udf0e2\u00bawith 10,000samples. Here, we use a \ud835\udf03=1and\ud835\udf0e=4. As the estimator is a\nfunction of the given samples, here we use the mean of the samples as an estimator for true\n\ud835\udf03in this normal distribution N\u00b9\ud835\udf03,\ud835\udf0e2\u00ba.\ntheta_true =1\nsigma =4\nsample_len =10000\nsamples =torch .normal(theta_true, sigma, size =(sample_len, 1))\ntheta_est =torch .mean(samples)\ntheta_est\n1012 Mathematics for Deep Learning\ntensor( 1.0170 )\nLet\u2019s validate the trade-off equation by calculating the summation of the squared bias and\nthe variance of our estimator. First, calculate the MSE of our estimator.", "mimetype": "text/plain", "start_char_idx": 2066150, "end_char_idx": 2068988, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "22eaea98-2ef8-4385-b893-7ffa4582c19d": {"__data__": {"id_": "22eaea98-2ef8-4385-b893-7ffa4582c19d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cd5e87ef-855d-4dd2-baaf-f466a5c8f6ec", "node_type": "1", "metadata": {}, "hash": "f8d8456bb09e017eeddfee90ed2861c1746ebb08f2cf3b3bea27d7b3bba88572", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "18b040d1-02d1-4581-a0b9-91d390c92109", "node_type": "1", "metadata": {}, "hash": "bc4828582f574d049ee15b92dc228193bd53363025842a6938bdef70ff3fe570", "class_name": "RelatedNodeInfo"}}, "text": "Here, we use a \ud835\udf03=1and\ud835\udf0e=4. As the estimator is a\nfunction of the given samples, here we use the mean of the samples as an estimator for true\n\ud835\udf03in this normal distribution N\u00b9\ud835\udf03,\ud835\udf0e2\u00ba.\ntheta_true =1\nsigma =4\nsample_len =10000\nsamples =torch .normal(theta_true, sigma, size =(sample_len, 1))\ntheta_est =torch .mean(samples)\ntheta_est\n1012 Mathematics for Deep Learning\ntensor( 1.0170 )\nLet\u2019s validate the trade-off equation by calculating the summation of the squared bias and\nthe variance of our estimator. First, calculate the MSE of our estimator.\nmse(samples, theta_true)\ntensor( 16.0298 )\nNext, we calculate Var \u00b9\u02c6\ud835\udf03\ud835\udc5b\u00ba\u00b8\u00bbbias\u00b9\u02c6\ud835\udf03\ud835\udc5b\u00ba\u00bc2as below. As you can see, the two values agree to\nnumerical precision.\nbias =stat_bias(theta_true, theta_est)\ntorch .square(samples .std(unbiased =False ))+torch .square(bias)\ntensor( 16.0298 )\nA.10.2Conducting HypothesisTests\nThe most commonly encountered topic in statistical inference is hypothesis testing. While\nhypothesis testing was popularized in the early 20th century, the first use can be traced\nback to John Arbuthnot in the 1700s. John tracked 80-year birth records in London and\nconcluded that more men were born than women each year. Following that, the modern\nsignificance testing is the intelligence heritage by Karl Pearson who invented \ud835\udc5d-value and\nPearson\u2019schi-squaredtest,WilliamGossetwhoisthefatherofStudent\u2019st-distribution,and\nRonald Fisher who initialed the null hypothesis and the significance test.\nAhypothesistest isawayofevaluatingsomeevidenceagainstthedefaultstatementabouta\npopulation. We refer the default statement as the nullhypothesis \ud835\udc3b0, which we try to reject\nusing the observed data. Here, we use \ud835\udc3b0as a starting point for the statistical significance\ntesting. The alternative hypothesis \ud835\udc3b\ud835\udc34(or\ud835\udc3b1) is a statement that is contrary to the null\nhypothesis. A null hypothesis is often stated in a declarative form which posits a relation-\nship between variables. It should reflect the brief as explicit as possible, and be testable by\nstatistics theory.\nImagine you are a chemist. After spending thousands of hours in the lab, you develop a\nnew medicine which can dramatically improve one\u2019s ability to understand math. To show\nits magic power, you need to test it. Naturally, you may need some volunteers to take\nthe medicine and see whether it can help them learn mathematics better. How do you get\nstarted?\nFirst, you will need carefully random selected two groups of volunteers, so that there is no\ndifference between their mathematical understanding ability measured by some metrics.\nThe two groups are commonly referred to as the test group and the control group. The\ntestgroup (ortreatmentgroup )isagroupofindividualswhowillexperiencethemedicine,\n1013 Statistics\nwhile the control group represents the group of users who are set aside as a benchmark,\ni.e., identical environment setups except taking this medicine. In this way, the influence\nof all the variables are minimized, except the impact of the independent variable in the\ntreatment.\nSecond, after a period of taking the medicine, you will need to measure the two groups\u2019\nmathematicalunderstandingbythesamemetrics,suchaslettingthevolunteersdothesame\ntests after learning a new mathematical formula. Then, you can collect their performance\nand compare the results. In this case, our null hypothesis will be that there is no difference\nbetween the two groups, and our alternate will be that there is.\nThis is still not fully formal. There are many details you have to think of carefully. For\nexample,whatisthesuitablemetricstotesttheirmathematicalunderstandingability? How\nmany volunteers for your test so you can be confident to claim the effectiveness of your\nmedicine? How long should you run the test? How do you decide if there is a difference\nbetweenthetwogroups? Doyoucareabouttheaverageperformanceonly,oralsotherange\nof variation of the scores? And so on.\nInthisway,hypothesistestingprovidesaframeworkforexperimentaldesignandreasoning\nabout certainty in observed results.", "mimetype": "text/plain", "start_char_idx": 2068446, "end_char_idx": 2072445, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "18b040d1-02d1-4581-a0b9-91d390c92109": {"__data__": {"id_": "18b040d1-02d1-4581-a0b9-91d390c92109", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "22eaea98-2ef8-4385-b893-7ffa4582c19d", "node_type": "1", "metadata": {}, "hash": "41a320acc13f652e7cb511410d6ce455aaf563bd211b7727526d9c3d37a121c9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7b6d014d-c532-4647-9350-96def4925efe", "node_type": "1", "metadata": {}, "hash": "f98d0cfb8047682d237dc37c2a10a516552fafed5026f27ca806695431fefa0b", "class_name": "RelatedNodeInfo"}}, "text": "Then, you can collect their performance\nand compare the results. In this case, our null hypothesis will be that there is no difference\nbetween the two groups, and our alternate will be that there is.\nThis is still not fully formal. There are many details you have to think of carefully. For\nexample,whatisthesuitablemetricstotesttheirmathematicalunderstandingability? How\nmany volunteers for your test so you can be confident to claim the effectiveness of your\nmedicine? How long should you run the test? How do you decide if there is a difference\nbetweenthetwogroups? Doyoucareabouttheaverageperformanceonly,oralsotherange\nof variation of the scores? And so on.\nInthisway,hypothesistestingprovidesaframeworkforexperimentaldesignandreasoning\nabout certainty in observed results. If we can now show that the null hypothesis is very\nunlikely to be true, we may reject it with confidence.\nTo complete the story of how to work with hypothesis testing, we need to now introduce\nsome additional terminology and make some of our concepts above formal.\nStatistical Significance\nThestatistical significance measures the probability of erroneously rejecting the null hy-\npothesis,\ud835\udc3b0, when it should not be rejected, i.e.,\nstatistical significance =1\u0000\ud835\udefc=1\u0000\ud835\udc43\u00b9reject\ud835\udc3b0j\ud835\udc3b0is true\u00ba. (A.5)\nIt is also referred to as the typeIerror orfalsepositive . The\ud835\udefc, is called as the significance\nleveland its commonly used value is 5%, i.e., 1\u0000\ud835\udefc=95%. The significance level can\nbe explained as the level of risk that we are willing to take, when we reject a true null\nhypothesis.\nFig. A.1 shows the observations\u2019 values and probability of a given normal distribution\nin a two-sample hypothesis test. If the observation data example is located outsides the\n95%threshold, it will be a very unlikely observation under the null hypothesis assump-\ntion. Hence, there might be something wrong with the null hypothesis and we will reject\nit.\nStatistical Power\nThestatisticalpower (orsensitivity ) measures the probability of reject the null hypothesis,\n\ud835\udc3b0, when it should be rejected, i.e.,\nstatistical power =1\u0000\ud835\udefd=1\u0000\ud835\udc43\u00b9fail to reject \ud835\udc3b0j\ud835\udc3b0is false\u00ba. (A.6)\n1014 Mathematics for Deep Learning\ntFig. A.1 Statistical signi\ufb01cance.\nRecall that a type I error is error caused by rejecting the null hypothesis when it is true,\nwhereas a typeIIerror is resulted from failing to reject the null hypothesis when it is false.\nA type II error is usually denoted as \ud835\udefd, and hence the corresponding statistical power is\n1\u0000\ud835\udefd.\nIntuitively, statistical power can be interpreted as how likely our test will detect a real dis-\ncrepancy of some minimum magnitude at a desired statistical significance level. 80%is\na commonly used statistical power threshold. The higher the statistical power, the more\nlikely we are to detect true differences.\nOne of the most common uses of statistical power is in determining the number of samples\nneeded. Theprobabilityyourejectthenullhypothesiswhenitisfalsedependsonthedegree\nto which it is false (known as the effect size ) and the number of samples you have. As you\nmightexpect,smalleffectsizeswillrequireaverylargenumberofsamplestobedetectable\nwith high probability. While beyond the scope of this brief appendix to derive in detail, as\nan example, want to be able to reject a null hypothesis that our sample came from a mean\nzerovarianceoneGaussian, andwebelievethatoursample\u2019smeanisactuallyclosetoone,\nwe can do so with acceptable error rates with a sample size of only 8. However, if we think\nour sample population true mean is close to 0.01, then we\u2019d need a sample size of nearly\n80000to detect the difference.\nWe can imagine the power as a water filter. In this analogy, a high power hypothesis test is\nlike a high quality water filtration system that will reduce harmful substances in the water\nas much as possible. On the other hand, a smaller discrepancy is like a low quality water\nfilter, where some relative small substances may easily escape from the gaps. Similarly, if\nthe statistical power is not of enough high power, then the test may not catch the smaller\ndiscrepancy.", "mimetype": "text/plain", "start_char_idx": 2071667, "end_char_idx": 2075736, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7b6d014d-c532-4647-9350-96def4925efe": {"__data__": {"id_": "7b6d014d-c532-4647-9350-96def4925efe", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "18b040d1-02d1-4581-a0b9-91d390c92109", "node_type": "1", "metadata": {}, "hash": "bc4828582f574d049ee15b92dc228193bd53363025842a6938bdef70ff3fe570", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e873e8c9-399d-4443-b06f-f882a35f7d1c", "node_type": "1", "metadata": {}, "hash": "58ff78eb09d7cca8b0e88547e3016790467f42c80e35a99d1ed765da61658e82", "class_name": "RelatedNodeInfo"}}, "text": "However, if we think\nour sample population true mean is close to 0.01, then we\u2019d need a sample size of nearly\n80000to detect the difference.\nWe can imagine the power as a water filter. In this analogy, a high power hypothesis test is\nlike a high quality water filtration system that will reduce harmful substances in the water\nas much as possible. On the other hand, a smaller discrepancy is like a low quality water\nfilter, where some relative small substances may easily escape from the gaps. Similarly, if\nthe statistical power is not of enough high power, then the test may not catch the smaller\ndiscrepancy.\nTestStatistic\nAtest statistic\ud835\udc47\u00b9\ud835\udc65\u00bais a scalar which summarizes some characteristic of the sample data.\nThegoalofdefiningsuchastatisticisthatitshouldallowustodistinguishbetweendifferent\ndistributions and conduct our hypothesis test. Thinking back to our chemist example, if we\nwish to show that one population performs better than the other, it could be reasonable to\n1015 Statistics\ntake the mean as the test statistic. Different choices of test statistic can lead to statistical\ntest with drastically different statistical power.\nOften,\ud835\udc47\u00b9\ud835\udc4b\u00ba(the distribution of the test statistic under our null hypothesis) will follow, at\nleast approximately, a common probability distribution such as a normal distribution when\nconsidered under the null hypothesis. If we can derive explicitly such a distribution, and\nthen measure our test statistic on our dataset, we can safely reject the null hypothesis if our\nstatistic is far outside the range that we would expect. Making this quantitative leads us to\nthe notion of \ud835\udc5d-values.\n\ud835\udc5d-value\nThe\ud835\udc5d-value (or the probabilityvalue ) is the probability that \ud835\udc47\u00b9\ud835\udc4b\u00bais at least as extreme as\nthe observed test statistic \ud835\udc47\u00b9\ud835\udc65\u00baassuming that the null hypothesis is true, i.e.,\n\ud835\udc5d-value =\ud835\udc43\ud835\udc3b0\u00b9\ud835\udc47\u00b9\ud835\udc4b\u00ba\u0015\ud835\udc47\u00b9\ud835\udc65\u00ba\u00ba. (A.7)\nIf the\ud835\udc5d-valueis smaller than or equal to a predefined and fixed statistical significance level\n\ud835\udefc, we may reject the null hypothesis. Otherwise, we will conclude that we are lack of\nevidence to reject the null hypothesis. For a given population distribution, the region of\nrejection will be the interval contained of all the points which has a \ud835\udc5d-value smaller than\nthe statistical significance level \ud835\udefc.\nOne-side Testand Two-sidedTest\nNormally there are two kinds of significance test: the one-sided test and the two-sided\ntest. The one-sided test (orone-tailed test ) is applicable when the null hypothesis and the\nalternative hypothesis only have one direction. For example, the null hypothesis may state\nthat the true parameter \ud835\udf03is less than or equal to a value \ud835\udc50. The alternative hypothesis\nwould be that \ud835\udf03is greater than \ud835\udc50. That is, the region of rejection is on only one side of the\nsampling distribution. Contrary to the one-sided test, the two-sidedtest (ortwo-tailedtest )\nis applicable when the region of rejection is on both sides of the sampling distribution. An\nexample in this case may have a null hypothesis state that the true parameter \ud835\udf03is equal to a\nvalue\ud835\udc50. The alternative hypothesis would be that \ud835\udf03is not equal to \ud835\udc50.\nGeneral Steps of HypothesisTesting\nAftergettingfamiliarwiththeaboveconcepts, let\u2019sgothroughthegeneralstepsofhypoth-\nesis testing.\n1.State the question and establish a null hypotheses \ud835\udc3b0.\n2.Set the statistical significance level \ud835\udefcand a statistical power ( 1\u0000\ud835\udefd).\n3.Obtain samples through experiments. The number of samples needed will depend on\nthe statistical power, and the expected effect size.\n4.Calculate the test statistic and the \ud835\udc5d-value.\n1016 Mathematics for Deep Learning\n5.Make the decision to keep or reject the null hypothesis based on the \ud835\udc5d-value and the\nstatistical significance level \ud835\udefc.\nTo conduct a hypothesis test, we start by defining a null hypothesis and a level of risk that\nwe are willing to take. Then we calculate the test statistic of the sample, taking an extreme\nvalue of the test statistic as evidence against the null hypothesis. If the test statistic falls\nwithintherejectregion,wemayrejectthenullhypothesisinfavorofthealternative.\nHypothesis testing is applicable in a variety of scenarios such as the clinical trails and A/B\ntesting.", "mimetype": "text/plain", "start_char_idx": 2075124, "end_char_idx": 2079265, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e873e8c9-399d-4443-b06f-f882a35f7d1c": {"__data__": {"id_": "e873e8c9-399d-4443-b06f-f882a35f7d1c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7b6d014d-c532-4647-9350-96def4925efe", "node_type": "1", "metadata": {}, "hash": "f98d0cfb8047682d237dc37c2a10a516552fafed5026f27ca806695431fefa0b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e9ff621c-e2eb-49dc-9dc2-2a277fbade30", "node_type": "1", "metadata": {}, "hash": "c6b1ee82eaad661e5b9a88de0b35f3fdb442a646ab2d54e7858ca5cec83c311c", "class_name": "RelatedNodeInfo"}}, "text": "2.Set the statistical significance level \ud835\udefcand a statistical power ( 1\u0000\ud835\udefd).\n3.Obtain samples through experiments. The number of samples needed will depend on\nthe statistical power, and the expected effect size.\n4.Calculate the test statistic and the \ud835\udc5d-value.\n1016 Mathematics for Deep Learning\n5.Make the decision to keep or reject the null hypothesis based on the \ud835\udc5d-value and the\nstatistical significance level \ud835\udefc.\nTo conduct a hypothesis test, we start by defining a null hypothesis and a level of risk that\nwe are willing to take. Then we calculate the test statistic of the sample, taking an extreme\nvalue of the test statistic as evidence against the null hypothesis. If the test statistic falls\nwithintherejectregion,wemayrejectthenullhypothesisinfavorofthealternative.\nHypothesis testing is applicable in a variety of scenarios such as the clinical trails and A/B\ntesting.\nA.10.3Constructing Confidence Intervals\nWhen estimating the value of a parameter \ud835\udf03, point estimators like \u02c6\ud835\udf03are of limited utility\nsince they contain no notion of uncertainty. Rather, it would be far better if we could\nproduce an interval that would contain the true parameter \ud835\udf03with high probability. If you\nwere interested in such ideas a century ago, then you would have been excited to read\n\u201cOutlineofaTheoryofStatisticalEstimationBasedontheClassicalTheoryofProbability\u201d\nby Jerzy Neyman ( Neyman, 1937 ), who first introduced the concept of confidence interval\nin 1937.\nTo be useful, a confidence interval should be as small as possible for a given degree of\ncertainty. Let\u2019s see how to derive it.\nDefinition\nMathematically, a confidence interval for the true parameter \ud835\udf03is an interval \ud835\udc36\ud835\udc5bthat com-\nputed from the sample data such that\n\ud835\udc43\ud835\udf03\u00b9\ud835\udc36\ud835\udc5b3\ud835\udf03\u00ba\u00151\u0000\ud835\udefc,8\ud835\udf03. (A.8)\nHere\ud835\udefc2\u00b90,1\u00ba, and 1\u0000\ud835\udefcis called the confidencelevel orcoverage of the interval. This is\nthe same\ud835\udefcas the significance level as we discussed about above.\nNote that (A.8)is about variable \ud835\udc36\ud835\udc5b, not about the fixed \ud835\udf03. To emphasize this, we write\n\ud835\udc43\ud835\udf03\u00b9\ud835\udc36\ud835\udc5b3\ud835\udf03\u00barather than\ud835\udc43\ud835\udf03\u00b9\ud835\udf032\ud835\udc36\ud835\udc5b\u00ba.\nInterpretation\nIt is very tempting to interpret a 95%confidence interval as an interval where you can be\n95%surethetrueparameterlies,howeverthisissadlynottrue. Thetrueparameterisfixed,\nand it is the interval that is random. Thus a better interpretation would be to say that if you\ngenerated a large number of confidence intervals by this procedure, 95%of the generated\nintervals would contain the true parameter.\nThismayseempedantic,butitcanhaverealimplicationsfortheinterpretationoftheresults.\nIn particular, we may satisfy (A.8)by constructing intervals that we are almost certain do\nnot contain the true value, as long as we only do so rarely enough. We close this section by\n1017 Statistics\nproviding three tempting but false statements. An in-depth discussion of these points can\nbe found in Morey etal.(2016).\n\u000fFallacy1 . Narrow confidence intervals mean we can estimate the parameter precisely.\n\u000fFallacy2 . The values inside the confidence interval are more likely to be the true value\nthan those outside the interval.\n\u000fFallacy 3 . The probability that a particular observed 95%confidence interval contains\nthe true value is 95%.\nSufficed to say, confidence intervals are subtle objects. However, if you keep the interpre-\ntation clear, they can be powerful tools.\nA Gaussian Example\nLet\u2019sdiscussthemostclassicalexample,theconfidenceintervalforthemeanofaGaussian\nof unknown mean and variance. Suppose we collect \ud835\udc5bsamplesf\ud835\udc65\ud835\udc56g\ud835\udc5b\n\ud835\udc56=1from our Gaussian\nN\u00b9\ud835\udf07,\ud835\udf0e2\u00ba.", "mimetype": "text/plain", "start_char_idx": 2078389, "end_char_idx": 2081856, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e9ff621c-e2eb-49dc-9dc2-2a277fbade30": {"__data__": {"id_": "e9ff621c-e2eb-49dc-9dc2-2a277fbade30", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e873e8c9-399d-4443-b06f-f882a35f7d1c", "node_type": "1", "metadata": {}, "hash": "58ff78eb09d7cca8b0e88547e3016790467f42c80e35a99d1ed765da61658e82", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "156d97e3-ce98-419c-8505-975d5e2bd61a", "node_type": "1", "metadata": {}, "hash": "ee6b59d4faf5c8aedf48c916e0ae14e501b6a2db6c0e88865ed321eae993a634", "class_name": "RelatedNodeInfo"}}, "text": "An in-depth discussion of these points can\nbe found in Morey etal.(2016).\n\u000fFallacy1 . Narrow confidence intervals mean we can estimate the parameter precisely.\n\u000fFallacy2 . The values inside the confidence interval are more likely to be the true value\nthan those outside the interval.\n\u000fFallacy 3 . The probability that a particular observed 95%confidence interval contains\nthe true value is 95%.\nSufficed to say, confidence intervals are subtle objects. However, if you keep the interpre-\ntation clear, they can be powerful tools.\nA Gaussian Example\nLet\u2019sdiscussthemostclassicalexample,theconfidenceintervalforthemeanofaGaussian\nof unknown mean and variance. Suppose we collect \ud835\udc5bsamplesf\ud835\udc65\ud835\udc56g\ud835\udc5b\n\ud835\udc56=1from our Gaussian\nN\u00b9\ud835\udf07,\ud835\udf0e2\u00ba. We can compute estimators for the mean and variance by taking\n\u02c6\ud835\udf07\ud835\udc5b=1\n\ud835\udc5b\ud835\udc5b\u00d5\n\ud835\udc56=1\ud835\udc65\ud835\udc56and \u02c6\ud835\udf0e2\n\ud835\udc5b=1\n\ud835\udc5b\u00001\ud835\udc5b\u00d5\n\ud835\udc56=1\u00b9\ud835\udc65\ud835\udc56\u0000\u02c6\ud835\udf07\u00ba2. (A.9)\nIf we now consider the random variable\n\ud835\udc47=\u02c6\ud835\udf07\ud835\udc5b\u0000\ud835\udf07\n\u02c6\ud835\udf0e\ud835\udc5b\u009dp\ud835\udc5b, (A.10)\nwe obtain a random variable following a well-known distribution called the Student\u2019s t-\ndistributionon \ud835\udc5b\u00001degreesof freedom .\nThis distribution is very well studied, and it is known, for instance, that as \ud835\udc5b!1, it is\napproximately a standard Gaussian, and thus by looking up values of the Gaussian c.d.f. in\na table, we may conclude that the value of \ud835\udc47is in the interval\u00bb\u00001.96,1.96\u00bcat least 95%\nof the time. For finite values of \ud835\udc5b, the interval needs to be somewhat larger, but are well\nknown and precomputed in tables.\nThus, we may conclude that for large \ud835\udc5b,\n\ud835\udc43\u0012\u02c6\ud835\udf07\ud835\udc5b\u0000\ud835\udf07\n\u02c6\ud835\udf0e\ud835\udc5b\u009dp\ud835\udc5b2\u00bb\u0000 1.96,1.96\u00bc\u0013\n\u00150.95. (A.11)\nRearrangingthisbymultiplyingbothsidesby \u02c6\ud835\udf0e\ud835\udc5b\u009dp\ud835\udc5bandthenadding \u02c6\ud835\udf07\ud835\udc5b,weobtain\n\ud835\udc43\u0012\n\ud835\udf072\u0014\n\u02c6\ud835\udf07\ud835\udc5b\u00001.96\u02c6\ud835\udf0e\ud835\udc5bp\ud835\udc5b,\u02c6\ud835\udf07\ud835\udc5b\u00b81.96\u02c6\ud835\udf0e\ud835\udc5bp\ud835\udc5b\u0015\u0013\n\u00150.95. (A.12)\nThus we know that we have found our 95%confidence interval:\n\u0014\n\u02c6\ud835\udf07\ud835\udc5b\u00001.96\u02c6\ud835\udf0e\ud835\udc5bp\ud835\udc5b,\u02c6\ud835\udf07\ud835\udc5b\u00b81.96\u02c6\ud835\udf0e\ud835\udc5bp\ud835\udc5b\u0015\n. (A.13)\nIt is safe to say that (A.13 )is one of the most used formula in statistics. Let\u2019s close our\n1018 Mathematics for Deep Learning\ndiscussion of statisticsbyimplementing it. Forsimplicity, weassume we are in the asymp-\ntotic regime. Small values of \ud835\udc41should include the correct value of t_starobtained either\nprogrammatically or from a \ud835\udc61-table.\n# PyTorch uses Bessel's correction by default, which means the use of ddof=1\n# instead of default ddof=0 in numpy. We can use unbiased=False to imitate\n# ddof=0.\n# Number of samples\nN=1000\n# Sample dataset\nsamples =torch .normal( 0,1, size =(N,))\n# Lookup Students's t-distribution c.d.f.", "mimetype": "text/plain", "start_char_idx": 2081136, "end_char_idx": 2083489, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "156d97e3-ce98-419c-8505-975d5e2bd61a": {"__data__": {"id_": "156d97e3-ce98-419c-8505-975d5e2bd61a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e9ff621c-e2eb-49dc-9dc2-2a277fbade30", "node_type": "1", "metadata": {}, "hash": "c6b1ee82eaad661e5b9a88de0b35f3fdb442a646ab2d54e7858ca5cec83c311c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "584584aa-5565-408f-a4d5-c55faea49732", "node_type": "1", "metadata": {}, "hash": "390291d7ca721d04fefaef4865b3cf7600c7d9321760e044b1c0e4fa5bfcbe44", "class_name": "RelatedNodeInfo"}}, "text": "(A.13)\nIt is safe to say that (A.13 )is one of the most used formula in statistics. Let\u2019s close our\n1018 Mathematics for Deep Learning\ndiscussion of statisticsbyimplementing it. Forsimplicity, weassume we are in the asymp-\ntotic regime. Small values of \ud835\udc41should include the correct value of t_starobtained either\nprogrammatically or from a \ud835\udc61-table.\n# PyTorch uses Bessel's correction by default, which means the use of ddof=1\n# instead of default ddof=0 in numpy. We can use unbiased=False to imitate\n# ddof=0.\n# Number of samples\nN=1000\n# Sample dataset\nsamples =torch .normal( 0,1, size =(N,))\n# Lookup Students's t-distribution c.d.f.\nt_star =1.96\n# Construct interval\nmu_hat =torch .mean(samples)\nsigma_hat =samples .std(unbiased =True )\n(mu_hat -t_star *sigma_hat /torch .sqrt(torch .tensor(N, dtype =torch .float32)),\\\nmu_hat +t_star *sigma_hat /torch .sqrt(torch .tensor(N, dtype =torch .float32)))\n(tensor( -0.0568 ), tensor( 0.0704 ))\nA.10.4Summary\n\u000fStatistics focuses on inference problems, whereas deep learning emphasizes on making\naccurate predictions without explicitly programming and understanding.\n\u000fTherearethreecommonstatisticsinferencemethods: evaluatingandcomparingestima-\ntors, conducting hypothesis tests, and constructing confidence intervals.\n\u000fThere are three most common estimators: statistical bias, standard deviation, and mean\nsquare error.\n\u000fA confidence interval is an estimated range of a true population parameter that we can\nconstruct by given the samples.\n\u000fHypothesis testing is a way of evaluating some evidence against the default statement\nabout a population.\nA.10.5Exercises\n1.Let\ud835\udc4b1,\ud835\udc4b2,...,\ud835\udc4b\ud835\udc5biid\u0018Unif\u00b90,\ud835\udf03\u00ba, where \u201ciid\u201d stands for independent and identically\ndistributed . Consider the following estimators of \ud835\udf03:\n\u02c6\ud835\udf03=maxf\ud835\udc4b1,\ud835\udc4b2,...,\ud835\udc4b\ud835\udc5bg; (A.14)\n\u02dc\ud835\udf03=2\u00af\ud835\udc4b\ud835\udc5b=2\n\ud835\udc5b\ud835\udc5b\u00d5\n\ud835\udc56=1\ud835\udc4b\ud835\udc56. (A.15)\n1019 Information Theory\n289\u000fFind the statistical bias, standard deviation, and mean square error of \u02c6\ud835\udf03.\n\u000fFind the statistical bias, standard deviation, and mean square error of \u02dc\ud835\udf03.\n\u000fWhich estimator is better?\n2.For our chemist example in introduction, can you derive the 5 steps to conduct a two-\nsided hypothesis testing? Given the statistical significance level \ud835\udefc=0.05and the sta-\ntistical power 1\u0000\ud835\udefd=0.8.\n3.Run the confidence interval code with \ud835\udc41=2and\ud835\udefc=0.5for100independently gener-\nated dataset, and plot the resulting intervals (in this case t_star = 1.0 ). You will see\nseveral very short intervals which are very far from containing the true mean 0. Does\nthis contradict the interpretation of the confidence interval? Do you feel comfortable\nusing short intervals to indicate high precision estimates?\nDiscussions289.\nA.11InformationTheory\nThe universe is overflowing with information. Information provides a common language\nacrossdisciplinaryrifts: fromShakespeare\u2019sSonnettoresearchers\u2019paperonCornellArXiv,\nfrom Van Gogh\u2019s printing Starry Night to Beethoven\u2019s music Symphony No. 5, from the\nfirstprogramminglanguagePlankalk\u00fcltothestate-of-the-artmachinelearningalgorithms.\nEverything must follow the rules of information theory, no matter the format. With infor-\nmation theory, we can measure and compare how much information is present in different\nsignals. Inthissection, wewillinvestigatethefundamentalconceptsofinformationtheory\nand applications of information theory in machine learning.\nBefore we get started, let\u2019s outline the relationship between machine learning and informa-\ntiontheory. Machinelearningaimstoextractinterestingsignalsfromdataandmakecritical\npredictions. On the other hand, information theory studies encoding, decoding, transmit-\nting, and manipulating information. As a result, information theory provides fundamental\nlanguagefordiscussingtheinformationprocessinginmachinelearnedsystems. Forexam-\nple, many machine learning applications use the cross-entropy loss as described in Section\n4.1.", "mimetype": "text/plain", "start_char_idx": 2082853, "end_char_idx": 2086684, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "584584aa-5565-408f-a4d5-c55faea49732": {"__data__": {"id_": "584584aa-5565-408f-a4d5-c55faea49732", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "156d97e3-ce98-419c-8505-975d5e2bd61a", "node_type": "1", "metadata": {}, "hash": "ee6b59d4faf5c8aedf48c916e0ae14e501b6a2db6c0e88865ed321eae993a634", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3f4d0360-f30c-4fb8-842f-be8d521262e2", "node_type": "1", "metadata": {}, "hash": "049d35c886f574e31ed61fa6fe9d03bb8b3b7c448b8b2f09f803662de7d8bcf7", "class_name": "RelatedNodeInfo"}}, "text": "5, from the\nfirstprogramminglanguagePlankalk\u00fcltothestate-of-the-artmachinelearningalgorithms.\nEverything must follow the rules of information theory, no matter the format. With infor-\nmation theory, we can measure and compare how much information is present in different\nsignals. Inthissection, wewillinvestigatethefundamentalconceptsofinformationtheory\nand applications of information theory in machine learning.\nBefore we get started, let\u2019s outline the relationship between machine learning and informa-\ntiontheory. Machinelearningaimstoextractinterestingsignalsfromdataandmakecritical\npredictions. On the other hand, information theory studies encoding, decoding, transmit-\nting, and manipulating information. As a result, information theory provides fundamental\nlanguagefordiscussingtheinformationprocessinginmachinelearnedsystems. Forexam-\nple, many machine learning applications use the cross-entropy loss as described in Section\n4.1. This loss can be directly derived from information theoretic considerations.\nA.11.1Information\nLet\u2019s start with the \u201csoul\u201d of information theory: information. Information can be encoded\nin anything with a particular sequence of one or more encoding formats. Suppose that we\ntask ourselves with trying to define a notion of information. What could be our starting\npoint?\nConsider the following thought experiment. We have a friend with a deck of cards. They\n1020 Mathematics for Deep Learning\nwill shuffle the deck, flip over some cards, and tell us statements about the cards. We will\ntry to assess the information content of each statement.\nFirst, they flip over a card and tell us, \u201cI see a card.\u201d This provides us with no information\nat all. We were already certain that this was the case so we hope the information should be\nzero.\nNext, they flip over a card and say, \u201cI see a heart.\u201d This provides us some information,\nbut in reality there are only 4different suits that were possible, each equally likely, so we\nare not surprised by this outcome. We hope that whatever the measure of information, this\nevent should have low information content.\nNext, they flip over a card and say, \u201cThis is the 3of spades.\u201d This is more information.\nIndeed there were 52equally likely possible outcomes, and our friend told us which one it\nwas. This should be a medium amount of information.\nLet\u2019stakethistothelogicalextreme. Supposethatfinallytheyflipovereverycardfromthe\ndeck and read off the entire sequence of the shuffled deck. There are 52!different orders\nto the deck, again all equally likely, so we need a lot of information to know which one it\nis.\nAny notion of information we develop must conform to this intuition. Indeed, in the next\nsections we will learn how to compute that these events have 0bits, 2bits, 5.7bits, and\n225.6bits of information respectively.\nIf we read through these thought experiments, we see a natural idea. As a starting point,\nrather than caring about the knowledge, we may build off the idea that information repre-\nsentsthedegreeofsurpriseortheabstractpossibilityoftheevent. Forexample, ifwewant\nto describe an unusual event, we need a lot information. For a common event, we may not\nneed much information.\nIn 1948, Claude E. Shannon published A Mathematical Theory of Communication (Shan-\nnon, 1948 ) establishing the theory of information. In his article, Shannon introduced the\nconcept of information entropy for the first time. We will begin our journey here.\nSelf-information\nSince information embodies the abstract possibility of an event, how do we map the pos-\nsibility to the number of bits? Shannon introduced the terminology bitas the unit of in-\nformation, which was originally created by John Tukey. So what is a \u201cbit\u201d and why do we\nuse it to measure information? Historically, an antique transmitter can onlysend or receive\ntwo types of code: 0and1. Indeed, binary encoding is still in common use on all modern\ndigital computers. In this way, any information is encoded by a series of 0and 1. And\nhence, a series of binary digits of length \ud835\udc5bcontains\ud835\udc5bbits of information.\nNow, suppose that for any series of codes, each 0or1occurs with a probability of1\n2.\nHence, an event \ud835\udc4bwith a series of codes of length \ud835\udc5b, occurs with a probability of1\n2\ud835\udc5b. At\nthe same time, as we mentioned before, this series contains \ud835\udc5bbits of information.", "mimetype": "text/plain", "start_char_idx": 2085744, "end_char_idx": 2090056, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3f4d0360-f30c-4fb8-842f-be8d521262e2": {"__data__": {"id_": "3f4d0360-f30c-4fb8-842f-be8d521262e2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "584584aa-5565-408f-a4d5-c55faea49732", "node_type": "1", "metadata": {}, "hash": "390291d7ca721d04fefaef4865b3cf7600c7d9321760e044b1c0e4fa5bfcbe44", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0764d31f-4fe2-4a66-bfe5-ff3aa150d2b8", "node_type": "1", "metadata": {}, "hash": "67ceed14b6a222315838a2d75c18dbe80715296da7ff8ad905dae76c49462461", "class_name": "RelatedNodeInfo"}}, "text": "So what is a \u201cbit\u201d and why do we\nuse it to measure information? Historically, an antique transmitter can onlysend or receive\ntwo types of code: 0and1. Indeed, binary encoding is still in common use on all modern\ndigital computers. In this way, any information is encoded by a series of 0and 1. And\nhence, a series of binary digits of length \ud835\udc5bcontains\ud835\udc5bbits of information.\nNow, suppose that for any series of codes, each 0or1occurs with a probability of1\n2.\nHence, an event \ud835\udc4bwith a series of codes of length \ud835\udc5b, occurs with a probability of1\n2\ud835\udc5b. At\nthe same time, as we mentioned before, this series contains \ud835\udc5bbits of information. So, can\n1021 Information Theory\nwegeneralizetoamathematicalfunctionwhichcantransfertheprobability \ud835\udc5dtothenumber\nof bits? Shannon gave the answer by defining self-information\n\ud835\udc3c\u00b9\ud835\udc4b\u00ba=\u0000log2\u00b9\ud835\udc5d\u00ba, (A.1)\nas thebitsof information we have received for this event \ud835\udc4b. Note that we will always use\nbase-2logarithmsinthissection. Forthesakeofsimplicity,therestofthissectionwillomit\nthe subscript 2 in the logarithm notation, i.e., log\u00b9.\u00baalways refers to log2\u00b9.\u00ba. For example,\nthe code \u201c0010\u201d has a self-information\n\ud835\udc3c\u00b9\u201d0010\u201d\u00ba=\u0000log\u00b9\ud835\udc5d\u00b9\u201d0010\u201d\u00ba\u00ba=\u0000log\u00121\n24\u0013\n=4bits. (A.2)\nWe can calculate self information as shown below. Before that, let\u2019s first import all the\nnecessary packages in this section.\nimport torch\nfrom torch .nnimport NLLLoss\ndef nansum (x):\n# Define nansum, as pytorch does not offer it inbuilt.\nreturn x[~torch .isnan(x)] .sum()\ndef self_information (p):\nreturn -torch .log2(torch .tensor(p)) .item()\nself_information( 1/64)\n6.0\nA.11.2Entropy\nAs self-information only measures the information of a single discrete event, we need a\nmore generalized measure for any random variable of either discrete or continuous distri-\nbution.\nMotivatingEntropy\nLet\u2019strytogetspecificaboutwhatwewant. Thiswillbeaninformalstatementofwhatare\nknown as the axioms of Shannon entropy . It will turn out that the following collection of\ncommon-sense statements force us to a unique definition of information. A formal version\nof these axioms, along with several others may be found in Csisz\u00e1r ( 2008).\n1.The information we gain by observing a random variable does not depend on what we\ncall the elements, or the presence of additional elements which have probability zero.\n2.The information we gain by observing two random variables is no more than the sum\nof the information we gain by observing them separately. If they are independent, then\nit is exactly the sum.\n1022 Mathematics for Deep Learning\n3.The information gained when observing (nearly) certain events is (nearly) zero.\nWhile proving this fact is beyond the scope of our text, it is important to know that this\nuniquely determines the form that entropy must take. The only ambiguity that these allow\nisinthechoiceoffundamentalunits, whichismostoftennormalizedbymakingthechoice\nwe saw before that the information provided by a single fair coin flip is one bit.\nDefinition\nFor any random variable \ud835\udc4bthat follows a probability distribution \ud835\udc43with a probability den-\nsityfunction(p.d.f.) oraprobabilitymassfunction(p.m.f.) \ud835\udc5d\u00b9\ud835\udc65\u00ba,wemeasuretheexpected\namount of information through entropy(orShannonentropy )\n\ud835\udc3b\u00b9\ud835\udc4b\u00ba=\u0000\ud835\udc38\ud835\udc65\u0018\ud835\udc43\u00bblog\ud835\udc5d\u00b9\ud835\udc65\u00ba\u00bc. (A.3)\nTo be specific, if \ud835\udc4bis discrete,\n\ud835\udc3b\u00b9\ud835\udc4b\u00ba=\u0000\u00d5\n\ud835\udc56\ud835\udc5d\ud835\udc56log\ud835\udc5d\ud835\udc56, where\ud835\udc5d\ud835\udc56=\ud835\udc43\u00b9\ud835\udc4b\ud835\udc56\u00ba.(A.4)\nOtherwise, if \ud835\udc4bis continuous, we also refer entropy as differentialentropy\n\ud835\udc3b\u00b9\ud835\udc4b\u00ba=\u0000\u00b9\n\ud835\udc65\ud835\udc5d\u00b9\ud835\udc65\u00balog\ud835\udc5d\u00b9\ud835\udc65\u00ba\ud835\udc51\ud835\udc65.", "mimetype": "text/plain", "start_char_idx": 2089428, "end_char_idx": 2092789, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0764d31f-4fe2-4a66-bfe5-ff3aa150d2b8": {"__data__": {"id_": "0764d31f-4fe2-4a66-bfe5-ff3aa150d2b8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3f4d0360-f30c-4fb8-842f-be8d521262e2", "node_type": "1", "metadata": {}, "hash": "049d35c886f574e31ed61fa6fe9d03bb8b3b7c448b8b2f09f803662de7d8bcf7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d7068396-4c09-4337-8426-002717e9737a", "node_type": "1", "metadata": {}, "hash": "ae59feb999b31e603e8b4ea19ed35803eec2c5313bc20aa81db4e9fc9165fda3", "class_name": "RelatedNodeInfo"}}, "text": "oraprobabilitymassfunction(p.m.f.) \ud835\udc5d\u00b9\ud835\udc65\u00ba,wemeasuretheexpected\namount of information through entropy(orShannonentropy )\n\ud835\udc3b\u00b9\ud835\udc4b\u00ba=\u0000\ud835\udc38\ud835\udc65\u0018\ud835\udc43\u00bblog\ud835\udc5d\u00b9\ud835\udc65\u00ba\u00bc. (A.3)\nTo be specific, if \ud835\udc4bis discrete,\n\ud835\udc3b\u00b9\ud835\udc4b\u00ba=\u0000\u00d5\n\ud835\udc56\ud835\udc5d\ud835\udc56log\ud835\udc5d\ud835\udc56, where\ud835\udc5d\ud835\udc56=\ud835\udc43\u00b9\ud835\udc4b\ud835\udc56\u00ba.(A.4)\nOtherwise, if \ud835\udc4bis continuous, we also refer entropy as differentialentropy\n\ud835\udc3b\u00b9\ud835\udc4b\u00ba=\u0000\u00b9\n\ud835\udc65\ud835\udc5d\u00b9\ud835\udc65\u00balog\ud835\udc5d\u00b9\ud835\udc65\u00ba\ud835\udc51\ud835\udc65. (A.5)\nWe can define entropy as below.\ndef entropy (p):\nentropy =-p*torch .log2(p)\n# Operator `nansum` will sum up the non-nan number\nout =nansum(entropy)\nreturn out\nentropy(torch .tensor([ 0.1,0.5,0.1,0.3]))\ntensor( 1.6855 )\nInterpretations\nYou may be curious: in the entropy definition (A.3), why do we use an expectation of a\nnegative logarithm? Here are some intuitions.\nFirst, why do we use a logarithm function log? Suppose that \ud835\udc5d\u00b9\ud835\udc65\u00ba=\ud835\udc531\u00b9\ud835\udc65\u00ba\ud835\udc532\u00b9\ud835\udc65\u00ba..., \ud835\udc53\ud835\udc5b\u00b9\ud835\udc65\u00ba,\nwhereeachcomponentfunction \ud835\udc53\ud835\udc56\u00b9\ud835\udc65\u00baisindependentfromeachother. Thismeansthateach\n\ud835\udc53\ud835\udc56\u00b9\ud835\udc65\u00bacontributes independently to the total information obtained from \ud835\udc5d\u00b9\ud835\udc65\u00ba. As discussed\nabove, we want the entropy formula to be additive over independent random variables.\nLuckily, logcan naturally turn a product of probability distributions to a summation of the\nindividual terms.\nNext, why do we use a negative log? Intuitively, more frequent events should contain less\n1023 Information Theory\ninformation than less common events, since we often gain more information from an un-\nusual case than from an ordinary one. However, logis monotonically increasing with the\nprobabilities, and indeed negative for all values in \u00bb0,1\u00bc. We need to construct a monoton-\nically decreasing relationship between the probability of events and their entropy, which\nwill ideally be always positive (for nothing we observe should force us to forget what we\nhave known). Hence, we add a negative sign in front of logfunction.\nLast, where does the expectation function come from? Consider a random variable \ud835\udc4b. We\ncan interpret the self-information ( \u0000log\u00b9\ud835\udc5d\u00ba) as the amount of surprise we have at seeing\na particular outcome. Indeed, as the probability approaches zero, the surprise becomes\ninfinite. Similarly, we can interpret the entropy as the average amount of surprise from\nobserving\ud835\udc4b. For example, imagine that a slot machine system emits statistical indepen-\ndently symbols \ud835\udc601,...,\ud835\udc60\ud835\udc58with probabilities \ud835\udc5d1,...,\ud835\udc5d\ud835\udc58respectively. Then the entropy of\nthis system equals to the average self-information from observing each output, i.e.,\n\ud835\udc3b\u00b9\ud835\udc46\u00ba=\u00d5\n\ud835\udc56\ud835\udc5d\ud835\udc56\u0001\ud835\udc3c\u00b9\ud835\udc60\ud835\udc56\u00ba=\u0000\u00d5\n\ud835\udc56\ud835\udc5d\ud835\udc56\u0001log\ud835\udc5d\ud835\udc56.(A.6)\nPropertiesof Entropy\nBy the above examples and interpretations, we can derive the following properties of en-\ntropy (A.3). Here, we refer to \ud835\udc4bas an event and \ud835\udc43as the probability distribution of\n\ud835\udc4b.\n\u000f\ud835\udc3b\u00b9\ud835\udc4b\u00ba\u00150for all discrete \ud835\udc4b(entropy can be negative for continuous \ud835\udc4b).\n\u000fIf\ud835\udc4b\u0018\ud835\udc43with a p.d.f. or a p.m.f. \ud835\udc5d\u00b9\ud835\udc65\u00ba, and we try to estimate \ud835\udc43by a new probability\ndistribution\ud835\udc44with a p.d.f. or a p.m.f.", "mimetype": "text/plain", "start_char_idx": 2092475, "end_char_idx": 2095273, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d7068396-4c09-4337-8426-002717e9737a": {"__data__": {"id_": "d7068396-4c09-4337-8426-002717e9737a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0764d31f-4fe2-4a66-bfe5-ff3aa150d2b8", "node_type": "1", "metadata": {}, "hash": "67ceed14b6a222315838a2d75c18dbe80715296da7ff8ad905dae76c49462461", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c6885a3e-29ff-486f-b06e-9139dce5c533", "node_type": "1", "metadata": {}, "hash": "aae009a36749e87125faebcd4a915ced1eb5d8919cfc041d2cfd0f9526286cc4", "class_name": "RelatedNodeInfo"}}, "text": "(A.6)\nPropertiesof Entropy\nBy the above examples and interpretations, we can derive the following properties of en-\ntropy (A.3). Here, we refer to \ud835\udc4bas an event and \ud835\udc43as the probability distribution of\n\ud835\udc4b.\n\u000f\ud835\udc3b\u00b9\ud835\udc4b\u00ba\u00150for all discrete \ud835\udc4b(entropy can be negative for continuous \ud835\udc4b).\n\u000fIf\ud835\udc4b\u0018\ud835\udc43with a p.d.f. or a p.m.f. \ud835\udc5d\u00b9\ud835\udc65\u00ba, and we try to estimate \ud835\udc43by a new probability\ndistribution\ud835\udc44with a p.d.f. or a p.m.f. \ud835\udc5e\u00b9\ud835\udc65\u00ba, then\n\ud835\udc3b\u00b9\ud835\udc4b\u00ba=\u0000\ud835\udc38\ud835\udc65\u0018\ud835\udc43\u00bblog\ud835\udc5d\u00b9\ud835\udc65\u00ba\u00bc\u0014\u0000\ud835\udc38\ud835\udc65\u0018\ud835\udc43\u00bblog\ud835\udc5e\u00b9\ud835\udc65\u00ba\u00bc,with equality if and only if \ud835\udc43=\ud835\udc44.\n(A.7)\nAlternatively, \ud835\udc3b\u00b9\ud835\udc4b\u00bagives a lower bound of the average number of bits needed to\nencode symbols drawn from \ud835\udc43.\n\u000fIf\ud835\udc4b\u0018\ud835\udc43,then\ud835\udc65conveysthemaximumamountofinformationifitspreadsevenlyamong\nall possible outcomes. Specifically, if the probability distribution \ud835\udc43is discrete with\n\ud835\udc58-classf\ud835\udc5d1,...,\ud835\udc5d\ud835\udc58g, then\n\ud835\udc3b\u00b9\ud835\udc4b\u00ba\u0014log\u00b9\ud835\udc58\u00ba,with equality if and only if \ud835\udc5d\ud835\udc56=1\n\ud835\udc58,8\ud835\udc56. (A.8)\nIf\ud835\udc43isacontinuousrandomvariable,thenthestorybecomesmuchmorecomplicated.\nHowever, if we additionally impose that \ud835\udc43is supported on a finite interval (with all\nvaluesbetween 0and1),then\ud835\udc43hasthehighestentropyifitistheuniformdistribution\non that interval.\nA.11.3MutualInformation\nPreviously we defined entropy of a single random variable \ud835\udc4b, how about the entropy of a\npair random variables \u00b9\ud835\udc4b,\ud835\udc4c\u00ba? We can think of these techniques as trying to answer the\n1024 Mathematics for Deep Learning\nfollowing type of question, \u201cWhat information is contained in \ud835\udc4band\ud835\udc4ctogether compared\nto each separately? Is there redundant information, or is it all unique?\u201d\nForthefollowingdiscussion,wealwaysuse \u00b9\ud835\udc4b,\ud835\udc4c\u00baasapairofrandomvariablesthatfollows\na joint probability distribution \ud835\udc43with a p.d.f. or a p.m.f. \ud835\udc5d\ud835\udc4b,\ud835\udc4c\u00b9\ud835\udc65,\ud835\udc66\u00ba, while\ud835\udc4band\ud835\udc4cfollow\nprobability distribution \ud835\udc5d\ud835\udc4b\u00b9\ud835\udc65\u00baand\ud835\udc5d\ud835\udc4c\u00b9\ud835\udc66\u00ba, respectively.\nJointEntropy\nSimilar to entropy of a single random variable (A.3), we define the joint entropy \ud835\udc3b\u00b9\ud835\udc4b,\ud835\udc4c\u00ba\nof a pair random variables \u00b9\ud835\udc4b,\ud835\udc4c\u00baas\n\ud835\udc3b\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=\u0000\ud835\udc38\u00b9\ud835\udc65,\ud835\udc66\u00ba\u0018\ud835\udc43\u00bblog\ud835\udc5d\ud835\udc4b,\ud835\udc4c\u00b9\ud835\udc65,\ud835\udc66\u00ba\u00bc. (A.9)\nPrecisely, on the one hand, if \u00b9\ud835\udc4b,\ud835\udc4c\u00bais a pair of discrete random variables, then\n\ud835\udc3b\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=\u0000\u00d5\n\ud835\udc65\u00d5\n\ud835\udc66\ud835\udc5d\ud835\udc4b,\ud835\udc4c\u00b9\ud835\udc65,\ud835\udc66\u00balog\ud835\udc5d\ud835\udc4b,\ud835\udc4c\u00b9\ud835\udc65,\ud835\udc66\u00ba.(A.10)\nOn the other hand, if \u00b9\ud835\udc4b,\ud835\udc4c\u00bais a pair of continuous random variables, then we define the\ndifferentialjoint entropy as\n\ud835\udc3b\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=\u0000\u00b9\n\ud835\udc65,\ud835\udc66\ud835\udc5d\ud835\udc4b,\ud835\udc4c\u00b9\ud835\udc65,\ud835\udc66\u00balog\ud835\udc5d\ud835\udc4b,\ud835\udc4c\u00b9\ud835\udc65,\ud835\udc66\u00ba\ud835\udc51\ud835\udc65 \ud835\udc51\ud835\udc66. (A.11)\nWe can think of (A.9)as telling us the total randomness in the pair of random variables.", "mimetype": "text/plain", "start_char_idx": 2094880, "end_char_idx": 2097123, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c6885a3e-29ff-486f-b06e-9139dce5c533": {"__data__": {"id_": "c6885a3e-29ff-486f-b06e-9139dce5c533", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d7068396-4c09-4337-8426-002717e9737a", "node_type": "1", "metadata": {}, "hash": "ae59feb999b31e603e8b4ea19ed35803eec2c5313bc20aa81db4e9fc9165fda3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "13883e49-d4bf-4844-9ac2-3ada0487ca28", "node_type": "1", "metadata": {}, "hash": "3fd0dd35b9c10608fadbc7d45ff218f3accd9b574ccc3e3a1c1bbdc61aa8fe06", "class_name": "RelatedNodeInfo"}}, "text": "(A.10)\nOn the other hand, if \u00b9\ud835\udc4b,\ud835\udc4c\u00bais a pair of continuous random variables, then we define the\ndifferentialjoint entropy as\n\ud835\udc3b\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=\u0000\u00b9\n\ud835\udc65,\ud835\udc66\ud835\udc5d\ud835\udc4b,\ud835\udc4c\u00b9\ud835\udc65,\ud835\udc66\u00balog\ud835\udc5d\ud835\udc4b,\ud835\udc4c\u00b9\ud835\udc65,\ud835\udc66\u00ba\ud835\udc51\ud835\udc65 \ud835\udc51\ud835\udc66. (A.11)\nWe can think of (A.9)as telling us the total randomness in the pair of random variables.\nAs a pair of extremes, if \ud835\udc4b=\ud835\udc4care two identical random variables, then the information in\nthe pair is exactly the information in one and we have \ud835\udc3b\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=\ud835\udc3b\u00b9\ud835\udc4b\u00ba=\ud835\udc3b\u00b9\ud835\udc4c\u00ba. On the\nother extreme, if \ud835\udc4band\ud835\udc4care independent then \ud835\udc3b\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=\ud835\udc3b\u00b9\ud835\udc4b\u00ba\u00b8\ud835\udc3b\u00b9\ud835\udc4c\u00ba. Indeed we will\nalways have that the information contained in a pair of random variables is no smaller than\nthe entropy of either random variable and no more than the sum of both.\n\ud835\udc3b\u00b9\ud835\udc4b\u00ba,\ud835\udc3b\u00b9\ud835\udc4c\u00ba\u0014\ud835\udc3b\u00b9\ud835\udc4b,\ud835\udc4c\u00ba\u0014\ud835\udc3b\u00b9\ud835\udc4b\u00ba\u00b8\ud835\udc3b\u00b9\ud835\udc4c\u00ba. (A.12)\nLet\u2019s implement joint entropy from scratch.\ndef joint_entropy (p_xy):\njoint_ent =-p_xy *torch .log2(p_xy)\n# Operator `nansum` will sum up the non-nan number\nout =nansum(joint_ent)\nreturn out\njoint_entropy(torch .tensor([[ 0.1,0.5], [ 0.1,0.3]]))\ntensor( 1.6855 )\nNotice that this is the same codeas before, but now we interpret it differently as working\non the joint distribution of the two random variables.\n1025 Information Theory\nConditionalEntropy\nThe joint entropy defined above the amount of information contained in a pair of random\nvariables. This is useful, but oftentimes it is not what we care about. Consider the setting\nofmachinelearning. Let\u2019stake \ud835\udc4btobetherandomvariable(orvectorofrandomvariables)\nthat describes the pixel values of an image, and \ud835\udc4cto be the random variable which is the\nclass label.\ud835\udc4bshould contain substantial information\u2014a natural image is a complex thing.\nHowever, the information contained in \ud835\udc4conce the image has been show should be low.\nIndeed, the image of a digit should already contain the information about what digit it is\nunless the digit is illegible. Thus, to continue to extend our vocabulary of information\ntheory, we need to be able to reason about the information content in a random variable\nconditional on another.\nIn the probability theory, we saw the definition of the conditional probability to measure\nthe relationship between variables. We now want to analogously define the conditional\nentropy\ud835\udc3b\u00b9\ud835\udc4cj\ud835\udc4b\u00ba. We can write this as\n\ud835\udc3b\u00b9\ud835\udc4cj\ud835\udc4b\u00ba=\u0000\ud835\udc38\u00b9\ud835\udc65,\ud835\udc66\u00ba\u0018\ud835\udc43\u00bblog\ud835\udc5d\u00b9\ud835\udc66j\ud835\udc65\u00ba\u00bc, (A.13)\nwhere\ud835\udc5d\u00b9\ud835\udc66j\ud835\udc65\u00ba=\ud835\udc5d\ud835\udc4b,\ud835\udc4c\u00b9\ud835\udc65,\ud835\udc66\u00ba\n\ud835\udc5d\ud835\udc4b\u00b9\ud835\udc65\u00bais the conditional probability. Specifically, if \u00b9\ud835\udc4b,\ud835\udc4c\u00bais a pair of\ndiscrete random variables, then\n\ud835\udc3b\u00b9\ud835\udc4cj\ud835\udc4b\u00ba=\u0000\u00d5\n\ud835\udc65\u00d5\n\ud835\udc66\ud835\udc5d\u00b9\ud835\udc65,\ud835\udc66\u00balog\ud835\udc5d\u00b9\ud835\udc66j\ud835\udc65\u00ba.(A.14)\nIf\u00b9\ud835\udc4b,\ud835\udc4c\u00bais a pair of continuous random variables, then the differentialconditionalentropy\nis similarly defined as\n\ud835\udc3b\u00b9\ud835\udc4cj\ud835\udc4b\u00ba=\u0000\u00b9\n\ud835\udc65\u00b9\n\ud835\udc66\ud835\udc5d\u00b9\ud835\udc65,\ud835\udc66\u00balog\ud835\udc5d\u00b9\ud835\udc66j\ud835\udc65\u00ba\ud835\udc51\ud835\udc65 \ud835\udc51\ud835\udc66.", "mimetype": "text/plain", "start_char_idx": 2096863, "end_char_idx": 2099393, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "13883e49-d4bf-4844-9ac2-3ada0487ca28": {"__data__": {"id_": "13883e49-d4bf-4844-9ac2-3ada0487ca28", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c6885a3e-29ff-486f-b06e-9139dce5c533", "node_type": "1", "metadata": {}, "hash": "aae009a36749e87125faebcd4a915ced1eb5d8919cfc041d2cfd0f9526286cc4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "60f1423f-82db-4c2f-b9f3-02e4cdf08c1d", "node_type": "1", "metadata": {}, "hash": "29c5e5bad6fb65c0ed17981b395103b3eb887310c2fda7ec44853b30a1dc9d9d", "class_name": "RelatedNodeInfo"}}, "text": "Specifically, if \u00b9\ud835\udc4b,\ud835\udc4c\u00bais a pair of\ndiscrete random variables, then\n\ud835\udc3b\u00b9\ud835\udc4cj\ud835\udc4b\u00ba=\u0000\u00d5\n\ud835\udc65\u00d5\n\ud835\udc66\ud835\udc5d\u00b9\ud835\udc65,\ud835\udc66\u00balog\ud835\udc5d\u00b9\ud835\udc66j\ud835\udc65\u00ba.(A.14)\nIf\u00b9\ud835\udc4b,\ud835\udc4c\u00bais a pair of continuous random variables, then the differentialconditionalentropy\nis similarly defined as\n\ud835\udc3b\u00b9\ud835\udc4cj\ud835\udc4b\u00ba=\u0000\u00b9\n\ud835\udc65\u00b9\n\ud835\udc66\ud835\udc5d\u00b9\ud835\udc65,\ud835\udc66\u00balog\ud835\udc5d\u00b9\ud835\udc66j\ud835\udc65\u00ba\ud835\udc51\ud835\udc65 \ud835\udc51\ud835\udc66. (A.15)\nIt is now natural to ask, how does the conditional entropy \ud835\udc3b\u00b9\ud835\udc4cj\ud835\udc4b\u00barelate to the entropy\n\ud835\udc3b\u00b9\ud835\udc4b\u00baand the joint entropy \ud835\udc3b\u00b9\ud835\udc4b,\ud835\udc4c\u00ba? Using the definitions above, we can express this\ncleanly:\n\ud835\udc3b\u00b9\ud835\udc4cj\ud835\udc4b\u00ba=\ud835\udc3b\u00b9\ud835\udc4b,\ud835\udc4c\u00ba\u0000\ud835\udc3b\u00b9\ud835\udc4b\u00ba. (A.16)\nThis has an intuitive interpretation: the information in \ud835\udc4cgiven\ud835\udc4b(\ud835\udc3b\u00b9\ud835\udc4cj\ud835\udc4b\u00ba) is the same\nas the information in both \ud835\udc4band\ud835\udc4ctogether (\ud835\udc3b\u00b9\ud835\udc4b,\ud835\udc4c\u00ba) minus the information already con-\ntained in\ud835\udc4b. This gives us the information in \ud835\udc4cwhich is not also represented in \ud835\udc4b.\nNow, let\u2019s implement conditional entropy (A.13 )from scratch.\ndef conditional_entropy (p_xy, p_x):\np_y_given_x =p_xy /p_x\ncond_ent =-p_xy *torch .log2(p_y_given_x)\n# Operator `nansum` will sum up the non-nan number\nout =nansum(cond_ent)\nreturn out\nconditional_entropy(torch .tensor([[ 0.1,0.5], [ 0.2,0.3]]),\ntorch .tensor([ 0.2,0.8]))\n1026 Mathematics for Deep Learning\ntensor( 0.8635 )\nMutualInformation\nGiven the previous setting of random variables \u00b9\ud835\udc4b,\ud835\udc4c\u00ba, you may wonder: \u201cNow that we\nknowhowmuchinformationiscontainedin \ud835\udc4cbutnotin\ud835\udc4b,canwesimilarlyaskhowmuch\ninformation is shared between \ud835\udc4band\ud835\udc4c?\u201d The answer will be the mutual information of\n\u00b9\ud835\udc4b,\ud835\udc4c\u00ba, which we will write as \ud835\udc3c\u00b9\ud835\udc4b,\ud835\udc4c\u00ba.\nRather than diving straight into the formal definition, let\u2019s practice our intuition by first\ntrying to derive an expression for the mutual information entirely based on terms we have\nconstructed before. Wewish to find the information shared betweentwo random variables.\nOne way we could try to do this is to start with all the information contained in both \ud835\udc4band\n\ud835\udc4ctogether, and then we take off the parts that are not shared. The information contained in\nboth\ud835\udc4band\ud835\udc4ctogetheriswrittenas \ud835\udc3b\u00b9\ud835\udc4b,\ud835\udc4c\u00ba. Wewanttosubtractfromthistheinformation\ncontained in \ud835\udc4bbut not in\ud835\udc4c, and the information contained in \ud835\udc4cbut not in\ud835\udc4b. As we saw in\nthe previous section, this is given by \ud835\udc3b\u00b9\ud835\udc4bj\ud835\udc4c\u00baand\ud835\udc3b\u00b9\ud835\udc4cj\ud835\udc4b\u00barespectively. Thus, we have\nthat the mutual information should be\n\ud835\udc3c\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=\ud835\udc3b\u00b9\ud835\udc4b,\ud835\udc4c\u00ba\u0000\ud835\udc3b\u00b9\ud835\udc4cj\ud835\udc4b\u00ba\u0000\ud835\udc3b\u00b9\ud835\udc4bj\ud835\udc4c\u00ba. (A.17)\nIndeed,thisisavaliddefinitionforthemutualinformation.", "mimetype": "text/plain", "start_char_idx": 2099141, "end_char_idx": 2101368, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "60f1423f-82db-4c2f-b9f3-02e4cdf08c1d": {"__data__": {"id_": "60f1423f-82db-4c2f-b9f3-02e4cdf08c1d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "13883e49-d4bf-4844-9ac2-3ada0487ca28", "node_type": "1", "metadata": {}, "hash": "3fd0dd35b9c10608fadbc7d45ff218f3accd9b574ccc3e3a1c1bbdc61aa8fe06", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b7d42f41-0545-4504-9ac8-bb50b3841d24", "node_type": "1", "metadata": {}, "hash": "8d2ce161a82078e7b7119c2d33a7688b9a881707fc7a264133b9fdba363ef6a0", "class_name": "RelatedNodeInfo"}}, "text": "The information contained in\nboth\ud835\udc4band\ud835\udc4ctogetheriswrittenas \ud835\udc3b\u00b9\ud835\udc4b,\ud835\udc4c\u00ba. Wewanttosubtractfromthistheinformation\ncontained in \ud835\udc4bbut not in\ud835\udc4c, and the information contained in \ud835\udc4cbut not in\ud835\udc4b. As we saw in\nthe previous section, this is given by \ud835\udc3b\u00b9\ud835\udc4bj\ud835\udc4c\u00baand\ud835\udc3b\u00b9\ud835\udc4cj\ud835\udc4b\u00barespectively. Thus, we have\nthat the mutual information should be\n\ud835\udc3c\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=\ud835\udc3b\u00b9\ud835\udc4b,\ud835\udc4c\u00ba\u0000\ud835\udc3b\u00b9\ud835\udc4cj\ud835\udc4b\u00ba\u0000\ud835\udc3b\u00b9\ud835\udc4bj\ud835\udc4c\u00ba. (A.17)\nIndeed,thisisavaliddefinitionforthemutualinformation. Ifweexpandoutthedefinitions\nof these terms and combine them, a little algebra shows that this is the same as\n\ud835\udc3c\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=\ud835\udc38\ud835\udc65\ud835\udc38\ud835\udc66\u001a\n\ud835\udc5d\ud835\udc4b,\ud835\udc4c\u00b9\ud835\udc65,\ud835\udc66\u00balog\ud835\udc5d\ud835\udc4b,\ud835\udc4c\u00b9\ud835\udc65,\ud835\udc66\u00ba\n\ud835\udc5d\ud835\udc4b\u00b9\ud835\udc65\u00ba\ud835\udc5d\ud835\udc4c\u00b9\ud835\udc66\u00ba\u001b\n. (A.18)\nWe can summarize all of these relationships in image Fig. A.1 . It is an excellent test of\nintuition to see why the following statements are all also equivalent to \ud835\udc3c\u00b9\ud835\udc4b,\ud835\udc4c\u00ba.\n\u000f\ud835\udc3b\u00b9\ud835\udc4b\u00ba\u0000\ud835\udc3b\u00b9\ud835\udc4bj\ud835\udc4c\u00ba\n\u000f\ud835\udc3b\u00b9\ud835\udc4c\u00ba\u0000\ud835\udc3b\u00b9\ud835\udc4cj\ud835\udc4b\u00ba\n\u000f\ud835\udc3b\u00b9\ud835\udc4b\u00ba\u00b8\ud835\udc3b\u00b9\ud835\udc4c\u00ba\u0000\ud835\udc3b\u00b9\ud835\udc4b,\ud835\udc4c\u00ba\ntFig. A.1 Mutual information\u2019s relationship with joint entropy and conditional entropy.\nIn many ways we can think of the mutual information (A.18 )as principled extension of\ncorrelation coefficient we saw in Section A.6 . This allows us to ask not only for linear\n1027 Information Theory\nrelationships between variables, but for the maximum information shared between the two\nrandom variables of any kind.\nNow, let\u2019s implement mutual information from scratch.\ndef mutual_information (p_xy, p_x, p_y):\np=p_xy /(p_x *p_y)\nmutual =p_xy *torch .log2(p)\n# Operator `nansum` will sum up the non-nan number\nout =nansum(mutual)\nreturn out\nmutual_information(torch .tensor([[ 0.1,0.5], [ 0.1,0.3]]),\ntorch .tensor([ 0.2,0.8]), torch .tensor([[ 0.75 ,0.25 ]]))\ntensor( 0.7195 )\nProperties of Mutual Information\nRatherthanmemorizingthedefinitionofmutualinformation (A.18 ),youonlyneedtokeep\nin mind its notable properties:\n\u000fMutual information is symmetric, i.e., \ud835\udc3c\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=\ud835\udc3c\u00b9\ud835\udc4c,\ud835\udc4b\u00ba.\n\u000fMutual information is non-negative, i.e., \ud835\udc3c\u00b9\ud835\udc4b,\ud835\udc4c\u00ba\u00150.\n\u000f\ud835\udc3c\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=0if and only if \ud835\udc4band\ud835\udc4care independent. For example, if \ud835\udc4band\ud835\udc4care in-\ndependent, then knowing \ud835\udc4cdoes not give any information about \ud835\udc4band vice versa, so\ntheir mutual information is zero.\n\u000fAlternatively, if \ud835\udc4bis an invertible function of \ud835\udc4c, then\ud835\udc4cand\ud835\udc4bshare all information and\n\ud835\udc3c\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=\ud835\udc3b\u00b9\ud835\udc4c\u00ba=\ud835\udc3b\u00b9\ud835\udc4b\u00ba. (A.19)\nPointwiseMutual Information\nWhen we worked with entropy at the beginning of this chapter, we were able to provide an\ninterpretation of\u0000log\u00b9\ud835\udc5d\ud835\udc4b\u00b9\ud835\udc65\u00ba\u00baas howsurprised we were with the particular outcome.", "mimetype": "text/plain", "start_char_idx": 2100967, "end_char_idx": 2103269, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b7d42f41-0545-4504-9ac8-bb50b3841d24": {"__data__": {"id_": "b7d42f41-0545-4504-9ac8-bb50b3841d24", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "60f1423f-82db-4c2f-b9f3-02e4cdf08c1d", "node_type": "1", "metadata": {}, "hash": "29c5e5bad6fb65c0ed17981b395103b3eb887310c2fda7ec44853b30a1dc9d9d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "93f5d1aa-f126-4880-93e1-c70729984fe9", "node_type": "1", "metadata": {}, "hash": "f73ed9088a18ed22074e1f3ba28f295527043f3cf2e411ecc27b37479978a473", "class_name": "RelatedNodeInfo"}}, "text": "\u000f\ud835\udc3c\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=0if and only if \ud835\udc4band\ud835\udc4care independent. For example, if \ud835\udc4band\ud835\udc4care in-\ndependent, then knowing \ud835\udc4cdoes not give any information about \ud835\udc4band vice versa, so\ntheir mutual information is zero.\n\u000fAlternatively, if \ud835\udc4bis an invertible function of \ud835\udc4c, then\ud835\udc4cand\ud835\udc4bshare all information and\n\ud835\udc3c\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=\ud835\udc3b\u00b9\ud835\udc4c\u00ba=\ud835\udc3b\u00b9\ud835\udc4b\u00ba. (A.19)\nPointwiseMutual Information\nWhen we worked with entropy at the beginning of this chapter, we were able to provide an\ninterpretation of\u0000log\u00b9\ud835\udc5d\ud835\udc4b\u00b9\ud835\udc65\u00ba\u00baas howsurprised we were with the particular outcome. We\nmay give a similar interpretation to the logarithmic term in the mutual information, which\nis often referred to as the pointwise mutual information :\npmi\u00b9\ud835\udc65,\ud835\udc66\u00ba=log\ud835\udc5d\ud835\udc4b,\ud835\udc4c\u00b9\ud835\udc65,\ud835\udc66\u00ba\n\ud835\udc5d\ud835\udc4b\u00b9\ud835\udc65\u00ba\ud835\udc5d\ud835\udc4c\u00b9\ud835\udc66\u00ba. (A.20)\nWe can think of (A.20 )as measuring how much more or less likely the specific combina-\ntion of outcomes \ud835\udc65and\ud835\udc66are compared to what we would expect for independent random\noutcomes. Ifitislargeandpositive,thenthesetwospecificoutcomesoccurmuchmorefre-\nquentlythantheywouldcomparedtorandomchance( note: thedenominatoris \ud835\udc5d\ud835\udc4b\u00b9\ud835\udc65\u00ba\ud835\udc5d\ud835\udc4c\u00b9\ud835\udc66\u00ba\nwhich is the probability of the two outcomes were independent), whereas if it is large and\n1028 Mathematics for Deep Learning\nnegativeitrepresentsthetwooutcomeshappeningfarlessthanwewouldexpectbyrandom\nchance.\nThis allows us to interpret the mutual information (A.18 )as the average amount that we\nwere surprised to see two outcomes occurring together compared to what we would expect\nif they were independent.\nApplicationsof Mutual Information\nMutual information may be a little abstract in it pure definition, so how does it related to\nmachinelearning? Innaturallanguageprocessing, oneofthemostdifficultproblemsisthe\nambiguity resolution , or the issue of the meaning of a word being unclear from context.\nFor example, recently a headline in the news reported that \u201cAmazon is on fire\u201d. You may\nwonder whether the company Amazon has a building on fire, or the Amazon rain forest is\non fire.\nIn this case, mutual information can help us resolve this ambiguity. We first find the group\nof words that each has a relatively large mutual information with the company Amazon,\nsuch as e-commerce, technology, and online. Second, we find another group of words that\neach has a relatively large mutual information with the Amazon rain forest, such as rain,\nforest, and tropical. When we need to disambiguate \u201cAmazon\u201d, we can compare which\ngroup has more occurrence in the context of the word Amazon. In this case the article\nwould go on to describe the forest, and make the context clear.\nA.11.4Kullback\u2013LeiblerDivergence\nAs what we have discussed in Section 2.3 , we can use norms to measure distance between\ntwo points in space of any dimensionality. We would like to be able to do a similar task\nwithprobabilitydistributions. Therearemanywaystogoaboutthis,butinformationtheory\nprovides one of the nicest. We now explore the Kullback\u2013Leibler (KL) divergence , which\nprovides a way to measure if two distributions are close together or not.\nDefinition\nGiven a random variable \ud835\udc4bthat follows the probability distribution \ud835\udc43with a p.d.f. or a\np.m.f.\ud835\udc5d\u00b9\ud835\udc65\u00ba, and we estimate \ud835\udc43by another probability distribution \ud835\udc44with a p.d.f. or a\np.m.f.\ud835\udc5e\u00b9\ud835\udc65\u00ba. Then the Kullback\u2013Leibler (KL) divergence (orrelative entropy ) between\ud835\udc43\nand\ud835\udc44is\n\ud835\udc37KL\u00b9\ud835\udc43k\ud835\udc44\u00ba=\ud835\udc38\ud835\udc65\u0018\ud835\udc43\u0014\nlog\ud835\udc5d\u00b9\ud835\udc65\u00ba\n\ud835\udc5e\u00b9\ud835\udc65\u00ba\u0015\n.", "mimetype": "text/plain", "start_char_idx": 2102770, "end_char_idx": 2106029, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "93f5d1aa-f126-4880-93e1-c70729984fe9": {"__data__": {"id_": "93f5d1aa-f126-4880-93e1-c70729984fe9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b7d42f41-0545-4504-9ac8-bb50b3841d24", "node_type": "1", "metadata": {}, "hash": "8d2ce161a82078e7b7119c2d33a7688b9a881707fc7a264133b9fdba363ef6a0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9b99c536-8bf3-4bb1-bb08-81dd7f81a440", "node_type": "1", "metadata": {}, "hash": "f0c0944fe4753f22e6196985f15c11a59db5a2dfa70a12249d797a02ac16218b", "class_name": "RelatedNodeInfo"}}, "text": "We now explore the Kullback\u2013Leibler (KL) divergence , which\nprovides a way to measure if two distributions are close together or not.\nDefinition\nGiven a random variable \ud835\udc4bthat follows the probability distribution \ud835\udc43with a p.d.f. or a\np.m.f.\ud835\udc5d\u00b9\ud835\udc65\u00ba, and we estimate \ud835\udc43by another probability distribution \ud835\udc44with a p.d.f. or a\np.m.f.\ud835\udc5e\u00b9\ud835\udc65\u00ba. Then the Kullback\u2013Leibler (KL) divergence (orrelative entropy ) between\ud835\udc43\nand\ud835\udc44is\n\ud835\udc37KL\u00b9\ud835\udc43k\ud835\udc44\u00ba=\ud835\udc38\ud835\udc65\u0018\ud835\udc43\u0014\nlog\ud835\udc5d\u00b9\ud835\udc65\u00ba\n\ud835\udc5e\u00b9\ud835\udc65\u00ba\u0015\n. (A.21)\nAswiththepointwisemutualinformation (A.20 ),wecanagainprovideaninterpretationof\nthe logarithmic term: \u0000log\ud835\udc5e\u00b9\ud835\udc65\u00ba\n\ud835\udc5d\u00b9\ud835\udc65\u00ba=\u0000log\u00b9\ud835\udc5e\u00b9\ud835\udc65\u00ba\u00ba\u0000\u00b9\u0000 log\u00b9\ud835\udc5d\u00b9\ud835\udc65\u00ba\u00ba\u00bawill be large and positive\nif we see\ud835\udc65far more often under \ud835\udc43than we would expect for \ud835\udc44, and large and negative if\nwe see the outcome far less than expected. In this way, we can interpret it as our relative\nsurprise at observing the outcome compared to how surprised we would be observing it\nfrom our reference distribution.\n1029 Information Theory\nLet\u2019s implement the KL divergence from Scratch.\ndef kl_divergence (p, q):\nkl=p*torch .log2(p /q)\nout =nansum(kl)\nreturn out.abs() .item()\nKL DivergenceProperties\nLet\u2019s take a look at some properties of the KL divergence (A.21 ).\n\u000fKL divergence is non-symmetric, i.e., there are \ud835\udc43,\ud835\udc44such that\n\ud835\udc37KL\u00b9\ud835\udc43k\ud835\udc44\u00ba\u2260\ud835\udc37KL\u00b9\ud835\udc44k\ud835\udc43\u00ba. (A.22)\n\u000fKL divergence is non-negative, i.e.,\n\ud835\udc37KL\u00b9\ud835\udc43k\ud835\udc44\u00ba\u00150. (A.23)\nNote that the equality holds only when \ud835\udc43=\ud835\udc44.\n\u000fIf there exists an \ud835\udc65such that\ud835\udc5d\u00b9\ud835\udc65\u00ba>0and\ud835\udc5e\u00b9\ud835\udc65\u00ba=0, then\ud835\udc37KL\u00b9\ud835\udc43k\ud835\udc44\u00ba=1.\n\u000fThere is a close relationship between KL divergence and mutual information. Besides\nthe relationship shown in Fig. A.1 ,\ud835\udc3c\u00b9\ud835\udc4b,\ud835\udc4c\u00bais also numerically equivalent with the\nfollowing terms:\n1.\ud835\udc37KL\u00b9\ud835\udc43\u00b9\ud835\udc4b,\ud835\udc4c\u00bak\ud835\udc43\u00b9\ud835\udc4b\u00ba\ud835\udc43\u00b9\ud835\udc4c\u00ba\u00ba;\n2.\ud835\udc38\ud835\udc4cf\ud835\udc37KL\u00b9\ud835\udc43\u00b9\ud835\udc4bj\ud835\udc4c\u00bak\ud835\udc43\u00b9\ud835\udc4b\u00ba\u00bag;\n3.\ud835\udc38\ud835\udc4bf\ud835\udc37KL\u00b9\ud835\udc43\u00b9\ud835\udc4cj\ud835\udc4b\u00bak\ud835\udc43\u00b9\ud835\udc4c\u00ba\u00bag.\nFor the first term, we interpret mutual information as the KL divergence between\n\ud835\udc43\u00b9\ud835\udc4b,\ud835\udc4c\u00baand the product of \ud835\udc43\u00b9\ud835\udc4b\u00baand\ud835\udc43\u00b9\ud835\udc4c\u00ba, and thus is a measure of how differ-\nent the joint distribution is from the distribution if they were independent. For the\nsecond term, mutual information tells us the average reduction in uncertainty about \ud835\udc4c\nthatresultsfromlearningthevalueofthe \ud835\udc4b\u2019sdistribution. Similarlytothethirdterm.\nExample\nLet\u2019s go through a toy example to see the non-symmetry explicitly.\nFirst, let\u2019s generate and sort three tensors of length 10,000: an objective tensor \ud835\udc5dwhich\nfollows a normal distribution \ud835\udc41\u00b90,1\u00ba, and two candidate tensors \ud835\udc5e1and\ud835\udc5e2which follow\nnormal distributions \ud835\udc41\u00b9\u00001,1\u00baand\ud835\udc41\u00b91,1\u00barespectively.", "mimetype": "text/plain", "start_char_idx": 2105590, "end_char_idx": 2107967, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9b99c536-8bf3-4bb1-bb08-81dd7f81a440": {"__data__": {"id_": "9b99c536-8bf3-4bb1-bb08-81dd7f81a440", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "93f5d1aa-f126-4880-93e1-c70729984fe9", "node_type": "1", "metadata": {}, "hash": "f73ed9088a18ed22074e1f3ba28f295527043f3cf2e411ecc27b37479978a473", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1895c57d-0027-43af-be92-7f4bbdffd460", "node_type": "1", "metadata": {}, "hash": "ef559ef3508ba298274eef7b6ed5fb9334191f51501070af7288a339c27bcc81", "class_name": "RelatedNodeInfo"}}, "text": "For the\nsecond term, mutual information tells us the average reduction in uncertainty about \ud835\udc4c\nthatresultsfromlearningthevalueofthe \ud835\udc4b\u2019sdistribution. Similarlytothethirdterm.\nExample\nLet\u2019s go through a toy example to see the non-symmetry explicitly.\nFirst, let\u2019s generate and sort three tensors of length 10,000: an objective tensor \ud835\udc5dwhich\nfollows a normal distribution \ud835\udc41\u00b90,1\u00ba, and two candidate tensors \ud835\udc5e1and\ud835\udc5e2which follow\nnormal distributions \ud835\udc41\u00b9\u00001,1\u00baand\ud835\udc41\u00b91,1\u00barespectively.\n1030 Mathematics for Deep Learning\ntorch .manual_seed( 1)\ntensor_len =10000\np=torch .normal( 0,1, (tensor_len, ))\nq1=torch .normal( -1,1, (tensor_len, ))\nq2=torch .normal( 1,1, (tensor_len, ))\np=torch .sort(p)[ 0]\nq1=torch .sort(q1)[ 0]\nq2=torch .sort(q2)[ 0]\nSince\ud835\udc5e1and\ud835\udc5e2are symmetric with respect to the y-axis (i.e., \ud835\udc65=0), we expect a similar\nvalue of KL divergencebetween \ud835\udc37KL\u00b9\ud835\udc5dk\ud835\udc5e1\u00baand\ud835\udc37KL\u00b9\ud835\udc5dk\ud835\udc5e2\u00ba. As youcan see below, there\nis only a less than 3% off between \ud835\udc37KL\u00b9\ud835\udc5dk\ud835\udc5e1\u00baand\ud835\udc37KL\u00b9\ud835\udc5dk\ud835\udc5e2\u00ba.\nkl_pq1 =kl_divergence(p, q1)\nkl_pq2 =kl_divergence(p, q2)\nsimilar_percentage =abs(kl_pq1 -kl_pq2) /((kl_pq1 +kl_pq2) /2)*100\nkl_pq1, kl_pq2, similar_percentage\n(8582.0341796875 ,8828.3095703125 ,2.8290698237936858 )\nIn contrast, you may find that \ud835\udc37KL\u00b9\ud835\udc5e2k\ud835\udc5d\u00baand\ud835\udc37KL\u00b9\ud835\udc5dk\ud835\udc5e2\u00baare off a lot, with around 40%\noff as shown below.\nkl_q2p =kl_divergence(q2, p)\ndiffer_percentage =abs(kl_q2p -kl_pq2) /((kl_q2p +kl_pq2) /2)*100\nkl_q2p, differ_percentage\n(14130.125 ,46.18621024399691 )\nA.11.5Cross-Entropy\nIfyouarecuriousaboutapplicationsofinformationtheoryindeeplearning,hereisaquick\nexample. We define the true distribution \ud835\udc43with probability distribution \ud835\udc5d\u00b9\ud835\udc65\u00ba, and the\nestimated distribution \ud835\udc44with probability distribution \ud835\udc5e\u00b9\ud835\udc65\u00ba, and we will use them in the\nrest of this section.\nSay we need to solve a binary classification problem based on given \ud835\udc5bdata examples\n{\ud835\udc651,...,\ud835\udc65\ud835\udc5b}. Assume that we encode 1and 0as the positive and negative class label \ud835\udc66\ud835\udc56\nrespectively, and our neural network is parametrized by \ud835\udf03. If we aim to find a best \ud835\udf03so\nthat \u02c6\ud835\udc66\ud835\udc56=\ud835\udc5d\ud835\udf03\u00b9\ud835\udc66\ud835\udc56j\ud835\udc65\ud835\udc56\u00ba, it is natural to apply the maximum log-likelihood approach as was\nseen inSection A.7 . To be specific, for true labels \ud835\udc66\ud835\udc56and predictions \u02c6\ud835\udc66\ud835\udc56=\ud835\udc5d\ud835\udf03\u00b9\ud835\udc66\ud835\udc56j\ud835\udc65\ud835\udc56\u00ba, the\nprobability to be classified as positive is \ud835\udf0b\ud835\udc56=\ud835\udc5d\ud835\udf03\u00b9\ud835\udc66\ud835\udc56=1j\ud835\udc65\ud835\udc56\u00ba. Hence, the log-likelihood\n1031 Information Theory\nfunction would be\n\ud835\udc59\u00b9\ud835\udf03\u00ba=log\ud835\udc3f\u00b9\ud835\udf03\u00ba\n=log\ud835\udc5b\u00d6\n\ud835\udc56=1\ud835\udf0b\ud835\udc66\ud835\udc56\n\ud835\udc56\u00b91\u0000\ud835\udf0b\ud835\udc56\u00ba1\u0000\ud835\udc66\ud835\udc56\n=\ud835\udc5b\u00d5\n\ud835\udc56=1\ud835\udc66\ud835\udc56log\u00b9\ud835\udf0b\ud835\udc56\u00ba\u00b8\u00b9 1\u0000\ud835\udc66\ud835\udc56\u00balog\u00b91\u0000\ud835\udf0b\ud835\udc56\u00ba.", "mimetype": "text/plain", "start_char_idx": 2107495, "end_char_idx": 2109852, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1895c57d-0027-43af-be92-7f4bbdffd460": {"__data__": {"id_": "1895c57d-0027-43af-be92-7f4bbdffd460", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9b99c536-8bf3-4bb1-bb08-81dd7f81a440", "node_type": "1", "metadata": {}, "hash": "f0c0944fe4753f22e6196985f15c11a59db5a2dfa70a12249d797a02ac16218b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "04b622a7-073a-434b-bbd5-ab949915012b", "node_type": "1", "metadata": {}, "hash": "5aa30f61540929e8a066c1541792ac684c8bc0a60538efb54e5fc444c08d9c6a", "class_name": "RelatedNodeInfo"}}, "text": "Hence, the log-likelihood\n1031 Information Theory\nfunction would be\n\ud835\udc59\u00b9\ud835\udf03\u00ba=log\ud835\udc3f\u00b9\ud835\udf03\u00ba\n=log\ud835\udc5b\u00d6\n\ud835\udc56=1\ud835\udf0b\ud835\udc66\ud835\udc56\n\ud835\udc56\u00b91\u0000\ud835\udf0b\ud835\udc56\u00ba1\u0000\ud835\udc66\ud835\udc56\n=\ud835\udc5b\u00d5\n\ud835\udc56=1\ud835\udc66\ud835\udc56log\u00b9\ud835\udf0b\ud835\udc56\u00ba\u00b8\u00b9 1\u0000\ud835\udc66\ud835\udc56\u00balog\u00b91\u0000\ud835\udf0b\ud835\udc56\u00ba.(A.24)\nMaximizing the log-likelihood function \ud835\udc59\u00b9\ud835\udf03\u00bais identical to minimizing \u0000\ud835\udc59\u00b9\ud835\udf03\u00ba, and hence\nwe can find the best \ud835\udf03from here. To generalize the above loss to any distributions, we also\ncalled\u0000\ud835\udc59\u00b9\ud835\udf03\u00bathecross-entropyloss CE\u00b9\ud835\udc66,\u02c6\ud835\udc66\u00ba, where\ud835\udc66follows the true distribution \ud835\udc43and \u02c6\ud835\udc66\nfollows the estimated distribution \ud835\udc44.\nThis was all derived by working from the maximum likelihood point of view. However, if\nwelookcloselywecanseethattermslike log\u00b9\ud835\udf0b\ud835\udc56\u00bahaveenteredintoourcomputationwhich\nis a solid indication that we can understand the expression from an information theoretic\npoint of view.\nFormalDefinition\nLikeKLdivergence, forarandomvariable \ud835\udc4b, wecanalsomeasurethedivergencebetween\nthe estimating distribution \ud835\udc44and the true distribution \ud835\udc43viacross-entropy ,\nCE\u00b9\ud835\udc43,\ud835\udc44\u00ba=\u0000\ud835\udc38\ud835\udc65\u0018\ud835\udc43\u00bblog\u00b9\ud835\udc5e\u00b9\ud835\udc65\u00ba\u00ba\u00bc. (A.25)\nBy using properties of entropy discussed above, we can also interpret it as the summation\nof the entropy \ud835\udc3b\u00b9\ud835\udc43\u00baand the KL divergence between \ud835\udc43and\ud835\udc44, i.e.,\nCE\u00b9\ud835\udc43,\ud835\udc44\u00ba=\ud835\udc3b\u00b9\ud835\udc43\u00ba\u00b8\ud835\udc37KL\u00b9\ud835\udc43k\ud835\udc44\u00ba. (A.26)\nWe can implement the cross-entropy loss as below.\ndef cross_entropy (y_hat, y):\nce=-torch .log(y_hat[ range (len(y_hat)), y])\nreturn ce.mean()\nNow define two tensors for the labels and predictions, and calculate the cross-entropy loss\nof them.\nlabels =torch .tensor([ 0,2])\npreds =torch .tensor([[ 0.3,0.6,0.1], [ 0.2,0.3,0.5]])\ncross_entropy(preds, labels)\ntensor( 0.9486 )\n1032 Mathematics for Deep Learning\nProperties\nAsalludedinthebeginningofthissection,cross-entropy (A.25 )canbeusedtodefinealoss\nfunction in the optimization problem. It turns out that the following are equivalent:\n1.Maximizing predictive probability of \ud835\udc44for distribution \ud835\udc43, (i.e.,\ud835\udc38\ud835\udc65\u0018\ud835\udc43\u00bblog\u00b9\ud835\udc5e\u00b9\ud835\udc65\u00ba\u00ba\u00bc);\n2.Minimizing cross-entropy CE \u00b9\ud835\udc43,\ud835\udc44\u00ba;\n3.Minimizing the KL divergence \ud835\udc37KL\u00b9\ud835\udc43k\ud835\udc44\u00ba.\nThe definition of cross-entropy indirectly proves the equivalent relationship between ob-\njective 2 and objective 3, as long as the entropy of true data \ud835\udc3b\u00b9\ud835\udc43\u00bais constant.\nCross-Entropyas An ObjectiveFunction of Multi-class Classification\nIf we dive deep into the classification objective function with cross-entropy loss CE, we\nwillfind minimizing CE is equivalentto maximizing the log-likelihoodfunction \ud835\udc3f.\nTo begin with, suppose that we are given a dataset with \ud835\udc5bexamples, and it can be classified\ninto\ud835\udc58-classes. For each data example \ud835\udc56, we represent any \ud835\udc58-class label y\ud835\udc56=\u00b9\ud835\udc66\ud835\udc561,...,\ud835\udc66\ud835\udc56\ud835\udc58\u00ba\nbyone-hot encoding . To be specific, if the example \ud835\udc56belongs to class \ud835\udc57, then we set the\n\ud835\udc57-th entry to 1, and all other components to 0, i.e.,\n\ud835\udc66\ud835\udc56\ud835\udc57=(\n1\ud835\udc572\ud835\udc3d;\n0otherwise.", "mimetype": "text/plain", "start_char_idx": 2109711, "end_char_idx": 2112318, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "04b622a7-073a-434b-bbd5-ab949915012b": {"__data__": {"id_": "04b622a7-073a-434b-bbd5-ab949915012b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1895c57d-0027-43af-be92-7f4bbdffd460", "node_type": "1", "metadata": {}, "hash": "ef559ef3508ba298274eef7b6ed5fb9334191f51501070af7288a339c27bcc81", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1994563d-ae5a-4047-a525-17510f4de97f", "node_type": "1", "metadata": {}, "hash": "723037b696c54a47edcc2cf43c9a41bb75a45c79a9fdc5ef89d4c00f55e1ace0", "class_name": "RelatedNodeInfo"}}, "text": "Cross-Entropyas An ObjectiveFunction of Multi-class Classification\nIf we dive deep into the classification objective function with cross-entropy loss CE, we\nwillfind minimizing CE is equivalentto maximizing the log-likelihoodfunction \ud835\udc3f.\nTo begin with, suppose that we are given a dataset with \ud835\udc5bexamples, and it can be classified\ninto\ud835\udc58-classes. For each data example \ud835\udc56, we represent any \ud835\udc58-class label y\ud835\udc56=\u00b9\ud835\udc66\ud835\udc561,...,\ud835\udc66\ud835\udc56\ud835\udc58\u00ba\nbyone-hot encoding . To be specific, if the example \ud835\udc56belongs to class \ud835\udc57, then we set the\n\ud835\udc57-th entry to 1, and all other components to 0, i.e.,\n\ud835\udc66\ud835\udc56\ud835\udc57=(\n1\ud835\udc572\ud835\udc3d;\n0otherwise.(A.27)\nForinstance,ifamulti-classclassificationproblemcontainsthreeclasses \ud835\udc34,\ud835\udc35,and\ud835\udc36,then\nthe labels y\ud835\udc56can be encoded in { \ud835\udc34:\u00b91,0,0\u00ba;\ud835\udc35:\u00b90,1,0\u00ba;\ud835\udc36:\u00b90,0,1\u00ba}.\nAssume that our neural network is parametrized by \ud835\udf03. For true label vectors y\ud835\udc56and predic-\ntions\n\u02c6y\ud835\udc56=\ud835\udc5d\ud835\udf03\u00b9y\ud835\udc56jx\ud835\udc56\u00ba=\ud835\udc58\u00d5\n\ud835\udc57=1\ud835\udc66\ud835\udc56\ud835\udc57\ud835\udc5d\ud835\udf03\u00b9\ud835\udc66\ud835\udc56\ud835\udc57jx\ud835\udc56\u00ba. (A.28)\nHence, the cross-entropyloss would be\nCE\u00b9y,\u02c6y\u00ba=\u0000\ud835\udc5b\u00d5\n\ud835\udc56=1y\ud835\udc56log \u02c6y\ud835\udc56=\u0000\ud835\udc5b\u00d5\n\ud835\udc56=1\ud835\udc58\u00d5\n\ud835\udc57=1\ud835\udc66\ud835\udc56\ud835\udc57log\ud835\udc5d\ud835\udf03\u00b9\ud835\udc66\ud835\udc56\ud835\udc57jx\ud835\udc56\u00ba. (A.29)\nOn the other side, we can also approach the problem through maximum likelihood es-\ntimation. To begin with, let\u2019s quickly introduce a \ud835\udc58-class multinoulli distribution. It is\nan extension of the Bernoulli distribution from binary class to multi-class. If a random\nvariable z=\u00b9\ud835\udc671,...,\ud835\udc67\ud835\udc58\u00bafollows a\ud835\udc58-classmultinoulli distribution with probabilities p=\n(\ud835\udc5d1,...,\ud835\udc5d\ud835\udc58), i.e.,\n\ud835\udc5d\u00b9z\u00ba=\ud835\udc5d\u00b9\ud835\udc671,...,\ud835\udc67\ud835\udc58\u00ba=Multi\u00b9\ud835\udc5d1,...,\ud835\udc5d\ud835\udc58\u00ba,where\ud835\udc58\u00d5\n\ud835\udc56=1\ud835\udc5d\ud835\udc56=1, (A.30)\n1033 Information Theory\nthen the joint probability mass function(p.m.f.) of zis\npz=\ud835\udc58\u00d6\n\ud835\udc57=1\ud835\udc5d\ud835\udc67\ud835\udc57\n\ud835\udc57. (A.31)\nIt can be seen that the label of each data example, y\ud835\udc56, is following a \ud835\udc58-class multinoulli\ndistribution with probabilities \ud835\udf45=(\ud835\udf0b1,...,\ud835\udf0b\ud835\udc58). Therefore, the joint p.m.f. of each data\nexample y\ud835\udc56is\u00dfy\ud835\udc56=\u00ce\ud835\udc58\n\ud835\udc57=1\ud835\udf0b\ud835\udc66\ud835\udc56 \ud835\udc57\n\ud835\udc57.Hence, the log-likelihood function would be\n\ud835\udc59\u00b9\ud835\udf03\u00ba=log\ud835\udc3f\u00b9\ud835\udf03\u00ba=log\ud835\udc5b\u00d6\n\ud835\udc56=1\ud835\udf45y\ud835\udc56=log\ud835\udc5b\u00d6\n\ud835\udc56=1\ud835\udc58\u00d6\n\ud835\udc57=1\ud835\udf0b\ud835\udc66\ud835\udc56 \ud835\udc57\n\ud835\udc57=\ud835\udc5b\u00d5\n\ud835\udc56=1\ud835\udc58\u00d5\n\ud835\udc57=1\ud835\udc66\ud835\udc56\ud835\udc57log\ud835\udf0b\ud835\udc57. (A.32)\nSince in maximum likelihood estimation, we maximizing the objective function \ud835\udc59\u00b9\ud835\udf03\u00baby\nhaving\ud835\udf0b\ud835\udc57=\ud835\udc5d\ud835\udf03\u00b9\ud835\udc66\ud835\udc56\ud835\udc57jx\ud835\udc56\u00ba.", "mimetype": "text/plain", "start_char_idx": 2111735, "end_char_idx": 2113676, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1994563d-ae5a-4047-a525-17510f4de97f": {"__data__": {"id_": "1994563d-ae5a-4047-a525-17510f4de97f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "04b622a7-073a-434b-bbd5-ab949915012b", "node_type": "1", "metadata": {}, "hash": "5aa30f61540929e8a066c1541792ac684c8bc0a60538efb54e5fc444c08d9c6a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fc7b26da-4ef0-444b-97cb-2e4e013a816c", "node_type": "1", "metadata": {}, "hash": "f56a15fbf238f88276d32cf2bfae41e6f93d8610853b8f73caa79cf047d245ec", "class_name": "RelatedNodeInfo"}}, "text": "(A.32)\nSince in maximum likelihood estimation, we maximizing the objective function \ud835\udc59\u00b9\ud835\udf03\u00baby\nhaving\ud835\udf0b\ud835\udc57=\ud835\udc5d\ud835\udf03\u00b9\ud835\udc66\ud835\udc56\ud835\udc57jx\ud835\udc56\u00ba. Therefore, for any multi-class classification, maximizing the\nabovelog-likelihoodfunction \ud835\udc59\u00b9\ud835\udf03\u00baisequivalenttominimizingtheCElossCE \u00b9\ud835\udc66,\u02c6\ud835\udc66\u00ba.\nTo test the above proof, let\u2019s apply the built-in measure NegativeLogLikelihood . Using\nthe same labelsandpredsas in the earlier example, we will get the same numerical loss\nas the previous example up to the 5 decimal place.\n# Implementation of cross-entropy loss in PyTorch combines `nn.LogSoftmax()`\n# and `nn.NLLLoss()`\nnll_loss =NLLLoss()\nloss =nll_loss(torch .log(preds), labels)\nloss\ntensor( 0.9486 )\nA.11.6Summary\n\u000fInformation theory is a field of study about encoding, decoding, transmitting, and ma-\nnipulating information.\n\u000fEntropy is the unit to measure how much information is presented in different signals.\n\u000fKL divergence can also measure the divergence between two distributions.\n\u000fCross-entropy can be viewed as an objective function of multi-class classification. Min-\nimizing cross-entropy loss is equivalent to maximizing the log-likelihood function.\nA.11.7Exercises\n1.Verify that the card examples from the first section indeed have the claimed entropy.\n2.ShowthattheKLdivergence \ud835\udc37\u00b9\ud835\udc5dk\ud835\udc5e\u00baisnonnegativeforalldistributions \ud835\udc5dand\ud835\udc5e. Hint:\nuse Jensen\u2019s inequality, i.e., use the fact that \u0000log\ud835\udc65is a convex function.\n3.Let\u2019s compute the entropy from a few data sources:\n1034 Mathematics for Deep Learning\n290\u000fAssume that you are watching the output generated by a monkey at a typewriter. The\nmonkey presses any of the 44keys of the typewriter at random (you can assume\nthat it has not discovered any special keys or the shift key yet). How many bits of\nrandomness per character do you observe?\n\u000fBeing unhappy with the monkey, you replaced it by a drunk typesetter. It is able\nto generate words, albeit not coherently. Instead, it picks a random word out of\na vocabulary of 2,000words. Let\u2019s assume that the average length of a word is\n4.5letters in English. How many bits of randomness per character do you observe\nnow?\n\u000fStill being unhappy with the result, you replace the typesetter by a high quality lan-\nguage model. The language model can currently obtain a perplexity as low as 15\npoints per word. The character perplexity of a language model is defined as the\ninverse of the geometric mean of a set of probabilities, each probability is corre-\nsponding to a character in the word. To be specific, if the length of a given word is\n\ud835\udc59, then PPL\u00b9word\u00ba=\u00bb\u00ce\n\ud835\udc56\ud835\udc5d\u00b9character\ud835\udc56\u00ba\u00bc\u00001\n\ud835\udc59=exp\u0002\n\u00001\n\ud835\udc59\u00cd\n\ud835\udc56log\ud835\udc5d\u00b9character\ud835\udc56\u00ba\u0003\n.As-\nsume that the test word has 4.5 letters, how many bits of randomness per character\ndo you observe now?\n4.Explain intuitively why \ud835\udc3c\u00b9\ud835\udc4b,\ud835\udc4c\u00ba=\ud835\udc3b\u00b9\ud835\udc4b\u00ba\u0000\ud835\udc3b\u00b9\ud835\udc4bj\ud835\udc4c\u00ba. Then, show this is true by\nexpressing both sides as an expectation with respect to the joint distribution.\n5.What is the KL Divergence between the two Gaussian distributions N\u00b9\ud835\udf071,\ud835\udf0e2\n1\u00baand\nN\u00b9\ud835\udf072,\ud835\udf0e2\n2\u00ba?\nDiscussions290.\n291\nB Tools for Deep Learning\nTo get the most out of DiveintoDeepLearning , we will talk you through different tools in\nthisappendix,suchasforrunningandcontributingtothisinteractiveopen-sourcebook.\nB.1UsingJupyterNotebooks\nThis section describes how to edit and run the code in each section of this book using\nthe Jupyter Notebook. Make sure you have installed Jupyter and downloaded the code as\ndescribed in Installation (page xxxiv). If you want to know more about Jupyter see the\nexcellent tutorial in their documentation291.\nB.1.1Editingand Runningthe Code Locally\nSuppose that the local path of the book\u2019s code is xx/yy/d2l-en/ .", "mimetype": "text/plain", "start_char_idx": 2113565, "end_char_idx": 2117137, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fc7b26da-4ef0-444b-97cb-2e4e013a816c": {"__data__": {"id_": "fc7b26da-4ef0-444b-97cb-2e4e013a816c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1994563d-ae5a-4047-a525-17510f4de97f", "node_type": "1", "metadata": {}, "hash": "723037b696c54a47edcc2cf43c9a41bb75a45c79a9fdc5ef89d4c00f55e1ace0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a00f05f9-355c-4121-8dab-bbdff524518e", "node_type": "1", "metadata": {}, "hash": "af2f10ad40e1089fc527001db0f79cd40671d8d92355acfcc87863d3b993d629", "class_name": "RelatedNodeInfo"}}, "text": "Discussions290.\n291\nB Tools for Deep Learning\nTo get the most out of DiveintoDeepLearning , we will talk you through different tools in\nthisappendix,suchasforrunningandcontributingtothisinteractiveopen-sourcebook.\nB.1UsingJupyterNotebooks\nThis section describes how to edit and run the code in each section of this book using\nthe Jupyter Notebook. Make sure you have installed Jupyter and downloaded the code as\ndescribed in Installation (page xxxiv). If you want to know more about Jupyter see the\nexcellent tutorial in their documentation291.\nB.1.1Editingand Runningthe Code Locally\nSuppose that the local path of the book\u2019s code is xx/yy/d2l-en/ . Use the shell to change\nthe directory to this path ( cd xx/yy/d2l-en ) and run the command jupyter notebook .\nIf your browser does not do this automatically, open http://localhost:8888 and you will see\ntheinterfaceofJupyterandallthefolderscontainingthecodeofthebook, asshownin Fig.\nB.1.\ntFig. B.1 The folders containing the code of this book.\nYoucanaccessthenotebookfilesbyclickingonthefolderdisplayedonthewebpage. They\nusuallyhavethesuffix\u201c.ipynb\u201d. Forthesakeofbrevity,wecreateatemporary\u201ctest.ipynb\u201d\nfile. The content displayed after you click it is shown in Fig. B.2. This notebook includes a\n1035\n1036 Tools for Deep Learning\nmarkdowncellandacodecell. Thecontentinthemarkdowncellincludes\u201cThisIsaTitle\u201d\nand \u201cThis is text.\u201d. The code cell contains two lines of Python code.\ntFig. B.2 Markdown and code cells in the \u201ctext.ipynb\u201d \ufb01le.\nDoubleclickonthemarkdowncelltoentereditmode. Addanewtextstring\u201cHelloworld.\u201d\nat the end of the cell, as shown in Fig. B.3.\ntFig. B.3 Edit the markdown cell.\nAs demonstrated in Fig. B.4, click \u201cCell\u201d!\u201cRun Cells\u201d in the menu bar to run the edited\ncell.\nAfter running, the markdown cell is shown in Fig. B.5.\nNext, clickonthecodecell. Multiplytheelementsby2afterthelastlineofcode, asshown\ninFig. B.6.\nYou can also run the cell with a shortcut (\u201cCtrl + Enter\u201d by default) and obtain the output\nresult from Fig. B.7.\nWhenanotebookcontainsmorecells,wecanclick\u201cKernel\u201d !\u201cRestart&RunAll\u201dinthe\nmenu bar to run all the cells in the entire notebook. By clicking \u201cHelp\u201d !\u201cEdit Keyboard\nShortcuts\u201dinthemenubar,youcanedittheshortcutsaccordingtoyourpreferences.\n1037 B.1 Using Jupyter Notebooks\ntFig. B.4 Run the cell.\ntFig. B.5 The markdown cell after running.\ntFig. B.6 Edit the code cell.\n1038 Tools for Deep Learning\ntFig. B.7 Run the code cell to obtain the output.\nB.1.2AdvancedOptions\nBeyondlocaleditingtwothingsarequiteimportant: editingthenotebooksinthemarkdown\nformatandrunningJupyterremotely. Thelattermatterswhenwewanttorunthecodeona\nfasterserver. TheformermatterssinceJupyter\u2019snativeipynbformatstoresalotofauxiliary\ndata that is irrelevant to the content, mostly related to how and where the code is run. This\nis confusing for Git, making reviewing contributions very difficult. Fortunately there is an\nalternative\u2014native editing in the markdown format.\nMarkdownFiles in Jupyter\nIfyouwishtocontributetothecontentofthisbook,youneedtomodifythesourcefile(md\nfile, notipynbfile)onGitHub. Usingthenotedownpluginwecanmodifynotebooksinthe\nmd format directly in Jupyter.\nFirst, install the notedown plugin, run the Jupyter Notebook, and load the plugin:\npip install d2l -notedown # You may need to uninstall the original notedown.\njupyter notebook --NotebookApp .contents_manager_class ='notedown.\n\u21a9!NotedownContentsManager '\nYou may also turn on the notedown plugin by default whenever you run the Jupyter Note-\nbook. First,generateaJupyterNotebookconfigurationfile(ifithasalreadybeengenerated,\nyou can skip this step).", "mimetype": "text/plain", "start_char_idx": 2116487, "end_char_idx": 2120081, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a00f05f9-355c-4121-8dab-bbdff524518e": {"__data__": {"id_": "a00f05f9-355c-4121-8dab-bbdff524518e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fc7b26da-4ef0-444b-97cb-2e4e013a816c", "node_type": "1", "metadata": {}, "hash": "f56a15fbf238f88276d32cf2bfae41e6f93d8610853b8f73caa79cf047d245ec", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f33304f6-01f8-4750-b78f-e65583b17438", "node_type": "1", "metadata": {}, "hash": "c0d2c3cac251b9ee45491509d6633c41e330c71799fea9d2e2db2d7443b1aa2f", "class_name": "RelatedNodeInfo"}}, "text": "Fortunately there is an\nalternative\u2014native editing in the markdown format.\nMarkdownFiles in Jupyter\nIfyouwishtocontributetothecontentofthisbook,youneedtomodifythesourcefile(md\nfile, notipynbfile)onGitHub. Usingthenotedownpluginwecanmodifynotebooksinthe\nmd format directly in Jupyter.\nFirst, install the notedown plugin, run the Jupyter Notebook, and load the plugin:\npip install d2l -notedown # You may need to uninstall the original notedown.\njupyter notebook --NotebookApp .contents_manager_class ='notedown.\n\u21a9!NotedownContentsManager '\nYou may also turn on the notedown plugin by default whenever you run the Jupyter Note-\nbook. First,generateaJupyterNotebookconfigurationfile(ifithasalreadybeengenerated,\nyou can skip this step).\njupyter notebook --generate -config\nThen,addthefollowinglinetotheendoftheJupyterNotebookconfigurationfile(forLinux\nor macOS, usually in the path ~/.jupyter/jupyter_notebook_config.py ):\n1039 Using Jupyter Notebooks\n292c.NotebookApp .contents_manager_class ='notedown.NotedownContentsManager '\nAfter that, you only need to run the jupyter notebook command to turn on the notedown\nplugin by default.\nRunningJupyterNotebookson a RemoteServer\nSometimes,youmaywanttorunJupyternotebooksonaremoteserverandaccessitthrough\na browser on your local computer. If Linux or macOS is installed on your local machine\n(Windowscanalsosupportthisfunctionthroughthird-partysoftwaresuchasPuTTY),you\ncan use port forwarding:\nssh myserver -L8888 :localhost: 8888\nThe above string myserver is the address of the remote server. Then we can use http:\n//localhost:8888 to access the remote server myserver that runs Jupyter notebooks. We\nwilldetailonhowtorunJupyternotebooksonAWSinstanceslaterinthisappendix.\nTiming\nWe can use the ExecuteTime plugin to time the execution of each code cell in Jupyter\nnotebooks. Use the following commands to install the plugin:\npip install jupyter_contrib_nbextensions\njupyter contrib nbextension install --user\njupyter nbextension enable execute_time /ExecuteTime\nB.1.3Summary\n\u000fUsing the Jupyter Notebook tool, we can edit, run, and contribute to each section of the\nbook.\n\u000fWe can run Jupyter notebooks on remote servers using port forwarding.\nB.1.4Exercises\n1.Edit and run the code in this book with the Jupyter Notebook on your local machine.\n2.EditandrunthecodeinthisbookwiththeJupyterNotebook remotely viaportforward-\ning.\n3.Compare the running time of the operations A>BandABfor two square matrices in\nR1024\u00021024. Which one is faster?\nDiscussions292.\n1040 Tools for Deep Learning\n293B.2Using Amazon SageMaker\nDeep learning applications may demand so much computational resource that easily goes\nbeyond what your local machine can offer. Cloud computing services allow you to run\nGPU-intensivecodeofthisbookmoreeasilyusingmorepowerfulcomputers. Thissection\nwill introduce how to use Amazon SageMaker to run the code of this book.\nB.2.1SigningUp\nFirst, we need to sign up an account at https://aws.amazon.com/ . For additional security,\nusingtwo-factorauthenticationisencouraged. Itisalsoagoodideatosetupdetailedbilling\nand spending alerts to avoid any surprise, e.g., when forgetting to stop running instances.\nAfter logging into your AWS account, go to your console293and search for \u201cAmazon\nSageMaker\u201d (see Fig. B.1), then click it to open the SageMaker panel.\ntFig. B.1 Search for and open the SageMaker panel.\nB.2.2Creatinga SageMakerInstance\nNext, let\u2019s create a notebook instance as described in Fig. B.2.\ntFig. B.2 Create a SageMaker instance.\n1041 Using Amazon SageMaker\n294SageMaker provides multiple instance types294with varying computational power and\nprices. When creating a notebook instance, we can specify its name and type. In Fig. B.3,\nwe choose ml.p3.2xlarge : with one Tesla V100 GPU and an 8-core CPU, this instance is\npowerful enough for most of the book.\ntFig. B.3 Choose the instance type.\nThe entire book in the ipynb format for running with SageMaker is available at https://\ngithub.com/d2l-ai/d2l-pytorch-sagemaker .", "mimetype": "text/plain", "start_char_idx": 2119348, "end_char_idx": 2123336, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f33304f6-01f8-4750-b78f-e65583b17438": {"__data__": {"id_": "f33304f6-01f8-4750-b78f-e65583b17438", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a00f05f9-355c-4121-8dab-bbdff524518e", "node_type": "1", "metadata": {}, "hash": "af2f10ad40e1089fc527001db0f79cd40671d8d92355acfcc87863d3b993d629", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "16e958e9-6e74-4331-9986-c5a59d0b612c", "node_type": "1", "metadata": {}, "hash": "614a381b047620d5ca3ce8e1c235a65b5c3643739756c826527021df8f25e22e", "class_name": "RelatedNodeInfo"}}, "text": "tFig. B.1 Search for and open the SageMaker panel.\nB.2.2Creatinga SageMakerInstance\nNext, let\u2019s create a notebook instance as described in Fig. B.2.\ntFig. B.2 Create a SageMaker instance.\n1041 Using Amazon SageMaker\n294SageMaker provides multiple instance types294with varying computational power and\nprices. When creating a notebook instance, we can specify its name and type. In Fig. B.3,\nwe choose ml.p3.2xlarge : with one Tesla V100 GPU and an 8-core CPU, this instance is\npowerful enough for most of the book.\ntFig. B.3 Choose the instance type.\nThe entire book in the ipynb format for running with SageMaker is available at https://\ngithub.com/d2l-ai/d2l-pytorch-sagemaker . We can specify this GitHub repository URL\n(Fig. B.4) to allow SageMaker to clone it when creating the instance.\ntFig. B.4 Specify the GitHub repository.\nB.2.3Runningand Stopping an Instance\nCreatinganinstancemaytakeafewminutes. Whenitisready,clickonthe\u201cOpenJupyter\u201d\nlink next to it ( Fig. B.5) so you can edit and run all the Jupyter notebooks of this book on\nthis instance (similar to steps in Section B.1 ).\ntFig. B.5 Open Jupyter on the created SageMaker instance.\nAfter finishing your work, do not forget to stop the instance to avoid being charged further\n(Fig. B.6).\n1042 Tools for Deep Learning\ntFig. B.6 Stop a SageMaker instance.\n295B.2.4UpdatingNotebooks\nNotebooks of this open-source book will be regularly updated in the d2l-ai/d2l-pytorch-\nsagemaker295repository on GitHub. To update to the latest version, you may open a\nterminal on the SageMaker instance ( Fig. B.7).\ntFig. B.7 Open a terminal on the SageMaker instance.\nYoumaywish to commit yourlocal changesbeforepulling updates fromthe remote repos-\nitory. Otherwise, simply discard all your local changes with the following commands in\nthe terminal:\ncdSageMaker/d2l-pytorch-sagemaker/\ngit reset --hard\ngit pull\nB.2.5Summary\n\u000fWecancreateanotebookinstanceusingAmazonSageMakertorunGPU-intensivecode\nof this book.\n\u000fWe can update notebooks via the terminal on the Amazon SageMaker instance.\nB.2.6Exercises\n1.Edit and run any section that requires a GPU using Amazon SageMaker.\n1043 Using AWS EC2 Instances\n2962.Open a terminal to access the local directory that hosts all the notebooks of this book.\nDiscussions296.\nB.3Using AWSEC2 Instances\nInthissection,wewillshowyouhowtoinstallalllibrariesonarawLinuxmachine. Recall\nthatinSectionB.2 wediscussedhowtouseAmazonSageMaker,whilebuildinganinstance\nby yourself costs less on AWS. The walkthrough includes three steps:\n1.Request for a GPU Linux instance from AWS EC2.\n2.Install CUDA (or use an Amazon Machine Image with preinstalled CUDA).\n3.Installthedeeplearningframeworkandotherlibrariesforrunningthecodeofthebook.\nThis process applies to other instances (and other clouds), too, albeit with some minor\nmodifications. Before going forward, you need to create an AWS account, see Section B.2\nfor more details.\nB.3.1Creating and Runningan EC2 Instance\nAfterloggingintoyourAWSaccount,click\u201cEC2\u201d( Fig.B.1)togototheEC2panel.\ntFig. B.1 Open the EC2 console.\nFig. B.2 shows the EC2 panel.\nPresettingLocation\nSelect a nearby data center to reduce latency, e.g., \u201cOregon\u201d (marked by the red box in the\ntop-right of Fig. B.2). If you are located in China, you can select a nearby Asia Pacific\n1044 Tools for Deep Learning\ntFig. B.2 The EC2 panel.\nregion, such as Seoul or Tokyo. Please note that some data centers may not have GPU\ninstances.\nIncreasingLimits\nBefore choosing an instance, check if there are quantity restrictions by clicking the \u201cLim-\nits\u201d label in the bar on the left as shown in Fig. B.2.Fig. B.3 shows an example of such\na limitation. The account currently cannot open \u201cp2.xlarge\u201d instances according to the re-\ngion.", "mimetype": "text/plain", "start_char_idx": 2122656, "end_char_idx": 2126376, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "16e958e9-6e74-4331-9986-c5a59d0b612c": {"__data__": {"id_": "16e958e9-6e74-4331-9986-c5a59d0b612c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f33304f6-01f8-4750-b78f-e65583b17438", "node_type": "1", "metadata": {}, "hash": "c0d2c3cac251b9ee45491509d6633c41e330c71799fea9d2e2db2d7443b1aa2f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "144aea52-dccf-4950-ad77-b28949db4b03", "node_type": "1", "metadata": {}, "hash": "319e5adb8f7e44544333b5d595c7569d195e8e8a49c8376b9c76ef7c92e44106", "class_name": "RelatedNodeInfo"}}, "text": "tFig. B.1 Open the EC2 console.\nFig. B.2 shows the EC2 panel.\nPresettingLocation\nSelect a nearby data center to reduce latency, e.g., \u201cOregon\u201d (marked by the red box in the\ntop-right of Fig. B.2). If you are located in China, you can select a nearby Asia Pacific\n1044 Tools for Deep Learning\ntFig. B.2 The EC2 panel.\nregion, such as Seoul or Tokyo. Please note that some data centers may not have GPU\ninstances.\nIncreasingLimits\nBefore choosing an instance, check if there are quantity restrictions by clicking the \u201cLim-\nits\u201d label in the bar on the left as shown in Fig. B.2.Fig. B.3 shows an example of such\na limitation. The account currently cannot open \u201cp2.xlarge\u201d instances according to the re-\ngion. If you need to open one or more instances, click on the \u201cRequest limit increase\u201d link\nto apply for a higher instance quota. Generally, it takes one business day to process an\napplication.\ntFig. B.3 Instance quantity restrictions.\nLaunchingan Instance\nNext, click the \u201cLaunch Instance\u201d button marked by the red box in Fig. B.2 to launch your\ninstance.\nWebeginbyselectingasuitableAmazonMachineImage(AMI).SelectanUbuntuinstance\n(Fig. B.4).\nEC2 provides many different instance configurations to choose from. This can sometimes\nfeel overwhelming to a beginner. tab_ec2 lists different suitable machines.\n:Different EC2 instance types\n1045 Using AWS EC2 Instances\ntFig. B.4 Choose an AMI.\n297\n298Table B.1: label: tab_ec2\nName GPU Notes\ng2 Grid K520 ancient\np2 Kepler K80 old but often cheap as spot\ng3 Maxwell M60 good trade-off\np3 Volta V100 high performance for FP16\np4 Ampere A100 high performance for large-scale training\ng4 Turing T4 inference optimized FP16/INT8\nAll these servers come in multiple flavors indicating the number of GPUs used. For exam-\nple, a p2.xlarge has 1 GPU and a p2.16xlarge has 16 GPUs and more memory. For more\ndetails, see the AWS EC2 documentation297or asummary page298. For the purpose of\nillustration, a p2.xlarge will suffice (marked in the red box of Fig. B.5).\ntFig. B.5 Choose an instance.\n1046 Tools for Deep Learning\nNote that youshould use a GPU-enabled instancewith suitable driversand a GPU-enabled\ndeeplearningframework. OtherwiseyouwillnotseeanybenefitfromusingGPUs.\nWe go on to select the key pair used to access the instance. If you do not have a key pair,\nclick \u201cCreate new key pair\u201d in Fig. B.6 to generate a key pair. Subsequently, you can select\nthe previously generated key pair. Make sure that you download the key pair and store\nit in a safe location if you generated a new one. This is your only way to SSH into the\nserver.\ntFig. B.6 Select a key pair.\nIn this example, we will keep the default configurations for \u201cNetwork settings\u201d (click the\n\u201cEdit\u201d button to configure items such as the subnet and security groups). We just increase\nthe default hard disk size to 64 GB ( Fig. B.7). Note that CUDA by itself already takes up\n4 GB.\ntFig. B.7 Modify the hard disk size.\nClick\u201cLaunchInstance\u201dtolaunchthecreatedinstance. ClicktheinstanceIDshownin Fig.\nB.8to view the status of this instance.\nConnecting to the Instance\nAsshownin Fig.B.9,aftertheinstancestateturnsgreen,right-clicktheinstanceandselect\nConnect to view the instance access method.\nIfthisisanewkey,itmustnotbepubliclyviewableforSSHtowork. Gotothefolderwhere\n1047 Using AWS EC2 Instances\ntFig. B.8 Click the instance ID.\ntFig. B.9 View the instance access method.\nyou store D2L_key.pem and execute the following command to make the key not publicly\nviewable:\nchmod 400 D2L_key.pem\ntFig. B.10 View instance access and startup method.", "mimetype": "text/plain", "start_char_idx": 2125670, "end_char_idx": 2129219, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "144aea52-dccf-4950-ad77-b28949db4b03": {"__data__": {"id_": "144aea52-dccf-4950-ad77-b28949db4b03", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "16e958e9-6e74-4331-9986-c5a59d0b612c", "node_type": "1", "metadata": {}, "hash": "614a381b047620d5ca3ce8e1c235a65b5c3643739756c826527021df8f25e22e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "96101319-5f76-4052-b361-d2966fb7fe0e", "node_type": "1", "metadata": {}, "hash": "75e35fc480172344cdd8c36370e733d0edeb91d8d79eefdf37bd411ecf874917", "class_name": "RelatedNodeInfo"}}, "text": "Note that CUDA by itself already takes up\n4 GB.\ntFig. B.7 Modify the hard disk size.\nClick\u201cLaunchInstance\u201dtolaunchthecreatedinstance. ClicktheinstanceIDshownin Fig.\nB.8to view the status of this instance.\nConnecting to the Instance\nAsshownin Fig.B.9,aftertheinstancestateturnsgreen,right-clicktheinstanceandselect\nConnect to view the instance access method.\nIfthisisanewkey,itmustnotbepubliclyviewableforSSHtowork. Gotothefolderwhere\n1047 Using AWS EC2 Instances\ntFig. B.8 Click the instance ID.\ntFig. B.9 View the instance access method.\nyou store D2L_key.pem and execute the following command to make the key not publicly\nviewable:\nchmod 400 D2L_key.pem\ntFig. B.10 View instance access and startup method.\nNow,copytheSSHcommandinthelowerredboxof Fig.B.10 andpasteontothecommand\nline:\n1048 Tools for Deep Learning\n299ssh -i\"D2L_key.pem\" ubuntu@ec2-xx-xxx-xxx-xxx.y.compute.amazonaws.com\nWhenthecommandlineprompts\u201cAreyousureyouwanttocontinueconnecting(yes/no)\u201d,\nenter \u201cyes\u201d and press Enter to log into the instance.\nYour server is ready now.\nB.3.2Installing CUDA\nBefore installing CUDA, be sure to update the instance with the latest drivers.\nsudo apt-get update &&sudo apt-get install -ybuild-essential git libgfortran3\nHerewedownloadCUDA12.1. VisitNVIDIA\u2019s officialrepository299tofindthedownload\nlink as shown in Fig. B.11 .\ntFig. B.11 Find the CUDA 12.1 download address.\nCopy the instructions and paste them onto the terminal to install CUDA 12.1.\n# The link and file name are subject to changes\nwget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_\n\u21a9!64/cuda-ubuntu2204.pin\nsudo mvcuda-ubuntu2204.pin /etc/apt/preferences.d/cuda-repository-pin-600\nwget https://developer.download.nvidia.com/compute/cuda/12.1.0/local_\n\u21a9!installers/cuda-repo-ubuntu2204-12-1-local_12.1.0-530.30.02-1_amd64.deb\nsudo dpkg -icuda-repo-ubuntu2204-12-1-local_12.1.0-530.30.02-1_amd64.deb\n(continues on next page)\n1049 Using AWS EC2 Instances\n(continued from previous page)\nsudo cp/var/cuda-repo-ubuntu2204-12-1-local/cuda-*-keyring.gpg /usr/share/\n\u21a9!keyrings/\nsudo apt-get update\nsudo apt-get -yinstall cuda\nAfter installing the program, run the following command to view the GPUs:\nnvidia-smi\nFinally, add CUDA to the library path to help other libraries find it, such as appending the\nfollowing lines to the end of ~/.bashrc .\nexport PATH =\"/usr/local/cuda-12.1/bin: $PATH \"\nexport LD_LIBRARY_PATH =${LD_LIBRARY_PATH }:/usr/local/cuda-12.1/lib64\nB.3.3Installing Libraries forRunningthe Code\nTorunthecodeofthisbook,justfollowstepsin Installation (pagexxxiv)forLinuxuserson\nthe EC2 instance and use the following tips for working on a remote Linux server:\n\u000fTodownloadthebashscriptontheMinicondainstallationpage,rightclickthedownload\nlink and select \u201cCopy Link Address\u201d, then execute wget [copied link address] .\n\u000fAfter running ~/miniconda3/bin/conda init , you may execute source ~/.bashrc\ninstead of closing and reopening your current shell.\nB.3.4Runningthe JupyterNotebookremotely\nTo run the Jupyter Notebook remotely you need to use SSH port forwarding. After all, the\nserver in the cloud does not havea monitor or keyboard. Forthis, log into your serverfrom\nyour desktop (or laptop) as follows:\n# This command must be run in the local command line\nssh -i\"/path/to/key.pem \"ubuntu @ec2 -xx-xxx-xxx-xxx.y.compute .amazonaws .com -L\u2423\n\u21a9!8889 :localhost: 8888\nNext, go to the location of the downloaded code of this book on the EC2 instance, then\nrun:\nconda activate d2l\njupyter notebook\nFig.B.12 showsthepossibleoutputafteryouruntheJupyterNotebook.", "mimetype": "text/plain", "start_char_idx": 2128512, "end_char_idx": 2132065, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "96101319-5f76-4052-b361-d2966fb7fe0e": {"__data__": {"id_": "96101319-5f76-4052-b361-d2966fb7fe0e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "144aea52-dccf-4950-ad77-b28949db4b03", "node_type": "1", "metadata": {}, "hash": "319e5adb8f7e44544333b5d595c7569d195e8e8a49c8376b9c76ef7c92e44106", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "131a694b-f269-449e-9d51-dc3e68c32971", "node_type": "1", "metadata": {}, "hash": "c17a93a3d02fe6070c263ccb4d67e1b9edf02c75906182d2b51dd46f3d17b16e", "class_name": "RelatedNodeInfo"}}, "text": "B.3.4Runningthe JupyterNotebookremotely\nTo run the Jupyter Notebook remotely you need to use SSH port forwarding. After all, the\nserver in the cloud does not havea monitor or keyboard. Forthis, log into your serverfrom\nyour desktop (or laptop) as follows:\n# This command must be run in the local command line\nssh -i\"/path/to/key.pem \"ubuntu @ec2 -xx-xxx-xxx-xxx.y.compute .amazonaws .com -L\u2423\n\u21a9!8889 :localhost: 8888\nNext, go to the location of the downloaded code of this book on the EC2 instance, then\nrun:\nconda activate d2l\njupyter notebook\nFig.B.12 showsthepossibleoutputafteryouruntheJupyterNotebook. Thelastrowisthe\nURL for port 8888.\nSince you used port forwarding to port 8889, copy the last row in the red box of Fig. B.12 ,\nreplace \u201c8888\u201d with \u201c8889\u201d in the URL, and open it in your local browser.\n1050 Tools for Deep Learning\ntFig. B.12 Output after running the Jupyter Notebook. The last row is the URL for port 8888.\n300B.3.5Closing UnusedInstances\nAscloudservicesarebilledbythetimeofuse,youshouldcloseinstancesthatarenotbeing\nused. Note that there are alternatives:\n\u000f\u201cStopping\u201d an instance means that you will be able to start it again. This is akin to\nswitching off the power for your regular server. However, stopped instances will still\nbe billed a small amount for the hard disk space retained.\n\u000f\u201cTerminating\u201d an instance will delete all data associated with it. This includes the disk,\nhence you cannot start it again. Only do this if you know that you will not need it in\nthe future.\nIf you want to use the instance as a template for many more instances, right-click on the\nexamplein Fig.B.9 andselect\u201cImage\u201d!\u201cCreate\u201dtocreateanimageoftheinstance. Once\nthisiscomplete,select\u201cInstanceState\u201d !\u201cTerminate\u201dtoterminatetheinstance. Thenext\ntime you want to use this instance, you can follow the steps in this section to create an\ninstance based on the saved image. The only difference is that, in \u201c1. Choose AMI\u201d shown\ninFig.B.4,youmustusethe\u201cMyAMIs\u201doptiononthelefttoselectyoursavedimage. The\ncreated instance will retain the information stored on the image hard disk. For example,\nyou will not have to reinstall CUDA and other runtime environments.\nB.3.6Summary\n\u000fWe can launch and stop instances on demand without having to buy and build our own\ncomputer.\n\u000fWe need to install CUDA before using the GPU-enabled deep learning framework.\n\u000fWe can use port forwarding to run the Jupyter Notebook on a remote server.\nB.3.7Exercises\n1.The cloud offers convenience, but it does not come cheap. Find out how to launch spot\ninstances300to see how to reduce costs.\n1051 Using Google Colab\n301\n3022.Experiment with different GPU servers. How fast are they?\n3.Experiment with multi-GPU servers. How well can you scale things up?\nDiscussions301.\nB.4UsingGoogle Colab\nWe introduced how to run this book on AWS in Section B.2 andSection B.3 . Another\noption is running this book on Google Colab302if you have a Google account.\nTo run the code of a section on Colab, simply click the Colabbutton as shown in Fig.\nB.1.\ntFig. B.1 Run the code of a section on Colab\nIf it is your first time to run a code cell, you will receive a warning message as shown in\nFig. B.2. Just click \u201cRUN ANYWAY\u201d to ignore it.\ntFig. B.2 Ignore the warning message by clicking \u201cRUN ANYWAY\u201d.\nNext, Colab will connect you to an instance to run the code of this section. Specifically,\nif a GPU is needed, Colab will be automatically requested for connecting to a GPU in-\nstance.\nB.4.1Summary\n\u000fYou can use Google Colab to run each section\u2019s code in this book.\n\u000fColab will be requested to connect to a GPU instance if a GPU is needed in any section\nof this book.\n1052 Tools for Deep Learning\n303\n304\n305B.4.2Exercises\n1.Open any section of this book using Google Colab.\n2.Edit and run any section that requires a GPU using Google Colab.", "mimetype": "text/plain", "start_char_idx": 2131460, "end_char_idx": 2135263, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "131a694b-f269-449e-9d51-dc3e68c32971": {"__data__": {"id_": "131a694b-f269-449e-9d51-dc3e68c32971", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "96101319-5f76-4052-b361-d2966fb7fe0e", "node_type": "1", "metadata": {}, "hash": "75e35fc480172344cdd8c36370e733d0edeb91d8d79eefdf37bd411ecf874917", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "114e7916-a391-46cf-9f33-ca3e9f21c476", "node_type": "1", "metadata": {}, "hash": "dfb1fb3f1a6e394d128464931fb204275e4f318f0462d1828b1a377e4da5e06f", "class_name": "RelatedNodeInfo"}}, "text": "B.2. Just click \u201cRUN ANYWAY\u201d to ignore it.\ntFig. B.2 Ignore the warning message by clicking \u201cRUN ANYWAY\u201d.\nNext, Colab will connect you to an instance to run the code of this section. Specifically,\nif a GPU is needed, Colab will be automatically requested for connecting to a GPU in-\nstance.\nB.4.1Summary\n\u000fYou can use Google Colab to run each section\u2019s code in this book.\n\u000fColab will be requested to connect to a GPU instance if a GPU is needed in any section\nof this book.\n1052 Tools for Deep Learning\n303\n304\n305B.4.2Exercises\n1.Open any section of this book using Google Colab.\n2.Edit and run any section that requires a GPU using Google Colab.\nDiscussions303.\nB.5SelectingServersand GPUs\nDeep learning training generally requires large amounts of computation. At present GPUs\narethemostcost-effectivehardwareacceleratorsfordeeplearning. Inparticular,compared\nwith CPUs, GPUs are cheaper and offer higher performance, often by over an order of\nmagnitude. Furthermore, a single server can support multiple GPUs, up to 8 for high end\nservers. More typical numbers are up to 4 GPUs for an engineering workstation, since\nheat, cooling, and power requirements escalate quickly beyond what an office building can\nsupport. For larger deployments, cloud computing (e.g., Amazon\u2019s P3304andG4305\ninstances) is a much more practical solution.\nB.5.1Selecting Servers\nThere is typically no need to purchase high-end CPUs with many threads since much of\nthe computation occurs on the GPUs. That said, due to the global interpreter lock (GIL)\nin Python single-thread performance of a CPU can matter in situations where we have 4\u20138\nGPUs. AllthingsequalthissuggeststhatCPUswithasmallernumberofcoresbutahigher\nclockfrequencymightbeamoreeconomicalchoice. Forexample,whenchoosingbetween\na 6-core 4 GHz and an 8-core 3.5 GHz CPU, the former is much preferable, even though\nits aggregate speed is less. An important consideration is that GPUs use lots of power and\nthus dissipate lots of heat. This requires very good cooling and a large enough chassis to\nuse the GPUs. Follow the guidelines below if possible:\n1.Power Supply . GPUs use significant amounts of power. Budget with up to 350W per\ndevice(checkforthe peakdemand ofthegraphicscardratherthantypicaldemand,since\nefficient code can use lots of energy). If your power supply is not up to the demand you\nwill find that your system becomes unstable.\n2.ChassisSize . GPUsarelargeandtheauxiliarypowerconnectorsoftenneedextraspace.\nAlso, large chassis are easier to cool.\n3.GPU Cooling . If you have a large number of GPUs you might want to invest in water\ncooling. Also, aim for reference designs even if they have fewer fans, since they are\nthin enough to allow for air intake between the devices. If you buy a multi-fan GPU it\nmight be too thick to get enough air when installing multiple GPUs and you will run\ninto thermal throttling.\n1053 Selecting Servers and GPUs\n4.PCIe Slots . Moving data to and from the GPU (and exchanging it between GPUs)\nrequires lots of bandwidth. We recommend PCIe 3.0 slots with 16 lanes. If you mount\nmultipleGPUs,besuretocarefullyreadthemotherboarddescriptiontoensurethat16 \u0002\nbandwidth is still available when multiple GPUs are used at the same time and that you\naregettingPCIe3.0asopposedtoPCIe2.0fortheadditionalslots. Somemotherboards\ndowngradeto8\u0002oreven4\u0002bandwidthwithmultipleGPUsinstalled. Thisispartlydue\nto the number of PCIe lanes that the CPU offers.\nIn short, here are some recommendations for building a deep learning server:\n\u000fBeginner . Buy a low end GPU with low power consumption (cheap gaming GPUs suit-\nablefordeeplearninguse150\u2013200W).Ifyouareluckyyourcurrentcomputersupports\nit.\n\u000f1 GPU. A low-end CPU with 4 cores will be sufficient and most motherboards suffice.\nAim for at least 32 GB DRAM and invest into an SSD for local data access. A power\nsupply with 600W should be sufficient. Buy a GPU with lots of fans.\n\u000f2GPUs. A low-end CPU with 4-6 cores will suffice.", "mimetype": "text/plain", "start_char_idx": 2134617, "end_char_idx": 2138565, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "114e7916-a391-46cf-9f33-ca3e9f21c476": {"__data__": {"id_": "114e7916-a391-46cf-9f33-ca3e9f21c476", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "131a694b-f269-449e-9d51-dc3e68c32971", "node_type": "1", "metadata": {}, "hash": "c17a93a3d02fe6070c263ccb4d67e1b9edf02c75906182d2b51dd46f3d17b16e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2aa194c7-cbf9-4543-b32a-0465e69af259", "node_type": "1", "metadata": {}, "hash": "795b96f7dc850c568216c1239a691f629a0d1252d306b5c93dcfa307445608b3", "class_name": "RelatedNodeInfo"}}, "text": "Somemotherboards\ndowngradeto8\u0002oreven4\u0002bandwidthwithmultipleGPUsinstalled. Thisispartlydue\nto the number of PCIe lanes that the CPU offers.\nIn short, here are some recommendations for building a deep learning server:\n\u000fBeginner . Buy a low end GPU with low power consumption (cheap gaming GPUs suit-\nablefordeeplearninguse150\u2013200W).Ifyouareluckyyourcurrentcomputersupports\nit.\n\u000f1 GPU. A low-end CPU with 4 cores will be sufficient and most motherboards suffice.\nAim for at least 32 GB DRAM and invest into an SSD for local data access. A power\nsupply with 600W should be sufficient. Buy a GPU with lots of fans.\n\u000f2GPUs. A low-end CPU with 4-6 cores will suffice. Aim for 64 GB DRAM and invest\ninto an SSD. You will need in the order of 1000W for two high-end GPUs. In terms\nof mainboards, make sure that they have twoPCIe 3.0 x16 slots. If you can, get a\nmainboard that has two free spaces (60mm spacing) between the PCIe 3.0 x16 slots\nfor extra air. In this case, buy two GPUs with lots of fans.\n\u000f4GPUs. MakesurethatyoubuyaCPUwithrelativelyfastsingle-threadspeed(i.e.,high\nclock frequency). You will probably need a CPU with a larger number of PCIe lanes,\nsuch as an AMD Threadripper. You will likely need relatively expensive mainboards\ntoget4PCIe3.0x16slotssincetheyprobablyneedaPLXtomultiplexthePCIelanes.\nBuyGPUswithreferencedesignthatarenarrowandletairinbetweentheGPUs. You\nneeda1600\u20132000Wpowersupplyandtheoutletinyourofficemightnotsupportthat.\nThis server will probably run loud and hot . You do not want it under your desk. 128\nGB of DRAM is recommended. Get an SSD (1\u20132 TB NVMe) for local storage and a\nbunch of hard disks in RAID configuration to store your data.\n\u000f8GPUs. Youneedtobuyadedicatedmulti-GPUserverchassiswithmultipleredundant\npower supplies (e.g., 2+1 for 1600W per power supply). This will require dual socket\nserver CPUs, 256 GB ECC DRAM, a fast network card (10 GBE recommended),\nand you will need to check whether the servers support the physical form factor of\nthe GPUs. Airflow and wiring placement differ significantly between consumer and\nserver GPUs (e.g., RTX 2080 vs. Tesla V100). This means that you might not be able\ntoinstalltheconsumerGPUinaserverduetoinsufficientclearanceforthepowercable\nor lack of a suitable wiring harness (as one of the coauthors painfully discovered).\nB.5.2SelectingGPUs\nAtpresent,AMDandNVIDIAarethetwomainmanufacturersofdedicatedGPUs. NVIDIA\nwas the first to enter the deep learning field and provides better support for deep learning\nframeworks via CUDA. Therefore, most buyers choose NVIDIA GPUs.\n1054 Tools for Deep Learning\nNVIDIA provides two types of GPUs, targeting individual users (e.g., via the GTX and\nRTX series) and enterprise users (via its Tesla series). The two types of GPUs provide\ncomparable compute power. However, the enterprise user GPUs generally use (passive)\nforced cooling, more memory, and ECC (error correcting) memory. These GPUs are more\nsuitable for data centers and usually cost ten times more than consumer GPUs.\nIfyouarealargecompanywith100+serversyoushouldconsidertheNVIDIATeslaseries\noralternativelyuseGPUserversinthecloud. Foralaborasmalltomediumcompanywith\n10+ servers the NVIDIA RTX series is likely most cost effective. You can buy preconfig-\nured servers with Supermicro or Asus chassis that hold 4\u20138 GPUs efficiently.\nGPU vendors typically release a new generation every one to two years, such as the GTX\n1000 (Pascal) series released in 2017 and the RTX 2000 (Turing) series released in 2019.\nEach series offers several different models that provide different performance levels. GPU\nperformance is primarily a combination of the following three parameters:\n1.Compute Power . Generally we look for 32-bit floating-point compute power. 16-bit\nfloatingpointtraining(FP16)isalsoenteringthemainstream.", "mimetype": "text/plain", "start_char_idx": 2137905, "end_char_idx": 2141704, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2aa194c7-cbf9-4543-b32a-0465e69af259": {"__data__": {"id_": "2aa194c7-cbf9-4543-b32a-0465e69af259", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "114e7916-a391-46cf-9f33-ca3e9f21c476", "node_type": "1", "metadata": {}, "hash": "dfb1fb3f1a6e394d128464931fb204275e4f318f0462d1828b1a377e4da5e06f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "06a9375e-686d-4938-936b-01084edc7b88", "node_type": "1", "metadata": {}, "hash": "cd5fd612a8b35e64d8cc3546e6b8594b49d75591588edffba71f7ba9d8740faf", "class_name": "RelatedNodeInfo"}}, "text": "Ifyouarealargecompanywith100+serversyoushouldconsidertheNVIDIATeslaseries\noralternativelyuseGPUserversinthecloud. Foralaborasmalltomediumcompanywith\n10+ servers the NVIDIA RTX series is likely most cost effective. You can buy preconfig-\nured servers with Supermicro or Asus chassis that hold 4\u20138 GPUs efficiently.\nGPU vendors typically release a new generation every one to two years, such as the GTX\n1000 (Pascal) series released in 2017 and the RTX 2000 (Turing) series released in 2019.\nEach series offers several different models that provide different performance levels. GPU\nperformance is primarily a combination of the following three parameters:\n1.Compute Power . Generally we look for 32-bit floating-point compute power. 16-bit\nfloatingpointtraining(FP16)isalsoenteringthemainstream. Ifyouareonlyinterested\ninprediction,youcanalsouse8-bitinteger. ThelatestgenerationofTuringGPUsoffers\n4-bit acceleration. Unfortunately at the time of writing the algorithms for training low-\nprecision networks are not yet widespread.\n2.MemorySize . As your models become larger or the batches used during training grow\nbigger,youwillneedmoreGPUmemory. CheckforHBM2(HighBandwidthMemory)\nvs. GDDR6 (Graphics DDR) memory. HBM2 is faster but much more expensive.\n3.MemoryBandwidth . You can only get the most out of your compute power when you\nhave sufficient memory bandwidth. Look for wide memory buses if using GDDR6.\nFormostusers,itisenoughtolookatcomputepower. NotethatmanyGPUsofferdifferent\ntypes of acceleration. For example, NVIDIA\u2019s TensorCores accelerate a subset of opera-\ntors by 5\u0002. Ensure that your libraries support this. The GPU memory should be no less\nthan 4 GB (8 GB is much better). Try to avoid using the GPU also for displaying a GUI\n(use the built-in graphics instead). If you cannot avoid it, add an extra 2 GB of RAM for\nsafety.\nFig. B.1 compares the 32-bit floating-point compute power and price of the various GTX\n900, GTX 1000 and RTX 2000 series models. The prices suggested are those found on\nWikipedia at the time of writing.\nWe can see a number of things:\n1.Withineachseries,priceandperformanceareroughlyproportional. Titanmodelscom-\nmand a significant premium for the benefit of larger amounts of GPU memory. How-\never, the newer models offer better cost effectiveness, as can be seen by comparing the\n980Tiand1080Ti. ThepricedoesnotappeartoimprovemuchfortheRTX2000series.\nHowever, this is due to the fact that they offer far superior low precision performance\n(FP16, INT8, and INT4).\n1055 Selecting Servers and GPUs\ntFig. B.1 Floating-point compute power and price comparison.\n2.The performance-to-cost ratio of the GTX 1000 series is about two times greater than\nthe 900 series.\n3.FortheRTX2000seriestheperformance(inGFLOPs)isan a\ufb00inefunctionoftheprice.\ntFig. B.2 Floating-point compute power and energy consumption.\nFig. B.2 shows how energy consumption scales mostly linearly with the amount of com-\n1056 Tools for Deep Learning\n306\n307\n308\n309\n310putation. Second, later generations are more efficient. This seems to be contradicted by\nthe graph corresponding to the RTX 2000 series. However, this is a consequence of the\nTensorCores that draw disproportionately much energy.\nB.5.3Summary\n\u000fWatch out for power, PCIe bus lanes, CPU single thread speed, and cooling when build-\ning a server.\n\u000fYou should purchase the latest GPU generation if possible.\n\u000fUse the cloud for large deployments.\n\u000fHigh density servers may not be compatible with all GPUs. Check the mechanical and\ncooling specifications before you buy.\n\u000fUse FP16 or lower precision for high efficiency.\nDiscussions306.\nB.6Contributing to This Book\nContributionsby readers307helpusimprovethisbook. Ifyoufindatypo,anoutdatedlink,\nsomething where you think we missed a citation, where the code does not look elegant or\nwhereanexplanationisunclear,pleasecontributebackandhelpushelpourreaders. While\nin regular books the delay between print runs (and thus between typo corrections) can be\nmeasured in years, it typically takes hours to days to incorporate an improvement in this\nbook.", "mimetype": "text/plain", "start_char_idx": 2140910, "end_char_idx": 2144976, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "06a9375e-686d-4938-936b-01084edc7b88": {"__data__": {"id_": "06a9375e-686d-4938-936b-01084edc7b88", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2aa194c7-cbf9-4543-b32a-0465e69af259", "node_type": "1", "metadata": {}, "hash": "795b96f7dc850c568216c1239a691f629a0d1252d306b5c93dcfa307445608b3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3d7b892f-11b9-4ba4-b71f-980ca9b7c99a", "node_type": "1", "metadata": {}, "hash": "ca8e3408d805473badc9ac96b5763beaa2bcd57b7a946f2d1cd844482f3994cd", "class_name": "RelatedNodeInfo"}}, "text": "\u000fYou should purchase the latest GPU generation if possible.\n\u000fUse the cloud for large deployments.\n\u000fHigh density servers may not be compatible with all GPUs. Check the mechanical and\ncooling specifications before you buy.\n\u000fUse FP16 or lower precision for high efficiency.\nDiscussions306.\nB.6Contributing to This Book\nContributionsby readers307helpusimprovethisbook. Ifyoufindatypo,anoutdatedlink,\nsomething where you think we missed a citation, where the code does not look elegant or\nwhereanexplanationisunclear,pleasecontributebackandhelpushelpourreaders. While\nin regular books the delay between print runs (and thus between typo corrections) can be\nmeasured in years, it typically takes hours to days to incorporate an improvement in this\nbook. Thisisallpossibleduetoversioncontrolandcontinuousintegration(CI)testing. To\ndosoyouneedtosubmita pullrequest308totheGitHubrepository. Whenyourpullrequest\nis merged into the code repository by the authors, you will become a contributor.\nB.6.1Submitting Minor Changes\nThe most common contributions are editing one sentence or fixing typos. We recommend\nthat you find the source file in the GitHub repository309and edit the file directly. For\nexample, you can search the file through the Find file310button (Fig. B.1) to locate the\nsource file (a markdown file). Then you click the \u201cEdit this file\u201d button on the upper-right\ncorner to make your changes in the markdown file.\nAfter you are done, fill in your change descriptions in the \u201cPropose file change\u201d panel on\nthe page bottom and then click the \u201cPropose file change\u201d button. It will redirect you to a\nnew page to review your changes ( Fig. B.7). If everything is good, you can submit a pull\nrequest by clicking the \u201cCreate pull request\u201d button.\n1057 Contributing to This Book\ntFig. B.1 Edit the \ufb01le on Github.\n311\n312B.6.2ProposingMajorChanges\nIf you plan to update a large portion of text or code, then you need to know a little bit more\nabout the format this book is using. The source file is based on the markdown format311\nwith a set of extensions through the D2L-Book312package such as referring to equations,\nimages, chapters, and citations. You can use any markdown editors to open these files and\nmake your changes.\nIf you would like to change the code, we recommend that you use the Jupyter Notebook to\nopen these markdown files as described in Section B.1 , so that you can run and test your\nchanges. Please remember to clear all outputs before submitting your changes since our CI\nsystem will execute the sections you updated to generate outputs.\nSome sections may support multiple framework implementations. If you add a new code\nblock, please use %%tabto mark this block on the beginning line. For example, %%tab\npytorch for a PyTorch code block, %%tab tensorflow for a TensorFlow code block, or\n%%tab all a shared code block for all implementations. You may refer to the d2lbook\npackage for more information.\nB.6.3Submitting MajorChanges\nWe suggest you to use the standard Git process to submit a major change. In a nutshell the\nprocess works as described in Fig. B.2.\ntFig. B.2 Contributing to the book.\nWe will walk you through the steps in detail. If you are already familiar with Git you\ncan skip this section. For concreteness we assume that the contributor\u2019s user name is \u201cas-\ntonzhang\u201d.\n1058 Tools for Deep Learning\n313\n314\n315Installing Git\nThe Git open-source book describes how to install Git313. This typically works via apt\ninstall git on Ubuntu Linux, by installing the Xcode developer tools on macOS, or by\nusing GitHub\u2019s desktop client314. If you do not have a GitHub account, you need to sign\nup for one.\nLogging in to GitHub\nEnter the address315of the book\u2019s code repository in your browser. Click on the Fork\nbutton in the red box at the upper-right of Fig. B.3, to make a copy of the repository of this\nbook. This is now yourcopy and you can change it any way you want.\ntFig. B.3 The code repository page.\nNow, the code repository of this book will be forked (i.e., copied) to your username, such\nasastonzhang/d2l-en shown at the upper-left of Fig. B.4.\ntFig. B.4 The forked code repository.", "mimetype": "text/plain", "start_char_idx": 2144229, "end_char_idx": 2148354, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3d7b892f-11b9-4ba4-b71f-980ca9b7c99a": {"__data__": {"id_": "3d7b892f-11b9-4ba4-b71f-980ca9b7c99a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "06a9375e-686d-4938-936b-01084edc7b88", "node_type": "1", "metadata": {}, "hash": "cd5fd612a8b35e64d8cc3546e6b8594b49d75591588edffba71f7ba9d8740faf", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "778b46dc-7e6a-4fdc-897d-085e54fc2cef", "node_type": "1", "metadata": {}, "hash": "17213c9d706333d924a03480415f888a7535fa6bf22f8ae6269821e32b8aef3b", "class_name": "RelatedNodeInfo"}}, "text": "This typically works via apt\ninstall git on Ubuntu Linux, by installing the Xcode developer tools on macOS, or by\nusing GitHub\u2019s desktop client314. If you do not have a GitHub account, you need to sign\nup for one.\nLogging in to GitHub\nEnter the address315of the book\u2019s code repository in your browser. Click on the Fork\nbutton in the red box at the upper-right of Fig. B.3, to make a copy of the repository of this\nbook. This is now yourcopy and you can change it any way you want.\ntFig. B.3 The code repository page.\nNow, the code repository of this book will be forked (i.e., copied) to your username, such\nasastonzhang/d2l-en shown at the upper-left of Fig. B.4.\ntFig. B.4 The forked code repository.\nCloningthe Repository\nTo clone the repository (i.e., to make a local copy) we need to get its repository address.\nThe green button in Fig. B.5 displays this. Make sure that your local copy is up to date\nwith the main repository if you decide to keep this fork around for longer. For now simply\nfollow the instructions in Installation (page xxxiv) to get started. The main difference is\nthat you are now downloading yourownfork of the repository.\ntFig. B.5 Cloning the repository.\n1059 Contributing to This Book\n# Replace your_github_username with your GitHub username\ngit clone https: //github .com/your_github_username /d2l-en.git\nEditing and Pushing\nNowitistimetoeditthebook. ItisbesttoedititintheJupyterNotebookfollowinginstruc-\ntions inSection B.1 . Make the changes and check that they are OK. Assume that we have\nmodified a typo in the file ~/d2l-en/chapter_appendix-tools-for-deep-learning/\ncontributing.md . You can then check which files you have changed.\nAt this point Git will prompt that the chapter_appendix-tools-for-deep-learning/\ncontributing.md file has been modified.\nmylaptop:d2l-en me$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges not staged for commit:\n(use \"git add <file>...\" to update what will be committed)\n(use \"git checkout -- <file>...\" to discard changes in working directory)\nmodified: chapter_appendix-tools-for-deep-learning/contributing.md\nAfter confirming that this is what you want, execute the following command:\ngit add chapter_appendix -tools -for-deep -learning /contributing .md\ngit commit -m'Fix a typo in git documentation '\ngit push\nThe changed code will then be in your personal fork of the repository. To request the\naddition of your change, you have to create a pull request for the official repository of the\nbook.\nSubmittingPull Requests\nAs shown in Fig. B.6, go to your fork of the repository on GitHub and select \u201cNew pull\nrequest\u201d. This will open up a screen that shows you the changes between your edits and\nwhat is current in the main repository of the book.\ntFig. B.6 New pull request.\n1060 Tools for Deep Learning\n316\n317Finally, submit a pull request by clicking the button as shown in Fig. B.7. Make sure to\ndescribe the changes you have made in the pull request. This will make it easier for the\nauthors to review it and to merge it with the book. Depending on the changes, this might\ngetacceptedrightaway,rejected,ormorelikely,youwillgetsomefeedbackonthechanges.\nOnce you have incorporated them, you are good to go.\ntFig. B.7 Create pull request.\nB.6.4Summary\n\u000fYou can use GitHub to contribute to this book.\n\u000fYou can edit the file on GitHub directly for minor changes.\n\u000fFor a major change, please fork the repository, edit things locally, and only contribute\nback once you are ready.\n\u000fPull requests are how contributions are being bundled up. Try not to submit huge pull\nrequestssincethismakesthemhardtounderstandandincorporate. Bettersendseveral\nsmaller ones.\nB.6.5Exercises\n1.Star and fork the d2l-ai/d2l-en repository.\n2.If you spot anything that needs improvement (e.g., missing a reference), submit a pull\nrequest.\n3.It is usually a better practice to create a pull request using a new branch. Learn how to\ndo it with Git branching316.\nDiscussions317.", "mimetype": "text/plain", "start_char_idx": 2147651, "end_char_idx": 2151610, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "778b46dc-7e6a-4fdc-897d-085e54fc2cef": {"__data__": {"id_": "778b46dc-7e6a-4fdc-897d-085e54fc2cef", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3d7b892f-11b9-4ba4-b71f-980ca9b7c99a", "node_type": "1", "metadata": {}, "hash": "ca8e3408d805473badc9ac96b5763beaa2bcd57b7a946f2d1cd844482f3994cd", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0bc868de-49dc-44bb-bc86-95e6e03ce24c", "node_type": "1", "metadata": {}, "hash": "6581c3b2d5dd0f707e04bd85bf756362d5979075543d9579f5472e577560acd5", "class_name": "RelatedNodeInfo"}}, "text": "tFig. B.7 Create pull request.\nB.6.4Summary\n\u000fYou can use GitHub to contribute to this book.\n\u000fYou can edit the file on GitHub directly for minor changes.\n\u000fFor a major change, please fork the repository, edit things locally, and only contribute\nback once you are ready.\n\u000fPull requests are how contributions are being bundled up. Try not to submit huge pull\nrequestssincethismakesthemhardtounderstandandincorporate. Bettersendseveral\nsmaller ones.\nB.6.5Exercises\n1.Star and fork the d2l-ai/d2l-en repository.\n2.If you spot anything that needs improvement (e.g., missing a reference), submit a pull\nrequest.\n3.It is usually a better practice to create a pull request using a new branch. Learn how to\ndo it with Git branching316.\nDiscussions317.\nB.7UtilityFunctions and Classes\nThis section contains the implementations of utility functions and classes used in this\nbook.\n1061 Utility Functions and Classes\nimport collections\nimport inspect\nfrom IPython import display\nfrom torch import nn\nfrom d2l import torch asd2l\nHyperparameters.\n@d2l .add_to_class(d2l .HyperParameters) #@save\ndef save_hyperparameters (self , ignore =[]):\n\"\"\"Save function arguments into class attributes.\"\"\"\nframe =inspect .currentframe() .f_back\n_, _, _, local_vars =inspect .getargvalues(frame)\nself .hparams ={k:v for k, v inlocal_vars .items()\nifknot inset(ignore +['self '])and not k.startswith( '_')}\nfor k, v inself .hparams .items():\nsetattr (self , k, v)\nProgress bar.", "mimetype": "text/plain", "start_char_idx": 2150870, "end_char_idx": 2152316, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0bc868de-49dc-44bb-bc86-95e6e03ce24c": {"__data__": {"id_": "0bc868de-49dc-44bb-bc86-95e6e03ce24c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "778b46dc-7e6a-4fdc-897d-085e54fc2cef", "node_type": "1", "metadata": {}, "hash": "17213c9d706333d924a03480415f888a7535fa6bf22f8ae6269821e32b8aef3b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "83cac814-a32f-4ef9-93f9-514c40403b2f", "node_type": "1", "metadata": {}, "hash": "39a2d2409f211767012685113afc89da78ceb299a64068343681bf2edaa2b6ab", "class_name": "RelatedNodeInfo"}}, "text": "Learn how to\ndo it with Git branching316.\nDiscussions317.\nB.7UtilityFunctions and Classes\nThis section contains the implementations of utility functions and classes used in this\nbook.\n1061 Utility Functions and Classes\nimport collections\nimport inspect\nfrom IPython import display\nfrom torch import nn\nfrom d2l import torch asd2l\nHyperparameters.\n@d2l .add_to_class(d2l .HyperParameters) #@save\ndef save_hyperparameters (self , ignore =[]):\n\"\"\"Save function arguments into class attributes.\"\"\"\nframe =inspect .currentframe() .f_back\n_, _, _, local_vars =inspect .getargvalues(frame)\nself .hparams ={k:v for k, v inlocal_vars .items()\nifknot inset(ignore +['self '])and not k.startswith( '_')}\nfor k, v inself .hparams .items():\nsetattr (self , k, v)\nProgress bar.\n@d2l .add_to_class(d2l .ProgressBoard) #@save\ndef draw (self , x, y, label, every_n =1):\nPoint =collections .namedtuple( 'Point ', ['x','y'])\nifnot hasattr (self ,'raw_points '):\nself .raw_points =collections .OrderedDict()\nself .data =collections .OrderedDict()\niflabel not inself .raw_points:\nself .raw_points[label] =[]\nself .data[label] =[]\npoints =self .raw_points[label]\nline =self .data[label]\npoints .append(Point(x, y))\niflen(points) !=every_n:\nreturn\nmean =lambda x:sum(x) /len(x)\nline .append(Point(mean([p .xfor pinpoints]),\nmean([p .yfor pinpoints])))\npoints .clear()\nifnot self .display:\nreturn\nd2l.use_svg_display()\nifself .fig isNone :\nself .fig =d2l.plt.figure(figsize =self .figsize)\nplt_lines, labels =[], []\nfor (k, v), ls, color inzip(self .data .items(), self .ls, self .colors):\nplt_lines .append(d2l .plt.plot([p .xfor pinv], [p .yfor pinv],\nlinestyle =ls, color =color)[ 0])\nlabels .append(k)\naxes =self .axes ifself .axes else d2l.plt.gca()\nifself .xlim: axes .set_xlim( self .xlim)\nifself .ylim: axes .set_ylim( self .ylim)\nifnot self .xlabel: self .xlabel =self .x\naxes .set_xlabel( self .xlabel)\naxes .set_ylabel( self .ylabel)\n(continues on next page)\n1062 Tools for Deep Learning\n(continued from previous page)\naxes .set_xscale( self .xscale)\naxes .set_yscale( self .yscale)\naxes .legend(plt_lines, labels)\ndisplay .display( self .fig)\ndisplay .clear_output(wait =True )\nAdd FrozenLake enviroment\ndef frozen_lake (seed): #@save\n# See https://www.gymlibrary.dev/environments/toy_text/frozen_lake/ to \u2423\n\u21a9!learn more about this env\n# How to process env.P.items is adpated from https://sites.google.com/view/\n\u21a9!deep-rl-bootcamp/labs\nimport gym\nenv =gym.make( 'FrozenLake-v1 ', is_slippery =False )\nenv.seed(seed)\nenv.action_space .np_random .seed(seed)\nenv.action_space .seed(seed)\nenv_info ={}\nenv_info[ 'desc ']=env.desc # 2D array specifying what each grid item \u2423\n\u21a9!means\nenv_info[ 'num_states ']=env.nS # Number of observations/states or obs/\n\u21a9!state dim\nenv_info[ 'num_actions ']=env.nA # Number of actions or action dim\n# Define indices for (transition probability, nextstate, reward, done) \u2423\n\u21a9!tuple\nenv_info[ 'trans_prob_idx ']=0# Index of transition probability entry\nenv_info[ 'nextstate_idx ']=1# Index of next state entry\nenv_info[ 'reward_idx ']=2# Index of reward entry\nenv_info[ 'done_idx ']=3# Index of done entry\nenv_info[ 'mdp']={}\nenv_info[ 'env']=env\nfor (s, others) inenv.P.items():\n# others(s) = {a0: [ (p(s'|s,a0), s', reward, done),...], a1:[...], ...\n\u21a9!}\nfor (a, pxrds) inothers .items():\n# pxrds is [(p1,next1,r1,d1),(p2,next2,r2,d2),..].\n# e.g.", "mimetype": "text/plain", "start_char_idx": 2151553, "end_char_idx": 2154915, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "83cac814-a32f-4ef9-93f9-514c40403b2f": {"__data__": {"id_": "83cac814-a32f-4ef9-93f9-514c40403b2f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0bc868de-49dc-44bb-bc86-95e6e03ce24c", "node_type": "1", "metadata": {}, "hash": "6581c3b2d5dd0f707e04bd85bf756362d5979075543d9579f5472e577560acd5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "76e44ce9-23db-4a3c-bd4f-1783aee6042f", "node_type": "1", "metadata": {}, "hash": "2e45813bdf58e6b602a836c6f0268b23fdce66d1d387db02c61c36c8502c71d2", "class_name": "RelatedNodeInfo"}}, "text": "\u21a9!}\nfor (a, pxrds) inothers .items():\n# pxrds is [(p1,next1,r1,d1),(p2,next2,r2,d2),..].\n# e.g. [(0.3, 0, 0, False), (0.3, 0, 0, False), (0.3, 4, 1, False)]\nenv_info[ 'mdp'][(s,a)] =pxrds\nreturn env_info\nCreate enviroment\ndef make_env (name ='', seed =0):#@save\n# Input parameters:\n# name: specifies a gym environment.\n# For Value iteration, only FrozenLake-v1 is supported.\nifname =='FrozenLake-v1 ':\nreturn frozen_lake(seed)\n(continues on next page)\n1063 Utility Functions and Classes\n(continued from previous page)\nelse :\nraise ValueError (\"%senv is not supported in this Notebook \")\nShow value function\ndef show_value_function_progress (env_desc, V, pi): #@save\n# This function visualizes how value and policy changes over time.\n# V: [num_iters, num_states]\n# pi: [num_iters, num_states]\n# How to visualize value function is adapted (but changed) from: https://\n\u21a9!sites.google.com/view/deep-rl-bootcamp/labs\nnum_iters =V.shape[ 0]\nfig, ax =plt.subplots(figsize =(15,15))\nfor kinrange (V.shape[ 0]):\nplt.subplot( 4,4, k +1)\nplt.imshow(V[k] .reshape( 4,4), cmap =\"bone \")\nax=plt.gca()\nax.set_xticks(np .arange( 0,5)-.5, minor =True )\nax.set_yticks(np .arange( 0,5)-.5, minor =True )\nax.grid(which =\"minor \", color =\"w\", linestyle ='-', linewidth =3)\nax.tick_params(which =\"minor \", bottom =False , left =False )\nax.set_xticks([])\nax.set_yticks([])\n# LEFT action: 0, DOWN action: 1\n# RIGHT action: 2, UP action: 3\naction2dxdy ={0:(-.25,0),1: (0,.25),\n2:(0.25 ,0),3: (-.25,0)}\nfor yinrange (4):\nfor xinrange (4):\naction =pi[k] .reshape( 4,4)[y, x]\ndx, dy =action2dxdy[action]\nifenv_desc[y,x] .decode() =='H':\nax.text(x, y, str(env_desc[y,x] .decode()),\nha=\"center \", va =\"center \", color =\"y\",\nsize =20, fontweight ='bold ')\nelif env_desc[y,x] .decode() =='G':\nax.text(x, y, str(env_desc[y,x] .decode()),\nha=\"center \", va =\"center \", color =\"w\",\nsize =20, fontweight ='bold ')\nelse :\nax.text(x, y, str(env_desc[y,x] .decode()),\nha=\"center \", va =\"center \", color =\"g\",\nsize =15, fontweight ='bold ')\n# No arrow for cells with G and H labels\nifenv_desc[y,x] .decode() !='G'and env_desc[y,x] .decode() !=\n(continues on next page)\n1064 Tools for Deep Learning\n(continued from previous page)\n\u21a9!'H':\nax.arrow(x, y, dx, dy, color ='r', head_width =0.2, head_\n\u21a9!length =0.15 )\nax.set_title( \"Step = \"+str(k+1), fontsize =20)\nfig.tight_layout()\nplt.show()\nShow Q function\ndef show_Q_function_progress (env_desc, V_all, pi_all): #@save\n# This function visualizes how value and policy changes over time.", "mimetype": "text/plain", "start_char_idx": 2154820, "end_char_idx": 2157313, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "76e44ce9-23db-4a3c-bd4f-1783aee6042f": {"__data__": {"id_": "76e44ce9-23db-4a3c-bd4f-1783aee6042f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "83cac814-a32f-4ef9-93f9-514c40403b2f", "node_type": "1", "metadata": {}, "hash": "39a2d2409f211767012685113afc89da78ceb299a64068343681bf2edaa2b6ab", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7a590fa2-8cc0-4b6a-b932-0cb1da7dc52d", "node_type": "1", "metadata": {}, "hash": "324b8afad7bd4f5f24ba83ee1fdfa0306937648350f8ef173c42956df670fb02", "class_name": "RelatedNodeInfo"}}, "text": "'H':\nax.arrow(x, y, dx, dy, color ='r', head_width =0.2, head_\n\u21a9!length =0.15 )\nax.set_title( \"Step = \"+str(k+1), fontsize =20)\nfig.tight_layout()\nplt.show()\nShow Q function\ndef show_Q_function_progress (env_desc, V_all, pi_all): #@save\n# This function visualizes how value and policy changes over time.\n# V: [num_iters, num_states]\n# pi: [num_iters, num_states]\n# We want to only shows few values\nnum_iters_all =V_all .shape[ 0]\nnum_iters =num_iters_all //10\nvis_indx =np.arange( 0, num_iters_all, num_iters) .tolist()\nvis_indx .append(num_iters_all -1)\nV=np.zeros(( len(vis_indx), V_all .shape[ 1]))\npi=np.zeros(( len(vis_indx), V_all .shape[ 1]))\nfor c, i inenumerate (vis_indx):\nV[c] =V_all[i]\npi[c] =pi_all[i]\nnum_iters =V.shape[ 0]\nfig, ax =plt.subplots(figsize =(15,15))\nfor kinrange (V.shape[ 0]):\nplt.subplot( 4,4, k +1)\nplt.imshow(V[k] .reshape( 4,4), cmap =\"bone \")\nax=plt.gca()\nax.set_xticks(np .arange( 0,5)-.5, minor =True )\nax.set_yticks(np .arange( 0,5)-.5, minor =True )\nax.grid(which =\"minor \", color =\"w\", linestyle ='-', linewidth =3)\nax.tick_params(which =\"minor \", bottom =False , left =False )\nax.set_xticks([])\nax.set_yticks([])\n# LEFT action: 0, DOWN action: 1\n# RIGHT action: 2, UP action: 3\naction2dxdy ={0:(-.25,0),1:(0,.25),\n2:(0.25 ,0),3:(-.25,0)}\nfor yinrange (4):\nfor xinrange (4):\naction =pi[k] .reshape( 4,4)[y, x]\ndx, dy =action2dxdy[action]\nifenv_desc[y,x] .decode() =='H':\n(continues on next page)\n1065 Utility Functions and Classes\n(continued from previous page)\nax.text(x, y, str(env_desc[y,x] .decode()),\nha=\"center \", va =\"center \", color =\"y\",\nsize =20, fontweight ='bold ')\nelif env_desc[y,x] .decode() =='G':\nax.text(x, y, str(env_desc[y,x] .decode()),\nha=\"center \", va =\"center \", color =\"w\",\nsize =20, fontweight ='bold ')\nelse :\nax.text(x, y, str(env_desc[y,x] .decode()),\nha=\"center \", va =\"center \", color =\"g\",\nsize =15, fontweight ='bold ')\n# No arrow for cells with G and H labels\nifenv_desc[y,x] .decode() !='G'and env_desc[y,x] .decode() !=\n\u21a9!'H':\nax.arrow(x, y, dx, dy, color ='r', head_width =0.2, head_\n\u21a9!length =0.15 )\nax.set_title( \"Step = \"+str(vis_indx[k] +1), fontsize =20)\nfig.tight_layout()\nplt.show()\nTrainer\nA bunch of functions that will be deprecated:\ndef load_array (data_arrays, batch_size, is_train =True ): #@save\n\"\"\"Construct a PyTorch data iterator.\"\"\"\ndataset =torch .utils .data .TensorDataset( *data_arrays)\nreturn torch .utils .data .DataLoader(dataset, batch_size, shuffle =is_train)\ndef synthetic_data (w, b, num_examples): #@save\n\"\"\"Generate y = Xw + b + noise.\"\"\"\nX=torch .normal( 0,1, (num_examples, len(w)))\ny=torch .matmul(X, w) +b\ny+=torch .normal( 0,0.01 , y.shape)\nreturn X, y .reshape(( -1,1))\ndef sgd(params, lr, batch_size): #@save\n\"\"\"Minibatch stochastic gradient descent.\"\"\"\nwith torch .no_grad():\nfor param inparams:\nparam -=lr*param .grad /batch_size\nparam .grad .zero_()\ndef get_dataloader_workers (): #@save\n\"\"\"Use 4 processes to read the data.\"\"\"\nreturn 4\ndef load_data_fashion_mnist (batch_size, resize =None ): #@save\n\"\"\"Download the Fashion-MNIST dataset and then load it into memory.\"\"\"", "mimetype": "text/plain", "start_char_idx": 2157010, "end_char_idx": 2160098, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7a590fa2-8cc0-4b6a-b932-0cb1da7dc52d": {"__data__": {"id_": "7a590fa2-8cc0-4b6a-b932-0cb1da7dc52d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "76e44ce9-23db-4a3c-bd4f-1783aee6042f", "node_type": "1", "metadata": {}, "hash": "2e45813bdf58e6b602a836c6f0268b23fdce66d1d387db02c61c36c8502c71d2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "603b65f3-ad11-4cc5-a42e-6a65a7759c8a", "node_type": "1", "metadata": {}, "hash": "3cca60bbefbbd7220eb56c0269694c5210832a70a2f063843332018cbbbc6f1f", "class_name": "RelatedNodeInfo"}}, "text": "X=torch .normal( 0,1, (num_examples, len(w)))\ny=torch .matmul(X, w) +b\ny+=torch .normal( 0,0.01 , y.shape)\nreturn X, y .reshape(( -1,1))\ndef sgd(params, lr, batch_size): #@save\n\"\"\"Minibatch stochastic gradient descent.\"\"\"\nwith torch .no_grad():\nfor param inparams:\nparam -=lr*param .grad /batch_size\nparam .grad .zero_()\ndef get_dataloader_workers (): #@save\n\"\"\"Use 4 processes to read the data.\"\"\"\nreturn 4\ndef load_data_fashion_mnist (batch_size, resize =None ): #@save\n\"\"\"Download the Fashion-MNIST dataset and then load it into memory.\"\"\"\n(continues on next page)\n1066 Tools for Deep Learning\n(continued from previous page)\ntrans =[transforms .ToTensor()]\nifresize:\ntrans .insert( 0, transforms .Resize(resize))\ntrans =transforms .Compose(trans)\nmnist_train =torchvision .datasets .FashionMNIST(\nroot =\"../data \", train =True , transform =trans, download =True )\nmnist_test =torchvision .datasets .FashionMNIST(\nroot =\"../data \", train =False , transform =trans, download =True )\nreturn (torch .utils .data .DataLoader(mnist_train, batch_size, shuffle =True ,\nnum_workers =get_dataloader_workers()),\ntorch .utils .data .DataLoader(mnist_test, batch_size, shuffle =False ,\nnum_workers =get_dataloader_workers()))\ndef evaluate_accuracy_gpu (net, data_iter, device =None ):#@save\n\"\"\"Compute the accuracy for a model on a dataset using a GPU.\"\"\"\nifisinstance (net, nn .Module):\nnet.eval() # Set the model to evaluation mode\nifnot device:\ndevice =next (iter (net .parameters())) .device\n# No. of correct predictions, no. of predictions\nmetric =d2l.Accumulator( 2)\nwith torch .no_grad():\nfor X, y indata_iter:\nifisinstance (X, list ):\n# Required for BERT Fine-tuning (to be covered later)\nX=[x.to(device) for xinX]\nelse :\nX=X.to(device)\ny=y.to(device)\nmetric .add(d2l .accuracy(net(X), y), y .numel())\nreturn metric[ 0]/metric[ 1]\n#@save\ndef train_ch6 (net, train_iter, test_iter, num_epochs, lr, device):\n\"\"\"Train a model with a GPU (defined in Chapter 6).\"\"\"\ndef init_weights (m):\niftype (m) ==nn.Linear ortype (m) ==nn.Conv2d:\nnn.init .xavier_uniform_(m .weight)\nnet.apply(init_weights)\nprint ('training on ', device)\nnet.to(device)\noptimizer =torch .optim .SGD(net .parameters(), lr =lr)\nloss =nn.CrossEntropyLoss()\nanimator =d2l.Animator(xlabel ='epoch ', xlim =[1, num_epochs],\nlegend =['train loss ','train acc ','test acc '])\ntimer, num_batches =d2l.Timer(), len(train_iter)\nfor epoch inrange (num_epochs):\n# Sum of training loss, sum of training accuracy, no. of examples\nmetric =d2l.Accumulator( 3)\nnet.train()\nfor i, (X, y) inenumerate (train_iter):\ntimer .start()\noptimizer .zero_grad()\n(continues on next page)\n1067 Utility Functions and Classes\n(continued from previous page)\nX, y =X.to(device), y .to(device)\ny_hat =net(X)\nl=loss(y_hat, y)\nl.backward()\noptimizer .step()\nwith torch .no_grad():\nmetric .add(l *X.shape[ 0], d2l .accuracy(y_hat, y), X .shape[ 0])\ntimer .stop()\ntrain_l =metric[ 0]/metric[ 2]\ntrain_acc =metric[ 1]/metric[ 2]\nif(i+1)%(num_batches //5)==0ori==num_batches -1:\nanimator .add(epoch +(i+1)/num_batches,\n(train_l, train_acc, None ))\ntest_acc =evaluate_accuracy_gpu(net, test_iter)\nanimator .add(epoch +1, (None ,None , test_acc))\nprint (f'loss {train_l :.3f}, train acc {train_acc :.3f},'\nf'test acc {test_acc :.3f}')\nprint (f'{metric[ 2]*num_epochs /timer .sum() :.1f}examples/sec '\nf'on{str(device) }')\ndef show_images (imgs, num_rows, num_cols, titles =None , scale =1.5): #@save\n\"\"\"Plot a list of images.\"\"\"", "mimetype": "text/plain", "start_char_idx": 2159556, "end_char_idx": 2163004, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "603b65f3-ad11-4cc5-a42e-6a65a7759c8a": {"__data__": {"id_": "603b65f3-ad11-4cc5-a42e-6a65a7759c8a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7a590fa2-8cc0-4b6a-b932-0cb1da7dc52d", "node_type": "1", "metadata": {}, "hash": "324b8afad7bd4f5f24ba83ee1fdfa0306937648350f8ef173c42956df670fb02", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a82f46f7-2b71-4e3f-8953-9723bad9ee3a", "node_type": "1", "metadata": {}, "hash": "ba9be3beaa80c9443ef692fe298709ea6b2f78541eb835c2dfd65aab4e6119bf", "class_name": "RelatedNodeInfo"}}, "text": "figsize =(num_cols *scale, num_rows *scale)\n_, axes =d2l.plt.subplots(num_rows, num_cols, figsize =figsize)\naxes =axes .flatten()\nfor i, (ax, img) inenumerate (zip(axes, imgs)):\ntry:\nimg =img.detach() .numpy()\nexcept :\npass\nax.imshow(img)\nax.axes .get_xaxis() .set_visible( False )\nax.axes .get_yaxis() .set_visible( False )\niftitles:\nax.set_title(titles[i])\nreturn axes\ndef linreg (X, w, b): #@save\n\"\"\"The linear regression model.\"\"\"\nreturn torch .matmul(X, w) +b\ndef squared_loss (y_hat, y): #@save\n\"\"\"Squared loss.\"\"\"\nreturn (y_hat -y.reshape(y_hat .shape)) **2/2\ndef get_fashion_mnist_labels (labels): #@save\n\"\"\"Return text labels for the Fashion-MNIST dataset.\"\"\"\ntext_labels =['t-shirt ','trouser ','pullover ','dress ','coat ',\n'sandal ','shirt ','sneaker ','bag','ankle boot ']\nreturn [text_labels[ int(i)] for iinlabels]\nclass Animator :#@save\n\"\"\"For plotting data in animation.\"\"\"\n(continues on next page)\n1068 Tools for Deep Learning\n(continued from previous page)\ndef __init__ (self , xlabel =None , ylabel =None , legend =None , xlim =None ,\nylim =None , xscale ='linear ', yscale ='linear ',\nfmts =('-','m--','g-.','r:'), nrows =1, ncols =1,\nfigsize =(3.5,2.5)):\n# Incrementally plot multiple lines\niflegend isNone :\nlegend =[]\nd2l.use_svg_display()\nself .fig, self .axes =d2l.plt.subplots(nrows, ncols, figsize =figsize)\nifnrows *ncols ==1:\nself .axes =[self .axes, ]\n# Use a lambda function to capture arguments\nself .config_axes =lambda : d2l .set_axes(\nself .axes[ 0], xlabel, ylabel, xlim, ylim, xscale, yscale, legend)\nself .X,self .Y,self .fmts =None ,None , fmts\ndef add(self , x, y):\n# Add multiple data points into the figure\nifnot hasattr (y, \"__len__ \"):\ny=[y]\nn=len(y)\nifnot hasattr (x, \"__len__ \"):\nx=[x] *n\nifnot self .X:\nself .X=[[] for _inrange (n)]\nifnot self .Y:\nself .Y=[[] for _inrange (n)]\nfor i, (a, b) inenumerate (zip(x, y)):\nifaisnot None and bisnot None :\nself .X[i] .append(a)\nself .Y[i] .append(b)\nself .axes[ 0].cla()\nfor x, y, fmt inzip(self .X,self .Y,self .fmts):\nself .axes[ 0].plot(x, y, fmt)\nself .config_axes()\ndisplay .display( self .fig)\ndisplay .clear_output(wait =True )\nclass Accumulator :#@save\n\"\"\"For accumulating sums over `n` variables.\"\"\"\ndef __init__ (self , n):\nself .data =[0.0]*n\ndef add(self ,*args):\nself .data =[a+float (b) for a, b inzip(self .data, args)]\ndef reset (self ):\nself .data =[0.0]*len(self .data)\ndef __getitem__ (self , idx):\nreturn self .data[idx]\ndef accuracy (y_hat, y): #@save\n\"\"\"Compute the number of correct predictions.\"\"\"\n(continues on next page)\n1069 Utility Functions and Classes\n(continued from previous page)\niflen(y_hat .shape) >1and y_hat .shape[ 1]>1:\ny_hat =y_hat .argmax(axis =1)\ncmp =y_hat .type(y .dtype) ==y\nreturn float (cmp .type(y .dtype) .sum())\nimport hashlib\nimport os\nimport tarfile\nimport zipfile\nimport requests\ndef download (url, folder ='../data ', sha1_hash =None ): #@save\n\"\"\"Download a file to folder and return the local filepath.\"\"\"", "mimetype": "text/plain", "start_char_idx": 2163005, "end_char_idx": 2165956, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a82f46f7-2b71-4e3f-8953-9723bad9ee3a": {"__data__": {"id_": "a82f46f7-2b71-4e3f-8953-9723bad9ee3a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "603b65f3-ad11-4cc5-a42e-6a65a7759c8a", "node_type": "1", "metadata": {}, "hash": "3cca60bbefbbd7220eb56c0269694c5210832a70a2f063843332018cbbbc6f1f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fc5ddfb1-a8f2-4e1a-8283-8625bb07902e", "node_type": "1", "metadata": {}, "hash": "0188a11be4aff3f46bb78b132ee693035df341d22d63aba93ae82c8075c71ca5", "class_name": "RelatedNodeInfo"}}, "text": "(continues on next page)\n1069 Utility Functions and Classes\n(continued from previous page)\niflen(y_hat .shape) >1and y_hat .shape[ 1]>1:\ny_hat =y_hat .argmax(axis =1)\ncmp =y_hat .type(y .dtype) ==y\nreturn float (cmp .type(y .dtype) .sum())\nimport hashlib\nimport os\nimport tarfile\nimport zipfile\nimport requests\ndef download (url, folder ='../data ', sha1_hash =None ): #@save\n\"\"\"Download a file to folder and return the local filepath.\"\"\"\nifnot url.startswith( 'http '):\n# For back compatability\nurl, sha1_hash =DATA_HUB[url]\nos.makedirs(folder, exist_ok =True )\nfname =os.path .join(folder, url .split( '/')[-1])\n# Check if hit cache\nifos.path .exists(fname) and sha1_hash:\nsha1 =hashlib .sha1()\nwith open (fname, 'rb')asf:\nwhile True :\ndata =f.read( 1048576 )\nifnot data:\nbreak\nsha1 .update(data)\nifsha1 .hexdigest() ==sha1_hash:\nreturn fname\n# Download\nprint (f'Downloading {fname }from {url}...')\nr=requests .get(url, stream =True , verify =True )\nwith open (fname, 'wb')asf:\nf.write(r .content)\nreturn fname\ndef extract (filename, folder =None ): #@save\n\"\"\"Extract a zip/tar file into folder.\"\"\"\nbase_dir =os.path .dirname(filename)\n_, ext =os.path .splitext(filename)\nassert ext in('.zip ','.tar ','.gz'),'Only support zip/tar files. '\nifext =='.zip ':\nfp=zipfile .ZipFile(filename, 'r')\nelse :\nfp=tarfile .open(filename, 'r')\niffolder isNone :\nfolder =base_dir\nfp.extractall(folder)\ndef download_extract (name, folder =None ): #@save\n\"\"\"Download and extract a zip/tar file.\"\"\"\nfname =download(name)\n(continues on next page)\n1070 Tools for Deep Learning\n(continued from previous page)\nbase_dir =os.path .dirname(fname)\ndata_dir, ext =os.path .splitext(fname)\nifext =='.zip ':\nfp=zipfile .ZipFile(fname, 'r')\nelif ext in('.tar ','.gz'):\nfp=tarfile .open(fname, 'r')\nelse :\nassert False ,'Only zip/tar files can be extracted. '\nfp.extractall(base_dir)\nreturn os.path .join(base_dir, folder) iffolder else data_dir\ndef tokenize (lines, token ='word '): #@save\n\"\"\"Split text lines into word or character tokens.\"\"\"\nassert token in('word ','char '),'Unknown token type: '+token\nreturn [line .split() iftoken =='word 'else list (line) for line inlines]\ndef evaluate_loss (net, data_iter, loss): #@save\n\"\"\"Evaluate the loss of a model on the given dataset.\"\"\"\nmetric =d2l.Accumulator( 2)# Sum of losses, no. of examples\nfor X, y indata_iter:\nout =net(X)\ny=y.reshape(out .shape)\nl=loss(out, y)\nmetric .add(l .sum(), l .numel())\nreturn metric[ 0]/metric[ 1]\ndef grad_clipping (net, theta): #@save\n\"\"\"Clip the gradient.\"\"\"\nifisinstance (net, nn .Module):\nparams =[pfor pinnet.parameters() ifp.requires_grad]\nelse :\nparams =net.params\nnorm =torch .sqrt( sum(torch .sum((p .grad **2))for pinparams))\nifnorm >theta:\nfor param inparams:\nparam .grad[:] *=theta /norm\nMore for the attention chapter.\n#@save\nd2l.DATA_HUB[ 'fra-eng ']=(d2l .DATA_URL +'fra-eng.zip ',\n'94646ad1522d915e7b0f9296181140edcf86a4f5 ')\n#@save\ndef read_data_nmt ():\n\"\"\"Load the English-French dataset.\"\"\"\ndata_dir =d2l.download_extract( 'fra-eng ')\nwith open (os.path .join(data_dir, 'fra.txt '),'r', encoding ='utf-8 ')asf:\nreturn f.read()\n#@save\n(continues on next page)\n1071 Utility Functions and Classes\n(continued from previous page)\ndef preprocess_nmt (text):\n\"\"\"Preprocess the English-French dataset.\"\"\"\ndef no_space (char, prev_char):\nreturn char inset(',.!?", "mimetype": "text/plain", "start_char_idx": 2165518, "end_char_idx": 2168847, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fc5ddfb1-a8f2-4e1a-8283-8625bb07902e": {"__data__": {"id_": "fc5ddfb1-a8f2-4e1a-8283-8625bb07902e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a82f46f7-2b71-4e3f-8953-9723bad9ee3a", "node_type": "1", "metadata": {}, "hash": "ba9be3beaa80c9443ef692fe298709ea6b2f78541eb835c2dfd65aab4e6119bf", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1c7eab56-3747-4b7c-8f15-6dd3ef965227", "node_type": "1", "metadata": {}, "hash": "b584536c494dcbe1108563aa8dffa9759efc09c5d520679787522f072e3c611b", "class_name": "RelatedNodeInfo"}}, "text": "#@save\nd2l.DATA_HUB[ 'fra-eng ']=(d2l .DATA_URL +'fra-eng.zip ',\n'94646ad1522d915e7b0f9296181140edcf86a4f5 ')\n#@save\ndef read_data_nmt ():\n\"\"\"Load the English-French dataset.\"\"\"\ndata_dir =d2l.download_extract( 'fra-eng ')\nwith open (os.path .join(data_dir, 'fra.txt '),'r', encoding ='utf-8 ')asf:\nreturn f.read()\n#@save\n(continues on next page)\n1071 Utility Functions and Classes\n(continued from previous page)\ndef preprocess_nmt (text):\n\"\"\"Preprocess the English-French dataset.\"\"\"\ndef no_space (char, prev_char):\nreturn char inset(',.!? ')and prev_char !=''\n# Replace non-breaking space with space, and convert uppercase letters to\n# lowercase ones\ntext =text .replace( '\\u202f ','').replace( '\\xa0 ','').lower()\n# Insert space between words and punctuation marks\nout =[''+char ifi>0and no_space(char, text[i -1])else char\nfor i, char inenumerate (text)]\nreturn ''.join(out)\n#@save\ndef tokenize_nmt (text, num_examples =None ):\n\"\"\"Tokenize the English-French dataset.\"\"\"\nsource, target =[], []\nfor i, line inenumerate (text .split( '\\n')):\nifnum_examples and i>num_examples:\nbreak\nparts =line .split( '\\t')\niflen(parts) ==2:\nsource .append(parts[ 0].split( ''))\ntarget .append(parts[ 1].split( ''))\nreturn source, target\n#@save\ndef truncate_pad (line, num_steps, padding_token):\n\"\"\"Truncate or pad sequences.\"\"\"\niflen(line) >num_steps:\nreturn line[:num_steps] # Truncate\nreturn line +[padding_token] *(num_steps -len(line)) # Pad\n#@save\ndef build_array_nmt (lines, vocab, num_steps):\n\"\"\"Transform text sequences of machine translation into minibatches.\"\"\"\nlines =[vocab[l] for linlines]\nlines =[l+[vocab[ '<eos> ']]for linlines]\narray =torch .tensor([truncate_pad(\nl, num_steps, vocab[ '<pad> '])for linlines])\nvalid_len =(array !=vocab[ '<pad> ']).type(torch .int32) .sum( 1)\nreturn array, valid_len\n#@save\ndef load_data_nmt (batch_size, num_steps, num_examples =600):\n\"\"\"Return the iterator and the vocabularies of the translation dataset.\"\"\"\ntext =preprocess_nmt(read_data_nmt())\nsource, target =tokenize_nmt(text, num_examples)\nsrc_vocab =d2l.Vocab(source, min_freq =2,\nreserved_tokens =['<pad> ','<bos> ','<eos> '])\ntgt_vocab =d2l.Vocab(target, min_freq =2,\nreserved_tokens =['<pad> ','<bos> ','<eos> '])\n(continues on next page)\n1072 Tools for Deep Learning\n(continued from previous page)\nsrc_array, src_valid_len =build_array_nmt(source, src_vocab, num_steps)\ntgt_array, tgt_valid_len =build_array_nmt(target, tgt_vocab, num_steps)\ndata_arrays =(src_array, src_valid_len, tgt_array, tgt_valid_len)\ndata_iter =d2l.load_array(data_arrays, batch_size)\nreturn data_iter, src_vocab, tgt_vocab\n#@save\ndef sequence_mask (X, valid_len, value =0):\n\"\"\"Mask irrelevant entries in sequences.\"\"\"\nmaxlen =X.size( 1)\nmask =torch .arange((maxlen), dtype =torch .float32,\ndevice =X.device)[ None , :] <valid_len[:, None ]\nX[~mask] =value\nreturn X\n#@save\nclass MaskedSoftmaxCELoss (nn.CrossEntropyLoss):\n\"\"\"The softmax cross-entropy loss with masks.\"\"\"\n# `pred` shape: (`batch_size`, `num_steps`, `vocab_size`)\n# `label` shape: (`batch_size`, `num_steps`)\n# `valid_len` shape: (`batch_size`,)\ndef forward (self , pred, label, valid_len):\nweights =torch .ones_like(label)\nweights =sequence_mask(weights, valid_len)\nself .reduction ='none '\nunweighted_loss =super (MaskedSoftmaxCELoss, self ).forward(\npred .permute( 0,2,1), label)\nweighted_loss =(unweighted_loss *weights) .mean(dim =1)\nreturn weighted_loss\n#@save\ndef train_seq2seq (net, data_iter, lr, num_epochs, tgt_vocab, device):\n\"\"\"Train a model for sequence to sequence.\"\"\"", "mimetype": "text/plain", "start_char_idx": 2168308, "end_char_idx": 2171830, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1c7eab56-3747-4b7c-8f15-6dd3ef965227": {"__data__": {"id_": "1c7eab56-3747-4b7c-8f15-6dd3ef965227", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fc5ddfb1-a8f2-4e1a-8283-8625bb07902e", "node_type": "1", "metadata": {}, "hash": "0188a11be4aff3f46bb78b132ee693035df341d22d63aba93ae82c8075c71ca5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "50cf6ca3-55ba-48dd-a89b-5a39d8aed9a5", "node_type": "1", "metadata": {}, "hash": "bc9899088eeb76e486a6a2cec572855b90374aa6ea9913f21edb5e572a978784", "class_name": "RelatedNodeInfo"}}, "text": "# `pred` shape: (`batch_size`, `num_steps`, `vocab_size`)\n# `label` shape: (`batch_size`, `num_steps`)\n# `valid_len` shape: (`batch_size`,)\ndef forward (self , pred, label, valid_len):\nweights =torch .ones_like(label)\nweights =sequence_mask(weights, valid_len)\nself .reduction ='none '\nunweighted_loss =super (MaskedSoftmaxCELoss, self ).forward(\npred .permute( 0,2,1), label)\nweighted_loss =(unweighted_loss *weights) .mean(dim =1)\nreturn weighted_loss\n#@save\ndef train_seq2seq (net, data_iter, lr, num_epochs, tgt_vocab, device):\n\"\"\"Train a model for sequence to sequence.\"\"\"\ndef xavier_init_weights (m):\niftype (m) ==nn.Linear:\nnn.init .xavier_uniform_(m .weight)\niftype (m) ==nn.GRU:\nfor param inm._flat_weights_names:\nif\"weight \"inparam:\nnn.init .xavier_uniform_(m ._parameters[param])\nnet.apply(xavier_init_weights)\nnet.to(device)\noptimizer =torch .optim .Adam(net .parameters(), lr =lr)\nloss =MaskedSoftmaxCELoss()\nnet.train()\nanimator =d2l.Animator(xlabel ='epoch ', ylabel ='loss ',\nxlim =[10, num_epochs])\nfor epoch inrange (num_epochs):\ntimer =d2l.Timer()\nmetric =d2l.Accumulator( 2)# Sum of training loss, no. of tokens\nfor batch indata_iter:\noptimizer .zero_grad()\nX, X_valid_len, Y, Y_valid_len =[x.to(device) for xinbatch]\n(continues on next page)\n1073 Utility Functions and Classes\n(continued from previous page)\nbos =torch .tensor([tgt_vocab[ '<bos> ']]*Y.shape[ 0],\ndevice =device) .reshape( -1,1)\ndec_input =torch .cat([bos, Y[:, : -1]], 1)# Teacher forcing\nY_hat, _ =net(X, dec_input, X_valid_len)\nl=loss(Y_hat, Y, Y_valid_len)\nl.sum() .backward() # Make the loss scalar for `backward`\nd2l.grad_clipping(net, 1)\nnum_tokens =Y_valid_len .sum()\noptimizer .step()\nwith torch .no_grad():\nmetric .add(l .sum(), num_tokens)\nif(epoch +1)%10==0:\nanimator .add(epoch +1, (metric[ 0]/metric[ 1],))\nprint (f'loss {metric[ 0]/metric[ 1]:.3f},{metric[ 1]/timer .stop() :.1f}'\nf'tokens/sec on {str(device) }')\n#@save\ndef predict_seq2seq (net, src_sentence, src_vocab, tgt_vocab, num_steps,\ndevice, save_attention_weights =False ):\n\"\"\"Predict for sequence to sequence.\"\"\"", "mimetype": "text/plain", "start_char_idx": 2171253, "end_char_idx": 2173329, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "50cf6ca3-55ba-48dd-a89b-5a39d8aed9a5": {"__data__": {"id_": "50cf6ca3-55ba-48dd-a89b-5a39d8aed9a5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1c7eab56-3747-4b7c-8f15-6dd3ef965227", "node_type": "1", "metadata": {}, "hash": "b584536c494dcbe1108563aa8dffa9759efc09c5d520679787522f072e3c611b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "10f632a9-6683-4d18-8140-1b2a2babcd19", "node_type": "1", "metadata": {}, "hash": "6a84a85706c39c1eb288b69971353f035755fd450ef561ae349e3982519f6e44", "class_name": "RelatedNodeInfo"}}, "text": "# Set `net` to eval mode for inference\nnet.eval()\nsrc_tokens =src_vocab[src_sentence .lower() .split( '')]+[\nsrc_vocab[ '<eos> ']]\nenc_valid_len =torch .tensor([ len(src_tokens)], device =device)\nsrc_tokens =d2l.truncate_pad(src_tokens, num_steps, src_vocab[ '<pad> '])\n# Add the batch axis\nenc_X =torch .unsqueeze(\ntorch .tensor(src_tokens, dtype =torch .long, device =device), dim =0)\nenc_outputs =net.encoder(enc_X, enc_valid_len)\ndec_state =net.decoder .init_state(enc_outputs, enc_valid_len)\n# Add the batch axis\ndec_X =torch .unsqueeze(torch .tensor(\n[tgt_vocab[ '<bos> ']], dtype =torch .long, device =device), dim =0)\noutput_seq, attention_weight_seq =[], []\nfor _inrange (num_steps):\nY, dec_state =net.decoder(dec_X, dec_state)\n# We use the token with the highest prediction likelihood as input\n# of the decoder at the next time step\ndec_X =Y.argmax(dim =2)\npred =dec_X .squeeze(dim =0).type(torch .int32) .item()\n# Save attention weights (to be covered later)\nifsave_attention_weights:\nattention_weight_seq .append(net .decoder .attention_weights)\n# Once the end-of-sequence token is predicted, the generation of the\n# output sequence is complete\nifpred ==tgt_vocab[ '<eos> ']:\nbreak\noutput_seq .append(pred)\nreturn ''.join(tgt_vocab .to_tokens(output_seq)), attention_weight_seq\n1074 Tools for Deep Learning\n318B.8The d2lAPI Document\nThis section displays classes and functions (sorted alphabetically) in the d2lpackage,\nshowing where they are defined in the book so you can find more detailed implementa-\ntions and explanations. See also the source code on the GitHub repository318.\nB.8.1Classes\nclass d2l.torch.AdditiveAttention( num_hiddens ,dropout,**kwargs )\nBases: Module\nAdditive attention.\nDefined in Section 11.3.2\nforward( queries,keys,values,valid_lens )\nDefines the computation performed at every call.\nShould be overridden by all subclasses.\nNote:Although the recipe for forward pass needs to be defined within this function,\none should call the Module(page 1078) instance afterwards instead of this since the\nformertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem.\nclass d2l.torch.AddNorm( norm_shape ,dropout )\nBases: Module\nThe residual connection followed by layer normalization.\nDefined in Section 11.7.2\nforward( X,Y)\nDefines the computation performed at every call.\nShould be overridden by all subclasses.\nNote:Although the recipe for forward pass needs to be defined within this function,\none should call the Module(page 1078) instance afterwards instead of this since the\nformertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem.\nclass d2l.torch.AttentionDecoder\nBases: Decoder (page 1075)\nThe base attention-based decoder interface.\n1075 Thed2lAPI Document\nDefined in Section 11.4\nproperty attention_weights\nclass d2l.torch.Classifier( plot_train_per_epoch=2 ,plot_valid_per_epoch=1 )\nBases: Module(page 1078)\nThe base class of classification models.\nDefined in Section 4.3\naccuracy( Y_hat,Y,averaged=True )\nCompute the number of correct predictions.\nDefined in Section 4.3\nlayer_summary( X_shape )\nDefined in Section 7.6\nloss(Y_hat,Y,averaged=True )\nDefined in Section 4.5\nvalidation_step( batch )\nclass d2l.torch.DataModule( root=\u2019../data\u2019 ,num_workers=4 )\nBases: HyperParameters (page 1077)\nThe base class of data.\nDefined in Section 3.2.2\nget_dataloader( train )\nget_tensorloader( tensors,train,indices=slice(0,None,None) )\nDefined in Section 3.3\ntrain_dataloader()\nval_dataloader()\nclass d2l.torch.Decoder\nBases: Module\nThe base decoder interface for the encoder\u2013decoder architecture.\nDefined in Section 10.6\nforward( X,state)\nDefines the computation performed at every call.\nShould be overridden by all subclasses.\n1076 Tools for Deep Learning\nNote:Although the recipe for forward pass needs to be defined within this function,\none should call the Module(page 1078) instance afterwards instead of this since the\nformertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem.", "mimetype": "text/plain", "start_char_idx": 2173330, "end_char_idx": 2177298, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "10f632a9-6683-4d18-8140-1b2a2babcd19": {"__data__": {"id_": "10f632a9-6683-4d18-8140-1b2a2babcd19", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "50cf6ca3-55ba-48dd-a89b-5a39d8aed9a5", "node_type": "1", "metadata": {}, "hash": "bc9899088eeb76e486a6a2cec572855b90374aa6ea9913f21edb5e572a978784", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cf3e27ab-78d7-400e-b5bb-3b76538f9737", "node_type": "1", "metadata": {}, "hash": "997b170335774b9c3ff03fa8e86534c6abc431f06314c85a9d3d6138a3b4aa5e", "class_name": "RelatedNodeInfo"}}, "text": "Defined in Section 3.2.2\nget_dataloader( train )\nget_tensorloader( tensors,train,indices=slice(0,None,None) )\nDefined in Section 3.3\ntrain_dataloader()\nval_dataloader()\nclass d2l.torch.Decoder\nBases: Module\nThe base decoder interface for the encoder\u2013decoder architecture.\nDefined in Section 10.6\nforward( X,state)\nDefines the computation performed at every call.\nShould be overridden by all subclasses.\n1076 Tools for Deep Learning\nNote:Although the recipe for forward pass needs to be defined within this function,\none should call the Module(page 1078) instance afterwards instead of this since the\nformertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem.\ninit_state( enc_all_outputs ,*args )\nclass d2l.torch.DotProductAttention( dropout )\nBases: Module\nScaled dot product attention.\nDefined in Section 11.3.2\nforward( queries,keys,values,valid_lens=None )\nDefines the computation performed at every call.\nShould be overridden by all subclasses.\nNote:Although the recipe for forward pass needs to be defined within this function,\none should call the Module(page 1078) instance afterwards instead of this since the\nformertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem.\nclass d2l.torch.Encoder\nBases: Module\nThe base encoder interface for the encoder\u2013decoder architecture.\nDefined in Section 10.6\nforward( X,*args )\nDefines the computation performed at every call.\nShould be overridden by all subclasses.\nNote:Although the recipe for forward pass needs to be defined within this function,\none should call the Module(page 1078) instance afterwards instead of this since the\nformertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem.\nclass d2l.torch.EncoderDecoder( encoder,decoder )\nBases: Classifier (page 1075)\nThe base class for the encoder\u2013decoder architecture.\nDefined in Section 10.6\n1077 Thed2lAPI Document\nforward( enc_X,dec_X,*args )\nDefines the computation performed at every call.\nShould be overridden by all subclasses.\nNote:Although the recipe for forward pass needs to be defined within this function,\none should call the Module(page 1078) instance afterwards instead of this since the\nformertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem.\npredict_step( batch,device,num_steps ,save_attention_weights=False )\nDefined in Section 10.7.6\nclass d2l.torch.FashionMNIST( batch_size=64 ,resize=(28, 28) )\nBases: DataModule (page 1075)\nThe Fashion-MNIST dataset.\nDefined in Section 4.2\nget_dataloader( train )\nDefined in Section 4.2\ntext_labels( indices )\nReturn text labels.\nDefined in Section 4.2\nvisualize( batch,nrows=1 ,ncols=8,labels=[] )\nDefined in Section 4.2\nclass d2l.torch.GRU( num_inputs ,num_hiddens ,num_layers ,dropout=0 )\nBases: RNN(page 1081)\nThe multilayer GRU model.\nDefined in Section 10.3\nclass d2l.torch.HyperParameters\nBases: object\nThe base class of hyperparameters.\nsave_hyperparameters( ignore=[] )\nSave function arguments into class attributes.\nDefined in Section B.7\n1078 Tools for Deep Learning\nclass d2l.torch.LeNet( lr=0.1,num_classes=10 )\nBases: Classifier (page 1075)\nThe LeNet-5 model.\nDefined in Section 7.6\nclass d2l.torch.LinearRegression( lr)\nBases: Module(page 1078)\nThe linear regression model implemented with high-level APIs.\nDefined in Section 3.5\nconfigure_optimizers()\nDefined in Section 3.5\nforward( X)\nDefined in Section 3.5\nget_w_b()\nDefined in Section 3.5\nloss(y_hat,y)\nDefined in Section 3.5\nclass d2l.torch.LinearRegressionScratch( num_inputs ,lr,sigma=0.01 )\nBases: Module(page 1078)\nThe linear regression model implemented from scratch.\nDefined in Section 3.4\nconfigure_optimizers()\nDefined in Section 3.4\nforward( X)\nDefined in Section 3.4\nloss(y_hat,y)\nDefined in Section 3.4\nclass d2l.torch.Module( plot_train_per_epoch=2 ,plot_valid_per_epoch=1 )\nBases: Module,HyperParameters (page 1077)\nThe base class of models.", "mimetype": "text/plain", "start_char_idx": 2176622, "end_char_idx": 2180481, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cf3e27ab-78d7-400e-b5bb-3b76538f9737": {"__data__": {"id_": "cf3e27ab-78d7-400e-b5bb-3b76538f9737", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "10f632a9-6683-4d18-8140-1b2a2babcd19", "node_type": "1", "metadata": {}, "hash": "6a84a85706c39c1eb288b69971353f035755fd450ef561ae349e3982519f6e44", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5d01bac4-ab37-4172-9a26-7a88ab926f75", "node_type": "1", "metadata": {}, "hash": "d81d6f51eb86a3de78eda5e9c1bea6de4b8d777fb1b1d798488e464f8edb8a91", "class_name": "RelatedNodeInfo"}}, "text": "Defined in Section 3.5\nconfigure_optimizers()\nDefined in Section 3.5\nforward( X)\nDefined in Section 3.5\nget_w_b()\nDefined in Section 3.5\nloss(y_hat,y)\nDefined in Section 3.5\nclass d2l.torch.LinearRegressionScratch( num_inputs ,lr,sigma=0.01 )\nBases: Module(page 1078)\nThe linear regression model implemented from scratch.\nDefined in Section 3.4\nconfigure_optimizers()\nDefined in Section 3.4\nforward( X)\nDefined in Section 3.4\nloss(y_hat,y)\nDefined in Section 3.4\nclass d2l.torch.Module( plot_train_per_epoch=2 ,plot_valid_per_epoch=1 )\nBases: Module,HyperParameters (page 1077)\nThe base class of models.\nDefined in Section 3.2\napply_init( inputs,init=None )\nDefined in Section 6.4\n1079 Thed2lAPI Document\nconfigure_optimizers()\nDefined in Section 4.3\nforward( X)\nDefines the computation performed at every call.\nShould be overridden by all subclasses.\nNote:Although the recipe for forward pass needs to be defined within this function,\none should call the Module(page 1078) instance afterwards instead of this since the\nformertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem.\nloss(y_hat,y)\nplot(key,value,train )\nPlot a point in animation.\ntraining_step( batch )\nvalidation_step( batch )\nclass d2l.torch.MTFraEng( batch_size ,num_steps=9 ,num_train=512 ,\nnum_val=128 )\nBases: DataModule (page 1075)\nThe English-French dataset.\nDefined in Section 10.5\nbuild(src_sentences ,tgt_sentences )\nDefined in Section 10.5.3\nget_dataloader( train )\nDefined in Section 10.5.3\nclass d2l.torch.MultiHeadAttention( num_hiddens ,num_heads ,dropout,\nbias=False ,**kwargs )\nBases: Module(page 1078)\nMulti-head attention.\nDefined in Section 11.5\nforward( queries,keys,values,valid_lens )\nDefines the computation performed at every call.\nShould be overridden by all subclasses.\n1080 Tools for Deep Learning\nNote:Although the recipe for forward pass needs to be defined within this function,\none should call the Module(page 1078) instance afterwards instead of this since the\nformertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem.\ntranspose_output( X)\nReverse the operation of transpose_qkv.\nDefined in Section 11.5\ntranspose_qkv( X)\nTransposition for parallel computation of multiple attention heads.\nDefined in Section 11.5\nclass d2l.torch.PositionalEncoding( num_hiddens ,dropout,max_len=1000 )\nBases: Module\nPositional encoding.\nDefined in Section 11.6\nforward( X)\nDefines the computation performed at every call.\nShould be overridden by all subclasses.\nNote:Although the recipe for forward pass needs to be defined within this function,\none should call the Module(page 1078) instance afterwards instead of this since the\nformertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem.\nclass d2l.torch.PositionWiseFFN( ffn_num_hiddens ,ffn_num_outputs )\nBases: Module\nThe positionwise feed-forward network.\nDefined in Section 11.7\nforward( X)\nDefines the computation performed at every call.\nShould be overridden by all subclasses.\nNote:Although the recipe for forward pass needs to be defined within this function,\none should call the Module(page 1078) instance afterwards instead of this since the\nformertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem.\n1081 Thed2lAPI Document\nclass d2l.torch.ProgressBoard( xlabel=None ,ylabel=None ,xlim=None ,\nylim=None ,xscale=\u2019linear\u2019 ,yscale=\u2019linear\u2019 ,\nls=[\u2019-\u2019,\u2019--\u2019,\u2019-.\u2019,\u2019:\u2019] ,colors=[\u2019C0\u2019,\u2019C1\u2019,\u2019C2\u2019,\n\u2019C3\u2019],fig=None ,axes=None ,figsize=(3.5, 2.5) ,\ndisplay=True )\nBases: HyperParameters (page 1077)\nThe board that plots data points in animation.\nDefined in Section 3.2\ndraw(x,y,label,every_n=1 )\nDefined in Section B.7\nclass d2l.torch.Residual( num_channels ,use_1x1conv=False ,strides=1 )\nBases: Module\nThe Residual block of ResNet models.", "mimetype": "text/plain", "start_char_idx": 2179878, "end_char_idx": 2183620, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5d01bac4-ab37-4172-9a26-7a88ab926f75": {"__data__": {"id_": "5d01bac4-ab37-4172-9a26-7a88ab926f75", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cf3e27ab-78d7-400e-b5bb-3b76538f9737", "node_type": "1", "metadata": {}, "hash": "997b170335774b9c3ff03fa8e86534c6abc431f06314c85a9d3d6138a3b4aa5e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6c21240c-9f22-43ba-8351-cdc428bb9db7", "node_type": "1", "metadata": {}, "hash": "f75383ba5cd49416a9e5a96456776920c91d15fe651c738251147607f49614cc", "class_name": "RelatedNodeInfo"}}, "text": "1081 Thed2lAPI Document\nclass d2l.torch.ProgressBoard( xlabel=None ,ylabel=None ,xlim=None ,\nylim=None ,xscale=\u2019linear\u2019 ,yscale=\u2019linear\u2019 ,\nls=[\u2019-\u2019,\u2019--\u2019,\u2019-.\u2019,\u2019:\u2019] ,colors=[\u2019C0\u2019,\u2019C1\u2019,\u2019C2\u2019,\n\u2019C3\u2019],fig=None ,axes=None ,figsize=(3.5, 2.5) ,\ndisplay=True )\nBases: HyperParameters (page 1077)\nThe board that plots data points in animation.\nDefined in Section 3.2\ndraw(x,y,label,every_n=1 )\nDefined in Section B.7\nclass d2l.torch.Residual( num_channels ,use_1x1conv=False ,strides=1 )\nBases: Module\nThe Residual block of ResNet models.\nDefined in Section 8.6\nforward( X)\nDefines the computation performed at every call.\nShould be overridden by all subclasses.\nNote:Although the recipe for forward pass needs to be defined within this function,\none should call the Module(page 1078) instance afterwards instead of this since the\nformertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem.\nclass d2l.torch.ResNeXtBlock( num_channels ,groups,bot_mul,\nuse_1x1conv=False ,strides=1 )\nBases: Module\nThe ResNeXt block.\nDefined in Section 8.6.2\nforward( X)\nDefines the computation performed at every call.\nShould be overridden by all subclasses.\nNote:Although the recipe for forward pass needs to be defined within this function,\none should call the Module(page 1078) instance afterwards instead of this since the\nformertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem.\n1082 Tools for Deep Learning\nclass d2l.torch.RNN( num_inputs ,num_hiddens )\nBases: Module(page 1078)\nThe RNN model implemented with high-level APIs.\nDefined in Section 9.6\nforward( inputs,H=None )\nDefines the computation performed at every call.\nShould be overridden by all subclasses.\nNote:Although the recipe for forward pass needs to be defined within this function,\none should call the Module(page 1078) instance afterwards instead of this since the\nformertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem.\nclass d2l.torch.RNNLM( rnn,vocab_size ,lr=0.01 )\nBases: RNNLMScratch (page 1082)\nThe RNN-based language model implemented with high-level APIs.\nDefined in Section 9.6\ninit_params()\noutput_layer( hiddens )\nDefined in Section 9.5\nclass d2l.torch.RNNLMScratch( rnn,vocab_size ,lr=0.01 )\nBases: Classifier (page 1075)\nThe RNN-based language model implemented from scratch.\nDefined in Section 9.5\nforward( X,state=None )\nDefined in Section 9.5\ninit_params()\none_hot( X)\nDefined in Section 9.5\noutput_layer( rnn_outputs )\nDefined in Section 9.5\npredict( prefix,num_preds ,vocab,device=None )\nDefined in Section 9.5\n1083 Thed2lAPI Document\ntraining_step( batch )\nvalidation_step( batch )\nclass d2l.torch.RNNScratch( num_inputs ,num_hiddens ,sigma=0.01 )\nBases: Module(page 1078)\nThe RNN model implemented from scratch.\nDefined in Section 9.5\nforward( inputs,state=None )\nDefined in Section 9.5\nclass d2l.torch.Seq2Seq( encoder,decoder,tgt_pad,lr)\nBases: EncoderDecoder (page 1076)\nThe RNN encoder\u2013decoder for sequence to sequence learning.\nDefined in Section 10.7.3\nconfigure_optimizers()\nDefined in Section 4.3\nvalidation_step( batch )\nclass d2l.torch.Seq2SeqEncoder( vocab_size ,embed_size ,num_hiddens ,\nnum_layers ,dropout=0 )\nBases: Encoder (page 1076)\nThe RNN encoder for sequence-to-sequence learning.\nDefined in Section 10.7\nforward( X,*args )\nDefines the computation performed at every call.\nShould be overridden by all subclasses.\nNote:Although the recipe for forward pass needs to be defined within this function,\none should call the Module(page 1078) instance afterwards instead of this since the\nformertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem.", "mimetype": "text/plain", "start_char_idx": 2183094, "end_char_idx": 2186694, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6c21240c-9f22-43ba-8351-cdc428bb9db7": {"__data__": {"id_": "6c21240c-9f22-43ba-8351-cdc428bb9db7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5d01bac4-ab37-4172-9a26-7a88ab926f75", "node_type": "1", "metadata": {}, "hash": "d81d6f51eb86a3de78eda5e9c1bea6de4b8d777fb1b1d798488e464f8edb8a91", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d57482fa-4867-4e8b-a887-89a1144858c6", "node_type": "1", "metadata": {}, "hash": "d09bb68cc3a307e1e19431e1450d14038c2444453dce4ae790b78edd434b5c89", "class_name": "RelatedNodeInfo"}}, "text": "Defined in Section 10.7.3\nconfigure_optimizers()\nDefined in Section 4.3\nvalidation_step( batch )\nclass d2l.torch.Seq2SeqEncoder( vocab_size ,embed_size ,num_hiddens ,\nnum_layers ,dropout=0 )\nBases: Encoder (page 1076)\nThe RNN encoder for sequence-to-sequence learning.\nDefined in Section 10.7\nforward( X,*args )\nDefines the computation performed at every call.\nShould be overridden by all subclasses.\nNote:Although the recipe for forward pass needs to be defined within this function,\none should call the Module(page 1078) instance afterwards instead of this since the\nformertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem.\nclass d2l.torch.SGD( params,lr)\nBases: HyperParameters (page 1077)\nMinibatch stochastic gradient descent.\nDefined in Section 3.4\n1084 Tools for Deep Learning\nstep()\nzero_grad()\nclass d2l.torch.SoftmaxRegression( num_outputs ,lr)\nBases: Classifier (page 1075)\nThe softmax regression model.\nDefined in Section 4.5\nforward( X)\nDefines the computation performed at every call.\nShould be overridden by all subclasses.\nNote:Although the recipe for forward pass needs to be defined within this function,\none should call the Module(page 1078) instance afterwards instead of this since the\nformertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem.\nclass d2l.torch.SyntheticRegressionData( w,b,noise=0.01 ,num_train=1000 ,\nnum_val=1000 ,batch_size=32 )\nBases: DataModule (page 1075)\nSynthetic data for linear regression.\nDefined in Section 3.3\nget_dataloader( train )\nDefined in Section 3.3\nclass d2l.torch.TimeMachine( batch_size ,num_steps ,num_train=10000 ,\nnum_val=5000 )\nBases: DataModule (page 1075)\nThe Time Machine dataset.\nDefined in Section 9.2\nbuild(raw_text ,vocab=None )\nDefined in Section 9.2\nget_dataloader( train )\nDefined in Section 9.3.3\nclass d2l.torch.Trainer( max_epochs ,num_gpus=0 ,gradient_clip_val=0 )\nBases: HyperParameters (page 1077)\nThe base class for training models with data.\n1085 Thed2lAPI Document\nDefined in Section 3.2.2\nclip_gradients( grad_clip_val ,model )\nDefined in Section 9.5\nfit(model,data)\nfit_epoch()\nDefined in Section 3.4\nprepare_batch( batch )\nDefined in Section 6.7\nprepare_data( data)\nprepare_model( model )\nDefined in Section 6.7\nclass d2l.torch.TransformerEncoder( vocab_size ,num_hiddens ,ffn_num_hiddens ,\nnum_heads ,num_blks ,dropout,\nuse_bias=False )\nBases: Encoder (page 1076)\nThe Transformer encoder.\nDefined in Section 11.7.4\nforward( X,valid_lens )\nDefines the computation performed at every call.\nShould be overridden by all subclasses.\nNote:Although the recipe for forward pass needs to be defined within this function,\none should call the Module(page 1078) instance afterwards instead of this since the\nformertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem.\nclass d2l.torch.TransformerEncoderBlock( num_hiddens ,ffn_num_hiddens ,\nnum_heads ,dropout,use_bias=False )\nBases: Module\nThe Transformer encoder block.\nDefined in Section 11.7.2\nforward( X,valid_lens )\nDefines the computation performed at every call.\nShould be overridden by all subclasses.\n1086 Tools for Deep Learning\nNote:Although the recipe for forward pass needs to be defined within this function,\none should call the Module(page 1078) instance afterwards instead of this since the\nformertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem.\nclass d2l.torch.Vocab( tokens=[] ,min_freq=0 ,reserved_tokens=[] )\nBases: object\nVocabulary for text.\nto_tokens( indices )\nproperty unk\nB.8.2Functions\nd2l.torch.add_to_class( Class )\nRegister functions as methods in created class.\nDefined in Section 3.2\nd2l.torch.bleu( pred_seq ,label_seq ,k)\nCompute the BLEU.\nDefined in Section 10.7.6\nd2l.torch.check_len( a,n)\nCheck the length of a list.", "mimetype": "text/plain", "start_char_idx": 2186049, "end_char_idx": 2189805, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d57482fa-4867-4e8b-a887-89a1144858c6": {"__data__": {"id_": "d57482fa-4867-4e8b-a887-89a1144858c6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6c21240c-9f22-43ba-8351-cdc428bb9db7", "node_type": "1", "metadata": {}, "hash": "f75383ba5cd49416a9e5a96456776920c91d15fe651c738251147607f49614cc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "20c30fd8-6a76-4886-a4de-de97a4a9d90d", "node_type": "1", "metadata": {}, "hash": "f4f10fa656c4898da76e38237ca829809efb673110cdb5c137b6c5f2acc82615", "class_name": "RelatedNodeInfo"}}, "text": "Should be overridden by all subclasses.\n1086 Tools for Deep Learning\nNote:Although the recipe for forward pass needs to be defined within this function,\none should call the Module(page 1078) instance afterwards instead of this since the\nformertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem.\nclass d2l.torch.Vocab( tokens=[] ,min_freq=0 ,reserved_tokens=[] )\nBases: object\nVocabulary for text.\nto_tokens( indices )\nproperty unk\nB.8.2Functions\nd2l.torch.add_to_class( Class )\nRegister functions as methods in created class.\nDefined in Section 3.2\nd2l.torch.bleu( pred_seq ,label_seq ,k)\nCompute the BLEU.\nDefined in Section 10.7.6\nd2l.torch.check_len( a,n)\nCheck the length of a list.\nDefined in Section 9.5\nd2l.torch.check_shape( a,shape )\nCheck the shape of a tensor.\nDefined in Section 9.5\nd2l.torch.corr2d( X,K)\nCompute 2D cross-correlation.\nDefined in Section 7.2\nd2l.torch.cpu()\nGet the CPU device.\nDefined in Section 6.7\nd2l.torch.gpu( i=0)\nGet a GPU device.\nDefined in Section 6.7\n1087 Thed2lAPI Document\nd2l.torch.init_cnn( module )\nInitialize weights for CNNs.\nDefined in Section 7.6\nd2l.torch.init_seq2seq( module )\nInitialize weights for sequence-to-sequence learning.\nDefined in Section 10.7\nd2l.torch.masked_softmax( X,valid_lens )\nPerform softmax operation by masking elements on the last axis.\nDefined in Section 11.3\nd2l.torch.num_gpus()\nGet the number of available GPUs.\nDefined in Section 6.7\nd2l.torch.plot( X,Y=None,xlabel=None ,ylabel=None ,legend=[] ,xlim=None ,\nylim=None ,xscale=\u2019linear\u2019 ,yscale=\u2019linear\u2019 ,fmts=(\u2019-\u2019,\u2019m--\u2019,\u2019g-.\u2019,\n\u2019r:\u2019),figsize=(3.5,2.5) ,axes=None )\nPlot data points.\nDefined in Section 2.4\nd2l.torch.set_axes( axes,xlabel,ylabel,xlim,ylim,xscale,yscale,legend )\nSet the axes for matplotlib.\nDefined in Section 2.4\nd2l.torch.set_figsize( figsize=(3.5,2.5) )\nSet the figure size for matplotlib.\nDefined in Section 2.4\nd2l.torch.show_heatmaps( matrices ,xlabel,ylabel,titles=None ,figsize=(2.5, 2.5) ,\ncmap=\u2019Reds\u2019 )\nShow heatmaps of matrices.\nDefined in Section 11.1\nd2l.torch.show_list_len_pair_hist( legend,xlabel,ylabel,xlist,ylist)\nPlot the histogram for list length pairs.\nDefined in Section 10.5\nd2l.torch.try_all_gpus()\nReturn all available GPUs, or [cpu(),] if no GPU exists.\nDefined in Section 6.7\n1088 Tools for Deep Learning\nd2l.torch.try_gpu( i=0)\nReturn gpu(i) if exists, otherwise return cpu().\nDefined in Section 6.7\nd2l.torch.use_svg_display()\nUse the svg format to display a plot in Jupyter.\nDefined in Section 2.4\nReferences\nAbadi, M., Barham, P., Chen, J., Chen, Z., Davis, A., Dean, J., \u2026 et al. (2016). Tensor-\nFlow: asystemforlarge-scalemachinelearning. 12thUSENIXSymposiumonOperating\nSystemsDesign and Implementation (OSDI 16) (pp. 265\u2013283).\nAbdel-Hamid, O., Mohamed, A.-R., Jiang, H., Deng, L., Penn, G., & Yu, D. (2014). Con-\nvolutional neural networks for speech recognition. IEEE/ACM Transactions on Audio,\nSpeech,and LanguageProcessing ,22(10), 1533\u20131545.\nAhmed, A., Aly, M., Gonzalez, J., Narayanamurthy, S., & Smola, A. J. (2012). Scalable\ninference in latent variable models. ProceedingsoftheFifthACMInternationalConfer-\nenceon WebSearchand Data Mining (pp. 123\u2013132).\nAkiba, T., Sano, S., Yanase, T., Ohta, T., & Koyama, M.", "mimetype": "text/plain", "start_char_idx": 2189100, "end_char_idx": 2192314, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "20c30fd8-6a76-4886-a4de-de97a4a9d90d": {"__data__": {"id_": "20c30fd8-6a76-4886-a4de-de97a4a9d90d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d57482fa-4867-4e8b-a887-89a1144858c6", "node_type": "1", "metadata": {}, "hash": "d09bb68cc3a307e1e19431e1450d14038c2444453dce4ae790b78edd434b5c89", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "39ddf429-be05-47f6-9254-e5031f5ddfa0", "node_type": "1", "metadata": {}, "hash": "b54d4a02ba25dd98b187efc8fba61bed5f318415d87606a93047a2d687e4ed35", "class_name": "RelatedNodeInfo"}}, "text": "265\u2013283).\nAbdel-Hamid, O., Mohamed, A.-R., Jiang, H., Deng, L., Penn, G., & Yu, D. (2014). Con-\nvolutional neural networks for speech recognition. IEEE/ACM Transactions on Audio,\nSpeech,and LanguageProcessing ,22(10), 1533\u20131545.\nAhmed, A., Aly, M., Gonzalez, J., Narayanamurthy, S., & Smola, A. J. (2012). Scalable\ninference in latent variable models. ProceedingsoftheFifthACMInternationalConfer-\nenceon WebSearchand Data Mining (pp. 123\u2013132).\nAkiba, T., Sano, S., Yanase, T., Ohta, T., & Koyama, M. (2019). Optuna: a next-generation\nhyperparameter optimization framework. Proceedings of the 25th ACM SIGKDD Inter-\nnationalConferenceon KnowledgeDiscovery & Data Mining .\nAlayrac, J.-B., Donahue, J., Luc, P., Miech, A., Barr, I., Hasson, Y., \u2026 et al. (2022).\nFlamingo: a visual language model for few-shot learning. ArXiv:2204.14198 .\nAlsallakh, B., Kokhlikyan, N., Miglani, V., Yuan, J., & Reblitz-Richardson, O. (2020).\nMind the PAD \u2013 CNNs can develop blind spots. ArXiv:2010.02178 .\nAnil, R., Dai, A. M., Firat, O., Johnson, M., Lepikhin, D., Passos, A., \u2026 et al. (2023).\nPaLM 2 Technical Report. ArXiv:2305.10403 .\nAnil, R., Gupta, V., Koren, T., Regan, K., & Singer, Y. (2020). Scalable second-order\noptimization for deep learning. ArXiv:2002.09018 .\nAronszajn, N. (1950). Theory of reproducing kernels. TransactionsoftheAmericanMath-\nematicalSociety ,68(3), 337\u2013404.\nBa, J. L., Kiros, J. R., & Hinton, G. E. (2016). Layer normalization. ArXiv:1607.06450 .\nBaevski, A., & Auli, M. (2018). Adaptive input representations for neural language mod-\neling.International Conferenceon Learning Representations .\nBahdanau,D.,Cho,K.,&Bengio,Y.(2014).Neuralmachinetranslationbyjointlylearning\nto align and translate. ArXiv:1409.0473 .\nBai, Y., Kadavath, S., Kundu, S., Askell, A., Kernion, J., Jones, A., \u2026 et al. (2022). Con-\nstitutional AI: harmlessness from AI feedback. ArXiv:2212.08073 .\nBaptista, R., & Poloczek, M. (2018). Bayesian optimization of combinatorial structures.\nProceedingsof the35thInternational Conferenceon MachineLearning .\nBardenet, R., Brendel, M., K\u00e9gl, B., & Sebag, M. (2013). Collaborative hyperparam-\neter tuning. Proceedings of the 30th International Conference on Machine Learning\n(ICML\u201913) .\nBay, H., Tuytelaars, T., & Van Gool, L. (2006). SURF: Speeded up robust features. Euro-\npeanConferenceon ComputerVision (pp. 404\u2013417).\n1089\n1090 REFERENCES\nBellman, R. (1966). Dynamic programming. Science,153, 34\u201337.\nBellman, R. (1952). On the theory of dynamic programming. ProceedingsoftheNational\nAcademyof Sciences ,38(8), 716\u2013719.\nBellman, R. (1957). A Markovian decision process. JournalofMathematicsandMechan-\nics,6(5), 679\u2013684. URL: http://www.jstor.org/stable/24900506\nBellman, R. (1957). Dynamic Programming . Dover Publications.\nBeltagy, I., Peters, M. E., & Cohan, A. (2020). Longformer: the long-document trans-\nformer.ArXiv:2004.05150 .", "mimetype": "text/plain", "start_char_idx": 2191815, "end_char_idx": 2194684, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "39ddf429-be05-47f6-9254-e5031f5ddfa0": {"__data__": {"id_": "39ddf429-be05-47f6-9254-e5031f5ddfa0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "20c30fd8-6a76-4886-a4de-de97a4a9d90d", "node_type": "1", "metadata": {}, "hash": "f4f10fa656c4898da76e38237ca829809efb673110cdb5c137b6c5f2acc82615", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cab96ccd-ceda-4937-8f92-5763b4c8a5c7", "node_type": "1", "metadata": {}, "hash": "2640785ec42086e52bad18d99a630f3a1c3dd769e16c6ebb6e78230f5fa2a4d2", "class_name": "RelatedNodeInfo"}}, "text": "404\u2013417).\n1089\n1090 REFERENCES\nBellman, R. (1966). Dynamic programming. Science,153, 34\u201337.\nBellman, R. (1952). On the theory of dynamic programming. ProceedingsoftheNational\nAcademyof Sciences ,38(8), 716\u2013719.\nBellman, R. (1957). A Markovian decision process. JournalofMathematicsandMechan-\nics,6(5), 679\u2013684. URL: http://www.jstor.org/stable/24900506\nBellman, R. (1957). Dynamic Programming . Dover Publications.\nBeltagy, I., Peters, M. E., & Cohan, A. (2020). Longformer: the long-document trans-\nformer.ArXiv:2004.05150 .\nBengio,Y.,Ducharme,R.,Vincent,P.,&Jauvin,C.(2003).Aneuralprobabilisticlanguage\nmodel.Journal of MachineLearning Research ,3(Feb), 1137\u20131155.\nBengio, Y., Simard, P., & Frasconi, P. (1994). Learning long-term dependencies with gra-\ndient descent is difficult. IEEE Transactionson NeuralNetworks ,5(2), 157\u2013166.\nBergstra, J., Bardenet, R., Bengio, Y., & K\u00e9gl, B. (2011). Algorithms for hyper-parameter\noptimization. Advancesin NeuralInformation ProcessingSystems ,24.\nBergstra, J., Breuleux, O., Bastien, F., Lamblin, P., Pascanu, R., Desjardins, G., \u2026 Ben-\ngio, Y. (2010). Theano: a CPU and GPU math compiler in Python. Proc. 9th Python in\nScienceConference (pp. 3\u201310).\nBeutel, A., Murray, K., Faloutsos, C., & Smola, A. J. (2014). CoBaFi: collaborative\nBayesianfiltering. Proceedingsofthe23rdInternationalConferenceonWorldWideWeb\n(pp. 97\u2013108).\nBishop, C.M.(1995).TrainingwithnoiseisequivalenttoTikhonovregularization. Neural\nComputation ,7(1), 108\u2013116.\nBishop, C. M. (2006). Pattern Recognitionand MachineLearning . Springer.\nBlack, F., & Scholes, M. (1973). The pricing of options and corporate liabilities. Journal\nofPoliticalEconomy ,81, 637\u2013654.\nBodla, N., Singh, B., Chellappa, R., & Davis, L. S. (2017). Soft-NMS-improving object\ndetection with one line of code. Proceedings of the IEEE International Conference on\nComputerVision (pp. 5561\u20135569).\nBojanowski, P., Grave, E., Joulin, A., & Mikolov, T. (2017). Enriching word vectors with\nsubword information. Transactions of the Association for Computational Linguistics ,5,\n135\u2013146.\nBollob\u00e1s, B. (1999). Linear Analysis . Cambridge University Press.\nBommasani, R., Hudson, D. A., Adeli, E., Altman, R., Arora, S., von Arx, S., \u2026 et al.\n(2021). On the opportunities and risks of foundation models. ArXiv:2108.07258 .\nBottou,L.(2010).Large-scalemachinelearningwithstochasticgradientdescent. Proceed-\ningsof COMPSTAT\u20192010 (pp. 177\u2013186). Springer.\nBottou, L., & Le Cun, Y. (1988). SN: a simulator for connectionist models. Proceedings\nof NeuroNimes 88 (pp. 371\u2013382). Nimes, France. URL: http://leon.bottou.org/papers/\nbottou-lecun-88\nBoucheron, S., Bousquet, O., & Lugosi, G. (2005). Theory of classification: a survey of\nsome recent advances. ESAIM: Probabilityand Statistics ,9, 323\u2013375.\nBowman, S. R., Angeli, G., Potts, C., & Manning, C. D. (2015). A large annotated corpus\nfor learning natural language inference. ArXiv:1508.05326 .", "mimetype": "text/plain", "start_char_idx": 2194159, "end_char_idx": 2197072, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cab96ccd-ceda-4937-8f92-5763b4c8a5c7": {"__data__": {"id_": "cab96ccd-ceda-4937-8f92-5763b4c8a5c7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "39ddf429-be05-47f6-9254-e5031f5ddfa0", "node_type": "1", "metadata": {}, "hash": "b54d4a02ba25dd98b187efc8fba61bed5f318415d87606a93047a2d687e4ed35", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1c2fe0a5-2ec1-42d8-9bb6-13a948a79538", "node_type": "1", "metadata": {}, "hash": "0b2249d93898dc86fccf44d61280c6531da8067e281b7be33f5369fe38e08d15", "class_name": "RelatedNodeInfo"}}, "text": "Proceed-\ningsof COMPSTAT\u20192010 (pp. 177\u2013186). Springer.\nBottou, L., & Le Cun, Y. (1988). SN: a simulator for connectionist models. Proceedings\nof NeuroNimes 88 (pp. 371\u2013382). Nimes, France. URL: http://leon.bottou.org/papers/\nbottou-lecun-88\nBoucheron, S., Bousquet, O., & Lugosi, G. (2005). Theory of classification: a survey of\nsome recent advances. ESAIM: Probabilityand Statistics ,9, 323\u2013375.\nBowman, S. R., Angeli, G., Potts, C., & Manning, C. D. (2015). A large annotated corpus\nfor learning natural language inference. ArXiv:1508.05326 .\nBoyd, S., & Vandenberghe, L. (2004). Convex Optimization . Cambridge, England:\nCambridge University Press.\n1091 REFERENCES\nBradley, R. A., & Terry, M. E. (1952). Rank analysis of incomplete block designs: I. The\nmethod of paired comparisons. Biometrika ,39(3/4), 324\u2013345.\nBrown, N., & Sandholm, T. (2017). Libratus: the superhuman AI for no-limit poker. IJCAI\n(pp. 5226\u20135228).\nBrown, P. F., Cocke, J., Della Pietra, S. A., Della Pietra, V. J., Jelinek, F., Lafferty, J.,\n\u2026 Roossin, P. S. (1990). A statistical approach to machine translation. Computational\nLinguistics ,16(2), 79\u201385.\nBrown, P. F., Cocke, J., Della Pietra, S. A., Della Pietra, V. J., Jelinek, F., Mercer, R. L.,\n& Roossin, P. (1988). A statistical approach to language translation. COLING Budapest\n1988Volume1: International Conferenceon Computational Linguistics .\nBrown, T., Mann, B., Ryder, N., Subbiah, M., Kaplan, J. D., Dhariwal, P., \u2026 et al. (2020).\nLanguagemodelsarefew-shotlearners. AdvancesinNeuralInformationProcessingSys-\ntems,33, 1877\u20131901.\nBuslaev, A., Iglovikov, V. I., Khvedchenya, E., Parinov, A., Druzhinin, M., & Kalinin,\nA. A. (2020). Albumentations: Fast and flexible image augmentations. Information ,\n11(2), 125.\nCampbell, M., Hoane Jr, A. J., & Hsu, F.-h. (2002). Deep blue. Artificial Intelligence ,\n134(1-2), 57\u201383.\nCanny, J. (1987). A computational approach to edge detection. Readings in Computer Vi-\nsion(pp. 184\u2013203). Elsevier.\nCer, D., Diab, M., Agirre, E., Lopez-Gazpio, I., & Specia, L. (2017). SemEval-2017 Task\n1: semantictextualsimilaritymultilingualandcrosslingualfocusedevaluation. Proceed-\ningsofthe11thInternationalWorkshoponSemanticEvaluation(SemEval-2017) (pp.1\u2013\n14).\nChan, W., Jaitly, N., Le, Q. V., & Vinyals, O. (2015). Listen, attend and spell.\nArXiv:1508.01211 .\nChen, L., Lu, K., Rajeswaran, A., Lee, K., Grover, A., Laskin, M., \u2026 Mordatch, I. (2021).\nDecision transformer: reinforcement learning via sequence modeling. AdvancesinNeu-\nralInformation ProcessingSystems ,34, 15084\u201315097.\nChen, T., Li, M., Li, Y., Lin, M., Wang, N., Wang, M., \u2026 Zhang, Z. (2015). MXNET:\na flexible and efficient machine learning library for heterogeneous distributed systems.\nArXiv:1512.01274 .\nCheng, J., Dong, L., &Lapata, M.", "mimetype": "text/plain", "start_char_idx": 2196528, "end_char_idx": 2199296, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1c2fe0a5-2ec1-42d8-9bb6-13a948a79538": {"__data__": {"id_": "1c2fe0a5-2ec1-42d8-9bb6-13a948a79538", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cab96ccd-ceda-4937-8f92-5763b4c8a5c7", "node_type": "1", "metadata": {}, "hash": "2640785ec42086e52bad18d99a630f3a1c3dd769e16c6ebb6e78230f5fa2a4d2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d9718bb3-6a49-46c3-aaec-5d6b64cf486f", "node_type": "1", "metadata": {}, "hash": "141c2bae13a1edb35d284cd07a9afcdb41749764fb3deb550f531f287a678779", "class_name": "RelatedNodeInfo"}}, "text": "Chan, W., Jaitly, N., Le, Q. V., & Vinyals, O. (2015). Listen, attend and spell.\nArXiv:1508.01211 .\nChen, L., Lu, K., Rajeswaran, A., Lee, K., Grover, A., Laskin, M., \u2026 Mordatch, I. (2021).\nDecision transformer: reinforcement learning via sequence modeling. AdvancesinNeu-\nralInformation ProcessingSystems ,34, 15084\u201315097.\nChen, T., Li, M., Li, Y., Lin, M., Wang, N., Wang, M., \u2026 Zhang, Z. (2015). MXNET:\na flexible and efficient machine learning library for heterogeneous distributed systems.\nArXiv:1512.01274 .\nCheng, J., Dong, L., &Lapata, M.(2016).Longshort-termmemory-networksformachine\nreading.Proceedingsofthe2016ConferenceonEmpiricalMethodsinNaturalLanguage\nProcessing (pp. 551\u2013561).\nChetlur,S.,Woolley,C.,Vandermersch,P.,Cohen,J.,Tran,J.,Catanzaro,B.,&Shelhamer,\nE. (2014). CuDNN: Efficient primitives for deep learning. ArXiv:1410.0759 .\nCho, K., Van Merri\u00ebnboer, B., Bahdanau, D., & Bengio, Y. (2014). On the properties of\nneural machine translation: Encoder\u2013decoder approaches. ArXiv:1409.1259 .\nCho, K., Van Merri\u00ebnboer, B., Gulcehre, C., Bahdanau, D., Bougares, F., Schwenk, H.,\n& Bengio, Y. (2014). Learning phrase representations using RNN encoder\u2013decoder for\nstatistical machine translation. ArXiv:1406.1078 .\nChowdhery,A.,Narang,S.,Devlin,J.,Bosma,M.,Mishra,G.,Roberts,A.,\u2026etal.(2022).\nPaLM: scaling language modeling with pathways. ArXiv:2204.02311 .\n1092 REFERENCES\nChung, J., Gulcehre, C., Cho, K., & Bengio, Y. (2014). Empirical evaluation of gated re-\ncurrent neural networks on sequence modeling. ArXiv:1412.3555 .\nClark,K.,Luong,M.-T.,Le, Q.V.,&Manning,C.D.(2020).ELECTRA:pre-trainingtext\nencodersasdiscriminatorsratherthangenerators. InternationalConferenceonLearning\nRepresentations .\nCollobert, R., Weston, J., Bottou, L., Karlen, M., Kavukcuoglu, K., & Kuksa, P. (2011).\nNatural language processing (almost) from scratch. Journal of Machine Learning Re-\nsearch,12, 2493\u20132537.\nCordonnier, J.-B., Loukas, A., & Jaggi, M. (2020). On the relationship between self-\nattention and convolutional layers. International Conference on Learning Representa-\ntions.\nCover, T., & Thomas, J. (1999). Elementsof Information Theory . John Wiley & Sons.\nCsisz\u00e1r, I. (2008). Axiomatic characterizations of information measures. Entropy,10(3),\n261\u2013273.\nCybenko,G.(1989).Approximationbysuperpositionsofasigmoidalfunction. Mathemat-\nicsof Control,Signals and Systems ,2(4), 303\u2013314.\nDalal, N., & Triggs, B. (2005). Histograms of oriented gradients for human detection.\n2005 IEEE Computer Society Conference on Computer Vision and Pattern Recognition\n(CVPR\u201905) (pp. 886\u2013893).\nDe Cock, D. (2011). Ames, Iowa: alternative to the Boston housing data as an end of\nsemester regression project. Journal of StatisticsEducation ,19(3).\nDean,J.,Corrado,G.S.,Monga,R.,Chen,K.,Devin,M.,Le,Q.V.,\u2026etal.(2012).Large\nscale distributed deep networks. Proceedings of the 25th International Conference on\nNeuralInformation ProcessingSystems,Volume1 (pp. 1223\u20131231).", "mimetype": "text/plain", "start_char_idx": 2198750, "end_char_idx": 2201704, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d9718bb3-6a49-46c3-aaec-5d6b64cf486f": {"__data__": {"id_": "d9718bb3-6a49-46c3-aaec-5d6b64cf486f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1c2fe0a5-2ec1-42d8-9bb6-13a948a79538", "node_type": "1", "metadata": {}, "hash": "0b2249d93898dc86fccf44d61280c6531da8067e281b7be33f5369fe38e08d15", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1e14e335-28ec-4e8a-81c1-f81065d39227", "node_type": "1", "metadata": {}, "hash": "50e8b227b85603b0f0423f4dd919cb3436f8f66f12660367035ab2dca55aedd3", "class_name": "RelatedNodeInfo"}}, "text": "Mathemat-\nicsof Control,Signals and Systems ,2(4), 303\u2013314.\nDalal, N., & Triggs, B. (2005). Histograms of oriented gradients for human detection.\n2005 IEEE Computer Society Conference on Computer Vision and Pattern Recognition\n(CVPR\u201905) (pp. 886\u2013893).\nDe Cock, D. (2011). Ames, Iowa: alternative to the Boston housing data as an end of\nsemester regression project. Journal of StatisticsEducation ,19(3).\nDean,J.,Corrado,G.S.,Monga,R.,Chen,K.,Devin,M.,Le,Q.V.,\u2026etal.(2012).Large\nscale distributed deep networks. Proceedings of the 25th International Conference on\nNeuralInformation ProcessingSystems,Volume1 (pp. 1223\u20131231).\nDeCandia, G., Hastorun, D., Jampani, M., Kakulapati, G., Lakshman, A., Pilchin, A., \u2026\nVogels, W. (2007). Dynamo: Amazon\u2019s highly available key-value store. ACM SIGOPS\nOperatingSystemsReview (pp. 205\u2013220).\nDeng, J., Dong, W., Socher, R., Li, L.-J., Li, K., & Fei-Fei, L. (2009). Imagenet: a large-\nscale hierarchical image database. 2009IEEEConferenceonComputerVisionandPat-\ntern Recognition (pp. 248\u2013255).\nDer Kiureghian, A., & Ditlevsen, O. (2009). Aleatory or epistemic? does it matter? Struc-\nturalSafety ,31(2), 105\u2013112.\nDevlin, J., Chang, M.-W., Lee, K., & Toutanova, K. (2018). BERT: Pre-training of deep\nbidirectional transformers for language understanding. ArXiv:1810.04805 .\nDinh, L., Krueger, D., & Bengio, Y. (2014). NICE: non-linear independent components\nestimation. ArXiv:1410.8516 .\nDinh, L., Sohl-Dickstein, J., & Bengio, S. (2017). Density estimation using real NVP. In-\nternational Conferenceon Learning Representations .\nDoersch,C.,Gupta,A.,&Efros,A.A.(2015).Unsupervisedvisualrepresentationlearning\nby context prediction. Proceedings of the IEEE International Conference on Computer\nVision(pp. 1422\u20131430).\nDosovitskiy, A., Beyer, L., Kolesnikov, A., Weissenborn, D., Zhai, X., Unterthiner, T., \u2026\net al. (2021). An image is worth 16 x 16 words: transformers for image recognition at\nscale.International Conferenceon Learning Representations .\n1093 REFERENCES\nDuchi,J.,Hazan,E.,&Singer,Y.(2011).Adaptivesubgradientmethodsforonlinelearning\nand stochastic optimization. Journal of MachineLearning Research ,12, 2121\u20132159.\nDumoulin, V., & Visin, F. (2016). A guide to convolution arithmetic for deep learning.\nArXiv:1603.07285 .\nDwivedi, V. P., & Bresson, X. (2020). A generalization of transformer networks to graphs.\nArXiv:2012.09699 .\nDwork, C., Feldman, V., Hardt, M., Pitassi, T., Reingold, O., & Roth, A. L. (2015). Pre-\nservingstatisticalvalidityinadaptivedataanalysis. Proceedingsofthe47thAnnualACM\nSymposiumon Theory of Computing (pp. 117\u2013126).\nElman, J. L. (1990). Finding structure in time. CognitiveScience ,14(2), 179\u2013211.\nElsken, T., Metzen, J. H., & Hutter, F. (2018). Neural architecture search: a ssurvey.\nArXiv:1808.05377[stat.ML] .\nFechner, G. T. (1860). Elementeder Psychophysik . Vol. 2. Breitkopf u. H\u00e4rtel.\nFedus, W., Zoph, B., & Shazeer, N. (2022). Switch transformers: scaling to trillion param-\neter models with simple and efficient sparsity.", "mimetype": "text/plain", "start_char_idx": 2201081, "end_char_idx": 2204089, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1e14e335-28ec-4e8a-81c1-f81065d39227": {"__data__": {"id_": "1e14e335-28ec-4e8a-81c1-f81065d39227", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d9718bb3-6a49-46c3-aaec-5d6b64cf486f", "node_type": "1", "metadata": {}, "hash": "141c2bae13a1edb35d284cd07a9afcdb41749764fb3deb550f531f287a678779", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0fce7818-36d8-4641-af69-611bea3ea1b4", "node_type": "1", "metadata": {}, "hash": "c1e75d11674d445f31ea8022c64e184225b888a8f0b89e6b7e8fbf45aae68bd7", "class_name": "RelatedNodeInfo"}}, "text": "Pre-\nservingstatisticalvalidityinadaptivedataanalysis. Proceedingsofthe47thAnnualACM\nSymposiumon Theory of Computing (pp. 117\u2013126).\nElman, J. L. (1990). Finding structure in time. CognitiveScience ,14(2), 179\u2013211.\nElsken, T., Metzen, J. H., & Hutter, F. (2018). Neural architecture search: a ssurvey.\nArXiv:1808.05377[stat.ML] .\nFechner, G. T. (1860). Elementeder Psychophysik . Vol. 2. Breitkopf u. H\u00e4rtel.\nFedus, W., Zoph, B., & Shazeer, N. (2022). Switch transformers: scaling to trillion param-\neter models with simple and efficient sparsity. Journal of Machine Learning Research ,\n23(120), 1\u201339.\nFernando,R.(2004). GPUGems: ProgrammingTechniques,Tips,andTricksforReal-Time\nGraphics . Addison-Wesley.\nFeurer, M., & Hutter, F. (2018). Hyperparameter ptimization. Automatic Machine Learn-\ning: Methods,Systems,Challenges . Springer.\nFeurer, M., Letham, B., Hutter, F., & Bakshy, E. (2022). Practical transfer learning for\nBayesian optimization. ArXiv:1802.02219[stat.ML] .\nField, D. J. (1987). Relations between the statistics of natural images and the response\nproperties of cortical cells. JOSA A,4(12), 2379\u20132394.\nFisher, R. A. (1925). Statistical MethodsforResearchWorkers. Oliver & Boyd.\nFlammarion, N., & Bach, F. (2015). From averaging to acceleration, there is only a step-\nsize.Conferenceon Learning Theory (pp. 658\u2013695).\nForrester, A. I., S\u00f3bester, A., & Keane, A. J. (2007). Multi-fidelity optimization via surro-\ngate modelling. Proceedings of the Royal Society A: Mathematical, Physical and Engi-\nneeringSciences ,463(2088), 3251\u20133269.\nFranceschi,L.,Donini,M.,Frasconi,P.,&Pontil,M.(2017).Forwardandreversegradient-\nbased hyperparameter optimization. Proceedings of the 34th International Conference\nonMachineLearning (ICML\u201917) .\nFrankle, J., & Carbin, M. (2018). The lottery ticket hypothesis: finding sparse, trainable\nneural networks. ArXiv:1803.03635 .\nFrazier, P. I. (2018). A tutorial on Bayesian optimization. ArXiv:1807.02811 .\nFreund, Y., & Schapire, R. E. (1996). Experiments with a new boosting algorithm. Pro-\nceedingsof theInternational Conferenceon MachineLearning (pp. 148\u2013156).\nFriedman, J.H.(1987).Exploratoryprojectionpursuit. JournaloftheAmericanStatistical\nAssociation ,82(397), 249\u2013266.\nFrostig, R., Johnson, M. J., & Leary, C. (2018). Compiling machine learning programs via\nhigh-level tracing. Proceedingsof SystemsforMachineLearning .\nFukushima, K. (1982). Neocognitron: a self-organizing neural network model for a\nmechanism of visual pattern recognition. Competition and Cooperation in Neural Nets\n(pp. 267\u2013285). Springer.\n1094 REFERENCES\nGardner, J., Pleiss, G., Weinberger, K. Q., Bindel, D., & Wilson, A. G. (2018). GPyTorch:\nblackbox matrix\u2013matrix Gaussian process inference with GPU acceleration. Advances\ninNeuralInformation ProcessingSystems .\nGarg, S., Balakrishnan, S., Kolter, Z., & Lipton, Z. (2021). RATT: leveraging unla-\nbeled data to guarantee generalization. International Conference on Machine Learning\n(pp. 3598\u20133609).\nGatys, L. A., Ecker, A. S., & Bethge, M. (2016). Image style transfer using convolutional\nneural networks.", "mimetype": "text/plain", "start_char_idx": 2203543, "end_char_idx": 2206627, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0fce7818-36d8-4641-af69-611bea3ea1b4": {"__data__": {"id_": "0fce7818-36d8-4641-af69-611bea3ea1b4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1e14e335-28ec-4e8a-81c1-f81065d39227", "node_type": "1", "metadata": {}, "hash": "50e8b227b85603b0f0423f4dd919cb3436f8f66f12660367035ab2dca55aedd3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f365573c-743a-4d61-9265-7e6ddbfb8afd", "node_type": "1", "metadata": {}, "hash": "13ce0281fe414e962377bc0f668e60ba454b3e9c0dd6e4a3900ddc81aba86c84", "class_name": "RelatedNodeInfo"}}, "text": "Competition and Cooperation in Neural Nets\n(pp. 267\u2013285). Springer.\n1094 REFERENCES\nGardner, J., Pleiss, G., Weinberger, K. Q., Bindel, D., & Wilson, A. G. (2018). GPyTorch:\nblackbox matrix\u2013matrix Gaussian process inference with GPU acceleration. Advances\ninNeuralInformation ProcessingSystems .\nGarg, S., Balakrishnan, S., Kolter, Z., & Lipton, Z. (2021). RATT: leveraging unla-\nbeled data to guarantee generalization. International Conference on Machine Learning\n(pp. 3598\u20133609).\nGatys, L. A., Ecker, A. S., & Bethge, M. (2016). Image style transfer using convolutional\nneural networks. Proceedings of the IEEE Conference on Computer Vision and Pattern\nRecognition (pp. 2414\u20132423).\nGauss, C. F. (1809). Theoria motus corporum coelestum. Werke. K\u00f6niglich Preussische\nAkademie der Wissenschaften.\nGibbs, J. W. (1902). Elementary Principles of StatisticalMhanics . Scribner\u2019s.\nGinibre,J.(1965).Statisticalensemblesofcomplex,quaternion,andrealmatrices. Journal\nofMathematicalPhysics ,6(3), 440\u2013449.\nGirshick, R. (2015). Fast R-CNN. Proceedings of the IEEE International Conference on\nComputerVision (pp. 1440\u20131448).\nGirshick, R., Donahue, J., Darrell, T., & Malik, J. (2014). Rich feature hierarchies for ac-\ncurateobjectdetectionandsemanticsegmentation. ProceedingsoftheIEEEConference\nonComputerVisionand Pattern Recognition (pp. 580\u2013587).\nGlorot, X., & Bengio, Y. (2010). Understanding the difficulty of training deep feedforward\nneural networks. Proceedings of the 13th International Conference on Artificial Intelli-\ngenceand Statistics (pp. 249\u2013256).\nGoh, G. (2017). Why momentum really works. Distill. URL: http://distill.pub/2017/\nmomentum\nGoldberg, D., Nichols, D., Oki, B. M., & Terry, D. (1992). Using collaborative filtering to\nweave an information tapestry. Communicationsof theACM ,35(12), 61\u201371.\nGolub, G. H., & Van Loan, C. F. (1996). Matrix Computations . Johns Hopkins University\nPress.\nGoodfellow,I.,Bengio,Y.,&Courville,A.(2016). DeepLearning .MITPress. http://www.\ndeeplearningbook.org .\nGoodfellow, I., Pouget-Abadie, J., Mirza, M., Xu, B., Warde-Farley, D., Ozair, S., \u2026 Ben-\ngio, Y. (2014). Generative adversarial nets. Advances in Neural Information Processing\nSystems (pp. 2672\u20132680).\nGotmare, A., Keskar, N. S., Xiong, C., & Socher, R. (2018). A closer look at deep learning\nheuristics: learning rate restarts, warmup and distillation. ArXiv:1810.13243 .\nGoyal, A., Bochkovskiy, A., Deng, J., & Koltun, V. (2021). Non-deep networks.\nArXiv:2110.07641 .\nGraham, B. (2014). Fractional max-pooling. ArXiv:1412.6071 .\nGraves,A.(2013).Generatingsequenceswithrecurrentneuralnetworks. ArXiv:1308.0850 .\nGraves, A., Liwicki, M., Fern\u00e1ndez, S., Bertolami, R., Bunke, H., & Schmidhuber, J.\n(2008). A novel connectionist system for unconstrained handwriting recognition. IEEE\nTransactionson Pattern Analysisand MachineIntelligence ,31(5), 855\u2013868.\nGraves,A.,&Schmidhuber,J.(2005).Framewisephonemeclassificationwithbidirectional\nLSTM and other neural network architectures. Neural Networks ,18(5-6), 602\u2013610.", "mimetype": "text/plain", "start_char_idx": 2206039, "end_char_idx": 2209058, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f365573c-743a-4d61-9265-7e6ddbfb8afd": {"__data__": {"id_": "f365573c-743a-4d61-9265-7e6ddbfb8afd", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0fce7818-36d8-4641-af69-611bea3ea1b4", "node_type": "1", "metadata": {}, "hash": "c1e75d11674d445f31ea8022c64e184225b888a8f0b89e6b7e8fbf45aae68bd7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1af23bc0-73ce-4020-b761-8237e84d9ef4", "node_type": "1", "metadata": {}, "hash": "b91da0d979be15ffbb7bf6025b32a8fac47cb7be2b897fdb0fbaafb8810fd278", "class_name": "RelatedNodeInfo"}}, "text": "Non-deep networks.\nArXiv:2110.07641 .\nGraham, B. (2014). Fractional max-pooling. ArXiv:1412.6071 .\nGraves,A.(2013).Generatingsequenceswithrecurrentneuralnetworks. ArXiv:1308.0850 .\nGraves, A., Liwicki, M., Fern\u00e1ndez, S., Bertolami, R., Bunke, H., & Schmidhuber, J.\n(2008). A novel connectionist system for unconstrained handwriting recognition. IEEE\nTransactionson Pattern Analysisand MachineIntelligence ,31(5), 855\u2013868.\nGraves,A.,&Schmidhuber,J.(2005).Framewisephonemeclassificationwithbidirectional\nLSTM and other neural network architectures. Neural Networks ,18(5-6), 602\u2013610.\n1095 REFERENCES\nGriewank, A. (1989). On automatic differentiation. Mathematical Programming: Recent\nDevelopmentsand Applications (pp. 83\u2013107). Kluwer.\nGulati, A., Qin, J., Chiu, C.-C., Parmar, N., Zhang, Y., Yu, J., \u2026 et al. (2020). Con-\nformer: convolution-augmented transformer for speech recognition. Proc. Interspeech\n2020, pp. 5036\u20135040.\nGuyon, I., Gunn, S., Nikravesh, M., & Zadeh, L. A. (2008). Feature Extraction: Founda-\ntionsand Applications . Springer.\nHadjis, S., Zhang, C., Mitliagkas, I., Iter, D., & R\u00e9, C. (2016). Omnivore: an optimizer for\nmulti-device deep learning on CPUs and GPUs. ArXiv:1606.04487 .\nHartley, R., & Zisserman, A. (2000). Multiple View Geometry in Computer Vision .\nCambridge University Press.\nHartley, R. I., & Kahl, F. (2009). Global optimization through rotation space search. Inter-\nnationalJournal of ComputerVision ,82(1), 64\u201379.\nHe,K.,Chen,X.,Xie,S.,Li,Y.,Doll\u00e1r,P.,&Girshick,R.(2022).Maskedautoencodersare\nscalable vision learners. ProceedingsoftheIEEE/CVFConferenceonComputerVision\nandPattern Recognition (pp. 16000\u201316009).\nHe, K., Gkioxari, G., Doll\u00e1r, P., & Girshick, R. (2017). Mask R-CNN. Proceedings of the\nIEEEInternational Conferenceon ComputerVision (pp. 2961\u20132969).\nHe, K., Zhang, X., Ren, S., & Sun, J. (2015). Delving deep into rectifiers: surpassing\nhuman-level performance on ImageNet classification. ProceedingsoftheIEEEInterna-\ntionalConferenceon ComputerVision (pp. 1026\u20131034).\nHe, K., Zhang, X., Ren, S., & Sun, J. (2016). Deep residual learning for image recogni-\ntion.ProceedingsoftheIEEEConferenceonComputerVisionandPatternRecognition\n(pp. 770\u2013778).\nHe, K., Zhang, X., Ren, S., & Sun, J. (2016). Identity mappings in deep residual networks.\nEuropeanConferenceon ComputerVision (pp. 630\u2013645).\nHebb, D. O. (1949). The Organizationof Behavior . Wiley.\nHendrycks, D., & Gimpel, K. (2016). Gaussian error linear units (GELUs).\nArXiv:1606.08415 .\nHennessy, J. L., & Patterson, D. A. (2011). Computer Architecture: A Quantitative Ap-\nproach. Elsevier.\nHo, J., Jain, A., & Abbeel, P. (2020). Denoising diffusion probabilistic models. Advances\ninNeuralInformation ProcessingSystems ,33, 6840\u20136851.\nHochreiter, S., Bengio, Y., Frasconi, P., & Schmidhuber, J. (2001). Gradient flow in recur-\nrentnets: thedifficultyoflearninglong-termdependencies. AFieldGuidetoDynamical\nRecurrentNeuralNetworks . IEEE Press.\nHochreiter, S., & Schmidhuber, J. (1997).", "mimetype": "text/plain", "start_char_idx": 2208477, "end_char_idx": 2211463, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1af23bc0-73ce-4020-b761-8237e84d9ef4": {"__data__": {"id_": "1af23bc0-73ce-4020-b761-8237e84d9ef4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f365573c-743a-4d61-9265-7e6ddbfb8afd", "node_type": "1", "metadata": {}, "hash": "13ce0281fe414e962377bc0f668e60ba454b3e9c0dd6e4a3900ddc81aba86c84", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1fe53da9-3851-4498-a058-8efa68bfb688", "node_type": "1", "metadata": {}, "hash": "f1a7826e14750b9c2a9df7859c5ebb3f8cbda50b7d45b2dda8ed8034cf2aa9ae", "class_name": "RelatedNodeInfo"}}, "text": "(2016). Gaussian error linear units (GELUs).\nArXiv:1606.08415 .\nHennessy, J. L., & Patterson, D. A. (2011). Computer Architecture: A Quantitative Ap-\nproach. Elsevier.\nHo, J., Jain, A., & Abbeel, P. (2020). Denoising diffusion probabilistic models. Advances\ninNeuralInformation ProcessingSystems ,33, 6840\u20136851.\nHochreiter, S., Bengio, Y., Frasconi, P., & Schmidhuber, J. (2001). Gradient flow in recur-\nrentnets: thedifficultyoflearninglong-termdependencies. AFieldGuidetoDynamical\nRecurrentNeuralNetworks . IEEE Press.\nHochreiter, S., & Schmidhuber, J. (1997). Long short-term memory. NeuralComputation ,\n9(8), 1735\u20131780.\nHoffmann, J., Borgeaud, S., Mensch, A., Buchatskaya, E., Cai, T., Rutherford, E., \u2026 et al.\n(2022). Training compute-optimal large language models. ArXiv:2203.15556 .\nHoward, A., Sandler, M., Chu, G., Chen, L.-C., Chen, B., Tan, M., \u2026 Adam, H. (2019).\nSearchingforMobileNetV3. ProceedingsoftheIEEE/CVFInternationalConferenceon\nComputerVision (pp. 1314\u20131324).\n1096 REFERENCES\nHoyer,P.O.,Janzing,D.,Mooij,J.M.,Peters,J.,&Sch\u00f6lkopf,B.(2009).Nonlinearcausal\ndiscovery with additive noise models. Advances in Neural Information Processing Sys-\ntems(pp. 689\u2013696).\nHu, J., Shen, L., & Sun, G. (2018). Squeeze-and-excitation networks. Proceedings of the\nIEEEConferenceon ComputerVisionand Pattern Recognition (pp. 7132\u20137141).\nHu, Y., Koren, Y., & Volinsky, C. (2008). Collaborative filtering for implicit feedback\ndatasets.20088thIEEE International Conferenceon Data Mining (pp. 263\u2013272).\nHu, Z., Lee, R. K.-W., Aggarwal, C. C., & Zhang, A. (2022). Text style transfer: a review\nand experimental evaluation. SIGKDD Explor. Newsl. ,24(1). URL: https://doi.org/10.\n1145/3544903.3544906\nHuang,C.-Z.A.,Vaswani,A.,Uszkoreit,J.,Simon,I.,Hawthorne,C.,Shazeer,N.,\u2026Eck,\nD. (2018). Music transformer: generating music with long-term structure. International\nConferenceon Learning Representations .\nHuang, G., Liu, Z., Van Der Maaten, L., & Weinberger, K. Q. (2017). Densely connected\nconvolutional networks. Proceedings of the IEEE Conference on Computer Vision and\nPattern Recognition (pp. 4700\u20134708).\nHuang, Z., Xu, W., & Yu, K. (2015). Bidirectional LSTM\u2013CRF models for sequence tag-\nging.ArXiv:1508.01991 .\nHubel,D.H.,&Wiesel,T.N.(1959).Receptivefieldsofsingleneuronesinthecat\u2019sstriate\ncortex.Journal of Physiology ,148(3), 574\u2013591.\nHubel,D.H.,&Wiesel,T.N.(1962).Receptivefields,binocularinteractionandfunctional\narchitecture in the cat\u2019s visual cortex. Journal of Physiology ,160(1), 106\u2013154.\nHubel, D. H., & Wiesel, T. N. (1968). Receptive fields and functional architecture of mon-\nkey striate cortex. Journal of Physiology ,195(1), 215\u2013243.\nHutter,F.,Hoos,H.,&Leyton-Brown,K.(2011).Sequentialmodel-basedoptimizationfor\ngeneral algorithm configuration. Proceedings of the Fifth International Conference on\nLearning and IntelligentOptimization(LION\u201911) .\nHutter, F., Kotthoff, L., & Vanschoren, J. (Eds.) (2019). Automated Machine Learning:\nMethods,Systems,Challenges . Springer.\nIoffe, S. (2017).", "mimetype": "text/plain", "start_char_idx": 2210901, "end_char_idx": 2213909, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1fe53da9-3851-4498-a058-8efa68bfb688": {"__data__": {"id_": "1fe53da9-3851-4498-a058-8efa68bfb688", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1af23bc0-73ce-4020-b761-8237e84d9ef4", "node_type": "1", "metadata": {}, "hash": "b91da0d979be15ffbb7bf6025b32a8fac47cb7be2b897fdb0fbaafb8810fd278", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b5b7955c-d9fa-492f-b223-22f4515bf5dd", "node_type": "1", "metadata": {}, "hash": "c88d004afdf5cdff08c52596981f4af33c235e4d2cac1c345ba3546e23f09a32", "class_name": "RelatedNodeInfo"}}, "text": "(1962).Receptivefields,binocularinteractionandfunctional\narchitecture in the cat\u2019s visual cortex. Journal of Physiology ,160(1), 106\u2013154.\nHubel, D. H., & Wiesel, T. N. (1968). Receptive fields and functional architecture of mon-\nkey striate cortex. Journal of Physiology ,195(1), 215\u2013243.\nHutter,F.,Hoos,H.,&Leyton-Brown,K.(2011).Sequentialmodel-basedoptimizationfor\ngeneral algorithm configuration. Proceedings of the Fifth International Conference on\nLearning and IntelligentOptimization(LION\u201911) .\nHutter, F., Kotthoff, L., & Vanschoren, J. (Eds.) (2019). Automated Machine Learning:\nMethods,Systems,Challenges . Springer.\nIoffe, S. (2017). Batch renormalization: towards reducing minibatch dependence in batch-\nnormalized models. Advances in Neural Information Processing Systems (pp. 1945\u2013\n1953).\nIoffe, S., & Szegedy, C. (2015). Batch normalization: accelerating deep network training\nby reducing internal covariate shift. ArXiv:1502.03167 .\nIzmailov, P., Podoprikhin, D., Garipov, T., Vetrov, D., & Wilson, A. G. (2018). Averaging\nweights leads to wider optima and better generalization. ArXiv:1803.05407 .\nJacot, A., Gabriel, F., & Hongler, C. (2018). Neural tangent kernel: convergence and gen-\neralization in neural networks. Advancesin NeuralInformation ProcessingSystems .\nJaeger, H. (2002). Tutorial on training recurrent neural networks, covering BPPT, RTRL,\nEKF and the \u201cecho state network\u201d approach . GMD-Forschungszentrum Information-\nstechnik Bonn.\nJamieson, K., & Talwalkar, A. (2016). Non-stochastic best arm identification and hyper-\nparameter optimization. Proceedings of the 17th International Conference on Artificial\nIntelligenceand Statistics .\n1097 REFERENCES\nJenatton, R., Archambeau, C., Gonz\u00e1lez, J., & Seeger, M. (2017). Bayesian optimization\nwith tree-structured dependencies. Proceedingsofthe34thInternationalConferenceon\nMachineLearning (ICML\u201917) .\nJia, X., Song, S., He, W., Wang, Y., Rong, H., Zhou, F., \u2026 et al. (2018). Highly scalable\ndeep learning training system with mixed-precision: training ImageNet in four minutes.\nArXiv:1807.11205 .\nJia, Y., Shelhamer, E., Donahue, J., Karayev, S., Long, J., Girshick, R., \u2026 Darrell, T.\n(2014). Caffe: convolutional architecture for fast feature embedding. Proceedingsofthe\n22ndACMInternational Conferenceon Multimedia (pp. 675\u2013678).\nJoshi, M., Chen, D., Liu, Y., Weld, D. S., Zettlemoyer, L., & Levy, O. (2020). SpanBERT:\nimproving pre-training by representing and predicting spans. Transactions of the Asso-\nciationforComputational Linguistics ,8, 64\u201377.\nJouppi, N. P., Young, C., Patil, N., Patterson, D., Agrawal, G., Bajwa, R., \u2026 et al. (2017).\nIn-datacenter performance analysis of a tensor processing unit. 2017 ACM/IEEE 44th\nAnnualInternational Symposium on ComputerArchitecture(ISCA) (pp. 1\u201312).\nKalchbrenner, N., Grefenstette, E., & Blunsom, P. (2014). A convolutional neural network\nfor modelling sentences. ArXiv:1404.2188 .\nKalman, B. L., & Kwasny, S. C. (1992). Why tanh: choosing a sigmoidal function. Pro-\nceedings of the International Joint Conference on Neural Networks (IJCNN) (pp. 578\u2013\n581).\nKaplan, J., McCandlish, S., Henighan, T., Brown, T. B., Chess, B., Child, R., \u2026 Amodei,\nD. (2020). Scaling laws for neural language models. ArXiv:2001.08361 .", "mimetype": "text/plain", "start_char_idx": 2213266, "end_char_idx": 2216516, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b5b7955c-d9fa-492f-b223-22f4515bf5dd": {"__data__": {"id_": "b5b7955c-d9fa-492f-b223-22f4515bf5dd", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1fe53da9-3851-4498-a058-8efa68bfb688", "node_type": "1", "metadata": {}, "hash": "f1a7826e14750b9c2a9df7859c5ebb3f8cbda50b7d45b2dda8ed8034cf2aa9ae", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b5428440-e491-47f6-83f3-bf28e9393d09", "node_type": "1", "metadata": {}, "hash": "494284139e4267c78470a0e9788672b2b3a323f4788d57dc19841eebdc0a3122", "class_name": "RelatedNodeInfo"}}, "text": "2017 ACM/IEEE 44th\nAnnualInternational Symposium on ComputerArchitecture(ISCA) (pp. 1\u201312).\nKalchbrenner, N., Grefenstette, E., & Blunsom, P. (2014). A convolutional neural network\nfor modelling sentences. ArXiv:1404.2188 .\nKalman, B. L., & Kwasny, S. C. (1992). Why tanh: choosing a sigmoidal function. Pro-\nceedings of the International Joint Conference on Neural Networks (IJCNN) (pp. 578\u2013\n581).\nKaplan, J., McCandlish, S., Henighan, T., Brown, T. B., Chess, B., Child, R., \u2026 Amodei,\nD. (2020). Scaling laws for neural language models. ArXiv:2001.08361 .\nKarnin, Z., Koren, T., & Somekh, O. (2013). Almost optimal exploration in multi-\narmed bandits. Proceedings of the 30th International Conference on Machine Learning\n(ICML\u201913) .\nKarras, T., Aila, T., Laine, S., & Lehtinen, J. (2017). Progressive growing of GANs for\nimproved quality, stability, and variation. ArXiv:1710.10196 .\nKim, J., El-Khamy, M., & Lee, J. (2017). Residual LSTM: design of a deep recurrent\narchitecture for distant speech recognition. ArXiv:1701.03360 .\nKim, Y. (2014). Convolutional neural networks for sentence classification.\nArXiv:1408.5882 .\nKimeldorf, G. S., & Wahba, G. (1971). Some results on Tchebycheffian spline functions.\nJ.Math.Anal. Appl. ,33, 82\u201395.\nKingma, D. P., & Ba, J. (2014). Adam: a method for stochastic optimization.\nArXiv:1412.6980 .\nKingma,D.P.,&Welling,M.(2014).Auto-encodingvariationalBayes. InternationalCon-\nferenceon Learning Representations(ICLR) .\nKipf,T.N.,&Welling,M.(2016).Semi-supervisedclassificationwithgraphconvolutional\nnetworks. ArXiv:1609.02907 .\nKojima, T., Gu, S. S., Reid, M., Matsuo, Y., & Iwasawa, Y. (2022). Large language models\nare zero-shot reasoners. arxiv.org/abs/2205.11916 .\nKoller, D., & Friedman, N. (2009). Probabilistic Graphical Models: Principles and Tech-\nniques. MIT Press.\nKolmogorov, A. (1933). Sulla determinazione empirica di una legge di distribuzione. Inst.\nItal.Attuari, Giorn. ,4, 83\u201391.\n1098 REFERENCES\nKolter, Z. (2008). Linear algebra review and reference. Available online:\nhttp://cs229.stanford.edu/section/cs229-linalg.pdf .\nKrizhevsky, A., Sutskever, I., & Hinton, G. E. (2012). ImageNet classification with deep\nconvolutional neural networks. Advances in Neural Information Processing Systems\n(pp. 1097\u20131105).\nKung, S. Y. (1988). VLSI Array Processors. PrenticeHall .\nKuzovkin, I., Vicente, R., Petton, M., Lachaux, J.-P., Baciu, M., Kahane, P., \u2026 Aru, J.\n(2018).Activationsofdeepconvolutionalneuralnetworksarealignedwithgammaband\nactivity of human visual cortex. CommunicationsBiology ,1(1), 1\u201312.\nLan, Z., Chen, M., Goodman, S., Gimpel, K., Sharma, P., & Soricut, R. (2019). ALBERT:\naliteBERTforself-supervisedlearningoflanguagerepresentations. ArXiv:1909.11942 .\nLavin, A., & Gray, S. (2016). Fast algorithms for convolutional neural networks. Proceed-\nings of the IEEE Conference on Computer Vision and Pattern Recognition (pp. 4013\u2013\n4021).", "mimetype": "text/plain", "start_char_idx": 2215960, "end_char_idx": 2218862, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b5428440-e491-47f6-83f3-bf28e9393d09": {"__data__": {"id_": "b5428440-e491-47f6-83f3-bf28e9393d09", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b5b7955c-d9fa-492f-b223-22f4515bf5dd", "node_type": "1", "metadata": {}, "hash": "c88d004afdf5cdff08c52596981f4af33c235e4d2cac1c345ba3546e23f09a32", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "91f789f1-52cf-4b7b-8813-1bb32e2aade3", "node_type": "1", "metadata": {}, "hash": "3ea8de013e73bb183d54cca88e7dabdf5d71b1d844f3539444223557adde0399", "class_name": "RelatedNodeInfo"}}, "text": "Kuzovkin, I., Vicente, R., Petton, M., Lachaux, J.-P., Baciu, M., Kahane, P., \u2026 Aru, J.\n(2018).Activationsofdeepconvolutionalneuralnetworksarealignedwithgammaband\nactivity of human visual cortex. CommunicationsBiology ,1(1), 1\u201312.\nLan, Z., Chen, M., Goodman, S., Gimpel, K., Sharma, P., & Soricut, R. (2019). ALBERT:\naliteBERTforself-supervisedlearningoflanguagerepresentations. ArXiv:1909.11942 .\nLavin, A., & Gray, S. (2016). Fast algorithms for convolutional neural networks. Proceed-\nings of the IEEE Conference on Computer Vision and Pattern Recognition (pp. 4013\u2013\n4021).\nLe,Q.V.(2013).Buildinghigh-levelfeaturesusinglargescaleunsupervisedlearning. Pro-\nceedingsoftheIEEEInternationalConferenceonAcoustics,SpeechandSignalProcess-\ning(pp. 8595\u20138598).\nLeCun, Y., Bengio, Y., & et al. (1995). Convolutional networks for images, speech, and\ntime series. TheHandbook of BrainTheory and NeuralNetworks (p. 3361). MIT Press.\nLeCun, Y., Boser, B., Denker, J. S., Henderson, D., Howard, R. E., Hubbard, W., & Jackel,\nL.D.(1989).Backpropagationappliedtohandwrittenzipcoderecognition. NeuralCom-\nputation ,1(4), 541\u2013551.\nLeCun, Y., Bottou, L., Orr, G., & Muller, K.-R. (1998). Efficient backprop. Neural Net-\nworks: Tricksof theTrade . Springer.\nLeCun, Y., Bottou, L., Bengio, Y., & Haffner, P. (1998). Gradient-based learning applied\nto document recognition. Proceedingsof theIEEE ,86(11), 2278\u20132324.\nLeCun, Y., Jackel, L., Bottou, L., Brunot, A., Cortes, C., Denker, J., \u2026 et al. (1995). Com-\nparison of learning algorithms for handwritten digit recognition. International Confer-\nenceon Artificial NeuralNetworks (pp. 53\u201360).\nLegendre, A.M.(1805). M\u00e9moiresurlesOp\u00e9rationsTrigonom\u00e9triques: dontlesR\u00e9sultats\nD\u00e9pendentde la Figurede la Terre . F. Didot.\nLewis,M.,Liu,Y.,Goyal,N.,Ghazvininejad,M.,Mohamed,A.,Levy,O.,\u2026Zettlemoyer,\nL.(2019).BART:denoisingsequence-to-sequencepre-trainingfornaturallanguagegen-\neration, translation, and comprehension. ArXiv:1910.13461 .\nLewkowycz, A., Andreassen, A., Dohan, D., Dyer, E., Michalewski, H., Ramasesh,\nV., \u2026 et al. (2022). Solving quantitative reasoning problems with language models.\nArXiv:2206.14858 .\nLi, L., Jamieson, K., Rostamizadeh, A., Gonina, K., Hardt, M., Recht, B., & Talwalkar, A.\n(2018). Massively parallel hyperparameter tuning. ArXiv:1810.05934 .\nLi,M.(2017). ScalingDistributedMachineLearningwithSystemandAlgorithmCo-design\n(Doctoral dissertation). PhD Thesis, CMU.\nLi, M., Andersen, D. G., Park, J. W., Smola, A. J., Ahmed, A., Josifovski, V., \u2026 Su, B.-Y.\n(2014).Scalingdistributedmachinelearningwiththeparameterserver. 11thSymposium\nonOperatingSystemsDesign and Implementation (OSDI 14) (pp. 583\u2013598).\n1099 REFERENCES\nLi, M., Zhang, T., Chen, Y., & Smola, A. J. (2014). Efficient mini-batch training for\nstochastic optimization. Proceedings of the 20th ACM SIGKDD International Confer-\nenceon KnowledgeDiscovery and Data Mining (pp. 661\u2013670).", "mimetype": "text/plain", "start_char_idx": 2218286, "end_char_idx": 2221185, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "91f789f1-52cf-4b7b-8813-1bb32e2aade3": {"__data__": {"id_": "91f789f1-52cf-4b7b-8813-1bb32e2aade3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b5428440-e491-47f6-83f3-bf28e9393d09", "node_type": "1", "metadata": {}, "hash": "494284139e4267c78470a0e9788672b2b3a323f4788d57dc19841eebdc0a3122", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3680adf0-3107-4e4d-92f3-cb6e1974e150", "node_type": "1", "metadata": {}, "hash": "62e49839bb01d98ea05e8ecbe34c29bc6bee1a628325ace483c90ed97561f7a8", "class_name": "RelatedNodeInfo"}}, "text": "ArXiv:1810.05934 .\nLi,M.(2017). ScalingDistributedMachineLearningwithSystemandAlgorithmCo-design\n(Doctoral dissertation). PhD Thesis, CMU.\nLi, M., Andersen, D. G., Park, J. W., Smola, A. J., Ahmed, A., Josifovski, V., \u2026 Su, B.-Y.\n(2014).Scalingdistributedmachinelearningwiththeparameterserver. 11thSymposium\nonOperatingSystemsDesign and Implementation (OSDI 14) (pp. 583\u2013598).\n1099 REFERENCES\nLi, M., Zhang, T., Chen, Y., & Smola, A. J. (2014). Efficient mini-batch training for\nstochastic optimization. Proceedings of the 20th ACM SIGKDD International Confer-\nenceon KnowledgeDiscovery and Data Mining (pp. 661\u2013670).\nLiaw, R., Liang, E., Nishihara, R., Moritz, P., Gonzalez, J., & Stoica, I. (2018). Tune: a\nresearch platform for distributed model selection and training. ArXiv:1807.05118 .\nLin, M., Chen, Q., & Yan, S. (2013). Network in network. ArXiv:1312.4400 .\nLin, T.-Y., Goyal, P., Girshick, R., He, K., & Doll\u00e1r, P. (2017). Focal loss for dense ob-\nject detection. Proceedings of the IEEE International Conference on Computer Vision\n(pp. 2980\u20132988).\nLin, Y., Lv, F., Zhu, S., Yang, M., Cour, T., Yu, K., \u2026 others. (2010). ImageNet classifi-\ncation: fast descriptor coding and large-scale SVM training. Large Scale Visual Recog-\nnitionChallenge .\nLin, Z., Feng, M., Santos, C. N. d., Yu, M., Xiang, B., Zhou, B., & Bengio, Y. (2017). A\nstructured self-attentive sentence embedding. ArXiv:1703.03130 .\nLipton, Z. C., Berkowitz, J., & Elkan, C. (2015). A critical review of recurrent neural\nnetworks for sequence learning. ArXiv:1506.00019 .\nLipton, Z. C., Kale, D. C., Elkan, C., & Wetzel, R. (2016). Learning to diagnose with\nLSTM recurrent neural networks. International Conference on Learning Representa-\ntions(ICLR) .\nLipton, Z. C., & Steinhardt, J. (2018). Troubling trends in machine learning scholarship.\nCommunicationsof theACM ,17, 45\u201377.\nLiu, D. C., & Nocedal, J. (1989). On the limited memory BFGS method for large scale\noptimization. MathematicalProgramming ,45(1), 503\u2013528.\nLiu, H., Simonyan, K., & Yang, Y. (2018). DARTS: differentiable architecture search.\nArXiv:1806.09055 .\nLiu, W., Anguelov, D., Erhan, D., Szegedy, C., Reed, S., Fu, C.-Y., & Berg, A. C. (2016).\nSSD: single shot multibox detector. EuropeanConferenceonComputerVision (pp. 21\u2013\n37).\nLiu, Y., Ott, M., Goyal, N., Du, J., Joshi, M., Chen, D., \u2026 Stoyanov, V. (2019). RoBERTa:\na robustly optimized BERT pretraining approach. ArXiv:1907.11692 .\nLiu, Z., Lin, Y., Cao, Y., Hu, H., Wei, Y., Zhang, Z., \u2026 Guo, B. (2021). Swin transformer:\nhierarchical vision transformer using shifted windows. Proceedings of the IEEE/CVF\nInternational Conferenceon ComputerVision (pp. 10012\u201310022).\nLiu, Z., Mao, H., Wu, C.-Y., Feichtenhofer, C., Darrell, T., & Xie, S. (2022). A convNet\nfor the 2020s. ArXiv:2201.03545 .\nLong, J., Shelhamer, E., & Darrell, T. (2015). Fully convolutional networks for semantic\nsegmentation.", "mimetype": "text/plain", "start_char_idx": 2220568, "end_char_idx": 2223458, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3680adf0-3107-4e4d-92f3-cb6e1974e150": {"__data__": {"id_": "3680adf0-3107-4e4d-92f3-cb6e1974e150", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "91f789f1-52cf-4b7b-8813-1bb32e2aade3", "node_type": "1", "metadata": {}, "hash": "3ea8de013e73bb183d54cca88e7dabdf5d71b1d844f3539444223557adde0399", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d464eeae-ed59-4cf3-bb39-412f2207a2e0", "node_type": "1", "metadata": {}, "hash": "1bfac8e2af4eed6923e46b966e375ddb9949f278407bae67b1713f1c890a9f62", "class_name": "RelatedNodeInfo"}}, "text": "(2019). RoBERTa:\na robustly optimized BERT pretraining approach. ArXiv:1907.11692 .\nLiu, Z., Lin, Y., Cao, Y., Hu, H., Wei, Y., Zhang, Z., \u2026 Guo, B. (2021). Swin transformer:\nhierarchical vision transformer using shifted windows. Proceedings of the IEEE/CVF\nInternational Conferenceon ComputerVision (pp. 10012\u201310022).\nLiu, Z., Mao, H., Wu, C.-Y., Feichtenhofer, C., Darrell, T., & Xie, S. (2022). A convNet\nfor the 2020s. ArXiv:2201.03545 .\nLong, J., Shelhamer, E., & Darrell, T. (2015). Fully convolutional networks for semantic\nsegmentation. Proceedings of the IEEE Conference on Computer Vision and Pattern\nRecognition (pp. 3431\u20133440).\nLoshchilov, I., & Hutter, F. (2016). SGDR: stochastic gradient descent with warm restarts.\nArXiv:1608.03983 .\nLowe, D. G. (2004). Distinctive image features from scale-invariant keypoints. Interna-\ntionalJournal of ComputerVision ,60(2), 91\u2013110.\nLuo, P., Wang, X., Shao, W., & Peng, Z. (2018). Towards understanding regularization in\nbatch normalization. ArXiv:1809.00846 .\n1100 REFERENCES\nMaas, A. L., Daly, R. E., Pham, P. T., Huang, D., Ng, A. Y., & Potts, C. (2011). Learn-\ning word vectors for sentiment analysis. Proceedings of the 49th Annual Meeting of the\nAssociation for Computational Linguistics: Human Language Technologies, Volume 1\n(pp. 142\u2013150).\nMack, Y.-P., & Silverman, B. W. (1982). Weak and strong uniform consistency of kernel\nregression estimates. Zeitschrift f\u00fcr Wahrscheinlichkeitstheorie und verwandte Gebiete ,\n61(3), 405\u2013415.\nMacKay,D.J.(2003). InformationTheory,InferenceandLearningAlgorithms .Cambridge\nUniversity Press.\nMaclaurin, D., Duvenaud, D., & Adams, R. (2015). Gradient-based hyperparameter opti-\nmization through reversible learning. Proceedingsofthe32ndInternationalConference\nonMachineLearning (ICML\u201915) .\nMangasarian, O. L. (1965). Linear and nonlinear separation of patterns by linear program-\nming.Oper.Res. ,13, 444-452.\nMangram,M.E.(2013).AsimplifiedperspectiveoftheMarkowitzportfoliotheory. Global\nJournal of Business Research ,7(1), 59\u201370.\nMatthews, A. G. d. G., Rowland, M., Hron, J., Turner, R. E., & Ghahramani, Z. (2018).\nGaussian process behaviour in wide deep neural networks. ArXiv:1804.11271 .\nMcCann,B.,Bradbury,J.,Xiong,C.,&Socher,R.(2017).Learnedintranslation: Contex-\ntualized word vectors. Advances in Neural Information Processing Systems (pp. 6294\u2013\n6305).\nMcCulloch, W. S., & Pitts, W. (1943). A logical calculus of the ideas immanent in nervous\nactivity.Bulletinof MathematicalBiophysics ,5(4), 115\u2013133.\nMead, C. (1980). Introduction to VLSI systems. IEE Proceedings I-Solid-State and Elec-\ntronDevices ,128(1), 18.\nMerity, S., Xiong, C., Bradbury, J., & Socher, R. (2016). Pointer sentinel mixture models.\nArXiv:1609.07843 .\nMicchelli,C.A.(1984).Interpolationofscattereddata: distancematricesandconditionally\npositive definite functions. Approximation Theory and Spline Functions (pp. 143\u2013145).\nSpringer.\nMikolov, T., Chen, K., Corrado, G., & Dean, J. (2013). Efficient estimation of word repre-\nsentations in vector space. ArXiv:1301.3781 .", "mimetype": "text/plain", "start_char_idx": 2222914, "end_char_idx": 2225959, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d464eeae-ed59-4cf3-bb39-412f2207a2e0": {"__data__": {"id_": "d464eeae-ed59-4cf3-bb39-412f2207a2e0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3680adf0-3107-4e4d-92f3-cb6e1974e150", "node_type": "1", "metadata": {}, "hash": "62e49839bb01d98ea05e8ecbe34c29bc6bee1a628325ace483c90ed97561f7a8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fcb58d6e-76a7-4339-a4f3-fbb4bda5f953", "node_type": "1", "metadata": {}, "hash": "7c618e15044a2debe7de4d2e92c2899288d9ffcc1507d9365ddb0251e102cc41", "class_name": "RelatedNodeInfo"}}, "text": "Mead, C. (1980). Introduction to VLSI systems. IEE Proceedings I-Solid-State and Elec-\ntronDevices ,128(1), 18.\nMerity, S., Xiong, C., Bradbury, J., & Socher, R. (2016). Pointer sentinel mixture models.\nArXiv:1609.07843 .\nMicchelli,C.A.(1984).Interpolationofscattereddata: distancematricesandconditionally\npositive definite functions. Approximation Theory and Spline Functions (pp. 143\u2013145).\nSpringer.\nMikolov, T., Chen, K., Corrado, G., & Dean, J. (2013). Efficient estimation of word repre-\nsentations in vector space. ArXiv:1301.3781 .\nMikolov, T., Sutskever, I., Chen, K., Corrado, G. S., & Dean, J. (2013). Distributed rep-\nresentations of words and phrases and their compositionality. AdvancesinNeuralInfor-\nmationProcessingSystems (pp. 3111\u20133119).\nMiller,G.A.(1995).WordNet: alexicaldatabaseforEnglish. CommunicationsoftheACM ,\n38(11), 39\u201341.\nMirhoseini, A., Pham, H., Le, Q. V., Steiner, B., Larsen, R., Zhou, Y., \u2026 Dean, J. (2017).\nDevice placement optimization with reinforcement learning. Proceedings of the 34th\nInternational Conferenceon MachineLearning (pp. 2430\u20132439).\nMnih, V., Heess, N., Graves, A., & others. (2014). Recurrent models of visual attention.\nAdvancesin NeuralInformation ProcessingSystems (pp. 2204\u20132212).\nMnih, V., Kavukcuoglu, K., Silver, D., Graves, A., Antonoglou, I., Wierstra, D., & Ried-\nmiller, M. (2013). Playing Atari with deep reinforcement learning. ArXiv:1312.5602 .\n1101 REFERENCES\nMnih, V., Kavukcuoglu, K., Silver, D., Rusu, A. A., Veness, J., Bellemare, M. G., \u2026 et al.\n(2015). Human-level control through deep reinforcement learning. Nature,518(7540),\n529\u2013533.\nMoon,T.,Smola,A.,Chang,Y.,&Zheng,Z.(2010).Intervalrank: isotonicregressionwith\nlistwise and pairwise constraints. Proceedingsofthe3rdACMInternationalConference\nonWebSearchand Data Mining (pp. 151\u2013160).\nMorey, R. D., Hoekstra, R., Rouder, J. N., Lee, M. D., & Wagenmakers, E.-J. (2016). The\nfallacy of placing confidence in confidence intervals. Psychonomic Bulletin & Review ,\n23(1), 103\u2013123.\nMorozov, V. A. (1984). MethodsforSolvingIncorrectlyPosedProblems . Springer.\nNadaraya,E.A.(1964).Onestimatingregression. TheoryofProbability&itsApplications ,\n9(1), 141\u2013142.\nNair, V., & Hinton, G. E. (2010). Rectified linear units improve restricted Boltzmann ma-\nchines.ICML.\nNakkiran,P.,Kaplun,G.,Bansal,Y.,Yang,T.,Barak,B.,&Sutskever,I.(2021).Deepdou-\nble descent: where bigger models and more data hurt. JournalofStatisticalMechanics:\nTheory and Experiment ,2021(12), 124003.\nNaor, M., & Reingold, O. (1999). On the construction of pseudorandom permutations:\nLuby\u2013Rackoff revisited. Journal of Cryptology ,12(1), 29\u201366.\nNeal, R. M. (1996). BayesianLearning forNeuralNetworks . Springer.\nNesterov, Y. (2018). Lectureson ConvexOptimization . Springer.\nNesterov, Y., & Vial, J.-P. (2000). Confidence level solutions for stochastic programming.\nAutomatica ,44(6), 1559\u20131568.\nNeyman, J. (1937). Outline of a theory of statistical estimation based on the classical the-\nory of probability.", "mimetype": "text/plain", "start_char_idx": 2225421, "end_char_idx": 2228411, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fcb58d6e-76a7-4339-a4f3-fbb4bda5f953": {"__data__": {"id_": "fcb58d6e-76a7-4339-a4f3-fbb4bda5f953", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d464eeae-ed59-4cf3-bb39-412f2207a2e0", "node_type": "1", "metadata": {}, "hash": "1bfac8e2af4eed6923e46b966e375ddb9949f278407bae67b1713f1c890a9f62", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c47830cf-5f41-44a8-96de-3225f00bc345", "node_type": "1", "metadata": {}, "hash": "4242f30b131550ddc924879308476f3845754b39b4cc82017f96ac3cde09a788", "class_name": "RelatedNodeInfo"}}, "text": "JournalofStatisticalMechanics:\nTheory and Experiment ,2021(12), 124003.\nNaor, M., & Reingold, O. (1999). On the construction of pseudorandom permutations:\nLuby\u2013Rackoff revisited. Journal of Cryptology ,12(1), 29\u201366.\nNeal, R. M. (1996). BayesianLearning forNeuralNetworks . Springer.\nNesterov, Y. (2018). Lectureson ConvexOptimization . Springer.\nNesterov, Y., & Vial, J.-P. (2000). Confidence level solutions for stochastic programming.\nAutomatica ,44(6), 1559\u20131568.\nNeyman, J. (1937). Outline of a theory of statistical estimation based on the classical the-\nory of probability. PhilosophicalTransactionsoftheRoyalSocietyofLondon.SeriesA,\nMathematicaland PhysicalSciences ,236(767), 333\u2013380.\nNorelli, A., Fumero, M., Maiorca, V., Moschella, L., Rodol\u00e0, E., & Locatello, F.\n(2022). ASIF: coupled data turns unimodal models to multimodal without training.\nArXiv:2210.01738 .\nNovak, R., Xiao, L., Lee, J., Bahri, Y., Yang, G., Hron, J., \u2026 Sohl-Dickstein, J. (2018).\nBayesian deep convolutional networks with many channels are Gaussian processes.\nArXiv:1810.05148 .\nNovikoff, A. B. J. (1962). On convergence proofs on perceptrons. ProceedingsoftheSym-\nposiumon theMathematicalTheory of Automata (pp. 615\u2013622).\nOlshausen,B.A.,&Field,D.J.(1996).Emergenceofsimple-cellreceptivefieldproperties\nby learning a sparse code for natural images. Nature,381(6583), 607\u2013609.\nOng, C. S., Smola, A., & Williamson, R. (2005). Learning the kernel with hyperkernels.\nJournal of MachineLearning Research ,6, 1043\u20131071.\nOpenAI. (2023). GPT-4 Technical Report. ArXiv:2303.08774 .\nOuyang, L., Wu, J., Jiang, X., Almeida, D., Wainwright, C. L., Mishkin, P., \u2026\net al. (2022). Training language models to follow instructions with human feedback.\nArXiv:2203.02155 .\nPapineni, K., Roukos, S., Ward, T., & Zhu, W.-J. (2002). BLEU: a method for automatic\nevaluation of machine translation. Proceedings of the 40th Annual Meeting of the Asso-\nciationforComputational Linguistics (pp. 311\u2013318).\n1102 REFERENCES\nParikh, A. P., T\u00e4ckstr\u00f6m, O., Das, D., & Uszkoreit, J. (2016). A decomposable attention\nmodel for natural language inference. ArXiv:1606.01933 .\nPark, T., Liu, M.-Y., Wang, T.-C., & Zhu, J.-Y. (2019). Semantic image synthesis with\nspatially-adaptive normalization. ProceedingsoftheIEEEConferenceonComputerVi-\nsionand Pattern Recognition (pp. 2337\u20132346).\nParzen, E. (1957). On consistent estimates of the spectrum of a stationary time series. An-\nnalsof MathematicalStatistics ,28, 329\u2013348.\nPaszke, A., Gross, S., Massa, F., Lerer, A., Bradbury, J., Chanan, G., \u2026 et al. (2019). Py-\nTorch: an imperative style, high-performance deep learning library. AdvancesinNeural\nInformation ProcessingSystems ,32, 8026\u20138037.\nPaulus, R., Xiong, C., & Socher, R. (2017). A deep reinforced model for abstractive sum-\nmarization. ArXiv:1705.04304 .\nPenedo,G.,Malartic,Q.,Hesslow,D.,Cojocaru,R.,Cappelli,A.,Alobeidli,H.,\u2026Launay,\nJ.(2023).TheRefinedWebdatasetforFalconLLM:outperformingcuratedcorporawith\nweb data, and web data only.", "mimetype": "text/plain", "start_char_idx": 2227832, "end_char_idx": 2230824, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c47830cf-5f41-44a8-96de-3225f00bc345": {"__data__": {"id_": "c47830cf-5f41-44a8-96de-3225f00bc345", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fcb58d6e-76a7-4339-a4f3-fbb4bda5f953", "node_type": "1", "metadata": {}, "hash": "7c618e15044a2debe7de4d2e92c2899288d9ffcc1507d9365ddb0251e102cc41", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "06193a1d-e19f-4d7d-8549-e730b78e28be", "node_type": "1", "metadata": {}, "hash": "872924232a14fa378b59392682a806f8718cd990de2443f3e20a9cfea77691c4", "class_name": "RelatedNodeInfo"}}, "text": "Paszke, A., Gross, S., Massa, F., Lerer, A., Bradbury, J., Chanan, G., \u2026 et al. (2019). Py-\nTorch: an imperative style, high-performance deep learning library. AdvancesinNeural\nInformation ProcessingSystems ,32, 8026\u20138037.\nPaulus, R., Xiong, C., & Socher, R. (2017). A deep reinforced model for abstractive sum-\nmarization. ArXiv:1705.04304 .\nPenedo,G.,Malartic,Q.,Hesslow,D.,Cojocaru,R.,Cappelli,A.,Alobeidli,H.,\u2026Launay,\nJ.(2023).TheRefinedWebdatasetforFalconLLM:outperformingcuratedcorporawith\nweb data, and web data only. ArXiv:2306.01116 .\nPennington, J., Schoenholz, S., & Ganguli, S. (2017). Resurrecting the sigmoid in deep\nlearningthroughdynamicalisometry: theoryandpractice. AdvancesinNeuralInforma-\ntionProcessingSystems (pp. 4785\u20134795).\nPennington,J.,Socher,R.,&Manning,C.(2014).GloVe: globalvectorsforwordrepresen-\ntation.Proceedingsofthe2014ConferenceonEmpiricalMethodsinNaturalLanguage\nProcessing(EMNLP) (pp. 1532\u20131543).\nPeters,J.,Janzing,D.,&Sch\u00f6lkopf,B.(2017). ElementsofCausalInference: Foundations\nandLearning Algorithms . MIT Press.\nPeters, M., Ammar, W., Bhagavatula, C., & Power, R. (2017). Semi-supervised sequence\ntagging with bidirectional language models. Proceedingsofthe55thAnnualMeetingof\ntheAssociation forComputational Linguistics,Volume1 (pp. 1756\u20131765).\nPeters, M., Neumann, M., Iyyer, M., Gardner, M., Clark, C., Lee, K., & Zettlemoyer, L.\n(2018). Deep contextualized word representations. Proceedingsofthe2018Conference\noftheNorthAmericanChapteroftheAssociationforComputationalLinguistics: Human\nLanguageTechnologies,Volume1 (pp. 2227\u20132237).\nPetersen, K. B., & Pedersen, M. S. (2008). The Matrix Cookbook . Technical University of\nDenmark.\nPleiss, G., Chen, D., Huang, G., Li, T., Van Der Maaten, L., & Weinberger, K. Q. (2017).\nMemory-efficient implementation of densenets. ArXiv:1707.06990 .\nPolyak, B. T. (1964). Some methods of speeding up the convergence of iteration methods.\nUSSRComputational Mathematicsand MathematicalPhysics ,4(5), 1\u201317.\nPrakash, A., Hasan, S. A., Lee, K., Datla, V., Qadir, A., Liu, J., & Farri, O. (2016). Neural\nparaphrase generation with stacked residual LSTM networks. ArXiv:1610.03098 .\nQin, C., Zhang, A., Zhang, Z., Chen, J., Yasunaga, M., & Yang, D. (2023). Is ChatGPT a\ngeneral-purpose natural language processing task solver? ArXiv:2302.06476 .\nQuadrana, M., Cremonesi, P., & Jannach, D. (2018). Sequence-aware recommender sys-\ntems.ACMComputing Surveys ,51(4), 66.\nQuinlan, J. R. (1993). C4.5: ProgramsforMachineLearning . Elsevier.\nRabiner, L., & Juang, B.-H. (1993). Fundamentalsof SpeechRecognition . Prentice-Hall.\n1103 REFERENCES\nRadford, A., Kim, J. W., Hallacy, C., Ramesh, A., Goh, G., Agarwal, S., \u2026 et al. (2021).\nLearning transferable visual models from natural language supervision. International\nConferenceon MachineLearning (pp. 8748\u20138763).\nRadford, A., Metz, L., & Chintala, S. (2015). Unsupervised representation learning with\ndeep convolutional generative adversarial networks.", "mimetype": "text/plain", "start_char_idx": 2230300, "end_char_idx": 2233267, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "06193a1d-e19f-4d7d-8549-e730b78e28be": {"__data__": {"id_": "06193a1d-e19f-4d7d-8549-e730b78e28be", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c47830cf-5f41-44a8-96de-3225f00bc345", "node_type": "1", "metadata": {}, "hash": "4242f30b131550ddc924879308476f3845754b39b4cc82017f96ac3cde09a788", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e5355f4d-cfa9-4eb9-abd5-6a24fd55aa98", "node_type": "1", "metadata": {}, "hash": "9d9b9fd051e4ae96c6947229094d44b0e743c5ba7513f89b6b59ec24cef6faf4", "class_name": "RelatedNodeInfo"}}, "text": "Sequence-aware recommender sys-\ntems.ACMComputing Surveys ,51(4), 66.\nQuinlan, J. R. (1993). C4.5: ProgramsforMachineLearning . Elsevier.\nRabiner, L., & Juang, B.-H. (1993). Fundamentalsof SpeechRecognition . Prentice-Hall.\n1103 REFERENCES\nRadford, A., Kim, J. W., Hallacy, C., Ramesh, A., Goh, G., Agarwal, S., \u2026 et al. (2021).\nLearning transferable visual models from natural language supervision. International\nConferenceon MachineLearning (pp. 8748\u20138763).\nRadford, A., Metz, L., & Chintala, S. (2015). Unsupervised representation learning with\ndeep convolutional generative adversarial networks. ArXiv:1511.06434 .\nRadford, A., Narasimhan, K., Salimans, T., & Sutskever, I. (2018). Improving language\nunderstanding by generative pre-training. OpenAI.\nRadford, A., Wu, J., Child, R., Luan, D., Amodei, D., & Sutskever, I. (2019). Language\nmodels are unsupervised multitask learners. OpenAI Blog ,1(8), 9.\nRadosavovic, I., Johnson, J., Xie, S., Lo, W.-Y., & Doll\u00e1r, P. (2019). On network design\nspaces for visual recognition. Proceedings of the IEEE/CVF International Conference\nonComputerVision (pp. 1882\u20131890).\nRadosavovic, I., Kosaraju, R. P., Girshick, R., He, K., & Doll\u00e1r, P. (2020). Designing net-\nwork design spaces. ProceedingsoftheIEEE/CVFConferenceonComputerVisionand\nPattern Recognition (pp. 10428\u201310436).\nRae, J. W., Borgeaud, S., Cai, T., Millican, K., Hoffmann, J., Song, F., \u2026 et al.\n(2021). Scaling language models: methods, analysis & insights from training gopher.\nArXiv:2112.11446 .\nRaffel, C., Shazeer, N., Roberts, A., Lee, K., Narang, S., Matena, M., \u2026 Liu, P. J. (2020).\nExploring the limits of transfer learning with a unified text-to-text transformer. Journal\nofMachineLearning Research ,21, 1\u201367.\nRajpurkar, P., Zhang, J., Lopyrev, K., & Liang, P. (2016). SQuAD: 100,000+ questions for\nmachine comprehension of text. ArXiv:1606.05250 .\nRamachandran, P., Parmar, N., Vaswani, A., Bello, I., Levskaya, A., & Shlens, J. (2019).\nStand-alone self-attention in vision models. AdvancesinNeuralInformationProcessing\nSystems,32.\nRamachandran, P., Zoph, B., & Le, Q. V. (2017). Searching for activation functions.\nArXiv:1710.05941 .\nRamesh, A., Dhariwal, P., Nichol, A., Chu, C., & Chen, M. (2022). Hierarchical text-\nconditional image generation with clip latents. ArXiv:2204.06125 .\nRam\u00f3n y Cajal, Santiago, & Azoulay, L. (1894). Les Nouvelles Id\u00e9es sur la Structure du\nSyst\u00e8meNerveuxchezl\u2019Homme etchezles Vert\u00e9br\u00e9s . Paris, C. Reinwald & Cie.\nRanzato, M.-A., Boureau, Y.-L., Chopra, S., & LeCun, Y. (2007). A unified energy-based\nframeworkforunsupervisedlearning. ArtificialIntelligenceandStatistics (pp.371\u2013379).\nRasmussen, C. E., & Williams, C. K. (2006). Gaussian Processes for Machine Learning .\nMIT Press.\nReddi, S. J., Kale, S., & Kumar, S. (2019). On the convergence of Adam and beyond.\nArXiv:1904.09237 .\nRedmon, J., Divvala, S., Girshick, R., & Farhadi, A.", "mimetype": "text/plain", "start_char_idx": 2232668, "end_char_idx": 2235555, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e5355f4d-cfa9-4eb9-abd5-6a24fd55aa98": {"__data__": {"id_": "e5355f4d-cfa9-4eb9-abd5-6a24fd55aa98", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "06193a1d-e19f-4d7d-8549-e730b78e28be", "node_type": "1", "metadata": {}, "hash": "872924232a14fa378b59392682a806f8718cd990de2443f3e20a9cfea77691c4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ca9acbb1-5468-406e-8a33-7319dde01d6b", "node_type": "1", "metadata": {}, "hash": "f0a1886f90f9b81dde8e545b4856e2c15861c6aadd4e21aab8111f617b778d93", "class_name": "RelatedNodeInfo"}}, "text": "Les Nouvelles Id\u00e9es sur la Structure du\nSyst\u00e8meNerveuxchezl\u2019Homme etchezles Vert\u00e9br\u00e9s . Paris, C. Reinwald & Cie.\nRanzato, M.-A., Boureau, Y.-L., Chopra, S., & LeCun, Y. (2007). A unified energy-based\nframeworkforunsupervisedlearning. ArtificialIntelligenceandStatistics (pp.371\u2013379).\nRasmussen, C. E., & Williams, C. K. (2006). Gaussian Processes for Machine Learning .\nMIT Press.\nReddi, S. J., Kale, S., & Kumar, S. (2019). On the convergence of Adam and beyond.\nArXiv:1904.09237 .\nRedmon, J., Divvala, S., Girshick, R., & Farhadi, A. (2016). You only look once: unified,\nreal-timeobjectdetection. ProceedingsoftheIEEEConferenceonComputerVisionand\nPattern Recognition (pp. 779\u2013788).\nRedmon, J., & Farhadi, A. (2018). YOLOv3: an incremental improvement.\nArXiv:1804.02767 .\nReed, S., & De Freitas, N. (2015). Neural programmer-interpreters. ArXiv:1511.06279 .\n1104 REFERENCES\nReed, S., Zolna, K., Parisotto, E., Colmenarejo, S. G., Novikov, A., Barth-Maron, G., \u2026\net al. (2022). A generalist agent. ArXiv:2205.06175 .\nRen, S., He, K., Girshick, R., & Sun, J. (2015). Faster R-CNN: towards real-time object\ndetection with region proposal networks. Advances in Neural Information Processing\nSystems (pp. 91\u201399).\nRevels, J., Lubin, M., & Papamarkou, T. (2016). Forward-mode automatic differentiation\nin Julia.ArXiv:1607.07892 .\nRezende, D. J., Mohamed, S., & Wierstra, D. (2014). Stochastic backpropagation and ap-\nproximate inference in deep generative models. International Conference on Machine\nLearning (pp. 1278\u20131286).\nRiesenhuber, M., &Poggio, T.(1999).Hierarchicalmodelsofobjectrecognitionincortex.\nNatureNeuroscience ,2(11), 1019\u20131025.\nRockafellar, R. T. (1970). ConvexAnalysis . Princeton University Press.\nRolnick, D., Veit, A., Belongie, S., &Shavit, N.(2017).Deeplearningisrobusttomassive\nlabel noise. ArXiv:1705.10694 .\nRudin, W. (1973). FunctionalAnalysis . McGraw-Hill.\nRumelhart, D. E., Hinton, G. E., & Williams, R. J. (1988). Learning representations by\nback-propagating errors. CognitiveModeling ,5(3), 1.\nRussakovsky, O., Deng, J., Huang, Z., Berg, A. C., & Fei-Fei, L. (2013). Detecting avoca-\ndostozucchinis: whathavewedone,andwherearewegoing? InternationalConference\nonComputerVision(ICCV) .\nRussakovsky, O., Deng, J., Su, H., Krause, J., Satheesh, S., Ma, S., \u2026 et al. (2015). Ima-\ngeNetlargescalevisualrecognitionchallenge. InternationalJournalofComputerVision ,\n115(3), 211\u2013252.\nRussell, S. J., & Norvig, P. (2016). Artificial Intelligence: A Modern Approach . Pearson\nEducation Limited.\nSaharia, C., Chan, W., Saxena, S., Li, L., Whang, J., Denton, E., \u2026 et al. (2022).\nPhotorealistic text-to-image diffusion models with deep language understanding.\nArXiv:2205.11487 .\nSalinas, D., Seeger, M., Klein, A., Perrone, V., Wistuba, M., & Archambeau, C. (2022).\nSyne Tune: a library for large scale hyperparameter tuning and reproducible research.", "mimetype": "text/plain", "start_char_idx": 2235019, "end_char_idx": 2237884, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ca9acbb1-5468-406e-8a33-7319dde01d6b": {"__data__": {"id_": "ca9acbb1-5468-406e-8a33-7319dde01d6b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e5355f4d-cfa9-4eb9-abd5-6a24fd55aa98", "node_type": "1", "metadata": {}, "hash": "9d9b9fd051e4ae96c6947229094d44b0e743c5ba7513f89b6b59ec24cef6faf4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "de24e18f-e50b-4bb2-a9d8-20657317d580", "node_type": "1", "metadata": {}, "hash": "0de94cbe8e63fd983a6b0cdf846e9e40acc35a316040f33f6272b50cd4b3b173", "class_name": "RelatedNodeInfo"}}, "text": "(2015). Ima-\ngeNetlargescalevisualrecognitionchallenge. InternationalJournalofComputerVision ,\n115(3), 211\u2013252.\nRussell, S. J., & Norvig, P. (2016). Artificial Intelligence: A Modern Approach . Pearson\nEducation Limited.\nSaharia, C., Chan, W., Saxena, S., Li, L., Whang, J., Denton, E., \u2026 et al. (2022).\nPhotorealistic text-to-image diffusion models with deep language understanding.\nArXiv:2205.11487 .\nSalinas, D., Seeger, M., Klein, A., Perrone, V., Wistuba, M., & Archambeau, C. (2022).\nSyne Tune: a library for large scale hyperparameter tuning and reproducible research.\nFirstConferenceon AutomatedMachineLearning .\nSanh, V., Debut, L., Chaumond, J., & Wolf, T. (2019). DistilBERT, a distilled version of\nBERT: smaller, faster, cheaper and lighter. ArXiv:1910.01108 .\nSanh, V., Webson, A., Raffel, C., Bach, S. H., Sutawika, L., Alyafeai, Z., \u2026 et al. (2021).\nMultitask prompted training enables zero-shot task generalization. ArXiv:2110.08207 .\nSanturkar, S., Tsipras, D., Ilyas, A., & Madry, A. (2018). How does batch normaliza-\ntion help optimization? AdvancesinNeuralInformationProcessingSystems (pp. 2483\u2013\n2493).\nSarwar, B. M., Karypis, G., Konstan, J. A., & Riedl, J. (2001). Item-based collaborative\nfiltering recommendation algorithms. Proceedings of 10th International Conference on\nWorldWideWeb (pp. 285\u2013295).\nScao, T. L., Fan, A., Akiki, C., Pavlick, E., Ili\u0107, S., Hesslow, D., \u2026 et al. (2022). BLOOM:\na 176B-parameter open-access multilingual language model. ArXiv:2211.05100 .\n1105 REFERENCES\nSchein,A.I.,Popescul,A.,Ungar,L.H.,&Pennock,D.M.(2002).Methodsandmetricsfor\ncold-start recommendations. Proceedings of the 25th Annual International ACM SIGIR\nConferenceon Researchand Developmentin Information Retrieval (pp. 253\u2013260).\nSchuhmann, C., Beaumont, R., Vencu, R., Gordon, C., Wightman, R., Cherti, M., \u2026 et al.\n(2022). LAION-5B: an open large-scale dataset for training next generation image-text\nmodels.ArXiv:2210.08402 .\nSchuster,M.,&Paliwal,K.K.(1997).Bidirectionalrecurrentneuralnetworks. IEEETrans-\nactionson Signal Processing ,45(11), 2673\u20132681.\nSch\u00f6lkopf, B., Herbrich, R., & Smola, A. J. (2001). Helmbold, D. P., & Williamson, B.\n(Eds.). A generalized representer theorem. Proceedings of the Annual Conference on\nComputationalLearning Theory (pp. 416\u2013426). Springer-Verlag.\nSch\u00f6lkopf,B.,Burges,C.,&Vapnik,V.(1996).Incorporatinginvariancesinsupportvector\nlearning machines. InternationalConferenceonArtificialNeuralNetworks (pp. 47\u201352).\nSch\u00f6lkopf, B., & Smola, A. J. (2002). Learning with Kernels: Support Vector Machines,\nRegularization,Optimization,and Beyond . MIT Press.\nSennrich, R., Haddow, B., & Birch, A. (2015). Neural machine translation of rare words\nwith subword units. ArXiv:1508.07909 .\nSergeev, A., & Del Balso, M. (2018). Horovod: fast and easy distributed deep learning in\nTensorFlow. ArXiv:1802.05799 .\nShannon, C. E. (1948). A mathematical theory of communication. TheBellSystemTechni-\ncalJournal ,27(3), 379\u2013423.", "mimetype": "text/plain", "start_char_idx": 2237309, "end_char_idx": 2240270, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "de24e18f-e50b-4bb2-a9d8-20657317d580": {"__data__": {"id_": "de24e18f-e50b-4bb2-a9d8-20657317d580", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ca9acbb1-5468-406e-8a33-7319dde01d6b", "node_type": "1", "metadata": {}, "hash": "f0a1886f90f9b81dde8e545b4856e2c15861c6aadd4e21aab8111f617b778d93", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1449fa66-f198-4207-8d0e-6bd32c08bffb", "node_type": "1", "metadata": {}, "hash": "ac62f6f0f46d7fc3e20fc3d347012d94b2c92dce754edfc8bdde55d122e6fa66", "class_name": "RelatedNodeInfo"}}, "text": "InternationalConferenceonArtificialNeuralNetworks (pp. 47\u201352).\nSch\u00f6lkopf, B., & Smola, A. J. (2002). Learning with Kernels: Support Vector Machines,\nRegularization,Optimization,and Beyond . MIT Press.\nSennrich, R., Haddow, B., & Birch, A. (2015). Neural machine translation of rare words\nwith subword units. ArXiv:1508.07909 .\nSergeev, A., & Del Balso, M. (2018). Horovod: fast and easy distributed deep learning in\nTensorFlow. ArXiv:1802.05799 .\nShannon, C. E. (1948). A mathematical theory of communication. TheBellSystemTechni-\ncalJournal ,27(3), 379\u2013423.\nShao, H., Yao, S., Sun, D., Zhang, A., Liu, S., Liu, D., \u2026 Abdelzaher, T. (2020). Con-\ntrolVAE: controllable variational autoencoder. Proceedings of the 37th International\nConferenceon MachineLearning .\nShaw, P., Uszkoreit, J., & Vaswani, A. (2018). Self-attention with relative position repre-\nsentations. ArXiv:1803.02155 .\nShoeybi, M., Patwary, M., Puri, R., LeGresley, P., Casper, J., & Catanzaro, B. (2019).\nMegatron-LM: training multi-billion parameter language models using model paral-\nlelism.ArXiv:1909.08053 .\nSilver,D.,Huang,A.,Maddison,C.J.,Guez,A.,Sifre,L.,VanDenDriessche,G.,\u2026etal.\n(2016). Mastering the game of Go with deep neural networks and tree search. Nature,\n529(7587), 484.\nSilverman, B. W. (1986). Density Estimation for Statistical and Data Analysis . Chapman\nand Hall.\nSimard, P. Y., LeCun, Y. A., Denker, J. S., & Victorri, B. (1998). Transformation invari-\nanceinpatternrecognition\u2013tangentdistanceandtangentpropagation. NeuralNetworks:\nTricksof theTrade (pp. 239\u2013274). Springer.\nSimonyan, K., & Zisserman, A. (2014). Very deep convolutional networks for large-scale\nimage recognition. ArXiv:1409.1556 .\nSindhwani, V., Sainath, T. N., & Kumar, S. (2015). Structured transforms for small-\nfootprint deep learning. ArXiv:1510.01722 .\nSivic,J.,&Zisserman,A.(2003).VideoGoogle: atextretrievalapproachtoobjectmatch-\ning in videos. Proceedings of the IEEE International Conference on Computer Vision\n(pp. 1470\u20131470).\n1106 REFERENCES\nSmith, S., Patwary, M., Norick, B., LeGresley, P., Rajbhandari, S., Casper, J., \u2026 et al.\n(2022). Using DeepSpeed and Megatron to train Megatron-Turing NLG 530B, a large-\nscale generative language model. ArXiv:2201.11990 .\nSmola, A., & Narayanamurthy, S. (2010). An architecture for parallel topic models. Pro-\nceedingsof theVLDB Endowment ,3(1-2), 703\u2013710.\nSnoek,J.,Larochelle,H.,&Adams,R.(2012).PracticalBayesianoptimizationofmachine\nlearning algorithms. AdvancesinNeuralInformationProcessingSystems25 (pp. 2951\u2013\n2959).\nSohl-Dickstein, J., Weiss, E., Maheswaranathan, N., & Ganguli, S. (2015). Deep unsu-\npervised learning using nonequilibrium thermodynamics. International Conference on\nMachineLearning (pp. 2256\u20132265).\nSong, Y., & Ermon, S. (2019). Generative modeling by estimating gradients of the data\ndistribution. Advancesin NeuralInformation ProcessingSystems ,32.\nSong, Y., Sohl-Dickstein, J., Kingma, D. P., Kumar, A., Ermon, S., & Poole, B. (2021).", "mimetype": "text/plain", "start_char_idx": 2239712, "end_char_idx": 2242684, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1449fa66-f198-4207-8d0e-6bd32c08bffb": {"__data__": {"id_": "1449fa66-f198-4207-8d0e-6bd32c08bffb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "de24e18f-e50b-4bb2-a9d8-20657317d580", "node_type": "1", "metadata": {}, "hash": "0de94cbe8e63fd983a6b0cdf846e9e40acc35a316040f33f6272b50cd4b3b173", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fad80e03-96f6-44e9-9ec4-77f3f51e5ada", "node_type": "1", "metadata": {}, "hash": "6e0e697f64c572af4e9bcacd9845effa86e5d24a50ff436bff8d841e3c66cb2c", "class_name": "RelatedNodeInfo"}}, "text": "Snoek,J.,Larochelle,H.,&Adams,R.(2012).PracticalBayesianoptimizationofmachine\nlearning algorithms. AdvancesinNeuralInformationProcessingSystems25 (pp. 2951\u2013\n2959).\nSohl-Dickstein, J., Weiss, E., Maheswaranathan, N., & Ganguli, S. (2015). Deep unsu-\npervised learning using nonequilibrium thermodynamics. International Conference on\nMachineLearning (pp. 2256\u20132265).\nSong, Y., & Ermon, S. (2019). Generative modeling by estimating gradients of the data\ndistribution. Advancesin NeuralInformation ProcessingSystems ,32.\nSong, Y., Sohl-Dickstein, J., Kingma, D. P., Kumar, A., Ermon, S., & Poole, B. (2021).\nScore-basedgenerativemodelingthroughstochasticdifferentialequations. International\nConferenceon Learning Representations .\nSpeelpenning, B. (1980). Compiling fast partial derivatives of functions given by algo-\nrithms(Doctoral dissertation). University of Illinois at Urbana-Champaign.\nSrivastava, A., Rastogi, A., Rao, A., Shoeb, A. A. M., Abid, A., Fisch, A., \u2026 et al. (2022).\nBeyond the imitation game: quantifying and extrapolating the capabilities of language\nmodels.ArXiv:2206.04615 .\nSrivastava, N., Hinton, G., Krizhevsky, A., Sutskever, I., & Salakhutdinov, R. (2014).\nDropout: a simple way to prevent neural networks from overfitting. JournalofMachine\nLearning Research ,15(1), 1929\u20131958.\nSrivastava, R. K., Greff, K., & Schmidhuber, J. (2015). Highway networks.\nArXiv:1505.00387 .\nStrang, G. (1993). IntroductiontoLinear Algebra . Wellesley\u2013Cambridge Press.\nSu, X., & Khoshgoftaar, T. M. (2009). A survey of collaborative filtering techniques. Ad-\nvancesin Artificial Intelligence ,2009.\nSukhbaatar, S., Weston, J., & Fergus, R. (2015). End-to-end memory networks. Advances\ninNeuralInformation ProcessingSystems (pp. 2440\u20132448).\nSutskever, I., Martens, J., Dahl, G., & Hinton, G. (2013). On the importance of initializa-\ntion and momentum in deep learning. International Conference on Machine Learning\n(pp. 1139\u20131147).\nSutskever, I., Vinyals, O., & Le, Q. V. (2014). Sequence to sequence learning with neural\nnetworks. Advancesin NeuralInformation ProcessingSystems (pp. 3104\u20133112).\nSzegedy, C., Ioffe, S., Vanhoucke, V., & Alemi, A. A. (2017). Inception-v4, Inception-\nResNet and the impact of residual connections on learning. 31st AAAI Conference on\nArtificial Intelligence .\nSzegedy, C., Liu, W., Jia, Y., Sermanet, P., Reed, S., Anguelov, D., \u2026 Rabinovich, A.\n(2015). Going deeper with convolutions. Proceedings of the IEEE Conference on Com-\nputerVisionand Pattern Recognition (pp. 1\u20139).\nSzegedy,C.,Vanhoucke,V.,Ioffe,S.,Shlens,J.,&Wojna,Z.(2016).RethinkingtheIncep-\ntionarchitectureforcomputervision. ProceedingsoftheIEEEConferenceonComputer\nVisionand Pattern Recognition (pp. 2818\u20132826).\n1107 REFERENCES\nTallec, C., & Ollivier, Y. (2017). Unbiasing truncated backpropagation through time.\nArXiv:1705.08209 .\nTan, M., & Le, Q. (2019). EfficientNet: rethinking model scaling for convolutional neural\nnetworks. International Conferenceon MachineLearning (pp. 6105\u20136114).\nTaskar, B., Guestrin, C., & Koller, D. (2004). Max-margin Markov networks. Advances in\nNeuralInformation ProcessingSystems ,16, 25.", "mimetype": "text/plain", "start_char_idx": 2242081, "end_char_idx": 2245203, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fad80e03-96f6-44e9-9ec4-77f3f51e5ada": {"__data__": {"id_": "fad80e03-96f6-44e9-9ec4-77f3f51e5ada", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1449fa66-f198-4207-8d0e-6bd32c08bffb", "node_type": "1", "metadata": {}, "hash": "ac62f6f0f46d7fc3e20fc3d347012d94b2c92dce754edfc8bdde55d122e6fa66", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9831867d-c656-42dc-b517-c50d84486ea8", "node_type": "1", "metadata": {}, "hash": "4c7551a9f5a9b00dbbfcd4e7b7bbb9eec4e63ed2cef02bd1607b9246b1e03853", "class_name": "RelatedNodeInfo"}}, "text": "(2016).RethinkingtheIncep-\ntionarchitectureforcomputervision. ProceedingsoftheIEEEConferenceonComputer\nVisionand Pattern Recognition (pp. 2818\u20132826).\n1107 REFERENCES\nTallec, C., & Ollivier, Y. (2017). Unbiasing truncated backpropagation through time.\nArXiv:1705.08209 .\nTan, M., & Le, Q. (2019). EfficientNet: rethinking model scaling for convolutional neural\nnetworks. International Conferenceon MachineLearning (pp. 6105\u20136114).\nTaskar, B., Guestrin, C., & Koller, D. (2004). Max-margin Markov networks. Advances in\nNeuralInformation ProcessingSystems ,16, 25.\nTay, Y., Dehghani, M., Bahri, D., & Metzler, D. (2020). Efficient transformers: a survey.\nArXiv:2009.06732 .\nTaylor, R., Kardas, M., Cucurull, G., Scialom, T., Hartshorn, A., Saravia, E., \u2026Stojnic, R.\n(2022). Galactica: a large language model for science. ArXiv:2211.09085 .\nTeye, M., Azizpour, H., & Smith, K. (2018). Bayesian uncertainty estimation for batch\nnormalized deep networks. ArXiv:1802.06455 .\nThomee, B., Shamma, D. A., Friedland, G., Elizalde, B., Ni, K., Poland, D., \u2026 Li, L.-J.\n(2016). Yfcc100m: the new data in multimedia research. Communications of the ACM ,\n59(2), 64\u201373.\nTieleman, T., & Hinton, G. (2012). Divide the gradient by a running average of its recent\nmagnitude. COURSERA:NeuralNetworksforMachineLearning,Lecture6.5-rmsprop .\nTikhonov, A. N., & Arsenin, V. Y. (1977). SolutionsofIll-PosedProblems . W.H. Winston.\nTolstikhin, I. O., Houlsby, N., Kolesnikov, A., Beyer, L., Zhai, X., Unterthiner, T., \u2026 et al.\n(2021).MLP-mixer: anall-MLParchitectureforvision. AdvancesinNeuralInformation\nProcessingSystems ,34.\nTorralba, A., Fergus, R., & Freeman, W. T. (2008). 80 million tiny images: a large data set\nfor nonparametric object and scene recognition. IEEE Transactions on Pattern Analysis\nandMachineIntelligence ,30(11), 1958\u20131970.\nTouvron, H., Cord, M., Douze, M., Massa, F., Sablayrolles, A., & J\u00e9gou, H. (2021). Train-\ningdata-efficientimagetransformers&distillationthroughattention. InternationalCon-\nferenceon MachineLearning (pp. 10347\u201310357).\nTouvron, H., Lavril, T., Izacard, G., Martinet, X., Lachaux, M.-A., Lacroix, T., \u2026 et al.\n(2023a). LLaMA: open and efficient foundation language models. ArXiv:2302.13971 .\nTouvron, H., Martin, L., Stone, K., Albert, P., Almahairi, A., Babaei, Y., \u2026 et al. (2023b).\nLLaMA 2: open foundation and fine-tuned chat models. ArXiv:2307.09288 .\nTsoumakas, G., &Katakis, I.(2007).Multi-labelclassification: anoverview. International\nJournal of Data Warehousingand Mining ,3(3), 1\u201313.\nTuring, A. (1950). Computing machinery and intelligence. Mind,59(236), 433.\nUijlings, J. R., Van De Sande, K. E., Gevers, T., & Smeulders, A. W. (2013). Selective\nsearch for object recognition. International Journal of Computer Vision ,104(2), 154\u2013\n171.\nVapnik, V. (1995). The Natureof StatisticalLearning Theory . New York: Springer.\nVapnik, V.", "mimetype": "text/plain", "start_char_idx": 2244642, "end_char_idx": 2247501, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9831867d-c656-42dc-b517-c50d84486ea8": {"__data__": {"id_": "9831867d-c656-42dc-b517-c50d84486ea8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fad80e03-96f6-44e9-9ec4-77f3f51e5ada", "node_type": "1", "metadata": {}, "hash": "6e0e697f64c572af4e9bcacd9845effa86e5d24a50ff436bff8d841e3c66cb2c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "95859364-c274-46e4-a404-23805cab18e3", "node_type": "1", "metadata": {}, "hash": "d5e43a8a8b6caafbdb57cd571dbe15669cdbc718b1539f1b91f2f3b74a867789", "class_name": "RelatedNodeInfo"}}, "text": "(2023b).\nLLaMA 2: open foundation and fine-tuned chat models. ArXiv:2307.09288 .\nTsoumakas, G., &Katakis, I.(2007).Multi-labelclassification: anoverview. International\nJournal of Data Warehousingand Mining ,3(3), 1\u201313.\nTuring, A. (1950). Computing machinery and intelligence. Mind,59(236), 433.\nUijlings, J. R., Van De Sande, K. E., Gevers, T., & Smeulders, A. W. (2013). Selective\nsearch for object recognition. International Journal of Computer Vision ,104(2), 154\u2013\n171.\nVapnik, V. (1995). The Natureof StatisticalLearning Theory . New York: Springer.\nVapnik, V. (1998). StatisticalLearning Theory . New York: John Wiley and Sons.\nVapnik, V., & Chervonenkis, A. (1964). A note on one class of perceptrons. Automation\nandRemoteControl ,25.\nVapnik, V., & Chervonenkis, A. (1968). Uniform convergence of frequencies of occurence\nof events to their probabilities. Dokl. Akad. NaukSSSR ,181, 915-918.\nVapnik,V.,&Chervonenkis,A.(1971).Ontheuniformconvergenceofrelativefrequencies\nof events to their probabilities. Theory Probab.Appl. ,16(2), 264-281.\n1108 REFERENCES\nVapnik, V., & Chervonenkis, A. (1981). The necessary and sufficient conditions for the\nuniform convergence of averages to their expected values. Teoriya Veroyatnostei i Ee\nPrimeneniya ,26(3), 543-564.\nVapnik,V.,&Chervonenkis,A.(1991).Thenecessaryandsufficientconditionsforconsis-\ntency in the empirical risk minimization method. Pattern Recognition and Image Anal-\nysis,1(3), 283-305.\nVapnik, V. N., & Chervonenkis, A. Y. (1974). Ordered risk minimization. Automationand\nRemoteControl ,35, 1226\u20131235, 1403\u20131412.\nVapnik, V. (1992). Principles of risk minimization for learning theory. AdvancesinNeural\nInformation ProcessingSystems (pp. 831\u2013838).\nVapnik, V., Levin, E., & Le Cun, Y. (1994). Measuring the VC-dimension of a learning\nmachine. NeuralComputation ,6(5), 851\u2013876.\nVaswani,A.,Shazeer,N.,Parmar,N.,Uszkoreit,J.,Jones,L.,Gomez,A.N.,\u2026Polosukhin,\nI. (2017). Attention is all you need. AdvancesinNeuralInformationProcessingSystems\n(pp. 5998\u20136008).\nWahba, G. (1990). Spline Models forObservationalData . SIAM.\nWaibel, A., Hanazawa, T., Hinton, G., Shikano, K., & Lang, K. J. (1989). Phoneme recog-\nnition using time-delay neural networks. IEEE Transactions on Acoustics, Speech, and\nSignalProcessing ,37(3), 328\u2013339.\nWang, H., Zhang, A., Zheng, S., Shi, X., Li, M., & Wang, Z. (2022). Removing batch nor-\nmalization boosts adversarial training. International Conference on Machine Learning\n(pp. 23433\u201323445).\nWang, L., Li, M., Liberty, E., & Smola, A. J. (2018). Optimal message scheduling for\naggregation. Networks ,2(3), 2\u20133.\nWang,Q.,Li,B.,Xiao,T.,Zhu,J.,Li,C.,Wong,D.F.,&Chao,L.S.(2019).Learningdeep\ntransformer models for machine translation. Proceedingsofthe57thAnnualMeetingof\ntheAssociation forComputational Linguistics (pp. 1810\u20131822).\nWang, X., Wei, J., Schuurmans, D., Le, Q., Chi, E., & Zhou, D. (2023).", "mimetype": "text/plain", "start_char_idx": 2246937, "end_char_idx": 2249817, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "95859364-c274-46e4-a404-23805cab18e3": {"__data__": {"id_": "95859364-c274-46e4-a404-23805cab18e3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9831867d-c656-42dc-b517-c50d84486ea8", "node_type": "1", "metadata": {}, "hash": "4c7551a9f5a9b00dbbfcd4e7b7bbb9eec4e63ed2cef02bd1607b9246b1e03853", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "98c6ff7e-a235-431a-92c5-1b0b1b6c5c15", "node_type": "1", "metadata": {}, "hash": "f4b72f6e555da60086cc7ef791b973778a1f6c2579d884280d8e6e2f64a33bb6", "class_name": "RelatedNodeInfo"}}, "text": "(2022). Removing batch nor-\nmalization boosts adversarial training. International Conference on Machine Learning\n(pp. 23433\u201323445).\nWang, L., Li, M., Liberty, E., & Smola, A. J. (2018). Optimal message scheduling for\naggregation. Networks ,2(3), 2\u20133.\nWang,Q.,Li,B.,Xiao,T.,Zhu,J.,Li,C.,Wong,D.F.,&Chao,L.S.(2019).Learningdeep\ntransformer models for machine translation. Proceedingsofthe57thAnnualMeetingof\ntheAssociation forComputational Linguistics (pp. 1810\u20131822).\nWang, X., Wei, J., Schuurmans, D., Le, Q., Chi, E., & Zhou, D. (2023). Self-consistency\nimproves chain of thought reasoning in language models. International Conference on\nLearning Representations .\nWang, Y., Davidson, A., Pan, Y., Wu, Y., Riffel, A., & Owens, J. D. (2016). Gunrock: a\nhigh-performancegraphprocessinglibraryontheGPU. ACMSIGPLANNotices (p.11).\nWarstadt,A.,Singh,A.,&Bowman,S.R.(2019).Neuralnetworkacceptabilityjudgments.\nTransactionsof theAssociation forComputational Linguistics ,7, 625\u2013641.\nWasserman,L.(2013). AllofStatistics: AConciseCourseinStatisticalInference .Springer.\nWatkins, C. J., & Dayan, P. (1992). Q-learning. MachineLearning ,8(3\u20134), 279\u2013292.\nWatson, G. S. (1964). Smooth regression analysis. Sankhy\u0101: TheIndianJournalofStatis-\ntics,Series A , pp. 359\u2013372.\nWei, J., Bosma, M., Zhao, V. Y., Guu, K., Yu, A. W., Lester, B., \u2026 Le, Q. V. (2021).\nFinetuned language models are zero-shot learners. ArXiv:2109.01652 .\nWei, J., Tay, Y., Bommasani, R., Raffel, C., Zoph, B., Borgeaud, S., \u2026 et al. (2022). Emer-\ngent abilities of large language models. ArXiv:2206.07682 .\nWei, J., Wang, X., Schuurmans, D., Bosma, M., Chi, E., Le, Q., & Zhou, D. (2022). Chain\nof thought prompting elicits reasoning in large language models. ArXiv:2201.11903 .\n1109 REFERENCES\nWelling, M., & Teh, Y. W. (2011). Bayesian learning via stochastic gradient Langevin dy-\nnamics.Proceedingsofthe28thInternationalConferenceonMachineLearning(ICML-\n11)(pp. 681\u2013688).\nWengert,R.E.(1964).Asimpleautomaticderivativeevaluationprogram. Communications\noftheACM ,7(8), 463\u2013464.\nWerbos, P. J. (1990). Backpropagation through time: what it does and how to do it. Pro-\nceedingsof theIEEE ,78(10), 1550\u20131560.\nWigner, E. P. (1958). On the distribution of the roots of certain symmetric matrices. Ann.\nMath.(pp. 325\u2013327).\nWilson,A.G.,&Izmailov,P.(2020).Bayesiandeeplearningandaprobabilisticperspective\nof generalization. Advances in Neural Information ProcessingSystems ,33, 4697\u20134708.\nWistuba, M., Rawat, A., & Pedapati, T. (2019). A survey on neural architecture search.\nArXiv:1905.01392[cs.LG] .\nWistuba, M., Schilling, N., & Schmidt-Thieme, L. (2018). Scalable Gaussian process-\nbased transfer surrogates for hyperparameter optimization. MachineLearning ,108, 43\u2013\n78.\nWolpert, D. H., & Macready, W. G. (1995). No free lunch theorems for search . Technical\nReport SFI-TR-95-02-010, Santa Fe Institute.\nWood, F., Gasthaus, J., Archambeau, C., James, L., & Teh, Y. W. (2011).", "mimetype": "text/plain", "start_char_idx": 2249280, "end_char_idx": 2252208, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "98c6ff7e-a235-431a-92c5-1b0b1b6c5c15": {"__data__": {"id_": "98c6ff7e-a235-431a-92c5-1b0b1b6c5c15", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "95859364-c274-46e4-a404-23805cab18e3", "node_type": "1", "metadata": {}, "hash": "d5e43a8a8b6caafbdb57cd571dbe15669cdbc718b1539f1b91f2f3b74a867789", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ec1d6025-4278-4b50-968c-4845047e89ef", "node_type": "1", "metadata": {}, "hash": "06baf68175f2b106a46c3f010b4c560ac09112167e12d5e01678e379adc8d2ff", "class_name": "RelatedNodeInfo"}}, "text": "Advances in Neural Information ProcessingSystems ,33, 4697\u20134708.\nWistuba, M., Rawat, A., & Pedapati, T. (2019). A survey on neural architecture search.\nArXiv:1905.01392[cs.LG] .\nWistuba, M., Schilling, N., & Schmidt-Thieme, L. (2018). Scalable Gaussian process-\nbased transfer surrogates for hyperparameter optimization. MachineLearning ,108, 43\u2013\n78.\nWolpert, D. H., & Macready, W. G. (1995). No free lunch theorems for search . Technical\nReport SFI-TR-95-02-010, Santa Fe Institute.\nWood, F., Gasthaus, J., Archambeau, C., James, L., & Teh, Y. W. (2011). The sequence\nmemoizer. Communicationsof theACM ,54(2), 91\u201398.\nWu, B., Wan, A., Yue, X., Jin, P., Zhao, S., Golmant, N., \u2026 Keutzer, K. (2018). Shift: a\nzero flop, zero parameter alternative to spatial convolutions. Proceedings of the IEEE\nConferenceon ComputerVisionand Pattern Recognition (pp. 9127\u20139135).\nWu, Y., Schuster, M., Chen, Z., Le, Q. V., Norouzi, M., Macherey, W., \u2026 et al. (2016).\nGoogle\u2019s neural machine translation system: bridging the gap between human and ma-\nchine translation. ArXiv:1609.08144 .\nXiao, H., Rasul, K., & Vollgraf, R. (2017). Fashion-MNIST: a novel image dataset for\nbenchmarking machine learning algorithms. ArXiv:1708.07747 .\nXiao,L.,Bahri,Y.,Sohl-Dickstein,J.,Schoenholz,S.,&Pennington,J.(2018).Dynamical\nisometry and a mean field theory of CNNs: how to train 10,000-layer vanilla convolu-\ntionalneuralnetworks. InternationalConferenceonMachineLearning (pp.5393\u20135402).\nXie, S., Girshick, R., Doll\u00e1r, P., Tu, Z., & He, K. (2017). Aggregated residual transforma-\ntionsfordeepneuralnetworks. ProceedingsoftheIEEEConferenceonComputerVision\nandPattern Recognition (pp. 1492\u20131500).\nXiong,R.,Yang,Y.,He,D.,Zheng,K.,Zheng,S.,Xing,C.,\u2026Liu,T.(2020).Onlayernor-\nmalization in the transformer architecture. InternationalConferenceonMachineLearn-\ning(pp. 10524\u201310533).\nXiong, W., Wu, L., Alleva, F., Droppo, J., Huang, X., & Stolcke, A. (2018). The Microsoft\n2017conversationalspeechrecognitionsystem. 2018IEEEInternationalConferenceon\nAcoustics,Speechand Signal Processing(ICASSP) (pp. 5934\u20135938).\nYamaguchi, K., Sakamoto, K., Akabane, T., & Fujimoto, Y. (1990). A neural network\nfor speaker-independent isolated word recognition. First International Conference on\nSpokenLanguageProcessing .\nYang, Z., Hu, Z., Deng, Y., Dyer, C., & Smola, A. (2016). Neural machine translation with\nrecurrent attention modeling. ArXiv:1607.05108 .\n1110 REFERENCES\nYang, Z., Moczulski, M., Denil, M., De Freitas, N., Smola, A., Song, L., & Wang, Z.\n(2015).Deepfriedconvnets. ProceedingsoftheIEEEInternationalConferenceonCom-\nputerVision (pp. 1476\u20131483).\nYe,M.,Yin,P.,Lee,W.-C.,&Lee,D.-L.(2011).Exploitinggeographicalinfluenceforcol-\nlaborativepoint-of-interestrecommendation. Proceedingsofthe34thInternationalACM\nSIGIR Conference on Research and Development in Information Retrieval (pp. 325\u2013\n334).\nYou,Y.,Gitman,I.,&Ginsburg,B.(2017).Largebatchtrainingofconvolutionalnetworks.\nArXiv:1708.03888 .", "mimetype": "text/plain", "start_char_idx": 2251653, "end_char_idx": 2254610, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ec1d6025-4278-4b50-968c-4845047e89ef": {"__data__": {"id_": "ec1d6025-4278-4b50-968c-4845047e89ef", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "98c6ff7e-a235-431a-92c5-1b0b1b6c5c15", "node_type": "1", "metadata": {}, "hash": "f4b72f6e555da60086cc7ef791b973778a1f6c2579d884280d8e6e2f64a33bb6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ec66e3e9-cc89-4462-b020-bbda40bda188", "node_type": "1", "metadata": {}, "hash": "c7d100823e1d34216b73b4674099bcddee4364804704145fe16da92e69614e84", "class_name": "RelatedNodeInfo"}}, "text": "ArXiv:1607.05108 .\n1110 REFERENCES\nYang, Z., Moczulski, M., Denil, M., De Freitas, N., Smola, A., Song, L., & Wang, Z.\n(2015).Deepfriedconvnets. ProceedingsoftheIEEEInternationalConferenceonCom-\nputerVision (pp. 1476\u20131483).\nYe,M.,Yin,P.,Lee,W.-C.,&Lee,D.-L.(2011).Exploitinggeographicalinfluenceforcol-\nlaborativepoint-of-interestrecommendation. Proceedingsofthe34thInternationalACM\nSIGIR Conference on Research and Development in Information Retrieval (pp. 325\u2013\n334).\nYou,Y.,Gitman,I.,&Ginsburg,B.(2017).Largebatchtrainingofconvolutionalnetworks.\nArXiv:1708.03888 .\nYu, J., Xu, Y., Koh, J. Y., Luong, T., Baid, G., Wang, Z., \u2026 Wu, Y. (2022). Scaling au-\ntoregressive models for content-rich text-to-image generation. ArXiv:2206.10789 .\nZaheer, M., Reddi, S., Sachan, D., Kale, S., & Kumar, S. (2018). Adaptive methods for\nnonconvexoptimization. AdvancesinNeuralInformationProcessingSystems (pp.9793\u2013\n9803).\nZeiler, M. D. (2012). ADADELTA: an adaptive learning rate method. ArXiv:1212.5701 .\nZeiler, M. D., & Fergus, R. (2013). Stochastic pooling for regularization of deep convolu-\ntional neural networks. ArXiv:1301.3557 .\nZhang, A., Tay, Y., Zhang, S., Chan, A., Luu, A. T., Hui, S. C., & Fu, J. (2021). Beyond\nfully-connected layers with quaternions: parameterization of hypercomplex multiplica-\ntions with 1/n parameters. International Conferenceon Learning Representations .\nZhang, C., Bengio, S., Hardt, M., Recht, B., & Vinyals, O. (2021). Understanding deep\nlearning (still) requires rethinking generalization. Communications of the ACM ,64(3),\n107\u2013115.\nZhang, S., Yao, L., Sun, A., & Tay, Y. (2019). Deep learning based recommender system:\na survey and new perspectives. ACMComputing Surveys ,52(1), 5.\nZhang, S., Roller, S., Goyal, N., Artetxe, M., Chen, M., Chen, S., \u2026 et al. (2022). OPT:\nopen pre-trained transformer language models. ArXiv:2205.01068 .\nZhang, W., Tanida, J., Itoh, K., & Ichioka, Y. (1988). Shift-invariant pattern recognition\nneural network and its optical architecture. Proceedings of Annual Conference of the\nJapanSocietyof Applied Physics .\nZhang, Y., Sun, P., Jiang, Y., Yu, D., Yuan, Z., Luo, P., \u2026 Wang, X. (2021). ByteTrack:\nmulti-object tracking by associating every detection box. ArXiv:2110.06864 .\nZhang, Z., Zhang, A., Li, M., & Smola, A. (2023). Automatic chain of thought prompting\nin large language models. International Conference on Learning Representations .\nZhang, Z., Zhang, A., Li, M., Zhao, H., Karypis, G., & Smola, A. (2023). Multimodal\nchain-of-thought reasoning in language models. ArXiv:2302.00923 .\nZhao, Z.-Q., Zheng, P., Xu, S.-t., & Wu, X. (2019). Object detection with deep learning:\na review. IEEE Transactions on Neural Networks and Learning Systems ,30(11), 3212\u2013\n3232.\nZhou, D., Sch\u00e4rli, N., Hou, L., Wei, J., Scales, N., Wang, X., \u2026 Chi, E. (2023). Least-\nto-most prompting enables complex reasoning in large language models. International\nConferenceon Learning Representations .\nZhu, J.-Y., Park, T., Isola, P., & Efros, A. A. (2017).", "mimetype": "text/plain", "start_char_idx": 2254044, "end_char_idx": 2257048, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ec66e3e9-cc89-4462-b020-bbda40bda188": {"__data__": {"id_": "ec66e3e9-cc89-4462-b020-bbda40bda188", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "82e8e78e-1466-4020-b2d4-4d7a0239afd5", "node_type": "4", "metadata": {}, "hash": "910da6e75c67e6b9a949f4b399df5292140e40396d11f697fb2e46c05efce40b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ec1d6025-4278-4b50-968c-4845047e89ef", "node_type": "1", "metadata": {}, "hash": "06baf68175f2b106a46c3f010b4c560ac09112167e12d5e01678e379adc8d2ff", "class_name": "RelatedNodeInfo"}}, "text": "(2023). Multimodal\nchain-of-thought reasoning in language models. ArXiv:2302.00923 .\nZhao, Z.-Q., Zheng, P., Xu, S.-t., & Wu, X. (2019). Object detection with deep learning:\na review. IEEE Transactions on Neural Networks and Learning Systems ,30(11), 3212\u2013\n3232.\nZhou, D., Sch\u00e4rli, N., Hou, L., Wei, J., Scales, N., Wang, X., \u2026 Chi, E. (2023). Least-\nto-most prompting enables complex reasoning in large language models. International\nConferenceon Learning Representations .\nZhu, J.-Y., Park, T., Isola, P., & Efros, A. A. (2017). Unpaired image-to-image transla-\ntion using cycle-consistent adversarial networks. ProceedingsoftheIEEEInternational\nConferenceon ComputerVision (pp. 2223\u20132232).\n1111 REFERENCES\nZhu, Y., Kiros, R., Zemel, R., Salakhutdinov, R., Urtasun, R., Torralba, A., & Fidler, S.\n(2015). Aligning books and movies: towards story-like visual explanations by watch-\ning movies and reading books. Proceedings of the IEEE International Conference on\nComputerVision (pp. 19\u201327).\nZoph, B., & Le, Q. V. (2016). Neural architecture search with reinforcement learning.\nArXiv:1611.01578 .", "mimetype": "text/plain", "start_char_idx": 2256518, "end_char_idx": 2257615, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"82e8e78e-1466-4020-b2d4-4d7a0239afd5": {"node_ids": ["50c1b7ec-25fb-470b-a31c-4b05756df829", "4ed79338-a2a3-4f67-bc96-7e2155338c75", "c5882dac-ebd5-4da5-957f-7649a9446182", "6412964f-4a1b-42ff-995a-cdd78f115370", "6475d4dc-319f-4399-8bd3-ca51d9b603c9", "b9597f06-568e-42d1-aa55-7b2bc77ea3ba", "28d5e5ca-c507-4ef1-86d4-19b8b648404b", "aa00d208-7795-4c59-9460-061cd07cfa76", "46c78bf2-500c-429f-9bd0-ed4ceb894a89", "aa39f7c1-f5da-4dae-8033-1a5f49e94b47", "e53e8d83-27b4-458e-b6d4-7fe075f7aff8", "5df950dc-1329-403a-b7f7-13e1e8880ee4", "ff4ffe15-fb0f-44fb-a002-54a16e1a5b1f", "0b338cb1-20e5-433b-a0da-58f00e3fb91c", "fd54ecda-fa15-4467-b87f-8cafe7ea8434", "257d7b50-3303-4dcd-8b76-5c502bf9664f", "d5b9712c-1dc8-401a-85fa-e65b88f9b380", "00fb73c4-71ce-4a64-af5d-a8c10f6f2241", "a4d7efef-f070-43d5-ad09-30fdefef852e", "373a6d13-c0eb-423b-b059-336b73998d0f", "5f934c3b-5adf-4c34-bde5-8ceedee0b6e1", "f9ed79d9-1e81-4faa-bb89-5d75c5994da8", "fc246ea3-adfa-4cd0-87b9-ab0de35a9473", "041f8e3f-4237-43e5-8c1f-24e63629d5ff", "dd131950-5133-48b8-88c1-c7ce3f4ce169", "3a8acb83-750b-4acb-ad79-7aaf220d0c05", "253f1368-47e0-49e0-a656-9956fc8afd02", "da1cd37e-4718-44a8-ae01-7a57c62705f7", "8eb7fe94-1be2-4977-be3e-df3298bf41c6", "f83842ef-d454-437b-afaf-2696b2f55951", "5650e9e1-956f-42d4-a3d9-1095b397ac43", "99e849d5-d340-4d42-b89f-5f84376e0d7c", "7c2c4e2a-f042-493c-91fc-d0efbdf97db3", "71710e7d-9be5-4554-9e47-5236c50c1ef5", "ace4dc8e-23a8-427d-8a5d-706f0740563f", "45832d34-5ac9-49ed-892b-112e826b24c8", "58881db4-4581-42dc-98d8-e64fdbb22d9d", "b170fe60-9304-4479-8103-ae20816a6412", "724185fd-5d85-4139-8e1f-c15d8b64ab7f", "36708a62-8036-4f63-830e-bfddbc8fff5f", "48ab4063-7c85-420e-88ae-44771decc928", "938a69f6-cbc8-43ab-96da-9caccd7c8b67", "cebcef18-11ab-475f-b374-f0ee85ba83e2", "94a2897e-06c3-4be4-a13a-b2a8b234fd9e", "dc43f26d-c5dc-48c4-b73b-776e0c110b8d", "35066ca7-4c6f-41f4-bb48-e280725af122", "ec4fefb6-1e2b-4cf0-8874-1fee3189dceb", "f4debcd1-bd94-4084-b443-ded515ce04f3", "7fa36e60-dbdd-4379-b971-a0fded704532", "3bb0d24c-efcf-470c-adf0-1e6ce405700e", "9f2e6dee-6479-415e-aa75-334f636a70be", "3827d73a-050e-48c8-8d6d-769c4eb3d3e2", "3bc53aec-8718-4602-8867-c0da06fa9983", "3a4de07a-ccaa-45f7-aa03-418c440a33db", "f2988966-9c4c-4f36-9432-b96b682fe6f8", "ae7b1e93-c6fb-43f4-b3ba-a6c49b57a605", "124b1e89-33e5-4d81-95d0-0513f3d50fbb", "4eeaaa35-36cc-4ec0-ac2a-03018d6d7bc3", "d74c16b8-15fc-4581-8c33-2934279a3a25", "55fbb0ce-02a9-4ce1-89c2-48471a993397", "fc7a684b-0813-46f7-be9f-79faba003a3b", "e961a397-16d3-4818-8b98-1ce8a69b568d", "306550e1-7ddf-4a29-975f-3484eef50f6a", "316721c3-b326-431b-a332-9d1da418ee75", "cde99be9-3e82-46ec-9f6a-0a27bc6811af", "1b0698fe-d177-4e69-be70-ed13b8bfe470", "fa9879be-6fb3-4228-a95f-ad6b089adc3d", "7b8794e7-ecc4-4647-b9f1-c3fa2b813a45", "6922a4f6-c044-428f-9dd1-585ecabf18fd", "e79670ed-9b31-4781-b8eb-f151aa3b5930", "f46655c2-ca05-46e2-ad04-1ab74fde8d60", "1c190347-aaeb-48ad-99c3-a88551674f17", "e501b0d0-616c-48d3-87f6-fe53165a682c", "c26cff40-8464-4055-b45f-9244e5378bb2", "08a42b27-547d-43fe-9b39-3d5c810c3fa2", "23da883a-4603-46ce-b19d-cc43b4a02543", "4dfa06ed-5258-4af2-9845-6f8d123589fe", "6eb8cf36-f29a-42ad-abb9-0c3b5cda754e", "d4ebb515-bfd4-4f08-94a5-82f44de014e6", "d2e153a2-c8e3-441b-93f7-bfc9e13c8709", "13a78da8-74de-487a-9504-38a9711b41e0", "924a08d5-8997-47c3-906c-754af4429b33", "3c09aac6-94c6-4437-ad0b-de84ce020bc3", "68c1efb8-1656-4606-887a-d6c7379334f6", "f31c5c66-bb37-40b3-81b0-9843fa657cb7", "61147081-a760-4e59-918d-5c4e1c1b9cc0", "41ad2588-e366-4c0c-ba1f-0461e147a213", "a13f254e-a1c0-40b3-9b27-f5f6148ea669", "63d7b5e1-45ec-47be-aa2c-371e4271c32c", "12d94253-e077-472b-b9c3-37aa97cf3a38", "3f42be62-1814-4568-a4bc-864cd9b2dddf", "4b93aa5b-0b03-4055-ab37-196da4583e07", "62d58b0d-3c60-484d-a53a-793f9088281f", "abdcc70f-33c9-427c-8f4d-9421055320a8", "133a8355-0e86-440b-a84a-31ce094f22c1", "be94ea1d-dbd3-40b0-8921-9dbadb91824b", "c4bfdcca-0b4a-4865-8c87-fba0e37fb362", "968c65ba-7cd0-453e-875f-cafea63b76dc", "127f89c2-677e-486c-9518-de26b67e2fb9", "2feeafb8-ad81-40a1-87ea-1e24efd44817", "0b1e5549-963d-40bb-9d44-fdcf58581701", "0c85c528-bb94-4028-b1cd-16fcf24cb567", "196e93bf-5a6c-49cd-8ac5-397df9f380c2", "cec537db-a0d2-428d-a719-531d5e784101", "62803096-4e40-4a71-b06a-a0477fe04661", "811d4bc4-e353-42ee-b491-f04f65640a46", "28742bc0-8105-4e78-a6b2-1c6d6d5e5e8f", "a4651b7e-529a-4afa-ad0e-919646a806d7", "a02493ac-e77c-4847-95ce-13836be165e7", "190f683a-e61c-4d61-a127-1057b8d5f9ab", "3b0e344d-e122-4fc3-9c59-a92fd47539c9", "7c22e814-135e-47d3-9f88-74f42f2f2c47", "06bf9afa-d5f5-43e3-b4fa-b2caec574e43", "521ae863-11c5-414e-83ea-61acb4de6393", "b21228bc-4516-406a-a004-ecbc82b1dd31", "2e61a564-ff85-4386-86a0-5c5f76482752", "7850297b-a989-4039-a16e-2225725936e6", "9603abc4-b73c-47f7-97ab-ea8e6fe06ce2", "f9bbc849-6673-4f2a-877d-64eb24231f9c", "0a750766-c41a-482f-bf7f-7c0474edae91", "652d991d-170b-4da8-a6c9-8038457422e8", "10254a26-55c2-499f-a709-ec450303e992", "6d7dfe58-0728-43ba-a282-ed63a7e36735", "030d18ef-2e41-4113-abf5-5e4a1f3eb6ea", "d3742376-9ef0-43c6-8fa8-126333c1d06a", "83738921-b5f1-4c2b-8bcc-9a8562e31053", "d85e9b53-ca93-4db8-9c45-37496b153e50", "fe108d59-2465-4bea-a890-61b6ff6585b8", "7d6fbfb3-3d5b-4b06-a506-fff0aed113e7", "bc7569da-4df3-4295-8e16-c6936efa5ed8", "73bf6874-0f20-4875-accd-a3ff3ff54539", "bc78bc95-5add-48f9-ada8-d124be5d884f", "1c7c6c78-732b-44ed-b5e0-006632d5c729", "1d8f84d6-6553-40f1-9a71-5a321f0f4eab", "2ca2f478-f27b-409f-a44e-c2c7e6bde926", "dd1469cf-8d89-4c10-b5ac-fff709b77fa1", "d4cc47cb-217c-4d71-ae5e-42f74e1fe281", "7d9a124d-5c1e-48c7-8698-5f2ddc4386a8", "5b36484a-ac86-4c34-8ee1-792a3e784c5c", "91e1ea5b-a0ea-49bc-b9e7-5ff96fe451a4", "65d007b3-7b80-4d05-9983-e4ed6e9431dd", "a557c721-a73a-40a0-9599-4e5ae44f26f9", "47eb288e-8199-4459-b13e-07115c044be8", "9603a88f-476c-4920-81d6-3a884142cd88", "c01c977f-bd47-4ca6-a32a-f3eb3b608a7d", "e76e09cd-e8e0-404a-b37b-3af88b692632", "9cb8a305-a433-47c5-b154-30bf23c973c0", "1a5c4e0f-33ae-41a1-8356-d09cf4d65000", "d4473a1d-7cd1-4c8d-b261-cd482db417fa", "46041e36-7a56-47d3-ab2c-abbbf8494045", "533b1447-356b-48a6-9e37-97f14a4d57ce", "0f9f8736-85cd-43c5-8c06-04754b3973e3", "2ed174eb-26fb-4e1d-a551-23eb0479a4b7", "e52f0545-4c18-4c46-aac1-03b7a67a2325", "f2093f11-86bb-4398-a654-bebe23434c35", "3ab35daa-7256-412f-8002-02e9b91c77d8", "d6691739-074e-48f3-9292-85590786444e", "2e72b2fb-798d-4849-9166-c72eca0958aa", "34d82bf9-550f-4600-b65f-91b0e3c2f36a", "bf905f9e-d201-4976-9232-93deab333e01", "a57bbc41-33ce-4b4f-8054-4e67b9c22e1b", "216bc339-c5f9-4b5d-b18b-6fb154833903", "c9b34d9f-6621-4f1d-a83c-d2b41d78b178", "2d51534e-9765-4938-be84-43bd55158e08", "569c9fb6-0bed-49ad-a6bc-f656dc91324d", "04a44e49-a82d-43f5-bcec-484fd8b2dd9b", "f958c009-805c-42d2-addb-becbda52d561", "fc10d8df-97bd-4f0e-98d8-417aa7304325", "91ac4010-9545-4d67-ab47-6d48fe5b0da0", "e7af3b22-90e0-4e78-b84e-115132b95cdf", "7730bfa3-9986-46fa-a1dd-befa1def170e", "b8ed9649-0992-4a76-bca5-2ccfaa454ea7", "fa841011-abcf-4258-a6a0-90f3c89e2132", "1cc979c3-3c13-42e9-b015-8d38be4c5c59", "f4d39709-e689-4591-968f-5e9429df58fa", "12137bef-3990-46e8-b25f-5a7f26ab2187", "51a8835b-34e3-4736-afb3-79865b481727", "3c200dda-f51a-4e20-9fdf-20a7cdfc5a91", "4286f418-ca59-4f91-879b-ddc181bf4748", "cc220c01-464e-484b-bffe-85f301700500", "14bb583a-fd06-45c0-86ea-863a9e175427", "90bded7c-0a2e-48b5-b6d6-075dadb2e012", "7aa8b595-d077-4205-8a57-fb408a906c94", "1ecb85cf-23fb-4794-8b19-b0090b1fd607", "382ef4a6-f79f-435d-ae5a-c80858947111", "44ac21c8-1e03-4669-bdf7-816b0b3393cf", "d96ce7ce-d17d-4866-bcf8-431b7b6a6cc1", "b4f1a3e9-3c70-42af-b6a3-088863b927d1", "d4ad6ff8-e157-430a-b5fe-41ab311c782c", "6647ce3b-1e0d-4fbb-ad02-ff9d14ea1e11", "b9a48fc4-e5aa-4a64-a594-c14003264340", "04d7a591-36bb-4f6d-b509-044ce1cdc3d2", "fc776d3e-ecea-4d0c-a3d3-a96ee8dd6a19", "0b7c6787-0bc0-429d-b3cf-ccda2220549d", "b55b4cc7-426f-498a-a206-8b60cd584741", "7522c200-552d-4278-bc4e-4c6f2a57cd1d", "2d291ee0-29a1-4d16-a769-8a750eab2eca", "45f09d6a-a8c1-4e17-85f3-6c4b1a6c1eac", "7aee0d06-2203-47da-afba-028df6d37ce2", "87f81415-a5ea-4cf7-bae7-24ca4c4f5dcb", "b4c6f59b-a442-40b5-ac2c-d43005a6d1b5", "36ac5c8c-8e14-4cae-bf86-710a0218d847", "298adf03-6580-46c5-b487-d672be177bb5", "9ce42bbf-0e9b-4e4c-a33a-fd041051140c", "24f0f93c-6afd-4467-ae71-e58cae9526f2", "7dbd256a-c916-4366-8227-abb1b7f2da4d", "d426c44b-034c-4d79-9af0-23847b9b11bd", "3cf444a2-9039-4b72-86ec-ed55fa6f1676", "fd714e9f-2a9d-475f-b06a-005be7fcb008", "4a82dddf-fb11-4bd6-b022-781d59ab7ef7", "182ef506-6e97-4f72-8044-68eb2b2e2f7c", "b5aa3cc3-a817-4330-b6ce-2d3e8cdca1e2", "a070f35b-5bcb-40f1-80d3-01dc3819e51a", "d6d7be01-150c-455d-b559-f2568193ae2e", "cceff5f6-4491-4d94-a19c-32f160f07ba6", "1c074884-7cbc-4cbc-ba86-41a59e0b6b0b", "0d26815e-76c0-4860-8864-1c296ba46899", "3a033a10-4c0b-44f9-b798-fd96c01070f2", "12b81399-52e7-4549-8a65-92a2fc91d9a8", "5a9eef3e-586f-4353-a345-9c02dc25dbf9", "4b6e6cd7-a76e-4ca6-8d14-f08a68501b91", "b3d4a14b-7cb4-4b47-96df-be0f4d0d5cd6", "fed390c8-3e08-4d00-88c1-15b05dbb52a9", "45897cfe-f088-425e-b3ed-d4763fd766ed", "5e2f4c66-8ac8-4a1d-96e2-07185610c734", "09900028-e59a-4225-9d3e-636b0028bb0d", "01356ff9-3de9-4b85-a286-ea2d0cff02dc", "944d2286-9133-41f9-9b88-0d2922b66104", "64f8e839-7502-4a3d-b88d-d2aaea3e8513", "78b814a9-6089-45aa-abdc-b6e1787db1b7", "12c17f23-ca2a-4b5d-a896-8bfcef37b213", "a2303d8e-5a77-4073-9fc4-08424723d347", "7ae2bcb6-feed-484d-a118-812617939f33", "daefad5b-2b0b-45b0-b15e-ee3eb591a175", "8f818552-857e-45b5-8b95-39bf6167d197", "c4ea145d-ddf2-44a8-b129-bcf29ba6e028", "ce668fd0-8521-4d37-a084-5dc2aebc58ae", "42ed2599-f8c2-4949-8b6e-faad0d133eed", "f85b1783-0912-432c-8656-fd774eda57de", "b6c68a12-fc00-4985-ad3a-10d0077a5981", "d830fd03-a3f0-4228-a89b-5cba2c25fc4f", "7fb35b1c-69b8-4300-b8fb-e118c65cfbfc", "37fa0b59-53d7-4741-8c21-e2b8daaac836", "2c3e176c-92cf-41a7-b046-c0112f546fcb", "7937e5a7-db35-4dc5-ad90-6b8a729aa4b0", "65ec2c99-5c01-4c5f-b6fa-096d2f356a14", "0771d6b2-a553-471e-a058-0f9ad4e469b1", "ce89d424-a04b-4f9b-b9aa-4276768e844b", "0c069235-9fae-4900-bdef-87327737ab9e", "a21095e3-c318-46b5-8081-2cec8514ebcc", "b3defebc-c3f9-49a0-9978-7566398756b9", "ede0064d-4a3a-4281-b41e-a7632ba5f776", "ed0cfaef-602b-43f1-8596-3f03d96edd4f", "5d741aad-6968-4ba2-8105-8f15ccdf5529", "067a7c2d-52a2-49d2-80a3-9f3b081a64b6", "dda8ba92-a80d-41b8-b3d7-adbf79c3fd5c", "d6a201b0-d2f1-4e35-aa3d-c78a9d683b49", "f4e32fb4-2876-4510-8630-08136a9554c1", "9cd6319e-f239-4045-8650-2ffb30c28565", "ae457299-c48f-4275-a94f-79b808571acb", "df9e68bd-2ecf-49a5-81db-e6c7260409c2", "b3c0c935-51bf-46d3-9c70-fae814ab7935", "8a1180e1-2815-4bb4-bea9-7ddfe04ca59a", "fad39a75-456c-43f7-853f-40c8e02e00e1", "92d388c1-f890-4a92-b556-a1e32286b117", "ce4398f7-c886-4b34-8e57-5905f99a7ea7", "cf754a1e-5838-470a-a19c-2c106150bb63", "0cb2f343-92c1-47c4-89ce-c3fc954a3d28", "fe4d0878-a2b9-4704-9fcb-ac7c0be822f3", "f1bf788f-6dd6-4694-b0bb-76bd0e083baa", "d4dd3629-17d8-4979-b27a-2b785e9d9e00", "0306ffb8-89c6-4daf-b391-ef44c918266a", "60dd11e1-4437-485a-a5f2-edce7893ad77", "735a507b-9a5a-4b49-80fa-083c601d9138", "7a118f90-381c-46c5-8091-7726c0a36476", "9bbce4d6-9059-4ac1-a38f-f256bb7688f7", "5c600742-599f-4c38-ae5d-4d8e35e7172b", "cc2c15db-3c3f-48a3-acda-58f8a61f09b3", "10e50c27-ec8f-4f96-a235-873d5dc6890e", "6b54c715-51ff-4f60-baa0-c5499d80e177", "5dbccf7b-5ce5-4308-ad0f-bf57b02f8664", "60d8a5ea-871d-425c-ba22-8f6335886d9d", "13f2ba21-ea4d-4828-9b4c-8c21829ac607", "55a581d2-aa2e-4879-82ef-31a2734ef44b", "da26f561-4f90-438d-889f-18e100ce7cdc", "946da3ae-095a-4376-aa05-d80f5eeab86a", "e46db9a1-daf2-427b-84e3-4e700078319f", "571ac82d-4426-4296-905f-a07eb3ed9d62", "311a4f84-216d-410f-90ba-5b70baeb799e", "b80d32b0-f760-439b-a708-4a8cbd492117", "97e535ca-abe4-45ee-8c50-37537064d747", "7c23e5b6-6f9d-4e53-a34e-845dfefa4ebf", "55b3bece-979b-473a-bb1c-8e98d34e75d1", "b7545fc3-3e76-48f1-84b3-64aa28f53585", "128677bd-f083-4b1f-b67f-8ccd7cb6b47f", "d0c39b82-8fc8-4067-96bd-c346e07c792d", "e680a6ac-ac0c-4d92-8183-62fd3ebb181a", "e4628853-0607-4cc2-a7b6-d8d06d02edcb", "97a4a886-b503-4105-9bde-4b58459e7f3c", "018d7dec-ee8f-41ab-8daf-bf002e87ff10", "9448b4c0-7343-4771-b7e4-22c02c6f0782", "e446ffeb-8f34-4495-8c3d-5c79f5d764aa", "ae06a1bc-738c-4ffa-998c-dd8b71e85f96", "3e1dd7e7-6f88-4aa5-8cc8-8d25543ff446", "1dd3ecb4-96a5-428f-8ae9-30a3b56acadc", "24fe6c16-fac4-47ba-8236-4ff611ae0481", "7a81335a-d499-4696-a820-7044d8daadc1", "8fa5f463-3d75-4b45-999a-fc7c91a750ca", "522bacc8-4e94-4665-9b88-5e902bc8bc16", "3110c164-5f55-4d67-9508-e1c9a984a3f7", "d8209767-669f-4131-9d83-bfc337549707", "e403de8b-cc6c-4e47-a438-30328ae64779", "6444dcea-c708-4530-9d2d-232fcbc50633", "6f950f92-47ff-4ddb-930e-21dc669b5a03", "c2ce7c52-7cf7-4119-8f64-032187212523", "88de74a9-caa7-41a6-acb9-b0f14e0ed7d7", "bf0ec803-bff8-4fdd-a4ca-3538cafc356f", "686b03ab-70bb-429b-8d44-d424fefb7c67", "22496963-c3cb-4862-9f0b-1fe966848a5d", "cb51740e-e8a1-4c57-a871-aee89c774c85", "aca14484-b9db-427d-ba59-9993f6cce0f3", "2a3fb042-e61e-4cfb-b057-88c550d50988", "da56cccc-2bea-4768-8250-b36246416785", "e280d9a0-0a5a-41c6-a5ca-eb2e8972f2db", "01c47f2a-a1f1-4616-83c6-ec0fb4db2179", "9c36a244-cc03-41e5-8673-1b2ba7311e92", "35105674-9e76-4f82-833f-80ecdddd75f7", "67c5803b-8cba-421c-8449-d0838698e7ae", "cd79b74d-d00f-4c27-b11a-7b3847109b4a", "dcb5fb76-14d0-476b-97c5-d4708a8dad4a", "ed1c198a-a7ca-43e0-862c-a4c7e752fa89", "59eb2e06-f1e1-4ac3-b80f-cf52bceda9a6", "2cb340ec-7a0a-489c-8839-ac278053d120", "a5a81eca-ac97-458c-b358-d783f1c3312d", "19ca01b1-6f58-4728-87b5-6943dfa7c727", "c701bc5b-185c-4ba3-9888-fd83cc4ba487", "130c92ef-e69f-4377-b704-424018681566", "4e2cecbd-0358-46d8-8b2f-bf9219036913", "82af1557-e069-49ae-bb1c-39435e9f00d5", "2fa30afc-b0e1-4854-8dfd-77d05249d86f", "a30de74e-e646-4077-bf63-53cb6290d3d5", "55083392-a9aa-4796-a0a8-1891632c1ed9", "eaaf5dc4-4dd6-4777-b169-68bff69bf2d1", "338753a6-aa61-4edd-84ef-a88828170e6e", "f7a824d0-2277-4083-b89e-795153a4c489", "360d7fc7-f58d-4cb8-874d-e87e393dea73", "90f09988-290a-473d-a99b-1037d2b67520", "22714739-1ef0-4798-810e-82f79b3feca7", "1ddc0ff5-2186-4b87-88a0-52849aa73e92", "7ade0e6f-0c37-4145-85b1-0789a13f21f7", "4a410f7e-fd45-47e7-a87b-5fc9bff48df6", "c63a68a3-d998-4ee7-af61-6bcb5e53ab74", "4f5f404e-c195-478d-95eb-07d3e13673e1", "95d231b3-b165-48d9-b311-4e17bbff18e5", "4fcb5bd0-6daa-4a71-8845-4b4fea16070c", "1df95d59-b2ee-4a6b-9444-44c468f6b198", "7d6393e3-faa8-40de-8bce-bd7fb99a8342", "7d14db31-94bb-4152-bdb3-616e816587fa", "11accb39-cd89-4687-8fb4-ea5bb91de766", "905b7137-aaa7-4c69-8f04-376caa0ba25f", "096fba12-75c4-4820-ad30-f526f27a4b9b", "75461e90-a1fe-4582-ae21-55b040fb884c", "46ef9c6c-7aa1-43cc-a57b-1da066a2d134", "9dda4634-0594-4a53-8b39-a78fcb827ffc", "c5fbe5b1-d5da-4769-850b-3babab7c10db", "2fc3bf49-5958-44aa-99f8-8acd981c2ac4", "8942b9bc-724f-49b0-8138-13d142f3feb8", "08de803a-98e6-4b38-9022-07c1dbd118aa", "585a4373-4cc9-41e3-8d33-9641cecf44f8", "e1e3c140-a670-4810-b39f-6dd236233009", "7ad45b4c-3408-4485-9150-a7a7d1b185ee", "e33dd020-53f9-41b0-be9d-ab6b01dcc728", "470e2ce7-18db-42e0-a851-42971fc120a6", "a8205fb5-3aec-4806-a0bd-e73ae8068fe0", "98ccc000-2938-4df0-a1a1-5f494889d456", "34765d87-3450-479c-85a2-b889b6002968", "2bbb3ca2-5d94-4a20-9322-96f471a966cf", "acf05399-5715-46b2-91f2-8a73866e10ef", "9e60ac1e-2bd1-4861-9bde-7b805dd113eb", "2c374338-aff8-4340-9989-461cd3772603", "afd7222d-103e-4394-b970-a3c18b4a5605", "1a055c74-cb31-4a2a-be35-478b80bc440a", "db66b242-0707-40a3-9ab8-20fb3b7a0503", "5cc01fda-462a-4658-ab49-f0730ad71f27", "3b4a8070-947a-435b-9ead-04d4dd6aab58", "21b7a125-5e6b-4d45-ae1f-2cd19d09209a", "27a407f7-fb20-417e-8c24-85060c31d721", "238f6e68-b9ae-4bd3-8c78-85b3949f9122", "749a0e77-ade1-443e-b149-fe68ec0b68d7", "cb254eb2-33eb-4522-8532-554e38dd156c", "192ff4e3-6ece-4cb3-a6d7-ce2f40203bfb", "53153f7c-e5ae-4e9a-98dc-471e679933e4", "a8108559-f5f7-4b72-8cca-9ee4607b6b5a", "9abd33f9-e15a-40b1-88d6-11bae333f56a", "e533d7a1-eac8-4b65-a0a5-a6c8fe76fc53", "96664a2f-c869-47ec-8c84-1bd6863f7f1d", "5fb631e2-974e-4e8a-b028-db46062cda98", "04102463-f094-42ee-afb1-96d4d77f8e27", "9b27d44a-be18-44da-a473-6088b9d5de91", "5e50fe11-6130-43e7-8024-d917ecfcf59f", "c768ba46-27d0-4b6a-8e27-9cdd8abb1e60", "df34c738-7989-48e0-a326-a69724d76c85", "c8f15898-4e03-4ef7-9153-4eca7d45994b", "ed18ea18-8c89-4647-9698-2bbacf3b418e", "9b10b181-e696-478f-bba8-65e1512d9e2d", "96eb6e4e-7e41-4bd8-a54d-64978ab74e6b", "e4e204ba-f69c-431b-9b17-8e21afe443cb", "999c0f05-0c2b-4984-9124-7dbfda9b86f6", "168b9c05-e7de-4a5a-b3f2-aed96acb1998", "ad0811b8-4c65-4397-b1c5-1d7f2ba8be04", "6dcc486f-837f-4ee3-acb4-d2944d99d7cf", "f3375fb2-130c-4acc-884b-b8450f77355a", "96f32a2e-3ab9-42aa-889e-64099d03cea9", "7f706f29-d30f-41bb-9478-08833679dacd", "e4832e7c-8f15-4bc8-ae93-d33ff7d0cfc5", "e62583b0-f0d9-49b1-b704-bee5b88b2e91", "4ef04176-c2a4-452b-962c-c378ef3bbbcb", "acc3a559-70a7-4eed-9406-50d986e7e19a", "87e75afc-8069-40f0-a37d-b9aac3f8c281", "11e32d85-68f1-41b2-9dec-8054d5146547", "17d75778-1247-4631-bd0f-319f0ee3f7c3", "0eea75ec-3e05-4f76-8dae-8664f16e6830", "fc141463-fae4-476a-be7d-73f4dccf807b", "64c117fe-f2ca-41d3-b8dd-52609c6c65e6", "281304a4-4ea0-438b-9955-15e6625d0f5c", "5bde89bf-7c70-4d25-afcd-527765ec4113", "9183f831-862b-4073-9074-62ed11c27564", "83b2f2c4-4a02-4e15-934f-41c8d013c6af", "7f2d0e50-7ccd-4e21-909a-46903e008260", "4d06838a-aa0a-457c-b19b-107cf8fa4841", "25c8c7a3-4c74-4f2f-9af9-3fdfe59cb492", "ae2b4d2e-77ee-4568-8d22-7bc4a42a98db", "8916a554-80a3-436e-8a5c-d43781b23a5b", "657a1771-105a-4996-bdc1-81314727d1df", "fd5f37ce-6dc8-46d9-aa2a-227b313b411d", "56071c9c-7b12-4005-89a8-fede6b09e692", "fa3a8e1d-9c6e-4fbc-ae2f-e341a990579b", "03ea9e79-eb86-4c7a-87db-ddd7d8a95b80", "2bc3cdef-0830-43a1-83db-8f548a4aaa81", "100bb1e2-1a6a-4712-bdfc-07694f518a1f", "2e244c12-8eff-4d05-b84d-7cfe7ffc3df8", "8b7e8d6f-28d6-4550-8817-61ba1977a7eb", "6e9ef3fe-735a-48e0-92f9-e9e14ea81ab6", "65c24837-ffd9-4243-af83-1eeb87f7e04b", "c84adff4-0f77-45c2-9f07-1c799e1b91c6", "2115b772-8509-4d77-8f9d-9282082ac41f", "7c5ab1e9-f70a-472b-af4f-c3ce8399578e", "ff15a545-95a9-491e-8fbe-1c0f1435a9e5", "9495b846-9914-4797-8427-651d38d839f4", "9d1cf90b-dfaa-421d-8087-62572f888b26", "71e2e835-a40d-4238-bdd5-3825f506e252", "57cf0d00-5651-4a1a-833e-77281d3f812f", "d4169122-5b86-4624-8283-0e7a93f50124", "ddeb8977-929d-491a-93b4-eb9dc1001373", "ba498d18-3a2f-4d6a-9e14-2c1ad7ebb655", "b35277f4-aafb-4163-b251-f09441c86327", "81663b14-04a6-46e5-9c43-4d479f62bf91", "bea6263b-747d-4a7b-8e69-f9fe68c53e9f", "546e0c0e-6877-4a50-a9e0-577e6af9fe13", "a13cecf5-a466-4976-a0c7-bb95b78f9a56", "3fa962bb-5545-4c5e-b344-89d929ce07e4", "3757b948-93a9-4fd0-b2c3-676754f23664", "c7bb4ec6-4f38-4ac2-8a6c-b3d742e0ff75", "9ffb9523-808d-45b5-be30-0fcd56148e7b", "683129e2-08b9-4b10-84ba-2eb021a15378", "210b47bc-7094-4519-a2f7-6278801c87c0", "40017e6a-f269-45d2-80ca-66a430022027", "33c66e75-86b4-4636-97ba-3268898e44d9", "8ca962dc-dedd-4e3f-a8c0-c8d389e84298", "a1d0213e-d38f-4b4a-aea1-9aa41277b3c1", "9dc4dd20-e23a-49f8-b57b-97c4a8ff19cb", "643dbdfd-6cfe-4ed0-a892-780a3b985eb7", "3cd98c10-1fd6-46eb-a3e1-72d52c1814f3", "e904659e-e60c-4692-a9ae-9d4e71b927a1", "1a808038-9f0c-4b12-9c72-12393769d7be", "a136d892-c327-4dec-90db-51241861a6f3", "4849393f-ea79-483e-9afc-f52509a9a5b6", "1832f8df-fcd5-4133-a245-f54f51a3e6f0", "9b40513b-344e-41f3-a282-0d8fb50f2d98", "8527d035-deba-4ca2-b6e4-799dc328ff13", "27673371-4df1-4858-beba-f8f3f275d7d1", "5e195af6-959f-48bf-9c02-0ea2f0d2ec7a", "0024d872-b833-4e4f-affd-91246c7c4def", "38b1bb0e-3206-4cee-9253-9de30a59a97c", "8167dce3-dbed-4fd3-92cc-d7c82873d052", "d85ff2c0-b1df-4576-bbc7-2d0c571149e9", "d87bea31-b41f-47b2-a169-57a99ae23454", "fdf686f2-910a-4d24-b978-7dbecb560c30", "7da223b6-cb70-4999-aef0-59f2825b1ff3", "d8915676-45ef-408c-8bec-f06b0ce7ab95", "1b293cae-24eb-4a25-a5f4-15f93546f2b7", "b275dc52-6c6a-44c9-9c56-1dafb2bd36ee", "731e143c-8837-4cef-85ec-9b5cbec72510", "404162c3-2736-4fe6-b571-41b7751a7fff", "eb48d6dd-d417-496d-8f2c-2a44c91bb67e", "dcb7d909-bab1-461b-aff3-488736260ea2", "8391ed98-00ee-451e-9a03-b801190d5456", "61ffb61d-ad1b-42d9-be24-10c966579ce2", "29516556-776c-4ce8-82fa-7cba9f49be79", "4c2a4489-d811-4b67-a762-865abadd57f9", "0e095c44-0846-43f0-8856-1eca7aacb70b", "d761b3af-3655-48d5-87c0-779853445479", "ffc66e9d-80e1-4b4f-adb3-6c7a0c57d752", "d3ebdc93-a33e-4c04-886b-52c491e5f78f", "6f23de83-87cf-4dd2-a932-ace03c8c56d9", "a1f5496c-c780-4073-b394-ace49f9964ef", "10211d91-9ae7-404c-946e-cf40ea3aef94", "18a08a9b-7b9f-4b09-ac5c-af5fa10ff3cf", "fd13fe4b-ecd3-4a3a-9590-5036fd87c338", "f137b538-04d9-4b12-a449-9fa9d9a1193e", "758e590b-5a22-47d9-94c5-0738db8f6d43", "71a7ba79-fafd-4a22-9eee-b6f0135aef1c", "ec50e8ee-346b-4904-817e-cce8a8829bf9", "57961b04-9358-4554-ae3f-3a8dea55ec6c", "50eb6a2b-3299-475d-a63d-2273ddf245b2", "29107840-2bf5-43c6-b33d-17a520f61d7a", "ed4a7b55-44a6-4d88-b9ee-e278d300be71", "0e0a4085-51c9-47bd-b355-1ec9d825c61a", "dd481b27-c04c-491e-a3a6-28665f177ee5", "28fb0d26-ed06-4898-a099-44b4f9af5054", "6af41214-d677-42ad-9247-e888244059cb", "24029408-8ced-4525-a4ad-b40c9aad9fd0", "fcb0185f-dbf8-40ba-924b-8fae181b073c", "5e4149ba-612a-4888-8e4f-e9aca4be2611", "08eb9bca-53e5-4359-baf9-7ad3e9d8e3f9", "aab111d3-5a77-454b-bde9-9126ccfb096c", "717f6a15-fd93-4b21-9a10-f3da311ccf80", "d87f29a6-ddb6-4a34-ab86-2fe9a317e63b", "d5696b51-3619-4906-bc37-9abd85ea5a53", "ba664613-e34d-4d2f-8d7d-219b4dde655b", "362b25b1-ae2a-42ba-bf01-b0d30f39b0b3", "ddfc4157-b6ba-4b22-88a4-369b0145eea9", "31dafcb9-20a3-46f5-b892-4741dcdf3ddf", "cf73f85d-e095-4d93-8ac1-15a099abce90", "5cb38e66-60a6-46c9-ad6d-f68a7327f624", "436560a5-e974-4910-9c44-d0a2d5034950", "b20d81a9-d671-4b73-a2a8-26c234f21e1f", "b610ebb2-8deb-49db-977f-535a81c03e5e", "85d3c9dc-5542-40d2-af57-996131303f4c", "7e89e79f-4550-4a1c-bd33-f56d6a21777a", "91b4f30c-c6ae-44e1-9fd5-bbe750f6a465", "5ccfaa56-c362-4bf0-acae-05bdc9761d1e", "7bcdaf01-e30a-45ea-a9e5-b82d9558bf04", "5c2ae046-771d-412c-bda0-3393a696a5c6", "a94527e4-4014-4265-9f2d-c50204060837", "9a8ef49c-f904-4312-976d-e2b295402e11", "2f7d3508-4e64-4f90-88ba-a547657a7fb3", "9aea6539-0d3c-474f-89ca-f26119fdefae", "e96294ca-271a-4eb2-b996-1033f856b4af", "aff623f3-f1f2-4b01-b89e-b0252c199668", "d95a7860-9d26-4dc2-a297-cf7368e8d370", "9b20ef12-ea90-4f6d-898f-f090f2d683ec", "d6e2a5f2-13e6-4a45-a193-9680a8b3f024", "2cfa4121-8687-4330-ae60-7acd5c90c175", "c3470aa7-69fc-4ca9-a6b5-69d9015cbabf", "6c826fd3-fe51-4d34-9d6e-d3be471307f1", "a1579f83-abc5-4e54-ae01-4f2b4e50bff2", "85011d4b-a961-44a2-9bc6-c16b28b4fa74", "0742ec95-a573-461b-aaec-d8cc5a6cfa82", "5d8e209c-8ad4-41cd-b7fd-5c06aac5ee81", "b42f59fd-091c-4579-9792-51645c108dd7", "9e5d968f-e9bb-4018-84b7-5cc22b9acf9d", "1068d22a-9227-4c98-b10a-60b728b278c4", "a456d989-0671-4f8b-b2e0-f59f3dbfda16", "3025ae38-324e-4b42-8ac6-cbbd067deb63", "42461474-7491-4d56-9021-ccd0ebb6d537", "03a96b86-71c1-439a-b005-0fabbb0c29bb", "b87de440-03fc-439a-b84e-86aea492da7b", "3feced31-14f1-4a7a-b2d5-36c9ad3a36db", "be4607c6-9c12-4dad-b226-ec6a1ff03a17", "13a6febd-9565-42bf-bcbc-9fb6623c8637", "71765722-539b-42f2-8781-889529263c05", "3f0eaee1-af63-4bb1-8f56-7c949fc4286c", "e7f97ad7-75c0-493f-9152-2122c7224606", "9a792f79-dbaf-4fcb-925a-26a7bc0f88ce", "d292bce9-817f-4945-ab26-222dd5544c0a", "b62a9260-a482-44a9-9c36-96ae2fb536cd", "40c285f1-c60f-4ae5-93ff-5a1c3eaa38e0", "0d69bb94-5121-4932-a3f3-4835db45f0f3", "e7b06f7a-090d-493f-b4ee-b5e1ae15f3c0", "ad7cad6b-46db-4336-a5d0-cf4bca1889ca", "b75352c8-a8bb-484d-81af-d1b615d9e5d4", "2a0b1413-c297-4845-8f50-887220c6f48e", "1854b75e-1faf-4491-95b4-6cc73bf2dfd4", "278211b7-2d8c-41c8-bf27-316ca001f527", "78234772-c54f-414e-a047-40a991152d53", "c001f618-7031-4d55-a2e7-bf9ce23f658c", "fa4f03f8-a7af-43e8-91c4-b4e0c879a814", "25ddc4eb-6ecd-4ad4-9378-44b79b47661f", "4cf04562-8f51-4a87-9a36-5ace5410436b", "8609a38c-b9b3-483a-b596-d0c11beb5551", "0b422f79-ce42-4436-b3e0-0efbb204de9c", "981098bb-eef9-4fbf-a02a-b45b14c6e7c6", "9724efee-9716-4bc6-af76-98cda7acbeed", "8d8a1f93-c17f-4b3b-9b54-9a020282838f", "bb850212-4186-4087-9aaf-7f2c79b9f1f3", "a7c4082a-a126-44e6-bd05-abf0284e4f63", "0e2bee3e-830a-4f39-a9c9-0e43a3ea562e", "c503baab-8e2d-433b-980c-37079534d9fe", "2944fa4d-855d-4953-9eef-5c38053be67e", "0d801766-8ee2-4561-ba6a-241ece43bc84", "e11ba821-b3bf-4744-a088-c7a79d6032e2", "aa904af0-41f2-4d28-9e10-1a0a286a90e5", "c88d4d0b-79cd-4c30-a93e-d74aec5d7810", "05af1732-21c9-4b11-810f-17f8b32c4509", "a4129773-b553-450a-b270-48acb3e0e609", "ef08a95c-ec0c-4f73-88d5-243a16ceb8bc", "d7b73331-45b9-42f0-b0cb-99336330ea1d", "2cdab69f-f41b-4253-b20e-3befb4a6bda7", "7908bb46-3f91-4f90-a6e7-49a2221d2055", "363fcfb7-4786-4de2-b2ab-89a98620a6b2", "f57a25b1-d70a-4107-ba24-a04b31ed45f7", "826e1233-b776-4ded-87fd-851c0552ab1d", "418f078d-d7f6-461c-9b9a-f67cf581cebe", "8a70e728-d913-4271-867a-3ba32ba5f3bd", "0a3378e0-8042-4a79-8c32-9fcd4a609d7f", "0585fee7-2d2c-4630-a9ae-be6659344b91", "b8674ab9-13b1-4abe-b2a8-c99fe6f4ea73", "87279993-ca14-4b2b-8e7a-a013724a1b94", "d1441a6e-252b-4a41-b843-50e0f3bd062f", "052affed-9bad-4a95-9d16-e0320f67c43d", "814d44f0-c7d7-46de-8c0d-0cc3f3d7cc3e", "edde0b2f-02da-4b61-b3a1-d348823cf101", "179d8a33-a284-4718-be66-78d7af07c644", "bbebbddc-2ed2-45d0-99a7-0640874e85a2", "ac2bffca-da33-49d4-91b7-92596e979138", "55754304-bcbe-4e76-9cf2-940fcd16f611", "116d199e-4d69-4bb0-a0e1-e638c84e0e16", "5e3d7301-bc24-414b-a172-8bb1c98ba632", "ea06dfe6-3024-47a9-b42c-5ffa407255c6", "1e06d94e-ea09-4ae9-ba40-4d8dabe22721", "a4634d29-0704-4b39-b474-82c80c9f1869", "19a53f73-b11e-46ea-9841-6045e4686021", "3ee8d4fd-0d8d-4d18-b0dc-5c7bc9409e39", "0031de93-b481-40f7-b3b9-7ab1d6b9b19d", "1f9cdd27-0a10-4503-bc43-02dd47723cad", "738c3606-b3fd-41d1-b6b2-22bd25b1dcc4", "31cd402e-372b-489e-80aa-160a07fc3d1a", "2f918556-7c48-438d-b25e-ab9fc4ccd98e", "a7b99c9c-8ebd-43e1-877a-df3dd25fd951", "cfe051f1-a6a6-45b6-93f0-3d19bd8bf0f7", "8f4933db-2e33-4ec0-bafd-6f16126e2e66", "29155992-b3da-4b80-9b9b-ce9b61a402e7", "a57ef517-064e-4ce7-aeb6-0c8b2a5e0239", "4a357617-06d5-4c3c-83df-ee4980264dc1", "cb2e7194-1a33-4487-9872-5da78a79d5d1", "2184b767-f43e-47f1-a833-febe4e6bf134", "8332ea64-2f88-481d-b28c-bb63331070c1", "b6441abf-d574-4d5e-9c3a-adc3042d5e65", "dfb4e10a-4700-4940-ba7c-ba2be17b0770", "ff30c03e-8e04-4adb-b67a-152e29242a6c", "6fd9564b-551c-4d8f-952c-d1d4fd208214", "06bcccdc-bb7d-4f35-ad87-e46d77d8eba0", "eb31aadb-e3da-4c00-8eb3-fa3591317426", "582f2e27-ae44-45a7-8546-e2a0a15d5d8b", "3f2dde09-9003-4df4-aee2-156d94662d33", "42f2cd88-9c2c-4f03-aac4-547373275ce9", "8aa42ac4-0f80-4350-a0f0-2258a3de4a7f", "2c40f651-abe8-415e-84a2-33daf2d4143c", "80d30081-2dcc-4dfd-8e12-4adb36a7c2b1", "c95c8429-7190-480a-96cc-5b2ef8a196c0", "be90c87c-7f20-424e-90fc-376920aeb72c", "00a98829-b011-4567-8ce2-ad6343d89dbf", "fe5c83f0-d7ae-46c0-8331-c20472872894", "96b22698-fad4-44ac-857b-96b268f674b5", "409ac874-db56-4595-8e2b-3b30bd458cda", "6e0c28b6-a032-4435-b6f1-a6bd8d31aa58", "c4245eef-9049-4d32-8165-c2b9470186b4", "9d0f09ce-7f75-4b77-8bba-45919deb553b", "6a66994f-4d49-405c-a29c-a9d5f871913c", "38624caa-3343-41bb-9b59-1701438b4e39", "e5c01dda-7094-44b3-9da5-abe2ec0aa7f2", "e15971d5-d03f-44cf-9bb7-77e06e78fd61", "301868e2-73d9-4ebd-95d2-ab13bd73be75", "ea876c21-1193-4daf-b17c-d5ec43f481ae", "87adc65f-05b4-4387-83df-33ad9c68108e", "c8a4ae60-4e1c-474f-b2d9-dfdce19e50c7", "6c2e8c1a-3510-416a-aa59-abfd57c1fc9f", "e58ea5b0-30f0-4ae6-863f-d7b0c9bfc306", "30b46570-c0ab-48cd-a15b-8f18a3023c6e", "0c6c2b56-2b1b-4023-a2e2-4e60bc1ead9e", "6161a539-ad9c-4ee2-8740-d6602bb43990", "e31e278c-d1d2-4198-97fe-74ddc7835c9d", "b666e30d-dbf0-46aa-bdd8-26d5defda016", "de91eca8-1f38-4e8e-8123-00f4dffb6e6b", "716d466a-d6d8-4d2d-abb5-ed754f4de062", "e0fe5a01-0595-4b25-bcf6-8fd87515d906", "610baafe-749c-4f5b-a6aa-66a8ca91c7d9", "0e6a003c-c742-4e00-a6be-c4801b3bdcc5", "bda6cfaf-92ba-44cd-9f23-88e29eeda142", "6602c357-9540-41f8-9795-01c5ca99552d", "92498833-a69e-4641-a86b-ab83b59056b6", "699dd142-9901-4c19-bd5b-b35aac5e1531", "4ce97d59-9318-4c6d-aef8-5f84a22fb1a4", "c4272f47-f0cc-48fa-b821-a7dfc044a0a9", "99f4b3e1-a4f4-4143-bad9-d1d808fa7175", "4f32ca98-23a4-4377-8530-b48a9339975b", "704c5ee7-4817-491e-ac00-1af9edb0e4aa", "fb215f6d-b4b7-47c6-80f7-fa7606a75733", "9eeba003-de7d-4c29-b4f2-25528ad56275", "23a834ad-1264-4b70-a59a-6eb9fd92b097", "39935019-4023-4996-8ba6-1c8a8deec6d3", "33254742-f72c-4234-81e2-91cc47b223d7", "d57f150c-2208-4866-ae1b-14305e248f65", "e8241460-99c3-47e9-9f64-59c4cdd5832e", "318c3cde-77a5-46b3-bedd-faa580a33da4", "b5bd7d32-8f7f-4f09-8b49-fceebd38c860", "1b1a3d3d-5c52-40ae-a4f9-b489a54ddf4e", "18ebeeb0-c2c1-4f2e-84ef-8e0b4304213e", "62461ea1-aa58-4ead-bf7e-38c3a99fbb97", "2c0f4fc8-10f1-4944-800b-dc624cef2c9f", "c09c3d44-1be5-484c-9259-896c3446fdc6", "301fd21b-2537-4c8c-bacd-8ffbac02c176", "3b94e476-ea17-4c7d-b7be-3cf188c9f020", "db6a2667-cd4b-4de2-9c73-f827241a1433", "7b6f05a9-b267-4aef-915f-e4e46339863a", "ecd926ac-f872-41fa-943e-baf9d6ffa683", "343413bd-0f8e-402c-83c4-c7a61d6f5022", "e662e19a-b809-472e-83d9-fadf8eb23e22", "ddd0533f-4d6f-4b40-8c8e-06aad0b26729", "9da7d8dd-a5c2-41e7-91fd-c45ff98c7b56", "bb37f5af-3a6a-49fe-8ba2-c2cb54a9b40d", "ec7edc44-8306-437c-9761-22cb6d782ced", "69d531e3-c4bd-47e5-a5e4-45ce031b5a52", "b491f6ec-c51c-48dd-bf90-c4285ad5bb24", "8c830307-442a-4d3f-8518-19e377dcaabf", "03c5ef62-ab3c-4f85-b9bf-0c7215985ac1", "7c5184c0-325c-4446-9858-838d5a636993", "945fa7e9-37ce-49d2-b044-2ec172bdbc64", "ce85fb12-c6a2-495d-bdc7-90438d4e86ec", "ad360a28-2882-41e6-b363-7c06d8bc0e9a", "c6a5dd39-9381-4829-857f-05a6ce2eff2c", "f4cb8c68-0c5e-45d7-b933-3a96b08c4f29", "dbccd467-cb3e-45fb-b8a1-62ccf849d933", "dd4c30fd-bab0-471d-b0b3-04b8ca553aa4", "89bb0b3f-288d-4843-890a-e3e65abaccd5", "39ccdc42-9477-44a4-b4b8-d9cede84314d", "cd5e87ef-855d-4dd2-baaf-f466a5c8f6ec", "22eaea98-2ef8-4385-b893-7ffa4582c19d", "18b040d1-02d1-4581-a0b9-91d390c92109", "7b6d014d-c532-4647-9350-96def4925efe", "e873e8c9-399d-4443-b06f-f882a35f7d1c", "e9ff621c-e2eb-49dc-9dc2-2a277fbade30", "156d97e3-ce98-419c-8505-975d5e2bd61a", "584584aa-5565-408f-a4d5-c55faea49732", "3f4d0360-f30c-4fb8-842f-be8d521262e2", "0764d31f-4fe2-4a66-bfe5-ff3aa150d2b8", "d7068396-4c09-4337-8426-002717e9737a", "c6885a3e-29ff-486f-b06e-9139dce5c533", "13883e49-d4bf-4844-9ac2-3ada0487ca28", "60f1423f-82db-4c2f-b9f3-02e4cdf08c1d", "b7d42f41-0545-4504-9ac8-bb50b3841d24", "93f5d1aa-f126-4880-93e1-c70729984fe9", "9b99c536-8bf3-4bb1-bb08-81dd7f81a440", "1895c57d-0027-43af-be92-7f4bbdffd460", "04b622a7-073a-434b-bbd5-ab949915012b", "1994563d-ae5a-4047-a525-17510f4de97f", "fc7b26da-4ef0-444b-97cb-2e4e013a816c", "a00f05f9-355c-4121-8dab-bbdff524518e", "f33304f6-01f8-4750-b78f-e65583b17438", "16e958e9-6e74-4331-9986-c5a59d0b612c", "144aea52-dccf-4950-ad77-b28949db4b03", "96101319-5f76-4052-b361-d2966fb7fe0e", "131a694b-f269-449e-9d51-dc3e68c32971", "114e7916-a391-46cf-9f33-ca3e9f21c476", "2aa194c7-cbf9-4543-b32a-0465e69af259", "06a9375e-686d-4938-936b-01084edc7b88", "3d7b892f-11b9-4ba4-b71f-980ca9b7c99a", "778b46dc-7e6a-4fdc-897d-085e54fc2cef", "0bc868de-49dc-44bb-bc86-95e6e03ce24c", "83cac814-a32f-4ef9-93f9-514c40403b2f", "76e44ce9-23db-4a3c-bd4f-1783aee6042f", "7a590fa2-8cc0-4b6a-b932-0cb1da7dc52d", "603b65f3-ad11-4cc5-a42e-6a65a7759c8a", "a82f46f7-2b71-4e3f-8953-9723bad9ee3a", "fc5ddfb1-a8f2-4e1a-8283-8625bb07902e", "1c7eab56-3747-4b7c-8f15-6dd3ef965227", "50cf6ca3-55ba-48dd-a89b-5a39d8aed9a5", "10f632a9-6683-4d18-8140-1b2a2babcd19", "cf3e27ab-78d7-400e-b5bb-3b76538f9737", "5d01bac4-ab37-4172-9a26-7a88ab926f75", "6c21240c-9f22-43ba-8351-cdc428bb9db7", "d57482fa-4867-4e8b-a887-89a1144858c6", "20c30fd8-6a76-4886-a4de-de97a4a9d90d", "39ddf429-be05-47f6-9254-e5031f5ddfa0", "cab96ccd-ceda-4937-8f92-5763b4c8a5c7", "1c2fe0a5-2ec1-42d8-9bb6-13a948a79538", "d9718bb3-6a49-46c3-aaec-5d6b64cf486f", "1e14e335-28ec-4e8a-81c1-f81065d39227", "0fce7818-36d8-4641-af69-611bea3ea1b4", "f365573c-743a-4d61-9265-7e6ddbfb8afd", "1af23bc0-73ce-4020-b761-8237e84d9ef4", "1fe53da9-3851-4498-a058-8efa68bfb688", "b5b7955c-d9fa-492f-b223-22f4515bf5dd", "b5428440-e491-47f6-83f3-bf28e9393d09", "91f789f1-52cf-4b7b-8813-1bb32e2aade3", "3680adf0-3107-4e4d-92f3-cb6e1974e150", "d464eeae-ed59-4cf3-bb39-412f2207a2e0", "fcb58d6e-76a7-4339-a4f3-fbb4bda5f953", "c47830cf-5f41-44a8-96de-3225f00bc345", "06193a1d-e19f-4d7d-8549-e730b78e28be", "e5355f4d-cfa9-4eb9-abd5-6a24fd55aa98", "ca9acbb1-5468-406e-8a33-7319dde01d6b", "de24e18f-e50b-4bb2-a9d8-20657317d580", "1449fa66-f198-4207-8d0e-6bd32c08bffb", "fad80e03-96f6-44e9-9ec4-77f3f51e5ada", "9831867d-c656-42dc-b517-c50d84486ea8", "95859364-c274-46e4-a404-23805cab18e3", "98c6ff7e-a235-431a-92c5-1b0b1b6c5c15", "ec1d6025-4278-4b50-968c-4845047e89ef", "ec66e3e9-cc89-4462-b020-bbda40bda188"], "metadata": {}}}}